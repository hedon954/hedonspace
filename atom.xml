<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HedonWang</title>
  
  <subtitle>君子求诸己，律己则安。</subtitle>
  <link href="https://hedon.top/atom.xml" rel="self"/>
  
  <link href="https://hedon.top/"/>
  <updated>2025-12-18T01:09:51.601Z</updated>
  <id>https://hedon.top/</id>
  
  <author>
    <name>Hedon Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 底层原理丨主从复制带来的新问题</title>
    <link href="https://hedon.top/2025/12/17/mysql/mysql-master-slave-new-questions/"/>
    <id>https://hedon.top/2025/12/17/mysql/mysql-master-slave-new-questions/</id>
    <published>2025-12-17T13:57:00.000Z</published>
    <updated>2025-12-18T01:09:51.601Z</updated>
    
    <content type="html"><![CDATA[<p>在单机数据库模式下，我们享受了太多的理所当然：ACID事务、强一致性读写、瞬间的数据可见性。然而，一旦引入了<strong>异步主从复制</strong>，这个美好的世界就崩塌了。系统从<strong>CP (一致性)</strong> 模型滑向了 <strong>AP (可用性)</strong>模型。<strong>主从延迟（Replication Lag）</strong>像一个幽灵，让许多在单机下奉为圭臬的最佳实践，变成了分布式环境下的致命陷阱。</p><p>核心矛盾根源：真相的传播延迟</p><ul><li><strong>单机模式</strong>："真相"只有一个（唯一的 DB实例）。写入即事实，读取即真相。时间差近乎为零。</li><li><strong>主从模式</strong>："真相"在传播。主库是当前的真相，从库是几百毫秒甚至几秒前的"历史影像"。<u>依赖历史影像做决策，必然出错</u>。</li></ul><p>从单机到主从架构的升级，不是简单的加几台机器，而是一场思维方式的革命：</p><ol type="1"><li><strong>放弃对实时强一致性的幻想</strong>：在分布式系统中，除了核心的金融级数据，大部分场景都要接受<strong>最终一致性</strong>。</li><li><strong>识别真理之源</strong>：时刻清楚 Master DB是唯一的真理。Slave DB 只是用于分担非敏感读压力的快照副本。</li><li><strong>防御性编程</strong>：写代码时，永远要假设你读到的数据可能是旧的，并思考"如果它是旧的，我的业务逻辑会不会炸？"如果会炸，就必须升级方案（走主库、加异步校验链等）。</li></ol><p>本篇接下来就梳理单机模式最佳实践在主从架构下失效的经典场景。</p><h2 id="缓存一致性">1. 缓存一致性</h2><p>在单机模式下，为了应对 MySQL 和Redis（缓存）的一致性，业界通用的解决方案是 CacheAside（旁路缓存）。即：先更新 DB，再删缓存。下次读请求发现 CacheMiss，查 DB 并回填。因 DB 里的数据永远是最新的，回填缓存没问题。</p><p>但是在主从模式下就不一样了：</p><blockquote><p>写请求删了缓存。读请求去<strong>从库</strong>查到了旧数据（因为延迟）。读请求把<strong>旧数据</strong>当作新数据塞回了Redis。结果就导致了 Redis 里存储了脏数据。</p></blockquote><h2 id="总结">总结</h2><table><colgroup><col style="width: 9%" /><col style="width: 21%" /><col style="width: 33%" /><col style="width: 36%" /></colgroup><thead><tr><th><strong>核心场景</strong></th><th><strong>单机模式下的最佳实践 (Best Practice)</strong></th><th><strong>主从模式下的失效原因 (The Trap)</strong></th><th><strong>必须升级的分布式方案 (The Upgrade Path)</strong></th></tr></thead><tbody><tr><td><strong>缓存一致性</strong> (Cache-Aside)</td><td><strong>先写 DB，再删缓存</strong>依赖读操作回填缓存。简单高效，极少出现不一致。</td><td><strong>脏数据回填死结</strong>写完主库删缓存后，读请求立刻打到延迟的从库，读到旧数据并永久回填入缓存。（即我们刚深入讨论的案例）。</td><td><strong>方案 A (标准)：Binlog异步消息队列删除</strong>（引入异步重试机制兜底）。 <br><strong>方案 B(极强)：回填前强制校验主库版本号</strong>（牺牲主库性能换取强一致）。</td></tr><tr><td><strong>读己之写</strong> (Read-Your-Own-Write)</td><td><strong>写完直接读</strong>用户修改资料后，立刻刷新页面调用查询接口，能马上看到更新后的信息。</td><td><strong>用户体验崩塌</strong>刚写完主库，转头读了从库。用户发现自己刚改的数据没生效，产生恐慌或重复提交。</td><td><strong>方案 A (折中)：短期强制路由</strong>（写操作后的 N秒内，该用户的读请求强制走主库）。 <strong>方案 B(复杂)：客户端版本追踪</strong>（客户端记住自己刚修改的版本号，请求时带上，中间件判断从库是否追上）。</td></tr><tr><td><strong>唯一性检查 / 业务前置校验</strong> (Business Check)</td><td><strong>先查后写 (Check-Then-Act)</strong>例如注册时：<code>SELECT count(*) FROM user WHERE email=?</code>，若为 0则 INSERT。</td><td><strong>并发重复与校验失效</strong>两个请求同时发到不同从库查询，都以为 email 不存在，然后同时向主库发起INSERT。虽然主库唯一索引能挡住，但业务层的校验逻辑彻底失效，引发大量报错。</td><td><strong>方案A：强制查主库</strong>（所有涉及状态决策的前置查询，必须走主库）。<br><strong>方案 B：分布式锁</strong>（在查 DB 前，先在 Redis/ZK上抢占一个 key，但这引入了新组件依赖）。</td></tr><tr><td><strong>高并发库存扣减</strong> (Inventory Deduction)</td><td><strong>悲观锁 <code>SELECT FOR UPDATE</code> 或 乐观锁<code>UPDATE ... WHERE count &gt; 0</code></strong> 依赖数据库行锁或MVCC 保证原子性扣减。</td><td><strong>从库读取导致超卖</strong>如果为了性能去从库查询“当前库存”，得到旧值（比如显示有货，实际主库已没货），然后发起扣减请求，导致判断失误。</td><td><strong>铁律：涉及钱和库存的操作，读写必须全部在主库完成。</strong>或者彻底升级架构，使用 Redis + Lua脚本做库存扣减中心，数据库只做异步落库。</td></tr><tr><td><strong>事务状态查询</strong> (Transaction Status)</td><td><strong>直接查询订单表状态</strong>支付回调后，查询订单表确认订单是否已变为“已支付”。</td><td><strong>回调“未找到订单”</strong>支付成功的回调非常快，可能在主从同步完成前就到达。此时去从库查订单状态，可能查到还是“未支付”，导致业务逻辑错误。</td><td><strong>方案：强制查主库</strong>。对于此类时效性极高的状态确认查询，绝不能走从库。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本篇将探讨主从复制带来的新问题。</summary>
    
    
    
    <category term="数据库" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://hedon.top/tags/MySQL/"/>
    
    <category term="主从复制" scheme="https://hedon.top/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 底层原理丨Online DDL</title>
    <link href="https://hedon.top/2025/12/17/mysql/mysql-online-ddl/"/>
    <id>https://hedon.top/2025/12/17/mysql/mysql-online-ddl/</id>
    <published>2025-12-17T13:57:00.000Z</published>
    <updated>2025-12-18T14:58:26.393Z</updated>
    
    <content type="html"><![CDATA[<p>要理解 MySQL 的 OnlineDDL，我们不能只看语法，必须从<strong>第一性原理</strong>出发，理解数据库在"修改结构"和"读写数据"这两个核心需求之间的矛盾与平衡。</p><p>简单来说，Online DDL的核心目标是：<strong>在修改表结构（DDL）的同时，不阻塞业务对表的读写操作（DML）。</strong></p><h2 id="宏观概述">1. 宏观概述</h2><h3 id="背景与痛点">1.1 背景与痛点</h3><p>为什么我们需要 Online DDL？</p><p>在 MySQL 5.6 之前，大多数 DDL操作（如添加索引、添加列）的本质是暴力重构。MySQL 会执行以下步骤：</p><ol type="1"><li>创建一个新的临时表（新结构）。</li><li><strong>锁住原表</strong>（禁止写入）。</li><li>将原表数据一行行复制到新表。</li><li>删除原表，重命名新表。</li></ol><p>这种方式被称为 <strong>Copy Table</strong>方式。它的痛点极其明显：在数据量大的表中，DDL可能运行数小时，期间业务无法写入，这对于高并发互联网应用是灾难性的。</p><p>为了解决这个问题，MySQL 逐步引入了 <strong>In-Place</strong> 和<strong>Instant</strong> 算法，统称为 Online DDL。</p><h3 id="从-copy-到-instant">1.2 从 Copy 到 Instant</h3><p>理解 Online DDL的关键在于理解三种算法的演进，这是一个由重到轻的过程：</p><h4 id="copymysql-5.6-之前">1.2.1 COPY（MySQL 5.6 之前）</h4><ul><li><strong>原理</strong>：在 Server 层处理，新建表 -&gt; 导数据 -&gt;删旧表。</li><li><strong>代价</strong>：极高。I/O飙升，占用双倍磁盘空间，<strong>全程锁表</strong>（无法写入）。</li></ul><h4 id="inplacemysql-5.6-引入成熟于-5.7">1.2.2 INPLACE（MySQL 5.6引入，成熟于 5.7）</h4><ul><li><strong>原理</strong>：不再通过 Server 层复制数据，而是由 InnoDB引擎内部在“原地”进行操作。</li><li><strong>关键机制</strong>：虽然叫In-Place（原地），但对于重建表的操作（如添加主键），它实际上还是在引擎内部重建了数据文件，但它引入了一个<strong>RowLog（增量日志）</strong>。</li><li><strong>并发性</strong>：允许 DML（增删改）操作。<ul><li>在 DDL 执行期间，业务产生的新数据写入 Row Log。</li><li>DDL 完成数据重组后，再重放 Row Log 中的变更应用到新表空间。</li></ul></li></ul><h4 id="instantmysql-8.0-引入并持续增强">1.2.3 INSTANT（MySQL 8.0引入并持续增强）</h4><ul><li><strong>原理</strong>：只修改数据字典（Metadata）中的元数据，完全不触碰底层数据文件（B+树）。</li><li><strong>代价</strong>：几乎为零。耗时通常在毫秒级。</li><li><strong>场景</strong>：MySQL 8.0 支持瞬间添加列，不需要重建表。</li></ul><h2 id="底层原理">2. 底层原理</h2><h3 id="inplace">2.1 INPLACE</h3><p>MySQL 5.6 引入，5.7 成熟。它的核心变革在于：<strong>将 DDL 操作下沉到InnoDB 引擎层，并引入了 Row Log 来暂存并发写入。</strong></p><p>INPLACE分为两类：需要重建表（Rebuild）和不需要重建表（No-Rebuild）。我们重点讲最复杂的<strong>Rebuild</strong>场景（例如：添加主键、删除列、修改列字符集）。</p><hr /><p><strong>第一阶段：初始化 (Prepare Phase)</strong></p><ol type="1"><li>对表加 <strong>MDL 写锁</strong>（极短时间）。</li><li>获取原表的元数据快照。</li><li><strong>降级锁</strong>：将 MDL 写锁降级为 <strong>MDL读锁</strong>。此时业务可以正常读写（SELECT/INSERT/UPDATE/DELETE）。</li></ol><hr /><p><strong>第二阶段：执行 (Execution Phase) —— 最漫长</strong></p><p>这是真正的 Online 阶段。InnoDB 引擎内部做两件事：</p><p><strong>1. 数据重组 (Rebuild Data)</strong>：</p><ul><li>InnoDB 建立一个新的临时表空间文件（<code>.ibd</code>）。</li><li>扫描原表的 B+ 树叶子节点，按顺序将数据写入新的 B+ 树中。</li></ul><p><strong>2. 增量捕获 (Row Log)</strong>：</p><ul><li>在数据重组期间，所有业务产生的DML（增删改）操作，除了修改原表数据外，还会被记录到一个专门的内存缓冲区：<strong>RowLog </strong>。如果内存存不下，会溢出写入到临时文件中。</li></ul><hr /><p><strong>第三阶段：提交 (Commit Phase)</strong></p><ol type="1"><li><strong>升级锁</strong>：再次将 MDL 读锁升级为 <strong>MDL写锁</strong>（此时业务写入再次短暂阻塞）。</li><li><strong>日志回放 (Apply Log)</strong>：将 <strong>Row Log</strong>中积累的增量变更，应用到新的表空间中。因为 Row Log通常比全量数据小得多，所以这个过程很快。</li><li><strong>文件交换</strong>：用新的 <code>.ibd</code>文件替换旧文件。</li><li><strong>释放锁</strong>。</li></ol><hr /><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251218000752138.png" /></p><p>总结：</p><ul><li><strong>核心机制</strong>：<strong>快照数据（基线） + RowLog（增量）</strong>。</li><li><strong>代价</strong>：虽然不阻塞写入，但会消耗大量 CPU 和IO（同时写原表和 Log），且若 DDL 耗时过长，Row Log 可能撑爆磁盘。</li></ul><div class="tag-plugin colorful note" color="red"><div class="title"><strong><p>注意</p></strong></div><div class="body"><p><strong>修改列的数据类型</strong>（例如从 <code>CHAR</code> 改为<code>INT</code>）通常<strong>必须使用 COPY算法</strong>。因为底层二进制存储格式变了，必须重写每一行数据，无法In-Place。</p></div></div><h3 id="instant">2.2 INSTANT</h3><p>MySQL 8.0 引入，并在 8.0.12 和 8.0.29版本中大幅增强。它的核心在于：<strong>彻底放弃修改物理数据文件，只修改数据字典（Metadata）。</strong></p><ul><li>MySQL8.0.12：仅支持追加列。原理很简单，在表定义的元数据中记录一个"列数"标记。旧数据读出来列数不够，就自动补默认值。</li><li>MySQL8.0.29：支持任意位置加列/删列。原理更加精妙，利用了<strong>行版本控制</strong>。</li></ul><p>底层原理流程：</p><ol type="1"><li><strong>加锁</strong>：加 MDL 写锁（极短，仅用于修改元数据）。</li><li><strong>修改元数据</strong>：<ul><li>在 <code>.SDI</code> (System Data Index)或数据字典中，更新表的定义。</li><li><strong>关键点</strong>：给表分配一个新的<strong><code>INSTANT_COLUMN_ID</code></strong>。</li><li>设置新列的 <strong>DefaultValue</strong>（存储在元数据中，不存磁盘行内）。</li></ul></li><li><strong>释放锁</strong>。</li></ol><p>当业务执行 <code>SELECT *</code> 时，InnoDB引擎读取磁盘上的行记录（Row）：</p><ul><li><strong>旧行（DDL之前写入的）</strong>：行头部的版本信息或列数标记表明它是"老版本"。InnoDB发现这一行缺少新列，于是从<strong>元数据</strong>中读取该列的默认值，动态拼接并返回给应用。</li><li><strong>新行（DDL之后写入的）</strong>：按照新的结构物理存储，包含新列的数据。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251218000807408.png" /></p><h2 id="风险隐患">3. 风险隐患</h2><h3 id="inplace-1">3.1 INPLACE</h3><p>虽然 INPLACE 是 "Online"，但在生产环境（特别是大表）直接执行<code>ALTER TABLE</code> 依然极其危险。</p><h4 id="mdl-锁风暴">3.1.1 MDL 锁风暴</h4><p>这是最容易被忽视的风险。</p><ul><li><strong>现象</strong>：你发起一个 OnlineDDL，理论上不锁表。但是，如果有另一个长事务（比如一个正在运行的慢查询）正在引用这张表，DDL就会挂起，等待获取 MDL 锁。</li><li><strong>连锁反应</strong>：MySQL 的锁等待队列通常是 <strong>FCFS(First Come First Served)</strong>或<strong>写锁优先级高于读锁</strong>。DDL 一旦开始等待 MDL锁，它后面进来的所有正常业务请求（SELECT/UPDATE）全都会被阻塞！瞬间导致连接池爆满，业务挂掉。</li><li><strong>对策</strong>：在执行 DDL 前，务必检查<code>information_schema.processlist</code>，确保没有长事务或慢查询在操作该表。</li></ul><blockquote><p>INSTANT 也有这个问题。</p></blockquote><h4 id="主从延迟">3.1.2 主从延迟</h4><p>这是 MySQL 主从架构的经典痛点。</p><ul><li><strong>Master</strong>：Online DDL 可以开启多线程（MySQL 8.0+ 支持parallel DDL），或者只是 Master 机器性能强，跑了 10 分钟做完了。</li><li><strong>Binlog</strong>：DDL 完成后，Master 会往 Binlog 写一句<code>ALTER TABLE ...</code>。</li><li><strong>Slave</strong>：<ul><li>Slave 的 SQL Thread 是单线程回放 DDL 的（在很多版本配置下）。</li><li>Slave 收到这个 DDL，也开始跑。Master 跑了 10 分钟，Slave 可能也要跑10 分钟（甚至更久，因为 Slave 配置通常低）。</li><li><strong>后果</strong>：在这 10 分钟内，Slave 忙着做 DDL，无法处理Master 传过来的其他 Update/Insert Binlog。</li><li><strong>Seconds_Behind_Master飙升</strong>。读写分离的业务读不到最新数据，产生逻辑错误。</li></ul></li></ul><h4 id="资源争抢与-buffer-pool-污染">3.1.3 资源争抢与 Buffer Pool污染</h4><p>Online DDL（In-Place Rebuild）本质上是一次<strong>全量的读 +全量的写</strong>。</p><ul><li><strong>Buffer Pool 污染</strong>：<ul><li>DDL 扫描原表所有数据页。如果表很大，会把 Buffer Pool里的热数据（业务正在用的数据）挤出去。</li><li>DDL 结束后，业务查询必须重新从磁盘加载数据，导致 <strong>RT(响应时间) 抖动</strong>。</li></ul></li><li><strong>IO 争抢</strong>：虽然 DDL设置了并发度，但它依然会占用大量的磁盘 IOPS 和CPU。如果是云盘或机械盘，业务正常的 CRUD 可能会因为 IO 等待而变慢。</li></ul><h4 id="apply-log-阻塞">3.1.4 Apply Log 阻塞</h4><p>MySQL 为了保证新表和旧表数据<strong>严格一致</strong>，在Switch（切换）的那一刻，必须保证 Row Log 里的数据全部回放完毕。</p><ul><li><strong>理想情况</strong>：DDL 执行期间，业务写入很少。Row Log只有几 KB。Step B 在毫秒级完成，用户无感知。</li><li><strong>糟糕情况</strong>：DDL 跑了 1 个小时（全表重组）。这 1小时内，业务疯狂写入（TPS 很高）。Row Log 积压了 500MB 甚至更多。<ul><li>到了 Commit 阶段，MySQL 获取写锁。</li><li>开始回放这 500MB 的日志。</li><li><strong>整个回放过程，业务全部被堵在外面！</strong></li><li>如果回放需要 1 分钟，你的系统就挂了 1 分钟。</li></ul></li></ul><blockquote><p><strong>第一性原理视角</strong>：这就是 <strong>追赶模型 (Catch-upModel)</strong>的固有缺陷。如果"增量产生的速度"接近"回放的速度"，或者存量太大，最后的同步阶段就会拉长阻塞窗口。</p><p>MySQL 其实做了一些优化（Iterative Apply），在 Execute阶段末尾会尝试预先回放一部分日志。但为了保证最终一致性，<strong>最后的一小截尾巴，必须在写锁保护下回放</strong>。如果这截尾巴处理不掉，阻塞就不可避免。</p></blockquote><h4 id="磁盘空间爆满">3.1.5 磁盘空间爆满</h4><p>DDL执行期间的并发写入（Insert/Update/Delete）不会直接修改正在重建的表，而是暂存在<code>innodb_online_alter_log</code>中（内存+磁盘临时文件）。该日志的大小受到<code>innodb_online_alter_log_max_size</code> 参数的硬性限制（默认仅128MB）。</p><p>如果 DDL 耗时很久，或者业务写入量很大，填满了这个 Log。<strong>MySQL会直接报错并回滚整个 DDL 操作</strong>，之前几个小时的 CPU/IO资源白费。更严重的是，<strong>触发溢出的那个用户事务会被强制回滚</strong>，导致业务报错。</p><h3 id="instant-1">3.2 INSTANT</h3><p>天下没有免费的午餐。INSTANT算法虽然写得快，但它把成本转移到了<strong>读</strong>的时候。</p><h4 id="读放大">3.2.1 读放大</h4><ul><li><strong>Copy/Inplace</strong>：数据在物理上已经重写好了。读取时，拿出来的就是完整的行。</li><li><strong>Instant</strong>：物理上的行数据可能只有 3 列，但表定义里有4 列。每次 <code>SELECT</code> 读取该行时，InnoDB引擎必须在内存中判断并加上缺失行的默认值。这增加了一点点 CPU的开销（微乎其微，但存在）。</li></ul><h4 id="数据腐烂风险">3.2.2 数据腐烂风险</h4><p>如果你对一张表连续做了 50 次<code>Instant Add Column</code>，再删几列。表里的数据行就会变得五花八门：有的行是2023 年的版本，有的行是 2024 年的版本。</p><p>表结构的元数据会变得非常复杂，解析成本变高。</p><p><strong>建议</strong>：如果一张表经过了极其频繁的 Instant变更，在低峰期做一次 <code>OPTIMIZE TABLE</code>（这会强制触发 In-PlaceRebuild）来把物理数据规整化，是有好处的。</p><h2 id="什么时候用哪个">4. 什么时候用哪个</h2><p>什么时候 INSTANT，什么时候 INPLACE，什么时候 COPY？怎么判断呢？</p><p>判断这三者的核心逻辑，依然遵循<strong>第一性原理：看数据的物理存储是否需要改变</strong>。</p><p>MySQL 在执行 DDL时，内部遵循一个<strong>懒惰原则</strong>：能偷懒就偷懒。优先级是：<strong>Instant (最懒/只改元数据) &gt; In-Place (勤快/原地修整) &gt;Copy (笨重/推倒重来)</strong>。</p><h3 id="instant-首选快乐路径">4.1 INSTANT (首选，快乐路径)</h3><p><strong>原理</strong>：只修改 <code>.SDI</code> (元数据) 或数据字典。不触碰 B+ 树叶子节点的数据。</p><p><strong>适用场景</strong>：</p><ul><li><strong>新增列 (Add Column)</strong>：<ul><li>MySQL 8.0.12+ 支持（只能加在最后）。</li><li>MySQL 8.0.29+ 支持（任意位置 <code>AFTER column</code>）。</li></ul></li><li><strong>删除列 (Drop Column)</strong>：MySQL 8.0.29+ 支持。</li><li><strong>重命名 (Rename)</strong>：表名、列名。</li><li><strong>修改默认值 (Set/Drop Default)</strong>。</li><li><strong>虚拟列 (Virtual Column)</strong>：添加或删除。</li><li><strong>扩展 VARCHAR 长度</strong>：且扩展后字节数 <strong>&lt;256</strong> (长度前缀保持 1 字节)。</li></ul><h3 id="inplace-主流需谨慎">4.2 INPLACE (主流，需谨慎)</h3><p><strong>原理</strong>：引擎层"原地"重建 B+ 树或索引树。利用<strong>Row Log</strong> 记录执行期间的并发写入，最后回放。</p><p><strong>适用场景</strong>：</p><ul><li><strong>添加索引 (Add Index)</strong>：最常见的场景。</li><li><strong>删除索引 (DropIndex)</strong>：实际上改元数据即可，极快（但在官方分类中常归为Inplace/Metadata）。</li><li><strong>整理表碎片 (Optimize Table)</strong>：强制触发生效。</li><li><strong>修改 Row Format</strong>：如 <code>Compact</code> -&gt;<code>Dynamic</code>。</li></ul><blockquote><p><strong>风险提示</strong>：虽不锁表，但消耗大量 IO 和 CPU，且最后Apply Log阶段如果追不上，可能短暂阻塞。<strong>务必避开业务高峰。</strong></p></blockquote><h3 id="copy-禁区保底方案">4.3 COPY (禁区，保底方案)</h3><p><strong>原理</strong>：数据的<strong>二进制存储格式</strong>发生了根本变化，引擎无法处理，必须由Server 层建立新表，一行行读出来清洗、转换、写入。</p><p><strong>适用场景</strong>：</p><ul><li><p><strong>修改字段数据类型</strong>：如 <code>INT</code> -&gt;<code>BIGINT</code>, <code>VARCHAR</code> -&gt;<code>INT</code>。</p></li><li><p><strong>修改字符集</strong>：如 <code>utf8</code> -&gt;<code>utf8mb4</code>。</p></li><li><p><strong>删除主键 (Drop Primary Key)</strong>。</p></li><li><p><strong>扩展 VARCHAR 长度</strong>：当从 &lt; 256 变为 ≥ 256字节时（字节记录长度发生变化）。</p><blockquote><p>MySQL 8.0.29+ 的 INSTANT 甚至支持跨越 256 字节的 VARCHAR扩展（只要不修改数据本身）。</p></blockquote></li><li><p><strong>MySQL 5.6 之前的大部分操作</strong>。</p></li></ul><blockquote><p><strong>警告</strong>：<strong>全程锁写入</strong>。线上大表严禁直接执行，必须使用<code>gh-ost</code> 或 <code>pt-osc</code>。</p></blockquote><h3 id="最佳实践">4.4 最佳实践</h3><p>不要让 MySQL 帮你选，<strong>显式指定算法</strong>，让潜在的 COPY暴露出来：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 你的防御性写法</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> your_table</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_xxx (xxx),</span><br><span class="line">ALGORITHM<span class="operator">=</span>INPLACE,  <span class="comment">-- 强制要求原地执行</span></span><br><span class="line">LOCK<span class="operator">=</span><span class="keyword">NONE</span>;          <span class="comment">-- 强制要求不锁表</span></span><br></pre></td></tr></table></figure><ul><li>如果 MySQL 能够满足（是 Instant 或 Inplace），它就执行。</li><li>如果 MySQL 发现这事儿必须COPY（要锁表），它会<strong>直接报错</strong>。</li></ul><p>如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE t_online_ddl MODIFY COLUMN val BIGINT, ALGORITHM=INPLACE, LOCK=NONE;</span><br><span class="line"></span><br><span class="line">ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported. Reason: Cannot change column <span class="built_in">type</span> INPLACE. Try ALGORITHM=COPY.</span><br></pre></td></tr></table></figure><h2 id="其他工具">5. 其他工具</h2><p>原生 Online DDL 还是存在一切痛点，尤其是 INPLACE 和 COPY。所以出现了<code>pt-online-schema-change (pt-osc)</code> 和<code>github-online-schema-migration-tool (gh-ost)</code>这两个工具。</p><p>它们的核心思想都是 <strong>影子表（ShadowTable）策略</strong>：建一张新表，同步数据，最后切换。</p><p>区别在于：<strong>怎么同步增量数据？</strong></p><h3 id="pt-osc">5.1 pt-osc</h3><blockquote><p>pt-osc 是 Percona Toolkit 的一部分，是老牌的方案。</p></blockquote><div class="tag-plugin colorful note" color="red"><div class="title"><strong><p>核心原理</p></strong></div><div class="body"><p>数据库触发器 (Database Triggers)。</p></div></div><p>工作流程：</p><ol type="1"><li><strong>创建影子表</strong>：创建一个和原表结构一样的新表<code>_table_new</code>。</li><li><strong>修改结构</strong>：在新表上执行<code>ALTER TABLE</code>（比如加字段）。</li><li><strong>创建触发器 (关键)</strong>：在原表上创建 3个触发器（<strong>AFTER INSERT, AFTER UPDATE, AFTERDELETE</strong>）。这意味着：每当业务向原表写入一行数据，MySQL会自动触发一个动作，把这行数据的变更同步写入到新表中。</li><li><strong>拷贝存量数据</strong>：工具开始分批次（Chunk）把原表的历史数据<code>INSERT IGNORE</code> 到新表中。</li><li><strong>原子切换</strong>：数据拷贝完后，利用<code>RENAME TABLE</code> 原子操作，把原表改名，新表上位。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251218000826173.png" /></p><p>优点：</p><ul><li><strong>可靠</strong>：基于数据库内部机制，数据一致性强。</li><li><strong>兼容性</strong>：支持所有 Binlog格式（Statement/Row/Mixed）。</li></ul><p>缺点：</p><ul><li><strong>同步阻塞</strong>：触发器是和业务 SQL<strong>在同一个事务</strong> 里执行的。<ul><li>如果你的业务 SQL 执行需 1ms，加上触发器写新表可能变成2ms。这直接导致<strong>写性能下降</strong>。</li><li>如果触发器写新表失败（比如锁等待），你的业务 SQL 也会回滚失败！</li></ul></li><li><strong>元数据锁(MDL)</strong>：创建和删除触发器的瞬间，需要锁表（MDL写锁），在高并发下可能导致拥堵。</li></ul><h3 id="gh-ost">5.2 gh-ost</h3><div class="tag-plugin colorful note" color="red"><div class="title"><strong><p>核心原理</p></strong></div><div class="body"><p>模拟从库 (Binlog Simulation)。</p></div></div><p>GitHub 在被 <code>pt-osc</code> 的触发器搞了几次故障后，开发了<code>gh-ost</code>。它彻底抛弃了触发器。</p><p>工作流程：</p><ol type="1"><li><strong>创建影子表</strong>：同上，建新表、改结构。</li><li><strong>伪装成从库</strong>：<code>gh-ost</code>进程把自己伪装成一个 MySQL Slave，连接到 Master（或者真实的Slave）。它请求 Dump <strong>Binlog</strong> 流。</li><li><strong>监听 Binlog</strong>：业务在原表写入数据，产生Binlog。<code>gh-ost</code> 读取 Binlog，将解析出来的 Binlog事件（Insert/Update/Delete），转换成 SQL 语句，并在影子表上回放。</li><li><strong>拷贝存量数据</strong>：同上，分批拷贝历史数据。</li><li><strong>原子切换</strong>：因为 <code>gh-ost</code>是异步的，所以切换的时候必须有"同步"辅助方案。所以它使用一种特殊的机制（Cut-over）进行表名切换。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251218000842840.png" /></p><p>Cut-over 过程：</p><ol type="1"><li><strong>制造阻塞</strong>：<code>gh-ost</code> 会建立一个连接C1，执行<code>LOCK TABLES tbl WRITE;</code>。这时候，<strong>所有</strong>业务线程想写这张表，都会被堵塞住（Blocked）。原表被冻结了，不再会有新数据写入（这就消除了追不上的问题）。</li><li><strong>发起改名</strong>：<code>gh-ost</code> 建立另一个连接C2，执行<code>RENAME TABLE tbl TO tbl_old, ghost_tbl TO tbl;</code>。这条 SQL也会被 C1 的锁堵塞住，<strong>卡在 MySQL 的执行队列里</strong>。</li><li><strong>插队机制</strong>：此时，MySQL的锁等待队列里可能排着一堆请求。但是！<strong><code>RENAME</code> 等 DDL操作的优先级高于 <code>INSERT/UPDATE</code> 等 DML 操作。</strong>所以，虽然大家都在排队，但 MySQL 会把 C2 的 Rename请求<strong>提到最前面</strong>（仅次于持有锁的 C1）。</li><li><strong>瞬间释放</strong>：<code>gh-ost</code> 确认 C2已经乖乖排在队首后，C1 执行<code>UNLOCK TABLES;</code>。锁一释放，排在队首的C2（Rename）瞬间执行。因为 C2 优先级最高，没有任何业务写入能插到 C1释放和 C2 执行这两个动作中间。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251218000920326.png" /></p><p>优点：</p><ul><li><strong>解耦</strong>：<code>gh-ost</code>是在<strong>应用层</strong>（或者说外部工具层）回放数据。它和业务的写操作完全<strong>异步</strong>。</li><li><strong>轻量</strong>：业务 SQL写入原表后就结束了，不需要等新表写入。<strong>不影响业务响应时间</strong>。</li><li><strong>可暂停/限速</strong>：这是 <code>gh-ost</code>的杀手锏。如果发现数据库负载高了，<code>gh-ost</code>可以瞬间<strong>暂停</strong>读取Binlog，甚至在拷贝数据的过程中随时停下来睡觉。这是触发器做不到的。</li></ul><p>缺点：</p><ul><li><strong>依赖 Row 格式</strong>：必须开启 Binlog <code>row</code>模式（现代 MySQL 标配）。</li><li><strong>复杂性</strong>：架构比 <code>pt-osc</code> 复杂，需要处理Binlog 解析。</li></ul><h2 id="总结">6. 总结</h2><p>回到<strong>第一性原理</strong>：Online DDL的本质，是在"修改表结构"与"保持业务可用"之间寻找平衡点。</p><table><colgroup><col style="width: 12%" /><col style="width: 39%" /><col style="width: 21%" /><col style="width: 26%" /></colgroup><thead><tr><th>算法</th><th>原理</th><th>代价</th><th>场景</th></tr></thead><tbody><tr><td><strong>COPY</strong></td><td>Server 层新建表 → 复制数据 → 删旧表</td><td>极高，全程锁表</td><td>数据类型变更、字符集修改</td></tr><tr><td><strong>INPLACE</strong></td><td>引擎层原地重建 + Row Log 增量</td><td>中等，不锁表但耗 IO</td><td>加索引、优化表碎片</td></tr><tr><td><strong>INSTANT</strong></td><td>只改元数据，不碰数据</td><td>几乎为零，毫秒级</td><td>加/删列、改默认值</td></tr></tbody></table><p>无论哪种算法，<strong>MDL锁</strong>始终是最隐蔽的杀手。一个长事务就能让整个 DDL 链路瘫痪。</p><ul><li><strong>INPLACE</strong>：主从延迟、Buffer Pool 污染、Apply Log阻塞、磁盘撑爆。</li><li><strong>INSTANT</strong>：读放大、数据腐烂（频繁变更后需定期OPTIMIZE）。</li></ul><p>工具选型：</p><table><colgroup><col style="width: 22%" /><col style="width: 77%" /></colgroup><thead><tr><th>场景</th><th>推荐方案</th></tr></thead><tbody><tr><td>小表 + 低峰期</td><td>原生 <code>ALTER TABLE ... ALGORITHM=INPLACE, LOCK=NONE</code></td></tr><tr><td>大表 + 主从架构</td><td><code>gh-ost</code>（无触发器、可暂停、可限速）</td></tr><tr><td>兼容性要求高</td><td><code>pt-osc</code>（支持所有 Binlog 格式）</td></tr></tbody></table><p>生产环境黄金法则：</p><ol type="1"><li><strong>永远显式指定算法</strong>：<code>ALGORITHM=INPLACE, LOCK=NONE</code>，让潜在的COPY 暴露出来。</li><li><strong>执行前检查长事务</strong>：<code>SELECT * FROM information_schema.processlist WHERE TIME &gt; 10;</code></li><li><strong>避开高峰期</strong>：再 Online 的 DDL，也会消耗资源。</li><li><strong>大表用工具</strong>：超过 100 万行，优先考虑<code>gh-ost</code>。</li><li><strong>监控主从延迟</strong>：<code>Seconds_Behind_Master</code>是你的生命线。</li></ol><hr /><p><strong>一句话总结</strong>：</p><blockquote><p>Online DDL 不是银弹。它只是把"长时间锁表"变成了"短时间锁表 +长时间后台作业"。理解它的边界，才能用好它。</p></blockquote>]]></content>
    
    
    <summary type="html">本文以第一性原理为切入点，系统梳理 MySQL Online DDL 的核心原理、发展历程与典型实现方式，结合实际场景分析 Online DDL 的类型、适用性与性能优化策略，并剖析其底层机制与使用注意事项。</summary>
    
    
    
    <category term="数据库" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://hedon.top/tags/MySQL/"/>
    
    <category term="Online-DDL" scheme="https://hedon.top/tags/Online-DDL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 底层原理丨锁</title>
    <link href="https://hedon.top/2025/12/17/mysql/mysql-lock/"/>
    <id>https://hedon.top/2025/12/17/mysql/mysql-lock/</id>
    <published>2025-12-17T12:21:00.000Z</published>
    <updated>2025-12-18T01:09:49.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础认知">1. 基础认知</h2><p>要从根本上理解 MySQL 的锁，必须理解它在 <strong>内存（RAM）</strong>和 <strong>数据结构（B+Tree）</strong> 层面是如何运作的。</p><p>可以将 MySQL（主要是 InnoDB 引擎）的锁机制拆解为五个层次：</p><ol type="1"><li>锁的结构：锁在内存里面到底长什么样？（打破"锁是数据行上的标记"这一误区）</li><li>锁的对象：锁是加在什么对象上？（打破"锁行"的字面理解）</li><li>锁的类型：读写冲突怎么解决？</li><li>锁的粒度：如何提高并发效率？（意向锁的由来）</li><li>锁的算法：如何解决幻读？（Gap Lock 的由来）</li></ol><h3 id="锁的结构锁在内存里面到底长什么样">1.1锁的结构：锁在内存里面到底长什么样？</h3><div class="tag-plugin colorful note" color="red"><div class="body"><p>核心认知：锁不是数据行（Row）上的一个字段，而是内存中独立的数据结构。</p></div></div><p>很多初学者认为锁是磁盘上每一行数据里的一个 <code>is_locked</code>标记。这是错的。如果是这样，锁事务回滚时还需要去修改磁盘数据，IO开销太大。</p><p>在 InnoDB 内部，锁通过 <strong><ahref="https://dev.mysql.com/doc/dev/mysql-server/8.4.7/PAGE_INNODB_LOCK_SYS.html">LockSystem (lock_sys)</a></strong> 进行管理，是一个巨大的 <strong>HashTable</strong>。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251217203647272.png" /></p><p>InnoDB 不会为每一行数据创建一个锁对象（LockStruct），那是巨大的内存浪费。它是按<strong>页（Page）</strong>来管理的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">lock_t</span> &#123;</span><br><span class="line">    <span class="type">trx_t</span>* trx;       <span class="comment">// 属于哪个事务</span></span><br><span class="line">    ulint  space_id;  <span class="comment">// 表空间 ID</span></span><br><span class="line">    ulint  page_no;   <span class="comment">// 页号</span></span><br><span class="line">    uint32 type_mode; <span class="comment">// 锁类型 (Shared/Exclusive) | 锁模式 (Rec/Gap/Next-Key)</span></span><br><span class="line">    <span class="comment">// ---------------------------------------------</span></span><br><span class="line">    <span class="comment">// 重点来了：这里没有 Row ID，而是一个 Bitmap</span></span><br><span class="line">    <span class="comment">// ---------------------------------------------</span></span><br><span class="line">    uint8  bitmap[];  <span class="comment">// 位图！映射这一页上的物理记录</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>一个 <code>lock_t</code>结构体对应"一个事务"在"一个数据页"上的锁信息。</li><li>在这个结构体后面，跟着一个 <strong>Bitmap（位图）</strong>。</li><li>如果一个页面有 100 条记录，位图里就有对应的一堆 Bit。如果你执行<code>UPDATE... WHERE id &lt; 1000</code>，锁住了这页的 50行记录，InnoDB 不需要创建 50 个锁对象，只需要在一个锁对象的位图中把这 50个 bit 置为 1。这就是为什么 MySQL宣称它支持行级锁且开销极小，即便你锁住了 100 万行，只要它们集中在几千个Page 里，内存消耗依然很小。</li></ul><h3 id="锁的对象锁是加在什么对象上">1.2锁的对象：锁是加在什么对象上？</h3><div class="tag-plugin colorful note" color="red"><div class="body"><p>核心认知：InnoDB 的行锁，永远是加在索引（Index）上的。</p></div></div><p>这是理解所有复杂锁问题的总钥匙。</p><ul><li><strong>如果你通过主键更新</strong>：锁加在<strong>聚簇索引</strong>（ClusteredIndex）的记录上。</li><li><strong>如果你通过二级索引更新</strong>：锁<strong>先</strong>加在二级索引（SecondaryIndex）的记录上，<strong>然后</strong>回表，去锁聚簇索引上的记录。</li><li><strong>如果你不走索引</strong>：因为 MySQL必须扫描全表才能找到你要更新的行。它会扫描一条、锁一条（在聚簇索引上）。虽然在RC 隔离级别下 MySQL 有优化（不匹配的行会释放锁），但在 RR级别下，它会把<strong>所有扫描过的记录</strong>以及<strong>记录之间的间隙</strong>全锁上。这在效果上等同于<strong>锁表</strong>。</li></ul><h3 id="锁的类型读写冲突怎么解决">1.3 锁的类型：读写冲突怎么解决？</h3><p>MySQL InnoDB 有 7 种锁：</p><ol type="1"><li>共享锁（S 锁）和排他锁（X 锁）</li><li>意向锁（Intension Locks）</li><li>记录锁（Record Locks）</li><li>间隙锁（Gap Locks）</li><li>临键锁（Next-Key Locks）</li><li>插入意向锁（Insert Intension Locks）</li><li>自增锁（Auto-Inc Locks）</li></ol><blockquote><p>MDL 是 MySQL Server 层面的锁。</p></blockquote><p>可以从 2 个维度进行理解：</p><ul><li>锁的粒度：锁表、锁行、锁区间</li><li>锁的模式：共享、排他、意向</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251217211914464.png" /></p><h3 id="锁的粒度如何提高并发效率">1.4 锁的粒度：如何提高并发效率？</h3><p>如果表里有 100 万行数据，事务 A 锁住了其中第 999 行（行锁）。此时事务B 想申请整张表的写锁（表锁），B 怎么知道能不能加锁？</p><ul><li><strong>笨办法</strong>：B 遍历这 100万行，看有没有人加了行锁。-&gt;<strong>效率极低，不可接受</strong>。</li><li><strong>第一性原理优化</strong>：在层级结构中，下层有锁，上层必须有标记。</li></ul><p><strong>意向锁（Intention Lock, IS/IX）</strong>这实际上是表级锁，它的作用只是<strong>"信号灯"</strong>：</p><ul><li><strong>规则</strong>：事务 A 在给第 999 行加 <strong>行级排他锁(X)</strong> 之前，必须先给这张表挂一个 <strong>意向排他锁(IX)</strong>。</li><li><strong>效果</strong>：事务 B 来看一眼表门头，发现有<strong>IX</strong> 标记，就知道表里有人在干活，于是 B 阻塞等待。B不需要遍历全表，<strong>效率提升为 O(1)</strong>。</li></ul><h3 id="锁的算法如何解决幻读">1.5 锁的算法：如何解决幻读？</h3><p>为了防止幻读（Phantom Read），InnoDB发明了复杂的锁算法，我们需要把数据想象成 B+树叶子节点上的一条有序链表。</p><p>假设表中现在的 ID 有：<code>10, 20, 30</code>。</p><p><strong>Record Lock（记录锁）：</strong></p><ul><li>定义：仅仅锁住索引记录本身。</li><li>场景：精准命中。例如<code>SELECT * FROM t WHERE id = 10 FOR UPDATE;</code>。</li><li>内存表现：Bitmap 中对应 <code>id=10</code> 的那个 bit 被置位。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251217212218168.png" /></p><p><strong>Gap Lock（间隙锁）：</strong></p><ul><li>定义：锁住两个索引记录之间的空隙，<strong>不包含记录本身</strong>。</li><li>目的：纯粹是为了通过禁止插入（insert）来防止幻读。</li><li>场景：<code>SELECT * FROM t WHERE id = 15 FOR UPDATE;</code>。</li><li>范围：例如 <code>(10, 20)</code>。这意味着你不能插入<code>11,12... 19</code>。</li><li>重要特性：Gap Lock 之间是兼容的！事务 A 可以对 <code>(10, 20)</code>加 Gap Lock，事务 B 也可以对 <code>(10, 20)</code> 加 GapLock。为什么？因为它们的目的都是阻止别人插入，不冲突。真正冲突的是<strong>Insert Intention Lock（插入意向锁）</strong>。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251217212309192.png" /></p><p><strong>Next Key Lock（临键锁）：</strong></p><ul><li>定义：<strong>Record Lock + GapLock</strong>。即锁住记录本身，也锁住它前面的空隙。</li><li>默认行为：在 RR（Repeatable Read）隔离级别下，InnoDB对于范围查询或非唯一索引的等值查询，默认加 Next-Key Lock。</li><li>场景：<code>SELECT * FROM t WHERE id &gt; 10 FOR UPDATE;</code></li><li>左开又闭：在 <code>10, 20, 30</code> 的例子中，扫描到 20 时，加Next-Key Lock <code>(10, 20]</code>；扫描到 30 时，加 Next-Key Lock<code>(20, 30]</code>。扫描完 30后，指针继续向后，发现没有真实记录了，碰到了 B+ 树页面的<strong>Supremum 伪记录</strong>（代表无穷大）。加 Next-Key Lock<code>(30, ∞)</code>。综合起来是锁住了<code>(10, +∞)</code>。它不仅仅是锁间隙，也会锁住记录。这意味着：你不能修改20，也不能在 10 到 20 之间插入数据 。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251217212317333.png" /></p><p><strong>Insert Intension Lock（插入意向锁）：</strong></p><ul><li>定义：这其实是一种特殊的 Gap Lock，但在代码里它叫"插入意向"。</li><li>触发：当执行 <code>INSERT</code> 时，如果目标位置已经被别的事务加了GapLock，插入操作就会进入等待，并在这个间隙上生成一个"插入意向锁"。</li><li>死锁之源：很多死锁都是因为两个事务持有 Gap Lock，然后又都想在这个Gap 里插入数据（申请插入意向锁），结果互相等待。</li></ul><p><strong>Metadata Lock（元数据锁）：</strong></p><ul><li>作用：保护表结构。当你执行 <code>SELECT</code> 或<code>UPDATE</code> 时，自动加 MDL 读锁。当你执行<code>ALTER TABLE</code> 时，需要 MDL 写锁。</li><li>阻塞逻辑：读写互斥。这意味着，只要有一个长事务（哪怕只是<code>SELECT</code>）没提交，持有 MDL 读锁，后续的<code>ALTER TABLE</code> 就会被卡住，而 <code>ALTER TABLE</code>卡住后，后面所有的 <code>SELECT/UPDATE</code>也会被卡住（形成锁队列堆积）。这就是著名的"MDL 暴击"。</li></ul><h2 id="分析模板">2. 分析模板</h2><p>当一个事务执行 SQL 时，InnoDB 锁引擎会遵循以下判定树：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/%E9%94%81%E5%88%86%E6%9E%90%E5%88%A4%E5%AE%9A%E6%A0%91.png" /></p><p>针对 RR 隔离级别，我们要秉持三大分析原则：</p><ol type="1"><li><p><strong>原则一：</strong> 加锁的基本单位是 <strong>Next-KeyLock</strong>（左开右闭）。</p></li><li><p><strong>原则二：</strong> 查找过程中，访问到的对象才会加锁。</p><ul><li><p>如果 SQL 走了二级索引，二级索引会被强力锁定（Next-Key +Gap）。</p></li><li><p>回表时，主键索引只加 <strong>Record Lock</strong>。</p></li></ul></li><li><p><strong>原则三（优化）：</strong> 索引上的等值查询：</p><ul><li><p><strong>唯一索引</strong>：Next-Key Lock 退化为 RecordLock（因为不用担心那个值后面插进一样的）。</p></li><li><p><strong>非唯一索引</strong>：向右扫描到第一个不符合条件的记录，该记录加<strong>Gap Lock</strong>（不锁记录本身，只锁它前面的空隙）。</p></li></ul></li></ol><h2 id="例题分析">3. 例题分析</h2><div class="tag-plugin colorful note" color="blue"><div class="body"><p><strong>表结构：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> students (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,       <span class="comment">-- 主键</span></span><br><span class="line">  score <span class="type">INT</span>,                <span class="comment">-- 非唯一索引</span></span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>),         <span class="comment">-- 无索引</span></span><br><span class="line">  INDEX idx_score (score)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p><strong>现有数据：</strong></p><ul><li><code>id=1, score=10, name='A'</code></li><li><code>id=5, score=20, name='B'</code></li><li><code>id=10, score=30, name='C'</code></li></ul><p><strong>当前事务执行：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隔离级别：RR</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> score <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><strong>请分析以下三个核心问题：</strong></p><ol type="1"><li><strong>二级索引锁：</strong> 在 <code>idx_score</code> 这棵 B+树上，锁住了哪些范围？（请用准确的区间表示，如<code>(10, 20]</code>）</li><li><strong>聚簇索引锁（回表）：</strong> 在 <code>PRIMARY KEY</code>(id) 这棵 B+ 树上，锁住了哪些 ID？有没有加 Gap Lock？</li><li><strong>并发测试：</strong> 此时，另一个事务想执行<code>INSERT INTO students (id, score, name) VALUES (2, 15, 'D');</code>，能否成功？为什么？</li></ol></div></div><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251217214204837.png" style="zoom:33%;" /></p><p><strong>问题一：<code>idx_score</code> 到底锁了什么？</strong></p><blockquote><p><strong>数据 (id, score):</strong> <code>(1, 10)</code>,<code>(5, 20)</code>, <code>(10, 30)</code></p><p><strong>SQL:</strong><code>DELETE FROM students WHERE score = 20;</code> (隔离级别 RR)</p></blockquote><p>InnoDB 的逻辑是：我要锁住 <code>score=20</code>，并且防止别人在<code>score=20</code> 的前后插入数据。</p><ul><li><strong>命中记录：</strong> 首先找到 <code>(5, 20)</code>这条记录。加上 <strong>Next-Key Lock</strong>。<ul><li><strong>范围一：</strong> <code>(10, 20]</code>。</li><li><strong>注意：</strong> 这里锁的是 <code>score</code>的范围，配合主键 <code>id</code>。确切地说，它锁的是<code>(score=10, id=1)</code> 到 <code>(score=20, id=5)</code>之间的间隙，加上 <code>(20, 5)</code> 这条记录本身。</li></ul></li><li><strong>向右探测：</strong><ul><li>为了防止幻读（比如别人插入一个 <code>score=20</code>的新行），InnoDB<strong>必须</strong>继续向右扫描，直到遇到<strong>第一条不满足条件</strong>的记录为止。</li><li>它向右看到了 <code>(10, 30)</code>。</li><li>因为 <code>30!= 20</code>，扫描结束。但是，为了封锁 <code>20</code>之后到 <code>30</code> 之前的空隙，它必须在 <code>(10, 30)</code>这条记录上加一个 <strong>Gap Lock</strong>。</li><li><strong>范围二：</strong> <code>(20, 30)</code>。</li></ul></li></ul><p><strong>结论：</strong> 在 <code>idx_score</code>索引上，实际锁住的范围是 <strong>(10, 30)</strong>。</p><ul><li><code>score</code> 在 <code>(10, 20]</code> 的不能插。</li><li><code>score</code> 在 <code>(20, 30)</code> 的也不能插。</li></ul><hr /><p><strong>问题二：聚簇索引 (<code>PRIMARY KEY</code>)锁了什么？</strong></p><p>二级索引回表锁主键时，<strong>只加 Record Lock，不加 GapLock</strong>。</p><p><strong>原因：</strong> Gap Lock是为了防止"在范围内插入"。二级索引上的 Gap Lock 已经足够阻止<code>score=20</code> 的插入了（因为插入必须维护所有索引）。主键上再加Gap Lock 是多余的，且会极大地降低并发（会误伤 <code>id</code> 邻近但<code>score</code> 无关的行）。</p><p>所以主键 <code>id=5</code> 上只有 Record Lock (X 锁)。</p><hr /><p><strong>问题三：并发测试结果分析</strong></p><blockquote><p>SQL:<code>INSERT INTO students (id, score, name) VALUES (2, 15, 'D');</code></p></blockquote><ul><li>我们要插入 <code>score=15</code>。</li><li>检查 <code>idx_score</code> 锁范围：<code>15</code> 落在<code>(10, 20]</code> 这个区间内。</li><li><strong>结果：</strong> 被 <code>idx_score</code> 的<strong>Next-Key Lock</strong> 阻塞。</li></ul><h2 id="参考">参考</h2><ul><li><a href="https://hevodata.com/learn/mysql-locks/">MySQL Locks: AComprehensive Guide 101</a></li><li><a href="https://kernelmaker.github.io/MySQL-implicit-locks">DeepDive into MySQL - Implicit Locks</a></li><li><ahref="https://cloud.tencent.com/developer/article/1799236">深入浅出MySQL 8.0 lock_sys 锁相关优化</a></li></ul>]]></content>
    
    
    <summary type="html">本文将从底层原理出发，全面解析 MySQL 的锁机制，涵盖锁的结构、对象、类型、粒度及其背后的实现逻辑与优化原则，帮助读者构建系统性认知。</summary>
    
    
    
    <category term="数据库" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://hedon.top/tags/MySQL/"/>
    
    <category term="锁" scheme="https://hedon.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>盘点 Redis 各种数据类型</title>
    <link href="https://hedon.top/2025/12/09/redis/redis-datatype/"/>
    <id>https://hedon.top/2025/12/09/redis/redis-datatype/</id>
    <published>2025-12-09T07:06:00.000Z</published>
    <updated>2025-12-10T04:55:36.212Z</updated>
    
    <content type="html"><![CDATA[<p>理解 Redis 各类数据结构的精妙之处，离不开两个底层设计原则：</p><ol type="1"><li>极致节省内存：能省就省，既压缩结构本身，也采用动态或共享等机制确保每一位（bit）都物尽其用。</li><li>最大化 CPU缓存友好：优先用一块连续小内存管理数据，降低指针跳转和碎片化，以提升访问速度和CPU 缓存命中率。</li></ol><p>这两点支撑着 Redis 各类数据类型的演进路线与编码选择。</p><blockquote><p>版本声明：<ahref="https://github.com/redis/redis/tree/8.4.0">Redis8.4.0</a></p></blockquote><h2 id="redisobject">0. redisObject</h2><p>在深入具体类型之前，我们先对 Redis 对象头 <code>redisObject</code>做一个简单的了解，因为 Redis 中的所有 Key 和 Value，在底层都是一个<code>redisObject</code> 结构体。这是 Redis多态的基石。<code>redisObject</code> 的定义位于 <ahref="https://github.com/redis/redis/blob/8.4.0/src/server.h#L1057">src/server.h</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_REFCOUNT_BITS 30</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">unsigned</span> iskvobj : <span class="number">1</span>;   <span class="comment">/* 1 if this struct serves as a kvobj base */</span></span><br><span class="line">    <span class="type">unsigned</span> expirable : <span class="number">1</span>; <span class="comment">/* 1 if this key has expiration time attached.</span></span><br><span class="line"><span class="comment">                             * If set, then this object is of type kvobj */</span></span><br><span class="line">    <span class="type">unsigned</span> refcount : OBJ_REFCOUNT_BITS;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>type</code>:逻辑数据类型（String、List、Hash、Set、ZSet）。</li><li><code>encoding</code>:物理编码格式（int、row、listpack、skiplist）。</li><li><code>lru</code>: 淘汰策略数据，如果是 LRU模式，则存储最后一次访问的时间戳（秒级）。如果是 LFU模式，则存储方法时间和访问频率。当内存达到 <code>maxmemory</code>时，Redis 根据此字段决定淘汰哪个 Key。</li><li><code>iskvobj</code>: Redis 8.0 的新特性。<code>1</code>表示该对象是一个 <code>kvobj</code> （键值对象）的一部分，意味着Key、Value和元数据在内存中是紧凑/内嵌存储的。这样可以消除"键值分离"带来的指针跳转，提升CPU 缓存命中率。</li><li><code>expirable</code>: Redis8.0 的新特性。<code>1</code> 表示该 Key设置了过期时间。这提供了一条快速通道，访问时若为 0，直接跳过查询<code>expires</code> 哈希表的步骤，节省昂贵的哈希查找开销。</li><li><code>refcount</code>:记录有多少个指针引用了该对象。用于内存管理和对象共享（主要用于小整数共享）。当计数降为0 时，回收内存。这里使用了位域压缩以节省空间。</li><li><code>ptr</code>: 指向实际存储数据的内存地址（如SDS、Dict、Quicklist 的地址）。特别地，如果 encoding 是<code>INT</code>，这里直接存储整数值本身，不再是指针。</li></ul><p>上述多个字段，最重要的就是 <code>type</code> 和<code>encoding</code>。总的来说，<code>type</code>决定了它对外声称是什么（比如 Hash），而 <code>encoding</code>决定了它在内存里到底怎么存（比如是压缩列表还是哈希表）。<strong>优化Redis 内存的核心，就是想办法让它保持在轻量级的 <code>encoding</code>上。</strong></p><h2 id="string">1. String</h2><p>String 是 Redis 最基本的数据类型，也是所有 Key 的类型。</p><h3 id="核心操作">1.1 核心操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础操作</span></span><br><span class="line">SET key value                 <span class="comment"># 设置键值对</span></span><br><span class="line">GET key                       <span class="comment"># 获取值</span></span><br><span class="line">DEL key                       <span class="comment"># 删除键</span></span><br><span class="line">EXISTS key                    <span class="comment"># 检查键是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量操作</span></span><br><span class="line">MSET key1 value1 key2 value2  <span class="comment"># 批量设置</span></span><br><span class="line">MGET key1 key2 key3           <span class="comment"># 批量获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数值操作</span></span><br><span class="line">INCR key                      <span class="comment"># 原子递增 +1</span></span><br><span class="line">DECR key                      <span class="comment"># 原子递减 -1</span></span><br><span class="line">INCRBY key increment          <span class="comment"># 按指定值递增</span></span><br><span class="line">DECRBY key decrement          <span class="comment"># 按指定值递减</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串操作</span></span><br><span class="line">APPEND key value              <span class="comment"># 追加字符串</span></span><br><span class="line">STRLEN key                    <span class="comment"># 获取字符串长度</span></span><br><span class="line">GETRANGE key start end        <span class="comment"># 获取子字符串（闭区间）</span></span><br><span class="line">SETRANGE key offset value     <span class="comment"># 从指定偏移量设置字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过期时间</span></span><br><span class="line">SETEX key seconds value       <span class="comment"># 设置带过期时间的键</span></span><br><span class="line">TTL key                       <span class="comment"># 查看剩余生存时间</span></span><br><span class="line">EXPIRE key seconds            <span class="comment"># 为已有键设置过期时间</span></span><br></pre></td></tr></table></figure><p><strong>常见使用场景：</strong></p><ul><li><strong>缓存层</strong>：存储 JSON序列化后的对象，如用户信息、商品详情</li><li><strong>计数器</strong>：文章阅读数、点赞数、库存数量等原子计数场景</li><li><strong>分布式锁</strong>：<code>SET key value NX EX 30</code>实现简单的分布式锁</li><li><strong>限流器</strong>：使用 <code>INCR</code> 和<code>EXPIRE</code> 实现滑动窗口限流</li><li><strong>会话管理</strong>：存储用户 session信息，配合过期时间自动清理</li></ul><h3 id="底层原理">1.2 底层原理</h3><p>Redis 没有直接使用 C 语言的字符串 <code>char*</code>，而是自己封装了SDS（Simple Dynamic String），而且还进一步分成了<code>sdshdr5</code>、<code>sdshdr8</code>、<code>sdshdr16</code>、<code>sdshdr32</code>和<code>sdshdr64</code>。其核心目的是根据<strong>字符串的长度</strong>，使用不同大小的头部，从而进一步压缩内存的使用。</p><p>SDS 的定义位于 <ahref="https://github.com/redis/redis/blob/8.4.0/src/sds.h">src/sds.h</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们重点关注 3 个字段：</p><ul><li><code>len</code>: 已用长度。</li><li><code>alloc</code>: 分片的总内存大小（不包括头部和末尾的<code>\0</code>）。</li><li><code>buf[]</code>: 实际存储字符数据的柔性数组。</li></ul><p>即便都是 String，Redis 为了省内存，也使用了 3 种不同的编码格式：</p><table><colgroup><col style="width: 8%" /><col style="width: 16%" /><col style="width: 38%" /><col style="width: 36%" /></colgroup><thead><tr><th><strong>编码类型</strong></th><th><strong>场景</strong></th><th><strong>特点</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>int</strong></td><td>纯数字且在 long 范围内</td><td><code>ptr</code> 指针直接存数值，不需要 SDS。</td><td>最省内存，无额外指针开销。</td></tr><tr><td><strong>embstr</strong></td><td>字符串 ≤ 44 字节</td><td><code>redisObject</code> 和 <code>SDS</code> 连续分配，只调用 1 次malloc。</td><td><strong>内存连续</strong>，缓存亲和性好；但只读，修改会转 raw。</td></tr><tr><td><strong>raw</strong></td><td>字符串 &gt; 44 字节</td><td><code>redisObject</code> 和 <code>SDS</code> 分开分配，调用 2 次malloc。</td><td>适合长字符串，修改灵活。</td></tr></tbody></table><blockquote><p>[!note]</p><p><strong>💡 44 字节怎么来的？</strong> <code>redisObject</code> (16B)+ <code>SDS</code> 头 (3B) + <code>\0</code> (1B) = 20B。 内存分配器（如jemalloc）通常分配 64B 的块。 64B - 20B =44B。刚好填满一个内存块，不浪费。</p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251209161405085.png" /></p><h2 id="list">2. List</h2><p>List 在 Redis 中逻辑上是一个<strong>双向链表</strong>。这意味着：</p><ul><li><strong>头尾操作极快</strong>：<code>LPUSH</code>/<code>RPOP</code>是 <strong>O(1)</strong>。</li><li><strong>随机访问极慢</strong>：<code>LINDEX</code> 是<strong>O(N)</strong>。（千万别把它当数组用！）</li></ul><h3 id="核心操作-1">2.1 核心操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 头部操作</span></span><br><span class="line">LPUSH key value1 value2       <span class="comment"># 从左侧头部推入元素（栈：先进后出）</span></span><br><span class="line">RPUSH key value1 value2       <span class="comment"># 从右侧尾部推入元素（队列：先进先出）</span></span><br><span class="line">LPOP key                      <span class="comment"># 从左侧头部弹出元素</span></span><br><span class="line">RPOP key                      <span class="comment"># 从右侧尾部弹出元素</span></span><br><span class="line">LPOP key count                <span class="comment"># 批量从左侧弹出多个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞操作（重要）</span></span><br><span class="line">BLPOP key1 key2 <span class="built_in">timeout</span>       <span class="comment"># 阻塞式左弹出，用于消息队列</span></span><br><span class="line">BRPOP key1 key2 <span class="built_in">timeout</span>       <span class="comment"># 阻塞式右弹出，用于消息队列</span></span><br><span class="line">BLMOVE <span class="built_in">source</span> destination <span class="built_in">timeout</span> LEFT|RIGHT LEFT|RIGHT  <span class="comment"># 阻塞式移动元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询操作</span></span><br><span class="line">LLEN key                      <span class="comment"># 获取列表长度</span></span><br><span class="line">LRANGE key start end          <span class="comment"># 获取指定范围内的元素（支持负数索引）</span></span><br><span class="line">LINDEX key index              <span class="comment"># 获取指定索引的元素</span></span><br><span class="line">LPOS key value [COUNT count]  <span class="comment"># 查找元素位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改操作</span></span><br><span class="line">LSET key index value          <span class="comment"># 设置指定索引的值</span></span><br><span class="line">LINSERT key BEFORE|AFTER pivot value  <span class="comment"># 在指定元素前/后插入新元素</span></span><br><span class="line">LTRIM key start end           <span class="comment"># 修剪列表，只保留指定范围内的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动操作</span></span><br><span class="line">RPOPLPUSH <span class="built_in">source</span> destination  <span class="comment"># 从 source 右弹出，destination 左推入</span></span><br><span class="line">LMOVE <span class="built_in">source</span> destination LEFT|RIGHT LEFT|RIGHT  <span class="comment"># 灵活的元素移动</span></span><br></pre></td></tr></table></figure><p><strong>常见使用场景：</strong></p><ul><li><strong>消息队列</strong>：<code>LPUSH/BRPOP</code>实现简单的生产者-消费者模式，<code>BLPOP</code> 提供阻塞式消费</li><li><strong>最新动态</strong>：用户动态、新闻列表使用<code>LPUSH/LRANGE 0 10</code> 获取最新 10 条</li><li><strong>任务队列</strong>：异步任务处理，配合 <code>RPOPLPUSH</code>实现可靠队列（失败重试）</li><li><strong>数据分页</strong>：存储分页数据，使用 <code>LRANGE</code>实现高效分页查询</li><li><strong>排行榜</strong>：结合 <code>LPUSH/LTRIM</code>维护固定大小的排行榜或热榜</li><li><strong>限流队列</strong>：实现滑动窗口限流，使用 <code>LLEN</code>监控队列长度</li></ul><h3 id="底层原理-1">2.2 底层原理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>Redis List 的底层实现经历了三次大的变革：</p><table><colgroup><col style="width: 7%" /><col style="width: 23%" /><col style="width: 21%" /><col style="width: 47%" /></colgroup><thead><tr><th><strong>Redis 版本</strong></th><th><strong>底层实现</strong></th><th><strong>结构描述</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>v3.2 之前</strong></td><td><strong>LinkedList</strong> (双向链表)<br><strong>Ziplist</strong>(压缩列表)</td><td>元素少用 Ziplist，多用 LinkedList。</td><td><strong>LinkedList</strong>：指针占用内存巨大，内存碎片多，Cache亲和性差。 <br><strong>Ziplist</strong>：省内存，但更新效率低。</td></tr><tr><td><strong>v3.2 - v6.2</strong></td><td><strong>Quicklist</strong> (快速列表)</td><td>链表的节点是压缩列表。</td><td>集大成者。既保留了链表的伸缩性，又利用了压缩列表的省内存特性。</td></tr><tr><td><strong>v7.0+</strong></td><td><strong>Quicklist</strong> + <strong>Listpack</strong></td><td>将 Quicklist 内部的 Ziplist 替换为 Listpack。</td><td>解决了 Ziplist 的级联更新问题。</td></tr></tbody></table><h4 id="linkedlist">2.2.1 LinkedList</h4><p>我们先来看 <code>LinkedList</code>，这是最直觉的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          +------+     +------+     +------+</span><br><span class="line">... &lt;---- | prev | &lt;-&gt; | prev | &lt;-&gt; | prev | ----&gt; ...</span><br><span class="line">          | data |     | data |     | data |</span><br><span class="line">... &lt;---- | next | &lt;-&gt; | next | &lt;-&gt; | next | ----&gt; ...</span><br><span class="line">          +------+     +------+     +------+</span><br></pre></td></tr></table></figure><p>优点：完美的 O(1) 头尾操作</p><p>缺点：</p><ul><li><strong>高昂的内存开销</strong>：<code>prev</code> 和<code>next</code> 指针占据了大量内存，如果 <code>data</code>不够大，那性价比就很低了。</li><li><strong>糟糕的 CPU缓存局部性</strong>：链表的节点在内存中是<strong>离散</strong>分布的。当CPU 遍历链表时，指针跳转的行为极易导致 <strong>CPU CacheMiss</strong>。</li></ul><h4 id="ziplist">2.2.2 Ziplist</h4><p>为了克服 <code>linkedlist</code> 的双重代价，Redis的设计者们创造了一种极其紧凑的数据结构：<strong>压缩列表(ziplist)</strong>。</p><p><code>ziplist</code>的核心思想是，用一块<strong>连续的、完整的内存块</strong>来存储所有元素，从而彻底消除指针开销，并最大化利用CPU 缓存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry_1&gt; &lt;entry_2&gt; ... &lt;entry_N&gt; &lt;zlend&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;zlbytes&gt;</code>: 整个 <code>ziplist</code>占用的总字节数。</li><li><code>&lt;zltail&gt;</code>: 到最后一个 entry的偏移量，用于快速定位到表尾。</li><li><code>&lt;zllen&gt;</code>: entry 的数量。</li><li><code>&lt;entry&gt;</code>: 真正的列表元素，每个 entry也是变长的。</li><li><code>&lt;zlend&gt;</code>: 特殊的结束标记 <code>0xFF</code>。</li></ul><p><code>ziplist</code> 的精髓在于 <code>entry</code> 的设计。每个 entry的头部会记录<strong>前一个 entry</strong> 的长度(<code>prev_len</code>)，这使得 <code>ziplist</code>可以从后向前遍历。</p><p>优点：内存占用小且对 CPU 缓存友好。</p><p>缺点：级联更新。因为 <code>entry</code>包含了前面节点的信息（<code>prev_len</code>），所以前面的节点发生变化时，很容易造成后面节点的级联更新。</p><h4 id="quicklist">2.2.3 Quicklist</h4><p>既然 <code>linkedlist</code> 和 <code>ziplist</code>各有优劣，能否将它们结合起来，取其精华，去其糟粕？<strong>快速列表(quicklist)</strong> 应运而生，并从 Redis 3.2 开始成为 List的默认实现。</p><p><code>quicklist</code> 的本质，就是一个由<code>ziplist</code>（或后来的<code>listpack</code>）节点组成的<strong>双向链表</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----------------+     +----------------+     +----------------+</span><br><span class="line">| quicklistNode  | &lt;-&gt; | quicklistNode  | &lt;-&gt; | quicklistNode  |</span><br><span class="line">| (ziplist/pack) |     | (ziplist/pack) |     | (ziplist/pack) |</span><br><span class="line">+----------------+     +----------------+     +----------------+</span><br><span class="line">         ^                    ^                      ^</span><br><span class="line">         |                    |                      |</span><br><span class="line">   [ e1, e2, e3 ]       [ e4, e5 ]           [ e6, e7, e8, e9 ]</span><br></pre></td></tr></table></figure><p>它在宏观上是一个 <code>linkedlist</code>，保持了 O(1)的头尾插入性能和灵活性。而在微观上，每个节点内部是一个<code>ziplist</code> 或<code>listpack</code>，存储了多个元素，极大地节省了内存，并提升了缓存局部性。<code>quicklist</code>通过将连锁更新的风险<strong>限制</strong>在一个个独立的小节点内部，完美地规避了<code>ziplist</code> 最大的风险。</p><h4 id="listpack">2.2.4 Listpack</h4><p><code>quicklist</code> 虽然将 <code>ziplist</code>的缺点限制在了一个节点之间，但是其缺点依旧存在，为此，<strong>紧凑列表(listpack)</strong>诞生了。它去掉了 <code>prev_len</code>，改为在当前节点内部记录自己的长度<code>back-len</code>（并且经过特殊编码支持反向解码）。修改当前节点，再也不会影响下一个节点的头部的长度了。</p><p>一个 <code>listpack</code> 结构如下：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251209213942454.png" /></p><p>重点在于这个 <code>back-len</code>，它等于该条目自身的<code>encoding-type</code> 和 <code>element-data</code><strong>两部分加起来的长度</strong>（我们称之为"部分长度"）。当需要从后向前遍历时，解析器会从前一个条目的<strong>尾部</strong>，反向解析出这个"部分长度"，然后再动态计算出<code>back-len</code>字段自身的长度，两者相加得到前一个条目的<strong>总长度</strong>，从而实现精确的回溯跳转。</p><h2 id="hash">3. Hash</h2><p>Hash 是一个 String 类型的 Field 和 Value 的映射表。</p><h3 id="核心操作-2">3.1 核心操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础操作</span></span><br><span class="line">HSET key field value          <span class="comment"># 设置字段值（可以同时设置多个字段）</span></span><br><span class="line">HGET key field                <span class="comment"># 获取字段值</span></span><br><span class="line">HMSET key field1 value1 field2 value2  <span class="comment"># 批量设置字段</span></span><br><span class="line">HMGET key field1 field2 field3  <span class="comment"># 批量获取字段</span></span><br><span class="line">HGETALL key                   <span class="comment"># 获取所有字段和值</span></span><br><span class="line">HDEL key field1 field2        <span class="comment"># 删除指定字段</span></span><br><span class="line">HEXISTS key field             <span class="comment"># 检查字段是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字段操作</span></span><br><span class="line">HLEN key                      <span class="comment"># 获取字段数量</span></span><br><span class="line">HKEYS key                     <span class="comment"># 获取所有字段名</span></span><br><span class="line">HVALS key                     <span class="comment"># 获取所有字段值</span></span><br><span class="line">HSTRLEN key field             <span class="comment"># 获取字段值的字符串长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数值操作</span></span><br><span class="line">HINCRBY key field increment   <span class="comment"># 字段值按指定整数递增</span></span><br><span class="line">HINCRBYFLOAT key field increment  <span class="comment"># 字段值按指定浮点数递增</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级操作（Redis 6.2+）</span></span><br><span class="line">HSETNX key field value        <span class="comment"># 仅当字段不存在时设置</span></span><br><span class="line">HRANDFIELD key [count [WITHVALUES]]  <span class="comment"># 随机获取字段</span></span><br></pre></td></tr></table></figure><p><strong>常见使用场景：</strong></p><ul><li><strong>对象缓存</strong>：存储用户信息、商品属性等结构化数据，如<code>user:1001 &#123;name: "张三", age: 25, city: "北京"&#125;</code></li><li><strong>计数器集合</strong>：文章的多维统计，如<code>article:1001 &#123;views: 1000, likes: 50, comments: 20&#125;</code></li><li><strong>配置管理</strong>：系统配置、用户偏好设置等键值对集合</li><li><strong>购物车</strong>：简化版购物车实现，<code>cart:1001 &#123;item_001: 2, item_005: 1&#125;</code></li><li><strong>会话管理</strong>：比 String 更灵活的 session存储，支持细粒度更新</li><li><strong>实时统计</strong>：网站在线用户统计、API调用次数等分组统计场景</li><li><strong>标签系统</strong>：文章标签管理，<code>tags:article_001 &#123;tech: 1, redis: 1, database: 1&#125;</code></li></ul><h3 id="底层原理-2">3.2 底层原理</h3><p>Hash 的底层实现有两种：<strong>Listpack (原 Ziplist)</strong> 和<strong>Hashtable</strong>。</p><table><colgroup><col style="width: 10%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 28%" /><col style="width: 18%" /><col style="width: 12%" /></colgroup><thead><tr><th><strong>编码类型</strong></th><th><strong>Redis 7.0 前</strong></th><th><strong>Redis 7.0 后</strong></th><th><strong>触发条件 (默认配置)</strong></th><th><strong>内存特征</strong></th><th><strong>查询复杂度</strong></th></tr></thead><tbody><tr><td><strong>紧凑型</strong></td><td><strong>Ziplist</strong></td><td><strong>Listpack</strong></td><td>元素数 &lt; 512 且 值长度 &lt; 64 字节</td><td><strong>连续内存</strong>，无指针</td><td><strong>O(N)</strong></td></tr><tr><td><strong>分散型</strong></td><td><strong>Hashtable</strong></td><td><strong>Hashtable</strong></td><td>超过上述任一阈值</td><td><strong>指针+链表</strong>，有碎片</td><td><strong>O(1)</strong></td></tr></tbody></table><blockquote><p>[!NOTE]</p><p><strong>💡 关键点：Hash 的 Listpack 布局</strong> 和 List 不同，Hash在 Listpack 中存储时，是<strong>成对</strong>出现的。<code>[ Key1 | Val1 | Key2 | Val2 | ... ]</code> 查找时，Redis从头遍历，找到 Key 后，紧接着取下一个 Entry 就是 Value。</p></blockquote><p><code>listpack</code> 的存储结构在 List 我们已经介绍过了，这里就介绍Hash 的默认编码格式 <code>hashtable</code>。构成 Redis 哈希表的核心是<code>dict</code> 及其节点 <code>dictEntry</code> 结构，源码可看：<ahref="https://github.com/redis/redis/blob/8.4.0/src/dict.c">src/dict.c</a>。它不仅支撑了Redis 的 Hash 数据类型，更重要的是，<strong>Redis 整个数据库（KV空间）本身就是一个巨大的 Dict</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">/* 指向下一个节点，解决哈希冲突 */</span></span><br><span class="line">    <span class="type">void</span> *key;               <span class="comment">/* 键 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>                  <span class="comment">/* 值（使用联合体优化内存） */</span></span><br><span class="line">        <span class="type">void</span> *val;<span class="comment">/* 通常指向一个 redisObject */</span></span><br><span class="line">        <span class="type">uint64_t</span> u64;<span class="comment">/* 无符号整数 */</span></span><br><span class="line">        <span class="type">int64_t</span> s64;<span class="comment">/* 有符号整数 */</span></span><br><span class="line">        <span class="type">double</span> d;<span class="comment">/* 浮点数 */</span></span><br><span class="line">    &#125; v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;          <span class="comment">/* 类型特定函数 */</span></span><br><span class="line"></span><br><span class="line">    dictEntry **ht_table[<span class="number">2</span>]; <span class="comment">/* 两个哈希表，平时只用[0]，迁移时共用[0]和[1] */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ht_used[<span class="number">2</span>];<span class="comment">/* 两个表已有的节点数量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> rehashidx;          <span class="comment">/* Rehash 进度索引 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> pauserehash;    <span class="comment">/* Rehash 暂停标志 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 紧凑排列的小变量，优化内存填充 */</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> ht_size_exp[<span class="number">2</span>]; <span class="comment">/* 大小的指数 (size = 1 &lt;&lt; exp) */</span></span><br><span class="line">    <span class="type">signed</span> pauseAutoResize: <span class="number">15</span>; <span class="comment">/* 禁止自动扩容标志 */</span></span><br><span class="line">    <span class="type">unsigned</span> useStoredKeyApi: <span class="number">1</span>;</span><br><span class="line">    <span class="type">void</span> *metadata[];           <span class="comment">/* 变长数组，用于存储额外元数据 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>拉链法 (Chaining)</strong>：<code>dictEntry</code> 中的<code>next</code> 指针，是 Redis 解决哈希冲突的基础手段，构建了 bucket内的单向链表。</li><li><strong>双表架构 (Double Tables)</strong>：<code>ht_table[2]</code>是 Redis 实现<strong>无阻塞扩容</strong>的物理基础。通常情况下，只有<code>ht_table[0]</code> 在工作，<code>ht_table[1]</code> 是空的。当<code>ht[0]</code> 满了需要扩容（或缩容）时，Redis并不是在原表上操作，而是先给 <code>ht[1]</code>分配更大的空间（两倍），然后将 <code>ht[0]</code> 的数据慢慢搬到<code>ht[1]</code>。等搬完后，删除 <code>ht[0]</code>，把<code>ht[1]</code> 变成新的 <code>ht[0]</code>。</li><li><strong>渐进式 Rehash (Incremental)</strong>：<code>rehashidx</code>记录当前搬迁到了 <code>ht[0]</code> 的第几个bucket（数组下标）。每次对字典进行增删改查（CRUD）时，顺便把<code>rehashidx</code> 位置的一个 bucket 搬到 <code>ht[1]</code>，然后<code>rehashidx++</code>。不用担心没有请求时就一直不迁移，后台有定时任务<code>serverCron</code> 会包含 rehash操作用于辅助迁移，以避免这个问题。</li></ul><h2 id="set">4. Set</h2><p>Set是一个无序、唯一的字符串元素集合。其核心价值在于高效的成员关系判断（<code>SISMEMBER</code>）和服务器端的集合运算（<code>SINTER</code>,<code>SUNION</code>, <code>SDIFF</code>）。</p><h3 id="核心操作-3">4.1 核心操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础操作</span></span><br><span class="line">SADD key member1 member2        <span class="comment"># 添加成员到集合</span></span><br><span class="line">SREM key member1 member2        <span class="comment"># 从集合中删除成员</span></span><br><span class="line">SPOP key [count]                <span class="comment"># 随机弹出并删除成员</span></span><br><span class="line">SRANDMEMBER key [count]         <span class="comment"># 随机获取成员（不删除）</span></span><br><span class="line">SCARD key                       <span class="comment"># 获取集合成员数量</span></span><br><span class="line">SMEMBERS key                    <span class="comment"># 获取所有成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员判断</span></span><br><span class="line">SISMEMBER key member            <span class="comment"># 检查成员是否存在</span></span><br><span class="line">SMISMEMBER key member1 member2  <span class="comment"># 批量检查成员是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合运算（重要）</span></span><br><span class="line">SINTER key1 key2 key3           <span class="comment"># 计算多个集合的交集</span></span><br><span class="line">SINTERCARD numkeys key1 key2 [key3...] [LIMIT <span class="built_in">limit</span>]  <span class="comment"># 计算交集的基数</span></span><br><span class="line">SINTERSTORE destination key1 key2  <span class="comment"># 计算交集并存储到新集合</span></span><br><span class="line">SUNION key1 key2 key3           <span class="comment"># 计算多个集合的并集</span></span><br><span class="line">SUNIONSTORE destination key1 key2  <span class="comment"># 计算并集并存储到新集合</span></span><br><span class="line">SDIFF key1 key2 key3            <span class="comment"># 计算差集（key1 - key2 - key3）</span></span><br><span class="line">SDIFFSTORE destination key1 key2  <span class="comment"># 计算差集并存储到新集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合操作（Redis 6.2+）</span></span><br><span class="line">SADD key member1 member2 [NX|XX]  <span class="comment"># NX:仅添加不存在的，XX:仅添加已存在的</span></span><br><span class="line">SMOVE <span class="built_in">source</span> destination member   <span class="comment"># 将成员从源集合移动到目标集合</span></span><br></pre></td></tr></table></figure><p><strong>常见使用场景：</strong></p><ul><li><strong>标签系统</strong>：文章标签、用户兴趣标签，<code>SINTER</code>找共同标签，<code>SUNION</code> 找所有标签</li><li><strong>共同好友</strong>：社交网络中找出两个用户的共同好友，<code>SINTER user:1001:friends user:1002:friends</code></li><li><strong>去重统计</strong>：访问用户去重、搜索关键词去重，利用 Set的天然去重特性</li><li><strong>权限控制</strong>：角色权限管理，<code>SADD role:admin user,delete,create</code></li><li><strong>推荐系统</strong>：基于共同兴趣的用户推荐，<code>SINTER user:1001:likes user:1002:likes</code></li><li><strong>黑名单/白名单</strong>：IP黑白名单、用户黑名单等，<code>SISMEMBER</code> 快速判断</li><li><strong>抽奖活动</strong>：<code>SRANDMEMBER</code>随机抽取中奖用户，<code>SPOP</code> 抽取并移除避免重复中奖</li><li><strong>在线用户</strong>：实时在线用户集合，<code>SADD</code>用户上线，<code>SREM</code> 用户下线</li></ul><h3 id="底层原理-3">4.2 底层原理</h3><p>Set 同样采用了双重编码策略，分别是 <code>hashtable</code> 和<code>intset</code>。</p><table><colgroup><col style="width: 20%" /><col style="width: 29%" /><col style="width: 20%" /><col style="width: 30%" /></colgroup><thead><tr><th><strong>编码类型</strong></th><th><strong>场景</strong></th><th><strong>结构描述</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>IntSet</strong> (整数集合)</td><td>元素<strong>全部是整数</strong> 且 数量 &lt; 512</td><td><strong>有序</strong>的整数数组</td><td><strong>二分查找 O(logN)</strong>；极致省内存。</td></tr><tr><td><strong>Hashtable</strong> (哈希表)</td><td>元素包含非整数 或 数量 &gt; 512</td><td>value 为 <code>NULL</code> 的字典</td><td>查询 <strong>O(1)</strong>；内存占用大。</td></tr></tbody></table><p>其中 <code>hashtable</code> 完全复用上文所述的 dict结构。集合中的每个元素被存储为 <code>dictEntry</code> 中的<code>key</code>，而 <code>union v</code> (值) 部分则被忽略（统一设为NULL）。这种设计直接利用了 dict 键的唯一性来保证 Set元素的唯一性，并继承了其 O(1) 的查找性能。</p><p>当一个 Set 满足以下两个条件时，会采用 <code>intset</code> 编码：</p><ol type="1"><li>集合中所有元素均为整数。</li><li>元素数量未超过 <code>set-max-intset-entries</code>配置项的阈值（默认为 512）。</li></ol><p><code>intset</code>是一种自适应整数编码的有序数组。它可以根据存入整数的范围，将内部存储格式动态升级为<code>int16_t</code>, <code>int32_t</code> 或<code>int64_t</code>，以最小的内存空间存储数据。成员查找通过二分搜索算法实现。它的定义位于<ahref="https://github.com/redis/redis/blob/8.4.0/src/intset.h#L35">src/intset.h</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;  <span class="comment">// 当前元素编码宽度：16/32/64 位</span></span><br><span class="line">    <span class="type">uint32_t</span> length;    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];  <span class="comment">// 紧凑存放有序整数</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p><strong>升级机制</strong>：</p><ul><li><p>如果当前存的都是小整数（如 1, 2, 100），数组用 <code>int16</code>存储。</p></li><li><p>当你插入一个大整数（如 65536，超出了 int16 范围），Redis会<strong>将整个数组的所有元素升级</strong>为<code>int32</code>，并重新分配内存。<strong>注意</strong>：IntSet<strong>不支持降级</strong>。一旦升级，这就回不去了。</p></li><li><p>如果你向一个 IntSet 插入了一个字符串（比如"a"），即使之前存的全是整数，Redis 也会立刻将其转换为<strong>Hashtable</strong>。且不可逆：就算你后来把 "a"删了，它也不会变回 IntSet。</p></li></ul><hr /><p>这里简单补充一下 <code>int8_t contents[]</code> 的含义，因为笔者对C/C++ 并不熟悉，所以一开始阅读这个代码定义的时候还觉得很奇怪？</p><blockquote><p>—— 为什么 <code>int8_t[]</code> 类型的数组可以存放<code>int16/int32/int64</code> 的元素？</p></blockquote><p>在 C99 标准中，结构体最后一个元素如果是未知大小的数组（如<code>contents[]</code>），被称为<strong>柔性数组成员</strong>。<code>contents</code>本身不占用 <code>intset</code>结构体的大小（或者只被视为一个偏移量标记）。当我们为 <code>intset</code>分配内存时，会多分配一块连续内存跟在结构体后面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：分配一个包含 10 个 int64 元素的 intset</span></span><br><span class="line"><span class="type">size_t</span> size = <span class="keyword">sizeof</span>(intset) + (<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int64_t</span>));</span><br><span class="line">intset *is = <span class="built_in">malloc</span>(size);</span><br></pre></td></tr></table></figure><p>声明为 <code>int8_t</code>（即 1 字节），是因为在 C语言中，<code>int8_t</code>（或<code>char</code>）是最小的内存寻址单位。这意味着 <code>contents</code>指向的是一块<strong>原始的、未被定义的字节流</strong>。</p><p>Redis 在读取数据时，并不是直接通过下标 <code>contents[i]</code>来读取（那样只能读到 1个字节），而是通过以下逻辑进行<strong>指针强转和偏移计算</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 根据给定的编码方式 (encoding)，返回 intset 中指定位置 (pos) 的元素值。</span></span><br><span class="line"><span class="comment"> * 注意：返回值统一提升为 int64_t，确保能容纳 int16, int32 和 int64。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int64_t</span> _intsetGetEncoded(intset *is, <span class="type">int</span> pos, <span class="type">uint8_t</span> enc) &#123;</span><br><span class="line">    <span class="type">int64_t</span> v64;</span><br><span class="line">    <span class="type">int32_t</span> v32;</span><br><span class="line">    <span class="type">int16_t</span> v16;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 情况 1: 集合存储的是 64 位整数 */</span></span><br><span class="line">    <span class="keyword">if</span> (enc == INTSET_ENC_INT64) &#123;</span><br><span class="line">        <span class="comment">/* * 核心指针运算：</span></span><br><span class="line"><span class="comment">         * 1. (int64_t*)is-&gt;contents : 将 int8_t* 强转为 int64_t*。</span></span><br><span class="line"><span class="comment">         * 这告诉编译器：这里的内存步长是 8 字节。</span></span><br><span class="line"><span class="comment">         * 2. + pos : 指针向后移动 pos * 8 个字节，精准定位到第 pos 个元素。</span></span><br><span class="line"><span class="comment">         * 3. memcpy : 从计算出的地址拷贝 8 个字节到栈变量 v64 中。</span></span><br><span class="line"><span class="comment">         * 使用 memcpy 而不是直接赋值 (v64 = ...)，是为了防止内存未对齐导致的 CPU 异常。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v64,((<span class="type">int64_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v64));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* * 字节序处理：</span></span><br><span class="line"><span class="comment">         * 如果当前 CPU 是大端序 (Big Endian)，则翻转字节顺序为小端序。</span></span><br><span class="line"><span class="comment">         * 如果是小端序 (Little Endian)，此宏不做任何操作。</span></span><br><span class="line"><span class="comment">         * 保证数据在内存中统一以小端序存储，实现跨平台兼容。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        memrev64ifbe(&amp;v64);</span><br><span class="line">        <span class="keyword">return</span> v64;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enc == INTSET_ENC_INT32) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v32,((<span class="type">int32_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v32));</span><br><span class="line">        memrev32ifbe(&amp;v32);</span><br><span class="line">        <span class="keyword">return</span> v32;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v16,((<span class="type">int16_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v16));</span><br><span class="line">        memrev16ifbe(&amp;v16);</span><br><span class="line">        <span class="keyword">return</span> v16;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sorted-set">5. Sorted Set</h2><p>Sorted Set，即 ZSet，它是一个 <code>Member</code> (成员) 到<code>Score</code> (分数) 的有序映射。</p><ul><li><strong>特性</strong>：Member 唯一，Score 可重复。</li><li><strong>排序</strong>：按 Score 从小到大排；Score 相同，按 Member字典序排。</li></ul><h3 id="核心操作-4">5.1 核心操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础操作</span></span><br><span class="line">ZADD key score1 member1 score2 member2  <span class="comment"># 添加成员及其分数</span></span><br><span class="line">ZREM key member1 member2                <span class="comment"># 删除指定成员</span></span><br><span class="line">ZCARD key                              <span class="comment"># 获取集合成员数量</span></span><br><span class="line">ZSCORE key member                      <span class="comment"># 获取成员分数</span></span><br><span class="line">ZCOUNT key min max                     <span class="comment"># 统计指定分数范围内的成员数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 排名查询（重要）</span></span><br><span class="line">ZRANK key member                       <span class="comment"># 获取成员排名（从0开始，分数从小到大）</span></span><br><span class="line">ZREVRANK key member                    <span class="comment"># 获取反向排名（分数从大到小）</span></span><br><span class="line">ZRANGE key start stop [BYSCORE|BYLEX] [REV] [LIMIT offset count] [WITHSCORES]  <span class="comment"># 获取排名范围内成员</span></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]  <span class="comment"># 获取反向排名范围内成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分数范围查询</span></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]     <span class="comment"># 按分数范围查询</span></span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]  <span class="comment"># 按分数范围反向查询</span></span><br><span class="line">ZREMRANGEBYRANK key start stop         <span class="comment"># 按排名范围删除成员</span></span><br><span class="line">ZREMRANGEBYSCORE key min max           <span class="comment"># 按分数范围删除成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分数操作</span></span><br><span class="line">ZINCRBY key increment member           <span class="comment"># 增加指定成员的分数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合运算</span></span><br><span class="line">ZINTERSTORE destination numkeys key1 key2 [WEIGHTS w1 w2] [AGGREGATE SUM|MIN|MAX]  <span class="comment"># 计算交集</span></span><br><span class="line">ZUNIONSTORE destination numkeys key1 key2 [WEIGHTS w1 w2] [AGGREGATE SUM|MIN|MAX]  <span class="comment"># 计算并集</span></span><br><span class="line">ZDIFFSTORE destination numkeys key1 key2  <span class="comment"># 计算差集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典序操作（Redis 6.2+）</span></span><br><span class="line">ZLEXCOUNT key min max                  <span class="comment"># 统计字典序范围内的成员数量</span></span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]  <span class="comment"># 按字典序范围查询</span></span><br><span class="line">ZREMRANGEBYLEX key min max             <span class="comment"># 按字典序范围删除</span></span><br><span class="line">ZMSCORE key member1 member2 member3    <span class="comment"># 批量获取成员分数</span></span><br></pre></td></tr></table></figure><p><strong>常见使用场景：</strong></p><ul><li><strong>排行榜系统</strong>：游戏积分榜、文章热度榜、用户财富榜，<code>ZRANGE/ZREVRANGE</code>获取 Top N</li><li><strong>延迟队列</strong>：以时间戳为分数，实现定时任务调度，<code>ZRANGEBYSCORE</code>获取到期任务</li><li><strong>优先级队列</strong>：任务优先级管理，高优先级任务分数更高，<code>ZPOPMAX</code>获取最高优先级任务</li><li><strong>范围搜索</strong>：价格区间商品查询、年龄范围用户筛选，<code>ZRANGEBYSCORE</code>高效范围查询</li><li><strong>加权投票</strong>：用户投票系统，投票时间越新权重越高（时间戳作为分数）</li><li><strong>实时统计</strong>：热门搜索词排行，搜索次数作为分数，<code>ZINCRBY</code>实时更新</li><li><strong>教育资源</strong>：学生成绩管理，分数直接作为 zset分数，<code>ZRANK</code> 获取排名</li><li><strong>地理位置排序</strong>：虽然有 Geo 类型，但 zset可以实现更复杂的排序逻辑</li></ul><h3 id="底层原理-4">5.2 底层原理</h3><p>Set 同样采用了双重编码策略，分别是 <code>ziplist/listpack</code> 和<code>skiplist+dict</code>。</p><table style="width:100%;"><colgroup><col style="width: 19%" /><col style="width: 23%" /><col style="width: 34%" /><col style="width: 22%" /></colgroup><thead><tr><th><strong>编码类型</strong></th><th><strong>场景</strong></th><th><strong>结构描述</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>紧凑型</strong> (Ziplist / Listpack)</td><td>元素少（&lt; 128）且 元素小（&lt; 64 字节）</td><td><strong>紧凑数组</strong>。Member 和 Score 紧挨着存，按 Score排序。</td><td>省内存；插入/查询 <strong>O(N)</strong>。</td></tr><tr><td><strong>分散型</strong> (Skiplist + Dict)</td><td>超过阈值</td><td><strong>跳表 + 哈希表</strong> (双重索引)。</td><td>查询/插入 <strong>O(logN)</strong>；内存占用大。</td></tr></tbody></table><p>相信对阅读到了这里的读者来说，已经不会对 ZSet 使用<code>listpack</code> 感到意外了，这是 Redis里典型的用时间换空间的策略了。</p><p>当 Sorted Set 中存储的元素数量很少，并且每个元素的值都不大时，Redis会选择 <code>listpack</code> 编码。</p><p>条件是：</p><ul><li>元素数量小于 <code>zset-max-listpack-entries 128</code></li><li>所有元素值的字节长度小于<code>zset-max-listpack-value 64</code></li></ul><p>它将每个 (member, score)对紧凑地序列化存储。为了保持有序，每次插入都需要找到正确的位置，这可能导致其后的数据发生移动。当<code>N</code> 非常小（例如小于 128）时，𝑂(𝑁)的操作成本极低，几乎是瞬时的，而节省下来的内存却非常可观。</p><p>一旦 <code>listpack</code> 的任一触发条件被打破，Redis会自动将其转换为 <code>skiplist</code> + <code>dict</code> 编码。其实ZSet要采用"双引擎"模式，也不难理解，它要解决的核心矛盾是：<strong>如何创建一个既能通过成员（member）快速查找、又能根据分数（score）高效排序和范围查找的数据集合？</strong></p><ul><li><strong><code>dict</code>(字典/哈希表)</strong>：负责"集合"的部分。它建立了一个从<code>member</code> 到 <code>score</code> 的映射。这使得<code>ZSCORE</code> 这种通过成员获取分数的操作，时间复杂度 𝑂(1)。</li><li><strong><code>skiplist</code>(跳表)</strong>：负责"排序"的部分。它将所有的<code>(score, member)</code> 对按照 <code>score</code>（分数相同则按<code>member</code>字典序）进行排序。跳表的特性使得插入、删除和按排名/分数范围查找的平均时间复杂度都是𝑂(𝑙𝑜𝑔𝑁)。</li></ul><blockquote><p>为了节约内存，<code>dict</code> 和 <code>skiplist</code> 中的<code>member</code> 字符串是共享的，即它们都指向同一个<code>SDS (Simple Dynamic String)</code> 对象。</p></blockquote><p>跳表的核心思想是<strong>空间换时间</strong>和<strong>随机化</strong>。</p><p>想象一下，一个普通的单链表，查找效率是𝑂(𝑁)。现在，我们从这个链表中，随机抽取一些节点，给它们增加一个"上层指针"，指向下一个被抽取的节点。这样我们就构建了第2 层"快速通道"。我们可以不断重复这个过程，构建出多层快速通道。</p><p>当我们要查找一个元素时：</p><ol type="1"><li>从最高层的"快速通道"开始。</li><li>在当前层向右查找，直到找到的下一个节点比目标大，或者到了链表末尾。</li><li>然后从当前节点下降一层，重复步骤 2。</li><li>最终在最底层（原始链表）找到目标位置。</li></ol><p>因为高层索引可以让你"跳过"大量节点，所以平均查找效率被提升到了𝑂(𝑙𝑜𝑔𝑁)。而这种层级的建立是完全随机的，它通过概率来维持整体的平衡，避免了红黑树那样复杂的平衡操作。</p><p>这就是 Redis选择跳表的原因：<strong>用更简单的实现，达到了与平衡树相媲美的性能。</strong></p><p>在 Redis 8.4.0 的源码中，关于 <code>zset</code> 的类型定义位于 <ahref="https://github.com/redis/redis/blob/8.4.0/src/server.h#L1599">src/server.h</a>文件中。如下所示，它主要包含 3个核心数据结构：<code>zset</code>、<code>zskiplist</code> 和<code>zskiplistNode</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;          <span class="comment">/* 成员字符串 */</span></span><br><span class="line">    <span class="type">double</span> score;     <span class="comment">/* 分值（排序主键） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">/* 反向遍历指针（指向前一个节点） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">/* 本层前进指针 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;            <span class="comment">/* 到 forward 的节点数，用于排名计算 */</span></span><br><span class="line">    &#125; level[];        <span class="comment">/* 可变层高的层数组 */</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span> <span class="comment">/* 哨兵头/尾 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;                <span class="comment">/* 节点总数 */</span></span><br><span class="line">    <span class="type">int</span> level;                           <span class="comment">/* 当前最高层数 */</span></span><br><span class="line">    <span class="type">size_t</span> alloc_size;                   <span class="comment">/* 内存统计 */</span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zset 结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;        <span class="comment">/* 成员 -&gt; score 映射，O(1) 查找/判重 */</span></span><br><span class="line">    zskiplist *zsl;    <span class="comment">/* 按 score+字典序排序的跳表，支持范围/排名 */</span></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>从比较直观的角度来讲的话，跳表的结构可以用下图来演示：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250918190254554.png" /></p><p>如果要完全复刻上述所定义出来的数据结构，那表示起来可能会有点复杂，这里我画了张图，供你参考：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250918190417220.png" /></p><p>本篇限于篇幅原因和阅读性价比的关系，笔者对绝大多数数据结构都不太愿意展开源码，不过介于skiplist是一个非常常考的点，也是一个比较艺术性的实现，所以在本章节我们将从一个最核心的<strong>插入</strong>逻辑来更进一步了解跳表的实现细节。<code>zset</code> 的核心实现逻辑位于 <ahref="https://github.com/redis/redis/blob/8.4.0/src/t_zset.c#L140">src/t_zset.c</a>文件中，其中插入操作由 <code>zslInsert</code>函数来实现。这里我先把完整的代码和注释给你，接下来我们再一一拆解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在跳表中插入一个新节点。</span></span><br><span class="line"><span class="comment"> * 假设：调用者已经检查过该元素不存在（Redis 在调用此函数前会在 dict 中检查）。</span></span><br><span class="line"><span class="comment"> * 注意：跳表会接管传入的 SDS 字符串 &#x27;ele&#x27; 的所有权。*/</span></span><br><span class="line">zskiplistNode *<span class="title function_">zslInsert</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, sds ele)</span> &#123;</span><br><span class="line">    <span class="comment">// update[]: 记录每一层中，新节点应该插入在哪个节点之后（即前驱节点）</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="comment">// rank[]: 记录 update[i] 节点在整个链表中的排名（从头节点到该节点的跨度之和）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="type">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * 步骤 1: 自顶向下查找插入位置</span></span><br><span class="line"><span class="comment">     * ---------------------------------------------------------------------- */</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 计算 rank:</span></span><br><span class="line"><span class="comment">         * 如果是最高层，rank 初始为 0。</span></span><br><span class="line"><span class="comment">         * 否则，rank 继承上一层已经走过的步数 (rank[i+1])。</span></span><br><span class="line"><span class="comment">         * 这实现了路径累加：比如 L3 走了 10 步，降到 L2 时，起点就是 10。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 向后遍历：直到下一个节点的 score &gt;= 新 score (或 score 相等但 ele 字典序更大) */</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 累加经过的跨度 span 到 rank[i]</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录第 i 层的前驱节点</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此时，rank[0] 保存的是插入位置前一个节点的总排名 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * 步骤 2: 生成随机层数</span></span><br><span class="line"><span class="comment">     * ---------------------------------------------------------------------- */</span></span><br><span class="line">    <span class="comment">// 幂次定律随机生成层数 (1/4 概率)</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新生成的层数比当前跳表最高层还高</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="comment">// 初始化多出来的层级</span></span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 新层级的前驱自然是 header</span></span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            <span class="comment">// header 在这些新层级的 span 暂时覆盖整个链表长度</span></span><br><span class="line">            <span class="comment">// (因为 header 后直接就是 NULL，或者即将插入的新节点)</span></span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level; <span class="comment">// 更新跳表最大层数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * 步骤 3: 创建节点并调整指针与 Span (最难点)</span></span><br><span class="line"><span class="comment">     * ---------------------------------------------------------------------- */</span></span><br><span class="line">    x = zslCreateNode(zsl,level,score,ele);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐层处理指针链接和 span 计算</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">// 标准的链表插入操作:</span></span><br><span class="line">        <span class="comment">// NewNode-&gt;Next = PrevNode-&gt;Next</span></span><br><span class="line">        <span class="comment">// PrevNode-&gt;Next = NewNode</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 计算 span 的逻辑：</span></span><br><span class="line"><span class="comment">         * update[i]-&gt;level[i].span 是原先 update[i] 到其下一个节点的距离。</span></span><br><span class="line"><span class="comment">         * 现在中间插了个 x。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * rank[0]: 插入点之前的总排名。</span></span><br><span class="line"><span class="comment">         * rank[i]: update[i] 节点的总排名。</span></span><br><span class="line"><span class="comment">         * (rank[0] - rank[i]): update[i] 和 实际插入点(L0层) 之间的距离。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 设置新节点 x 的 span</span></span><br><span class="line">        <span class="comment">// x 的 span = 原前驱的 span - (前驱到 x 的距离)</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 更新前驱节点 update[i] 的 span</span></span><br><span class="line">        <span class="comment">// 前驱的 span = (前驱到 x 的距离) + 1 (这个 1 是 x 节点本身)</span></span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于比新节点层数更高的层级，结构没变，只是底层多了一个节点</span></span><br><span class="line">    <span class="comment">// 所以这些层级的 span 只需要简单的 +1</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * 步骤 4: 设置后退指针 (用于 L0 层双向遍历)</span></span><br><span class="line"><span class="comment">     * ---------------------------------------------------------------------- */</span></span><br><span class="line">    <span class="comment">// 如果前驱是 header，backward 设为 NULL (header 不作为数据节点)</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置下一个节点的 backward 指向新节点 x</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果 x 是最后一个节点，更新 tail 指针</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line"></span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作主要分为四个步骤：</p><ol type="1"><li><strong>查找插入位置（Search）</strong>：从最高层往下找，记录每层的前驱节点（<code>update[]</code>）和到达前驱节点的排名（<code>rank[]</code>）。</li><li><strong>生成随机层数（RandomLevel）</strong>：决定新节点的高度。如果比当前跳表高，需要初始化高层的前驱。</li><li><strong>创建节点与链接（Link）</strong>：调整指针，在 <code>0</code>到 <code>level-1</code>的每一层中将新节点插入链表，并<strong>极其精细地计算新旧节点的 span值</strong>。</li><li><strong>收尾工作</strong>：更新高层的 span（只加1），设置后退指针，更新长度。</li></ol><p>接下来我们来一一拆解这段代码的每一个细节。</p><p><strong>第 0 步：初始化与准备</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zskiplistNode *<span class="title function_">zslInsert</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, sds ele)</span> &#123;</span><br><span class="line">    <span class="comment">// update[]: 记录每一层中，新节点应该插入在哪个节点之后（即前驱节点）</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="comment">// rank[]: 记录 update[i] 节点在整个链表中的排名（从头节点到该节点的跨度之和）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="type">int</span> i, level;</span><br></pre></td></tr></table></figure><ul><li><code>zskiplistNode *update[ZSKIPLIST_MAXLEVEL]</code>:<strong>路径记录仪</strong>。它是一个指针数组，<code>update[i]</code>将用于存储新节点在第 <code>i</code>层的前驱节点。为什么需要它？因为插入操作的本质就是在<code>update[i]</code>和它原来的下一个节点之间，插入我们的新节点。这个数组为我们保存了所有需要修改的连接点。</li><li><code>unsigned long rank[ZSKIPLIST_MAXLEVEL]</code>:<strong>距离计数器</strong>。<code>rank[i]</code> 用于记录从跳表<code>header</code> 头节点出发，到达 <code>update[i]</code>这个节点时，在最底层（第 0层）总共跨越了多少个节点。它的核心作用是为后续精确计算和更新节点的<code>span</code>（跨度）提供数据支持，这是 <code>ZRANK</code>命令能够实现 𝑂(𝑙𝑜𝑔𝑁) 的基石。</li></ul><p><strong>第 1 步：查找插入位置并记录路径</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">x = zsl-&gt;header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 步骤 1: 自顶向下查找插入位置</span></span><br><span class="line"><span class="comment"> * ---------------------------------------------------------------------- */</span></span><br><span class="line"><span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">/* 计算 rank:</span></span><br><span class="line"><span class="comment">     * 如果是最高层，rank 初始为 0。</span></span><br><span class="line"><span class="comment">     * 否则，rank 继承上一层已经走过的步数 (rank[i+1])。</span></span><br><span class="line"><span class="comment">     * 这实现了路径累加：比如 L3 走了 10 步，降到 L2 时，起点就是 10。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向后遍历：直到下一个节点的 score &gt;= 新 score (或 score 相等但 ele 字典序更大) */</span></span><br><span class="line">    <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 累加经过的跨度 span 到 rank[i]</span></span><br><span class="line">        rank[i] += x-&gt;level[i].span;</span><br><span class="line">        x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录第 i 层的前驱节点</span></span><br><span class="line">    update[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是跳表算法的精髓所在——<strong>分层查找</strong>。</p><ul><li><code>for (i = zsl-&gt;level-1; i &gt;= 0; i--)</code>:循环从最高层（<code>zsl-&gt;level-1</code>）开始，逐层下降到最底层（<code>0</code>）。这模仿了我们在地图上查找位置的过程：先看洲际地图（高层），再看国家地图（中层），最后看城市街道图（底层）。高层级的"快速通道"可以让我们一次性跳过大量节点。</li><li><code>while (...)</code>: 在当前层级，不断向右移动。判断条件<code>(score &lt; ... || (score == ... &amp;&amp; ele &lt; ...))</code>保证了跳表的排序规则：优先按 <code>score</code> 升序，如果<code>score</code> 相同，则按 <code>member</code> 的字典序升序。</li><li><code>rank[i] += x-&gt;level[i].span;</code>: 这是 <code>rank</code>数组工作的核心。每当我们从 <code>x</code>节点跳到它的下一个节点时，并不是只前进了一步，而是前进了<code>x-&gt;level[i].span</code> 步。我们将这个跨度累加到<code>rank[i]</code> 中，<code>rank[i]</code>就实时记录了我们距离起点的总步数。</li><li><code>update[i] = x;</code>: 当 <code>while</code>循环结束时，<code>x</code> 节点就是新节点在第 <code>i</code>层的前驱节点。我们将其记录在 <code>update[i]</code> 中。当整个<code>for</code> 循环结束后，<code>update</code>数组就完整记录了从最高层到最底层的一条插入路径。</li></ul><p><strong>第 2 步：确定新节点层高并处理新层级</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 步骤 2: 生成随机层数</span></span><br><span class="line"><span class="comment"> * ---------------------------------------------------------------------- */</span></span><br><span class="line"><span class="comment">// 幂次定律随机生成层数 (1/4 概率)</span></span><br><span class="line">level = zslRandomLevel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果新生成的层数比当前跳表最高层还高</span></span><br><span class="line"><span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">    <span class="comment">// 初始化多出来的层级</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 新层级的前驱自然是 header</span></span><br><span class="line">        update[i] = zsl-&gt;header;</span><br><span class="line">        <span class="comment">// header 在这些新层级的 span 暂时覆盖整个链表长度</span></span><br><span class="line">        <span class="comment">// (因为 header 后直接就是 NULL，或者即将插入的新节点)</span></span><br><span class="line">        update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;level = level; <span class="comment">// 更新跳表最大层数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>level = zslRandomLevel()</code>:新节点将拥有几层"快速通道"？这里不是由复杂的平衡算法决定，而是通过一个简单的概率函数随机生成。大部分节点只有1层，极少数节点会有很高的层数。正是这种随机性，使得跳表在整体上能够维持一个高效的对数级结构。</li><li><code>if (level &gt; zsl-&gt;level)</code>:处理一个特殊情况。如果随机出的 <code>level</code>比当前跳表的最大层数还大，意味着我们需要为整个跳表加盖新的楼层。在这些新楼层，路径上的前驱节点自然就是<code>header</code> 节点，并且它到 <code>NULL</code>的跨度就是整个跳表的长度 <code>zsl-&gt;length</code>。</li></ul><p><strong>第 3 步：节点创建、链接与跨度更新</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 步骤 3: 创建节点并调整指针与 Span (最难点)</span></span><br><span class="line"><span class="comment"> * ---------------------------------------------------------------------- */</span></span><br><span class="line">x = zslCreateNode(zsl,level,score,ele);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐层处理指针链接和 span 计算</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">    <span class="comment">// 标准的链表插入操作:</span></span><br><span class="line">    <span class="comment">// NewNode-&gt;Next = PrevNode-&gt;Next</span></span><br><span class="line">    <span class="comment">// PrevNode-&gt;Next = NewNode</span></span><br><span class="line">    x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">    update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算 span 的逻辑：</span></span><br><span class="line"><span class="comment">     * update[i]-&gt;level[i].span 是原先 update[i] 到其下一个节点的距离。</span></span><br><span class="line"><span class="comment">     * 现在中间插了个 x。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * rank[0]: 插入点之前的总排名。</span></span><br><span class="line"><span class="comment">     * rank[i]: update[i] 节点的总排名。</span></span><br><span class="line"><span class="comment">     * (rank[0] - rank[i]): update[i] 和 实际插入点(L0层) 之间的距离。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 设置新节点 x 的 span</span></span><br><span class="line">    <span class="comment">// x 的 span = 原前驱的 span - (前驱到 x 的距离)</span></span><br><span class="line">    x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新前驱节点 update[i] 的 span</span></span><br><span class="line">    <span class="comment">// 前驱的 span = (前驱到 x 的距离) + 1 (这个 1 是 x 节点本身)</span></span><br><span class="line">    update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是整个插入过程中最核心的逻辑：</p><p><strong>链接 <code>forward</code> 指针</strong>:这两行是经典的链表插入操作。假设原来是<code>A -&gt; C</code>，<code>A</code> 就是<code>update[i]</code>，<code>C</code> 就是<code>update[i]-&gt;level[i].forward</code>。现在，我们将新节点<code>x</code> 插入其中，变为 <code>A -&gt; x -&gt; C</code>。</p><p><strong>更新 <code>span</code> (跨度)</strong>:这是最精妙的部分，我们用一个例子来说明。</p><ul><li>假设在第 <code>i</code> 层，前驱节点 <code>A</code> (即<code>update[i]</code>) 原来的 <code>span</code> 是<code>10</code>，它直接指向 <code>C</code>。</li><li>我们在第 0 层（最底层）的查找过程中，从 <code>A</code>之后，又前进了 3 步才找到插入点。这意味着 <code>rank[0] - rank[i]</code>的值是 3（可以理解为 A 在高层和底层之间的投影偏差）。</li><li><code>update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;</code>:<code>A</code> 的新 <code>span</code> 变为<code>3 + 1 = 4</code>。因为它现在指向新节点<code>x</code>，它俩之间跨越了 <code>3</code> 个旧节点，加上<code>x</code> 本身，总共是 <code>4</code> 步。</li><li><code>x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);</code>:新节点 <code>x</code> 的 <code>span</code> 等于 <code>A</code>的<strong>旧</strong> <code>span</code> (<code>10</code>)减去它俩之间的距离 (<code>3</code>)，等于 <code>7</code>。</li></ul><blockquote><p><strong>验证</strong>: 插入后，<code>A</code> 的新 <code>span</code>(4) + <code>x</code> 的新 <code>span</code> (7) = <code>11</code>。而<code>A</code> 的旧 <code>span</code> 是 <code>10</code>。总跨度增加了<code>1</code>，正好等于新加入的节点数量。完美！</p></blockquote><p>另外，对于那些高于新节点 <code>level</code>的层级，新节点并不会被插入。但是，由于整个跳表的总长度增加了1，这些更高层级上、位于插入路径上的前驱节点（<code>update[i]</code>），它们指向的下一个节点的相对距离也增加1。因此，它们的 <code>span</code> 值需要递增。</p><p><strong>第 4 步：更新后退指针和表尾</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 步骤 4: 设置后退指针 (用于 L0 层双向遍历)</span></span><br><span class="line"><span class="comment"> * ---------------------------------------------------------------------- */</span></span><br><span class="line"><span class="comment">// 如果前驱是 header，backward 设为 NULL (header 不作为数据节点)</span></span><br><span class="line">x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置下一个节点的 backward 指向新节点 x</span></span><br><span class="line"><span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">    x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 如果 x 是最后一个节点，更新 tail 指针</span></span><br><span class="line">    zsl-&gt;tail = x;</span><br><span class="line"></span><br><span class="line">zsl-&gt;length++;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure><ul><li><code>x-&gt;backward = ...</code>:跳表的最底层（<code>level[0]</code>）是一个<strong>双向链表</strong>，<code>backward</code>指针用于支持 <code>ZREVRANGE</code>等反向遍历命令。这里将新节点的后退指针正确地指向它的前驱节点<code>update[0]</code>。</li><li><code>if...else...</code>: 更新新节点的后继节点的<code>backward</code> 指针，让它指向新节点<code>x</code>。如果新节点是最后一个节点，则更新整个跳表的<code>tail</code> 指针。</li><li><code>zsl-&gt;length++</code>: 最后，将跳表的总长度加 1。</li></ul><p>至此，一个新节点被天衣无缝地织入了跳表这张大网中，所有相关的指针和跨度信息都得到了原子性的更新。</p><h2 id="bitmap">6. Bitmap</h2><p><code>Bitmap</code>（位图） 利用 String的二进制位（Bit）来存数据，适用于处理 bit 级别的数据。因为 SDS 最大512MB，所以 Bitmap 最多能存 <span class="math inline">\(2^{32}\)</span>(约 40 亿) 个 bit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础位操作</span></span><br><span class="line">SETBIT key offset value          <span class="comment"># 设置指定偏移量的位值（0或1）</span></span><br><span class="line">GETBIT key offset                <span class="comment"># 获取指定偏移量的位值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 位统计</span></span><br><span class="line">BITCOUNT key [start end]         <span class="comment"># 统计位图中值为1的位数</span></span><br><span class="line">BITPOS key bit [start end]       <span class="comment"># 查找第一个指定值的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 位运算（重要）</span></span><br><span class="line">BITOP operation destkey key1 key2 ...  <span class="comment"># 位运算操作</span></span><br><span class="line">  <span class="comment"># operation: AND(与), OR(或), XOR(异或), NOT(非)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串和位图转换</span></span><br><span class="line">BITFIELD key [GET <span class="built_in">type</span> offset] [SET <span class="built_in">type</span> offset value] [INCRBY <span class="built_in">type</span> offset increment]  <span class="comment"># 位域操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展命令（Redis 6.2+）</span></span><br><span class="line">BITFIELD_RO key [GET <span class="built_in">type</span> offset] ...  <span class="comment"># 只读的位域操作</span></span><br></pre></td></tr></table></figure><p><strong>常见使用场景：</strong></p><ul><li><strong>用户签到</strong>：用位表示用户每日签到状态，1表示已签到，<code>BITCOUNT</code> 统计月签到天数</li><li><strong>在线状态</strong>：用户在线/离线状态跟踪，<code>SETBIT user:online 1001 1</code>表示用户 1001 在线</li><li><strong>权限管理</strong>：RBAC权限系统，每位代表一种权限，<code>BITOP AND</code> 实现权限交集</li><li><strong>布隆过滤器底层</strong>：实现自定义布隆过滤器的基础数据结构</li><li><strong>用户特征</strong>：用户画像标签系统，1表示有该特征，<code>BITOP OR</code> 找相似用户</li><li><strong>A/B 测试</strong>：用户分组标识，0 为对照组，1 为实验组</li><li><strong>数据统计</strong>：日活用户统计，<code>BITOP OR</code>合并多日活跃用户计算总活跃数</li><li><strong>去重统计</strong>：大量 ID 去重，使用位图存储已见过的ID，节省内存</li><li><strong>游戏系统</strong>：成就系统解锁状态，每个成就对应一个位，<code>BITCOUNT</code>统计解锁数量</li></ul><h2 id="hyperloglog">7. HyperLogLog</h2><p><code>HyperLogLog</code>是一个概率数据结构，用于估计集合的基数。它的底层也是 String 类型。每个<code>HyperLogLog</code> 最多消耗 12KB 的内存，在标准误差 0.81%的前提下，可以计算 <span class="math inline">\(2^{64}\)</span>个元素的基数。</p><h3 id="核心操作-5">7.1 核心操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础操作</span></span><br><span class="line">PFADD key element1 element2 ...  <span class="comment"># 添加元素到 HyperLogLog</span></span><br><span class="line">PFCOUNT key1 key2 key3 ...       <span class="comment"># 获取一个或多个 HyperLogLog 的基数估计</span></span><br><span class="line">PFMERGE destkey source1 source2 ...  <span class="comment"># 合并多个 HyperLogLog 到目标键</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实用命令组合</span></span><br><span class="line"><span class="comment"># 创建并初始化</span></span><br><span class="line">PFADD daily_users_20231201 <span class="string">&quot;user_1001&quot;</span> <span class="string">&quot;user_1002&quot;</span> <span class="string">&quot;user_1003&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看基数估计</span></span><br><span class="line">PFCOUNT daily_users_20231201</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并多日数据</span></span><br><span class="line">PFMERGE month_users daily_users_20231201 daily_users_20231202 daily_users_20231203</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多键统计</span></span><br><span class="line">PFCOUNT week_users month_users  <span class="comment"># 可以同时查询多个键的合并基数</span></span><br></pre></td></tr></table></figure><p><strong>常见使用场景：</strong></p><ul><li><strong>UV 统计</strong>：网站/APP日活、月活用户统计，<code>PFADD</code>记录用户访问，<code>PFCOUNT</code> 获取 UV 数量</li><li><strong>大数据去重</strong>：海量数据去重统计，如日志分析中的独立 IP统计</li><li><strong>实时统计</strong>：社交平台的活跃用户数、电商平台的访客数等实时去重统计</li><li><strong>用户行为分析</strong>：页面浏览量去重、搜索关键词去重统计</li><li><strong>广告曝光</strong>：广告独立曝光人数统计，避免重复计算同一用户</li><li><strong>数据分析</strong>：A/B测试中的独立用户数统计、转化漏斗的去重计数</li><li><strong>监控告警</strong>：系统独立错误触发次数、独立异常 IP统计</li><li><strong>内容分发</strong>：视频独立观看人数、文章独立阅读数统计</li></ul><h3 id="底层原理-5">7.2 底层原理</h3><p><code>HyperLogLog</code>使用概率算法来统计集合的近似基数，而概率算法的本质是伯努利试验（BernoulliTrial），伯努利试验可以看作一个抛硬币过程。</p><p>假设我们玩抛硬币游戏，我让你一直抛，直到抛出"正面"为止，这算一轮。</p><p>我们记录每一轮中，"反面"连续出现的次数（也就是前导 0 的个数）。</p><ul><li><strong>情况 1</strong>：你抛了 1 次就出了正面。前导 0 个数 =0。</li><li><strong>情况 2</strong>：你抛了 2 次（反、正）。前导 0 个数 =1。</li><li>...</li><li><strong>情况N</strong>：如果你告诉我，你刚刚那一轮，<strong>连续抛了 10次反面</strong>才出正面（前导 0 = 10）。</li></ul><p>推断：连续抛 10 次反面的概率是 <span class="math inline">\((1/2)^{10}= 1/1024\)</span>。</p><p>如果你能做到这件事，我不仅认为你运气好，我更有理由相信：你肯定已经在背后偷偷抛了很多很多轮（大概1024轮左右），才碰巧出现了一次这么罕见的情况。所以我们可以通过观察<strong>一组随机数</strong>（Hash值）中<strong>"最大前导 0的个数"</strong>，来反推这组随机数大概有多少个（基数）。</p><table style="width:100%;"><colgroup><col style="width: 28%" /><col style="width: 26%" /><col style="width: 18%" /><col style="width: 26%" /></colgroup><thead><tr><th><strong>二进制形态</strong></th><th><strong>描述</strong></th><th><strong>概率</strong></th><th><strong>倒数 (预估数量)</strong></th></tr></thead><tbody><tr><td><code>1...</code></td><td>开头是 1 (0 个零)</td><td><span class="math inline">\(1/2\)</span> (50%)</td><td><span class="math inline">\(2^1 = 2\)</span></td></tr><tr><td><code>01...</code></td><td>开头是 01 (1 个零)</td><td><span class="math inline">\(1/4\)</span> (25%)</td><td><span class="math inline">\(2^2 = 4\)</span></td></tr><tr><td><code>001...</code></td><td>开头是 001 (2 个零)</td><td><span class="math inline">\(1/8\)</span> (12.5%)</td><td><span class="math inline">\(2^3 = 8\)</span></td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr><td><code>00...01</code> (<span class="math inline">\(k\)</span>个零)</td><td>开头 <span class="math inline">\(k\)</span> 个 0</td><td><span class="math inline">\(1 / 2^{k+1}\)</span></td><td><strong><span class="math inline">\(2^{k+1}\)</span></strong></td></tr></tbody></table><p>如果只依据一次运气最好的记录（最大前导0）来估算，偶然性太大（比如我第一次就走了狗屎运抛了 10个反面，你不能说我抛了 1000 次）。</p><p><code>HyperLogLog</code> 引入了 分桶（Bucketing）的概念：</p><ol type="1"><li>把数据分成 <span class="math inline">\(m\)</span> 个桶。</li><li>分别统计每个桶里的最大前导 0。</li><li>对这些桶的结果求<strong>调和平均数</strong>（而不是算术平均数），以消除极端值（离群点）的影响。</li></ol><blockquote><p>算术平均数（Arithmetic Mean）我们都懂：加起来除以 N。</p><p><span class="math display">\[A = \frac{x_1 + x_2}{2}\]</span></p><p>调和平均数是：倒数的平均数，再取倒数。</p><p><span class="math display">\[H = \frac{2}{\frac{1}{x_1} + \frac{1}{x_2}}\]</span></p><p>调和平均数对小数值更敏感，而对大数值（离群值）不敏感。Redis就是通过这 16384 个桶的调和平均数，把"运气"成分对冲掉，最终让误差稳定在<strong>0.81%</strong> 左右。</p></blockquote><p>Redos 内部使用字符串 Bitmap 来存储 <code>HyperLogLog</code>所有桶的计数值，一共包含 <spanclass="math inline">\(2^{14}=16384\)</span> 个桶，每个桶都是一个 6bit的数组。<code>HyperLogLog</code> 的头部定义位于：<ahref="https://github.com/redis/redis/blob/8.4.0/src/hyperloglog.c#L181">src/hyperloglog.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HLL_P 14 <span class="comment">/* The greater is P, the smaller the error. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HLL_Q (64-HLL_P) <span class="comment">/* The number of bits of the hash value used for</span></span></span><br><span class="line"><span class="comment"><span class="meta">                            determining the number of leading zeros. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HLL_REGISTERS (1&lt;&lt;HLL_P) <span class="comment">/* With P=14, 16384 registers. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HLL_P_MASK (HLL_REGISTERS-1) <span class="comment">/* Mask to index register. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HLL_BITS 6 <span class="comment">/* Enough to count up to 63 leading zeroes. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HyperLogLog 头部：</span></span><br><span class="line"><span class="comment"> * magic：固定标识 &quot;HYLL&quot;，用于持久化格式识别。</span></span><br><span class="line"><span class="comment"> * encoding：两种存储模式</span></span><br><span class="line"><span class="comment"> *   - HLL_DENSE：每个寄存器 6 bit，16K 寄存器共约 12288 字节，元素多时内存固定。</span></span><br><span class="line"><span class="comment"> *   - HLL_SPARSE：稀疏 RLE/指令流压缩，元素少时占用小，超过阈值自动转为 DENSE。</span></span><br><span class="line"><span class="comment"> * notused[3]：保留位，必须为 0。</span></span><br><span class="line"><span class="comment"> * card[8]：缓存的基数估计值（小端），为 0 表示缓存失效，下次查询重算并写回。</span></span><br><span class="line"><span class="comment"> * registers[]：寄存器数据区；</span></span><br><span class="line"><span class="comment"> * - DENSE 为紧凑 6-bit 数组。</span></span><br><span class="line"><span class="comment"> * - SPARSE 为指令序列（ZERO/VAL/XZERO 等表示连续寄存器段）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> magic[<span class="number">4</span>];      <span class="comment">/* &quot;HYLL&quot; */</span></span><br><span class="line">    <span class="type">uint8_t</span> encoding;   <span class="comment">/* HLL_DENSE or HLL_SPARSE. */</span></span><br><span class="line">    <span class="type">uint8_t</span> notused[<span class="number">3</span>]; <span class="comment">/* Reserved for future use, must be zero. */</span></span><br><span class="line">    <span class="type">uint8_t</span> card[<span class="number">8</span>];    <span class="comment">/* Cached cardinality, little endian. */</span></span><br><span class="line">    <span class="type">uint8_t</span> registers[]; <span class="comment">/* Data bytes. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251209231456770.png" style="zoom: 33%;" /></p><p>当执行 <code>PFADD key element</code> 时：</p><ol type="1"><li><strong>Hash</strong>：Redis 使用 MurmurHash64A 算法将<code>element</code> 转换为一个 <strong>64位的整数</strong>（比特串）。</li><li><strong>分桶</strong>：Redis 使用这个 64 位整数的 <strong>前 14位</strong> 作为桶的索引（Register Index）。<spanclass="math inline">\(2^{14} = 16384\)</span>，所以才说 Redis 内部维护了16384 个桶（<code>registers[]</code>）。</li><li><strong>计数</strong>：使用剩下的 <strong>50 位</strong> (64 - 14)来计算前导 0 的个数，因为只有 50 位，所以 6 个 bit（<spanclass="math inline">\(2^6 = 64 &gt;50\)</span>）就足够了。如果算出来前导 0 是 <spanclass="math inline">\(k\)</span>，就把第 <spanclass="math inline">\(index\)</span> 个桶的值更新为 <spanclass="math inline">\(\max(\text{当前值}, k+1)\)</span>。</li></ol><p>Redis 为了省内存，也不会一上来就申请 12KB，所以<code>registers[]</code> 存在两种编码格式：</p><ul><li><strong>稀疏编码 (Sparse)</strong>：当 HLL刚创建，或者元素很少时，Redis 使用一种类似 RLE (Run-Length Encoding)的压缩格式。比如"连续 100 个桶都是 0"，它就存"100 个 0"，而不是存 100 个0 的实际数据。</li><li><strong>密集编码(Dense)</strong>：当数据多了，稀疏编码存不下了，就会转换成标准的 12KB密集数组。</li></ul><h2 id="bloom-filter">8. Bloom Filter</h2><p>Bloom Filter（布隆过滤器）是由 Burton Howard Bloom 于 1970年提出的，它是一种 space efficient的概率型数据结构，用于判断一个元素是否在集合中。通常用于快速判断某个元素是否可能存在于一个大型数据集中，而无需实际存储整个数据集。</p><p>在 Redis 8 之后，Bloom Filter 已经内置在 Redis 中了。在这之前，它不是Redis 的标准功能，而是通过 Redis 4.0+ 引入 Module插件机制安装的，详细可参考 <ahref="https://github.com/RedisBloom/RedisBloom">GitHub 丨RedisBloom</a>。</p><h3 id="核心操作-6">8.1 核心操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建布隆过滤器</span></span><br><span class="line">BF.ADD key item1 item2 item3       <span class="comment"># 添加元素（自动创建过滤器）</span></span><br><span class="line">BF.EXISTS key item                 <span class="comment"># 检查元素是否存在</span></span><br><span class="line">BF.MADD key item1 item2 item3      <span class="comment"># 批量添加元素</span></span><br><span class="line">BF.MEXISTS key item1 item2 item3   <span class="comment"># 批量检查元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动创建并配置</span></span><br><span class="line">BF.RESERVE key error_rate capacity [EXPANSION expansion] [NONSCALING]</span><br><span class="line">  <span class="comment"># error_rate: 期望的错误率（如0.01表示1%）</span></span><br><span class="line">  <span class="comment"># capacity: 期望的元素数量</span></span><br><span class="line">  <span class="comment"># EXPANSION: 扩容因子（默认2）</span></span><br><span class="line">  <span class="comment"># NONSCALING: 禁用自动扩容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级操作</span></span><br><span class="line">BF.INSERT key [CAPACITY <span class="built_in">cap</span>] [ERROR error] [NOCREATE] ITEMS item1 item2 ...  <span class="comment"># 插入元素</span></span><br><span class="line">BF.INFO key                        <span class="comment"># 查看过滤器信息</span></span><br><span class="line">BF.CARD key                        <span class="comment"># 获取过滤器中元素数量（近似值）</span></span><br><span class="line">BF.SCANDUMP key iterator           <span class="comment"># 用于数据备份和恢复</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计数布隆过滤器（Cuckoo Filter替代方案）</span></span><br><span class="line">CF.ADD key item                    <span class="comment"># 添加元素到计数过滤器</span></span><br><span class="line">CF.ADDNX key item                  <span class="comment"># 仅当元素不存在时添加</span></span><br><span class="line">CF.EXISTS key item                 <span class="comment"># 检查元素是否存在</span></span><br><span class="line">CF.DEL key item                    <span class="comment"># 删除元素（支持删除）</span></span><br><span class="line">CF.COUNT key item                  <span class="comment"># 获取元素计数</span></span><br></pre></td></tr></table></figure><p><strong>常见使用场景：</strong></p><ul><li><strong>缓存穿透防护</strong>：查询数据库前先用布隆过滤器检查 key是否存在，避免无效查询穿透到数据库</li><li><strong>URL 去重</strong>：爬虫系统中判断 URL是否已经爬取过，避免重复爬取</li><li><strong>用户注册</strong>：检查用户名/邮箱是否已被注册，快速响应</li><li><strong>垃圾邮件过滤</strong>：维护已知垃圾邮件发送者黑名单，快速过滤</li><li><strong>数据库分片</strong>：快速判断某个 key应该存储在哪个分片上</li><li><strong>推荐系统</strong>：过滤用户已经看过的内容，避免重复推荐</li><li><strong>安全防护</strong>：IP 黑名单、恶意请求过滤等安全场景</li><li><strong>数据同步</strong>：分布式系统中判断数据是否需要同步，减少网络传输</li></ul><h3 id="底层原理-6">8.2 底层原理</h3><p>布隆过滤器的数据结构底层其实就是一个巨大的<code>Bitmap</code>。通过一组哈希函数，将同一个元素计算出来的多个哈希值对应的bit 位置为 <code>1</code>，从而判断一个元素是否存在：</p><ul><li>如果存在 bit 位为 <code>0</code>的：则该元素<strong>一定不存在</strong>。</li><li>如果不存在 bit 位为 <code>0</code>的：则该元素<strong>大概率存在</strong>。</li></ul><p>所以很显然，Bloom Filter 是不支持删除元素的。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/add-item-bloom-filter.webp" /></p><h2 id="geospatial">9. Geospatial</h2><p>Redis Geospatial 是 Redis 3.2引入的一组用于处理地理位置信息的命令。它允许我们存储地理坐标（经度和纬度），并执行诸如"计算两点距离"、"查找附近的人"等LBS（Location-Based Service）操作。</p><h3 id="核心操作-7">9.1 核心操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础操作</span></span><br><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]  <span class="comment"># 添加地理位置</span></span><br><span class="line">GEOPOS key member1 member2 ...     <span class="comment"># 获取指定位置的坐标</span></span><br><span class="line">GEODIST key member1 member2 [unit]  <span class="comment"># 计算两个位置之间的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单位参数：m(米)、km(千米)、mi(英里)、ft(英尺)</span></span><br><span class="line">GEODIST cities beijing shanghai km  <span class="comment"># 计算北京到上海的公里距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范围查询（重要）</span></span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br><span class="line">GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询选项说明：</span></span><br><span class="line"><span class="comment"># WITHCOORD: 返回坐标</span></span><br><span class="line"><span class="comment"># WITHDIST: 返回距离</span></span><br><span class="line"><span class="comment"># WITHHASH: 返回geohash值</span></span><br><span class="line"><span class="comment"># COUNT: 限制返回数量</span></span><br><span class="line"><span class="comment"># ASC|DESC: 按距离排序</span></span><br><span class="line"><span class="comment"># STORE: 存储结果到有序集合</span></span><br><span class="line"><span class="comment"># STOREDIST: 存储距离到有序集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索示例</span></span><br><span class="line">GEORADIUS restaurants 116.397128 39.916527 5 km WITHDIST WITHCOORD COUNT 10</span><br><span class="line">GEORADIUSBYMEMBER restaurants starbucks 2 km WITHDIST</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希操作</span></span><br><span class="line">GEOHASH key member1 member2 ...  <span class="comment"># 获取位置的 geohash 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有序集合操作（底层是zset）</span></span><br><span class="line">ZSCORE key member               <span class="comment"># 获取位置的geohash分数</span></span><br><span class="line">ZRANGE key start stop WITHSCORES  <span class="comment"># 获取范围位置和分数</span></span><br><span class="line">ZREM key member1 member2         <span class="comment"># 删除位置</span></span><br><span class="line">ZCARD key                       <span class="comment"># 获取位置数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量操作（Redis 6.2+）</span></span><br><span class="line">GEOSEARCH key [FROMMEMBER member | FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi | BYBOX width height m|km|ft|mi] [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC]</span><br></pre></td></tr></table></figure><p><strong>常见使用场景：</strong></p><ul><li><strong>附近的人</strong>：社交应用查找附近用户，<code>GEORADIUS</code>查找指定范围内的用户</li><li><strong>附近商家</strong>：生活服务平台查找附近餐厅、酒店、银行等</li><li><strong>打车服务</strong>：查找附近司机、计算预估距离和费用</li><li><strong>外卖配送</strong>：查找附近商家、计算配送距离和时间</li><li><strong>位置签到</strong>：记录用户位置，实现签到功能</li><li><strong>地理围栏</strong>：设定虚拟地理边界，进入或离开时触发事件</li><li><strong>位置营销</strong>：基于地理位置的精准营销和广告推送</li><li><strong>物流追踪</strong>：实时追踪包裹位置，查找附近配送点</li><li><strong>旅游导航</strong>：查找附近景点、计算景点间距离</li><li><strong>紧急服务</strong>：查找附近的医院、警察局等紧急服务点</li></ul><p><strong>实用示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加城市位置</span></span><br><span class="line">GEOADD cities 116.397128 39.916527 beijing</span><br><span class="line">GEOADD cities 121.473701 31.230416 shanghai</span><br><span class="line">GEOADD cities 113.264385 23.129112 guangzhou</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算距离</span></span><br><span class="line">GEODIST cities beijing shanghai km  <span class="comment"># 输出：1067.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找北京500km内的城市</span></span><br><span class="line">GEORADIUS cities 116.397128 39.916527 500 km WITHDIST</span><br></pre></td></tr></table></figure><h3 id="底层原理-7">9.2 底层原理</h3><p>Redis Geo 并没有引入新的底层数据结构，其本质上是一个<code>Sorted Set</code>。</p><p>地理位置是一个二维坐标 <code>(经度, 纬度)</code>，而 Redis 的 ZSet只能按一个一维的 <code>score</code> 进行排序。为了复用 ZSet的排序和范围查找能力，必须将二维坐标映射为一维整数。</p><p><strong>GeoHash</strong>就是这种映射算法。它将地球表面划分为无数个矩形网格，并利用 Z-OrderCurve（Z 阶曲线）将二维网格编码为一维的二进制串。GeoHash的编码过程就是<u>将经度和纬度分别二分逼近，大于中间值记为 1，小于记为0。然后将经纬度的二进制位交错组合（偶数位放精度，奇数位放纬度），生成最终的52 位整数。</u></p><p>当我们要查询"附近的人"时，实际上是在 ZSet 中查找<code>score</code>（GeoHash 值）相近的元素。</p><p>但是，GeoHash存在一个著名的<strong>边界问题</strong>：两个点可能直线距离很近，但刚好位于两个格子的边缘，导致它们的GeoHash 值差异巨大（例如一个在 Z 曲线的末端，一个在起端）。</p><p>为了解决这个问题，Redis 在执行 <code>GEORADIUS</code>时，不仅会搜索中心点所在的那个格子（GeoHash范围），还会自动计算并搜索<strong>周围的 8 个邻居格子</strong>。</p><p>我让 Gemini绘制了一个网页，用于辅助理解，感兴趣的读者可自行下载参考。</p><blockquote><p>https://github.com/hedon954/geohash-display</p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251210100627954.png" /></p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251210101309164.png" /></p><h2 id="pubsub">10. PubSub</h2><p>PubSub（Publish/Subscribe，发布/订阅）是一种消息通信模式。发送者（Pub）将消息发送到频道（Channel），而不用知道谁订阅了它；订阅者（Sub）接收感兴趣频道的消息，而不用知道谁发送了它。</p><p>Pub/Sub 的核心逻辑是 <strong>广播 (Broadcasting)</strong>。 它和List/Stream 最大的区别在于：<strong>它不存储消息</strong>。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251210095612077.png" /></p><h3 id="核心操作-8">10.1 核心操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布订阅操作</span></span><br><span class="line">PUBLISH channel message         <span class="comment"># 向指定频道发布消息</span></span><br><span class="line">SUBSCRIBE channel1 channel2 ... <span class="comment"># 订阅一个或多个频道</span></span><br><span class="line">UNSUBSCRIBE channel1 channel2 ...  <span class="comment"># 取消订阅指定频道</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式订阅</span></span><br><span class="line">PSUBSCRIBE pattern1 pattern2 ...   <span class="comment"># 订阅匹配模式的频道（支持通配符*和?）</span></span><br><span class="line">PUNSUBSCRIBE pattern1 pattern2 ... <span class="comment"># 取消模式订阅</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询操作</span></span><br><span class="line">PUBSUB CHANNELS [pattern]         <span class="comment"># 列出活跃的频道（支持模式匹配）</span></span><br><span class="line">PUBSUB NUMSUB [channel1 channel2 ...]  <span class="comment"># 查看指定频道的订阅者数量</span></span><br><span class="line">PUBSUB NUMPAT                     <span class="comment"># 查看模式订阅的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实用示例</span></span><br><span class="line"><span class="comment"># 发布者</span></span><br><span class="line">PUBLISH news:sports <span class="string">&quot;中国队获得冠军！&quot;</span></span><br><span class="line">PUBLISH notifications:user:1001 <span class="string">&quot;您有新的消息&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅者</span></span><br><span class="line">SUBSCRIBE news:sports</span><br><span class="line">SUBSCRIBE notifications:user:1001</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式订阅（订阅所有新闻频道）</span></span><br><span class="line">PSUBSCRIBE news:*</span><br><span class="line">PSUBSCRIBE notifications:user:*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看频道状态</span></span><br><span class="line">PUBSUB NUMSUB news:sports notifications:user:1001</span><br><span class="line">PUBSUB CHANNELS news:*</span><br></pre></td></tr></table></figure><p><strong>常见使用场景：</strong></p><ul><li><strong>实时通知</strong>：系统通知、消息推送、事件提醒等实时通知场景</li><li><strong>聊天室</strong>：多用户实时聊天系统，群聊广播消息</li><li><strong>实时数据推送</strong>：股票价格、比赛比分、实时监控数据推送</li><li><strong>事件驱动架构</strong>：微服务间的事件通信，解耦生产者和消费者</li><li><strong>缓存失效</strong>：当数据更新时，通过 PubSub通知缓存失效，实现缓存一致性</li><li><strong>日志收集</strong>：应用日志实时收集和分发到日志处理系统</li><li><strong>监控系统</strong>：系统告警、性能指标实时推送</li><li><strong>配置更新</strong>：分布式系统中的配置变更通知</li><li><strong>游戏实时通信</strong>：多人游戏中的状态同步、位置更新等</li></ul><h3 id="底层原理-8">10.2 底层原理</h3><p>Redis 服务器结构体 <code>redisServer</code> 中维护了关于 Pub/Sub的重要字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/server.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">  kvstore *pubsub_channels;  <span class="comment">/* Map channels to list of subscribed clients */</span></span><br><span class="line">  dict *pubsub_patterns;  <span class="comment">/* A dict of pubsub_patterns */</span></span><br><span class="line">  <span class="type">int</span> notify_keyspace_events; <span class="comment">/* Events to propagate via Pub/Sub. This is an</span></span><br><span class="line"><span class="comment">                                 xor of NOTIFY_... flags. */</span></span><br><span class="line">  kvstore *pubsubshard_channels;  <span class="comment">/* Map shard channels in every slot to list of subscribed clients */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> pubsub_clients; <span class="comment">/* # of clients in Pub/Sub mode */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kvstore *pubsub_channels</code>:</p><ul><li><strong>普通频道订阅关系表</strong>。Key 是频道名 (Channel)，Value是一个链表，存储了所有订阅该频道的客户端 (Clients)。对应<code>SUBSCRIBE</code> 和 <code>PUBLISH</code> 命令。</li><li>在 Redis 7.0 之前，这里是一个<code>dict *</code>（字典）。但在新版本中，它升级为了<strong><code>kvstore *</code></strong>。在 Redis Cluster 模式下，普通的Pub/Sub是<strong>广播</strong>的（一个节点收到消息，会转发给集群内所有节点）。<code>kvstore</code>是 Redis 内部对"支持分槽（Slot）的字典"的抽象。虽然普通的 Pub/Sub是广播的，但使用 <code>kvstore</code>统一了内部的数据结构接口，方便管理和扩容。</li></ul><p><code>dict *pubsub_patterns</code>:</p><ul><li><strong>模式订阅关系表</strong>。Key 是匹配模式 (Pattern，如<code>news.*</code>)，Value 是订阅了该模式的客户端列表。对应<code>PSUBSCRIBE</code> 和 <code>PPUBLISH</code> 命令。</li><li>当有消息发布到 <code>news.sports</code> 频道时，Redis 不仅要查<code>pubsub_channels</code>，还要遍历这个 <code>pubsub_patterns</code>字典，看 <code>news.sports</code> 是否匹配其中的模式。</li></ul><p><code>int notify_keyspace_events</code>:</p><ul><li><strong>键空间通知配置</strong>。这是一个 <strong>Bitmask(位掩码)</strong> 整数。对应 <code>redis.conf</code> 配置中的<code>notify-keyspace-events</code>（如 "Ex" 代表过期事件）。</li><li>Redis 的键空间通知（Keyspace Notifications）本质上就是利用 Pub/Sub机制实现的。当一个 Key 被修改或过期时，如果这个掩码中对应的位被置为1，Redis 就会自动向特定的频道（如<code>__keyevent@0__:expired</code>）发送一条 Pub/Sub 消息。</li></ul><p><code>kvstore *pubsubshard_channels</code>:</p><ul><li><strong>分片频道订阅关系表 (Sharded Pub/Sub)</strong>。对应<code>SSUBSCRIBE</code> 和 <code>SPUBLISH</code> 命令 (Redis 7.0新增)。</li><li>普通的 Pub/Sub 在集群中是<strong>全量广播</strong>的。你在节点 A发布消息，节点 A 会把它转发给 B、C、D... 即使 B、C、D上根本没有客户端订阅这个频道。这造成了巨大的网络带宽浪费（写放大）。</li><li><strong>Sharded Pub/Sub</strong> 将频道名通过 Hash 算法映射到具体的<strong>Slot (槽)</strong>，就像普通的 Key一样。消息只会被发送到<strong>持有该 Slot的节点</strong>，不再全网广播。这里的<strong><code>kvstore</code></strong> 发挥了关键作用：它能根据 Slot快速索引和管理频道。这是 Redis 7.0 针对集群 Pub/Sub性能优化的一大体现。</li></ul><p><code>unsigned int pubsub_clients</code>:</p><ul><li><strong>当前的 Pub/Sub 客户端总数</strong>。用于 <code>INFO</code>命令统计和监控。</li><li>Redis需要知道当前有多少个连接处于"订阅状态"，因为处于订阅状态的客户端，其socket 读取逻辑和普通客户端略有不同（只能发送订阅相关命令）。</li></ul><blockquote><p>[!WARNING]</p><p>注意，虽然 Pub/Sub不保存消息，但是为了保证把消息推给（在线的）订阅者，会把积压的消息暂时存在该订阅者Client 的 <strong>输出缓冲区 (Output Buffer)</strong>中。如果消费者处理得很慢，导致积压越来越多，这个缓冲区会无限膨胀，最终OOM。</p><p>Redis 默认配置了保护策略<code>client-output-buffer-limit</code>：如果缓冲区超过 32MB，或者持续60 秒超过 8MB，Redis会<strong>强制断开</strong>这个订阅者的连接。订阅者断连，消息丢失，但Redis 活下来了。</p></blockquote><h2 id="stream">11. Stream</h2><p>Redis Stream 是 Redis 5.0 引入的最重量级特性，它的出现是为了填补Redis在消息队列领域的最后一块短板——<strong>持久化与可靠性</strong>。</p><p>在此之前，使用 Redis 做消息队列主要有两种方式，但都有致命缺陷：</p><ol type="1"><li><strong>List(<code>BLPOP</code>)</strong>：无法支持多播；更致命的是，它没有<strong>ACK 机制</strong>。消息一旦从队列中 <code>POP</code>出来，如果消费者处理时宕机，这条消息就永久丢失了。</li><li><strong>Pub/Sub</strong>：支持多播，但它是 <strong>Fire andForget</strong>（即发即弃）模式。如果消费者下线，期间发送的所有消息都会丢失，且无法回溯。</li></ol><p>Stream 的设计灵感深受 Kafka 影响，它不仅支持多播（消费组），还引入了<strong>PEL (Pending Entries List)</strong>机制来保证消息的绝对不丢失，同时在底层结构上针对"时间序列ID"做了极致的内存压缩。</p><h3 id="核心操作-9">11.1 核心操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础操作</span></span><br><span class="line">XADD key [MAXLEN len [~]] [NOMKSTREAM] *|ID field value [field value ...]  <span class="comment"># 添加消息</span></span><br><span class="line">XLEN key                              <span class="comment"># 获取流中消息数量</span></span><br><span class="line">XRANGE key start end [COUNT count]    <span class="comment"># 读取范围内的消息（正向）</span></span><br><span class="line">XREVRANGE key end start [COUNT count] <span class="comment"># 读取范围内的消息（反向）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消息读取</span></span><br><span class="line">XREAD [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key1 key2 ... ID1 ID2 ...</span><br><span class="line"><span class="comment"># ID选项：$（最新消息）、&gt;（消费者组新消息）、具体时间戳ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费组操作</span></span><br><span class="line">XGROUP [CREATE key groupname <span class="built_in">id</span>|$] [MKSTREAM]           <span class="comment"># 创建消费组</span></span><br><span class="line">XGROUP [DESTROY key groupname]                         <span class="comment"># 销毁消费组</span></span><br><span class="line">XGROUP [SETID key groupname <span class="built_in">id</span>|$]                      <span class="comment"># 设置消费组最后消息ID</span></span><br><span class="line">XGROUP [DELCONSUMER key groupname consumername]        <span class="comment"># 删除消费者</span></span><br><span class="line">XINFO [GROUPS key]                                     <span class="comment"># 查看消费组信息</span></span><br><span class="line">XINFO [CONSUMERS key groupname]                        <span class="comment"># 查看消费者信息</span></span><br><span class="line">XINFO [STREAM key] [FULL]                              <span class="comment"># 查看流详细信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者读取</span></span><br><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key1 key2 ... ID1 ID2 ...</span><br><span class="line"><span class="comment"># ID选项：&gt;（新消息）、0（所有未处理消息）、具体ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消息确认</span></span><br><span class="line">XACK key group ID [ID ...]                            <span class="comment"># 确认消息已处理</span></span><br><span class="line">XPENDING key group [start end count consumer]         <span class="comment"># 查看待处理消息</span></span><br><span class="line">XCLAIM key group consumer min_idle_time ID [ID ...] [IDLE ms] [TIME ms] [RETRYCOUNT count] [FORCE] [JUSTID] [LASTID <span class="built_in">id</span>]</span><br><span class="line">XDEL key ID [ID ...]                                  <span class="comment"># 删除消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修剪操作</span></span><br><span class="line">XTRIM key MAXLEN len [~]                              <span class="comment"># 修剪流到指定长度</span></span><br><span class="line">XTRIM key MINID threshold [~]                         <span class="comment"># 删除小于指定ID的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实用示例</span></span><br><span class="line"><span class="comment"># 创建流并添加消息</span></span><br><span class="line">XADD mystream * name <span class="string">&quot;张三&quot;</span> age 25</span><br><span class="line">XADD mystream * name <span class="string">&quot;李四&quot;</span> age 30</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取消息</span></span><br><span class="line">XREAD COUNT 2 STREAMS mystream 0-0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建消费组</span></span><br><span class="line">XGROUP CREATE mystream mygroup $ MKSTREAM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者读取</span></span><br><span class="line">XREADGROUP GROUP mygroup consumer1 COUNT 1 STREAMS mystream &gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认消息</span></span><br><span class="line">XACK mystream mygroup 1672502400000-0</span><br></pre></td></tr></table></figure><p><strong>常见使用场景：</strong></p><ul><li><strong>消息队列</strong>：替代RabbitMQ/Kafka，处理异步任务、事件驱动架构</li><li><strong>事件溯源</strong>：记录系统状态变更历史，支持事件回放和时间旅行查询</li><li><strong>日志收集</strong>：应用日志的可靠收集和转发，支持消费者组并行处理</li><li><strong>监控告警</strong>：系统监控指标的时序数据存储和分析</li><li><strong>数据管道</strong>：ETL 过程中的数据缓冲和批处理</li><li><strong>实时分析</strong>：用户行为分析、点击流处理等实时数据流处理</li><li><strong>IoT 数据</strong>：物联网设备数据的时序存储和处理</li><li><strong>金融交易</strong>：交易日志记录、审计追踪，支持精确的时间序列查询</li><li><strong>游戏系统</strong>：游戏事件记录、玩家行为分析</li><li><strong>聊天系统</strong>：可靠的消息投递，支持离线消息和消息重试</li></ul><h3 id="底层原理-9">11.2 底层原理</h3><p>Stream 本质上是一个 <strong>仅追加 (Append-only)</strong>的日志结构。为了满足高效的范围查找（按时间范围读消息）和极致的内存节省，Redis并没有使用简单的链表或数组，而是设计了一种混合结构：<strong>Radix Tree(基数树) + Listpack</strong>。</p><h4 id="stream-1">11.2.1 stream</h4><p>Stream 定义在 <ahref="https://github.com/redis/redis/blob/8.4.0/src/stream.h#L16">src/stream.h</a>，负责维护消息的元数据、存储引擎（Rax）入口以及消费组状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Stream 核心结构体</span></span><br><span class="line"><span class="comment"> * 位于 src/stream.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stream</span> &#123;</span></span><br><span class="line">    <span class="comment">/* ---- 数据存储区 ---- */</span></span><br><span class="line">    rax *rax;               <span class="comment">/* 核心存储引擎：Radix Tree。</span></span><br><span class="line"><span class="comment">                             * Key: 消息 ID (大端序二进制)</span></span><br><span class="line"><span class="comment">                             * Value: 指向一个 Listpack 的指针 (每个 Listpack 存多条消息) */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> length;        <span class="comment">/* 当前 Stream 中的有效消息数量 (不包含已删除的消息) */</span></span><br><span class="line"></span><br><span class="line">    streamID last_id;       <span class="comment">/* 当前 Stream 中最后一条消息的 ID (若为空则为 0-0) */</span></span><br><span class="line">    streamID first_id;      <span class="comment">/* 当前 Stream 中第一条消息的 ID (若为空则为 0-0) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---- 统计与清理 ---- */</span></span><br><span class="line">    streamID max_deleted_entry_id;  <span class="comment">/* 历史上被删除的最大消息 ID (用于协议兼容) */</span></span><br><span class="line">    <span class="type">uint64_t</span> entries_added;         <span class="comment">/* 历史上累计写入过的消息总数 (即 ID 序列号计数器) */</span></span><br><span class="line">    <span class="type">size_t</span> alloc_size;              <span class="comment">/* Stream 自身占用的堆内存大小 (不含 key 本身) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---- 消费组管理 ---- */</span></span><br><span class="line">    rax *cgroups;           <span class="comment">/* 消费组字典。</span></span><br><span class="line"><span class="comment">                             * Key: 消费组名称 (String)</span></span><br><span class="line"><span class="comment">                             * Value: streamCG 结构体指针 */</span></span><br><span class="line"></span><br><span class="line">    rax *cgroups_ref;       <span class="comment">/* 辅助索引：用于加速 NACK 处理等场景 */</span></span><br><span class="line"></span><br><span class="line">    streamID min_cgroup_last_id;    <span class="comment">/* 缓存：所有消费组中，进度最慢的那个 last_id。</span></span><br><span class="line"><span class="comment">                                     * 用于垃圾回收，判断哪些数据可以安全清理 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> min_cgroup_last_id_valid: <span class="number">1</span>; <span class="comment">/* 缓存是否有效标记 */</span></span><br><span class="line">&#125; stream;</span><br></pre></td></tr></table></figure><h4 id="streamid">11.2.2 streamID</h4><p>Stream 的消息 ID 默认是自动生成的，格式为<code>&lt;时间戳&gt;-&lt;序列号&gt;</code>（例如<code>1702108800000-0</code>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">streamID</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> ms;        <span class="comment">/* Unix time in milliseconds. */</span></span><br><span class="line">    <span class="type">uint64_t</span> seq;       <span class="comment">/* Sequence number. */</span></span><br><span class="line">&#125; streamID;</span><br></pre></td></tr></table></figure><p>观察这组ID，你会发现一个显著特征：<strong>前缀高度重复</strong>。在同一毫秒甚至同一秒内产生的消息，其ID 的高位部分是完全相同的。如果使用普通的 Hash表或跳表存储，这些重复的前缀会浪费大量内存。</p><h4 id="radix-tree">11.2.3 Radix Tree</h4><p><strong>Radix Tree (Rax)</strong>是一种前缀树。它将公共前缀提取出来作为父节点，差异部分作为子节点。这种结构天然适合存储时间序列数据，极大地压缩了索引空间。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1280px-Radix_tree.svg.png" alt="undefined" style="zoom: 25%;" /></p><blockquote><p>这并非标准的 Radix Tree 的实现，标准的 Radix Tree一个节点只有一个字符，当然这对于 Stream这个场景依旧是极大的浪费，所以一个改进方案就是将多个相同前缀的字符合并在一个作为一个共享节点。</p><p>事实上 Go 的 Gin 框架的路由树也是采取的这种策略，具体可参考：<ahref="https://hedon.top/2025/06/30/go/go-gin/">Go 底层原理丨深度剖析 Gin框架核心机制：从 HTTP 请求生命周期到高性能设计哲学</a>。</p></blockquote><p>如果 Rax 的每个叶子节点只挂一条消息，那指针开销依然很大。Redis再次运用了"打包"的思想。</p><p>Stream 在 Rax 的节点中，并不直接存储单个消息，而是存储一个<code>listpack</code>（又来了，神奇的 listpack）。一个 Rax节点（称为宏节点）可能包含几十条甚至上百条消息。</p><ul><li><strong>宏观上</strong>：利用 Radix Tree 对 ID 前缀进行压缩，支持<span class="math inline">\(O(\log N)\)</span> 的时间范围查找。</li><li><strong>微观上</strong>：利用 Listpack对具体的消息内容（Field-Value）进行紧凑存储，利用 CPU缓存行并减少内存碎片。</li></ul><blockquote><p>[!IMPORTANT]</p><p>这再次印证了 Redis的设计哲学：在大规模索引上使用树/跳表（空间换时间），在局部小数据块上使用紧凑数组（时间换空间）。</p></blockquote><p>Radix Tree 定义在 <ahref="https://github.com/redis/redis/blob/8.4.0/src/rax.h#L78">src/rax.h</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Rax (Radix Tree) 头部 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rax</span> &#123;</span></span><br><span class="line">    raxNode *head;          <span class="comment">/* 指向根节点的指针 */</span></span><br><span class="line">    <span class="type">uint64_t</span> numele;        <span class="comment">/* 树中存储的元素总数 (即 Key 的数量) */</span></span><br><span class="line">    <span class="type">uint64_t</span> numnodes;      <span class="comment">/* 树中节点的总数 */</span></span><br><span class="line">    <span class="type">size_t</span> *alloc_size;     <span class="comment">/* 指向外部变量的指针，用于统计该树占用的总内存 */</span></span><br><span class="line">    <span class="type">void</span> *metadata[];       <span class="comment">/* 可选的元数据区域 (通常用于填充对齐) */</span></span><br><span class="line">&#125; rax;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rax 节点 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raxNode</span> &#123;</span></span><br><span class="line">    <span class="comment">/* ---- 位域标志头 (4字节) ---- */</span></span><br><span class="line">    <span class="type">uint32_t</span> iskey:<span class="number">1</span>;     <span class="comment">/* 1 表示这就到达了一个 Key 的终点 (包含 Value) */</span></span><br><span class="line">    <span class="type">uint32_t</span> isnull:<span class="number">1</span>;    <span class="comment">/* 1 表示 Value 为 NULL (即使 iskey=1) */</span></span><br><span class="line">    <span class="type">uint32_t</span> iscompr:<span class="number">1</span>;   <span class="comment">/* 1 表示这是压缩节点 (Compressed)，0 表示非压缩 (Normal) */</span></span><br><span class="line">    <span class="type">uint32_t</span> size:<span class="number">29</span>;     <span class="comment">/* 节点负载大小：</span></span><br><span class="line"><span class="comment">                           * - 若 iscompr=1: 表示压缩后缀的长度 (字节数)</span></span><br><span class="line"><span class="comment">                           * - 若 iscompr=0: 表示子节点的数量 (边数) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---- 柔性数组：数据负载区 ----</span></span><br><span class="line"><span class="comment">     * 这里的布局根据 iscompr 的值完全不同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[];</span><br><span class="line">&#125; raxNode;</span><br></pre></td></tr></table></figure><p>由于 <code>data[]</code> 是变长的，C语言无法直接描述其结构，其内存布局如下：</p><p><strong>1. 压缩节点（iscompr = 1）</strong></p><p>这意味着这是一条<strong>单行道</strong>。当前节点只有一个子节点，且中间经过了一串字符。 比如：从节点 A 到节点B，中间的路径字符串是 <code>"QD"</code>。</p><p><code>data[]</code>的内存布局：它像三明治一样，把<strong>路径字符串”</strong>和<strong>唯一的子节点指针</strong>紧挨着放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+ &lt;-- 节点起始地址</span><br><span class="line">| Header (4 Bytes)      | iskey=1, iscompr=1, size=2</span><br><span class="line">+-----------------------+</span><br><span class="line">| &#x27;Q&#x27; (1 Byte)          | \</span><br><span class="line">+-----------------------+  &gt; 压缩字符串 &quot;QD&quot;</span><br><span class="line">| &#x27;D&#x27; (1 Byte)          | /</span><br><span class="line">+-----------------------+</span><br><span class="line">| Child Ptr (8 Bytes)   | --&gt; 指向下一个 raxNode (代表 ID 后续部分的节点)</span><br><span class="line">+-----------------------+</span><br><span class="line">| Value Ptr (8 Bytes)   | --&gt; 指向 Listpack (存储消息内容) [仅当 iskey=1 时存在]</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251210002143921.png" style="zoom:33%;" /></p><p><strong>2. 非压缩节点（iscompr = 0）</strong></p><p>这意味着这是一个<strong>十字路口</strong>（分叉点）。当前节点有多个子节点。 比如：节点 A 下面分出了 <code>'A'</code>,<code>'B'</code>, <code>'C'</code> 三条路。</p><p><strong><code>data[]</code> 的内存布局</strong>：它把<strong>所有的路牌（字符）</strong>放一起，把<strong>所有的路（指针）</strong>放一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+ &lt;-- 节点起始地址</span><br><span class="line">| Header (4 Bytes)      | iskey=1, iscompr=0, size=3</span><br><span class="line">+-----------------------+</span><br><span class="line">| &#x27;A&#x27; (1 Byte)          | \</span><br><span class="line">+-----------------------+  |</span><br><span class="line">| &#x27;B&#x27; (1 Byte)          |  &gt; 子节点索引字符 (共3个)</span><br><span class="line">+-----------------------+  |</span><br><span class="line">| &#x27;C&#x27; (1 Byte)          | /</span><br><span class="line">+-----------------------+</span><br><span class="line">| Padding (X Bytes)     | &lt;-- 内存对齐填充 (视当前偏移量而定，确保后续指针地址对齐)</span><br><span class="line">+-----------------------+</span><br><span class="line">| Child Ptr 1 (8 Bytes) | --&gt; 指向 &#x27;A&#x27; 分支的下一个 raxNode</span><br><span class="line">+-----------------------+</span><br><span class="line">| Child Ptr 2 (8 Bytes) | --&gt; 指向 &#x27;B&#x27; 分支的下一个 raxNode</span><br><span class="line">+-----------------------+</span><br><span class="line">| Child Ptr 3 (8 Bytes) | --&gt; 指向 &#x27;C&#x27; 分支的下一个 raxNode</span><br><span class="line">+-----------------------+</span><br><span class="line">| Value Ptr (8 Bytes)   | --&gt; 指向 Listpack (存储消息内容) [仅当 iskey=1 时存在]</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251210002239926.png" style="zoom:33%;" /></p><h4 id="streamcg">11.2.4 streamCG</h4><p>Stream 能替代 List成为企业级消息队列的核心，在于它引入了<strong>消费组 (ConsumerGroup)</strong> 和 <strong>PEL (Pending Entries List)</strong>。</p><p>当消费者调用 <code>XREADGROUP</code> 读取消息时：</p><ol type="1"><li>消息<strong>不会</strong>从 Stream 中删除（这点与 List 不同）。</li><li>消息 ID 会被加入到该消费者的 <strong>PEL</strong> 中。</li><li>只有当消费者显式调用 <code>XACK</code> 后，Redis 才会把该 ID 从 PEL中移除。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/8887.1571235190.png" /></p><p>这背后的核心数据结构是 <code>streamCG</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Consumer group. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">streamCG</span> &#123;</span></span><br><span class="line">    streamID last_id;       <span class="comment">/* 该消费组最后一次交付（但未确认）的消息 ID。</span></span><br><span class="line"><span class="comment">                               当消费者请求“新消息”时，Redis 会提供大于此 ID 的消息。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> entries_read; <span class="comment">/* 统计信息：该组读取的消息总数 */</span></span><br><span class="line"></span><br><span class="line">    rax *pel;               <span class="comment">/* Pending Entries List (待处理列表)。</span></span><br><span class="line"><span class="comment">                               这是一个 Radix Tree。</span></span><br><span class="line"><span class="comment">                               Key: 消息 ID (64位大端序)</span></span><br><span class="line"><span class="comment">                               Value: streamNACK 结构 (记录了投递次数、最后投递时间等)</span></span><br><span class="line"><span class="comment">                               作用: 记录所有已发给消费者但尚未 ACK 的消息。 */</span></span><br><span class="line"></span><br><span class="line">    rax *pel_by_time;       <span class="comment">/* 辅助索引：按“投递时间”排序的 PEL。</span></span><br><span class="line"><span class="comment">                               Key: pelTimeKey (包含 delivery_time + stream ID)</span></span><br><span class="line"><span class="comment">                               Value: NULL (所有信息都在 Key 里)</span></span><br><span class="line"><span class="comment">                               作用: 加速超时消息的查询 (如 XPENDING ... IDLE &lt;time&gt;)。 */</span></span><br><span class="line"></span><br><span class="line">    rax *consumers;         <span class="comment">/* 消费者字典。</span></span><br><span class="line"><span class="comment">                               Key: 消费者名称</span></span><br><span class="line"><span class="comment">                               Value: streamConsumer 结构 */</span></span><br><span class="line">&#125; streamCG;</span><br></pre></td></tr></table></figure><p>每个消费组都有一个全局游标 <code>last_id</code>。</p><ul><li>当你使用 <code>XREADGROUP GROUP mygroup alice &gt;</code> 时，那个<code>&gt;</code> 符号实际上就是告诉 Redis："请把 <code>last_id</code>之后的消息发给我"。</li><li>Redis 发送消息后，会更新<code>last_id</code>。这保证了在同一个组内，消息不会被重复消费（除非显式回溯）。</li></ul><p>如下图所示，如果我们把 Radix Tree摊平来看，每个消费组有自己的游标位置，互不干扰，而 <code>stream</code>结构中的 <code>min_cgroup_last_id</code> 字段会存储最满的<code>last_id</code>，那前面的消息就可以删除了。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/5646.1571235119.png" /></p><p><strong>PEL (Pending Entries List)</strong> 是 Stream 实现 <strong>AtLeast Once</strong> 的关键。<code>streamCG</code> 维护了一个名为<code>pel</code> 的 Radix Tree。</p><ul><li><strong>写入时机</strong>：当消息被 <code>XREADGROUP</code> 读取但未<code>XACK</code> 时，它会立即进入 <code>pel</code>。</li><li><strong>移除时机</strong>：只有收到 <code>XACK</code>，Redis才会将该 ID 从 <code>pel</code> 中移除。</li></ul><p>如果消费者宕机，这条消息会永久停留在 <code>pel</code>中。运维人员可以通过 <code>XPENDING</code>命令查看到这些消息，并安排其他消费者进行 <strong>Claim(接管)</strong>。</p><p>仔细观察结构体，你会发现 <code>streamGC</code>维护了<strong>两个</strong>与 PEL 相关的 Radix Tree：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Consumer group. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">streamCG</span> &#123;</span></span><br><span class="line">    rax *pel;</span><br><span class="line">    rax *pel_by_time;</span><br><span class="line">&#125; streamCG;</span><br></pre></td></tr></table></figure><p>这是一种典型的<strong>空间换时间</strong>设计：</p><ul><li><code>pel</code>: 按 ID 索引，Key 是<code>消息 ID</code>。当消费者发送 <code>XACK &lt;id&gt;</code>时，Redis 需要快速找到这条消息并标记完成。使用 ID 索引可以达到 <spanclass="math inline">\(O(\log N)\)</span> 的查找速度。</li><li><code>pel_by_time</code>: 按时间索引，Key 是<code>投递时间 + 消息 ID</code>。用于故障恢复。当我们需要找出"哪些消息已经超时10 分钟没处理了？"（即 <code>XPENDING ... IDLE &lt;time&gt;</code>命令），Redis 不需要遍历整个 PEL，而是直接在 <code>pel_by_time</code>这个时间树上进行范围查找。</li></ul><p>这种<strong>主键索引 + 辅助索引</strong>的设计，确保了 Stream无论是<strong>正常确认 (ACK)</strong> 还是<strong>故障排查 (PendingQuery)</strong>，都能保持极高的性能，不会因为积压消息过多而拖慢Redis。</p><blockquote><p>[!WARNING]</p><p>但这不意味着 Redis Stream 就可以替代传统的 MQ了，其本质上是受限于昂贵的内存容量和异步持久化机制，无法像基于磁盘的Kafka 那样以低成本实现海量数据的长期堆积与金融级的零丢失保障。</p></blockquote><h2 id="原理和应用场景总结">12. 原理和应用场景总结</h2><p>Redis 的数据类型虽然丰富多样，但万变不离其宗。回顾全文，我们可以看到Redis 在设计上始终在做<strong>两个维度的权衡（Trade-off）</strong>：</p><ol type="1"><li><strong>内存 vsCPU</strong>：在数据量少时，倾向于使用时间换空间的紧凑结构（如Listpack、Intset），通过 CPU的轮询计算来节省昂贵的内存；在数据量大时，倾向于使用空间换时间的索引结构（如Hashtable、Skiplist），通过增加指针开销来保证 O(1) 或 O(logN)的访问速度。</li><li><strong>精确 vs概率</strong>：在处理海量数据统计时，为了突破物理内存的限制，引入了概率型数据结构（HLL、BloomFilter），用极小的误差换取了巨大的空间收益。</li></ol><p>以下是全系数据类型的核心原理与选型指南：</p><table><colgroup><col style="width: 5%" /><col style="width: 20%" /><col style="width: 31%" /><col style="width: 14%" /><col style="width: 27%" /></colgroup><thead><tr><th style="text-align: left;">数据类型</th><th style="text-align: left;">底层结构 (Encoding)</th><th style="text-align: left;">设计权衡 (Trade-off)</th><th style="text-align: left;">核心适用场景</th><th style="text-align: left;">关键限制/注意</th></tr></thead><tbody><tr><td style="text-align: left;"><strong>String</strong></td><td style="text-align: left;"><strong>int</strong> /<strong>embstr</strong> / <strong>raw</strong> (SDS)</td><td style="text-align: left;">根据长度动态分配头部，减少内存碎片。</td><td style="text-align: left;">缓存、计数器、分布式锁、会话</td><td style="text-align: left;">最大 512MB。</td></tr><tr><td style="text-align: left;"><strong>List</strong></td><td style="text-align: left;"><strong>Quicklist</strong> (Listpack链表)</td><td style="text-align: left;"><strong>宏观链表 +微观数组</strong>。平衡了内存紧凑性与两端操作的灵活性。</td><td style="text-align: left;">消息队列、最新 N 条动态、栈</td><td style="text-align: left;">随机访问 (<code>LINDEX</code>)慢，适合头尾操作。</td></tr><tr><td style="text-align: left;"><strong>Hash</strong></td><td style="text-align: left;"><strong>Listpack</strong> <spanclass="math inline">\(\to\)</span> <strong>Hashtable</strong></td><td style="text-align: left;">小数据用紧凑数组（省内存但O(N)），大数据转哈希表（快但费内存）。</td><td style="text-align: left;">对象存储、购物车、配置项</td><td style="text-align: left;">避免大 Key，大 Hash 迁移会阻塞（虽有渐进式Rehash）。</td></tr><tr><td style="text-align: left;"><strong>Set</strong></td><td style="text-align: left;"><strong>Intset</strong> <spanclass="math inline">\(\to\)</span> <strong>Hashtable</strong></td><tdstyle="text-align: left;">纯整数且有序时极致压缩，一旦插入非整数<strong>不可逆</strong>转为哈希表。</td><td style="text-align: left;">标签系统、共同好友、抽奖</td><td style="text-align: left;">尽量存整数 ID 以利用 Intset 优化。</td></tr><tr><td style="text-align: left;"><strong>ZSet</strong></td><td style="text-align: left;"><strong>Listpack</strong> <spanclass="math inline">\(\to\)</span><strong>Skiplist</strong>+<strong>Dict</strong></td><td style="text-align: left;">双重结构：Dict 保证查询 O(1)，跳表保证范围O(logN)。</td><td style="text-align: left;">排行榜、延迟队列、范围查找</td><tdstyle="text-align: left;">内存占用较高（指针多），元素多时注意性能。</td></tr><tr><td style="text-align: left;"><strong>Bitmap</strong></td><td style="text-align: left;"><strong>String</strong> (位数组)</td><td style="text-align: left;">用 Bit 表示状态，将 String 视为结构体数组(<code>BITFIELD</code>)。</td><td style="text-align: left;">日活统计、签到、用户状态</td><td style="text-align: left;">操作稀疏数据时会浪费大量内存。</td></tr><tr><td style="text-align: left;"><strong>HLL</strong></td><td style="text-align: left;"><strong>String</strong>(Sparse/Dense)</td><tdstyle="text-align: left;"><strong>概率统计</strong>。用调和平均数消除离群值，12KB统计亿级基数。</td><td style="text-align: left;">UV 统计、独立 IP 数</td><td style="text-align: left;">有 0.81% 误差，无法取出具体元素。</td></tr><tr><td style="text-align: left;"><strong>Bloom</strong></td><td style="text-align: left;"><strong>Bitmap</strong> + Hash 函数</td><tdstyle="text-align: left;"><strong>概率判存</strong>。绝无假阴性，但有假阳性。</td><td style="text-align: left;">缓存穿透防护、黑名单校验</td><td style="text-align: left;">不支持删除（除非用 CountingBF），需容忍误判。</td></tr><tr><td style="text-align: left;"><strong>Geo</strong></td><td style="text-align: left;"><strong>ZSet</strong> (GeoHash)</td><tdstyle="text-align: left;"><strong>降维打击</strong>。将二维坐标映射为一维整数，复用ZSet 排序能力。</td><td style="text-align: left;">附近的人、距离计算</td><td style="text-align: left;">存在边界误差（需查 9宫格），高纬度畸变。</td></tr><tr><td style="text-align: left;"><strong>PubSub</strong></td><td style="text-align: left;">Dict + LinkedList</td><tdstyle="text-align: left;"><strong>无状态广播</strong>。即发即弃，不存储数据。</td><td style="text-align: left;">实时通知、配置刷新</td><td style="text-align: left;">消费者断线即丢消息，无堆积能力。</td></tr><tr><td style="text-align: left;"><strong>Stream</strong></td><td style="text-align: left;"><strong>Radix Tree</strong> +<strong>Listpack</strong></td><td style="text-align: left;"><strong>前缀压缩</strong>。针对时间序列 ID优化，引入消费组和 PEL 保证可靠性。</td><td style="text-align: left;">轻量级 MQ、事件溯源、日志</td><td style="text-align: left;">内存型存储，不适合海量历史数据回溯。</td></tr></tbody></table><h2 id="参考">参考</h2><ul><li><a href="https://github.com/redis/redis/blob/8.4.0">Redis8.4.0</a></li><li><a href="https://redis.io/docs/latest/commands/">RedisCommands</a></li><li><a href="https://systemdesign.one/bloom-filters-explained/">BloomFilters Explained</a></li><li><a href="https://en.wikipedia.org/wiki/Radix_tree">Wikipedia-Radixtree</a></li><li><a href="https://devopedia.org/redis-streams">redis streams</a></li></ul>]]></content>
    
    
    <summary type="html">本文系统梳理 Redis 十一种数据类型，并结合底层实现原理、关键优化细节，深入解析其高性能背后的设计智慧与技术取舍。</summary>
    
    
    
    <category term="Redis" scheme="https://hedon.top/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://hedon.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Binlog 实践 CDC</title>
    <link href="https://hedon.top/2025/12/08/mysql/mysql-binlog-practice/"/>
    <id>https://hedon.top/2025/12/08/mysql/mysql-binlog-practice/</id>
    <published>2025-12-08T03:20:00.000Z</published>
    <updated>2025-12-18T01:09:36.351Z</updated>
    
    <content type="html"><![CDATA[<p>好的！这是一次非常棒的实战演练。</p><p>我们要构建一个<strong>“微型分布式事务同步系统”</strong>。</p><p>目标：当 MySQL 中的用户余额发生变更（充值）时，Go 程序自动捕获Binlog，并将最新的余额实时同步到 Redis 中，实现最终一致性。</p><p>我们将全流程分为 <strong>四个步骤</strong>：</p><ol type="1"><li><strong>环境准备 (MySQL &amp; Redis)</strong></li><li><strong>Go 项目初始化</strong></li><li><strong>编写核心代码 (main.go)</strong></li><li><strong>运行与验证</strong></li></ol><hr /><h3 id="第一步环境准备-mysql-redis">🟢 第一步：环境准备 (MySQL &amp;Redis)</h3><p>请确保你的本地或开发机已经启动了 MySQL 和 Redis。</p><h4 id="mysql-建表与数据准备">1. MySQL 建表与数据准备</h4><p>请在你的 MySQL 中执行以下 SQL。我们创建一个简单的<code>user_balance</code> 表。</p><p>SQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 创建测试数据库</span><br><span class="line">CREATE DATABASE IF NOT EXISTS order_db;</span><br><span class="line">USE order_db;</span><br><span class="line"></span><br><span class="line">-- 2. 创建用户余额表</span><br><span class="line">CREATE TABLE IF NOT EXISTS user_balance (</span><br><span class="line">    uid INT PRIMARY KEY,</span><br><span class="line">    username VARCHAR(50),</span><br><span class="line">    balance INT DEFAULT 0 COMMENT &#x27;余额(分)&#x27;,</span><br><span class="line">    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">-- 3. 初始化一个用户 (uid=10086, 余额=0)</span><br><span class="line">INSERT INTO user_balance (uid, username, balance) VALUES (10086, &#x27;Hedon&#x27;, 0)</span><br><span class="line">ON DUPLICATE KEY UPDATE balance=0;</span><br><span class="line"></span><br><span class="line">-- 4. 确认 Binlog 格式为 ROW (必须!)</span><br><span class="line">SET SESSION binlog_format = &#x27;ROW&#x27;;</span><br></pre></td></tr></table></figure><h4 id="创建拥有复制权限的用户-可选推荐">2. 创建拥有复制权限的用户(可选，推荐)</h4><p>为了安全，通常创建一个专门用于同步的账号，而不是用 root。</p><p>SQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;canal_user&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;canal_pass&#x27;;</span><br><span class="line">GRANT REPLICATION SLAVE, REPLICATION CLIENT, SELECT ON *.* TO &#x27;canal_user&#x27;@&#x27;%&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><hr /><h3 id="第二步go-项目初始化">🔵 第二步：Go 项目初始化</h3><p>在你的工作目录下创建一个新项目：</p><p>Bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1. 创建目录</span><br><span class="line">mkdir binlog-sync-demo</span><br><span class="line">cd binlog-sync-demo</span><br><span class="line"></span><br><span class="line"># 2. 初始化 go mod</span><br><span class="line">go mod init binlog-sync-demo</span><br><span class="line"></span><br><span class="line"># 3. 下载依赖库</span><br><span class="line"># go-mysql: 用于解析 Binlog</span><br><span class="line"># go-redis: 用于操作 Redis</span><br><span class="line">go get github.com/go-mysql-org/go-mysql/replication</span><br><span class="line">go get github.com/redis/go-redis/v9</span><br></pre></td></tr></table></figure><hr /><h3 id="第三步编写核心代码-main.go">🟠 第三步：编写核心代码(main.go)</h3><p>这是整个系统的灵魂。我会加上详细的注释，帮助你理解每一行。</p><p>创建一个 <code>main.go</code> 文件，将以下代码完整复制进去。</p><blockquote><p><strong>注意</strong>：请修改代码顶部的 <code>MySQL 配置</code> 和<code>Redis 配置</code>，适配你本地的环境。</p></blockquote><p>Go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line"></span><br><span class="line">&quot;github.com/go-mysql-org/go-mysql/replication&quot;</span><br><span class="line">&quot;github.com/redis/go-redis/v9&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// --- 配置区域 (请修改为你自己的配置) ---</span><br><span class="line">var (</span><br><span class="line">// MySQL 配置</span><br><span class="line">mysqlHost     = &quot;127.0.0.1&quot;</span><br><span class="line">mysqlPort     = uint16(3306)</span><br><span class="line">mysqlUser     = &quot;canal_user&quot; // 或者 root</span><br><span class="line">mysqlPass     = &quot;canal_pass&quot; // 或者你的密码</span><br><span class="line">targetDB      = &quot;order_db&quot;</span><br><span class="line">targetTable   = &quot;user_balance&quot;</span><br><span class="line"></span><br><span class="line">// Redis 配置</span><br><span class="line">redisAddr     = &quot;127.0.0.1:6379&quot;</span><br><span class="line">redisPass     = &quot;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var ctx = context.Background()</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 1. 初始化 Redis 客户端</span><br><span class="line">rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     redisAddr,</span><br><span class="line">Password: redisPass,</span><br><span class="line">&#125;)</span><br><span class="line">if _, err := rdb.Ping(ctx).Result(); err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;❌ Redis 连接失败: %v\n&quot;, err)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;✅ Redis 连接成功！等待数据同步...&quot;)</span><br><span class="line"></span><br><span class="line">// 2. 初始化 Binlog Syncer</span><br><span class="line">cfg := replication.BinlogSyncerConfig&#123;</span><br><span class="line">ServerID: 100, // 假装自己是一个从库，ID 必须唯一</span><br><span class="line">Flavor:   &quot;mysql&quot;,</span><br><span class="line">Host:     mysqlHost,</span><br><span class="line">Port:     mysqlPort,</span><br><span class="line">User:     mysqlUser,</span><br><span class="line">Password: mysqlPass,</span><br><span class="line">&#125;</span><br><span class="line">syncer := replication.NewBinlogSyncer(cfg)</span><br><span class="line"></span><br><span class="line">// 3. 开始同步</span><br><span class="line">// 这里的 Position 设置为 File=&quot;&quot;, Pos=4 表示从当前最新的位置开始监听</span><br><span class="line">// 生产环境需要从存储的 Checkpoint 读取</span><br><span class="line">streamer, err := syncer.StartSync(replication.Position&#123;Name: &quot;&quot;, Pos: 4&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;❌ 启动 Binlog 监听失败: %v\n&quot;, err)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;🚀 Binlog 监听器启动成功！正在监听 MySQL 变更...&quot;)</span><br><span class="line"></span><br><span class="line">// 4. 进入事件循环</span><br><span class="line">for &#123;</span><br><span class="line">ev, err := streamer.GetEvent(context.Background())</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;❌ 获取事件错误: %v\n&quot;, err)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们只关心 UPDATE 事件 (充值通常是 Update)</span><br><span class="line">// 如果是新用户注册，还需要监听 WRITE_ROWS_EVENTv2</span><br><span class="line">if ev.Header.EventType == replication.UPDATE_ROWS_EVENTv1 || ev.Header.EventType == replication.UPDATE_ROWS_EVENTv2 &#123;</span><br><span class="line">handleUpdateEvent(ev, rdb)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理更新事件</span><br><span class="line">func handleUpdateEvent(ev *replication.BinlogEvent, rdb *redis.Client) &#123;</span><br><span class="line">rowsEvent := ev.Event.(*replication.RowsEvent)</span><br><span class="line"></span><br><span class="line">// 1. 过滤库名和表名 (我们只关心 user_balance 表)</span><br><span class="line">// 注意：go-mysql 解析出来的 SchemaName 和 TableName 是 byte 数组</span><br><span class="line">dbName := string(rowsEvent.Table.Schema)</span><br><span class="line">tblName := string(rowsEvent.Table.Table)</span><br><span class="line"></span><br><span class="line">if dbName != targetDB || tblName != targetTable &#123;</span><br><span class="line">return // 不是我们要的表，跳过</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;\n⚡ 捕获到 %s.%s 的更新事件！\n&quot;, dbName, tblName)</span><br><span class="line"></span><br><span class="line">// 2. 解析行数据</span><br><span class="line">// Update 事件的 Rows 数组结构：[旧行1, 新行1, 旧行2, 新行2, ...]</span><br><span class="line">for i := 0; i &lt; len(rowsEvent.Rows); i += 2 &#123;</span><br><span class="line">oldRow := rowsEvent.Rows[i]</span><br><span class="line">newRow := rowsEvent.Rows[i+1]</span><br><span class="line"></span><br><span class="line">// 根据你的表结构 user_balance (uid, username, balance, update_time)</span><br><span class="line">// 对应的索引是: 0, 1, 2, 3</span><br><span class="line"></span><br><span class="line">// 提取 UID (主键)</span><br><span class="line">uid := getInt(newRow[0])</span><br><span class="line"></span><br><span class="line">// 提取余额 Balance</span><br><span class="line">oldBalance := getInt(oldRow[2])</span><br><span class="line">newBalance := getInt(newRow[2])</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;   用户 UID: %d\n&quot;, uid)</span><br><span class="line">fmt.Printf(&quot;   余额变更: %d -&gt; %d\n&quot;, oldBalance, newBalance)</span><br><span class="line"></span><br><span class="line">// 3. 业务逻辑：同步到 Redis</span><br><span class="line">// 只有余额真的变了才同步</span><br><span class="line">if newBalance != oldBalance &#123;</span><br><span class="line">redisKey := fmt.Sprintf(&quot;user:balance:%d&quot;, uid)</span><br><span class="line"></span><br><span class="line">// 模拟耗时，体现&quot;异步&quot;特性</span><br><span class="line">// time.Sleep(10 * time.Millisecond)</span><br><span class="line"></span><br><span class="line">err := rdb.Set(ctx, redisKey, newBalance, 0).Err()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;   ❌ Redis 同步失败: %v\n&quot;, err)</span><br><span class="line">// 生产环境这里需要重试或报警</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Printf(&quot;   ✅ Redis 同步成功！Key: %s, Value: %d\n&quot;, redisKey, newBalance)</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;   ⚠️ 余额未发生实质变化，忽略同步。&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 辅助函数：处理 go-mysql 解析出来的 int 类型差异</span><br><span class="line">// go-mysql 可能会根据数值大小返回 int, int32, int64 等不同类型</span><br><span class="line">func getInt(v interface&#123;&#125;) int64 &#123;</span><br><span class="line">switch val := v.(type) &#123;</span><br><span class="line">case int:</span><br><span class="line">return int64(val)</span><br><span class="line">case int8:</span><br><span class="line">return int64(val)</span><br><span class="line">case int16:</span><br><span class="line">return int64(val)</span><br><span class="line">case int32:</span><br><span class="line">return int64(val)</span><br><span class="line">case int64:</span><br><span class="line">return val</span><br><span class="line">case uint:</span><br><span class="line">return int64(val)</span><br><span class="line">case uint32:</span><br><span class="line">return int64(val)</span><br><span class="line">case uint64:</span><br><span class="line">return int64(val)</span><br><span class="line">default:</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h3 id="第四步运行与验证-见证奇迹的时刻">🟣 第四步：运行与验证(见证奇迹的时刻)</h3><p>现在我们打开两个终端窗口。</p><h4 id="窗口-1运行-go-程序-同步器">窗口 1：运行 Go 程序 (同步器)</h4><p>Bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p>你会看到输出：</p><blockquote><p>✅ Redis 连接成功！等待数据同步...</p><p>🚀 Binlog 监听器启动成功！正在监听 MySQL 变更...</p></blockquote><p>程序现在处于<strong>阻塞监听</strong>状态。</p><h4 id="窗口-2操作-mysql-模拟充值">窗口 2：操作 MySQL (模拟充值)</h4><p>连接到你的 MySQL，执行充值操作。</p><p>SQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USE order_db;</span><br><span class="line"></span><br><span class="line">-- 模拟：给用户 10086 充值 100 块 (10000分)</span><br><span class="line">UPDATE user_balance SET balance = balance + 10000 WHERE uid = 10086;</span><br></pre></td></tr></table></figure><h4 id="观察结果">👀 观察结果</h4><p><strong>回到窗口 1 (Go 程序)</strong>，你应该会立刻看到如下输出：</p><p>Plaintext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">⚡ 捕获到 order_db.user_balance 的更新事件！</span><br><span class="line">   用户 UID: 10086</span><br><span class="line">   余额变更: 0 -&gt; 10000</span><br><span class="line">   ✅ Redis 同步成功！Key: user:balance:10086, Value: 10000</span><br></pre></td></tr></table></figure><p>检查 Redis (可选)：</p><p>如果你有 Redis 客户端，可以去验证一下：</p><p>Bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli get user:balance:10086</span><br><span class="line"># 输出应该是 &quot;10000&quot;</span><br></pre></td></tr></table></figure><hr /><h3 id="深度复盘这个-demo-里的架构点">🧠 深度复盘：这个 Demo里的架构点</h3><p>通过这个实操，你实际上已经跑通了<strong>“异构数据同步”</strong>的最核心路径。</p><ol type="1"><li><p>ROW 格式的威力：</p><p>代码里的 oldRow 和 newRow 之所以能拿到，全靠 MySQL Binlog 的 ROW格式记录了镜像数据。</p></li><li><p>准实时性：</p><p>你会发现，当你敲下 SQL 回车的一瞬间，Go程序几乎同时输出了日志。这就是 Binlog 推送 的效率（通常在 10ms以内），足以满足绝大多数“最终一致性”的业务需求。</p></li><li><p>解耦：</p><p>你在操作 MySQL 时，完全不需要知道 Redis 的存在。是 Go程序作为“旁路”把数据搬运过去的。这就实现了业务代码与缓存逻辑的解耦。</p></li></ol><p>去做一下这个实验吧！跑通的那一刻，你会对“分布式事务”有全新的实感。</p><p>这是一个非常敏锐的架构问题！你能问出这个问题，说明你已经具备了<strong>“生产级架构”</strong>的思维，不再局限于写一个小Demo。</p><p>结论先行：</p><p>在刚才的 Demo 中，我跳过 Kafka是为了降低学习门槛和演示环境复杂度（避免让你在本地搭建 Zookeeper + Kafka集群）。</p><p>但在<strong>真实的生产环境（高并发/大规模）中，引入 Kafka（或RocketMQ）几乎是必须的</strong>。</p><p>我们来深度剖析一下：<strong>为什么在这个链路中，我们需要 Kafka做中间件？</strong> 它到底解决了什么“直连模式”解决不了的问题？</p><hr /><h3 id="架构演进从直连到消息队列">1. 架构演进：从“直连”到“消息队列”</h3><h4 id="阶段一直连模式-刚才的-demo">🔵 阶段一：直连模式 (刚才的Demo)</h4><p><strong>架构</strong>：<code>MySQL -&gt; Binlog 监听程序 (Canal/Go) -&gt; Redis</code></p><ul><li><strong>优点</strong>：<ul><li>简单，无中间件依赖。</li><li>延迟极低（少了一次网络传输）。</li></ul></li><li><strong>致命缺陷</strong>：<ol type="1"><li><strong>强耦合</strong>：Go 程序既要负责解析Binlog（复杂的协议），又要负责写 Redis（业务逻辑）。如果 Redis挂了，或者 Redis 写得太慢，会阻塞 Binlog的解析，导致<strong>主从延迟堆积</strong>。</li><li><strong>无法复用</strong>：如果你的搜索团队说：“嘿，我也想要一份用户余额变更的数据写到Elasticsearch 里”。你就得改代码，或者再起一个 Binlog 监听（对 MySQL造成双倍压力）。</li><li><strong>无削峰能力</strong>：如果 MySQL 瞬间爆发 10 万 TPS的写入，Go 程序会尝试向 Redis 发起 10 万次写入，Redis可能会直接崩掉（缓存雪崩）。</li></ol></li></ul><h4 id="阶段二引入-kafka-生产标准">🟠 阶段二：引入 Kafka (生产标准)</h4><p><strong>架构</strong>：<code>MySQL -&gt; Binlog 解析器 (Canal/Debezium) -&gt; Kafka -&gt; 消费者 (Go App) -&gt; Redis</code></p><p>在这个架构中，<strong>Kafka</strong>扮演了最重要的“缓冲”和“解耦”角色。</p><hr /><h3 id="kafka-在-cdc-链路中的四大核心价值">2. Kafka 在 CDC链路中的四大核心价值</h3><p>如果你在面试中被问到“为什么要加 Kafka”，请抛出这四个关键词：</p><h4 id="解耦-decoupling-各司其职">① 解耦 (Decoupling) —— 各司其职</h4><ul><li><strong>Binlog 解析器 (Producer)</strong>：只负责把 Binlog 变成 JSON扔进 Kafka。它根本不关心下游是 Redis 还是ES，也不关心下游是不是挂了。它的任务就是<strong>快</strong>，紧跟 MySQL主库。</li><li><strong>业务消费者 (Consumer)</strong>：只负责从 Kafka 拿消息写Redis。如果 Redis 挂了，消费者可以暂停，Kafka会帮我们保存进度（Offset）。等 Redis修好了，消费者重启，继续从断点消费。<strong>整个过程不影响 MySQL主库。</strong></li></ul><h4 id="削峰填谷-traffic-shaping-保护下游">② 削峰填谷 (Traffic Shaping)—— 保护下游</h4><ul><li><strong>场景</strong>：大促期间，MySQL 瞬间涌入 5 万 QPS的充值请求。</li><li><strong>作用</strong>：Kafka 极其能抗写（百万级TPS）。它能瞬间吞下这 5万条消息，像一个巨大的<strong>蓄水池</strong>。</li><li><strong>下游</strong>：后端的 Go程序可以按照自己的节奏（比如每秒处理 2000 个），慢慢地从 Kafka里取数据更新 Redis。Redis 此时是非常安全的，不会被流量洪峰打死。</li></ul><h4 id="广播多路分发-fan-out-数据资产化">③ 广播/多路分发 (Fan-out) ——数据资产化</h4><ul><li><strong>场景</strong>：一份数据，多处使用。</li><li><strong>作用</strong>：Binlog 数据进入 Kafka 的<code>Topic: user_balance_update</code> 后：<ul><li><strong>Consumer Group A (缓存组)</strong>：读取数据 -&gt; 更新Redis。</li><li><strong>Consumer Group B (搜索组)</strong>：读取同一份数据 -&gt;更新 Elasticsearch。</li><li><strong>Consumer Group C (数仓组)</strong>：读取同一份数据 -&gt;存入 Hive/ClickHouse。</li></ul></li><li><strong>收益</strong>：MySQL 只需要承受一次 Binlog Dump的压力，实现了<strong>“一次生产，多次消费”</strong>。</li></ul><h4 id="数据回放-data-replay-容错后悔药">④ 数据回放 (Data Replay) ——容错后悔药</h4><ul><li><strong>场景</strong>：你写的更新 Redis 的代码有个Bug，把余额加错了。代码上线跑了 1 个小时你才发现。</li><li><strong>作用</strong>：如果是直连模式，Binlog早就流过去了，难以重来。但在 Kafka 模式下，你可以把消费者的<strong>Offset (偏移量)</strong> 重置到 1 小时前。</li><li><strong>结果</strong>：消费者会重新拉取过去 1小时的历史消息，重新计算并覆盖 Redis 中的错误数据。</li></ul><hr /><h3 id="代码层面的变化">3. 代码层面的变化</h3><p>如果要上 Kafka，你的 Go 代码会拆分成两个独立的程序。</p><h4 id="程序-aproducer-binlog---kafka">程序 A：Producer (Binlog -&gt;Kafka)</h4><p>你可以继续用 <code>go-mysql</code>，或者直接部署开源的 <strong>CanalDeployer</strong> 或 <strong>Debezium</strong>（推荐，基于 Java/KafkaConnect）。它们配置一下就能用，不需要写代码。</p><h4 id="程序-bconsumer-kafka---redis">程序 B：Consumer (Kafka -&gt;Redis)</h4><p>这才是你需要写的业务代码：</p><p>Go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码：从 Kafka 消费</span><br><span class="line">func main() &#123;</span><br><span class="line">    reader := kafka.NewReader(kafka.ReaderConfig&#123;</span><br><span class="line">        Brokers: []string&#123;&quot;localhost:9092&quot;&#125;,</span><br><span class="line">        Topic:   &quot;mysql_binlog_user_balance&quot;,</span><br><span class="line">        GroupID: &quot;redis_updater_group&quot;, // 消费者组</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        m, _ := reader.ReadMessage(context.Background())</span><br><span class="line"></span><br><span class="line">        // 1. 解析 Kafka 消息 (JSON)</span><br><span class="line">        var event BalanceUpdateEvent</span><br><span class="line">        json.Unmarshal(m.Value, &amp;event)</span><br><span class="line"></span><br><span class="line">        // 2. 写入 Redis</span><br><span class="line">        redis.Set(&quot;user:&quot;+event.Uid, event.NewBalance)</span><br><span class="line"></span><br><span class="line">        // 3. 提交 Offset (表示这条我处理完了)</span><br><span class="line">        reader.CommitMessages(context.Background(), m)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>你问得非常好。</p><ul><li><strong>学习/开发/小规模</strong>：直连模式（MySQL -&gt; App -&gt;Redis）完全 OK，简单粗暴，延迟最低。</li><li><strong>生产/大规模/核心链路</strong>：<strong>必须上Kafka</strong>。不仅仅是为了解耦，更是为了数据的安全和系统的健壮性。</li></ul><p>建议：</p><p>既然你已经跑通了直连。如果想挑战高阶，可以尝试在本地起一个Kafka，把刚才 Demo 里的 handleUpdateEvent 函数改成“发送 Kafka消息”，然后再写一个小程序去消费它。这就构成了一个完整的工业级 CDC链路。</p>]]></content>
    
    
    <summary type="html">本文介绍了 MySQL Binlog 的实践，包括如何使用 MySQL Binlog 进行 CDC 操作。</summary>
    
    
    
    <category term="数据库" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://hedon.top/tags/MySQL/"/>
    
    <category term="Binlog" scheme="https://hedon.top/tags/Binlog/"/>
    
    <category term="CDC" scheme="https://hedon.top/tags/CDC/"/>
    
  </entry>
  
  <entry>
    <title>分库分表 ID 生成方案</title>
    <link href="https://hedon.top/2025/12/06/mysql/sharding-id-generate/"/>
    <id>https://hedon.top/2025/12/06/mysql/sharding-id-generate/</id>
    <published>2025-12-06T06:00:00.000Z</published>
    <updated>2025-12-06T07:31:44.541Z</updated>
    
    <content type="html"><![CDATA[<p>要彻底掌握分库分表环境下的 ID生成方案，不能只背诵"雪花算法"的配置，而必须从数据库底层原理（B+树）和分布式系统的 CAP 定理出发，建立一套完整的评估体系。</p><p>我们可以从 <strong>"不可能三角"</strong>开始，层层拆解，最后落实到工业级的设计。</p><h2 id="不可能三角">1. 不可能三角</h2><p>在分库分表场景下，一个优秀的 ID必须同时满足以下三个维度的苛刻要求，但这往往存在权衡：</p><ol type="1"><li><strong>全局唯一性(Uniqueness)</strong>：这是基本底线。不能出现两个分片生成了同一个ID。</li><li><strong>单调递增性 (Trend Increasing)</strong>：这是 MySQL场景下的核心痛点。MySQL 的 InnoDB 引擎使用 <strong>聚簇索引 (ClusteredIndex)</strong>。数据是直接挂在主键 B+ 树叶子节点上的。如果 ID是随机的（如 UUID），插入新数据时，会频繁导致 B+ 树中间节点的<strong>页分裂 (Page Split)</strong>，造成大量的随机磁盘 I/O和碎片，极大地降低写入性能。所以：<strong><u>ID必须尽量有序，最好是严格递增</u></strong>。</li><li><strong>高可用与高性能 (Availability &amp;Performance)</strong>：发号器不能成为系统的瓶颈，也不能因为单点故障导致整个业务停摆。</li></ol><h2 id="方案演进">2. 方案演进</h2><h3 id="反面教材uuid">2.1 反面教材：UUID</h3><p>UUID 是原理是利用网卡 MAC 地址、时间戳、随机数生成 128位字符串。它适用于生成Token、文件名，但<strong>绝不用于数据库主键</strong>。</p><p>主要缺点有：</p><ul><li><strong>性能杀手</strong>：无序，导致 MySQL频繁页分裂（写入性能比有序 ID 差 N 倍）。</li><li><strong>存储浪费</strong>：128位字符串太长，且作为二级索引的叶子节点值，会膨胀整个数据库索引空间。</li><li><strong>不可读</strong>：无法在日志中快速定位时间或业务含义。</li></ul><h3 id="远古方案数据库步长法">2.2 远古方案：数据库步长法</h3><p>利用 MySQL 的<code>auto_increment</code>，但不同分片设置不同的起始值和步长。</p><ul><li>DB1: start=1, step=2 -&gt; 1, 3, 5...</li><li>DB2: start=2, step=2 -&gt; 2, 4, 6...</li></ul><p>这种方案有一个最大的缺陷：一旦设定了 step=2，后续想扩容成 3个分片，所有旧数据的 ID 生成逻辑都要改，几乎无法平滑扩容。</p><p>美团的 <ahref="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf-segment</a>对这个方案进行了改进，它的核心思路是单独搞一个发号服务，每次从数据库领1000 个 ID（号段）放在内存里慢慢发。</p><ul><li>优点：减轻数据库压力，容忍数据库短时间宕机。</li><li>缺点：ID 不严格连续，依赖中心化服务。</li></ul><h3 id="黄金标准雪花算法">2.3 黄金标准：雪花算法</h3><p>这是目前最主流的分布式 ID 方案，由 Twitter提出。它本质上是一个<strong>位运算 (Bit Manipulation)</strong>的艺术。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*zgoVKDg2-q9gmU1E.png" /></p><ul><li><strong>1 bit</strong>：不使用（符号位）。</li><li><strong>41 bits</strong>：毫秒级时间戳（可以使用 69 年）。</li><li><strong>10 bits</strong>：机器 ID（5 位数据中心 ID + 5 位工作机器ID，支持 1024 个节点）。</li><li><strong>12 bits</strong>：序列号（每毫秒内支持生成 4096 个ID）。</li></ul><blockquote><p>笔者认为，雪花算法最大的价值在于提出了<strong>ID分段</strong>的思想，我们大可以根据需求、借助时间戳和分段，自由切割 ID的不同比特位，赋予其不同的含义，灵活设计自己的 ID 算法。</p></blockquote><p>雪花算法有两大优势：</p><ul><li><strong>本地生成</strong>：不依赖网络请求，性能极高。</li><li><strong>趋势递增</strong>：高位是时间，整体随时间递增，对 B+树友好。</li></ul><p>但是雪花算法强依赖服务器系统时间。如果服务器时间校准（NTP）导致时间回退，可能会生成<strong>重复 ID</strong>。</p><h4 id="直接拒绝">2.3.1 直接拒绝</h4><p>如果发现当前时间 &lt;上次生成时间，抛出异常，拒绝服务（最简单，但影响可用性）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rust 伪代码示例</span></span><br><span class="line"><span class="keyword">if</span> current_timestamp &lt; <span class="keyword">self</span>.last_timestamp &#123;</span><br><span class="line">    <span class="comment">// 警报！当前时间竟然比上一次发号的时间还早！</span></span><br><span class="line">    <span class="comment">// 说明发生了时钟回拨</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Error</span>(<span class="string">&quot;Clock moved backwards!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等待追赶">2.3.2 等待追赶</h4><p>NTP 的校准通常非常微小。如果发现回拨了 2ms，程序可以选择<strong>不报错，死循环等待</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rust 伪代码示例</span></span><br><span class="line"><span class="keyword">if</span> current_timestamp &lt; <span class="keyword">self</span>.last_timestamp &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">offset</span> = <span class="keyword">self</span>.last_timestamp - current_timestamp;</span><br><span class="line">    <span class="keyword">if</span> offset &lt;= <span class="number">5</span> &#123; <span class="comment">// 如果只回拨了 5ms 以内</span></span><br><span class="line">        <span class="comment">// 睡一会儿，或者空转，直到时间追上来</span></span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(offset));</span><br><span class="line">        <span class="comment">// 重新获取时间</span></span><br><span class="line">        current_timestamp = <span class="title function_ invoke__">Now</span>(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;回拨太多了，救不了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>代价</strong>：这次 ID生成请求会增加几毫秒的延迟（用户无感知）。</li><li><strong>收益</strong>：服务不会挂，数据不会错。</li></ul><h4 id="扩展位">2.3.3 扩展位</h4><p>如果回拨时间较长（比如几秒），等待策略会导致请求超时。 百度开源的UidGenerator使用了一种<strong>"未来时间"</strong>的思路，或者利用保留位。</p><ul><li><strong>思路</strong>：Snowflake 的 64 位中，通常有 <code>1-2</code>位是保留位（Reserved）。</li><li><strong>做法</strong>：当发生回拨时，将 <code>last_timestamp</code>继续递增（使用虚拟时间），同时修改 <code>sequence</code> 或者启用<code>回拨位</code>。</li><li><strong>本质</strong>：此时生成的 ID里的"时间戳部分"已经不是真实的物理时间了，而是逻辑时间。只要保证 ID的单调递增性，物理时间不准确并不影响数据库的主键性能。</li></ul><p>这里还有个问题！<code>self.last_timestamp</code>是存在内存中的，服务重启怎么办？</p><p>解决方案是：</p><blockquote><p>每次服务启动时，先去 ZK/Redis 拿一下这台机器"上次汇报的时间"。如果<code>当前系统时间 &lt; 上次汇报时间</code>，说明机器时间有问题，<strong>拒绝启动</strong>报警。当然，这里肯定是异步汇报的，而且，可以汇报未来时间，比如<code>当前系统时间+3s</code>，这样，<strong>哪怕我崩溃了，Redis里记录的时间戳一定比我发出的最后一个 ID的时间戳要大</strong>。重启时只要检查 Redis，就能 100%保证时间轴没有重叠。</p></blockquote><h2 id="多维查询">3. 多维查询</h2><p>分库分表的 ID 问题，除了 ID 的生成问题，还有 ID 的选择问题。</p><p>思考一下：订单ID、用户ID、商户ID。当拆分的时候，根据哪个维度进行拆分呢?</p><blockquote><p>假设按用户 ID 维度拆分，同一个用户 ID的所有订单会落到同一个库的同一张表里。 当查询的时候，按用户 ID查，可以很容易地定位到某个库的某个表。但如果按订单 ID 或 商户 ID维度查询，就很难做。</p></blockquote><p>解决思路有：</p><ol type="1"><li>建立一个映射表：商户 ID 和用户 ID 之间的映射关系，订单 ID 和用户 ID之间的映射关系，存在分布式事务问题。</li><li>业务双写：同一份数据，两套分库分表。一套按用户 ID 切分，一套按商户ID 切分。同样，存在写入多个库的分布式事务问题。</li><li>异步双写：还是两套表，只是业务单写。然后通过监听Binlog，同步到另外一套表。</li><li><strong>基因法</strong>：两个维度统一到一个维度，把订单 ID 和用户 ID统一成一个维度，比如订单 ID 固定前几位是用户 ID。</li></ol>]]></content>
    
    
    <summary type="html">本文深入分析 MySQL 分库分表后的主键生成难点，从唯一性、有序性、高可用等维度对比 UUID、自增 ID、雪花算法等方案，帮助读者系统理解各自优劣与实际落地考量。</summary>
    
    
    
    <category term="数据库" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="分库分表" scheme="https://hedon.top/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    <category term="ID 生成" scheme="https://hedon.top/tags/ID-%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>分库分表后的分页查询思路总结</title>
    <link href="https://hedon.top/2025/12/06/mysql/sharding-page-search/"/>
    <id>https://hedon.top/2025/12/06/mysql/sharding-page-search/</id>
    <published>2025-12-06T05:41:20.000Z</published>
    <updated>2025-12-06T07:32:04.123Z</updated>
    
    <content type="html"><![CDATA[<p>分库分表（Sharding）后的分页查询问题，本质上是<strong>「局部有序」与「全局有序」之间的矛盾</strong>。</p><p>在单表场景下，数据库利用 B+ 树索引可以快速定位offset；但在分片环境下，数据分散在不同的物理节点，没有任何一个节点拥有全局视图。</p><blockquote><p>当然，在单表场景下，如果 offset 太大，依旧需要白白扫前面的 offset条数据，然后才取 limit 要的数据，很浪费。</p></blockquote><p>我们可以从<strong>问题本源（第一性原理）</strong>、<strong>通用方案</strong>、<strong>深度分页优化</strong>以及 <strong>业务折衷</strong> 四个层面来思考解决方案。</p><h3 id="为何分表后分页变难了">1. 为何分表后分页变难了？</h3><p>假设我们有 3 个分片（Node A, Node B, Node C），按照 ID取模分片。现在我们要按时间排序，查询第 10 页的数据（每页 10 条，即<code>LIMIT 10 OFFSET 90</code>）。</p><h4 id="错误的直觉">1.1 错误的直觉</h4><p>直觉告诉我们：在每个分片上执行<code>LIMIT 10 OFFSET 90</code>，然后把结果拿回来合并。</p><p><strong>这是错误的</strong>。因为 Node A/B/C 的第 91条数据，可能是全局第 91 条，也可能是全局第 1 条（如果 Node A的数据时间都很新），也可能是全局第 270条。你无法确定每个分片内部数据的<strong>全局相对位置</strong>。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251206140030292.png" /></p><h4 id="正确但低效的做法broadcast-merge">1.2 正确但低效的做法（Broadcast&amp; Merge）</h4><p>为了保证数据的准确性，你必须确保不错过任何可能的记录。</p><ul><li>你需要向 <strong>所有分片</strong>发送请求：<code>SELECT * FROM table ORDER BY time LIMIT 100</code>(OFFSET + LIMIT)。</li><li>汇总所有分片返回的数据：<span class="math inline">\(3 \times 100 =300\)</span> 条。</li><li>在内存中对这 300 条数据进行全局排序。</li><li>取第 91-100 条，抛弃其余 270 条。</li></ul><p>这种做法被称为全局视野法。它的代价是随着页码（OFFSET）的增加，查询代价呈指数级（或线性倍数）增长。</p><p>如果用户查询第 10,000 页（Offset 100,000, Limit 10），有 N个分片：</p><ul><li><strong>网络 I/O：</strong> 需要传输 <span class="math inline">\(N\times (100,000 + 10)\)</span> 条数据。</li><li><strong>内存 CPU：</strong> 应用层或中间件需要对 <spanclass="math inline">\(N \times 100,010\)</span> 条数据进行排序。</li></ul><p>这就是著名的 <strong>分库分表深分页（Deep Paging）问题</strong>。</p><h3 id="通用解决方案">2. 通用解决方案</h3><p>针对上述问题，工界通常有以下几种演进方案：</p><ul><li>全局视野法：中间件代理，即上述的 broadcast &amp; merge。</li><li>二次查询法：新增一个全局 ID 映射表，先查 ID 后查数据。</li><li>同步至异构数据源：利用专门的 OLAP 数据库进行处理。</li></ul><h4 id="全局视野法中间件代理">2.1 全局视野法（中间件代理）</h4><p>即上述的 "Broadcast &amp; Merge"。</p><ul><li><strong>实现：</strong> 依赖 ShardingSphere、MyCat等中间件，或者在代码层并发调用。</li><li><strong>适用场景：</strong> 分页深度较浅（前 10-20页），对性能要求不极致的后台管理系统。</li><li><strong>缺点：</strong> 越往后翻，数据库压力越大，最终会导致OOM（内存溢出）或超时。</li></ul><h4 id="二次查询法全局-id-映射">2.2 二次查询法（全局 ID 映射）</h4><p>如果必须精确分页且页码较深，可以建立一张<strong>「索引表」</strong>。</p><ul><li><strong>原理：</strong> 建立一张只有<code>(排序字段, 主键 ID)</code>的表，这张表<strong>不分片</strong>（或者按照排序字段分片）。</li><li><strong>步骤：</strong><ol type="1"><li>先在索引表中执行 <code>LIMIT 10 OFFSET N</code>，拿到 10 个ID。</li><li>拿着这 10 个 ID，去各个分片中查询具体数据（利用 <code>IN</code>查询，命中分片键）。</li></ol></li><li><strong>适用场景：</strong>排序字段单一，且索引表数据量在单机可承受范围内（例如数据量虽大但每行很小）。</li><li><strong>缺点：</strong> 多了一次查询；索引表本身可能成为瓶颈。</li></ul><h4 id="同步至异构数据源大数据方案">2.3同步至异构数据源（大数据方案）</h4><p>这是最通用的重型解决方案。MySQL 只做OLTP（事务处理），复杂的查询交给专门的检索引擎。</p><ul><li><strong>原理：</strong> 通过Binlog（Canal/Debezium）将数据实时同步到 <strong>Elasticsearch(ES)</strong> 或 <strong>ClickHouse</strong>。</li><li><strong>步骤：</strong> 分页查询直接走 ES，ES天然支持分布式搜索和排序。拿到 ID 后，如果需要最新鲜的详情，再回查MySQL（可选）。</li><li><strong>适用场景：</strong> C端搜索、复杂条件筛选、海量数据分页。</li><li><strong>缺点：</strong>架构复杂，存在数据同步延迟（秒级或毫秒级）。</li></ul><h3 id="深度分页的优化技巧">3. 深度分页的优化技巧</h3><p>如果不想引入 ES，必须在 MySQL体系内解决深分页，可以使用以下方法：</p><ul><li>游标法：不用 offset，改用 where + limit。</li><li>只有 ID 的全局排序：分片只查询 ID，然后再逐个去查询其他字段。</li></ul><h4 id="游标法">3.1 游标法</h4><p>这是最高效的方案，将 <span class="math inline">\(O(N)\)</span>的复杂度降为 <span class="math inline">\(O(1)\)</span>。</p><ul><li><strong>核心思想：</strong> 抛弃 <code>OFFSET</code>，使用<strong>"上一页的最后一条记录"</strong> 作为锚点。</li><li><strong>前提：</strong> 排序字段必须有唯一性（通常用<code>order by time, id</code>）。</li><li><strong>SQL 变化：</strong><ul><li>第 1 页：<code>LIMIT 10</code> -&gt; 记录最后一条的<code>time=T1, id=ID1</code>。</li><li>第 2页：<code>WHERE time &lt; T1 OR (time = T1 AND id &lt; ID1) ORDER BY time DESC, id DESC LIMIT 10</code>。</li></ul></li><li><strong>优点：</strong> 无论翻到第几万页，每个分片只需要扫描 10条数据，性能恒定。</li><li><strong>缺点：</strong><strong>不支持跳页</strong>（只能点击"下一页"或"加载更多"），不适合需要跳转到"第X 页"的场景。适用于 App 的无限流（Feed 流）。</li></ul><blockquote><p>单表场景其实也建议使用这个方案，不然 offset会白白扫描很多的数据。</p></blockquote><h4 id="只有-id-的全局排序">3.2 只有 ID 的全局排序</h4><p>如果必须支持跳页，可以结合方案一进行优化。</p><p><strong>步骤：</strong></p><ol type="1"><li>每个分片只查询 <code>id</code> 和 <code>排序字段</code>（不查询<code>select *</code>），减少网络传输和内存消耗。</li><li>在内存中对 ID 列表排序，截取需要的 ID。</li><li>用 ID 回表查询完整数据。</li></ol><p><strong>效果：</strong> 缓解了网络带宽压力，但没有解决数据库扫描的I/O 压力。</p><h3 id="业务折衷与产品设计">4. 业务折衷与产品设计</h3><p>很多时候，技术上的难题可以通过修改产品逻辑来规避。</p><h4 id="限制最大页码">4.1 限制最大页码</h4><p>真的有用户会看电商商品的第 5000 页吗？通常 Google搜索也只给你看前几十页。</p><blockquote><p>可以限制只能查看前 100 页。超过 100页提示“请输入更精确的搜索条件”。</p></blockquote><h4 id="牺牲精度模糊分页">4.2 牺牲精度（模糊分页）</h4><p>当数据量达到亿级，用户并不在乎显示的 "共 10000+ 条"是否精确，也不在乎第 100 页的第一条数据和第 99页的最后一条是否严格连续。</p><blockquote><p>可以每个分片各取一部分数据，按照某种权重拼凑一页给用户。或者，每隔一定时间预计算一次全局Count。</p></blockquote><h3 id="总结">5. 总结</h3><table style="width:100%;"><colgroup><col style="width: 20%" /><col style="width: 18%" /><col style="width: 22%" /><col style="width: 16%" /><col style="width: 21%" /></colgroup><thead><tr><th><strong>方案</strong></th><th><strong>关键技术点</strong></th><th><strong>复杂度</strong></th><th><strong>适用场景</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>全局视野 (Standard)</strong></td><td>中间件广播合并</td><td><span class="math inline">\(O(Offset \times Shards)\)</span></td><td>后台管理，前几页</td><td>开发成本最低，深分页必死</td></tr><tr><td><strong>异构索引 (ES)</strong></td><td>MySQL -&gt; ES</td><td><span class="math inline">\(O(1)\)</span> ~ <spanclass="math inline">\(O(logN)\)</span></td><td>C 端搜索，复杂查询</td><td>架构重，有延迟</td></tr><tr><td><strong>游标法 (Seek)</strong></td><td><code>WHERE id &gt; last_id</code></td><td><span class="math inline">\(O(1)\)</span></td><td>移动端 Feed 流</td><td><strong>性能最好</strong>，但不能跳页</td></tr><tr><td><strong>二次查询</strong></td><td>全局索引表</td><td><span class="math inline">\(O(logN)\)</span></td><td>排序维度单一</td><td>维护额外的表</td></tr></tbody></table><p>推荐方案：</p><ul><li><strong>首选游标法（Cursor-based pagination）</strong>：设计 API时，参数不要用 <code>page_number</code>，而是用<code>next_cursor</code>（加密的 token，包含上一页的 ID）。这是现代API（如 Twitter, Stripe）的标准做法。</li><li><strong>兜底方案</strong>：如果必须用传统分页，限制<code>max_offset</code>。</li></ul>]]></content>
    
    
    <summary type="html">本文分析了分库分表环境下分页查询的本质难点，详细讲解了全局排序（Broadcast &amp; Merge）、分片本地分页的误区、深分页的性能瓶颈，并对游标分页与业务折衷等优化方案进行了总结。</summary>
    
    
    
    <category term="数据库" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="分库分表" scheme="https://hedon.top/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    <category term="分页查询" scheme="https://hedon.top/tags/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>gRPC 原理与应用场景深度解析</title>
    <link href="https://hedon.top/2025/12/01/computer-net/net-grpc/"/>
    <id>https://hedon.top/2025/12/01/computer-net/net-grpc/</id>
    <published>2025-12-01T03:08:00.000Z</published>
    <updated>2025-12-01T05:43:12.847Z</updated>
    
    <content type="html"><![CDATA[<div class="tag-plugin video" style="aspect-ratio:1.7777777777777777;max-width:100%;">    <iframe style="border:none" src="https://www.youtube.com/embed/njC24ts24Pg?rel=0&disablekb=1&playsinline=1&autoplay=0" picture-in-picture="true" allowfullscreen="true" >    </iframe>    </div>    <h2 id="grpc">1. gRPC</h2><p>要彻底掌握 gRPC，我们不能仅停留在会写 <code>.proto</code>文件和生成代码的层面。我们需要从 <strong>第一性原理</strong>出发，理解它到底解决了什么问题，它是如何构建在网络协议之上的，以及在生产环境中会遇到哪些真实挑战。</p><p>特此声明，本篇是笔者与 Google Gemini 3Pro 共创所作，非常庆幸在当今 AI时代下获取知识已是如此便利，且也为学习者从第一性原理理解所学知识大大降低了门槛。不过本篇的篇章安排和叙述逻辑，均由笔者把控和审阅，欢迎放心阅读。</p><h3 id="为什么需要-grpc">1.1 为什么需要 gRPC</h3><p>在深入技术细节前，必须理解 gRPC 诞生的背景。它本质上是 <strong>RPC(Remote Procedure Call)</strong> 技术的一种现代演进</p><p>RPC的核心愿景是：<strong>让调用远程服务就像调用本地函数一样简单。</strong></p><ul><li><strong>本地函数：</strong><code>result = calculator.add(a, b)</code>，在内存中跳转，极快。</li><li><strong>远程调用：</strong><code>result = request("http://api/add", &#123;a, b&#125;)</code>，需要跨越网络，面临延迟、丢包、序列化开销。</li></ul><p>要掌握 gRPC，首先要明白它为什么要革 REST 的命：</p><table><colgroup><col style="width: 6%" /><col style="width: 22%" /><col style="width: 25%" /><col style="width: 46%" /></colgroup><thead><tr><th><strong>特性</strong></th><th><strong>REST (JSON + HTTP/1.1)</strong></th><th><strong>gRPC (Protobuf + HTTP/2)</strong></th><th><strong>原理差异</strong></th></tr></thead><tbody><tr><td><strong>协议</strong></td><td>文本协议 (Text)</td><td>二进制协议 (Binary)</td><td>计算机处理二进制比处理文本快得多（无需频繁的字符串解析）。</td></tr><tr><td><strong>传输</strong></td><td>请求/响应模型，连接复用差</td><td>多路复用 (Multiplexing)</td><td>HTTP/2 允许在一个 TCP 连接上并行处理多个请求，解决了队头阻塞(Head-of-Line Blocking)。</td></tr><tr><td><strong>约束</strong></td><td>弱类型，依赖文档 (OpenAPI)</td><td>强类型，依赖 IDL (.proto)</td><td><strong>IDL (Interface Definition Language)</strong> 是 gRPC的核心，它是强契约，保证了客户端和服务端的数据结构绝对一致。</td></tr><tr><td><strong>方向</strong></td><td>主要是单向 (Request-Response)</td><td>双向流 (Bi-directional Streaming)</td><td>HTTP/2 的流特性允许服务端主动推送数据。</td></tr></tbody></table><blockquote><p>gRPC 的高性能并非魔法，而是通过 <strong>空间效率</strong>（Protobuf压缩率高）和 <strong>时间效率</strong>（HTTP/2并发高、序列化快）的物理层优化换来的。</p></blockquote><h3 id="两大基石">1.2 两大基石</h3><h4 id="protocol-buffers-protobuf">1.2.1 Protocol Buffers(Protobuf)</h4><p>不要只把它当作 XML/JSON 的替代品，要理解其<strong>编码原理</strong>。</p><ul><li><strong>TLV 格式：</strong> Protobuf 采用<code>Tag - Length - Value</code>的紧凑存储方式，没有字段名（字段名在编译后的代码中），只有字段编号(Field ID)。</li><li><strong>Varint 编码：</strong> 对于整数，使用变长编码（Base 128Varints）。例如数字 <code>1</code> 只需要 1 个字节存储，而不是标准的 4个字节 (int32)。</li><li><strong>向后兼容性：</strong>掌握如何安全地增加、删除字段而不破坏现有的客户端（永远不要修改已存在的Field ID）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The greeter service definition.</span></span><br><span class="line">service Greeter &#123;</span><br><span class="line">  <span class="comment">// Sends a greeting</span></span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The request message containing the user&#x27;s name.</span></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="http2-传输机制">1.2.2 HTTP/2 传输机制</h4><p>gRPC 强依赖 HTTP/2。你需要理解以下概念在 gRPC 中如何映射：</p><ul><li><strong>Frame (帧)：</strong> HTTP/2 通信的最小单位。gRPC的数据被封装在 DATA 帧中。</li><li><strong>Stream (流)：</strong> 一个 RPC 调用对应一个 Stream。</li><li><strong>HPACK：</strong> HTTP 头压缩。RPC 调用往往 Header重复度高，HPACK 能极大减少带宽消耗。</li></ul><h3 id="四种模式与工程化">1.3 四种模式与工程化</h3><h4 id="四种通信模式">1.3.1 四种通信模式</h4><ul><li><strong>Unary RPC：</strong> 一问一答。适用于常规 API。</li><li><strong>Server Streaming：</strong>客户端发一个，服务端回一堆。适用于：<strong>大列表数据</strong>、<strong>实时行情推送</strong>。</li><li><strong>Client Streaming：</strong>客户端发一堆，服务端回一个。适用于：<strong>物联网传感器上报</strong>、<strong>大文件上传</strong>。</li><li><strong>Bidirectional Streaming：</strong>双向实时对话。适用于：<strong>聊天室</strong>、<strong>实时游戏同步</strong>。</li></ul><h4 id="interceptor-拦截器">1.3.2 Interceptor (拦截器)</h4><p>这是 gRPC 的中间件机制。彻底掌握它是做架构设计的关键。</p><ul><li><strong>用途：</strong> 鉴权 (Auth)、日志 (Logging)、监控(Metrics)、分布式追踪 (Tracing)。</li><li><strong>实践：</strong> 学会编写一个<code>UnaryServerInterceptor</code>，在其中计算每个请求的耗时并打印日志。</li></ul><blockquote><p>笔者的开源项目 <a href="https://github.com/hedon954/goapm">goapm</a>中提供了 gRPC Server 和 Client 的链路追踪封装，有需要的读者可参考。</p></blockquote><h4 id="error-handling-错误处理">1.3.3 Error Handling (错误处理)</h4><p>gRPC 的错误不是 HTTP Status Code（虽然底层映射了）。</p><ul><li><strong>gRPC Status Code：</strong> 掌握标准码的含义，如<code>OK(0)</code>, <code>CANCELLED(1)</code>,<code>DEADLINE_EXCEEDED(4)</code>, <code>UNAVAILABLE(14)</code>。</li><li><strong>Rich Error Model：</strong> 学会使用<code>google.rpc.Status</code>传递更详细的错误信息（如具体的字段校验错误），而不仅是一个简单的错误码。</li></ul><h3 id="注意事项">1.4 注意事项</h3><h4 id="负载均衡的陷阱">1.4.1 负载均衡的陷阱</h4><ul><li><strong>问题：</strong> gRPC 基于 HTTP/2，连接是 <strong>长连接(Persistent Connection)</strong>。一旦连接建立，后续请求都在同一个 TCP连接中复用。</li><li><strong>后果：</strong> 传统的 L4 负载均衡器（如 AWSNLB、LVS）只在连接建立时起作用。结果就是：<strong>一个后端实例累死，其他实例闲死。</strong></li><li><strong>解决方案：</strong><ul><li><strong>客户端负载均衡 (Client-side LB)：</strong>客户端感知所有后端 IP（需配合 Service Discovery，如Consul/Etcd），自己做轮询。</li><li><strong>代理负载均衡 (Proxy LB / L7 LB)：</strong> 使用支持 HTTP/2的网关（如 Envoy, Nginx）来拆解请求并分发。</li></ul></li></ul><h4 id="deadlines-超时控制">14.2 Deadlines (超时控制)</h4><ul><li><strong>原则：</strong> 永远不要发起没有 Deadline 的 RPC 调用。</li><li><strong>级联故障：</strong> 如果服务 A 调 B，B 调 C，A必须设置超时，且该超时上下文 (Context) 应该传递给 B 和 C。如果 A超时了，C 的运算也应该立即取消 (Context Cancel)，避免浪费资源。</li></ul><h2 id="数据编码">2. 数据编码</h2><p>为了更深入理解 gRPC 的高性能，从根本上掌握为什么 gRPC 要使用 Protobuf编码格式。本篇将参考 <ahref="https://book.douban.com/subject/26197294/">DesigningData-Intensive Applications(DDIA)</a>一书，对业内常用的数据编码格式进行统一梳理。</p><table><colgroup><col style="width: 10%" /><col style="width: 5%" /><col style="width: 15%" /><col style="width: 42%" /><col style="width: 25%" /></colgroup><thead><tr><th><strong>协议</strong></th><th><strong>类型</strong></th><th><strong>Schema 依赖</strong></th><th><strong>核心设计哲学</strong></th><th><strong>典型场景</strong></th></tr></thead><tbody><tr><td><strong>JSON</strong></td><td>文本</td><td>无 (Self-describing)</td><td><strong>可读性至上</strong>。万物皆文本，浏览器原生支持。</td><td>前后端交互、配置文件、调试接口。</td></tr><tr><td><strong>MessagePack</strong></td><td>二进制</td><td>无 (Schema-less)</td><td><strong>二进制版 JSON</strong>。旨在无缝替换 JSON以换取更小的体积，无需预定义 IDL。</td><td>Redis 缓存存储、内部简单服务交互。</td></tr><tr><td><strong>Protobuf</strong></td><td>二进制</td><td>强 (Static IDL)</td><td><strong>微服务契约</strong>。强调字段编号 (Tag)管理，极致的向后兼容性。</td><td>gRPC、微服务内部通信。</td></tr><tr><td><strong>Thrift</strong></td><td>二进制</td><td>强 (Static IDL)</td><td><strong>全栈 RPC</strong>。不仅是序列化，还包含完整的 RPC传输层和框架实现。</td><td>早期大规模跨语言服务 (Facebook 系)。</td></tr><tr><td><strong>Avro</strong></td><td>二进制</td><td>动态 (Schema w/ Data)</td><td><strong>大数据吞吐</strong>。Schema 与数据分离或随数据头传输，去掉Tag 冗余。</td><td>Hadoop、Kafka、数据湖 (Data Lake)。</td></tr></tbody></table><h3 id="json">2.1 JSON</h3><blockquote><p>基于文本的、自描述 (Self-describing) 的键值对格式。</p></blockquote><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://www.json.org/json-en.html" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://www.json.org/json-en.html" autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div><span class="cap link footnote">https://www.json.org/json-en.html</span></div><div class="bottom"><span class="title">https://www.json.org/json-en.html</span><span class="cap desc footnote"></span></div></a></div><p>JSON 实际上是一长串 <strong>Unicode 字符</strong>。</p><ul><li><strong>自描述性：</strong> 数据中包含了结构信息（<code>&#123;</code>,<code>&#125;</code>, <code>[</code>,<code>]</code>）和字段名称。这意味着接收端不需要任何预先的沟通，只要有一个标准的JSON 解析器就能读懂。</li><li><strong>编码方式：</strong>数字存储为字符串（ASCII/UTF-8）。例如整数 <code>12345</code>在内存中通常是 4 字节整数，但在 JSON 中变成了 5 个字符<code>"1", "2", "3", "4", "5"</code>，占用 5 个字节。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Martin&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;favoriteNumber&quot;</span><span class="punctuation">:</span> <span class="number">1337</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;interests&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;daydreaming&quot;</span><span class="punctuation">,</span> <span class="string">&quot;hacking&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对于上面的例子，去掉空格后，JSON 格式需要占用 <font color="red">81bytes</font>。</p><h3 id="message-pack">2.2 Message Pack</h3><blockquote><p>二进制的 JSON (Binary JSON)。</p></blockquote><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://msgpack.org/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://msgpack.org/" autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div><span class="cap link footnote">https://msgpack.org/</span></div><div class="bottom"><span class="title">https://msgpack.org/</span><span class="cap desc footnote"></span></div></a></div><p>MessagePack 的目标是：<strong>在保留 JSON的灵活性的前提下，极致压缩体积和提升解析速度。</strong> 它不需要Schema，依然存储 Key，但它引入了 <strong>类型前缀 (Type Prefix)</strong>系统。</p><p>对于 JSON <code>&#123;"a": 1&#125;</code>，MessagePack 的二进制流可能如下：</p><ol type="1"><li><strong>Map 标记 (1 byte):</strong> <code>0x81</code><ul><li><code>0x8</code> 表示这是一个 Map。</li><li><code>0x1</code> 表示这个 Map 有 1 个元素。</li></ul></li><li><strong>Key 标记 (1 byte):</strong> <code>0xa1</code><ul><li><code>0xa</code> 表示这是一个 String。</li><li><code>0x1</code> 表示字符串长度为 1。</li></ul></li><li><strong>Key 内容 (1 byte):</strong> <code>0x61</code> (ASCII'a')</li><li><strong>Value (1 byte):</strong> <code>0x01</code>，MessagePack 使用<code>FixInt</code>，对于小整数，直接用一个字节存值，不需要额外的类型标记。</li></ol><p>与 JSON 的核心差异：</p><ul><li><strong>无分隔符：</strong> 它不需要 <code>&#123;</code> 或<code>:</code>。解析器读到 <code>0xa1</code> 就知道接下来读 1个字节作为字符串，<strong>无需扫描</strong>，直接进行内存拷贝，速度极快。</li><li><strong>Key 依然存在：</strong> 它虽然压缩了结构，但<code>"userName"</code> 这种字段名依然被完整地编码进去了。</li></ul><p>我们来看相同的例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;userName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Martin&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;favoriteNumber&quot;</span><span class="punctuation">:</span> <span class="number">1337</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;interests&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;daydreaming&quot;</span><span class="punctuation">,</span> <span class="string">&quot;hacking&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对于上面列举的数据，MessagePack 会将其进行如下图所示编码：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251201121921362.png" /></p><ol type="1"><li>第 1 个字节 <code>0x83</code>表示接下来是一个对象（顶部四位 =<code>0x80</code>），有三个字段（底部四位 =<code>0x03</code>）。（如果你想知道，如果一个对象有超过15个字段，字段数不适合四位，它会得到不同的类型指示器，字段数编码为两字节或四字节。）</li><li>第 2 个字节 <code>0xa8</code> 表示接下来是一个字符串（顶部四位 =<code>0xa0</code>），长度为八字节（底部四位 = <code>0x08</code>）。</li><li>接下来的 8 个字节是 ASCII 中的字段名userName。既然之前已经标明了长度，就不需要任何标记来告诉我们弦的终点（或任何逸出点）。</li><li>接下来的 7 个字节编码带有前缀 <code>0xa6</code> 的六字母字符串值Martin，依此类推。</li></ol><p>同样的数据，MessagePack 将数据大小压缩到了 <font color="red">66bytes</font>。</p><h3 id="protocol-buffer">2.3 Protocol Buffer</h3><blockquote><p>基于 IDL (接口定义语言) 的 Tag-Length-Value (TLV) 协议。</p></blockquote><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://protobuf.dev/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://protobuf.dev/" autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div><span class="cap link footnote">https://protobuf.dev/</span></div><div class="bottom"><span class="title">https://protobuf.dev/</span><span class="cap desc footnote"></span></div></a></div><p>Protobuf 的核心哲学是<strong>"约定优于配置"</strong>。通信双方必须预先持有<code>.proto</code> 文件（契约）。 因为有了契约，数据包里<strong>完全抛弃了字段名</strong>，只保留了字段编号 (Field ID)。</p><p>其核心由三个机制组成：</p><ol type="1"><li><strong>Varint (Base 128):</strong> 用变长字节存储整数。数字<code>1</code> 占 1 字节，数字 <code>300</code> 占 2 字节。</li><li><strong>ZigZag:</strong> 将有符号整数映射为无符号整数，解决了负数varint 编码效率低的问题。</li><li><strong>TLV 结构:</strong> 每一个字段都是 <spanclass="math inline">\(Tag + [Length] + Value\)</span>。<spanclass="math inline">\(Tag\)</span> 包含了 Field ID 和 Wire Type。</li></ol><p>Protobuf 的关键是其兼容性：</p><ul><li><strong>向后兼容性</strong>：如果接收端的 <code>.proto</code>是旧的，它读到了一个新的 Tag（例如 ID=5），它通过 Wire Type知道这个字段的数据类型，因此它可以安全地 <strong>跳过</strong>这段数据，继续解析下一个字段，而不会报错。</li><li><strong>向前兼容性</strong>：如果接收端的 <code>.proto</code>是新的，客户端没有传递新的字段，如果该字段被定义为 <code>optional</code>可选的，则接收端依旧可以跳过该缺失的字段，继续解析下一个字段，而不会报错。</li></ul><p>对于上面给出的例子，<code>proto</code> 文件定义如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">required</span> <span class="type">string</span> user_name = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="type">int64</span> favorite_number = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">repeated</span> <span class="type">string</span> interests = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251201124042969.png" /></p><ol type="1"><li>每一个字段都是 <span class="math inline">\(Tag + [Length] +Value\)</span>。<span class="math inline">\(Tag\)</span> 包含了 Field ID和 Wire Type。</li><li>第 1 个字节 <code>0x0a</code> 的低 3 位 <code>010</code> 代表<strong>Wire Type2</strong>（Length-delimited，即后面跟着长度）。这告诉解析器：准备好读取一段指定长度的数据（通常是字符串或嵌套对象）。高5 位 <code>00001</code> 代表 Field ID=1。</li><li>第 2 个字节 <code>0x06</code> 表示接下来的数据长度为 6 字节。既然Tag 里的 Wire Type 是 2，解析器就知道这里必须读一个 Varint来确定长度。<code>06</code> 就是长度。</li><li>接下来的 6 个字节 <code>4d 61 72 74 69 6e</code> 是 ASCII编码的字符串值 <strong>"Martin"</strong>。解析器读完这 6个字节后，知道当前字段结束，准备读取下一个 Tag。</li><li>重点的对于数组，它们的 tag 是一样的，如上图都是<code>0x1a</code>，Protobuf 会把一样的 <code>tag</code> 组成数组。</li></ol><p>同样的数据，Protobuf 将数据大小压缩到了 <font color="red">33bytes</font>：</p><ol type="1"><li><strong>没有 Key：</strong> 整个流里你找不到 "userName"这个单词，只有 <code>0x0a</code> (ID=1) 和 <code>0x10</code> (ID=2)这样的编号。</li><li><strong>紧凑的数字：</strong> 1337这种数字被压缩成了变长格式，且低位在前（Little Endian 风格）。</li><li><strong>无分隔符：</strong> 字符串没有结束符（如<code>\0</code>），完全依靠前面的 Length (<code>06</code>,<code>0b</code>, <code>07</code>)来精确定位边界。这使得解析过程可以利用内存拷贝（Memcpy），非常高效。</li></ol><h3 id="thrift">2.4 Thrift</h3><blockquote><p>全栈式的 RPC 框架与序列化协议。</p></blockquote><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://thrift.apache.org/docs/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://thrift.apache.org/docs/" autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div><span class="cap link footnote">https://thrift.apache.org/docs/</span></div><div class="bottom"><span class="title">https://thrift.apache.org/docs/</span><span class="cap desc footnote"></span></div></a></div><p>Thrift 是由 Facebook 开发的跨语言 RPC 框架。与 gRPC (Protobuf)相比，Thrift 最显著的特点是它把"传输格式"抽象出来了：</p><ul><li><strong>BinaryProtocol:</strong>简单粗暴，不做压缩，解析速度极快，但占用带宽。</li><li><strong>CompactProtocol:</strong> 极致压缩，逻辑复杂，节省带宽（类似Protobuf）。</li></ul><blockquote><p>其实还有 DenseProtocol，不过只支持C++，不具备跨语言，所以暂不讨论。</p></blockquote><p>对于上面给出的例子，<code>thrift</code> 文件定义如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line"><span class="number">1</span>: <span class="keyword">required</span> <span class="type">string</span> userName,</span><br><span class="line"><span class="number">2</span>: <span class="keyword">optional</span> i64 favoriteNumber,</span><br><span class="line"><span class="number">3</span>: <span class="keyword">optional</span> list&lt;<span class="type">string</span>&gt; interests</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="binaryprotocol">2.4.1 BinaryProtocol</h4><p><strong>核心特征：</strong><strong>定长、豪横、浪费</strong>。它不喜欢做位运算，喜欢用标准的 4字节（32位）或 8 字节（64位）来存储数字，哪怕数字很小。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251201125109843.png" /></p><p>我们看第一个字段 <code>userName="Martin"</code>：</p><ol type="1"><li>第 1 个字节 <code>0b</code>（Type）用于表示数据类型（String）。</li><li>第 2-3 个字节 <code>00 01</code> 表示 Field ID = 1。用了 2个字节表示 ID，很奢侈啊！</li><li>第 4-7 个字节 <code>00 00 00 06</code> 表示字符串长度为 6。用了 4个字节表示长度，真奢侈啊！</li><li>第 8-13 个字节即为 <code>Martin</code> 的 ASCII 编码。</li></ol><p>再来看第二个字段 <code>favoriteNumber=1337</code>：</p><ol type="1"><li>第 1 个字节 <code>0a</code> （Type）表示数据类型<code>I64</code>。</li><li>第 2-3 个字节 <code>00 02</code> 表示 Field ID = 2。</li><li>第 4-11 个字节，用 8 字节的定长证书来表示 1337，真是奢靡！</li></ol><p>接下来比较复杂的第三个字段 <code>interest(List)</code>：</p><ol type="1"><li>第 1 个字节 <code>0f</code> （Type）表示接下来是一个 List。</li><li>第 2-3 个字节 <code>00 03</code> 表示 Field ID = 3。</li><li>第 4 个字节 <code>0b</code> 表示数组元素的数据类型的 String。</li><li>第 5-8 个字节 <code>00 00 00 02</code> 表示数组列表长度是2，又是豪横的 4 字节整数。</li><li>剩下的就是数组的两个元素的 Length + Value。</li></ol><p>最后还有一个结尾字符 <code>00</code>，类似于 C 语言字符串的<code>\0</code>，表示整个 Struct 结束。</p><p>同样的数据，Thrift Binary Protocol 用了 <font color="red">59bytes</font>：</p><h4 id="compactprotocol">2.4.2 CompactProtocol</h4><p><strong>核心特征：</strong><strong>变长、紧凑、巧妙</strong>。这一张图的逻辑和 Protobuf非常像，但有一个<strong>关键的区别</strong>（Delta Encoding）。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251201125118197.png" /></p><p>我们看第一个字段 <code>userName="Martin"</code>：</p><ol type="1"><li>第 1 个字节 <code>0x18</code> （Tag）跟 Protobuf一样，是一个组合字节，低 4 位 <code>1000</code> （Type）表示数据类型是String，高 4 位 <code>0001</code> （Delta）表示 <strong>FieldID = 上一个ID + 1</strong>。因为这是第一个字段，所以 ID=1。</li><li>第 2 个字节 <code>06</code>（Length） 表示字符串长度为 6。CompactProtocol 使用 Varint 存储长度 6。只占 1 字节。</li><li>第 3-8 个字节即为 <code>Martin</code> 的 ASCII 编码。</li></ol><p>再来看第二个字段 <code>favoriteNumber=1337</code>：</p><ol type="1"><li>第 1 个字节 <code>0x16</code> （Tag）低 4 位 <code>0110</code>（Type）表示数据类型是 i64，高 4 位 <code>0001</code> （Delta）表示<strong>FieldID = 上一个 ID + 1</strong>。因为这是第二个字段，所以ID=1+1=2。</li><li>第 2-3 个字节 <code>f2 14</code> 是 1337 的 <strong>ZigZagVarint</strong> 编码。和 Protobuf 一样，它把 1337编码成了变长格式，只用了 2 个字节，而不是 BinaryProtocol 的 8个字节。</li></ol><p>接下来比较复杂的第三个字段 <code>interest(List)</code>：</p><ol type="1"><li>第 1 个字节 <code>0x19</code> （Tag）低 4 位<code>1001</code>（Type）代表数据类型 List，高 4 位 <code>0001</code>（Delta）表示 FieldID=1+2=3。</li><li>第 2 个字节 <code>28</code> 也是一个组合字节，低 4位（ElemType）表示数组元素类型是 String，高 4 位（Size）代表有 2个元组。</li><li>剩下的就是数组的两个元素的 Length + Value。</li></ol><p>最后一样有一个结尾字符 <code>00</code> 表示整个 Struct 结束。</p><p>同样的数据，Thrift Compact Protocol 用了 <font color="red">34bytes</font>：</p><h3 id="avro">2.5 Avro</h3><blockquote><p>Schema 与数据分离的、面向大数据的序列化协议。</p></blockquote><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://avro.apache.org/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://avro.apache.org/" autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div><span class="cap link footnote">https://avro.apache.org/</span></div><div class="bottom"><span class="title">https://avro.apache.org/</span><span class="cap desc footnote"></span></div></a></div><p>Avro 是为 Hadoop生态系统设计的。它的第一性原理假设是：<strong>一次定义Schema，处理百万条数据。</strong> 因此，Avro采取了最激进的策略：<strong>数据包里连 Field ID (Tag)都不存。</strong></p><p>假设 Schema 定义如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;record&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;int&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对于数据 <code>id=10, name="foo"</code>，Avro 的二进制流里只有：<code>[Varint 10]</code> + <code>[Length 3]</code> +<code>[Bytes 'foo']</code></p><ul><li><strong>没有 Key，没有 Tag：</strong> 没有任何标记告诉解析器<code>10</code> 是 <code>id</code>。</li><li><strong>依序解析：</strong> 解析器必须手里拿着Schema，严格按照顺序读："Schema 说第一个字段是 int，那我读一个Varint；Schema 说第二个是 string，那我读一个 string..."。</li></ul><p>既然没有 ID，怎么处理 Schema 变更（比如加字段）？ Avro 引入了<strong>Writer Schema</strong>（写数据时的格式）和 <strong>ReaderSchema</strong>（读数据时的格式）。 在反序列化时，Avro 库会对比这两份Schema：</p><ul><li>如果 Reader 想要字段 A，但 Writer 里没有，且 Reader定义了默认值，则自动填入默认值。</li><li>如果 Writer 有字段 B，但 Reader 不需要，则自动跳过。 这种<strong>动态解析</strong> 能力使得它非常适合存储历史数据。</li></ul><p>Avro 的优缺点也很明显：</p><ul><li><strong>优点：</strong>对于大批量数据（数组、文件），体积最小（因为完全去除了每条记录的元数据）。支持动态Schema。</li><li><strong>缺点：</strong> 如果没有Schema，数据完全是一堆乱码，无法解析。单条小数据传输时，如果还要带上Schema，开销反而巨大。</li></ul><p>我们还是回到前面介绍的例子，它的 <code>avro</code> 定义如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">record Person &#123;</span><br><span class="line"><span class="type">string</span> userName;</span><br><span class="line">union &#123; null, long &#125; favoriteNumber = null;</span><br><span class="line">array&lt;<span class="type">string</span>&gt; interests;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者同等含义的 JSON 结构：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;record&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Person&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;userName&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;favoriteNumber&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;null&quot;</span><span class="punctuation">,</span> <span class="string">&quot;long&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;interests&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;array&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对于上面的例子，Avro 会编码成如下图所示：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251201132124198.png" /></p><p>如前面所说的，在解析这张图之前，解析器必须先加载对应的<code>schema</code>。</p><p>我们看第一个字段 <code>userName="Martin"</code>：</p><ol type="1"><li>第 1 个字节 <code>0c</code>（Length）表示字符串长度。那问题就来了，字符串 "Martin" 长度是6，为什么这里是 12 (<code>0x0c</code>)？这是因为 Avro 对长度也使用了ZigZag 编码。<ul><li><strong>Thrift/Protobuf</strong> 认为：长度永远是正数，所以用<strong>无符号数 (Unsigned Varint)</strong>。</li><li><strong>Avro</strong> 认为：为了统一简单的底层实现，所有整数都当<strong>有符号数 (ZigZag Varint)</strong>处理；而且在数组场景下，长度甚至<strong>真的可以是负数</strong>（作为一个特殊标记）。所以 Avro<strong><u>最低位</u></strong>留给符号位，所以 <code>1100</code>中，<code>110</code> 表示大小 6，而最后的 <code>0</code> 表示正数。</li></ul></li><li>第 2-7 个字节即为 <code>Martin</code> 的 ASCII 编码。前面没有任何Tag 告诉我们这是<code>userName</code>，解析器只是因为这是第一个字段所以把它当字符串读。</li></ol><p>再来看第二个字段 <code>favoriteNumber=1337</code>：</p><ol type="1"><li>第 1 个字节 <code>02</code> 表示 Union Index，这是 Avro 的关键特性。Schema 定义这个字段可能是 <code>null</code>，也可能是<code>long</code>。数据流必须明确这次传的是哪个。由于 Schema中定义的顺序是 <code>[null, long]</code>，所以<code>index0=null</code>、<code>index1=long</code>。我们要选择index1，又根据 ZigZag 编码，所以 <spanclass="math inline">\(1×2=2=0x02\)</span>。</li><li>第 2-3 个字节 <code>f2 14</code> 是 1337 的 ZigZag Varint 编码，跟Protobuf/Thrift Compact 完全一致。</li></ol><p>接下来比较复杂的第三个字段 <code>interest(List)</code>：</p><ol type="1"><li>第 1 个字节 <code>0x04</code> 表示接下来有 2 个元素（<spanclass="math inline">\(2×2=4=0x04\)</span>)。</li><li>剩下的就是数组的两个元素的 Length + Value。</li><li>最后有一个 <code>00</code> 代表数组的结束标志。</li></ol><p>同样的数据，Avro 只用了 <font color="red">33bytes</font>，这目前的最好成绩！</p><p>通过上图的分析，我们可以清晰地看到 Avro 与 Protobuf/Thrift的根本区别：</p><ol type="1"><li><strong>消失的 Tag：</strong><ul><li>Protobuf: <code>08</code> (Field ID=1) -&gt; Value</li><li>Avro: 直接 Value</li></ul></li><li><strong>Length 的 ZigZag 化：</strong><ul><li>Protobuf 的长度就是单纯的 Varint。</li><li>Avro 连长度都要乘 2(ZigZag)，这是为了保持整个协议整数编码的一致性。</li></ul></li><li><strong>Union 的代价：</strong>虽然省去了 Tag，但在处理<code>Nullable</code> 字段时，Avro 需要一个额外的字节来标记非空。</li></ol><h3 id="总结">2.6 总结</h3><p>通过对同一个 <code>Person</code> 对象（包含 String, Int64,Array）的编码过程进行显微镜式的观察，我们可以从<strong>空间效率</strong> 和 <strong>设计哲学</strong>两个维度对这些数据编码协议进行最终的复盘。</p><p>在去除了所有不必要的空格和换行后，各协议的编码结果如下表所示：</p><table><colgroup><col style="width: 12%" /><col style="width: 8%" /><col style="width: 40%" /><col style="width: 40%" /></colgroup><thead><tr><th><strong>协议</strong></th><th><strong>最终大小</strong></th><th><strong>核心开销来源</strong></th><th><strong>技术评价</strong></th></tr></thead><tbody><tr><td><strong>JSON</strong></td><td>81 bytes</td><td><strong>文本冗余</strong>：包含完整的字段键名(<code>"userName"</code>)、结构符号 (<code>&#123;</code>,<code>:</code>)及数字的文本表示。</td><td><strong>极低效率</strong>：保留了完全的可读性与自描述性，但空间代价最高。</td></tr><tr><td><strong>MessagePack</strong></td><td>66 bytes</td><td><strong>键名冗余</strong>：虽然移除了结构符号并对数字进行了二进制处理，但依然保留了完整的字段键名。</td><td><strong>低效率</strong>：仅解决了 JSON的解析速度与部分体积问题，未解决结构冗余。</td></tr><tr><td><strong>Thrift Binary</strong></td><td>59 bytes</td><td><strong>定长编码</strong>：使用固定的 4 字节或 8字节存储整数与长度，不进行 Varint 压缩。</td><td><strong>中等效率</strong>：以空间换时间，追求内存映射级别的解析速度。</td></tr><tr><td><strong>Thrift Compact</strong></td><td>34 bytes</td><td><strong>Delta Encoding</strong>：字段 ID采用差值存储；<strong>ZigZag</strong>：整数采用变长编码。</td><td><strong>高效率</strong>：通过位运算极大降低了元数据占比。</td></tr><tr><td><strong>Protobuf</strong></td><td>33 bytes</td><td><strong>Tag 机制</strong>：使用数字 ID替代文本键名；<strong>Varint</strong>：整数变长压缩。</td><td><strong>高效率</strong>：利用静态 IDL契约，实现了极高的信噪比。</td></tr><tr><td><strong>Avro</strong></td><td>32 bytes</td><td><strong>Schema 分离</strong>：移除 Field ID(Tag)，仅保留数据值与必要的长度/索引信息。</td><td><strong>极致效率</strong>：完全依赖 Schema顺序解析，适合大批量数据存储。</td></tr></tbody></table><p>从底层设计原理来看，这几种协议代表了三种不同的数据治理哲学：</p><ol type="1"><li><strong>自描述模式 (Self-describing) —— JSON, MessagePack</strong><ul><li><strong>特征：</strong> 数据包内部自带 Schema信息（键名、类型）。</li><li><strong>优势：</strong> 灵活性极高，无需预定义 IDL，完全解耦。</li><li><strong>劣势：</strong>存在大量冗余信息，不适合高频或高吞吐场景。</li></ul></li><li><strong>静态契约模式 (Static IDL) —— Protobuf, Thrift</strong><ul><li><strong>特征：</strong> 依赖预定义的 IDL 文件（<code>.proto</code> /<code>.thrift</code>）。数据包通过 Field ID（Tag）与 IDL 映射。</li><li><strong>优势：</strong> 实现了强类型约束与向后兼容性（Tag机制），解析速度快。</li><li><strong>劣势：</strong> 需要维护 IDL文件，客户端与服务端需同步更新代码。</li></ul></li><li><strong>动态分离模式 (Schema-on-Read) —— Avro</strong><ul><li><strong>特征：</strong> 数据与 Schema分离（或在文件头仅定义一次）。数据体中不包含任何字段标识，仅包含值。</li><li><strong>优势：</strong>在处理大规模数据集（如数仓文件）时，消除了每条记录的元数据开销。支持读写Schema 动态演进。</li><li><strong>劣势：</strong> 必须严格依赖 Schema解析，单条数据传输时若需附带 Schema 则开销巨大。</li></ul></li></ol><p>在实际架构设计中，应根据业务场景的 <strong>I/O 特性</strong> 与<strong>协作模式</strong> 进行选择：</p><ul><li><strong>对外 API / 前端交互 / 调试接口</strong> <spanclass="math inline">\(\rightarrow\)</span> <strong>JSON</strong><ul><li>优先考虑可读性与通用性，浏览器原生支持是其不可替代的优势。</li></ul></li><li><strong>微服务内部通信 (RPC)</strong> <spanclass="math inline">\(\rightarrow\)</span> <strong>Protobuf(gRPC)</strong><ul><li>强契约（IDL）能有效降低多人协作中的接口不一致风险，且 Google生态支持完善。</li></ul></li><li><strong>大数据存储与离线分析 (Data Lake)</strong> <spanclass="math inline">\(\rightarrow\)</span> <strong>Avro</strong><ul><li>在 HDFS/S3 存储 TB 级数据时，移除 Tag带来的存储成本节省十分显著，且适合 Schema 频繁变更的 ETL 场景。</li></ul></li><li><strong>遗留系统或特定语言栈</strong> <spanclass="math inline">\(\rightarrow\)</span> <strong>Thrift</strong><ul><li>如果需要完整的 RPC 框架且不仅限于序列化（如需要特定的 Server模型），或者在 Protobuf 支持较弱的语言环境中使用。</li></ul></li></ul><h2 id="总结-1">3. 总结</h2><p>回顾 gRPC的设计架构，我们可以清晰地看到，其高性能并非源于单一技术的突破，而是源于<strong>传输层 (HTTP/2)</strong> 与 <strong>表示层 (Protobuf)</strong>两个维度的深度优化叠加。gRPC从第一性原理出发，分别解决了网络通信中的"拥塞"与"冗余"问题。</p><p>在表示层，gRPC 坚定地选择了 <strong>ProtocolBuffers</strong>，这不仅仅是为了更小的体积，更是为了更严谨的契约。</p><ul><li><strong>极高的信噪比</strong>：通过前文的字节级解剖，我们看到Protobuf 将一个包含丰富信息的 <code>Person</code> 对象压缩至 <strong>33bytes</strong>，仅为 JSON (81 bytes) 的<strong>40%</strong>。它通过移除字段名（Keys）并使用 Varint/ZigZag压缩数字，极大地减少了网络带宽的占用。</li><li><strong>解析效率</strong>：二进制协议允许计算机通过位运算直接解析数据，避免了文本协议中昂贵的字符串匹配与浮点数转换开销。</li><li><strong>强契约保证</strong>：IDL (<code>.proto</code>)的存在使得通信双方必须遵守严格的类型约束，这种“静态”特性消除了运行时猜测数据类型的成本，同时也为大规模微服务治理提供了坚实的基础。</li></ul><p>在传输层，gRPC 摒弃了文本格式的 HTTP/1.1，全面拥抱二进制的<strong>HTTP/2</strong>，这从物理上改变了连接的使用方式。</p><ul><li><strong>多路复用 (Multiplexing)</strong>：这是 HTTP/2最核心的优势。gRPC 允许在同一个 TCP连接上并发处理多个请求（Stream）。每个 Request/Response被拆分成多个二进制帧 (Frame) 并打乱发送，接收端根据 Stream ID重新组装。这彻底解决了 HTTP/1.1 的 <strong>队头阻塞 (Head-of-LineBlocking)</strong> 问题，使得单一连接的吞吐量成倍提升。</li><li><strong>头部压缩 (HPACK)</strong>：在微服务架构中，RPC调用往往伴随着大量重复的 Header (如 Auth Token, Tracing ID)。HTTP/2 使用HPACK 算法在客户端和服务端维护动态字典，对 Header进行增量压缩，进一步减少了带宽消耗。</li><li><strong>双向流 (Bi-directional Streaming)</strong>：得益于 HTTP/2的流特性，gRPC原生支持四种通信模式，使得实时推送、长连接对话等复杂业务场景的实现变得像普通函数调用一样简单。</li></ul><p>最终，彻底掌握 gRPC 意味着理解它在 <strong>互操作性</strong> 与<strong>性能</strong> 之间所做的权衡：</p><ol type="1"><li><strong>它不是万能的</strong>：在浏览器前端、简单的 CRUD接口或对调试可读性要求极高的场景下，REST/JSON 依然是更优的选择。</li><li><strong>它是云原生的通用语</strong>：在微服务内部通信、移动端与后端的长连接交互、以及低延迟高吞吐的系统中，gRPC凭借其 <strong>Protobuf 的极致编码</strong> 与 <strong>HTTP/2的高效传输</strong>，成为了现代分布式系统事实上的标准。</li></ol><p>理解了这些底层原理，我们才能在架构选型时，不盲目跟风，而是根据业务的真实需求（是追求极致的Bytes 节省，还是追求开发的灵活性），做出最准确的技术决策。</p>]]></content>
    
    
    <summary type="html">本文深入剖析 gRPC 的核心设计原理、性能优势、应用场景及其与传统 REST 架构的差异，助你真正理解它在现代分布式系统中的不可或缺地位。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="gRPC" scheme="https://hedon.top/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>HTTP、SSE、WebSocket、gRPC、Streamable HTTP：原理与场景全方位对比分析</title>
    <link href="https://hedon.top/2025/12/01/computer-net/net-http-sse-ws-grpc/"/>
    <id>https://hedon.top/2025/12/01/computer-net/net-http-sse-ws-grpc/</id>
    <published>2025-12-01T02:41:00.000Z</published>
    <updated>2025-12-01T03:02:57.194Z</updated>
    
    <content type="html"><![CDATA[<p>笔者近期在学习 AI 相关技术的时候，发现 MCP相关的调用方式很多都已经废弃 SSE（Server-Sent Event）而推荐使用Streamable HTTP了。于是在对二者进行学习和对比了之后，决定趁机将网络交互相关的应用层协议都总结一下。</p><p>本文不会特别深入和细节地探讨各个协议的底层实现，会尽量从第一性原理去介绍为什么要出现这些协议，以及这些协议的适应场景是什么。</p><p>要真正理解 HTTP、Streamable HTTP、SSE、WebSocket 和gRPC这几者的区别，我们不能仅停留在 API调用的表面，而需要<strong>回到网络通信的第一性原理：TCP连接的使用方式、数据编码格式以及协议层面的抽象。</strong>绝大多数现代网络通信（除了HTTP/3 基于 UDP）都建立在 TCP之上。这五种技术的本质区别，实际上是<strong>如何利用 TCP连接</strong>以及<strong>如何定义数据交换的格式</strong>。</p><h2 id="协议速览">1. 协议速览</h2><h3 id="http1.1">HTTP/1.1</h3><p>这是互联网的基石。在最原始的模型中，它遵循一次请求，一次连接的模式（虽然Keep-Alive 改善了复用，但逻辑上仍是独立的）。</p><ul><li><strong>底层原理：</strong> 客户端发起 TCP 握手 -&gt; 发送 HTTPHeader + Body -&gt; 服务器处理 -&gt; 返回 HTTP Header + Body -&gt;(可能) 关闭连接。</li><li><strong>通信模式：</strong>严格的半双工（Half-duplex）逻辑。客户端不问，服务器不说。</li><li><strong>数据格式：</strong> 通常是 JSON (文本) 或XML。可读性好，但序列化/反序列化有性能损耗。</li><li><strong>缺点：</strong> 头部冗余（Headeroverhead）大。如果要实时获取数据，必须使用 <strong>轮询(Polling)</strong>，这会制造大量的无效请求，浪费服务器资源和带宽。</li></ul><blockquote><p>关于 HTTP 更多细节可参阅：<ahref="https://hedon.top/2025/11/29/computer-net/net-http/">从 HTTP1.0 到HTTP3 的演化</a></p></blockquote><h3 id="streamable-http">Streamable HTTP</h3><p>Streamable HTTP 本质上仍然是 HTTP，但利用了 HTTP/1.1的一个特性：<code>Transfer-Encoding: chunked</code>。</p><ul><li><strong>底层原理：</strong><ol type="1"><li>客户端发送标准 HTTP 请求。</li><li>服务器在响应头中声明<code>Transfer-Encoding: chunked</code>，并不返回<code>Content-Length</code>（因为长度未知）。</li><li>服务器通过同一个 TCP 连接，分批次（Chunk）发送数据块。</li><li>发送一个长度为 0 的块表示传输结束。</li></ol></li><li><strong>通信模式：</strong> 单向流（Server -&gt;Client）。连接保持打开，直到传输完成。</li><li><strong>适用场景：</strong> 生成式AI（LLM）的打字机效果、大文件下载、动态生成的报表。</li></ul><h3 id="sse">SSE</h3><p>SSE 是 Streamable HTTP的一种标准化封装，专门用于浏览器端的服务器推送。它规定了特定的<code>Content-Type: text/event-stream</code>和数据格式（<code>data: ...</code>）。</p><ul><li><strong>底层原理：</strong><ol type="1"><li>客户端发起 HTTP 请求。</li><li>服务器挂起连接，不关闭。</li><li>服务器有数据时，通过该连接直接写入遵循特定格式的文本流。</li><li>浏览器原生支持 <code>EventSource</code>API，能自动处理断线重连。</li></ol></li><li><strong>与 WebSocket 的本质区别：</strong> SSE 依然是 HTTP协议。它不需要协议升级，防火墙友好，但只能 <strong>服务器 -&gt;客户端</strong> 单向传输。</li><li><strong>适用场景：</strong> 股票行情更新、新闻推送、CI/CD日志流、系统状态监控。</li></ul><blockquote><p>关于 SSE 更多细节可参阅：<ahref="https://hedon.top/2024/06/06/rust-action-sse/">Rust实战丨SSE(Server-Sent Events)</a></p></blockquote><h3 id="websocket">WebSocket</h3><p>WebSocket 旨在解决 HTTP "请求-响应"模式在实时双向通信上的无能。它从HTTP 开始，但随后"背叛"了 HTTP。</p><ul><li><strong>底层原理：</strong><ol type="1"><li><strong>握手：</strong> 客户端发送一个 HTTP 请求，带上<code>Upgrade: websocket</code> 头。</li><li><strong>升级：</strong> 服务器如果同意，返回 101 SwitchingProtocols。</li><li><strong>裸奔：</strong> 此刻起，HTTP 协议层消失，连接变成了原始的TCP 通道（Over TCP）。</li><li><strong>帧（Frame）：</strong>双方可以在这个通道上自由地发送自定义的二进制帧或文本帧，不再受 HTTPHeader 的束缚。</li></ol></li><li><strong>通信模式：</strong>真正的全双工（Full-duplex）。客户端和服务器地位对等，谁都可以随时发消息。</li><li><strong>缺点：</strong>状态管理复杂（需要处理心跳、重连、鉴权），且不支持 HTTP 的语义（如404、500 状态码，需要自己定义业务层协议）。</li><li><strong>适用场景：</strong>多人在线游戏、实时聊天室、协同编辑文档。</li></ul><h3 id="grpc">gRPC</h3><p>gRPC 是 Google 开发的高性能框架。它和前面几个不在一个维度：WebSocket是一种协议，而 gRPC 是一个框架，它默认基于 <strong>HTTP/2</strong>协议。</p><ul><li><strong>底层原理：</strong><ol type="1"><li><strong>HTTP/2 多路复用：</strong> 也就是在一个 TCP连接上并发处理多个请求，解决了 HTTP/1.1 的队头阻塞问题。</li><li><strong>Protobuf (Protocol Buffers)：</strong> 放弃JSON，使用二进制序列化。数据极其紧凑，且需要预先定义 <code>.proto</code>文件（Schema）。</li><li><strong>RPC (远程过程调用)：</strong>对开发者屏蔽了网络细节。你调用远程服务器的 <code>GetUser()</code>方法，就像调用本地函数一样。</li></ol></li><li><strong>gRPC 支持四种模式：</strong><ol type="1"><li>简单 RPC（类似标准 HTTP）。</li><li>服务端流式（类似 SSE）。</li><li>客户端流式。</li><li>双向流式（类似 WebSocket）。</li></ol></li><li><strong>缺点：</strong> 浏览器支持较差（需要 gRPC-Web代理），调试不如 JSON 直观（是乱码的二进制）。</li><li><strong>适用场景：</strong> 微服务内部通信（高频、低延迟）、IoT设备通信、多语言混合开发环境。</li></ul><h3 id="对比">对比</h3><table><colgroup><col style="width: 14%" /><col style="width: 20%" /><col style="width: 18%" /><col style="width: 13%" /><col style="width: 34%" /></colgroup><thead><tr><th><strong>技术方案</strong></th><th><strong>本质 (First Principles)</strong></th><th><strong>通信模型</strong></th><th><strong>数据形态</strong></th><th><strong>核心适用场景</strong></th></tr></thead><tbody><tr><td><strong>HTTP/1.1 (REST)</strong></td><td><strong>短连接</strong></td><td>问答式 (Request-Response)</td><td>JSON (文本)</td><td>传统的 CRUD 业务，无实时性要求。</td></tr><tr><td><strong>WebSocket</strong></td><td><strong>全双工隧道</strong> (TCP 裸连)</td><td>自由对话 (Bi-directional)</td><td>二进制 / 文本</td><td><strong>高频低延迟</strong>场景（游戏、协同编辑、IM）。</td></tr><tr><td><strong>SSE (Standard)</strong></td><td><strong>单向订阅</strong> (GET 请求)</td><td>广播式 (Pub / Sub)</td><td>文本 (<code>data: ...</code>)</td><td><strong>轻量级推送</strong>（股票、新闻、简单的系统通知）。</td></tr><tr><td><strong>Streamable HTTP</strong></td><td><strong>分块传输</strong> (POST 请求)</td><td>管道式 (Pipeline)</td><td>NDJSON / Bytes</td><td><strong>AI 生成</strong>（ChatGPT）、大文件下载、复杂 RPC。</td></tr><tr><td><strong>gRPC</strong></td><td><strong>RPC 框架</strong> (HTTP/2)</td><td>远程调用 (Function Call)</td><td>Protobuf (二进制)</td><td><strong>微服务内部通信</strong>（高效、强类型、多语言）。</td></tr></tbody></table><h2 id="为什么-mcp-弃用-sse">2. 为什么 MCP 弃用 SSE</h2><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://blog.fka.dev/blog/2025-06-06-why-mcp-deprecated-sse-and-go-with-streamable-http/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://blog.fka.dev/blog/2025-06-06-why-mcp-deprecated-sse-and-go-with-streamable-http/" autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div><span class="cap link footnote">https://blog.fka.dev/blog/2025-06-06-why-mcp-deprecated-sse-and-go-with-streamable-http/</span></div><div class="bottom"><span class="title">https://blog.fka.dev/blog/2025-06-06-why-mcp-deprecated-sse-and-go-with-streamable-http/</span><span class="cap desc footnote"></span></div></a></div><div class="tag-plugin colorful note" ><div class="title"><strong><p>color=orange 总结</p></strong></div><div class="body"><p><strong>废弃 SSE不是因为它传输文本格式不好，而是因为"长连接订阅模式"在复杂的RPC（远程过程调用）场景下是一种架构错误。</strong></p><p>MCP 从 SSE 转向 Streamable HTTP，本质上是从<strong>异步的消息总线模式</strong> 回归到了 <strong>同步流式的 RPC模式</strong>。后者更简单、更健壮，也更符合 AI Agent这种"一来一回"的思考特性。</p></div></div><h3 id="核心痛点双通道架构">2.1 核心痛点：双通道架构</h3><p>这是博客中提到的最直观的原因。</p><ul><li><p><strong>旧的 SSE 模式（Legacy MCP）：</strong>你必须维护<strong>两条</strong>独立的连接才能完成一次对话：</p><ol type="1"><li><strong>听筒（GET <code>/sse</code>）：</strong>建立一个长连接，专门用来<strong>听</strong>服务器说话（接收Event）。</li><li><strong>话筒（POST <code>/messages</code>）：</strong>每次要说话时，发起一个新的短连接，专门用来<strong>发</strong>指令。</li></ol><blockquote><p><strong>比喻：</strong>就像你给朋友打电话，手里拿着两个手机。左手拿一个手机只听不因，右手拿另一个手机只发短信。朋友回话还得通过左手的手机传过来。</p></blockquote></li><li><p><strong>新的 Streamable HTTP 模式：</strong><strong>回归单通道。</strong> 你发送一个 <code>POST</code>请求（说话），服务器直接在这个请求的 Response里通过流式传输回话（听）。代码复杂度指数级下降。不再需要维护一个"永远在线"的幽灵连接，也不需要处理"指令发出去了，但接收通道断了"这种分布式系统里的脑裂状态。</p></li></ul><h3 id="基础设施的敌意">2.2 基础设施的敌意</h3><p>博客中重点提到了这一点，这是运维层面的第一性原理。</p><ul><li><strong>SSE 的长连接诅咒：</strong> 旧版 MCP 要求 <code>/sse</code>连接必须<strong>一直活着</strong>。<ul><li><strong>现实世界：</strong> 企业的防火墙、Nginx负载均衡器、云服务网关（AWS ALB,Cloudflare）非常讨厌占着茅坑不拉屎的空闲长连接。它们会强行切断这些连接（Timeout）。</li><li><strong>后果：</strong>客户端必须不断写复杂的保活（Keep-alive）和重连逻辑。</li></ul></li><li><strong>Streamable HTTP 的优势：</strong>它是<strong>按需（On-Demand）</strong>的。<ul><li>有任务？发个 POST，保持连接直到任务结束。</li><li>没任务？连接自然关闭。</li><li>这完全符合 HTTP的设计初衷，对所有的中间件（Middleware）都非常友好。</li></ul></li></ul><h3 id="状态管理的灾难">2.3 状态管理的灾难</h3><p>这也是博客中提到的关键技术细节。</p><ul><li><strong>SSE 的状态同步难题：</strong>在旧模式下，因为"听"和"说"是分离的，很容易出现竞态条件（RaceCondition）。<ul><li>比如：客户端刚发了一个 POST 指令，但在服务器回包之前，SSE连接断了。此时服务器把结果推给了谁？数据丢了吗？客户端重连后还能收到刚才的结果吗？</li><li>为了解决这个问题，需要引入复杂的 Session ID 和消息队列机制。</li></ul></li><li><strong>Streamable HTTP 的原子性：</strong> 请求和响应绑定在同一个TCP 上下文里。<ul><li>连接断了 =请求失败。逻辑非常清晰（要么成功，要么重试），不需要在应用层去猜测数据去哪了。</li></ul></li></ul><h3 id="为什么博客中提到它依然支持-sse-格式">2.4为什么博客中提到它依然支持 SSE 格式？</h3><p>这是一个容易混淆的点。</p><p>博客中澄清了：<strong>Streamable HTTP 依然可以使用<code>text/event-stream</code>作为数据传输的格式（Framing），但它改变的是传输的载体（Transport）。</strong></p><ul><li><strong>旧 MCP：</strong> SSE是一个<strong>订阅频道</strong>（Pub/Sub）。</li><li><strong>新 MCP：</strong> SSE 只是 POST响应体里的一种<strong>编码方式</strong>。</li></ul><p>OpenAI 和 Anthropic 现在的做法也是如此：他们不再使用浏览器原生的<code>EventSource</code>（那个只能 GET 的订阅 API），而是使用<code>fetch</code> POST 请求，然后把响应体当成流来处理。</p>]]></content>
    
    
    <summary type="html">本文以第一性原理为出发点，剖析 HTTP、SSE、WebSocket、gRPC 以及 Streamable HTTP 等主流应用层协议的核心设计思想、演化动因与各自适用场景，助你真正理解它们的本质区别与选择依据。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="https://hedon.top/tags/HTTP/"/>
    
    <category term="Streamable HTTP" scheme="https://hedon.top/tags/Streamable-HTTP/"/>
    
    <category term="SSE" scheme="https://hedon.top/tags/SSE/"/>
    
    <category term="WebSocket" scheme="https://hedon.top/tags/WebSocket/"/>
    
    <category term="gRPC" scheme="https://hedon.top/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>从 HTTP1.0 到 HTTP3 的演化</title>
    <link href="https://hedon.top/2025/11/29/computer-net/net-http/"/>
    <id>https://hedon.top/2025/11/29/computer-net/net-http/</id>
    <published>2025-11-29T06:17:00.000Z</published>
    <updated>2025-11-30T16:08:19.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http1.0">HTTP1.0</h2><p>HTTP/1.0 的设计初衷只是为了在网络上传输 HTML 文档。</p><ul><li><p><strong>模型</strong>：Request-Response（一问一答）。</p></li><li><p><strong>底层</strong>：基于 TCP。</p></li><li><p><strong>瓶颈</strong>：<strong>TCP 连接成本过高</strong>。</p><ul><li><p>在 1.0 默认行为中，每一次 HTTP请求（比如下载一张图片）都要新建一个 TCP 连接。</p></li><li><p><strong>TCP 三次握手</strong>：这意味着每个请求都要先消耗 1.5 个RTT（往返时延）才能开始发数据。</p></li><li><p><strong>TCP 慢启动（SlowStart）</strong>：新连接的速度是从低到高爬坡的，短连接导致 TCP永远在低速爬坡阶段就断开了，带宽利用率极低。</p></li></ul></li></ul><h2 id="http1.1">HTTP1.1</h2><p>为了解决连接成本问题，HTTP/1.1 在 1999 年成为了标准，并统治互联网长达15 年。</p><h3 id="keep-alive长连接解决连接复用">1.Keep-Alive（长连接）：解决连接复用</h3><ul><li><strong>机制</strong>：引入持久连接（Persistent Connection）。默认<code>Connection: keep-alive</code>。</li><li><strong>效果</strong>：只要连接不断开，后续请求可以直接发送，省去了三次握手和TCP 慢启动的开销。</li><li><strong>细节</strong>：设置<code>Keep-Alive: timeout=5, max=100</code> 来控制连接的生命周期。</li></ul><h3 id="pipeline管道化解决串行等待失败的尝试">2.Pipeline（管道化）：解决串行等待（失败的尝试）</h3><ul><li><strong>尝试</strong>：允许客户端一口气发出去 10个请求，不用等第一个回来再发第二个。</li><li><strong>致命缺陷</strong>：<strong>HTTP 层面的队头阻塞（HOLBlocking）</strong>。<ul><li>服务器必须按照接收请求的顺序返回响应（FIFO）。如果第 1个请求处理很慢（比如数据库查询），第 2-10个请求即使处理完了，也必须排队等待第 1 个发送完毕。</li><li>由于这个风险，浏览器厂商默认都关闭了 Pipeline。</li></ul></li></ul><h3 id="transfer-encoding-chunked分块传输">3. Transfer-Encoding:chunked（分块传输）</h3><ul><li><strong>痛点</strong>：HTTP/1.0 需要在 Header 里通过<code>Content-Length</code>告诉对方包体多大。如果是动态生成的流（比如视频、动态页面），服务器必须先把所有数据生成完算出长度才能发，延迟太高。</li><li><strong>解决</strong>：<code>chunked</code>模式允许服务器产生一部分数据就发一部分，最后发一个长度为 0的块表示结束。这使得<strong>流式传输</strong>成为可能。</li></ul><h3 id="缓存控制增强">4. 缓存控制增强</h3><ul><li>引入<code>Cache-Control</code>、<code>Etag</code>、<code>If-None-Match</code>，比1.0 的 <code>Expires</code> 和 <code>Last-Modified</code>提供了更精细的缓存策略，节省带宽。</li></ul><h2 id="http2">HTTP2</h2><p>HTTP/1.1虽然有了长连接，但本质上请求还是<strong>串行</strong>的。为了并发下载资源，浏览器被迫对同一个域名开启6 个 TCP 连接。HTTP/2 旨在解决这个问题。</p><h3 id="核心改变二进制分帧层-binary-framing-layer">1.核心改变：二进制分帧层 (Binary Framing Layer)</h3><p>这是 HTTP/2 的基石。</p><ul><li><strong>HTTP/1.1</strong>：纯文本，换行符分隔。解析慢，且无法交错。</li><li><strong>HTTP/2</strong>：将报文切分为更小的<strong>Frame（帧）</strong>。<ul><li><strong>Headers Frame</strong>：存放头部。</li><li><strong>Data Frame</strong>：存放包体。</li></ul></li><li><strong>意义</strong>：机器解析二进制比解析文本快得多，更重要的是，这为多路复用提供了基础。</li></ul><h3 id="多路复用-multiplexing解决-http-队头阻塞">2. 多路复用(Multiplexing)：解决 HTTP 队头阻塞</h3><ul><li><strong>机制</strong>：在一个 TCP 连接中，通过<strong>Stream（流）</strong> 的概念，同时传输多个请求的数据帧。<ul><li>每个帧都有一个 <code>Stream ID</code>。</li><li>比如：Stream 1 的帧和 Stream 2的帧可以<strong>乱序</strong>发送，接收端根据 ID 重新组装。</li></ul></li><li><strong>彻底解决</strong>：HTTP/1.1 的队头阻塞。请求 A的处理慢，完全不影响请求 B 的数据传输。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/HTTP1.1VSHTTP2.png" /></p><h3 id="hpack头部压缩">3. HPACK：头部压缩</h3><ul><li><strong>痛点</strong>：HTTP/1.1 的 Header 很多是冗余的（如 Cookie,User-Agent），每次都要重复发几百字节，浪费带宽。</li><li><strong>原理</strong>：<ul><li><strong>静态表</strong>：预定义 61 个常用头部（如<code>method: GET</code> 对应索引 2）。传输时只传索引号（1个字节）。</li><li><strong>动态表</strong>：连接建立后，双方动态维护一个表。第一次发过<code>User-Agent</code> 后，把它存入动态表，下次只发索引即可。</li><li><strong>Huffman 编码</strong>：对字符串进行压缩。</li></ul></li></ul><h2 id="tls1.2">TLS1.2</h2><p>在进入 HTTP3 之前，先来阐述一下 TLS1.2 和 TLS1.3，它们都是 HTTPS的基石。</p><p>HTTPS 常用的密钥交换算法有两种，分别是 RSA 和 ECDHE 算法。</p><p>其中，RSA是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而ECDHE 算法具有前向安全，所以被广泛使用。</p><h3 id="rsa">1. RSA</h3><p>我们先回顾一下 RSA方式的密钥交换，笔者发现大多数的书籍和文章介绍的都是这种方式。但事实上因为它不具备前向安全的性质，现在很少被服务器所使用。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251130232202995.png" /></p><ol type="1"><li><strong>客户端发送 ClientHello</strong>：客户端向服务器发送<code>ClientHello</code> 消息，包含支持的 TLS版本、加密算法列表、压缩方法以及一个随机数（ClientRandom），用于后续生成会话密钥。</li><li><strong>服务器发送 ServerHello</strong>：服务器收到<code>ClientHello</code> 后，选择一个 TLS 版本和加密算法，发送<code>ServerHello</code>消息，包含选择的版本、加密算法、另一个随机数（ServerRandom）以及服务器的数字证书（包含公钥和 CA 信息）。</li><li><strong>客户端验证证书并生成预主密钥</strong>：<ul><li>客户端验证服务器的数字证书，检查是否由受信任的 CA 颁发（一直验证到根CA）、是否在有效期内、域名是否匹配。如果验证通过，客户端生成一个预主密钥（Pre-MasterSecret），并用服务器的公钥加密后发送给服务器。</li><li>结合预主密钥，结合 Client Random 和 ServerRandom，生成对称加密的会话密钥（Session Key）。</li><li>并把迄今为止的通信数据内容生成一个摘要，形成 <code>Finished</code>报文，发送给服务端。</li></ul></li><li><strong>服务端生成会话密钥</strong>：<ul><li>服务器使用私钥解密客户端发送的预主密钥，结合 Client Random 和 ServerRandom，用跟客户端相同的算法生成对称加密的会话密钥（Session Key）。</li><li>然后发送 <code>Finished</code> 报文。</li></ul></li><li><strong>完成握手</strong>：如果双方都能正确解密对方的<code>Finished</code> 消息，握手成功。</li><li><strong>加密传输数据</strong>：握手完成后，客户端和服务器使用会话密钥对所有通信数据进行加密和解密，确保数据的机密性和完整性。</li></ol><h3 id="ecdhe">2. ECDHE</h3><div class="tag-plugin colorful note" color="orange"><div class="title"><strong><p>向前安全的定义</p></strong></div><div class="body"><p>即便<strong>现在</strong>私钥泄漏了，也无法破解<strong>过去</strong>截获的流量。</p></div></div><p>为什么说 TLS 1.2 使用 RSA 握手会有前向安全（ForwardSecrecy）的问题呢？</p><p>在 TLS 1.2 (RSA) 中，最终用来加密数据的 <strong>Session Key</strong>是这样算出来的：</p><p><span class="math display">\[Session\ Key = Function(ClientRandom, ServerRandom, Pre\text{-}Master\Secret)\]</span></p><p>因为 ClientRandom 和 ServerRandom都是明文的，所以<strong>整个会话的安全性，完全变成了"如何保护 Pre-MasterSecret"这一个问题</strong>。</p><p>只要私钥一旦泄露，那黑客就可以根据过完的 ClientRandom 和 ServerRandom以及解密后的 pre-master-secret 还原所有的历史消息。</p><p><strong>ECDHE</strong> 旨在解决这个问题。这个名字由四部分组成：</p><ul><li><strong>EC (Elliptic Curve)</strong>：椭圆曲线。相比RSA，它用更短的密钥就能实现同等强度，计算更快，带宽更省。</li><li><strong>DH(Diffie-Hellman)</strong>：密钥交换算法。它的魔力在于：<strong>双方只交换公钥，就能算出同一个密钥，而无需传递密钥本身。</strong></li><li><strong>E(Ephemeral)</strong>：<strong>临时（关键点！）</strong>。指每次握手生成的"私钥"都是临时的，用完即焚。</li></ul><p>它的核心原理是：<strong>核心原理（离散对数难题）</strong>。</p><p>为了不陷入复杂的数学证明，我们用最简化的数学逻辑描述：</p><p>假设椭圆曲线上有一个基点 <span class="math inline">\(G\)</span>。</p><ol type="1"><li><strong>Client</strong> 生成一个随机临时私钥 <spanclass="math inline">\(a\)</span>，计算公钥 <span class="math inline">\(A= a \cdot G\)</span>，发给 Server。</li><li><strong>Server</strong> 生成一个随机临时私钥 <spanclass="math inline">\(b\)</span>，计算公钥 <span class="math inline">\(B= b \cdot G\)</span>，发给 Client。</li><li><strong>计算共享密钥</strong>：<ul><li>Client 计算：<span class="math inline">\(S = a \cdot B = a \cdot b\cdot G\)</span></li><li>Server 计算：<span class="math inline">\(S = b \cdot A = b \cdot a\cdot G\)</span></li><li>结果一样！双方都得到了 <span class="math inline">\(S\)</span>。</li></ul></li></ol><blockquote><p><strong>注意</strong>：黑客截获了 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span>，但根据椭圆曲线离散对数难题，他无法反推出<span class="math inline">\(a\)</span> 或 <spanclass="math inline">\(b\)</span>，因此算不出 <spanclass="math inline">\(S\)</span>。</p></blockquote><p>为什么 ECDHE 有前向安全？在 ECDHE 中，<code>Session Key</code>依然需要三个参数，但第三个参数的来源变了：</p><ol type="1"><li>ClientRandom（明文，可见）。</li><li>ServerRandom（明文，可见）。</li><li><strong>ECDH 算出的共享密钥</strong>（替代了原来的 Pre-MasterSecret）。</li></ol><p><strong>关键区别在于</strong>：</p><ul><li>这个共享密钥是 Client 和 Server通过交换<strong>临时的（Ephemeral）</strong>公钥 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 算出来的。</li><li>在这个过程中，<strong>服务器的长期私钥仅仅用来"签名"</strong>（证明<span class="math inline">\(B\)</span>是我发的），而<strong>不参与密钥的加密或计算</strong>。</li><li>握手结束后，Client 和 Server 会把计算用的临时私钥 <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 删掉。</li></ul><p>我们来看使用 ECDHE 的握手流程：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251130231349481.png" /></p><ol type="1"><li><p><strong>客户端发送 ClientHello：</strong> 客户端向服务器发送ClientHello 消息，包含支持的 TLS 版本、加密算法列表（必须包含<strong>ECDHE</strong> 算法）、压缩方法以及一个随机数（<strong>ClientRandom</strong>）。</p></li><li><p><strong>服务器发送 ServerHello 和密钥协商参数：</strong>服务器收到 ClientHello 后，选择 ECDHE 算法，发送ServerHello（包含选择的版本、算法、<strong>ServerRandom</strong>）以及服务器数字证书。</p><blockquote><p><strong>关键区别</strong>：服务器会在本地生成一对<strong>临时的</strong>椭圆曲线公私钥。它将<strong>服务器临时公钥</strong>发送给客户端，并用证书中的<strong>长期私钥</strong>对这个临时公钥进行<strong>数字签名</strong>，以防止篡改。</p></blockquote></li><li><p><strong>客户端验证并协商预主密钥：</strong></p><ul><li><p>客户端验证服务器证书的合法性。并用证书中的长期公钥验证收到的服务器临时公钥的<strong>签名</strong>是否有效。</p></li><li><p>验证通过后，客户端也在本地生成一对<strong>临时的</strong>椭圆曲线公私钥。</p></li><li><p><strong>计算预主密钥</strong>：客户端利用<strong>自己的临时私钥</strong>和收到的<strong>服务器临时公钥</strong>，通过ECDH 算法在本地计算出预主密钥（Pre-Master Secret）。</p></li><li><p>客户端将<strong>自己的临时公钥</strong>明文发送给服务器。</p></li><li><p>结合算出的预主密钥、Client Random 和 ServerRandom，生成会话密钥（Session Key），并发送 Finished 报文。</p></li></ul></li><li><p><strong>服务端计算预主密钥：</strong></p><ul><li><strong>计算预主密钥</strong>：服务器收到客户端的临时公钥后，利用<strong>自己的临时私钥</strong>和收到的<strong>客户端临时公钥</strong>，通过同样的ECDH 算法在本地计算出<strong>一模一样</strong>的预主密钥。</li><li>结合预主密钥、Client Random 和 ServerRandom，生成相同的会话密钥（Session Key），并发送 Finished 报文。</li></ul></li><li><p><strong>完成握手：</strong> 如果双方都能正确解密对方的 Finished消息，握手成功。双方立即<strong>删除</strong>各自生成的临时公私钥（实现前向安全）。</p></li><li><p><strong>加密传输数据：</strong>握手完成后，客户端和服务器使用会话密钥对通信数据进行加密传输。</p></li></ol><h2 id="tls1.3">TLS1.3</h2><p>TLS 1.2 虽然支持 ECDHE，但握手还是很慢（需要2-RTT），而且保留了很多不安全的加密算法。TLS 1.3做了大刀阔斧的改革。</p><p>TLS 1.2的逻辑是：<strong><u>"先打招呼，商量用什么算法，再交换密钥"</u></strong>。TLS 1.3的逻辑是：<strong><u>"我猜你会用这个算法，先把公钥给你！"</u></strong></p><h3 id="rtt">1-RTT</h3><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251130231937223.png" /></p><p>通过上述流程图可以看到，TLS1.3 直接从 2-RTT 缩短到了 1-RTT：</p><ul><li>Client 在发 <code>ClientHello</code>时，不再干等服务器选算法，而是<strong>直接猜测</strong>服务器支持ECDHE，并直接把自己的<strong>Key Share（临时公钥）</strong>一起发过去。</li><li>Server 收到后直接生成密钥，回复 <code>ServerHello</code> +<code>Finished</code>。握手直接结束。</li></ul><h3 id="rtt-1">0-RTT</h3><p>更进一步，如果是连接恢复的情况，TLS1.3 还可以做到 0-RTT。</p><p>在初始连接 1-RTT之后，在连接结束前，服务器会生成一个极其重要的数据结构，叫做<strong>Session Ticket（会话票据）</strong>，并通过<code>NewSessionTicket</code> 指令发给客户端。<strong>SessionTicket</strong> 包含了 Pre-Shared Key（预共享密钥）</p><ul><li>一个 <strong>PSK (Pre-SharedKey，预共享密钥)</strong>：这是从当前的会话主密钥衍生出来的一个秘密数据。</li><li>有效期、加密算法等信息。</li><li>这个 Ticket通常只有服务器能解密（用服务器只有自己知道的密钥加密）。</li></ul><p>客户端收到 Ticket后，把它安全地存在本地（比如浏览器的缓存里），然后断开连接。</p><p>假设过了几个小时，用户又打开了同一个网站。客户端发现本地有上次存的Ticket。</p><p><strong>客户端动作：</strong></p><ol type="1"><li><strong>取出 PSK</strong>：客户端从 Ticket 里提取出 PSK。</li><li><strong>生成早期密钥</strong>：客户端利用这个 PSK，结合当前的 ClientRandom，提前算出用于加密早期数据（Early Data）的密钥。</li><li><strong>客户端构造一个超级数据包，一次性发给服务器：</strong><ul><li><strong>ClientHello</strong>：标准的问候，包含支持的算法、随机数。</li><li><strong>Session Ticket</strong></li><li><strong>Key Share</strong>：为了保险起见，依然带上新的 ECDHE临时公钥（万一 0-RTT 失败了，可以无缝降级回 1-RTT）。</li><li><strong>Early Data(加密的)</strong>：这是重点！用刚才算的早期密钥加密的 HTTP 请求（如<code>GET /index.html</code>）。</li></ul></li></ol><p><strong>服务器动作：</strong></p><ol type="1"><li><strong>收到大礼包</strong>：服务器收到这一大堆数据。</li><li><strong>验证凭证</strong>：服务器解密 SessionTicket，确认它有效，并从中提取出 <strong>PSK</strong>。</li><li><strong>尝试解密</strong>：服务器用提取出的PSK，算出同样的早期密钥，尝试解密后面的 <strong>EarlyData</strong>。</li><li><strong>并行处理（极速的核心）</strong>：<ul><li><strong>路径A（应用层）</strong>：如果解密成功，服务器<strong>立即</strong>把解出来的HTTP 请求（GET /）交给后端应用（比如Nginx/Tomcat）去处理。<strong>此时此刻，握手甚至还没完成，但服务器已经开始干活了！</strong></li><li><strong>路径 B（握手层）</strong>：与此同时，服务器利用客户端发来的Key Share，完成标准的 ECDHE密钥协商，生成<strong>新的</strong>、具有前向安全的正式会话密钥。</li></ul></li><li><strong>回复</strong>：服务器发送 <code>ServerHello</code> +<code>Finished</code>（完成握手），紧接着发送用新密钥加密的 HTTP响应（网页内容）。</li></ol><p><strong>效果对比：</strong></p><ul><li><strong>1-RTT</strong>：客户端发送 -&gt; 服务器处理握手 -&gt;服务器回复握手完成 -&gt; 客户端发送 HTTP 请求 -&gt;服务器处理并回复网页。</li><li><strong>0-RTT</strong>：客户端发送(含 HTTP 请求) -&gt;服务器处理握手并<strong>同时</strong>处理 HTTP 请求 -&gt;服务器回复握手完成和网页内容。</li><li>用户感受到网页加载的时间，整整少了一个RTT。在跨国网络或移动网络下，这可能是几百毫秒的提升。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251130233954053.png" /></p><p>然而！天下没有免费的午餐。0-RTT带来了极致的速度，也引入了一个巨大的安全风险。</p><p>在标准的 ECDHE 握手中，每次的密钥都是基于<strong>全新的</strong>Client Random 和 Server Random实时计算出来的。黑客录制了昨天的握手数据包，今天重新发给服务器，服务器一看随机数是旧的，或者因为没有对应的临时私钥无法算出正确的密钥，直接就拒绝了。</p><p>然而 0-RTT 用于加密 Early Data 的密钥，是基于<strong>以前</strong>的PSK 衍生出来的，所以是存在重放危险的！</p><p>由于这个致命缺陷，TLS 1.3 标准明确建议：<strong>千万不要用 0-RTT发送非幂等（Non-Idempotent）请求！</strong></p><ul><li><strong>安全场景</strong>：<code>GET</code>请求（如获取图片、网页）。重放多少次结果都一样，没副作用。</li><li><strong>危险场景</strong>：<code>POST</code>、<code>PUT</code>、<code>DELETE</code>等改变服务器状态的请求。</li></ul><h2 id="http3">HTTP3</h2><p>HTTP/3 不再使用 TCP，而是基于 Google 开发的<strong>QUIC</strong>（Quick UDP Internet Connections），底层使用<strong>UDP</strong>。</p><h3 id="核心机制">1. 核心机制</h3><ul><li><strong>机制 1：独立的流控制（解决 TCP 队头阻塞）</strong><ul><li>QUIC 在用户态（User Space）实现了类似 TCP 的可靠传输。</li><li>但它知道"流"的概念。如果 Stream 1 丢包，QUIC 只会阻塞 Stream1，Stream 2 的数据包可以直接交给浏览器渲染。</li></ul></li><li><strong>机制 2：连接迁移 (Connection Migration)</strong><ul><li><strong>TCP</strong>：使用四元组（源 IP, 源端口, 目的 IP,目的端口）标识连接。手机从 Wi-Fi 切到 4G，源 IP变了，连接断开，必须重连。</li><li><strong>QUIC</strong>：使用 <strong>Connection ID</strong> (CID)标识连接。只要 CID 不变，IP 变了也能继续传输，实现无缝网络切换。</li></ul></li><li><strong>机制 3：内置 TLS 1.3</strong><ul><li>HTTP/3 没有把 TLS 当作上层协议，而是直接将 TLS 1.3 的握手过程嵌入到QUIC 的建立过程中。</li><li>传输层握手 + 加密层握手合并，实现真正的 1-RTT 建连（TCP+TLS需要分别握手）。</li></ul></li><li><strong>机制 4：用户态拥塞控制</strong><ul><li>TCP 的拥塞控制（CUBIC, BBR）在操作系统内核里，升级困难（需要更新OS）。</li><li>QUIC在应用层实现，浏览器更新一下就能换用最新的拥塞控制算法，迭代极快。</li></ul></li><li><strong>QPACK</strong>：<ul><li>HTTP/2 的 HPACK 依赖于数据的顺序到达（更新动态表）。</li><li>由于 QUIC 允许乱序，HPACK 失效。HTTP/3 引入了QPACK，专门适配乱序环境下的头部压缩。</li></ul></li></ul><h3 id="握手机制">2. 握手机制</h3><p>接下来我们重点讨论 QUIC（HTTP3）的握手机制。QUIC的握手是其最核心的创新之一，它解决了 TCP + TLS分层架构带来的根本性低效问题。</p><p>在传统的 HTTPS (HTTP/2) 中，网络栈是分层的：</p><ol type="1"><li><strong>TCP 层</strong>：先花1-RTT（三次握手）建立可靠连接。此时数据是明文的。</li><li><strong>TLS 层</strong>：再花 1-RTT（TLS 1.3）在 TCP之上协商密钥。</li></ol><p>总共需要 <strong>2-RTT</strong> 才能开始发 HTTP 数据。</p><div class="tag-plugin colorful note" color="green"><div class="title"><strong><p>QUIC 的革命性设计：融合层级</p></strong></div><div class="body"><p>QUIC 基于 UDP，UDP 没有连接的概念。QUIC协议栈<strong>直接包含</strong>了 TLS 1.3 模块。 QUIC的握手目标是：<strong>在建立逻辑连接的同时，完成加密密钥的协商。</strong>它把这两个步骤合并成了真正的<strong>1-RTT</strong>。</p></div></div><p>在深入 QUIC 的握手机制之前，我们需要先了解几个 QUIC 特有的概念：</p><ol type="1"><li><p><strong>Connection ID (CID, 连接 ID)</strong>：</p><ul><li><p>因为 UDP 没有连接，IP地址和端口又可能会变（比如手机切网络），QUIC 使用 CID来标识一个连接。</p></li><li><p>每个数据包头都会带上目标 CID (DCID) 和源 CID(SCID)。这使得连接可以迁移。</p></li></ul></li><li><p><strong>报文类型 (Packet Types)</strong>：</p><ul><li><p>QUIC 在握手阶段使用特殊的长首部（Long Header）报文。</p></li><li><p><strong>Initial 包</strong>：用于承载 TLS 的<code>ClientHello</code> 和 <code>ServerHello</code>。</p></li><li><p><strong>Handshake 包</strong>：用于承载加密后的 TLS握手消息（如证书、Finished）。</p></li><li><p><strong>0-RTT 包</strong>：用于承载 0-RTT的早期应用数据。</p></li><li><p><strong>Short Header包</strong>：握手完成后，传输普通应用数据使用。</p></li></ul></li><li><p><strong>反放大攻击 (Anti-Amplification)</strong>：</p><ul><li>由于 UDP 容易被伪造 IP 进行 DDoS 攻击（发送小包骗取大包回复），QUIC规定在验证客户端 IP地址之前，服务器回复的数据量不能超过客户端发送数据量的 3 倍。</li></ul></li></ol><h4 id="rtt-2">2.1 1-RTT</h4><p>这是最基础的场景，目标是达到 TLS 1.3 的 1-RTT 效果，但不需要 TCP握手。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251130235652829.png" /></p><p><strong>步骤 1：客户端发送 Initial 包</strong></p><ul><li><strong>外层 (QUIC)</strong>：客户端生成一个随机的各种 CID。封装一个<code>Initial</code> 类型的 QUIC 包。</li><li><strong>内层 (TLS 1.3)</strong>：包含标准的 TLS<code>ClientHello</code> 消息。<ul><li>带着 Key Share（猜测的临时公钥，如 X25519 公钥 A）。</li><li>带着 TLS 版本、加密套件列表等。</li></ul></li><li><strong>注意</strong>：这个包本身也需要加密，但因为还没协商密钥，所以使用一个协议标准里写死的"初始密钥"进行模糊化（Obfuscation），主要为了防干扰，不防黑客。</li></ul><p><strong>步骤 2：服务器回复 Initial + Handshake 包</strong></p><ul><li><p>服务器收到包，提取出 <code>ClientHello</code>，交给内置的 TLS模块处理。</p></li><li><p>TLS 模块生成自己的临时公钥 B，算出握手密钥（HandshakeKeys）。</p></li><li><p><strong>服务器需要连续发送两个逻辑上的包（可能会合并在一个 UDP数据报里）</strong>：</p><ol type="1"><li><strong>QUIC Initial 包</strong>：包裹着 TLS<code>ServerHello</code>（包含服务器的临时公钥B）。这个包用初始密钥模糊化。</li><li><strong>QUIC Handshake 包</strong>：包裹着 TLS的后续消息——<strong>证书 (Certificate)、签名(CertificateVerify)、结束消息 (Finished)</strong>。</li></ol><ul><li><strong>关键点</strong>：这个 Handshake包是使用刚才算出来的<strong>握手密钥加密</strong>的。这是第一批真正加密的数据。</li></ul></li></ul><p><strong>步骤 3：客户端完成握手并发送数据</strong></p><ul><li>客户端收到 <code>ServerHello</code>，算出握手密钥。</li><li>用握手密钥解密后续的 <code>Handshake</code>包，验证证书和签名。</li><li>验证成功后，客户端算出最终的传输层会话密钥（1-RTT Keys）。</li><li><strong>发送两个逻辑包</strong>：<ol type="1"><li><strong>QUIC Handshake 包</strong>：包裹着客户端的 TLS<code>Finished</code> 消息（用握手密钥加密）。</li><li><strong>QUIC Short Header 包</strong>：包裹着真正的 HTTP/3请求数据（如<code>GET /</code>），<strong>用最终会话密钥加密</strong>。</li></ol></li><li><strong>握手结束</strong>。</li></ul><h4 id="rtt-3">2.2 0-RTT</h4><p>如果你理解了 TLS 1.3 的 0-RTT 原理（利用之前的 PSK/Ticket），QUIC只是把它封装到了特定的包类型中。</p><blockquote><p>所以它跟 TCP+TLS1.3 的 0-RTT 一样会存在重放危险。</p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251201000218593.png" /></p><p><strong>步骤 1：客户端发送 Initial + 0-RTT 包（大礼包）</strong></p><ul><li>客户端找到了上次连接存下来的 Session Ticket (PSK)。</li><li>客户端使用 PSK 生成"早期数据密钥"。</li><li><strong>客户端一股脑发送出去：</strong><ol type="1"><li><strong>QUIC Initial 包</strong>：包含 TLS<code>ClientHello</code>，里面带着 PSK Ticket，同时也带着新的 Key Share(以防 0-RTT 失败回退到 1-RTT)。</li><li><strong>QUIC 0-RTT 包</strong>：使用早期密钥加密的 HTTP请求数据。</li></ol></li></ul><p><strong>步骤 2：服务器并行处理</strong></p><ul><li>服务器收到这些包。TLS 模块验证 PSK 成功。</li><li><strong>关键动作（并行）</strong>：<ul><li>服务器使用 PSK 算出早期密钥，<strong>立即解密 0-RTT 包里的 HTTP请求，交给后端应用处理</strong>。</li><li>同时，服务器利用 <code>ClientHello</code> 里的新 KeyShare，完成标准的 1-RTT 握手流程，生成新的、前向安全的会话密钥。</li></ul></li></ul><p><strong>步骤 3：服务器回复</strong></p><ul><li>服务器发送 <code>ServerHello</code>和加密的握手消息（Finished），完成正式握手。</li><li>紧接着发送用新密钥加密的 HTTP 响应数据。</li></ul><hr /><p>特殊情况：<strong>地址验证（Retry 机制）</strong></p><p>为了防止 UDP反放大攻击，当服务器是一个热门服务，它可能会要求客户端先证明"<u><strong>你确实拥有这个IP 地址，不是伪造的</strong></u>"。</p><p>这会引入一个额外的 RTT：</p><ol type="1"><li><strong>Client -&gt; Server</strong>: 发送 <code>Initial</code> 包(ClientHello)。</li><li><strong>Server -&gt; Client</strong>: 服务器感觉有风险，不进行复杂的TLS 运算，而是回复一个很小的 <strong>QUIC Retry包</strong>，里面包含一个加密的 <strong>Token</strong>。</li><li><strong>Client -&gt; Server</strong>: 客户端收到 Retry，必须重新发送<code>Initial</code> 包，但这次要带上刚才收到的<strong>Token</strong>。</li><li><strong>Server -&gt; Client</strong>: 服务器验证 Token有效，确认客户端 IP 没问题，才开始正常的 1-RTT 握手流程（回复Certificate 等）。</li></ol><p>虽然多了一步，但这是一个轻量级的 UDP 交互，比完整的 TCP握手还是要快。</p><h2 id="总结">总结</h2><p>回顾从 HTTP/1.0 到 HTTP/3的二十多年演进历程，我们可以清晰地看到，推动 Web协议不断升级的核心动力，始终是为了提供<strong>更快、更稳、更安全</strong>的网络体验。这是一部与网络延迟、带宽限制和计算成本进行持续抗争的历史。</p><ul><li><strong>HTTP/1.0 -&gt; HTTP/1.1</strong>：为了解决 TCP短连接带来的巨大开销，HTTP/1.1引入了<strong>持久连接（Keep-Alive）</strong>，让多个请求可以复用同一个TCP 连接，显著减少了握手次数，是 Web 性能优化的第一步。</li><li><strong>HTTP/1.1 -&gt; HTTP/2</strong>：为了解决 HTTP/1.1在持久连接上仍然存在的<strong>应用层队头阻塞</strong>问题，HTTP/2引入了<strong>二进制分帧</strong>和<strong>多路复用（Multiplexing）</strong>。它允许在同一个TCP连接上并发处理多个请求和响应，极大地提高了带宽利用率和并发能力。</li><li><strong>TLS 的演进 (1.2 -&gt; 1.3)</strong>：在安全层面，TLS协议也在不断进化。TLS 1.3通过废除不安全的加密算法、强制使用具备<strong>前向安全</strong>的 ECDHE密钥交换，并将握手流程极致优化至 <strong>1-RTT</strong> 甚至<strong>0-RTT</strong>，实现了速度与安全的双重飞跃。</li><li><strong>HTTP/2 -&gt; HTTP/3</strong>：为了彻底解决受制于 TCP协议特性的<strong>传输层队头阻塞</strong>以及网络切换时的连接中断问题，HTTP/3做出了颠覆性的改变。它基于 UDP 构建了全新的 <strong>QUIC</strong>协议，将 TLS 1.3 的安全握手深度融合，实现了真正的 <strong>1-RTT</strong>建连、基于 <strong>Connection ID</strong>的无缝连接迁移，以及更高效的独立流控制。</li></ul><p>从最初的简单文本传输，到如今基于 UDP 的高性能、高安全复合协议，HTTP的演进之路从未停歇。未来的网络协议将如何发展？也许会更加智能化、更加适应边缘计算和物联网的需求，但其核心目标——<strong>连接你我，更快更安全</strong>——将永远不变。</p>]]></content>
    
    
    <summary type="html">本文梳理了从 HTTP/1.0 到 HTTP/3 的发展历程，介绍了各版本在连接管理、性能优化及协议升级方面的核心变化，帮助读者理解现代 Web 通信协议的演化脉络。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="https://hedon.top/tags/HTTP/"/>
    
    <category term="HTTP1.0" scheme="https://hedon.top/tags/HTTP1-0/"/>
    
    <category term="HTTP2" scheme="https://hedon.top/tags/HTTP2/"/>
    
    <category term="HTTP3" scheme="https://hedon.top/tags/HTTP3/"/>
    
    <category term="QUIC" scheme="https://hedon.top/tags/QUIC/"/>
    
  </entry>
  
  <entry>
    <title>从第一性原理掌握 UDP/TCP/KCP/QUIC</title>
    <link href="https://hedon.top/2025/11/26/computer-net/net-udp-tcp-kcp-quic/"/>
    <id>https://hedon.top/2025/11/26/computer-net/net-udp-tcp-kcp-quic/</id>
    <published>2025-11-26T15:42:00.000Z</published>
    <updated>2025-11-29T06:16:28.462Z</updated>
    
    <content type="html"><![CDATA[<p>相信不少读者跟笔者一样，对计算机网络中传输层的各种协议背了又忘，忘了又背，背了还完。所以本篇想尝试从第一性原理出发，看看能否从根上去掌握传输层中的UDP、TCP、KCP 和 QUIC 协议（尽管 KCP 和 QUIC是在应用层进行实现的，不过因为其实现的功能属于传输层的范畴，所以笔者在本篇将将这二者归为传输层）。</p><p>特此声明，本篇是笔者与 Google Gemini 3Pro 共创所作，非常庆幸在当今 AI时代下获取知识已是如此便利，且也为学习者从第一性原理理解所学知识大大降低了门槛。不过本篇的篇章安排和叙述逻辑，均由笔者把控和审阅，欢迎放心阅读。</p><h2 id="宏观理解">1. 宏观理解</h2><p>之所以背了又忘，通常是因为我们把传输层看作是一堆枯燥的字段（Flags、Windowsize）和死记硬背的流程（三次握手、四次挥手），而忽略了它存在的<strong>核心目的</strong>和<strong>演化逻辑</strong>。</p><p>要从根本上理解传输层（TransportLayer），我们需要剥离掉具体的协议细节，回归到第一性原理：<strong>传输层到底解决了什么网络层（IP）解决不了的问题？</strong></p><h3 id="三个层级">1.2 三个层级</h3><p>我们可以将其分解为三个层级来理解：<strong>复用与分用</strong>、<strong>不可靠基础上的可靠性</strong>、<strong>传输效率的权衡</strong>。</p><h4 id="第一层级复用与复用">1.2.1 第一层级：复用与复用</h4><div class="tag-plugin colorful note" color="orange"><div class="title"><strong><p>👉🏻 核心逻辑</p></strong></div><div class="body"><p>从<strong>主机到主机</strong>进化为<strong>进程到进程</strong>。</p></div></div><p>网络层（IP 层）的任务非常纯粹：通过 IP地址，把数据包从地球的一端（主机 A）送到另一端（主机 B）。</p><p>但是，当数据包到达主机 B 时，IP 的任务就结束了。主机 B此时正运行着微信、浏览器、Steam 和网易云音乐。这个数据包到底是给谁的？IP协议不知道，也不管。</p><p>这就是传输层存在的<strong>第一个根本原因</strong>：</p><ul><li><strong>网络层</strong>只负责把快递送到<strong>大楼传达室</strong>（主机IP）。</li><li><strong>传输层</strong>负责把快递分发给大楼里的<strong>具体某个人</strong>（进程Port）。</li></ul><p>这个过程叫做<strong>复用（Multiplexing）</strong>和<strong>分用（Demultiplexing）</strong>。</p><blockquote><p>不要把端口想象成物理插口，它只是一个<strong>逻辑地址</strong>。如果没有传输层，你的电脑同一时间只能运行一个网络程序，这显然是不可接受的。</p></blockquote><h4 id="第二层级不可靠基础上的可靠性">1.2.2第二层级：不可靠基础上的可靠性</h4><div class="tag-plugin colorful note" color="orange"><div class="title"><strong><p>👉🏻 核心逻辑</p></strong></div><div class="body"><p>在不可靠的物理世界，构建一个完美的虚拟管道。</p></div></div><p>这是传输层最难理解、也最容易忘的部分。我们来看 TCP为什么要搞得这么复杂。</p><p><strong>第一性原理推导：</strong> 底层的网络环境（IP层及更底层）本质上是<strong>不可靠</strong>的。</p><ol type="1"><li><strong>丢包：</strong> 路由器太忙，直接把包扔了。</li><li><strong>乱序：</strong>或者是前面的包走了远路，后面的包走了近路。</li><li><strong>篡改/错误：</strong> 电信号干扰导致比特翻转。</li></ol><p>如果你的应用是"银行转账"或"网页浏览"，你无法容忍上述任何一种情况。你希望应用层感受到的是一条<strong>连续的、无差错的字节流</strong>。</p><p>TCP的所有机制，都是为了填补"不可靠的现实"与"可靠的需求"之间的鸿沟。我们不需要死记硬背，而是通过问题来推导方案：</p><ol type="1"><li><strong>问题：我怎么知道数据包丢没丢？</strong><ul><li><strong>方案（确认应答 ACK）：</strong>接收方收到数据必须回一个"收到了"。</li><li><strong>衍生问题：</strong> 如果发送方一直收不到 ACK 怎么办？</li><li><strong>方案（超时重传）：</strong>设个闹钟，时间到了没消息就重发。</li></ul></li><li><strong>问题：数据包乱了怎么办？重复了怎么办？</strong><ul><li><strong>方案（序列号 Sequence Number）：</strong>给每个字节的数据编号。1, 2, 3...这样接收方就可以重新排序，或者丢弃重复的号。</li></ul></li><li><strong>问题：接收方处理不过来怎么办？（比如服务器太慢，或者你发得太快）</strong><ul><li><strong>方案（流量控制 Flow Control）：</strong>接收方在回信里告诉发送方："我的缓冲区还剩 X 大小（WindowSize）"。发送方根据这个 X调整发送速度。这就是<strong>滑动窗口</strong>的本质——保护接收方。</li></ul></li><li><strong>问题：网线堵塞了怎么办？（中间的路由器处理不过来）</strong><ul><li><strong>方案（拥塞控制 Congestion Control）：</strong> 这是 TCP最伟大的设计。发送方通过试探（慢启动、拥塞避免），感知网络的拥堵程度。一旦发现丢包（暗示堵车），立马减速。这是一个<strong>保护互联网基础设施</strong>的利他机制。</li></ul></li></ol><blockquote><p>不要孤立地背诵"慢启动"、"快重传"。把 TCP想象成一个<strong>强迫症晚期的快递员</strong>：他必须给每一个包裹编号（序列号），必须拿到客户的签字（ACK），发现客户家堆满了（流量控制）就暂停发货，发现路上堵车（拥塞控制）就换个时间发。</p></blockquote><h4 id="第三层级速度与质量的权衡">1.2.3 第三层级：速度与质量的权衡</h4><div class="tag-plugin colorful note" color="orange"><div class="title"><strong><p>👉🏻 核心逻辑</p></strong></div><div class="body"><p>有时候，比起<strong>准确</strong>，我更需要<strong>实时</strong>。</p></div></div><p>并不是所有应用都需要 TCP 那样的强迫症。</p><ul><li><strong>场景：</strong> 视频通话、在线 FPS 游戏（如 CS:GO）。</li><li><strong>思考：</strong> 在视频通话中，如果第 5 秒的画面丢了一帧，TCP会怎么做？它会暂停后续播放，疯狂重传第 5秒的那一帧，直到成功。等你看到那一帧时，已经是第 8秒了，画面卡顿延迟。</li><li><strong>实际需求：</strong> 丢了就丢了，赶紧把第 6 秒、第 7秒的画面给我，我要的是<strong>实时性</strong>。</li></ul><p>这就是 <strong>UDP（用户数据报协议）</strong> 的生存空间。</p><ul><li>它几乎不加修饰，只做最基础的“复用/分用”（加个端口号）。</li><li>它不保证到达，不保证顺序，没有拥塞控制。</li><li><strong>特点：</strong> 快、自由、无连接。</li></ul><p><strong>理论与实践结合：</strong></p><ul><li><strong>HTTP/3 (QUIC)：</strong> 现在的互联网巨头发现 TCP太重了（握手慢、队头阻塞），于是开始在 UDP之上重新实现一套可靠传输协议（QUIC）。这说明<strong>传输层的本质功能（可靠性）可以上移到应用层实现</strong>，但底层的物理限制永远存在。</li></ul><h4 id="总结">1.2.4 总结</h4><table><colgroup><col style="width: 10%" /><col style="width: 44%" /><col style="width: 44%" /></colgroup><thead><tr><th><strong>特性</strong></th><th><strong>TCP (Transmission Control Protocol)</strong></th><th><strong>UDP (User Datagram Protocol)</strong></th></tr></thead><tbody><tr><td><strong>角色人格</strong></td><td><strong>严谨的会计师</strong></td><td><strong>急躁的广播员</strong></td></tr><tr><td><strong>核心价值观</strong></td><td>可靠性 &gt; 实时性</td><td>实时性 &gt; 可靠性</td></tr><tr><td><strong>第一性原理</strong></td><td>通过<strong>确认、重传、排序、流控</strong>，将不可靠的 IP网络模拟成可靠的管道。</td><td>尽最大努力交付，保留 IP 网络的原始特性，只增加端口区分进程。</td></tr><tr><td><strong>连接方式</strong></td><td><strong>面向连接</strong> (三次握手确认双方都在线)</td><td><strong>无连接</strong> (想发就发，不管你在不在)</td></tr><tr><td><strong>典型应用</strong></td><td>网页 (HTTP)、邮件 (SMTP)、文件传输 (FTP)</td><td>直播、视频会议、DNS、早期的 QUIC</td></tr></tbody></table><h3 id="三个时代">1.3 三个时代</h3><p>要彻底理解这四个协议，我们不能平铺直叙地去背它们的定义。我们需要站在<strong>进化论</strong>的视角，看它们是如何为了解决特定时代的特定痛点而诞生的。</p><p>这不仅仅是协议的区别，更是<strong>思维模式（Mindset）</strong>的转变：从<strong>内核态的僵化</strong>走向<strong>用户态的灵活</strong>。</p><p>我们将这四个协议分为三个代际来理解：<strong>二元对立的世界 (TCP vsUDP)</strong>、<strong>暴力美学的补丁 (KCP)</strong> 和<strong>颠覆架构的革命 (QUIC / HTTP3)</strong>。</p><h4 id="第一代二元对立的世界-tcp-vs-udp">1.3.1 第一代：二元对立的世界(TCP vs UDP)</h4><p>这是互联网早期的基础设定。设计者面临一个根本的取舍（Trade-off）：<strong>你是要绝对准确，还是要绝对速度？</strong></p><p><strong>1. TCP (Transmission Control Protocol) —— 老好人</strong></p><ul><li><strong>第一性原理：</strong> <strong>公平与可靠</strong>。</li><li><strong>痛点解决：</strong>互联网早期网络极不稳定，必须保证数据不丢、不乱。</li><li><strong>性格缺陷：</strong><ul><li><strong>太守规矩（慢）：</strong>建立连接要三次握手，断开要四次挥手。</li><li><strong>太顾大局（拥塞控制）：</strong> 一旦发现丢包，TCP默认认为是网络堵了，为了不给互联网添乱，它会立刻减速（慢启动、拥塞避免）。哪怕其实只是因为你家WiFi 信号抖了一下，它也会大幅降低速度。</li><li><strong>队头阻塞（Head-of-Line Blocking）：</strong>前面一个包没到，后面的包到了也不能用，必须排队等。</li></ul></li></ul><p><strong>2. UDP (User Datagram Protocol) —— 甩手掌柜</strong></p><ul><li><strong>第一性原理：</strong> <strong>简单与直接</strong>。</li><li><strong>痛点解决：</strong> 解决 TCP 头部太大、握手太慢的问题。</li><li><strong>性格特征：</strong><ul><li>只管发，不管你收没收到。</li><li>没有任何"流控"或"拥塞控制"，有多少发多少。</li></ul></li><li><strong>问题：</strong> 在复杂的互联网环境下，纯 UDP几乎无法直接传输关键数据，因为丢包率不可控。</li></ul><h4 id="第二代暴力美学的补丁-kcp">1.3.2 第二代：暴力美学的补丁(KCP)</h4><p>随着<strong>实时对战游戏（如王者荣耀、MMORPG）</strong>的兴起，开发者遇到了两难：</p><ul><li>用 TCP？延迟太高，角色瞬移，因为 TCP 一丢包就降速等待。</li><li>用 UDP？包丢了技能放不出来。</li></ul><p>于是，<strong>KCP</strong>诞生了。它不是一个标准的网络协议，而是一个运行在 UDP之上的<strong>算法库</strong>。</p><ul><li><strong>核心逻辑：</strong><strong>用带宽换延迟（流量换速度）</strong>。</li><li><strong>第一性原理：</strong> TCP的可靠性逻辑是对的（要确认、要重传），但 TCP的<strong>策略太保守了</strong>。KCP 在 UDP 上重新实现了 TCP的可靠机制，但把参数调得非常激进。</li><li><strong>KCP 怎么魔改 TCP 的？</strong><ol type="1"><li><strong>死不退让（RTO 不翻倍）：</strong> TCP发现超时，下一次等待时间会翻倍（1s -&gt; 2s -&gt; 4s）；KCP说不，超时了我立马重传，等待时间只增加一点点（1s -&gt;1.5s），绝不让用户等。</li><li><strong>选择性重传：</strong> 丢了哪个包，只重传那个包，不像早期 TCP可能把后续的一起重传。</li><li><strong>快速重传：</strong> 只要发现跳号（比如收到了 1, 3, 4，没收到2），KCP 不等超时，立马重传 2。</li></ol></li><li><strong>代价：</strong> 会比 TCP 多消耗 10%-20%的带宽。这是一种自私的协议，为了我的应用快，我不惜挤占网络资源。</li><li><strong>总结：</strong> <strong>KCP = 激进版 TCP + UDP的外壳</strong>。</li></ul><h4 id="颠覆架构的革命-quic-http3">1.3.3 颠覆架构的革命 (QUIC /HTTP3)</h4><p>到了移动互联网时代，网页请求变得极其复杂（一个页面几百个资源），且用户经常切换网络（从WiFi 切到 4G）。TCP 的<strong>底层架构</strong>（基于 IP和端口）和<strong>队头阻塞</strong>成了瓶颈。KCP这种小修小补已经不够了。</p><p>Google 站出来说：我们要重新发明轮子。这就是 <strong>QUIC (Quick UDPInternet Connections)</strong>。</p><ul><li><strong>核心逻辑：</strong><strong>移花接木，在用户态重构一切</strong>。</li><li><strong>第一性原理：</strong> 既然操作系统的 TCP协议栈（Kernel）更新太慢（你没法强迫全世界升级 Windows/Linux内核），那我们就绕过内核，<strong>在应用层（用户态）基于 UDP自己写一套完美的传输协议</strong>。</li><li><strong>QUIC 解决了什么 TCP 解决不了的问题？</strong><ol type="1"><li><strong>彻底解决队头阻塞（多路复用）：</strong><ul><li><strong>TCP：</strong> 一条高速公路，前面车坏了，后面全堵死。</li><li><strong>QUIC：</strong>并不是单纯的一条路，而是并行的多车道（Stream）。图片 A的包丢了，只影响图片 A，不影响旁边的 CSS 文件和文字加载。这是 QUIC最核心的优势。</li></ul></li><li><strong>网络切换不断线（Connection Migration）：</strong><ul><li><strong>TCP：</strong> 依靠 IP:Port 识别连接。你从 WiFi (IP: A)切换到 4G (IP: B)，IP 变了，TCP 连接必断，必须重新握手。</li><li><strong>QUIC：</strong> 发明了一个 <strong>Connection ID(UUID)</strong>。不管你的 IP 怎么变，只要 ID没变，服务端就知道还是你，连接保持，无需重连。</li></ul></li><li><strong>0-RTT 建连：</strong><ul><li>TCP + TLS 需要多次往返才能建立加密连接。QUIC把传输层握手和加密层（TLS 1.3）握手合并了，最快可以做到 0延迟发送数据。</li></ul></li></ol></li></ul><h4 id="总结-1">1.3.4 总结</h4><table><colgroup><col style="width: 9%" /><col style="width: 18%" /><col style="width: 18%" /><col style="width: 24%" /><col style="width: 29%" /></colgroup><thead><tr><th><strong>协议</strong></th><th><strong>TCP</strong></th><th><strong>UDP</strong></th><th><strong>KCP</strong></th><th><strong>QUIC (HTTP/3)</strong></th></tr></thead><tbody><tr><td><strong>本质身份</strong></td><td><strong>正规军</strong> (OS内核实现)</td><td><strong>传令兵</strong> (OS内核实现)</td><td><strong>雇佣兵</strong> (应用层算法库)</td><td><strong>特种部队</strong> (应用层协议栈)</td></tr><tr><td><strong>底层载体</strong></td><td>IP</td><td>IP</td><td><strong>UDP</strong></td><td><strong>UDP</strong></td></tr><tr><td><strong>核心哲学</strong></td><td>可靠性、公平性、顺序</td><td>简单、快、无状态</td><td><strong>速度优先</strong> (牺牲带宽换低延迟)</td><td><strong>效率优先</strong> (解决队头阻塞、快速握手)</td></tr><tr><td><strong>丢包处理</strong></td><td>减速、退让、重传</td><td>不管</td><td><strong>激进重传</strong>、死不退让</td><td>独立流重传 (只重传丢的那一路)</td></tr><tr><td><strong>连接识别</strong></td><td>五元组 (IP:Port...)</td><td>无连接</td><td>会话 ID (Conv ID)</td><td><strong>Connection ID</strong> (不怕切网络)</td></tr><tr><td><strong>典型场景</strong></td><td>网页、文件下载、金融</td><td>DNS、广播、简单的 IoT</td><td><strong>MOBA 游戏、实时音视频</strong></td><td><strong>下一代 Web、YouTube、Gmail</strong></td></tr></tbody></table><ol type="1"><li><strong>TCP 和 UDP</strong>是操作系统提供的<strong>原材料</strong>。TCP 也就是加了确认和流控的UDP。</li><li><strong>KCP</strong>是为了<strong>游戏</strong>和<strong>弱网环境</strong>，在 UDP上<strong>模仿并魔改</strong>了 TCP，甚至不惜浪费流量也要快。</li><li><strong>QUIC</strong> 是为了<strong>现代 Web</strong>，在 UDP上<strong>彻底重写</strong>了 TCP + TLS，解决了 TCP几十年改不掉的"队头阻塞"和"僵化"毛病。</li></ol><p><strong>一句话总结：</strong> TCP 是老古董，UDP 是地基，KCP是为了快而拼命的魔改插件，QUIC 是试图取代 TCP 的下一代互联网标准。</p><h2 id="底层剖析">2. 底层剖析</h2><p>要详细剖析这四个协议的底层原理，我们必须深入到<strong>数据包（Packet）的结构</strong>和<strong>状态机（StateMachine）</strong>的控制逻辑中去。</p><p>我们要抓住一个核心矛盾：<strong>如何在不可靠的物理线路（丢包、乱序、延迟）上，构建出符合应用层需求的逻辑管道。</strong></p><h3 id="udp裸奔的传输层">2.1 UDP：裸奔的传输层</h3><p>UDP 是理解其他所有协议的基准。它的底层原理非常简单，几乎就是 IP协议的“影分身”。</p><h4 id="头部结构">2.1.1 头部结构</h4><p>UDP 的头部只有 8 个字节。</p><ul><li><strong>Source Port &amp; Destination Port：</strong>也就是前面提到的"复用/分用"。</li><li><strong>Length &amp; Checksum：</strong>告诉你包有多长，校验一下数据有没有坏（比特翻转）。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251127132809962.png" style="zoom:33%;" /></p><h4 id="核心机制">2.1.2 核心机制</h4><ul><li><strong>无状态（Stateless）：</strong> 操作系统内核不会为 UDP维护任何表格。来一个包，查一下端口，扔给应用程序。发一个包，直接扔给网卡。</li><li><strong>MTU 限制：</strong> UDP 不负责切分数据。如果你应用层给 UDP一个 2000 字节的数据包，而底层以太网 MTU 只有 1500，IP层会进行分片（Fragmentation）。一旦其中一个分片丢了，整个 UDP包就废了。</li></ul><blockquote><p>既然 UDP 什么都不管，那么所有的高级功能（KCP 的重传、QUIC的流控）都必须由<strong>应用层代码</strong>自己来实现。</p></blockquote><h3 id="tcp流量与拥塞的博弈">2.2 TCP：流量与拥塞的博弈</h3><p>传输控制协议（TCP）是互联网的基石，其设计目标是在不可靠的 IP网络上提供<strong>可靠（Reliable）</strong>、<strong>有序（Ordered）</strong>且<strong>错误检查（Error-Checked）</strong>的字节流服务。从第一性原理来看，TCP是一个复杂的控制论系统，通过负反馈机制（ACK）来调节系统的输入（发送速率），以维持系统的稳定性（避免拥塞崩溃）。</p><h4 id="字节流抽象与序列号管理">2.2.1 字节流抽象与序列号管理</h4><p>TCP 的核心抽象是<strong>字节流</strong>。不同于 UDP 的报文，TCP将应用层数据视为无边界的水流。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251127132830720.png" style="zoom:33%;" /></p><p>为了实现有序重组，TCP为发送的每一个<strong>字节</strong>（Octet）分配一个 32 位的序列号。</p><ul><li><strong>语义</strong>：TCP 段头部的 <code>Sequence Number</code>字段表示该段数据载荷中<strong>第一个字节</strong>在整个数据流中的偏移量。</li><li><strong>ACK 机制</strong>：TCP 使用累积确认（CumulativeACK）。<code>Acknowledgment Number</code>表示接收端<strong>期望收到</strong>的下一个字节的序列号。例如，ACK=1001意味着 1000 及以前的所有字节均已正确接收。</li></ul><p>内核为每个 TCP 连接维护一个接收缓冲区（Receive Buffer）。</p><ul><li>当数据包乱序到达（例如，先收到 SEQ 2000，后收到 SEQ 1000），内核会将SEQ 2000 的数据暂存在缓冲区中的对应位置（SACK机制辅助记录这一空洞）。</li><li>只有当 SEQ 1000 到达填补空洞后，内核才会更新 ACK指针，并唤醒用户进程读取数据。</li><li><strong>队头阻塞（Head-of-Line Blocking, HOL）</strong>：这是 TCP在低延迟场景下的致命弱点。如果 SEQ 1000 的包丢失，即使 SEQ 2000-5000的数据已经完整到达，应用层也无法读取这 3000 字节。内核必须等待 SEQ 1000重传成功，才能交付后续数据。在丢包率为 1%-2% 的网络中，HOL会导致巨大的延迟抖动。</li></ul><h4 id="可靠传输rto-与-arq">2.2.2 可靠传输：RTO 与 ARQ</h4><p>TCP的可靠性依赖于自动重传请求（ARQ）。核心问题在于：发送端发出数据后，应该等待多久才认为数据丢失？这个时间被称为<strong>重传超时（RTO）</strong>。</p><p>RTO 的计算必须基于对往返时间（RTT）的动态估算。</p><ul><li><p>SRTT（SmoothedRTT）：采用指数加权移动平均（EWMA）算法平滑采样值。 <spanclass="math display">\[SRTT_{new} = (1 - \alpha) \cdot SRTT_{old} + \alpha \cdot RTT_{sample}\]</span> 其中 <span class="math inline">\(\alpha\)</span> 通常取0.125。</p></li><li><p>RTTVAR（RTT Variation）：Van Jacobson 引入了对 RTT抖动（方差）的估算，以适应网络波动 17。</p><p><span class="math display">\[RTTVAR_{new} = (1 - \beta) \cdot RTTVAR_{old} + \beta \cdot |SRTT_{old}- RTT_{sample}|\]</span> 最终 RTO 计算公式为： <span class="math display">\[RTO = SRTT + 4 \cdot RTTVAR\]</span> 系数 4 的选择基于切比雪夫不等式，旨在覆盖 99% 以上的 RTT分布。</p></li><li><p><strong>Karn算法</strong>：解决重传二义性问题。如果一个包发生了重传，收到 ACK时无法确定是回应原包还是重传包，因此 Karn算法规定：<strong>发生重传时，不更新 RTT 估算值，并将 RTO指数退避（Exponential Backoff）</strong> 。</p></li></ul><p>等待 RTO 超时过于缓慢。TCP 引入了快速重传机制：当发送端收到 <strong>3个重复的 ACK（Duplicate ACK）</strong> 时，推断该 ACK指示的下一个报文段已丢失，立即重传，而不必等待定时器溢出。这一机制利用了"重复ACK"作为网络丢包的隐式信号，显著降低了恢复延迟。</p><h4 id="拥塞控制从-aimd-到-bbr">2.2.3 拥塞控制：从 AIMD 到 BBR</h4><p>TCP 认为丢包是网络拥塞的信号（这一假设在无线网络中往往不成立，却是TCP 设计的基石）。</p><ol type="1"><li><strong>慢启动（SlowStart）</strong>：连接建立初期，拥塞窗口（cwnd）呈指数增长，每收到一个ACK，cwnd 加 1MSS（最大报文段长度）。这实际上是倍增过程，用于快速探测可用带宽。</li><li><strong>拥塞避免（Congestion Avoidance）</strong>：当 cwnd达到慢启动阈值（ssthresh）后，进入线性增长阶段（AIMD：加法增，乘法减）。每经过一个RTT，cwnd 增加 1 MSS。</li><li><strong>拥塞发生</strong>：一旦检测到丢包（超时或 3 个重复ACK），TCP 立即大幅削减 cwnd（通常减半或降为 1），以释放网络压力。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/bbr-fig3.png" /></p><h5 id="cubic-算法">2.2.3.1 CUBIC 算法</h5><p>Linux 默认使用的 CUBIC 算法，将窗口增长函数设计为一个三次函数。 <spanclass="math display">\[W(t) = C(t - K)^3 + W_{max}\]</span> 其曲线在接近上次丢包窗口 <spanclass="math inline">\(W_{max}\)</span>时变得平缓（稳定探测），而在远离饱和点时快速增长。这种凹凸性使得 CUBIC在高带宽延迟积（BDP）网络中比线性增长的 Reno 算法更高效。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/bbr-fig4.png" /></p><h5 id="bbrbottleneck-bandwidth-and-rtt">2.2.3.2 BBR(BottleneckBandwidth and RTT)</h5><p>Google 提出的 BBR 算法颠覆了“基于丢包”的传统逻辑。BBR基于<strong>模型（Model-based）</strong>，试图实时测量网络的两个物理边界：</p><ul><li><p><strong>RTprop</strong>（物理链路的最小往返传播时延）。</p></li><li><p>BtlBw（瓶颈链路带宽）。</p><p>BBR 试图将发送速率控制在 BtlBw，同时保持 inflight 数据量等于BDP（带宽×延迟），从而在不填满路由器缓冲区（Bufferbloat）的情况下跑满带宽。这种机制使得BBR在高丢包率环境下依然能保持高吞吐，因为它不会因为非拥塞性丢包而错误地降低速度。</p></li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/bbr-fig7.png" /></p><blockquote><p>TCP 的丢包判断机制（通常是 3 次重复 ACK或超时）在现代高丢包率或高延迟网络（如跨海传输）下显得反应太慢，且一旦退让就退让太多。</p></blockquote><h3 id="kcp用带宽换时延">2.3 KCP：用带宽换时延</h3><p>KCP 是一个纯算法层面的 ARQ 协议，其设计者 skywind3000 明确指出，KCP的第一性原理是<strong>用带宽换延迟</strong>。如果说 TCP是为了最大化全网的带宽利用率和公平性，那么 KCP就是为了在单点连接上压榨出物理极限的响应速度，不惜牺牲带宽资源。</p><h4 id="头部结构-1">2.3.1 头部结构</h4><p>KCP 的核心在于其精巧的数据段结构 <code>IKCPSEG</code>，其头部占据 24字节（TCP 通常为 20 字节），字段定义直接服务于激进的重传逻辑。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612172557464.png" style="zoom:33%;" /></p><table><colgroup><col style="width: 15%" /><col style="width: 8%" /><col style="width: 10%" /><col style="width: 65%" /></colgroup><thead><tr><th><strong>字段</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th><th><strong>设计意图</strong></th></tr></thead><tbody><tr><td><code>conv</code></td><td>32-bit</td><td>会话 ID</td><td>区分不同的逻辑连接，类似于 TCP 的四元组但仅由 ID 标识。</td></tr><tr><td><code>cmd</code></td><td>8-bit</td><td>指令类型</td><td>IKCP_CMD_PUSH (数据), ACK (确认), WASK (窗口探测), WINS(窗口通告)。</td></tr><tr><td><code>frg</code></td><td>8-bit</td><td>分片序号</td><td>支持应用层大数据包的自动分片与重组（倒序编号，0 为最后一片）。</td></tr><tr><td><code>wnd</code></td><td>16-bit</td><td>接收窗口</td><td>类似于 TCP 的 rwnd，用于流量控制。</td></tr><tr><td><code>ts</code></td><td>32-bit</td><td>时间戳</td><td>发送时刻的本地时间，用于接收端回显以计算 RTT。</td></tr><tr><td><code>sn</code></td><td>32-bit</td><td>序列号</td><td>数据包的编号。</td></tr><tr><td><code>una</code></td><td>32-bit</td><td>未确认序号</td><td>告知对方：此编号之前的所有包已收到（累计确认）。</td></tr><tr><td><code>len</code></td><td>32-bit</td><td>数据长度</td><td>载荷长度。</td></tr><tr><td><strong><code>resendts</code></strong></td><td>(内部)</td><td>重传时间</td><td>下一次需要重传的时刻，由 <code>ikcp_update</code> 检查。</td></tr><tr><td><strong><code>rto</code></strong></td><td>(内部)</td><td>超时时间</td><td>该包当前的重传超时设定。</td></tr><tr><td><strong><code>fastack</code></strong></td><td>(内部)</td><td>跳过次数</td><td>记录该包被多少个后续包的 ACK 跳过（SACK机制），用于触发快速重传。</td></tr></tbody></table><h4 id="激进-arq">2.3.2 激进 ARQ</h4><p>KCP 的激进性体现在它对传统 TCP 策略的全面修正。</p><h5 id="混合确认机制una-ack-list">2.3.2.1 混合确认机制：UNA + ACKList</h5><p>TCP 主要依赖累计确认（UNA）。KCP 则采用了 <strong>UNA + ACKList</strong> 的混合模式。</p><ul><li>头部中的 <code>una</code>字段提供累计确认，保证基础的滑动窗口推进。</li><li>同时，KCP 会单独发送 ACK 包（或者在数据包后追加 ACK信息），显式告知收到了哪些特定的 <code>sn</code>。这种机制类似于 TCP 的SACK，但在 KCP中是原生且强制的。它允许发送端精确知道哪些包丢失，从而只重传丢失的包（选择性重传，SelectiveRepeat），避免了 Go-Back-N 的带宽浪费。</li></ul><h5 id="快速重传">2.3.2.2 快速重传</h5><p>TCP 需要 3 个重复 ACK 触发快重传。KCP 引入了 <code>fastack</code>计数器：</p><ul><li>当发送端收到一个 ACK，确认了 <code>sn=100</code> 和<code>sn=102</code>，但没有确认 <code>sn=101</code>时，<code>sn=101</code> 的 <code>fastack</code> 计数器加 1。</li><li>一旦 <code>fastack</code> 达到设定阈值（<code>resend</code>参数，通常设为 2 甚至 1），KCP 不等待 <code>rto</code> 超时，立即重传<code>sn=101</code>。</li><li>这使得 KCP 在跨越长肥管道（Long Fat Network）时，能比 TCP快数倍地感知并恢复丢包。</li></ul><h5 id="非退让的流控">2.3.2.3 非退让的流控</h5><p>TCP 检测到丢包会减半窗口（拥塞避免）。KCP 提供了 <code>nc</code>（NoCongestion Control）配置开关。</p><ul><li>当 <code>nc=1</code> 时，KCP完全关闭拥塞窗口（cwnd）逻辑，只受限于接收端的接收窗口（rwnd）和发送端的发送缓冲区大小。</li><li>这意味着即使网络极度拥塞，丢包率极高，KCP依然会按照最大速度发送数据和重传包。这种“自私”的行为在公共互联网上可能加剧拥塞，但对于实时游戏等对延迟极度敏感的应用，它是保证流畅体验的关键手段。</li></ul><h5 id="rto-策略优化">2.3.2.4 RTO 策略优化</h5><ul><li><strong>不翻倍</strong>：TCP 超时后 RTO 翻倍（x2, x4, x8）。KCP默认仅 x1.5，这意味着它会更频繁地重试。</li><li><strong>RTO 最小值</strong>：TCP 的 RTO 最小值通常受限于内核tick（例如 200ms），虽然现代 Linux 已优化，但 KCP 允许在用户态设置极低的RTO 最小值（如10ms-30ms），这对于局域网或高质量光纤网的微小抖动反应极快。</li></ul><h4 id="算力代价用户态时钟与轮询">2.3.3 算力代价：用户态时钟与轮询</h4><p>KCP 的高性能是有代价的——CPU 利用率。</p><ul><li><strong>User-space Scheduling</strong>：KCP没有内核的中断驱动机制。用户程序必须在一个循环中不断调用<code>ikcp_update(current_time)</code>。</li><li><strong>Tick 频率</strong>：为了获得低延迟，<code>ikcp_update</code>通常每 10ms 甚至 1ms 调用一次。这导致 CPU即使在空闲时也难以进入深度睡眠状态，产生了大量的空轮询开销。</li></ul><blockquote><p>KCP 的本质是在应用层实现了一个<strong>高频轮询的调度器</strong>（通常<code>update</code> 间隔为 10ms）。它比 TCP 多耗费 20%-30%的流量，换取了低延迟。</p><p>关于 KCP 更多的底层细节可参阅 <ahref="https://hedon.top/2024/12/01/kcp/">KCP源码分析与原理总结</a>。</p></blockquote><h3 id="quic用户态的-tcptls">2.4 QUIC：用户态的 TCP+TLS</h3><p>QUIC（Quick UDP Internet Connections），现已标准化为 RFC9000，代表了网络传输协议的最新演进方向。它不仅仅是一个传输协议，更是一个将传输层（Transport）、安全层（TLS）和部分应用层（HTTP/2）功能融合的<strong>垂直整合架构</strong>。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251127135757381.png" style="zoom: 25%;" /></p><p>关键点：</p><ol type="1"><li>低连接延迟</li><li>无队头阻塞</li><li>灵活拥塞控制</li><li>连接迁移</li></ol><h4 id="报文结构">2.4.1 报文结构</h4><p>QUIC 设计了两种头部格式，以适应握手和数据传输的不同需求。</p><ul><li><p><strong>长首部（LongHeader）</strong>：用于连接建立阶段（Initial, Handshake, Retry,0-RTT）。第一字节最高位为 1。包含完整的 Source CID 和 DestinationCID，以及版本号。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251127140231826.png" style="zoom:60%;" /></p></li><li><p><strong>短首部（ShortHeader）</strong>：用于连接建立后的数据传输（1-RTT）。第一字节最高位为0。仅包含 Destination CID（可选）和 PacketNumber。这极大地减少了头部开销。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251127140249939.png" style="zoom: 85%;" /></p></li></ul><p>QUIC 的一个关键安全特性是对 Packet Number 进行加密。</p><ul><li><strong>机制</strong>：利用 Header Protection Key（从 TLS协商导出），对 Packet Number 字段进行异或掩码操作。</li><li><strong>目的</strong>：防止中间设备（Middleboxes）窥探连接的 RTT或丢包率，也防止中间设备基于明文头部做深度包检测（DPI）从而干扰连接。这强化了协议的抗僵化能力（OssificationResistance）。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/http3_packet.png" /></p><h4 id="核心结构frame-与-stream解决队头阻塞">2.4.2 核心结构：Frame 与Stream（解决队头阻塞）</h4><p>TCP 的队头阻塞源于其单一的字节流抽象。QUIC引入了<strong>Stream</strong>作为一等公民。</p><ul><li><strong>独立性</strong>：一个 QUIC 连接可以包含多个 Stream。每个Stream 有独立的 ID 和 Offset。</li><li><strong>底层实现</strong>：QUIC 数据包（Packet）是传输单元，Frame是逻辑单元。一个 Packet 可以承载属于 Stream A 的 Frame 和属于 Stream B的 Frame。</li><li><strong>抗阻塞</strong>：如果承载 Stream A 数据的 Packet丢失，接收端只需等待该 Packet 重传即可恢复 Stream A；而 Stream B的数据如果在后续 Packet 中到达，接收端可以立即提交给应用层，无需等待Stream A 的恢复。这彻底消除了传输层的队头阻塞。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/QUIC-PICTURE-05-1024x560.jpg" style="zoom:50%;" /></p><h4 id="连接迁移与-cid">2.4.3 连接迁移与 CID</h4><p>移动互联网时代，设备的 IP 地址经常变动（Wi-Fi 切 5G）。TCP依赖四元组（SrcIP, SrcPort, DstIP, DstPort）标识连接，IP变动会导致连接中断。</p><ul><li><strong>Connection ID (CID)</strong>：QUIC 使用 CID唯一标识连接。</li><li><strong>迁移机制</strong>：当客户端 IP 变化时，它在新的 IP上发送包含原有 Destination CID 的数据包。服务器收到后，通过哈希表查找CID对应的连接上下文，验证数据包的真实性（防欺均），然后更新路径信息。连接保持不断，应用层无感知22。</li><li><strong>隐私保护</strong>：为了防止路径关联攻击（通过追踪 CID关联用户的物理位置），QUIC 允许在连接期间协商一组新的CID。客户端在切换网络时主动更换使用新的CID，使得监听者无法关联前后两条路径。</li></ul><h4 id="低延迟连接">2.4.4 低延迟连接</h4><p>QUIC 深度集成了 TLS 1.3，将传输层握手与加密握手合并。</p><ul><li><strong>1-RTT</strong>：首次连接，客户端发送 Initial 包包含 TLSClientHello，服务器回复 ServerHello 和 EncryptedExtensions。1 个 RTT后即可发送应用数据。</li><li><strong>0-RTT</strong>：对于曾经连接过的服务器，客户端缓存了ServerConfig 或 SessionTicket。在重连时，客户端利用预共享密钥（PSK）加密应用数据，随第一个Initial 包（ClientHello）一起发送。服务器收到后立即解密处理。</li><li><strong>反重放（Anti-Replay）</strong>：0-RTT数据不具备前向安全性，且容易被重放。RFC 9000 要求服务器对 0-RTT数据的使用极其谨慎，通常只允许幂等请求（如 GET），并通过时间窗和 Ticket唯一性检查来限制重放窗口。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/quic-handshake-comparison.gif" style="zoom:67%;" /></p><h4 id="更精确的恢复">2.4.5 更精确的恢复</h4><p>QUIC 改进了 TCP 的 ACK 机制：</p><ul><li><strong>ACK Ranges</strong>：TCP SACK 只有 3-4 个块。QUIC 的 ACKFrame 可以携带大量的 ACK Ranges（交替的 Ack 和 Gap块），能精确描述极度碎片化的接收状态。</li><li><strong>Packet Number 单调递增</strong>：TCP 重传时使用相同的SEQ。QUIC 重传一个 Frame 时，会将其封装在一个新的 Packet中，使用<strong>新的 Packet Number</strong>。<ul><li><strong>消除二义性</strong>：接收端收到 ACK 时，根据 ACK 中的 PacketNumber 就能明确知道是确认了原始包还是重传包。这彻底解决了 TCP的重传二义性问题，使得 RTT 计算极其精准，不再需要 Karn算法的退避策略。</li></ul></li></ul><h3 id="总结-2">2.5 总结</h3><p>为了更直观地理解，我们对比一下它们处理"数据发送"这个动作的底层逻辑：</p><table><colgroup><col style="width: 5%" /><col style="width: 24%" /><col style="width: 18%" /><col style="width: 25%" /><col style="width: 26%" /></colgroup><thead><tr><th><strong>动作</strong></th><th><strong>TCP (Kernel)</strong></th><th><strong>UDP (Kernel)</strong></th><th><strong>KCP (User Space)</strong></th><th><strong>QUIC (User Space)</strong></th></tr></thead><tbody><tr><td><strong>封装</strong></td><td>这里是数据 -&gt; 加 TCP 头 -&gt; 存入发送缓冲区 -&gt; 睡觉等ACK</td><td>这里是数据 -&gt; 加 UDP 头 -&gt; 扔给网卡 -&gt; 结束</td><td>这里是数据 -&gt; <strong>加 KCP 头 -&gt; 放入 UDP Payload</strong>-&gt; 扔给网卡</td><td>这里是数据 -&gt; <strong>拆分 Frame -&gt; 加密 -&gt; 放入 UDPPayload</strong> -&gt; 扔给网卡</td></tr><tr><td><strong>重传触发</strong></td><td>1. 超时 (RTO 很长) <br>2. 收到 3 个重复 ACK</td><td>无</td><td>1. 超时 (RTO 很短) <br>2. 收到 n 个跨越包 (n可配)</td><td>1. 超时 (基于精确 RTT) <br>2. 独立 Stream 触发</td></tr><tr><td><strong>拥塞响应</strong></td><td>丢包 = 网络堵塞 -&gt; <strong>降速</strong></td><td>无</td><td>丢包 = 信号不好 -&gt; <strong>加速重传</strong> (可选关闭流控)</td><td>丢包 = 根据算法 (如 BBR) 智能判断 -&gt;<strong>动态调整</strong></td></tr><tr><td><strong>内存拷贝</strong></td><td>用户态 -&gt; 内核态 (Context Switch)</td><td>用户态 -&gt; 内核态</td><td>用户态处理 -&gt; 此时还在用户态 -&gt; 只有最后发 UDP 时进内核</td><td>完全在用户态处理 -&gt; 只有最后发 UDP 时进内核</td></tr></tbody></table><p>从原理出发，我们可以得出工程实践的指导原则：</p><ol type="1"><li><strong>内网微服务 (RPC)：</strong> 依然首选<strong>TCP</strong>。因为内网环境极其稳定，带宽大，丢包率几乎为 0。TCP的内核态实现效率极高，CPU 消耗比 QUIC 低得多（QUIC需要在用户态频繁解密和计算，非常吃 CPU）。</li><li><strong>公网实时游戏/音视频：</strong> 首选<strong>KCP</strong>（或类 KCP的私有协议）。因为你要的是低延迟，且你可以容忍多跑一点流量。</li><li><strong>弱网环境下的 App/Web：</strong> 首选<strong>QUIC</strong>。比如跨国访问、移动端环境。它解决了 TCP的队头阻塞和连接迁移问题，能显著提高用户的加载体验。</li></ol><h2 id="实践检验">3. 实践检验</h2><blockquote><p>抓包看一下 TCP 的三次握手、四次挥手和数据传输。</p></blockquote><p>server:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> axum::&#123;routing::get, Router&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio::net::TcpListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> anyhow::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">router</span> = Router::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">route</span>(<span class="string">&quot;/hello&quot;</span>, <span class="title function_ invoke__">get</span>(hello_handler));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">listener</span> = TcpListener::<span class="title function_ invoke__">bind</span>(<span class="string">&quot;0.0.0.0:12345&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;listening on &#123;&#125;&quot;</span>, listener.<span class="title function_ invoke__">local_addr</span>()?);</span><br><span class="line">    axum::<span class="title function_ invoke__">serve</span>(listener, router.<span class="title function_ invoke__">into_make_service</span>()).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">hello_handler</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="string">&quot;hello world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> anyhow::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = reqwest::<span class="title function_ invoke__">get</span>(<span class="string">&quot;http://localhost:12345/hello&quot;</span>).<span class="keyword">await</span>?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, res.<span class="title function_ invoke__">text</span>().<span class="keyword">await</span>?);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tcpdump:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -Xvvvnnttt -i any  -s 0 tcp port 12345 -w ./packet.pcap &gt; tcpdump.log</span><br></pre></td></tr></table></figure><h3 id="三次握手">3.1 三次握手</h3><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251127163957890.png" /></p><p>第一次握手：client(57831) 向 server(12345) 发送 <code>SYNC</code>包</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 初始化 <span class="code">`Sequence Number`</span> 为 408182767</span><br><span class="line"><span class="bullet">-</span> 初始化 <span class="code">`Acknowled Number (raw)`</span> 为 0</span><br><span class="line"><span class="bullet">-</span> 设置 <span class="code">`SYNC`</span> 标记位</span><br><span class="line"><span class="bullet">-</span> 初始化窗口 <span class="code">`65535`</span></span><br><span class="line"><span class="bullet">-</span> Options 中允许 <span class="code">`SACK`</span> 选择性确认</span><br></pre></td></tr></table></figure><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251127164015711.png" /></p><p>第二次握手：server(12345) 向 client(57831) 发送 <code>ACK+SYNC</code>包</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 初始化 <span class="code">`Sequence Number`</span> 为 785921704</span><br><span class="line"><span class="bullet">-</span> 初始化 <span class="code">`Acknowled Number (raw)`</span> 为 408182768（为上一步的 <span class="code">`Sequence Number 408182767`</span> + 1）</span><br><span class="line"><span class="bullet">-</span> 设置 <span class="code">`SYNC`</span> 和 <span class="code">`ACK`</span> 标记位</span><br><span class="line"><span class="bullet">-</span> 初始化窗口 <span class="code">`65535`</span></span><br><span class="line"><span class="bullet">-</span> Options 中允许 <span class="code">`SACK`</span> 选择性确认</span><br></pre></td></tr></table></figure><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241121123516535.png" /></p><p>第三次握手：client(57831) 向 server(12345) 发送 <code>ACK</code>包</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`Sequence Number`</span> 加 1 变为 <span class="code">`408182768`</span>，即上一步的 <span class="code">`Acknowled Number (raw)`</span></span><br><span class="line"><span class="bullet">-</span> 初始化 <span class="code">`Acknowled Number (raw)`</span> 为 785921705（为上一步的 <span class="code">`Sequence Number 785921704`</span> + 1）</span><br><span class="line"><span class="bullet">-</span> 设置 <span class="code">`ACK`</span> 标记位</span><br><span class="line"><span class="bullet">-</span> 窗口修改为 <span class="code">`5379`</span></span><br></pre></td></tr></table></figure><h3 id="数据传输">3.2 数据传输</h3><p>初始状态：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client:</span><br><span class="line"><span class="bullet">-</span> SeqNum: 408192768</span><br><span class="line"><span class="bullet">-</span> AckNum: 78591705</span><br><span class="line">server:</span><br><span class="line"><span class="bullet">-</span> SeqNum: 78591705（SYNC 包占了一个序列号，所以是 785921704+1）</span><br><span class="line"><span class="bullet">-</span> AckNum: 408192768</span><br></pre></td></tr></table></figure><p>client → server:</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241121133716537.png" /></p><p>server → client:</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241121133759217.png" /></p><h3 id="四次挥手">3.3 四次挥手</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241121133849880.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>第一次挥手：client(57831) 向 server(12345) 发送 <code>FIN</code>包</p><p>第二次挥手：server(12345) 向 client(57831) 发送 <code>ACK</code>包</p><p>第三次挥手：server(12345) 向 client(57831) 发送 <code>FIN</code>包</p><p>第四次挥手：client(57831) 向 server(12345) 发送 <code>ACK</code>包</p><h3 id="两个工具">3.4 两个工具</h3><h4 id="netstat">3.4.1 netstat</h4><p><strong>基础参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-a    <span class="comment"># 显示所有连接和监听端口</span></span><br><span class="line">-n    <span class="comment"># 以数字形式显示地址和端口号</span></span><br><span class="line">-p    <span class="comment"># 显示进程名称/进程号</span></span><br><span class="line">-t    <span class="comment"># 显示 TCP 协议的连接</span></span><br><span class="line">-u    <span class="comment"># 显示 UDP 协议的连接</span></span><br><span class="line">-l    <span class="comment"># 仅显示监听中的连接</span></span><br></pre></td></tr></table></figure><p><strong>常见组合使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有 TCP 连接</span></span><br><span class="line">netstat -at</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有监听端口</span></span><br><span class="line">netstat -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有 TCP 监听端口</span></span><br><span class="line">netstat -lt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有进程和监听端口（需要 root 权限）</span></span><br><span class="line">netstat -nltp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示路由表信息</span></span><br><span class="line">netstat -r</span><br></pre></td></tr></table></figure><p><strong>查看特定端口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 80 端口的使用情况</span></span><br><span class="line">netstat -an | grep <span class="string">&#x27;:80&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>查看程序连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有 HTTP 相关连接</span></span><br><span class="line">netstat -anp | grep <span class="string">&#x27;http&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>统计连接数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计各种状态的连接数</span></span><br><span class="line">netstat -n | awk <span class="string">&#x27;/^tcp/ &#123;++state[$NF]&#125; END &#123;for(key in state) print key,&quot;\\\\t&quot;,state[key]&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>netstat 输出的典型字段包括：</p><ul><li><code>Proto</code>: 协议（TCP/UDP）</li><li><code>Recv-Q</code>: 接收队列</li><li><code>Send-Q</code>: 发送队列</li><li><code>Local Address</code>: 本地地址:端口</li><li><code>Foreign Address</code>: 远程地址:端口</li><li><code>State</code>: 连接状态</li><li><code>PID/Program name</code>: 进程ID和程序名称</li></ul><p>常见连接状态：</p><ul><li><code>LISTEN</code>: 监听中</li><li><code>ESTABLISHED</code>: 已建立连接</li><li><code>TIME_WAIT</code>: 等待关闭</li><li><code>CLOSE_WAIT</code>: 等待关闭</li><li><code>SYN_SENT</code>: 发送同步</li><li><code>SYN_RECV</code>: 接收同步</li></ul><h4 id="ss">3.4.2 ss</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss [选项] [过滤条件]</span><br></pre></td></tr></table></figure><p><strong>基础参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-n    <span class="comment"># 不解析服务名称，以数字显示</span></span><br><span class="line">-a    <span class="comment"># 显示所有套接字</span></span><br><span class="line">-l    <span class="comment"># 显示监听状态的套接字</span></span><br><span class="line">-p    <span class="comment"># 显示进程信息</span></span><br><span class="line">-t    <span class="comment"># 显示 TCP 套接字</span></span><br><span class="line">-u    <span class="comment"># 显示 UDP 套接字</span></span><br><span class="line">-x    <span class="comment"># 显示 Unix domain 套接字</span></span><br><span class="line">-s    <span class="comment"># 显示套接字使用概况</span></span><br><span class="line">-4    <span class="comment"># 仅显示 IPv4</span></span><br><span class="line">-6    <span class="comment"># 仅显示 IPv6</span></span><br></pre></td></tr></table></figure><p><strong>常见用法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有 TCP 连接</span></span><br><span class="line">ss -t -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有监听端口和进程信息（常用）</span></span><br><span class="line">ss -tlnp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示统计信息</span></span><br><span class="line">ss -s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有 established 状态的 TCP 连接</span></span><br><span class="line">ss -t state established</span><br></pre></td></tr></table></figure><p><strong>状态过滤</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示指定状态的连接</span></span><br><span class="line">ss state established</span><br><span class="line">ss state time-wait</span><br><span class="line">ss state listening</span><br></pre></td></tr></table></figure><p><strong>端口过滤</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示指定端口的连接</span></span><br><span class="line">ss sport = :80    <span class="comment"># 源端口</span></span><br><span class="line">ss dport = :80    <span class="comment"># 目标端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示特定端口范围</span></span><br><span class="line">ss sport gt :1024  <span class="comment"># 大于1024的源端口</span></span><br></pre></td></tr></table></figure><p><strong>地址过滤</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示与特定 IP 相关的连接</span></span><br><span class="line">ss dst 192.168.1.1</span><br><span class="line">ss src 192.168.1.1</span><br></pre></td></tr></table></figure><p><strong>查看具体服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 HTTP 相关连接</span></span><br><span class="line">ss -np state established <span class="string">&#x27;( dport = :80 or sport = :80 )&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 SSH 连接</span></span><br><span class="line">ss -o state established <span class="string">&#x27;( dport = :22 or sport = :22 )&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>查看连接统计</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看连接速率</span></span><br><span class="line">ss -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存使用</span></span><br><span class="line">ss -m</span><br></pre></td></tr></table></figure><p><strong>高级过滤</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看特定进程的连接</span></span><br><span class="line">ss -p | grep nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看非监听 TCP 连接</span></span><br><span class="line">ss -t -a <span class="string">&#x27;( dport != :22 )&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>ss 输出的典型字段包括：</strong></p><ul><li><code>Netid</code>: 协议类型</li><li><code>State</code>: 连接状态</li><li><code>Recv-Q</code>: 接收队列</li><li><code>Send-Q</code>: 发送队列</li><li><code>Local Address:Port</code>: 本地地址和端口</li><li><code>Peer Address:Port</code>: 对端地址和端口</li><li><code>Process</code>: 进程信息（使用 -p 参数时显示）</li></ul><p><strong>性能优势：</strong></p><ol type="1"><li><strong>ss 直接从内核空间读取信息，而不是像 netstat 那样读取/proc</strong></li><li>ss 的运行速度更快</li><li>ss 能够显示更多的 TCP 状态信息</li></ol><p><strong>注意事项：</strong></p><ol type="1"><li>某些操作需要 root 权限</li><li>不同 Linux 发行版的 ss 版本可能有细微差异</li><li>使用 -p 参数时，非 root 用户可能看不到所有进程信息</li></ol><p><strong>与 netstat 的对比：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat 命令              # ss 等效命令</span></span><br><span class="line">netstat -tulpn            ss -tulpn</span><br><span class="line">netstat -antop            ss -antop</span><br><span class="line">netstat -t                ss -t</span><br><span class="line">netstat -l                ss -l</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文将结合第一性原理，深入解析 UDP、TCP、KCP 和 QUIC 协议的设计动机、核心机制及其区别，助你真正理解它们为何而生、如何演化、彼此之间有何联系与差异。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络编程" scheme="https://hedon.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="QUIC" scheme="https://hedon.top/tags/QUIC/"/>
    
    <category term="UDP" scheme="https://hedon.top/tags/UDP/"/>
    
    <category term="TCP" scheme="https://hedon.top/tags/TCP/"/>
    
    <category term="KCP" scheme="https://hedon.top/tags/KCP/"/>
    
  </entry>
  
  <entry>
    <title>traceroute 故障排查：Clash Fake IP 及其他 4 种常见原因</title>
    <link href="https://hedon.top/2025/11/25/clash-fake-ip/"/>
    <id>https://hedon.top/2025/11/25/clash-fake-ip/</id>
    <published>2025-11-25T13:30:00.000Z</published>
    <updated>2025-11-25T14:23:55.679Z</updated>
    
    <content type="html"><![CDATA[<p>本篇源于笔者一次使用 <code>traceroute</code>遇到的疑难杂症的排查，在这个过程中，通过跟 Google Gemini 3Pro的沟通，对计算机网络和平时使用的 VPN工具又有了进一步的了解，特此梳理本文。</p><h3 id="traceroute-回顾">traceroute 回顾</h3><p>先回顾一下 <code>traceroute</code> 这个工具：</p><ul><li><strong>作用</strong>：用来跟踪一个 IP数据包从源点到终点的路径。</li><li><strong>原理</strong>：它利用 <strong>IP</strong> 数据报中的<strong>TTL</strong> 字段和 <strong>ICMP</strong>时间超时差错报告报文实现对从源点到终点的路径的跟踪。</li><li><strong>过程</strong>：<ul><li>客户端发送一个 TTL 为 1 的探测数据包（Linux/macOS 默认使用UDP，Windows 使用 ICMP），在第一跳的时候超时并返回一个 ICMP超时数据包，得到第一跳的地址。<ul><li>客户端发送一个 TTL 为 2 的探测数据包，得到第二跳的地址。</li><li>依次递增 TTL，直到到达<strong>目标主机</strong>，目标主机返回响应（UDP 端口不可达或 ICMP回显应答），traceroute 结束。</li></ul></li></ul></li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gt3mv34h3ej30hj0cw0te.jpg" /></p><h3 id="问题再现">问题再现</h3><p>我在使用 <code>traceroute</code> 跟踪我本机到我的博客域名<code>hedon.top</code> 的跳转路径时，发现很奇怪，返回的全是<code>* * *</code>！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ traceroute hedon.top</span><br><span class="line">traceroute to hedon.top (172.19.0.13), 64 hops max, 40 byte packets</span><br><span class="line"> 1  * * *</span><br><span class="line"> 2  * * *</span><br><span class="line"> 3  * * *</span><br><span class="line"> 4  *</span><br></pre></td></tr></table></figure><p>我就怀疑是不是因为我开启了 VPN，所以我就询问了一下 Google Gemini3Pro，还真是！它说是因为 VPN 里面的 <code>fake ip</code>导致了，我立马检查了我的 Clash Mi，发现果真如此，同时我关闭 Clash Mi后，<code>traceroute</code> 就一切正常了。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251125213716125.png" style="zoom:33%;" /></p><hr /><h3 id="原理分析">原理分析</h3><p>为什么会这样呢？</p><blockquote><p>[!IMPORTANT]</p><p>很多代理软件开启 <strong>增强模式 (Fake IP)</strong> 时，会拦截所有DNS 请求。为了加快速度，它不进行真正的 DNS查询，而是直接扔给你一个“假的内部 IP”（通常是<code>198.18.x.x</code>，但也可以配置成<code>172.x.x.x</code>），然后由代理软件接管流量。</p><p>又因为大多数 VPN 软件的 Fake IP 逻辑只处理 <strong>TCP/UDP数据流</strong>（用来浏览网页），它并不支持通过 Fake IP 来做 ICMP路由探测。所以就导致了探测包发出去如泥牛入海，VPN不回信，真实服务器更收不到（因为根本没发给真实 IP），所以看到的全是<code>* * *</code>。</p></blockquote><h4 id="为什么需要-fake-ip-呢-为了快">为什么需要 Fake IP 呢？ ——为了快！</h4><p>在正常的 VPN/代理模式下，当你访问 <code>hedon.top</code> 时，采用的是<code>Redir-Host</code> 模式：</p><ol type="1"><li><strong>本地 DNS 解析</strong>：电脑问 DNS 服务器 "hedon.top是多少？"</li><li><strong>等待</strong>：等待 DNS 返回 IP（比如 30ms）。</li><li><strong>建立连接</strong>：电脑拿着 IP 去发起 TCP 连接。</li><li><strong>代理软件</strong>：拦截连接，发现这个 IP是国外的，于是走代理通道。</li></ol><p>代理软件的设计者觉得步骤 2是纯浪费时间。既然反正要走代理，我为什么要让本地 DNS 去查一个国外的IP？而且万一 DNS 被污染了，给了一个错误的 IP，我还得想办法纠错。</p><p><strong>开启 VPN (Fake IP 模式) 后的流程：</strong></p><ol type="1"><li><strong>拦截</strong>：你发出的 DNS 请求，还没出电脑网卡，就被 VPN软件截获了。</li><li><strong>秒回</strong>：VPN<strong>立刻、马上、随便</strong>编一个内网 IP（比如我看到的<code>172.19.0.13</code>）扔给你的系统。<ul><li>VPN 在心里记了个账：<code>172.19.0.13</code> &lt;==&gt;<code>hedon.top</code>。</li></ul></li><li><strong>欺骗成功</strong>：浏览器（或 traceroute）拿到了这个IP，以为是真的，于是向这个 IP 发起连接。</li><li><strong>偷梁换柱</strong>：数据包发出来，又被 VPN 截获。VPN查账本，发现目标是<code>172.19.0.13</code>，于是它知道："哦，这其实是要去访问<code>hedon.top</code>"。</li><li><strong>远程解析</strong>：VPN 把"访问<code>hedon.top</code>"这个指令发给远端的代理服务器，由远端服务器去解析真正的IP 并传输数据。</li></ol><pre class="mermaid">sequenceDiagram    autonumber    participant App as 浏览器/App    participant OS as 操作系统/DNS栈    participant Clash as Clash (Fake IP)    participant Remote as 远端代理服务器    Note over App, Clash: 阶段一：DNS 欺骗 (极速响应)    App->>OS: 域名解析请求: hedon.top    OS->>Clash: 发送 UDP 53 包    Note right of Clash: Clash 拦截请求<br>根本不去查互联网！    Clash->>Clash: 1. 从 Fake IP 池选一个空闲 IP<br>比如 172.19.0.13    Clash->>Clash: 2. 记账 (Mapping)<br>"172.19.0.13" = "hedon.top"    Clash-->>App: 秒回: IP 是 172.19.0.13    Note over App, Clash: 阶段二：建立连接 (偷梁换柱)    App->>App: 以为拿到了真 IP<br>向 172.19.0.13 发起 TCP 连接    App->>Clash: TCP SYN (Dst: 172.19.0.13)    Note right of Clash: Clash 拦截 TCP 包<br>查账本：172.19.0.13 是谁？    Clash->>Clash: 哦，原来是 hedon.top    Clash->>Remote: 把"域名 hedon.top"发给远端<br>由远端服务器去解析真实 IP    Remote->>Remote: 在海外解析并连接真实服务器</pre><p><strong>关键点：</strong></p><ol type="1"><li><strong>省时</strong>：DNS响应是<strong>毫秒级</strong>的，因为根本不需要网络请求，Clash直接从内存里扔一个 IP 给你。</li><li><strong>防污染</strong>：因为本地根本不进行真实的 DNS 解析，GFW 的DNS 污染攻击直接无效。</li><li><strong>远端解析</strong>：真实的 IP解析发生在远端代理服务器（比如在日本或美国的机房），那里解析出来的 IP一定是离目标最近、最准确的（比如 Google 的 CDN 节点）。</li></ol><h4 id="为什么返回是全是-呢">为什么返回是全是 * * * 呢？</h4><p>再看那个全是 <code>* * *</code> 的现象，就很容易理解了：</p><ol type="1"><li><strong>执行</strong>：<code>traceroute hedon.top</code>。</li><li><strong>Clash Mi 欺骗</strong>：给了 <code>172.19.0.13</code>。</li><li><strong>发包</strong>：<code>traceroute</code> 向<code>172.19.0.13</code> 发送 UDP/ICMP 探测包。</li><li><strong>死胡同</strong>：<ul><li>这个 IP 在公网上是不存在的。</li><li>Clash 通常只代理浏览器的 TCP/UDP<strong>数据流</strong>，它并没有义务去模拟路由器的 ICMP TTL回显功能。</li><li>所以探测包发给 Clash Mi的虚拟网卡后，就像掉进了黑洞，没有任何设备回信"超时"。</li></ul></li></ol><hr /><h3 id="注意事项">注意事项</h3><p>Fake IP 虽然爽，但对于写代码的人来说，有两个巨大的坑：</p><h4 id="坑一docker局域网冲突">坑一：Docker/局域网冲突</h4><p>如果 Clash Mi 用的 Fake IP 网段（如<code>172.19.0.0/16</code>）恰好和你的 Docker 容器网段重叠。</p><ul><li><strong>现象</strong>：你要连本地的 Docker 数据库，结果流量被 Clash吸走了，报"连接被拒绝"。</li><li><strong>解法</strong>：始终确保 Fake IP 网段设置为<strong><code>198.18.0.1/16</code></strong>。这是一个专门用于性能测试的保留网段，世界上没有公网机器用它，Docker默认也不用它。</li></ul><h4 id="坑二ip-缓存中毒-dns-cache-poisoning">坑二：IP 缓存中毒 (DNSCache Poisoning)</h4><p>有些笨拙的软件（比如旧版的 Java 客户端、某些物联网设备SDK）会<strong>缓存 DNS 结果</strong>。</p><ol type="1"><li>你开了 VPN，程序解析 <code>hedon.top</code> 拿到<code>172.19.0.13</code>。</li><li>程序把这个 IP 存到自己的内存缓存里，有效期 1 小时。</li><li><strong>你关了 VPN</strong>。</li><li>程序再次发起请求，它不去解析 DNS 了，直接连<code>172.19.0.13</code>。</li><li><strong>报错</strong>：因为 VPN 关了，操作系统不知道这个 IP是谁，网络直接不可达。</li></ol><p><strong>解法</strong>：关 VPN 后，往往需要重启应用，甚至执行<code>ipconfig /flushdns</code> (Windows) 或<code>sudo killall -HUP mDNSResponder</code> (macOS)。</p><h3 id="其他原因">其他原因</h3><p>除了 Fake IP这种本地欺骗导致的全是星星外，在真实的互联网环境中，<code>traceroute</code>出现 <code>* * *</code> 是非常普遍的现象。</p><p>从第一性原理来看，<code>* * *</code>的本质含义只有一个：<strong>我发出了探测包，但在规定时间内（通常是 5秒），我没有收到任何回信。</strong></p><p>造成没有回信通常有以下四大类原因，我们按照<strong>出现的概率</strong>从高到低排列：</p><h4 id="中间路由器的高冷-icmp-限速或禁发">1. 中间路由器的高冷 (ICMP限速或禁发)</h4><p>表现：中间几行是星星，但最后能到达终点。</p><ul><li>原理：路由器的核心 KPI 是转发数据包，而不是陪聊。当你发送 TTL超时的探测包时，路由器需要暂停手头的工作，调用 CPU 生成一个 ICMP TimeExceeded 消息发回给你。这会消耗路由器的 CPU 资源。</li><li>策略：为了防止被 DDoS攻击或节省性能，运营商（ISP）和骨干网路由器通常配置了 ICMP Rate Limiting(限速) 甚至 ICMP Silently Drop (静默丢弃)。</li><li><strong>结论</strong>：如果中间全是星，但最后一行通了，<strong>完全不用担心</strong>，这是正常的网络现象。</li></ul><h4 id="防火墙的黑洞策略-drop-vs-reject">2. 防火墙的黑洞策略 (DROP vsREJECT)</h4><p>表现：从某一行开始全是星星，直到结束都连不上。</p><ul><li>原理：当探测包撞上防火墙（可能是企业边缘防火墙、GFW、或者目标机器的iptables）时，防火墙有两种处理方式：<ol type="1"><li><strong>REJECT</strong>：明确告诉你"滚"。你会收到<code>Destination Unreachable</code>。</li><li><strong>DROP(丢弃)</strong>：直接把包扔垃圾桶，<strong>不给任何回信</strong>。</li></ol></li><li>为什么：出于安全考虑，管理员通常配置DROP。因为回复错误信息会暴露防火墙的存在和 IP地址，给黑客留下线索。</li><li>Linux 的痛点：Linux traceroute 默认用 UDP高端口探测。很多企业的防火墙策略是：只允许 Web (80/443)流量进入，封禁所有未知 UDP 端口。这会导致你还没到终点就被拦截了。</li><li>解决方法：使用 <code>traceroute -I</code> (改用 ICMP) 或<code>traceroute -T</code> (改用 TCP 80 端口) 通常能穿透更多层。</li></ul><h4 id="进出路径不一致-非对称路由-asymmetric-routing">3. 进出路径不一致(非对称路由 Asymmetric Routing)</h4><p>表现：忽通忽断，或者全是星星。</p><ul><li>原理：互联网非常复杂，"去程"和"回程"走的路往往是不一样的。<ul><li><strong>去程</strong>：你 -&gt; 路由器 A -&gt; 路由器 B -&gt;目标。</li><li><strong>回程</strong>：目标 -&gt; 路由器 C -&gt; 路由器 D -&gt;你。</li></ul></li><li>问题：<ul><li>如果你发出的探测包经过了路由器B（它是有状态防火墙），它记录了"我发出了一个包"。</li><li>但回信是路由器 C 试图发回来的。路由器B（或者你这边的防火墙）一看："我没见过你 C发过来的连接请求啊？你是谁？"</li><li>于是回信被状态防火墙 (Stateful Firewall) 拦截了。</li></ul></li><li><strong>结论</strong>：虽然数据包可能真的到达了，但回音被杀死了。</li></ul><h4 id="真的断网了-路由黑洞-环路">4. 真的断网了 (路由黑洞 / 环路)</h4><p>表现：到某一跳后中断，或者在两个 IP 之间死循环。</p><ul><li><p>路由黑洞 (Blackhole)：路由器 A 的路由表说"去往目标找 B"，但路由器B 说"我不认识目标，也没有默认网关"。数据包到了 B 就被丢弃了（且 B如果配置了不回显 ICMP，就是星星）。</p></li><li><p>路由环路 (Loop)：A 说"找 B"，B 说"找 A"。</p><p>traceroute 会显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5  10.0.0.1</span><br><span class="line">6  10.0.0.2</span><br><span class="line">7  10.0.0.1</span><br><span class="line">8  10.0.0.2</span><br></pre></td></tr></table></figure><p>直到 TTL 耗尽。</p></li></ul><h3 id="总结">总结</h3><p>看到 <code>* * *</code>时，需要通过<strong>上下文</strong>来判断：</p><table><colgroup><col style="width: 36%" /><col style="width: 27%" /><col style="width: 36%" /></colgroup><thead><tr><th><strong>现象</strong></th><th><strong>含义</strong></th><th><strong>后端应对</strong></th></tr></thead><tbody><tr><td><strong>全星 (第 1 跳就开始)</strong></td><td>连门都没出去</td><td>查 VPN Fake IP、本地防火墙、网关配置</td></tr><tr><td><strong>中间有星，最后通了</strong></td><td>中间路由器高冷/忙碌</td><td><strong>忽略</strong>，网络是通的</td></tr><tr><td><strong>最后几行全是星</strong></td><td>目标主机开了防火墙/禁 Ping</td><td>尝试 <code>telnet</code> 端口验证业务层连通性</td></tr><tr><td><strong>从第 X 跳开始全星</strong></td><td>链路中断 或 强力防火墙(GFW)</td><td>检查路由表，联系网管</td></tr><tr><td><strong>星星夹杂 IP (如 <code>\* 1.1.1.1 \*</code>)</strong></td><td>丢包率高 / 负载均衡</td><td>网络质量差，存在抖动</td></tr></tbody></table><h3 id="新工具推荐">新工具推荐</h3><p>一个实用的命令：</p><p>如果你在排查服务器连通性，建议使用 mtr (My Traceroute)。它结合了 ping和 traceroute，会实时刷新每一跳的丢包率。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 能够清晰看到是哪一跳开始丢包的</span></span><br><span class="line">mtr -n hedon.top</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">通过分析 Clash Mi 的 Fake IP 模式导致 traceroute 返回全是星号的问题，深入理解 VPN 代理的工作原理和常见陷阱。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>从第一性原理理解 epoll</title>
    <link href="https://hedon.top/2025/11/23/linux-io-epoll/"/>
    <id>https://hedon.top/2025/11/23/linux-io-epoll/</id>
    <published>2025-11-23T12:00:00.000Z</published>
    <updated>2025-11-23T12:15:39.896Z</updated>
    
    <content type="html"><![CDATA[<p>要从根本上理解 <code>epoll</code>，我们必须跳出 API的表象，深入到操作系统内核的数据结构和中断处理机制中。</p><div class="tag-plugin colorful note" color="orange"><div class="title"><strong><p>一句话总结 epoll</p></strong></div><div class="body"><p>它将 I/O 处理模式从 <strong>"同步轮询 (Synchronous Polling)"</strong>彻底转变为 <strong>"异步事件驱动 (AsynchronousEvent-Driven)"</strong>，并将文件描述符（FD）集合的管理权从 "用户态"移交给了 "内核态" 以实现状态持久化。</p></div></div><p>为了讲清楚，我们把它拆解为三个维度：<strong>核心痛点</strong>（为什么要有它）、<strong>内核架构</strong>（它长什么样）、<strong>工作流程</strong>（它是怎么跑的）。</p><h2 id="核心痛点on-的线性复杂度瓶颈">1. 核心痛点：O(N)的线性复杂度瓶颈</h2><p>在 <code>epoll</code> 出现之前（Linux 2.6 之前），网络编程主要依赖<code>select</code> 或<code>poll</code>。从计算机体系结构角度看，它们存在一个致命的<strong>无状态（Stateless）</strong>设计缺陷。</p><p><code>select</code>/<code>poll</code>模型要求用户每次发起系统调用时，必须将所有需要监控的 FD集合传递给内核。内核的处理逻辑如下：</p><ol type="1"><li><strong>全量拷贝</strong>：将用户态的 FD 数组完整拷贝到内核态。</li><li><strong>全量遍历</strong>：内核必须线性遍历这个 FD数组，逐个检查对应的硬件设备状态。</li><li><strong>全量返回</strong>：如果发现有就绪事件，或者超时，内核再将修改后的FD 状态位图拷贝回用户态。</li></ol><p>这种方式有以下弊端：</p><ul><li><strong>上下文切换开销</strong>：在高并发场景下（例如 10万连接），每次调用都要在用户态和内核态之间传递巨大的数据块。</li><li><strong>CPU 算力浪费</strong>：时间复杂度为 <spanclass="math inline">\(O(N)\)</span>。即使 10 万个连接中只有 1个活跃，内核也必须检查完所有 10 万个状态。随着 <spanclass="math inline">\(N\)</span> 的增加，系统性能呈线性下降趋势。</li></ul><p>于是就出现了 <code>epoll</code>，<code>epoll</code>具有以下特点：</p><ul><li><strong>效率高</strong>: 相较于 <code>select</code> 和<code>poll</code>，<code>epoll</code>可以更高效地处理大量的并发连接。<code>select</code> 和 <code>poll</code>的效率随着监视的文件描述符数量增加而线性下降，而 <code>epoll</code>则不会因为监视的文件描述符数量增加而显著降低效率。</li><li><strong>扩展性好</strong>: <code>epoll</code>使用一种称为事件通知的机制，只会处理那些真正发生了事件的文件描述符。这意味着系统不必重新检查所有文件描述符，从而大大减少了不必要的CPU 开销。</li><li><strong>支持边缘触发和水平触发</strong>: <code>epoll</code> 支持<code>Edge Triggered</code> 和水平触发 <code>Level Triggered</code>两种模式。边缘触发模式只在文件描述符状态改变时才通知应用程序，适用于非阻塞I/O；而水平触发模式则在有事件可读或可写时都会通知应用程序，更容易使用但效率略低。</li></ul><h2 id="内核架构红黑树与就绪链表">2. 内核架构：红黑树与就绪链表</h2><p><code>epoll</code>的核心改进在于它在内核中维护了一个<strong>持久化的上下文（Context）</strong>。当你调用<code>epoll_create</code> 时，内核会在内存中分配一个<code>eventpoll</code> 结构体，它包含两个核心数据结构：</p><h3 id="红黑树-red-black-tree-监控集合的静态存储">2.1 红黑树 (Red-BlackTree) —— 监控集合的静态存储</h3><ul><li><strong>作用</strong>：存储所有通过 <code>epoll_ctl</code> 注册的 FD及其对应的 <code>epitem</code>（封装了事件类型等信息）。</li><li><strong>设计理由</strong>：<ul><li>红黑树提供了稳定的查找、插入和删除性能，时间复杂度为 <spanclass="math inline">\(O(\log N)\)</span>。</li><li>它实现了 <strong>IO多路复用的状态保持</strong>。用户态不需要每次都重新传递 FD列表，内核直接在树中维护。</li></ul></li></ul><h3 id="双向链表-double-linked-list-活跃集合的动态缓冲">2.2 双向链表(Double Linked List) —— 活跃集合的动态缓冲</h3><ul><li><strong>作用</strong>：仅存储<strong>当前处于就绪状态</strong>的<code>epitem</code> 引用。这是一个“活跃事件队列”。</li><li><strong>设计理由</strong>：<ul><li><code>epoll_wait</code> 的核心逻辑简化为：检查该链表是否为空。</li><li>如果不为空，将链表节点弹出并复制到用户态。</li><li><strong>复杂度质变</strong>：获取就绪事件的时间复杂度从 <spanclass="math inline">\(O(N)\)</span> 降低为 <spanclass="math inline">\(O(K)\)</span>，其中 <spanclass="math inline">\(K\)</span>为当前活跃连接数。在海量并发空闲连接的场景下，效率与总连接数无关。</li></ul></li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/178bad747306420493f9c4271df7be7c.webp" /></p><h2 id="工作流程中断驱动与回调机制">3. 工作流程：中断驱动与回调机制</h2><p>红黑树中的静态节点如何流转到就绪链表中？这依赖于底层的<strong>硬件中断</strong>与<strong>等待队列回调</strong>机制。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240429121302958.png" /></p><ol type="1"><li><strong>实例初始化 (epoll_create):</strong><ul><li>内核分配 eventpoll 结构，初始化红黑树根节点和就绪链表头指针。</li></ul></li><li><strong>事件注册 (<code>epoll_ctl</code> +<code>EPOLL_CTL_ADD</code>)</strong>:<ul><li>内核在红黑树中插入新的节点。</li><li><strong>关键操作</strong>：内核查找到该 FD对应的底层文件对象（Socket），并在该对象的<strong>等待队列（WaitQueue）中注册一个特定的回调函数：<code>ep_poll_callback</code></strong>。这一步建立了硬件事件与<code>epoll</code> 实例的联系。</li></ul></li><li><strong>阻塞等待 (<code>epoll_wait</code>)</strong>:<ul><li>检查 <code>eventpoll</code> 的就绪链表是否为空。</li><li>若为空，将当前进程（或线程）挂起，进入睡眠状态（调度出CPU），直到超时或被唤醒。</li></ul></li><li><strong>中断触发 (数据到达)</strong>:<ul><li>网卡接收数据 -&gt; CPU 响应硬件中断 -&gt; DMA 拷贝数据到内核缓冲区-&gt; TCP 协议栈处理。</li><li>当数据写入 Socket 接收缓冲区后，协议栈检测到该 Socket的等待队列非空，随即调用注册的<strong><code>ep_poll_callback</code></strong>。</li></ul></li><li><strong>回调执行</strong>:<ul><li><code>ep_poll_callback</code> 将该 FD 对应的 <code>epitem</code>引用添加到 <code>eventpoll</code> 的 <strong>就绪链表</strong>尾部。</li><li>同时，唤醒正在 <code>epoll_wait</code> 中阻塞的进程。</li></ul></li><li><strong>返回用户态</strong>:<ul><li>进程被唤醒，<code>epoll_wait</code>将就绪链表中的事件复制到用户态内存，函数返回。</li></ul></li></ol><h2 id="lt-vs-et">4. LT vs ET</h2><p>理解了回调机制后，LT 和 ET的区别就在于<strong>就绪链表的维护策略</strong>不同。</p><h3 id="lt-水平触发-level-triggered---默认模式">4.1 LT 水平触发 (LevelTriggered) - 默认模式</h3><ul><li><strong>机制</strong>：当 <code>epoll_wait</code>检测到就绪链表中有节点时，会将其报告给用户。如果用户没有读完缓冲区的所有数据，内核在下一次检查时，<strong>会重新将该节点加入就绪链表</strong>（或者不将其从链表中移除）。</li><li><strong>特征</strong>：状态驱动。只要缓冲区不为空，事件就一直存在。</li></ul><h3 id="et-边缘触发-edge-triggered---高性能模式">4.2 ET 边缘触发 (EdgeTriggered) - 高性能模式</h3><ul><li><strong>机制</strong>：<code>ep_poll_callback</code> 仅在 Socket状态发生变化（如从"不可读"变为"可读"）时触发一次，将节点加入就绪链表。一旦用户通过<code>epoll_wait</code>取走了该事件，除非有新的硬件中断（新数据到达），否则该节点不会再次进入就绪链表。</li><li><strong>特征</strong>：事件驱动。</li></ul><h2 id="中断">5. 中断</h2><p>中断机制是计算机硬件和操作系统核心功能之一，它允许外设或硬件异步地通知CPU 需要处理某些事件。中断机制的实现并不依赖于类似于 <code>for</code>循环的轮询检查，而是建立在更为直接和高效的硬件和处理器架构支持之上。</p><p>当 CPU接收到中断信号时，它是通过一套内建于硬件的协调机制来识别和响应中断的。这个过程涉及硬件电路设计、处理器架构和操作系统的中断管理功能。</p><h3 id="中断信号的检测和响应">5.1 中断信号的检测和响应</h3><ol type="1"><li><strong>中断请求线（IRQ）</strong>：外部设备通过连接到处理器的一个特定的硬件线路（IRQ）发送中断信号。这个线路直接与处理器内的中断控制单元（InterruptController）相连。</li><li><strong>中断控制器</strong>：大多数现代计算机系统使用一个或多个中断控制器来管理中断信号。中断控制器的任务是接收来自各种外部设备的中断请求，并将这些请求优先级排序后发送给CPU。</li><li><strong>中断向量</strong>：当中断控制器接收到一个中断信号后，它会根据中断源确定一个中断向量。这个向量是一个数字，指向中断向量表中对应的入口，该入口包含了处理该中断的中断服务例程（ISR）的地址。</li></ol><h3 id="cpu-如何处理中断">5.2 CPU 如何处理中断</h3><ol type="1"><li><strong>当前指令的完成</strong>：当 CPU接收到中断控制器发出的中断信号时，它首先会完成当前执行的指令。这是为了保证程序的状态能够正确保存，从而在中断处理完毕后可以无缝地恢复执行。</li><li><strong>保存上下文</strong>：一旦当前指令执行完毕，CPU会自动保存当前的程序状态，包括程序计数器（PC）、寄存器和其他必要的状态信息。这些信息通常被推送到当前的栈上。</li><li><strong>跳转到 ISR</strong>：CPU使用中断向量来访问中断向量表，找到与中断号对应的中断服务例程（ISR）的地址，并跳转到该地址开始执行ISR。这个过程是自动的，由处理器的内部机制控制。</li><li><strong>执行ISR</strong>：中断服务例程会执行必要的操作来处理中断，比如读取数据缓冲区、清除设备状态或发送信号等。</li><li><strong>恢复上下文并返回</strong>：一旦 ISR执行完成，处理器会从栈上恢复之前保存的程序状态，并将控制权返回到被中断的程序，继续执行。</li></ol>]]></content>
    
    
    <summary type="html">本文跳出传统 API 层面，从第一性原理剖析 epoll 的高并发优势，阐释其通过内核态持久化管理、异步事件驱动和红黑树/链表机制，彻底解决 select/poll 线性瓶颈的内核机制与原理。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="epoll" scheme="https://hedon.top/tags/epoll/"/>
    
    <category term="网络编程" scheme="https://hedon.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="非阻塞 i/o" scheme="https://hedon.top/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E-i-o/"/>
    
  </entry>
  
  <entry>
    <title>Go 底层原理丨网络编程</title>
    <link href="https://hedon.top/2025/11/23/go/go-net/"/>
    <id>https://hedon.top/2025/11/23/go/go-net/</id>
    <published>2025-11-23T04:00:00.000Z</published>
    <updated>2025-12-04T12:15:29.767Z</updated>
    
    <content type="html"><![CDATA[<p>本篇我们将讨论 Go 语言底层的网络编程原理，本篇将揭示 Go语言是如何做到<strong>同步的代码，异步的执行</strong>。</p><p>特此声明，本篇是笔者基于 Go 1.25.3 版本源码、并与 Google Gemini 3Pro共创所作，非常庆幸在当今 AI时代下获取知识已是如此便利，且也为学习者从第一性原理理解所学知识大大降低了门槛。不过本篇的篇章安排和叙述逻辑，均由笔者把控和审阅，欢迎放心阅读。</p><p>在开启本章之前，你最好对下列知识有一点的了解：</p><ul><li><ahref="https://hedon954.github.io/noteSite/cs/cn/cn-transfer-layer.html">计算机网络- 传输层</a></li><li><ahref="https://hedon954.github.io/noteSite/cs/cn/cn-apply-layer.html#_5-socket">计算机网络- 应用层 - Socket</a></li><li><ahref="https://hedon954.github.io/noteSite/linux/linux-io/0-concept.html">LinuxIO 模型</a></li><li><ahref="https://hedon954.github.io/noteSite/backend/golang/high/net.html">Go网络编程</a></li><li><ahref="https://hedon.top/2025/11/23/linux-io-epoll/">从第一性原理理解epoll</a></li></ul><h1 id="宏观概述">1. 宏观概述</h1><p>要从根本上理解 Go的网络编程模型，我们需要剥离掉语法糖，回到计算机体系结构和操作系统原理的<strong>第一性原理</strong>：<strong>如何高效地处理 CPU 计算与 I/O等待之间的速度差异？</strong></p><p>Go的网络模型之所以强大，是因为它在一个极其优雅的抽象层（Goroutine）下，完美隐藏了复杂的异步I/O 细节。</p><p>接下来让我们尝试由表及里，从编程模型到内核实现，分三个层级来剖析。</p><h2 id="第一层编程模型-同步的代码异步的执行">2.1 第一层：编程模型 ——同步的代码，异步的执行</h2><p>在 Go 1.25 中，网络编程的依然遵循着 Go诞生之初的哲学：<strong>Goroutine-per-connection</strong>。开发者编写的是标准的<strong>同步阻塞式（Synchronous Blocking）</strong> 代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发者视角：逻辑是线性的</span></span><br><span class="line">listener, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, _ := listener.Accept() <span class="comment">// 看起来这里阻塞了，直到有新连接</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">        n, _ := c.Read(buf) <span class="comment">// 看起来这里阻塞了，直到有数据</span></span><br><span class="line">        <span class="comment">// 处理数据...</span></span><br><span class="line">    &#125;(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果按照 C 语言或早期 Java的传统线程模型，上述代码意味着每个连接需要一个 OS线程。但线程太重了（栈内存约 1MB - 8MB，上下文切换成本高）。但是在 Go语言中，当你调用 <code>c.Read</code> 时，当前的 Goroutine确实"暂停"了，但底层的操作系统线程（M）并没有阻塞，而是去干别的活了。这样开发者拥有了编写简单线性逻辑的权利，同时享受了非阻塞I/O 的高性能。</p><h2 id="第二层系统调用层-非阻塞-io-的伪装">2.2 第二层：系统调用层 ——非阻塞 I/O 的伪装</h2><p>为了实现上述同步阻塞的假象，Go 在底层实际上使用的是 <strong>非阻塞I/O（Non-blocking I/O）</strong>。</p><p>在 Go 1.25 的 <code>net</code> 包内部，当你创建一个 socket 时，GoRuntime 会通过系统调用（如 Linux 下的 <code>socket</code> +<code>fcntl</code>）显式地将该文件描述符（File Descriptor, FD）设置为<strong>Non-blocking</strong> 模式。</p><p>当你调用 <code>conn.Read()</code> 时，Go 底层实际执行了以下逻辑：</p><ol type="1"><li><strong>直接尝试读取：</strong> 直接对 FD 发起 <code>read</code>系统调用。</li><li><strong>EAGAIN 错误：</strong> 绝大多数时候，内核缓冲区是空的。因为FD 是非阻塞的，操作系统不会让线程睡眠，而是立刻返回一个<code>EAGAIN</code>（或<code>EWOULDBLOCK</code>）错误，表示现在没数据，别堵在这。</li><li><strong>捕获错误并挂起：</strong> Go的网络库捕获到这个错误，意识到"现在读不到数据"。于是，它不会让代码报错，而是通过Runtime 调度器将当前的 <strong>Goroutine</strong> 状态置为<code>Gwaiting</code>（等待中），并将该 Goroutine 移出 CPU执行队列。</li></ol><h2 id="第三层runtime-核心-netpoller-与-gmp-的联动">2.3 第三层：Runtime核心 —— Netpoller 与 GMP 的联动</h2><p>这是 Go 网络模型的心脏。Go 引入了一个名为 <strong>Netpoller</strong>的组件，它是 Go Runtime 与操作系统 I/O 多路复用机制（I/OMultiplexing）之间的桥梁。</p><p>Netpoller 并不是一个一直运行的独立线程，而是 Runtime中的一组函数逻辑。它封装了不同操作系统的多路复用技术：</p><ul><li><strong>Linux:</strong> <code>epoll</code></li><li><strong>macOS/FreeBSD:</strong> <code>kqueue</code></li><li><strong>Windows:</strong> <code>IOCP</code></li></ul><p>在 Linux 的 <code>epoll</code> 中，包含 3 个核心函数：</p><ul><li>新建多路复用器：<code>epoll_create()</code></li><li>插入监听事件：<code>epoll_ctl()</code></li><li>查询发生了什么事件：<code>epoll_wait()</code></li></ul><p>Go 的 Netpoller 提供了对各个平台多路复用器的抽象和适配：</p><ul><li><code>netpollinit</code> -&gt; <code>epoll_create</code></li><li><code>netpollopen</code> -&gt; <code>epoll_ctl</code></li><li><code>netpoll</code> -&gt; <code>epoll_wait</code></li></ul><p>让我们回到刚才 <code>conn.Read()</code> 返回 <code>EAGAIN</code>的时刻：</p><ol type="1"><li><strong>注册（Register）：</strong> 当前运行的 Goroutine (G)在被挂起前，会将自己的 FD 和期望的事件（如可读）注册到 Netpoller中。本质上是调用了 <code>epoll_ctl</code> 将 FD 加入监听列表。</li><li><strong>让出（Park）：</strong> G停止运行，M（系统线程）现在空闲了。M 会根据 GMP 调度模型，从P（处理器）的本地队列中抓取下一个可运行的 G 去执行。</li><li><strong>监控（Poll）：</strong> 什么时候唤醒原来的 G？<ul><li><strong>被动触发：</strong> 当系统监控线程 <code>sysmon</code>运行，或者调度器发现没有 G 可运行时，会调用<code>runtime.netpoll</code>。</li><li><strong>底层机制：</strong> <code>runtime.netpoll</code> 内部调用<code>epoll_wait</code>，询问操作系统我关注的那些 FD有哪些数据到了。</li></ul></li><li><strong>唤醒（Ready）：</strong> 操作系统返回就绪的 FD列表。Netpoller 根据 FD 找到当初阻塞在上面的 Goroutine，将其状态改为<code>Grunnable</code>（可运行），并将其注入到当前 P的本地队列或全局队列中。</li><li><strong>执行：</strong> 在下一轮调度中，原来的 G 被 M 拿到，继续执行<code>conn.Read()</code> 后面的代码。</li></ol><h2 id="小节">2.4 小节</h2><p>如果用文字总结这套机制的精髓，可以概括为：<strong>用户态的阻塞，内核态的非阻塞；线性的逻辑，事件驱动的内核。</strong></p><p><strong>完整的数据流向图解：</strong></p><ol type="1"><li><strong>User:</strong> <code>conn.Read(buf)</code></li><li><strong>Go Runtime (Poll):</strong> <code>syscall.Read(fd)</code>-&gt; 返回 <code>EAGAIN</code></li><li><strong>Go Scheduler:</strong><ul><li>调用 <code>netpollOpen</code> (注册 epoll)</li><li>调用 <code>gopark</code> (挂起当前 G，状态 -&gt; Gwaiting)</li><li>线程 M 切换去执行其他 G</li></ul></li><li><strong>--- 时间流逝，网络包到达网卡 ---</strong></li><li><strong>OS Kernel:</strong> 中断处理，数据拷贝到内核缓冲区，FD 变为Readable。</li><li><strong>Go Runtime (Monitor/Schedule):</strong><ul><li><code>sysmon</code> 或 调度器执行 <code>netpoll</code>(<code>epoll_wait</code>)</li><li>发现 FD 就绪</li><li>调用 <code>goready</code> (找到对应的 G，状态 -&gt; Grunnable)</li></ul></li><li><strong>Go Scheduler:</strong> G 被放入队列，最终被 M 执行。</li><li><strong>User:</strong> <code>conn.Read</code> 从挂起处恢复，再次执行<code>syscall.Read</code>，成功读取数据。</li></ol><pre class="mermaid">sequenceDiagram    autonumber    participant G as User Goroutine (G)    participant NP as Netpoller (Internal)    participant Sched as Go Scheduler (M/P)    participant OS as OS Kernel (epoll/IO)    Note over G, Sched: 阶段一：发起读请求 (User Space)    G->>NP: 1. conn.Read(buf)    activate G    activate NP    NP->>OS: 2. syscall.Read(fd) (非阻塞)    OS-->>NP: 3. 返回 EAGAIN (无数据)    Note right of NP: 判定需要挂起    NP->>OS: 4. netpollOpen / epoll_ctl<br/>(注册 FD 到 epoll 实例)    NP->>Sched: 5. gopark (请求挂起 G)    deactivate NP    deactivate G    activate Sched    Note over G: 状态: Grunning -> Gwaiting    Note over Sched: 6. 线程 M 解绑当前 G<br/>M 切换去执行其他 G    deactivate Sched    Note over G, OS: 阶段二：异步等待 (Kernel Space)    G-x G: (Goroutine 暂停，不消耗 CPU)    Note over OS: ... 时间流逝 ...    Note over OS: 7. 网络包到达 -> 中断处理<br/>数据拷入内核缓冲区 -> FD Readable    Note over G, OS: 阶段三：唤醒与执行 (Runtime Monitor)    loop Sysmon 或 调度器检查        Sched->>OS: 8. netpoll (epoll_wait)        OS-->>Sched: 9. 返回就绪 FD 列表    end    activate Sched    Sched->>Sched: 根据 FD 找到对应的 G    Sched->>Sched: 10. goready(G)    Note over G: 状态: Gwaiting -> Grunnable    Sched-->>G: 11. G 被放入本地/全局队列<br/>最终被 M 捕获并执行    deactivate Sched    activate G    Note over G: 从 gopark 处恢复代码执行    G->>NP: 12. 再次调用 internal read    activate NP    NP->>OS: 13. syscall.Read(fd)    OS-->>NP: 14. 返回实际数据 (Data)    NP-->>G: 15. 返回 n, err    deactivate NP    deactivate G</pre><h1 id="源码剖析">2. 源码剖析</h1><p>在对 Go的网络编程模型有了一定的宏观了解后，本篇我们将深入底层源码来剖析 GoRuntime 是如何实现上面这些能力的。</p><h2 id="go-的系统调用的封装">2.1 Go 的系统调用的封装</h2><p>在 Go1.16 左右的版本（笔者之前研究的是 Go.16版本，对其他版本可能不太熟悉），Go 对<code>epoll_create</code>、<code>epoll_ctl</code>等系统调用，每个都有单独的汇编实现，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int32 runtime·epollcreate(int32 size);</span></span><br><span class="line">TEXT runtime·epollcreate(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">MOVL    size+<span class="number">0</span>(FP), DI</span><br><span class="line">MOVL    $SYS_epoll_create, AX</span><br><span class="line">SYSCALL</span><br><span class="line">MOVLAX, ret+<span class="number">8</span>(FP)</span><br><span class="line">RET</span><br><span class="line"></span><br><span class="line"><span class="comment">// func epollctl(epfd, op, fd int32, ev *epollEvent) int</span></span><br><span class="line">TEXT runtime·epollctl(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">MOVLepfd+<span class="number">0</span>(FP), DI</span><br><span class="line">MOVLop+<span class="number">4</span>(FP), SI</span><br><span class="line">MOVLfd+<span class="number">8</span>(FP), DX</span><br><span class="line">MOVQev+<span class="number">16</span>(FP), R10</span><br><span class="line">MOVL$SYS_epoll_ctl, AX</span><br><span class="line">SYSCALL</span><br><span class="line">MOVLAX, ret+<span class="number">24</span>(FP)</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>但是当最近笔者在阅读 Go 1.25 版本的源码时，发现 Go已经统一了系统调用的入口了，如 linux amd64 平台上，Go将系统调用统一封装在 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/asm_linux_amd64.s">internal/runtime/syscall/asm_linux_amd64.s</a>，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// func Syscall6(num, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, errno uintptr)</span><br><span class="line">TEXT ·Syscall6&lt;ABIInternal&gt;(SB),NOSPLIT,$0</span><br><span class="line">// a6 already in R9.</span><br><span class="line">// a5 already in R8.</span><br><span class="line">MOVQSI, R10 // a4</span><br><span class="line">MOVQDI, DX  // a3</span><br><span class="line">MOVQCX, SI  // a2</span><br><span class="line">MOVQBX, DI  // a1</span><br><span class="line">// num already in AX.</span><br><span class="line">SYSCALL</span><br><span class="line">CMPQAX, $0xfffffffffffff001</span><br><span class="line">JLSok</span><br><span class="line">NEGQAX</span><br><span class="line">MOVQAX, CX  // errno</span><br><span class="line">MOVQ$-1, AX // r1</span><br><span class="line">MOVQ$0, BX  // r2</span><br><span class="line">RET</span><br><span class="line">ok:</span><br><span class="line">// r1 already in AX.</span><br><span class="line">MOVQDX, BX // r2</span><br><span class="line">MOVQ$0, CX // errno</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>我们不用太纠结它的具体实现，通过注释，我们可以知道这段汇编对应的就是Go 里面的 <code>Syscall6</code>，具体位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/syscall_linux.go#L17">runtime/syscall/syscall_linux.go#L17</a>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Syscall6 calls system call number &#x27;num&#x27; with arguments a1-6.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Syscall6</span><span class="params">(num, a1, a2, a3, a4, a5, a6 <span class="type">uintptr</span>)</span></span> (r1, r2, errno <span class="type">uintptr</span>)</span><br></pre></td></tr></table></figure><p>它的具体运用在 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/syscall/syscall_linux.go#L95">syscall/syscall_linux.go#L95</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:uintptrkeepalive</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:linkname Syscall6</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Syscall6</span><span class="params">(trap, a1, a2, a3, a4, a5, a6 <span class="type">uintptr</span>)</span></span> (r1, r2 <span class="type">uintptr</span>, err Errno) &#123;</span><br><span class="line">runtime_entersyscall()</span><br><span class="line">r1, r2, err = RawSyscall6(trap, a1, a2, a3, a4, a5, a6)</span><br><span class="line">runtime_exitsyscall()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:uintptrkeepalive</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:norace</span></span><br><span class="line"><span class="comment">//go:linkname RawSyscall6</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RawSyscall6</span><span class="params">(trap, a1, a2, a3, a4, a5, a6 <span class="type">uintptr</span>)</span></span> (r1, r2 <span class="type">uintptr</span>, err Errno) &#123;</span><br><span class="line"><span class="keyword">var</span> errno <span class="type">uintptr</span></span><br><span class="line">r1, r2, errno = runtimesyscall.Syscall6(trap, a1, a2, a3, a4, a5, a6)</span><br><span class="line">err = Errno(errno)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候 <code>epollo_create</code>、<code>epollo_wait</code> 和<code>epollo_ctl</code> 就很好实现了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollCreate1</span><span class="params">(flags <span class="type">int32</span>)</span></span> (fd <span class="type">int32</span>, errno <span class="type">uintptr</span>) &#123;</span><br><span class="line">r1, _, e := Syscall6(SYS_EPOLL_CREATE1, <span class="type">uintptr</span>(flags), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="type">int32</span>(r1), e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _zero <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollWait</span><span class="params">(epfd <span class="type">int32</span>, events []EpollEvent, maxev, waitms <span class="type">int32</span>)</span></span> (n <span class="type">int32</span>, errno <span class="type">uintptr</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> ev unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(events) &gt; <span class="number">0</span> &#123;</span><br><span class="line">ev = unsafe.Pointer(&amp;events[<span class="number">0</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ev = unsafe.Pointer(&amp;_zero)</span><br><span class="line">&#125;</span><br><span class="line">r1, _, e := Syscall6(SYS_EPOLL_PWAIT, <span class="type">uintptr</span>(epfd), <span class="type">uintptr</span>(ev), <span class="type">uintptr</span>(maxev), <span class="type">uintptr</span>(waitms), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="type">int32</span>(r1), e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollCtl</span><span class="params">(epfd, op, fd <span class="type">int32</span>, event *EpollEvent)</span></span> (errno <span class="type">uintptr</span>) &#123;</span><br><span class="line">_, _, e := Syscall6(SYS_EPOLL_CTL, <span class="type">uintptr</span>(epfd), <span class="type">uintptr</span>(op), <span class="type">uintptr</span>(fd), <span class="type">uintptr</span>(unsafe.Pointer(event)), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="go-对-epoll-的抽象---network-poller">2.2 Go 对 Epoll 的抽象 -network poller</h2><blockquote><p>本文仅介绍针对 Linux AMD64 的实现。</p></blockquote><p>Go NetWork Poll 是对各个平台多路复用器的抽象和适配：</p><ul><li><code>netpollinit</code> -&gt; <code>epoll_create</code></li><li><code>netpollopen</code> -&gt; <code>epoll_ctl</code></li><li><code>netpoll</code> -&gt; <code>epoll_wait</code></li></ul><h3 id="netpollinit---epoll_create">2.1.1 netpollinit -&gt;epoll_create</h3><p>系统指令：<strong><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/defs_linux_amd64.go#L14">internal/runtime/syscall/defs_linux_amd64.go</a></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYS_EPOLL_CREATE1 = <span class="number">291</span></span><br></pre></td></tr></table></figure><p>Go 中的声明：<strong><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/syscall_linux.go#L19">EpolloCreate1</a></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollCreate1</span><span class="params">(flags <span class="type">int32</span>)</span></span> (fd <span class="type">int32</span>, errno <span class="type">uintptr</span>) &#123;</span><br><span class="line">r1, _, e := Syscall6(SYS_EPOLL_CREATE1, <span class="type">uintptr</span>(flags), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="type">int32</span>(r1), e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> errno <span class="type">uintptr</span></span><br><span class="line">epfd, errno = syscall.EpollCreate1(syscall.EPOLL_CLOEXEC)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>_EPOLL_CLOEXEC</code>：创建的 epfd 会设置<code>FD_CLOEXEC</code>，它是一个 fd 的标识说明，用来设置文件的close-on-exec 状态的。当 close-on-exec 状态为 0 时，调用 exec 时，fd不会被关闭；非零状态时则会被关闭，这样做可以防止 fd 泄露给执行 exec后的进程。</li></ul><p>针对 Linux 的实现：<strong><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/netpoll_epoll.go#L21">runtime/netpoll_epoll.go</a></strong></p><ol type="1"><li><strong>创建 epoll 实例</strong>：创建 Linux 的 I/O多路复用器，用于同时监控成千上万个网络连接。</li><li><strong>创建eventfd</strong>：创建一个特殊的文件描述符，用于唤醒阻塞线程。</li><li><strong>将 eventfd 注册到epoll</strong>：这样既能等网络事件，也能被主动唤醒。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建多路复用器，这个函数在 Go 程序启动时被调用一次，用于初始化 Linux 平台的网络轮询器（netpoller）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> errno <span class="type">uintptr</span></span><br><span class="line">  <span class="comment">// 1. 创建一个 epoll 实例，返回的文件描述符存储在全局变量 `epfd` 中</span></span><br><span class="line">  <span class="comment">//`EPOLL_CLOEXEC` 标志确保在 `exec` 时自动关闭这个 fd</span></span><br><span class="line">epfd, errno = syscall.EpollCreate1(syscall.EPOLL_CLOEXEC)</span><br><span class="line"><span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;runtime: epollcreate failed with&quot;</span>, errno)</span><br><span class="line">throw(<span class="string">&quot;runtime: netpollinit failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 2. 创建一个 eventfd，这是 Linux 的一种特殊文件描述符</span></span><br><span class="line">  <span class="comment">// 设置为非阻塞模式（EFD_NONBLOCK）和 exec 时关闭（EFD_CLOEXEC）</span></span><br><span class="line">  <span class="comment">// eventfd 用于唤醒阻塞在 `epoll_wait` 上的线程。这是 Go netpoller 的关键机制！</span></span><br><span class="line">efd, errno := syscall.Eventfd(<span class="number">0</span>, syscall.EFD_CLOEXEC|syscall.EFD_NONBLOCK)</span><br><span class="line"><span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;runtime: eventfd failed with&quot;</span>, -errno)</span><br><span class="line">throw(<span class="string">&quot;runtime: eventfd failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 3. 构造 epollo 事件结构，syscall.EPOLLIN 表示监听可读事件</span></span><br><span class="line">ev := syscall.EpollEvent&#123;</span><br><span class="line">Events: syscall.EPOLLIN,</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 4. 将 netpollEventFd 的地址存储到 ev.Data 中</span></span><br><span class="line">  <span class="comment">//当 epoll 返回事件时，我们需要知道是哪个 fd 触发的事件。</span></span><br><span class="line">  <span class="comment">//通过 Data 字段，我们可以区分：</span></span><br><span class="line">  <span class="comment">//- 是 eventfd 触发的（唤醒信号）</span></span><br><span class="line">  <span class="comment">//- 还是某个网络连接 fd 触发的（真正的网络 I/O）</span></span><br><span class="line">*(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.Data)) = &amp;netpollEventFd</span><br><span class="line">  <span class="comment">// 5. 使用 `EPOLL_CTL_ADD` 操作将 eventfd 添加到 epoll 实例中</span></span><br><span class="line">  <span class="comment">//当 eventfd 变为可读时，epoll_wait 会返回</span></span><br><span class="line">errno = syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, efd, &amp;ev)</span><br><span class="line"><span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;runtime: epollctl failed with&quot;</span>, errno)</span><br><span class="line">throw(<span class="string">&quot;runtime: epollctl failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 6. 将 eventfd 保存到全局变量中</span></span><br><span class="line">  <span class="comment">//后续 `netpollBreak()` 函数会使用这个 fd 来唤醒阻塞的 epoll_wait</span></span><br><span class="line">netpollEventFd = <span class="type">uintptr</span>(efd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="netpollopen---epoll_ctl">2.1.2 netpollopen -&gt; epoll_ctl</h3><p>系统指令：<strong><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/defs_linux_amd64.go#L12">internal/runtime/syscall/defs_linux_amd64.go</a></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYS_EPOLL_CTL     = <span class="number">233</span></span><br></pre></td></tr></table></figure><p>Go 中的声明：<strong><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/syscall_linux.go#L37">EpolloCtl</a></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollCtl</span><span class="params">(epfd, op, fd <span class="type">int32</span>, event *EpollEvent)</span></span> (errno <span class="type">uintptr</span>) &#123;</span><br><span class="line">_, _, e := Syscall6(SYS_EPOLL_CTL, <span class="type">uintptr</span>(epfd), <span class="type">uintptr</span>(op), <span class="type">uintptr</span>(fd), <span class="type">uintptr</span>(unsafe.Pointer(event)), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>epfd</code>：epoll_create函数返回的文件描述符，用于标识内核中的 epoll 实例</li><li><code>op</code>：对 fd 文件描述符的操作类型：<ul><li><code>EPOLL_CTL_ADD</code>：向 interest list添加一个需要监视的描述符</li><li><code>EPOLL_CTL_DEL</code>：向 interest list 删除一个描述符</li><li><code>EPOLL_CTL_MOD</code>：修改 interst list 中的一个描述符</li></ul></li><li><code>fd</code>：需要被操作的文件描述符</li><li><code>event</code>：一个指向名为 epoll_event的结构的指针，它存储了我们实际要监视的 fd 的事件<ul><li><code>EPOLLIN</code>：表示对应的文件描述符可以读。</li><li><code>EPOLLOUT</code>：表示对应的文件描述符可以写。</li><li><code>EPOLLERR</code>：表示对应的文件描述符发生错误。</li><li><code>EPOLLHUP</code>：表示对应的文件描述符被挂断。</li><li><code>EPOLLRDHUP</code>：表示对端关闭连接或半关闭写端。</li><li><code>EPOLLET</code>： 将 epoll 设为边缘触发（EdgeTriggered）模式，相对于水平触发（Level Triggered）来说的。</li></ul></li></ul><p>针对 Linux 的实现：<strong><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/netpoll_epoll.go#L49">runtime/netpoll_epoll.go</a></strong></p><ol type="1"><li>传入一个 socket 的 fd，和 pollDesc 指针，pollDesc 是 Go 中对 socket的抽象。pollDesc 中记录了 socket 的详细信息，以及哪个协程休眠在等待此socket；</li><li>将 socket 的可读、可写、断开事件注册到 epoll 中；</li><li>将 epoll 设置为 ET 模式。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 fd 的四个事件 syscall.EPOLLIN | syscall.EPOLLOUT | syscall.EPOLLRDHUP | syscall.EPOLLET 注册到 epfd 上</span></span><br><span class="line"><span class="comment">// 开始监控其 I/O 事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="type">uintptr</span>, pd *pollDesc)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line"><span class="keyword">var</span> ev syscall.EpollEvent</span><br><span class="line">ev.Events = syscall.EPOLLIN | syscall.EPOLLOUT | syscall.EPOLLRDHUP | syscall.EPOLLET</span><br><span class="line">tp := taggedPointerPack(unsafe.Pointer(pd), pd.fdseq.Load())</span><br><span class="line">*(*taggedPointer)(unsafe.Pointer(&amp;ev.Data)) = tp</span><br><span class="line"><span class="keyword">return</span> syscall.EpollCtl(epfd, syscall.EPOLL_CTL_ADD, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="netpoll---epoll_wait">2.1.3 netpoll -&gt; epoll_wait</h3><p>系统指令：<strong><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/defs_linux_amd64.go#L13">internal/runtime/syscall/defs_linux_amd64.go</a></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYS_EPOLL_PWAIT   = <span class="number">281</span></span><br></pre></td></tr></table></figure><p>Go 中的声明：<strong><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/runtime/syscall/syscall_linux.go#L26">EpolloWait</a></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollWait</span><span class="params">(epfd <span class="type">int32</span>, events []EpollEvent, maxev, waitms <span class="type">int32</span>)</span></span> (n <span class="type">int32</span>, errno <span class="type">uintptr</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> ev unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(events) &gt; <span class="number">0</span> &#123;</span><br><span class="line">ev = unsafe.Pointer(&amp;events[<span class="number">0</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ev = unsafe.Pointer(&amp;_zero)</span><br><span class="line">&#125;</span><br><span class="line">r1, _, e := Syscall6(SYS_EPOLL_PWAIT, <span class="type">uintptr</span>(epfd), <span class="type">uintptr</span>(ev), <span class="type">uintptr</span>(maxev), <span class="type">uintptr</span>(waitms), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="type">int32</span>(r1), e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>epfd</code>：epoll_create函数返回的文件描述符，用于标识内核中的 epoll 实例。</li><li><code>ev</code> 已经分配好的 epoll_event 结构体数组，epoll会把发生的事件存入 events 中。</li><li><code>maxev</code>：告诉内核最多返回的事件数量有多大，必须大于0。</li><li><code>waitms</code>：超时时间，<strong>-1</strong> 表示 epoll将无限制等待下去。</li></ul><p>针对 Linux 的实现：<strong><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/netpoll_epoll.go#L99">runtime/netpoll_epoll.go</a></strong></p><ol type="1"><li>根据 delay 确定要轮询多久；</li><li>创建一个长度为 128 的事件列表；</li><li>调用系统底层的 epollwait，查询有多少事件发生了；</li><li>新建一个协程列表；</li><li>遍历事件列表；</li><li>获取 go 中对 fd 的抽象结构体的值 pd；</li><li>将 pd 中的 g 取出来加入到 toRun 列表中；</li><li>返回可执行的 <font color="red">goroutine</font> 列表。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意返回的是一个可执行的 Goroutine 列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delay <span class="type">int64</span>)</span></span> (gList, <span class="type">int32</span>) &#123;</span><br><span class="line"><span class="comment">// 1. 计算超时时间</span></span><br><span class="line"><span class="keyword">var</span> waitms <span class="type">int32</span></span><br><span class="line"><span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;  <span class="comment">// 无限等待，阻塞直到有事件</span></span><br><span class="line">waitms = <span class="number">-1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay == <span class="number">0</span> &#123;  <span class="comment">// 非阻塞，立即返回</span></span><br><span class="line">waitms = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e6</span> &#123;</span><br><span class="line">waitms = <span class="number">1</span> <span class="comment">// 小于 1 微秒的延迟，至少等待 1 毫秒，毫秒是最小粒度，0 会变成非阻塞</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e15</span> &#123;</span><br><span class="line">waitms = <span class="type">int32</span>(delay / <span class="number">1e6</span>)  <span class="comment">// 正常范围：转换纳秒到毫秒 (1ms = 1e6 ns)</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">waitms = <span class="number">1e9</span> <span class="comment">// 超大延迟，限制为约 11.5 天</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 准备接收最多 128 个就绪事件</span></span><br><span class="line"><span class="keyword">var</span> events [<span class="number">128</span>]syscall.EpollEvent</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line"><span class="comment">// 3. 调用 epoll_wait 等待事件</span></span><br><span class="line">n, errno := syscall.EpollWait(epfd, events[:], <span class="type">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line"><span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> errno != _EINTR &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;runtime: epollwait on fd&quot;</span>, epfd, <span class="string">&quot;failed with&quot;</span>, errno)</span><br><span class="line">throw(<span class="string">&quot;runtime: netpoll failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> gList&#123;&#125;, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 初始化返回值</span></span><br><span class="line"><span class="keyword">var</span> toRun gList      <span class="comment">// 就绪的 goroutine 列表</span></span><br><span class="line">delta := <span class="type">int32</span>(<span class="number">0</span>)    <span class="comment">// netpollWaiters 的调整值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.处理所有返回的事件</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">ev := events[i]</span><br><span class="line"><span class="keyword">if</span> ev.Events == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 判断是否是 eventfd 的唤醒信号，eventfd 用于从外部唤醒 epoll_wait</span></span><br><span class="line"><span class="keyword">if</span> *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.Data)) == &amp;netpollEventFd &#123;</span><br><span class="line"><span class="comment">// eventfd 应该只产生 EPOLLIN 事件</span></span><br><span class="line"><span class="keyword">if</span> ev.Events != syscall.EPOLLIN &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;runtime: netpoll: eventfd ready for&quot;</span>, ev.Events)</span><br><span class="line">throw(<span class="string">&quot;runtime: netpoll: eventfd ready for something unexpected&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费唤醒信号</span></span><br><span class="line"><span class="keyword">if</span> delay != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> one <span class="type">uint64</span></span><br><span class="line">read(<span class="type">int32</span>(netpollEventFd), noescape(unsafe.Pointer(&amp;one)), <span class="type">int32</span>(unsafe.Sizeof(one)))</span><br><span class="line"><span class="comment">// 清除唤醒标志，允许下次 netpollBreak</span></span><br><span class="line">netpollWakeSig.Store(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 跳过 eventfd，继续处理其他事件，eventfd 只是唤醒机制，不对应真实的网络 I/O</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.根据触发的事件设置读写模式</span></span><br><span class="line"><span class="keyword">var</span> mode <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [可读事件] 检查各种可读条件</span></span><br><span class="line"><span class="keyword">if</span> ev.Events&amp;(syscall.EPOLLIN|syscall.EPOLLRDHUP|syscall.EPOLLHUP|syscall.EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// EPOLLIN: 有数据可读</span></span><br><span class="line"><span class="comment">// EPOLLRDHUP: 对端关闭写端（半关闭）</span></span><br><span class="line"><span class="comment">// EPOLLHUP: 连接挂断</span></span><br><span class="line"><span class="comment">// EPOLLERR: 发生错误</span></span><br><span class="line">mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [可写事件] 检查各种可写条件</span></span><br><span class="line"><span class="keyword">if</span> ev.Events&amp;(syscall.EPOLLOUT|syscall.EPOLLHUP|syscall.EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// EPOLLOUT: 可以写入数据</span></span><br><span class="line"><span class="comment">// EPOLLHUP: 连接挂断</span></span><br><span class="line"><span class="comment">// EPOLLERR: 发生错误</span></span><br><span class="line">mode += <span class="string">&#x27;w&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：mode 可能是 &#x27;r&#x27;(114), &#x27;w&#x27;(119), 或 &#x27;r&#x27;+&#x27;w&#x27;(233)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 8. 获取 netpoller 对 socket 的抽象实例 pollDesc</span></span><br><span class="line">tp := *(*taggedPointer)(unsafe.Pointer(&amp;ev.Data))</span><br><span class="line">pd := (*pollDesc)(tp.pointer())</span><br><span class="line">tag := tp.tag() <span class="comment">// 提取序列号标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 检查是否是过期事件</span></span><br><span class="line"><span class="keyword">if</span> pd.fdseq.Load() == tag &#123;</span><br><span class="line"><span class="comment">// 序列号匹配，这是有效的事件</span></span><br><span class="line"><span class="comment">// 原因：防止 ABA 问题（fd 被关闭后重新打开复用）</span></span><br><span class="line">pd.setEventErr(ev.Events == syscall.EPOLLERR, tag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 将就绪的 goroutine 加入运行队列</span></span><br><span class="line">delta += netpollready(&amp;toRun, pd, mode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// else: 序列号不匹配，忽略过期事件，说明这个 pollDesc 已经被新的连接复用了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11. 返回就绪的 goroutine 列表和等待计数调整值</span></span><br><span class="line"><span class="keyword">return</span> toRun, delta</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>netpollready()</code> 表示 pd 底层的 fd 已经可以进行 I/O操作了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="type">int32</span>)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">delta := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> rg, wg *g</span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">&#x27;r&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">true</span>, &amp;delta)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> || mode == <span class="string">&#x27;r&#x27;</span>+<span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">wg = netpollunblock(pd, <span class="string">&#x27;w&#x27;</span>, <span class="literal">true</span>, &amp;delta)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">toRun.push(rg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">toRun.push(wg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> delta</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="谁在调用-netpoll">2.1.4 谁在调用 netpoll()？</h3><h4 id="垃圾回收循环">2.1.4.1 垃圾回收循环</h4><p><code>runtime/proc.go</code> 中的 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/proc.go#L1768">startTheWorldWithSema()</a>会调用 <code>netpoll()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTheWorldWithSema</span><span class="params">(emitTraceEvent <span class="type">bool</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> netpollinited() &#123;</span><br><span class="line">list := netpoll(<span class="number">0</span>)   <span class="comment">//调用 netpoll</span></span><br><span class="line">injectglist(&amp;list)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtime/mgc.go</code> 中的 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/mgc.go#L744">gcStart()</a>会调用 <code>startTheWorldWithSema()</code>，而 <code>gcStart()</code>又会被我们的 g0 协程一直循环执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcStart starts the GC.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Concurrent mark.</span></span><br><span class="line">  systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    now = startTheWorldWithSema(trace.enabled)<span class="comment">// 调用 startTheWorldWithSema</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且 <code>g0</code> 协程在循环 gc 的时候，顺带执行了<code>netpoll()</code> 来检查是否有事件发生。</p><h4 id="协程调度">2.1.4.2 协程调度</h4><p>在 <a href="https://hedon.top/2024/01/20/go/go-gpm/">深入浅出 Go语言的 GPM 模型（Go1.21）</a> 中，我们提到了 Go 协程调度最核心的函数<code>schedule()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">gp, inheritTime, tryWakeP := findRunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程调度的时候会去执行 <code>findRunnable()</code> 寻找可以运行的Goroutine，这里面也会调用 <code>netpoll()</code>检查是否有网络事件发生。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRunnable</span><span class="params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"><span class="comment">// Poll network until next timer.</span></span><br><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; (netpollAnyWaiters() || pollUntil != <span class="number">0</span>) &amp;&amp; sched.lastpoll.Swap(<span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//..</span></span><br><span class="line">list, delta := netpoll(delay) <span class="comment">// block until new work is available</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="network-poll-对-socket-的抽象-polldesc">2.2 network poll 对socket 的抽象 —— pollDesc</h2><p>Go 的 netpoller 需要进一步对 socket 进行抽象，是为了解决 2个核心问题：</p><ol type="1"><li><strong>状态同步问题</strong>：如何让 Go调度器（用户态）和操作系统内核（内核态）共享同一个 socket的状态（是读还是写？是谁在等？）。</li><li><strong>生命周期错位问题</strong>：操作系统内核的通知是异步的，可能在Go已经关闭或复用了文件描述符（FD）之后，内核才发来一个旧的就绪通知。这会导致严重的内存腐坏或逻辑错误。</li></ol><p>为此，Go 定义了两个数据结构：<code>pollDesc</code> 和<code>pollCache</code>。我们将 <code>pollDesc</code>看作<strong>"桥梁"</strong>，将 <code>pollCache</code>看作<strong>"安全区"</strong>。</p><h3 id="polldesc">2.2.1 pollDesc</h3><p><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/netpoll.go#L75">pollDesc</a>是 Go运行时为每个网络文件描述符（socket）创建的轮询描述符对象，用于管理该 fd的异步 I/O 状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network poller descriptor.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// No heap pointers.</span></span><br><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">_     sys.NotInHeap</span><br><span class="line">link  *pollDesc      <span class="comment">// in pollcache, protected by pollcache.lock</span></span><br><span class="line">fd    <span class="type">uintptr</span>        <span class="comment">// constant for pollDesc usage lifetime</span></span><br><span class="line">fdseq atomic.Uintptr <span class="comment">// protects against stale pollDesc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// atomicInfo holds bits from closing, rd, and wd,</span></span><br><span class="line"><span class="comment">// which are only ever written while holding the lock,</span></span><br><span class="line"><span class="comment">// summarized for use by netpollcheckerr,</span></span><br><span class="line"><span class="comment">// which cannot acquire the lock.</span></span><br><span class="line"><span class="comment">// After writing these fields under lock in a way that</span></span><br><span class="line"><span class="comment">// might change the summary, code must call publishInfo</span></span><br><span class="line"><span class="comment">// before releasing the lock.</span></span><br><span class="line"><span class="comment">// Code that changes fields and then calls netpollunblock</span></span><br><span class="line"><span class="comment">// (while still holding the lock) must call publishInfo</span></span><br><span class="line"><span class="comment">// before calling netpollunblock, because publishInfo is what</span></span><br><span class="line"><span class="comment">// stops netpollblock from blocking anew</span></span><br><span class="line"><span class="comment">// (by changing the result of netpollcheckerr).</span></span><br><span class="line"><span class="comment">// atomicInfo also holds the eventErr bit,</span></span><br><span class="line"><span class="comment">// recording whether a poll event on the fd got an error;</span></span><br><span class="line"><span class="comment">// atomicInfo is the only source of truth for that bit.</span></span><br><span class="line">atomicInfo atomic.Uint32 <span class="comment">// atomic pollInfo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rg, wg are accessed atomically and hold g pointers.</span></span><br><span class="line"><span class="comment">// (Using atomic.Uintptr here is similar to using guintptr elsewhere.)</span></span><br><span class="line">rg atomic.Uintptr <span class="comment">// pdReady, pdWait, G waiting for read or pdNil</span></span><br><span class="line">wg atomic.Uintptr <span class="comment">// pdReady, pdWait, G waiting for write or pdNil</span></span><br><span class="line"></span><br><span class="line">lock    mutex <span class="comment">// protects the following fields</span></span><br><span class="line">closing <span class="type">bool</span></span><br><span class="line">rrun    <span class="type">bool</span>      <span class="comment">// whether rt is running</span></span><br><span class="line">wrun    <span class="type">bool</span>      <span class="comment">// whether wt is running</span></span><br><span class="line">user    <span class="type">uint32</span>    <span class="comment">// user settable cookie</span></span><br><span class="line">rseq    <span class="type">uintptr</span>   <span class="comment">// protects from stale read timers</span></span><br><span class="line">rt      timer     <span class="comment">// read deadline timer</span></span><br><span class="line">rd      <span class="type">int64</span>     <span class="comment">// read deadline (a nanotime in the future, -1 when expired)</span></span><br><span class="line">wseq    <span class="type">uintptr</span>   <span class="comment">// protects from stale write timers</span></span><br><span class="line">wt      timer     <span class="comment">// write deadline timer</span></span><br><span class="line">wd      <span class="type">int64</span>     <span class="comment">// write deadline (a nanotime in the future, -1 when expired)</span></span><br><span class="line">self    *pollDesc <span class="comment">// storage for indirect interface. See (*pollDesc).makeArg.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心字段解析：</p><ol type="1"><li><p><strong><code>fd</code></strong>：这是最原始的操作系统文件描述符（例如Linux 上的 <code>int</code> 类型的 5, 6 等）。它是连接到<code>epoll</code> / <code>kqueue</code> 的物理句柄。</p></li><li><p><strong><code>rg</code> (Read Group) / <code>wg</code> (WriteGroup)</strong>：<strong>这是最重要的字段。</strong>它们实现了无锁（Lock-free）的状态流转。它们不仅仅存储 Goroutine的指针（<code>*g</code>），还是一个多状态的原子变量：</p><ul><li><code>0 (pdNil)</code>: 没有任何 Goroutine 在等待。</li><li><code>1 (pdReady)</code>: I/O已经就绪（网卡有数据了），不需要等待，直接读。</li><li><code>2 (pdWait)</code>: 正在准备挂起，作为中间状态。</li><li><code>&gt; 2 (G Pointer)</code>: <strong>存储了正在阻塞等待的Goroutine 的内存地址。</strong></li></ul><p>当 <code>epoll_wait</code> 返回就绪事件时，Netpoller 会通过<code>rg</code> 或 <code>wg</code> 里的地址找到那个 G，然后调用<code>goready(G)</code> 唤醒它。</p></li><li><p>超时管理（<strong><code>rt</code></strong>、<strong><code>wt</code></strong>、<strong><code>rd</code></strong>、<strong><code>wd</code></strong>）：管理读写操作的deadline。Go 的 <code>SetReadDeadline</code> 和<code>SetWriteDeadline</code>就是在这里实现的。每个网络连接自带两个定时器。如果超时触发，定时器回调会强制将<code>rg</code> 或 <code>wg</code> 状态置为错误，并唤醒 G。G醒来后发现是超时导致的唤醒，于是返回<code>timeout error</code>。</p></li><li><p>防止过时通知（<strong><code>fdseq</code></strong>、<strong><code>rseq</code></strong>、<strong><code>wseq</code></strong>）：通过序列号防止在<code>fd</code> 复用后收到旧的就绪通知。</p></li><li><p><strong><code>link</code></strong>：指向下一个空闲的<code>pollDesc</code>，后面会详细分析。</p></li></ol><h3 id="pollcache">2.2.1 pollCache</h3><p>网络程序中会频繁地打开和关闭连接，每个连接都需要一个<code>pollDesc</code>。如果每次都分配新对象并最终让 GC回收，会带来巨大的性能开销。<ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/netpoll.go#L192">pollCache</a>通过对象池模式复用<code>pollDesc</code>，大幅提升性能。用一句话概述就是：<code>pollCache</code>是一个专门用于分配 <code>pollDesc</code> 的链表式缓存池。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollCache <span class="keyword">struct</span> &#123;</span><br><span class="line">lock  mutex<span class="comment">// 锁</span></span><br><span class="line">first *pollDesc<span class="comment">// 指向 pollDesc 链表的第一个节点，即下一个可用的空闲节点（头插法）</span></span><br><span class="line"><span class="comment">// PollDesc objects must be type-stable,</span></span><br><span class="line"><span class="comment">// because we can get ready notification from epoll/kqueue</span></span><br><span class="line"><span class="comment">// after the descriptor is closed/reused.</span></span><br><span class="line"><span class="comment">// Stale notifications are detected using seq variable,</span></span><br><span class="line"><span class="comment">// seq is incremented when deadlines are changed or descriptor is reused.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信不少读者都会注意到注释中的这句话：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PollDesc objects must be type-stable,</span></span><br></pre></td></tr></table></figure><p>为什么呢？想象下面这样一个流程：</p><ol type="1"><li>你打开了一个 Socket，FD 为 10。</li><li>Go 将 FD 10 注册给<code>epoll</code>，由于内核并没有给我们回调函数，<code>epoll</code>内部通常存储的是 <code>pollDesc</code> 的<strong>内存地址</strong>作为<code>user_data</code>。</li><li>你关闭了连接。Go 回收了 FD 10，也释放了 <code>pollDesc</code>的内存。</li><li><strong>危险时刻</strong>：假设这块内存立刻被 Go 的 GC 分配给了一个<code>string</code> 或者是其他对象。</li><li><strong>延迟通知</strong>：此时，内核里积压的一个关于 FD 10的"可读"事件突然触发了（或者是一个极端的竞态条件）。<code>epoll</code>返回了那个旧的 <code>pollDesc</code> 内存地址，告诉 Runtime这里"可读"。</li><li><strong>崩溃</strong>：Runtime 以为这还是个<code>pollDesc</code>，试图去修改它的 <code>rg</code>字段。但这块内存现在存的是一个字符串！<strong>结果：内存腐坏（MemoryCorruption），程序直接崩溃且极难调试。</strong></li></ol><p><strong>解决方案：Type-Stable Memory（类型稳定内存）</strong></p><p><code>pollCache</code>保证了通过它分配出去的内存块，<strong>即使被释放回收了，也永远只能作为<code>pollDesc</code> 存在，绝不会被 GC 挪作他用。</strong></p><ul><li><code>sys.NotInHeap</code>: 标记这个结构体不在普通的 GC堆上管理，而是手动管理的（<code>pollDesc</code> 的第一个字段）。</li><li><strong>链表管理</strong>:<ul><li><code>lock</code>: 保护链表。</li><li><code>first</code>: 指向链表头部的空闲 <code>pollDesc</code>。</li><li><strong>分配</strong>: 从 <code>first</code> 取一个。如果链表空，向OS 申请一大块内存（4KB），切分成多个 <code>pollDesc</code>串到链表上。</li><li><strong>释放</strong>: 并不是真的 <code>free</code>掉内存，而是把它放回 <code>first</code>链表头，留给下一个连接复用。</li></ul></li></ul><p>这就保证了：即使内核发来一个过期的通知，Runtime访问的那个内存地址依然是一个合法的 <code>pollDesc</code>结构体（虽然它可能不再关联任何活跃连接），最多就是读到一个无效状态，而不会导致内存越界或类型错误。</p><h4 id="分配-alloc">2.2.1.1 分配 alloc</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span></span> alloc() *pollDesc &#123;</span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line">  <span class="comment">// 1. 未初始化，则先进行初始化，一次性分配 n 个 pollDesc</span></span><br><span class="line"><span class="keyword">if</span> c.first == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">type</span> pollDescPadded <span class="keyword">struct</span> &#123;</span><br><span class="line">pollDesc</span><br><span class="line">pad [tagAlign - unsafe.Sizeof(pollDesc&#123;&#125;)]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pdSize = unsafe.Sizeof(pollDescPadded&#123;&#125;)</span><br><span class="line">n := pollBlockSize / pdSize</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Must be in non-GC memory because can be referenced</span></span><br><span class="line"><span class="comment">// only from epoll/kqueue internals.</span></span><br><span class="line">mem := persistentalloc(n*pdSize, tagAlign, &amp;memstats.other_sys)</span><br><span class="line"><span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">pd := (*pollDesc)(add(mem, i*pdSize))</span><br><span class="line">lockInit(&amp;pd.lock, lockRankPollDesc)</span><br><span class="line">pd.rt.init(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">pd.wt.init(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">pd.link = c.first</span><br><span class="line">c.first = pd</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 2. 取出链表头部的空闲节点</span></span><br><span class="line">pd := c.first</span><br><span class="line">  <span class="comment">// 3. 移动到下一个空闲节点</span></span><br><span class="line">c.first = pd.link</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> pd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回收-free">2.2.1.2 回收 free</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span></span> free(pd *pollDesc) &#123;</span><br><span class="line"><span class="comment">// pd can&#x27;t be shared here, but lock anyhow because</span></span><br><span class="line"><span class="comment">// that&#x27;s what publishInfo documents.</span></span><br><span class="line">lock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 自增 fdseq，避免处理过期事件造成生命周期错位问题</span></span><br><span class="line">fdseq := pd.fdseq.Load()</span><br><span class="line">fdseq = (fdseq + <span class="number">1</span>) &amp; (<span class="number">1</span>&lt;&lt;tagBits - <span class="number">1</span>)</span><br><span class="line">pd.fdseq.Store(fdseq)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 重置 pollDesc</span></span><br><span class="line">pd.publishInfo()</span><br><span class="line"></span><br><span class="line">unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 放回链表头部</span></span><br><span class="line">pd.link = c.first</span><br><span class="line">c.first = pd</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即便内存类型安全了，我们还面临逻辑上的 <strong>ABA问题</strong>：</p><ol type="1"><li>Goroutine A 使用 FD 10 (<code>pollDesc</code> 地址 0x123)。</li><li>A 关闭连接，释放 FD 10，释放 <code>pollDesc</code> (0x123返回缓存池)。</li><li>Goroutine B 建立新连接，刚好系统又分配了 FD 10，且<code>pollCache</code> 又把 0x123 分配给了 B。</li><li><strong>此时，内核发来了 A 时代的 FD 10 的就绪事件。</strong></li><li>Runtime 拿着 0x123，以为是 B 的数据来了，错误地唤醒了B（或者处理了错误的数据）。</li></ol><p><strong><code>fdseq</code> 的作用：</strong> 每次<code>pollDesc</code> 被复用（从缓存池拿出来）时，<code>fdseq</code>都会自增。</p><ul><li>当注册 <code>epoll</code> 时，Go 会把当前的 <code>fdseq</code>记录在某个地方（或者在检查时比对）。</li><li>当事件回来时，Runtime会检查：<code>Event.seq == pollDesc.seq?</code></li><li>如果不相等，说明是个过期事件，直接忽略，不进行唤醒操作。</li></ul><h3 id="总结">2.2.3 总结</h3><ol type="1"><li><strong><code>pollDesc</code> (State)</strong>: 使用<code>atomic.Uintptr</code> 存储 Goroutine 指针，实现了<strong>用户态 G与内核态 I/O 事件的高效无锁传递</strong>。</li><li><strong><code>pollCache</code> (Memory)</strong>:使用<strong>类型稳定内存（Type-StableMemory）</strong>，从物理内存布局的层面消灭了异步 I/O可能导致的内存腐坏风险。</li><li><strong><code>fdseq</code> (Logic)</strong>:使用<strong>版本号机制</strong>，解决了资源复用带来的逻辑混淆（ABA问题）。</li></ol><p>这就是为什么 Go的网络库在高并发、高动态（大量连接建立和断开）场景下，依然稳如磐石的底层原因。</p><h2 id="network-poller-工作细节">2.3 network poller 工作细节</h2><h3 id="初始化-poll_runtime_pollserverinit">2.3.1 初始化poll_runtime_pollServerInit</h3><p>通过原子操作 &amp; 双重检查来执行一次<code>netpollinit()</code>，创建一个 epoll。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollServerInit internal/poll.runtime_pollServerInit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollServerInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">netpollGenericInit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollGenericInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 类似于 双重检查 的单例模式</span></span><br><span class="line">  <span class="comment">// 保证只执行一次 netpollinit()</span></span><br><span class="line"><span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">lockInit(&amp;netpollInitLock, lockRankNetpollInit)</span><br><span class="line">lockInit(&amp;pollcache.lock, lockRankPollCache)</span><br><span class="line">lock(&amp;netpollInitLock)</span><br><span class="line"><span class="keyword">if</span> netpollInited.Load() == <span class="number">0</span> &#123;</span><br><span class="line">netpollinit() <span class="comment">// epoll_create() 创建一个多路复用器</span></span><br><span class="line">netpollInited.Store(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;netpollInitLock)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tag-plugin colorful note" color="green"><div class="title"><strong><p>补充：go:linkname</p></strong></div><div class="body"><p>补充：go:linkname</p><blockquote><p>The //go:linkname directive instructs the compiler to use“importpath.name” as the object file symbol name for the variable orfunction declared as “localname” in the source code. Because thisdirective can subvert the type system and package modularity, it is onlyenabled in files that have imported “unsafe”.</p></blockquote><p><code>//go:linkname</code>的目的是告诉编译器使用<code>importpath.name</code>来对本来不可导出的（localname）函数或者变量实现导出功能。由于这种方法是破坏了Go语言的模块化规则的，所以必须在导入了<code>"unsafe"</code>包的情况下使用。</p><p>即：</p><blockquote><p>由于 Go语法规则限制，小写字母开头的函数或者变量是本模块私有的，不可被包外的代码访问；但是如果必须要能被外部模块访问到，又要限制为私有方法呢？只能在编译器上做手脚，通过一个特殊的<strong>标记</strong> 来实现这种功能。</p></blockquote><p>具体到上面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollServerInit internal/poll.runtime_pollServerInit</span></span><br></pre></td></tr></table></figure><ul><li>表示调用 <code>internal/poll.runtime_pollServerInit</code>相当于调用当前的 <code>poll_runtime_pollServerInit</code>。</li></ul></div></div><h3 id="新增监听-poll_runtime_pollopen">2.3.2 新增监听poll_runtime_pollOpen</h3><ol type="1"><li>在 pollcache 链表中分配一个 pollDesc，用来描述要新增将它的socket；</li><li>初始化 pollDesc，主要是将 rg、wg 置为 0；</li><li>调用 netpollopen，将底层 socket 及其读、写和断开事件注册到 epoll上；</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollOpen internal/poll.runtime_pollOpen</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollOpen</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> (*pollDesc, <span class="type">int</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 分配一个 pollDesc，用来描述要新增监听的 socket</span></span><br><span class="line">pd := pollcache.alloc()</span><br><span class="line">  <span class="comment">// 2. 上锁</span></span><br><span class="line">lock(&amp;pd.lock)</span><br><span class="line">wg := pd.wg.Load()</span><br><span class="line"><span class="keyword">if</span> wg != pdNil &amp;&amp; wg != pdReady &#123;</span><br><span class="line">throw(<span class="string">&quot;runtime: blocked write on free polldesc&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">rg := pd.rg.Load()</span><br><span class="line"><span class="keyword">if</span> rg != pdNil &amp;&amp; rg != pdReady &#123;</span><br><span class="line">throw(<span class="string">&quot;runtime: blocked read on free polldesc&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 3. 赋值</span></span><br><span class="line">pd.fd = fd</span><br><span class="line"><span class="keyword">if</span> pd.fdseq.Load() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// The value 0 is special in setEventErr, so don&#x27;t use it.</span></span><br><span class="line">pd.fdseq.Store(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">pd.closing = <span class="literal">false</span></span><br><span class="line">pd.setEventErr(<span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">pd.rseq++</span><br><span class="line">pd.rg.Store(pdNil)<span class="comment">// 初始值，还没感兴趣的 Goroutine</span></span><br><span class="line">pd.rd = <span class="number">0</span></span><br><span class="line">pd.wseq++</span><br><span class="line">pd.wg.Store(pdNil)<span class="comment">// 初始化，还没感兴趣的 Goroutine</span></span><br><span class="line">pd.wd = <span class="number">0</span></span><br><span class="line">pd.self = pd</span><br><span class="line">pd.publishInfo()</span><br><span class="line">  <span class="comment">// 4. 解锁</span></span><br><span class="line">unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 调用 netpollopen  -&gt; epoll_ctl</span></span><br><span class="line">  <span class="comment">// 将 pd 关联的 fd 的相关事件注册到 epoll 上</span></span><br><span class="line">errno := netpollopen(fd, pd)</span><br><span class="line"><span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">pollcache.free(pd)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="type">int</span>(errno)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pd, <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断是否就绪-poll_runtime_pollwait">2.3.3 判断是否就绪poll_runtime_pollWait</h3><ol type="1"><li>协程要对 socket 进行 read 或者 write 的时候，底层就会调用poll_runtime_pollWait；</li><li>该方法循环调用 netpollblock()，直到 netpollblock() 返回 true，表明rg 或 wg 已经置为 pdReady 了，可以进行读或者写了。</li><li>netpollblock()：<ol type="1"><li>根据 mode，取出 rg 或者 wg，命名为 gpp；</li><li>如果 gpp 是 pdReady，直接返回 true，否则，置为 pdWait，返回false。</li></ol></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> wait(mode <span class="type">int</span>, isFile <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> pd.runtimeCtx == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;waiting for unsupported file type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">res := runtime_pollWait(pd.runtimeCtx, mode)</span><br><span class="line"><span class="keyword">return</span> convertErr(res, isFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime_pollWait</span><span class="params">(ctx <span class="type">uintptr</span>, mode <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 循环调用 netpollblock，直到 netpollblock 返回 true</span></span><br><span class="line">   <span class="comment">// 也就是 rg 或 wg 已经置为 pdReady 了，可以读 / 写了</span></span><br><span class="line">   <span class="keyword">for</span> !netpollblock(pd, <span class="type">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returns true if IO is ready, or false if timed out or closed</span></span><br><span class="line"><span class="comment">// waitio - wait only for completed IO, ignore errors</span></span><br><span class="line"><span class="comment">// Concurrent calls to netpollblock in the same mode are forbidden, as pollDesc</span></span><br><span class="line"><span class="comment">// can hold only a single waiting goroutine for each mode.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="type">int32</span>, waitio <span class="type">bool</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 根据 mode，看看是要读还是要写</span></span><br><span class="line">gpp := &amp;pd.rg</span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">&#x27;w&#x27;</span> &#123;</span><br><span class="line">gpp = &amp;pd.wg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 已经 pdReady 了，返回 true，完成</span></span><br><span class="line"><span class="keyword">if</span> gpp.CompareAndSwap(pdReady, pdNil) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 没有 pdReady，则先置为 pdWait，再往下走</span></span><br><span class="line"><span class="keyword">if</span> gpp.CompareAndSwap(pdNil, pdWait) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 调用 gopark 阻塞当前 goroutine</span></span><br><span class="line"><span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == pollNoError &#123;</span><br><span class="line">gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceBlockNet, <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 当 gopark 返回时，表示被唤醒，重置为 pdNil</span></span><br><span class="line">old := gpp.Swap(pdNil)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. 如果是 pdReady，则返回 true，否则可能是超时等原因，返回 false</span></span><br><span class="line"><span class="keyword">return</span> old == pdReady</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblockcommit</span><span class="params">(gp *g, gpp unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">r := atomic.Casuintptr((*<span class="type">uintptr</span>)(gpp), pdWait, <span class="type">uintptr</span>(unsafe.Pointer(gp)))</span><br><span class="line"><span class="keyword">if</span> r &#123;</span><br><span class="line"><span class="comment">// Bump the count of goroutines waiting for the poller.</span></span><br><span class="line"><span class="comment">// The scheduler uses this to decide whether to block</span></span><br><span class="line"><span class="comment">// waiting for the poller if there is nothing else to do.</span></span><br><span class="line">netpollAdjustWaiters(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调度协程去读写-socket">2.3.4 调度协程去读写 socket</h3><ul><li><p>socket 已经可以读写：</p><ol type="1"><li><p><font color="red">runtime</font> 循环调用 netpoll() 方法；</p><blockquote><p>前面分析过了，是 g0 协程在 gc 的时候顺便调用了 netpoll。</p></blockquote></li><li><p>发现 socket 可读写时，给对应的 rg 或 wg 置为pdReady(1)；</p></li><li><p><font color="red">协程</font>调用 poll_runtime_pollWait() 判断socket 是否就绪；判断 rg 或者 wg 已经置为<strong>pdReady(1)</strong>，那就返回 0；</p></li><li><p>runtime 就知道 socket 可以操作了。</p></li></ol></li><li><p>socket 暂时不可读写：</p><ol type="1"><li><font color="red">runtime</font> 循环调用 netpoll() 方法；</li><li>netpoll 中没有监听到任何事件，执行不到 netpollready，没有对 pd做任何改变；</li><li><font color="red">协程</font>调用 poll_runtime_pollWait() 判断socket 是否就绪：<ol type="1"><li>判断 rg 或 wg 还是 <strong>pdNil(0)</strong>，就将 rg 或者 wg 置为<strong>pdWait(2)</strong>；</li><li>调用 gopark 将协程进行休眠等待；</li><li>然后再进入 netpollblockcommit 将 rg 或者 wg 置为 <strong>Gpointer</strong>；</li></ol></li><li>假如 runtime 后面再循环调用 netpoll() 方法；</li><li>发现 socket 可读写时，进入 netpollready 再检查对应的 rg 或者wg；</li><li>netpollready 再进入 netpollunblock，它会检查 rg 或者 wg；</li><li>若为 <strong>G pointer</strong>，那么就将 rg 或者 wg 置为<strong>pdReady</strong>，然后返回协程地址给 runtime；</li><li>runtime 就会去调度对应协程进行 socket 的读写操作。</li></ol></li><li><p>读写后都会再将 rg 或者 wg 置为 <strong>nil</strong></p></li></ul><h3 id="总结-1">2.3.5 总结</h3><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5laualr25j21im0u079y.jpg" /></p><p>Go 的网络操作底层为 <strong>阻塞模型（协程调度） +多路复用（系统底层）</strong>，具体情况为：</p><ul><li>BIO：go协程从网络读取数据，读取失败并且返回<code>syscall.EAGAIN</code>时，依次调用<code>waitRead-&gt;runtime_pollWait-&gt;poll_runtime_pollWait-&gt;netpollblock-&gt;gopark</code>将当前协程挂起。</li><li>NIO：runtime 的 g0 协程在 gc 的时候会顺便调用 <code>netpoll()</code>检查 socket 事件是否发生，当 socket可操作的时候，重新唤醒对应协程，进行调度。</li></ul><p>具体细节为：</p><ul><li>runtime<ol type="1"><li>runtime 会一直循环去检查 socket 的可读写状态 ——<code>netpoll()</code></li><li>然后再看是否有协程在等待对应的 socket：——<code>netpollready()</code><ol type="1"><li>没有，那就单纯记录 pollDesc；</li><li>有那就唤醒协程，将 g 加入 toRun 列表，进行调度 ——<code>netpollunblock()</code></li></ol></li></ol></li><li>goroutine<ol type="1"><li>表明想要操作 socket ——<code>poll_runtime_pollWait(pd,mode)</code></li><li>循环检查自己关心的 socket 是否可操作 —— <code>netpollblock()</code><ol type="1"><li>可以操作，goroutine 就会对 socket 进行读或写操作了；</li><li>不可操作：<ol type="1"><li>就将自己休眠 —— <code>gopark()</code>；</li><li>将 rg 或 wg 置为自己的地址 —— <code>netpollblockcommit()</code></li></ol></li></ol></li></ol></li></ul><h2 id="net-包">2.4 net 包</h2><ul><li><p>net 包是 go 原生的网络包；</p></li><li><p>net 包实现了 TCP、UDP、HTTP 等网络操作；</p></li><li><p>使用 <code>net.Listen()</code> 可以得到 <code>LISTEN</code>状态的 socket —— listener；</p></li><li><p>使用 <code>listener.Accept()</code> 可以得到<code>ESTABLISHED</code> 状态的 socket —— conn；</p></li><li><p><code>conn.Read() / Writer()</code> 可以进行读写 socket的操作；</p></li><li><p>network poll 作为上述功能的底层支撑；</p><blockquote><p>本文仅介绍 TCP 相关的部分。</p></blockquote></li></ul><h3 id="net.netfd">2.4.1 net.netFD</h3><p><code>netFD</code> 是 Go 中 net 包对 socket之类的网络文件描述符的抽象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> netFD <span class="keyword">struct</span> &#123;</span><br><span class="line">pfd poll.FD</span><br><span class="line"></span><br><span class="line"><span class="comment">// immutable until Close</span></span><br><span class="line">family      <span class="type">int</span></span><br><span class="line">sotype      <span class="type">int</span></span><br><span class="line">isConnected <span class="type">bool</span> <span class="comment">// handshake completed or use of association with peer</span></span><br><span class="line">net         <span class="type">string</span></span><br><span class="line">laddr       Addr</span><br><span class="line">raddr       Addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5ldvdxiy6j21h80i6759.jpg" /></p><h3 id="net.listen-listenter">2.4.2 net.Listen() Listenter</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, address <span class="type">string</span>)</span></span> (Listener, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> lc ListenConfig</span><br><span class="line"><span class="keyword">return</span> lc.Listen(context.Background(), network, address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>新建 socket，并执行 bind 操作；</li><li>新建一个 netFD，它是 net 包对 socket 的详情描述；</li><li>返回一个 TCPListener 对象，底层是调用了 runtime_pollOpen 方法，将TCPListener 的 FD 信息加入监听。TCPListener 对象本质是一个<strong>LISTEN</strong> 状态的 socket。</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5leaayjlcj20u010zn0e.jpg" style="zoom:50%;" /></p><h3 id="listener.accept">2.4.3 listener.Accept()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accept implements the Accept method in the [Listener] interface; it</span></span><br><span class="line"><span class="comment">// waits for the next call and returns a generic [Conn].</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TCPListener)</span></span> Accept() (Conn, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> !l.ok() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, syscall.EINVAL</span><br><span class="line">&#125;</span><br><span class="line">c, err := l.accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">&quot;accept&quot;</span>, Net: l.fd.net, Source: <span class="literal">nil</span>, Addr: l.fd.laddr, Err: err&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>调用 tcpListener 的 accept，本质上就是调用处于 LISTEN 状态的 socket的 accept 方法，看看有无新的连接；</li><li>如果失败，休眠等待新的连接，底层调用了 runtime_pollWait；</li><li>如果有新的连接，那就包装成一个新的 socket，最后返回为一个 TCPConn变量，底层是调用了 runtime_pollOpen 方法，将 TCPConn 的 FD信息加入监听。TCPConn 对象本质是一个 <strong>ESTABLISHED</strong> 状态的socket。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5lf3th4jjj21cz0u0gpf.jpg" /></p><h3 id="conn.read-conn.write">2.4.4 conn.Read() / conn.Write()</h3><p>这两个方法原理差不多，下面以 Read() 为例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read implements the Conn Read method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> Read(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">   n, err := c.fd.Read(b)</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read implements io.Reader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 循环读数据</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   <span class="comment">// 1. 调用系统命令 syscall.Read，读取 sysfd 上的数据，然后往 p 写数据</span></span><br><span class="line">n, err := ignoringEINTRIO(syscall.Read, fd.Sysfd, p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 2. syscall.EAGAIN 说明还没数据，得先等等</span></span><br><span class="line"><span class="keyword">if</span> err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() &#123;</span><br><span class="line">        <span class="comment">// 3. 挂起，休眠等待</span></span><br><span class="line"><span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="comment">// 4. 当有数据来的时候，会被唤醒走到这里，然后在回到 for 循环读取数据</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">err = fd.eofError(n, err)</span><br><span class="line"><span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>底层直接调用 socket原生读写方法（syscall.Read、syscall.Write）；</li><li>成功则直接返回；</li><li>如果失败，休眠等待可读 / 可写事件的发生；</li><li>被唤醒后重新调用系统 socket 进行读写；</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5lfqryruej21ir0u0n3b.jpg" /></p><h3 id="net.dialtcp">2.4.5 net.DialTCP()</h3><p><code>Dial()</code> 方法支持 TCP、UDP、IP、unix、unixgram 和unixpacket 网络通讯方式，它是一个统共的方法，通过传入<code>network</code>字段来区分不同的网络类型，所以它前面很多的操作，都是在判断当前是什么网络类型。本文主要讲TCP 的实现底层，故直接进入 <code>DialTCP()</code>即可，其他的网络类型，也是大同小异的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialTCP</span><span class="params">(network <span class="type">string</span>, laddr, raddr *TCPAddr)</span></span> (*TCPConn, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 看看具体是哪种 tcp 连接</span></span><br><span class="line"><span class="keyword">switch</span> network &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;tcp4&quot;</span>, <span class="string">&quot;tcp6&quot;</span>:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">&quot;dial&quot;</span>, Net: network, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: UnknownNetworkError(network)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> raddr == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">&quot;dial&quot;</span>, Net: network, Source: laddr.opAddr(), Addr: <span class="literal">nil</span>, Err: errMissingAddress&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 创建一个系统的网络连接工具</span></span><br><span class="line">sd := &amp;sysDialer&#123;network: network, address: raddr.String()&#125;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">c   *TCPConn</span><br><span class="line">err <span class="type">error</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 进行 TCP 连接</span></span><br><span class="line"><span class="keyword">if</span> sd.MultipathTCP() &#123;</span><br><span class="line">c, err = sd.dialMPTCP(context.Background(), laddr, raddr)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c, err = sd.dialTCP(context.Background(), laddr, raddr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">&quot;dial&quot;</span>, Net: network, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: err&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sd *sysDialer)</span></span> dialTCP(ctx context.Context, laddr, raddr *TCPAddr) (*TCPConn, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> h := sd.testHookDialTCP; h != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h(ctx, sd.network, laddr, raddr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h := testHookDialTCP; h != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h(ctx, sd.network, laddr, raddr)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 4. 进入 doDialTCP</span></span><br><span class="line"><span class="keyword">return</span> sd.doDialTCP(ctx, laddr, raddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sd *sysDialer)</span></span> doDialTCP(ctx context.Context, laddr, raddr *TCPAddr) (*TCPConn, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> sd.doDialTCPProto(ctx, laddr, raddr, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sd *sysDialer)</span></span> doDialTCPProto(ctx context.Context, laddr, raddr *TCPAddr, proto <span class="type">int</span>) (*TCPConn, <span class="type">error</span>) &#123;</span><br><span class="line">ctrlCtxFn := sd.Dialer.ControlContext</span><br><span class="line"><span class="keyword">if</span> ctrlCtxFn == <span class="literal">nil</span> &amp;&amp; sd.Dialer.Control != <span class="literal">nil</span> &#123;</span><br><span class="line">ctrlCtxFn = <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, address <span class="type">string</span>, c syscall.RawConn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sd.Dialer.Control(network, address, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 5. 有了前面的基础，到这就明白了</span></span><br><span class="line"> <span class="comment">// internetSocket 创建一个 fd，生成一个新的 socket，并注册到 epoll 中监听</span></span><br><span class="line">fd, err := internetSocket(ctx, sd.network, laddr, raddr, syscall.SOCK_STREAM, proto, <span class="string">&quot;dial&quot;</span>, ctrlCtxFn)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; (laddr == <span class="literal">nil</span> || laddr.Port == <span class="number">0</span>) &amp;&amp; (selfConnect(fd, err) || spuriousENOTAVAIL(err)); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line">&#125;</span><br><span class="line">fd, err = internetSocket(ctx, sd.network, laddr, raddr, syscall.SOCK_STREAM, proto, <span class="string">&quot;dial&quot;</span>, ctrlCtxFn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 6. 返回一个 TCPConn</span></span><br><span class="line"><span class="keyword">return</span> newTCPConn(fd, sd.Dialer.KeepAlive, sd.Dialer.KeepAliveConfig, testPreHookSetKeepAlive, testHookSetKeepAlive), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>创建一个系统的网络连接工具 sysDialer；</li><li>dial 进行 TCP 连接，连接不上那就是 connect refused；</li><li>连接上的话，创建一个新的 socket，并最后返回为一个 TCPConn变量，底层是调用了 runtime_pollOpen 方法，将 TCPConn 的 FD信息加入监听。TCPConn 对象本质是一个 <strong>ESTABLISHED</strong> 状态的socket。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5lgqvxxivj21nd0u0q67.jpg" /></p><h1 id="总结-2">3. 总结</h1><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5lh6uxgk3j21770u0773.jpg" /></p>]]></content>
    
    
    <summary type="html">本文立足于 Go 1.25 版本源码，系统拆解 Go 网络编程模型的底层机制，解析 Goroutine 如何实现同步代码，异步执行、net 包的核心实现，以及 I/O 多路复用背后的第一性原理，带你从源码视角理解 Go 网络高并发的秘密。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="epoll" scheme="https://hedon.top/tags/epoll/"/>
    
    <category term="网络编程" scheme="https://hedon.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go 底层原理丨channel</title>
    <link href="https://hedon.top/2025/11/22/go/go-channel/"/>
    <id>https://hedon.top/2025/11/22/go/go-channel/</id>
    <published>2025-11-22T02:30:00.000Z</published>
    <updated>2025-12-17T11:07:53.198Z</updated>
    
    <content type="html"><![CDATA[<p>继上篇 <a href="https://hedon.top/2025/11/21/go/go-lock/">Go底层原理丨锁</a>，本篇将进入 Go语言中关于通道（channel）底层原理的探讨。在 Rust 中，笔者参考 Mara Bos的 <a href="https://marabos.nl/atomics/">《Rust Atomics and Locks》</a>实现了一个 oneshot channel，感兴趣的读者也可以参阅 <ahref="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust实战丨手写一个 oneshot channel</a>。</p><p>特此声明，本篇是笔者基于 Go 1.25.3 版本源码、并与 Google Gemini 3Pro共创所作，非常庆幸在当今 AI时代下获取知识已是如此便利，且也为学习者从第一性原理理解所学知识大大降低了门槛。不过本篇的篇章安排和叙述逻辑，均由笔者把控和审阅，欢迎放心阅读。</p><h1 id="结论先行">结论先行</h1><p>channel 底层是 <code>hchan</code> 结构体，包含了：</p><ul><li>一个环形缓存队列；</li><li>接受者队列、发送者队列；</li><li>锁；</li><li>关闭标志；</li></ul><p>发送：<code>chansend()</code></p><ul><li>直接发送给阻塞中的接受者</li><li>塞入缓存</li><li>休眠等待</li></ul><p>接收：<code>chanrecv()</code></p><ul><li>直接接收阻塞中的发送者的数据</li><li>从缓存拿</li><li>休眠等待</li></ul><h1 id="数据结构-hchan">1. 数据结构 hchan</h1><p>channel 的底层数据结构 <code>hchan</code> 源码位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/chan.go#L34">runtime/chan.go#L34</a>，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">elemsize <span class="type">uint16</span></span><br><span class="line">closed   <span class="type">uint32</span></span><br><span class="line">timer    *timer <span class="comment">// timer feeding this chan</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">bubble   *synctestBubble</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中以下五个字段组成了一个 <strong>环形缓冲队列</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qcount   <span class="type">uint</span>           <span class="comment">// 当前在队列中的数据个数</span></span><br><span class="line">dataqsiz <span class="type">uint</span>           <span class="comment">// 环形队列大小</span></span><br><span class="line">buf      unsafe.Pointer<span class="comment">// 指向环形队列的指针</span></span><br><span class="line">elemsize <span class="type">uint16</span><span class="comment">// 每个数据大小</span></span><br><span class="line">elemtype *_type <span class="comment">// 数据类型</span></span><br></pre></td></tr></table></figure><blockquote><p>环形缓存可以大幅降低 GC 的开销。</p></blockquote><p>其中还有四个字段组成了两个 <strong>链表</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// 下次要发送的数据的 index</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// 下个要接收的数据的 index</span></span><br><span class="line">recvq    waitq  <span class="comment">// 接受者等待队列</span></span><br><span class="line">sendq    waitq  <span class="comment">// 发送者等待队列</span></span><br></pre></td></tr></table></figure><p>还有一个 <strong>锁</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock mutex<span class="comment">// 保存 hchan 中的所有字段</span></span><br></pre></td></tr></table></figure><blockquote><p>互斥锁并不是排队发送 / 接收数据，它保护的是 hchan 结构体本身。</p></blockquote><p>还有一个标记：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closed   <span class="type">uint32</span>   <span class="comment">// 标记 channel 是否已经关闭</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5fztbxrzej21ka0u0q62.jpg" /></p><h1 id="创建-makechan">2. 创建 makechan</h1><p>创建 channel 的逻辑位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/chan.go#L75">runtime/chan.go#L75</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makechan 创建一个新的 channel</span></span><br><span class="line"><span class="comment">// t: channel 的类型信息（包含元素类型）</span></span><br><span class="line"><span class="comment">// size: channel 的缓冲区大小（0 表示无缓冲）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">elem := t.Elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// === GC 优化说明 ===</span></span><br><span class="line"><span class="comment">// 当 buf 中的元素不包含指针时，hchan 对 GC 来说不包含需要追踪的指针</span></span><br><span class="line"><span class="comment">// - buf 指针指向同一次分配的内存（或单独分配的不含指针的内存）</span></span><br><span class="line"><span class="comment">// - elemtype 是持久化的类型元数据</span></span><br><span class="line"><span class="comment">// - sudog 由其所属线程引用，不会被回收</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 当 GC 支持移动对象时需要重新考虑这个设计</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// === 三种分配策略 ===</span></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// 策略1: 无缓冲 channel 或元素大小为 0</span></span><br><span class="line"><span class="comment">// 只需分配 hchan 结构体本身，不需要缓冲区</span></span><br><span class="line"><span class="comment">// 示例：make(chan int, 0) 或 make(chan struct&#123;&#125;, 10)</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Race detector 使用这个地址作为同步点</span></span><br><span class="line"><span class="comment">// 即使没有实际的 buf，也需要一个地址用于竞态检测</span></span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> !elem.Pointers():</span><br><span class="line"><span class="comment">// 策略2: 元素不包含指针（如 int, float, struct&#123;int,int&#125; 等）</span></span><br><span class="line"><span class="comment">// GC 优化：hchan 和 buf 在一次分配中完成，减少 GC 扫描开销</span></span><br><span class="line"><span class="comment">// 内存布局：[hchan 结构][buf 数组]</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// buf 指向紧跟在 hchan 后面的内存</span></span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 策略3: 元素包含指针（如 *int, string, slice, map 等）</span></span><br><span class="line"><span class="comment">// 必须分开分配，让 GC 能够正确追踪 buf 中的指针</span></span><br><span class="line"><span class="comment">// new(hchan) 会将 hchan 分配在 GC 扫描的内存区域</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line"><span class="comment">// mallocgc 的第二个参数传入 elem 类型，让 GC 知道如何扫描这块内存</span></span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// === 初始化 hchan 字段 ===</span></span><br><span class="line"></span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.Size_)    <span class="comment">// 元素大小（已检查不超过 uint16）</span></span><br><span class="line">c.elemtype = elem                   <span class="comment">// 元素类型信息（用于类型安全的内存操作）</span></span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size)            <span class="comment">// 循环队列容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前 goroutine 在 synctest bubble 中，关联到 channel</span></span><br><span class="line"><span class="comment">// synctest 是用于确定性测试的机制</span></span><br><span class="line"><span class="keyword">if</span> b := getg().bubble; b != <span class="literal">nil</span> &#123;</span><br><span class="line">c.bubble = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁，指定锁的等级（用于死锁检测）</span></span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>策略 1：无缓冲/零大小元素</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br></pre></td></tr></table></figure><ul><li><p>无缓冲 channel：size = 0，数据直接在 goroutine 间传递</p></li><li><p>零大小元素：struct{}，不需要实际存储空间</p></li></ul><p><strong>策略 2：元素不含指针</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> !elem.Pointers():</span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">    c.buf = add(unsafe.Pointer(c), hchanSize)</span><br></pre></td></tr></table></figure><ul><li><p>一次分配：减少内存碎片，提高缓存局部性</p></li><li><p>GC 优化：整块内存标记为"无指针"，GC 扫描时可以跳过</p></li><li><p>内存布局：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低地址 → 高地址</span><br><span class="line">[hchan 结构体][buf[0]][buf[1]]...[buf[n-1]]</span><br></pre></td></tr></table></figure></li></ul><p><strong>策略 3：元素含指针</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    c = <span class="built_in">new</span>(hchan)</span><br><span class="line">    c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><ul><li><p>mallocgc 的第二个参数 elem 告诉 GC 这块内存的类型</p></li><li><p>GC 需要递归扫描 buf 中的每个元素，查找其中的指针</p></li><li><p>如果用策略 2，GC 无法正确追踪 buf中的指针，导致对象被错误回收</p></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Value <span class="type">int</span></span><br><span class="line">    Next  *Node  <span class="comment">// 指针！</span></span><br><span class="line">&#125;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> *Node, <span class="number">10</span>)  <span class="comment">// 使用策略 3</span></span><br></pre></td></tr></table></figure><h1 id="发送-chansend">3. 发送 chansend</h1><ol type="1"><li>对整个 channel 上锁；</li><li>检查 channel 是否已经关闭，若关闭，这 panic；</li><li>检查是否有正在等待中的协程：<ol type="1"><li>有的话，直接将数据拷贝给它，然后唤醒它；</li><li>没有，则检查缓存队列是否已满：<ol type="1"><li>没有满，则将数据塞入缓存队列中；</li><li>已满，则把自己包装成 sudog 放入 sendq队列，休眠并解锁，等待唤醒。被唤醒后数据已经被取走了，当下 sudog负责维护其他的数据；</li></ol></li></ol></li><li>解锁。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="comment">// 快速路径：在非阻塞情况（select）下，如果 channel 已经满了，快速返回</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 上锁修改队列</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 不允许往已关闭的 channel 发送数据</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 检查是否有阻塞中的接收者，如果有，取出一个，直接将数据交付给它</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 没有接受者，且缓冲区还有位置，则数据进入缓冲区，直接返回</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">c.sendx++</span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount++</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 非阻塞，返回 false</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. 没有接受者，缓冲区也没有位置，且是阻塞队列，则当前协程入队休眠，等待接受者唤醒</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.sendq.enqueue(mysg) <span class="comment">// 入队</span></span><br><span class="line">gp.parkingOnChan.Store(<span class="literal">true</span>)</span><br><span class="line">reason := waitReasonChanSend</span><br><span class="line"><span class="keyword">if</span> c.bubble != <span class="literal">nil</span> &#123;</span><br><span class="line">reason = waitReasonSynctestChanSend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7. 陷入阻塞，等待唤醒</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), reason, traceBlockChanSend, <span class="number">2</span>)</span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 被唤醒了</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">closed := !mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9. 被唤醒的时候，数据其实已经被取走了，mysg 负责维护其他数据</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">if</span> closed &#123;</span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接收-chanrecv">4. 接收 chanrecv</h1><ol type="1"><li>对整个 channel 上锁；</li><li>如果 channel 已经关闭，且缓存中没有数据，如果这个时候 eq指向的地址有数据，则清空数据；</li><li>检查是否有等待中的 sender：<ol type="1"><li>有，则看 channel 有无缓存：<ol type="1"><li>没有，则直接从 sender 中取走数据，唤醒 sender；</li><li>有，则说明缓存已满，从缓存队列队头取走数据，然后将 sender数据塞到队尾，唤醒 sender；</li></ol></li><li>无，则看 channel 有无缓存：<ol type="1"><li>有，则直接从缓存中取走数据，维护队列索引，解锁返回；</li><li>无，则将自己包装成 sudog，放入 recvq休眠等待唤醒，被唤醒的时候，sender 已经将数据拷贝到位了；</li></ol></li></ol></li><li>解锁。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// 快速路径：非阻塞（select）且队列为空，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> empty(c) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 对整个 channel 上锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 检查 channel 是否已经被关闭，且缓存中没有数据</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 缓冲区没有数据，返回 false</span></span><br><span class="line"><span class="keyword">if</span> c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 清除 ep 指向的数据</span></span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3. 如果没有关闭，且有阻塞中的发送者，则直接接收发送者的数据，然后唤醒它</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 没有等待中的 sender，且缓存中有数据，则时间从缓存队列中取出数据，并解锁返回</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racenotify(c, c.recvx, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount--</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 非阻塞情况下，没有获取到数据，则返回 false</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 缓存中没有数据，则将自己包装成 sudog，放入 recvq 队列中，休眠等待唤醒</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line"></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line"><span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">blockTimerChan(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gp.parkingOnChan.Store(<span class="literal">true</span>)</span><br><span class="line">reason := waitReasonChanReceive</span><br><span class="line"><span class="keyword">if</span> c.bubble != <span class="literal">nil</span> &#123;</span><br><span class="line">reason = waitReasonSynctestChanReceive</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 6. 被唤醒，唤醒的时候，sender 已经将数据拷贝到 receiver 的 ep 所指向的位置了（也就是 chansend 的第 3 步）</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), reason, traceBlockChanRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被唤醒，这个时候，数据已经接收到了</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">unblockTimerChan(c)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">success := mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关闭-closechan">5. 关闭 closechan</h1><ol type="1"><li>设置 c.closed = 1</li><li>唤醒所有接收者（返回零值，success = false）</li><li>唤醒所有发送者（会 panic）</li><li>释放锁后再调用 goready，避免持锁调度</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1. 不能关闭 nil channel</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.bubble != <span class="literal">nil</span> &amp;&amp; getg().bubble != c.bubble &#123;</span><br><span class="line">fatal(<span class="string">&quot;close of synctest channel from outside bubble&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 上锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 不能重复关闭 channel</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 设置关闭标识</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 唤醒所有接收者（返回零值，success = false）</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 唤醒所有发送者（会 panic）</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 释放锁后再调用 goready，避免持锁调度</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实践建议">6. 实践建议</h1><p>通过上述对 channel 各种操作的源码分析，我们可以发现存在一些容易 panic的点：</p><ul><li>往未初始化的 channel 发送数据，会 panic</li><li>重复关闭 channel，会 panic</li><li>往关闭的 channel 发送数据，会 panic</li></ul><p>这里笔者总结了一些实践建议，供参考。</p><p>基于 <code>go-channel.md</code> 中解析的底层原理，Go channel 的 panic风险主要源于对 <code>hchan</code> 状态的错误操作（特别是<code>closed</code> 状态）。</p><p>以下是基于第一性原理（源码逻辑）总结的 channel 使用最佳实践：</p><h2 id="核心原则谁发送谁关闭">6.1 核心原则：谁发送，谁关闭</h2><p>这是避免 panic 的第一铁律。</p><ul><li><strong>原理</strong>：源码中 <code>chansend</code> 会在检测到<code>c.closed != 0</code> 时直接 panic。同时，<code>closechan</code>唤醒被阻塞的发送者时，发送者被唤醒后检测到 channel 已关闭也会panic。</li><li><strong>建议</strong>：只有<strong>发送端</strong>（Sender）才有资格关闭channel。<ul><li>如果 channel是由接收端（Receiver）关闭的，发送端无法感知，一旦再次发送就会panic。</li><li><strong>如果有多个发送端</strong>：不要在发送端关闭channel。应该使用一个额外的信号 channel（stop channel）或者是<code>sync.WaitGroup</code> 来协调，或者让 channel 由 GC自动回收（如果没有 goroutine 引用它）。</li></ul></li></ul><h2 id="严禁重复关闭">6.2 严禁重复关闭</h2><ul><li><strong>原理</strong>：<code>closechan</code> 函数开头就会检查<code>c.closed</code>，如果不为 0，会直接 panic "close of closedchannel"。</li><li><strong>建议</strong>：<ul><li>确保代码逻辑中 <code>close()</code> 只被执行一次。</li><li>在复杂的多并发场景下，如果无法确定谁是最后一个关闭者，可以使用<code>sync.Once</code> 来封装关闭操作，确保幂等性。</li></ul></li></ul><h2 id="接收端使用-comma-ok-句式">6.3 接收端使用 "comma, ok" 句式</h2><ul><li><strong>原理</strong>：<code>chanrecv</code> 在 channel已关闭且缓存无数据时，会返回对应类型的零值，并且返回的<code>success</code> (即 ok) 为 <code>false</code>。</li><li><strong>建议</strong>：<ul><li>总是检查接收操作的第二个返回值：<code>val, ok := &lt;-ch</code>。</li><li>如果 <code>!ok</code>，说明 channel已关闭且已读完，应当退出接收循环，而不是继续处理零值。</li></ul></li></ul><h2 id="避免关闭-nil-channel">6.4 避免关闭 nil channel</h2><ul><li><strong>原理</strong>：<code>closechan</code> 第一步检查<code>if c == nil</code>，如果是则 panic "close of nil channel"。</li><li><strong>建议</strong>：<ul><li>在使用 channel 前确保它已被 <code>make</code> 初始化。</li><li>小心处理结构体中的 channel 字段，确保它们不是默认的 nil 值。</li></ul></li></ul><h2 id="优雅退出模式signal-channel">6.5 优雅退出模式（SignalChannel）</h2><p>当有多个发送者（N Senders）或 1个接收者想停止多个发送者时，不要直接关闭数据 channel。</p><ul><li><strong>原理</strong>：直接关闭会导致正在运行的发送者 panic。</li><li><strong>建议</strong>：<ul><li>创建一个专门的 <code>done</code> 或 <code>stop</code>channel（通常是 <code>chan struct&#123;&#125;</code>）。</li><li>接收者通过 <code>close(done)</code> 进行广播（利用了“从已关闭channel 接收会立即返回零值”的特性）。</li><li>发送者在 <code>select</code> 中同时监听 <code>dataCh</code> 和<code>done</code>，一旦 <code>done</code> 关闭，立即停止发送。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本文将以 Go 1.25 版本源码为基础，系统剖析 Go channel 的底层实现，包括 hchan 数据结构、缓存队列、发送接收机制与阻塞唤醒原理，帮助读者以第一性原理深入理解 Go 并发通信的内核。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="channel" scheme="https://hedon.top/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go 底层原理丨锁</title>
    <link href="https://hedon.top/2025/11/21/go/go-lock/"/>
    <id>https://hedon.top/2025/11/21/go/go-lock/</id>
    <published>2025-11-21T07:30:00.000Z</published>
    <updated>2025-12-16T02:41:09.197Z</updated>
    
    <content type="html"><![CDATA[<p>本篇将进入 Go 语言中关于锁的底层原理的探讨，笔者有幸阅读过 Mara Bos的 <a href="https://marabos.nl/atomics/">《Rust Atomics andLocks》</a>，该书对锁这一概念和底层原理进行了非常详尽的探讨，并且给出了Rust 中 SpinLock、Mutex、RWMutex、Channel 和 Arc等基础并发工具的手写实战案例，对于想更加深入理解并发编程尤其那些想手写并发工具的读者，非常推荐阅读该书。</p><p>特此声明，本篇是笔者基于 Go 1.25.3 版本源码、并与 Google Gemini 3Pro共创所作，非常庆幸在当今 AI时代下获取知识已是如此便利，且也为学习者从第一性原理理解所学知识大大降低了门槛。不过本篇的篇章安排和叙述逻辑，均由笔者把控和审阅，欢迎放心阅读。</p><h1 id="结论先行">结论先行</h1><p>本篇我们将探讨 Go 语言中的各种"锁"的底层实现原理，包括<code>Mutex</code>、<code>RWMutex</code>、<code>WaitGroup</code> 和<code>Once</code> 。它们都离不开两个核心基础：<code>atomic</code> 和<code>sema</code>：</p><ul><li><code>atomic</code>即原子变量，是一种硬件层面加锁的机制，可以保证基本类型在高并发下的并发安全性，实现原子操作。</li><li><code>sema</code> 全称 semaphore，也叫信号锁 /信号量锁，它的核心是一个 <code>uint32</code>类型的值，含义是同时可并发的协程数量。在 Go 语言里面，每个<code>seam</code> 背后都对应一个 <code>semaRoot</code>结构体。</li></ul><p>我们先给出上述几种并发工具的简要概述，后文再进行详细阐述：</p><ul><li><code>Mutex</code>：互斥锁，只能有一个持有者。<ul><li>正常模式：得到锁返回，得不到锁自旋，自旋多了就饥饿。</li><li>饥饿模式：不自选，直接入队等待。依次从队里唤醒协程并授予锁。</li></ul></li><li><code>RWMutex</code>：读写锁，只能一个写，可以同时多个读。</li><li><code>WaitGroup</code>：一组协程等待另外一组协程全部执行完毕再执行。</li><li><code>Once</code>：控制一段代码在并发中只执行一次。</li><li><code>Cond</code>：条件变量，允许多个 Goroutine等待某个条件成立后被唤醒，常用于处理生产者-消费者模型。</li></ul><h1 id="go-锁的两大基础">1. Go 锁的两大基础</h1><h2 id="原子操作">1.1 原子操作</h2><p>Go 在 <code>sync/atomic</code>包提供了一系列基本类型的原子操作，使用这些操作，可以保证基本类型在高并发下的并发安全性，实现原子操作。</p><ul><li>SwapInt32</li><li>CompareAndSwapInt32</li><li>AddInt32</li><li>LoadInt32</li><li>StoreInt32</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddInt32 atomically adds delta to *addr and returns the new value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>)</span><br></pre></td></tr></table></figure><p>查看 AMD64 的汇编时，我们会发现其中有一个 <code>LOCK</code>指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// uint32 Xadd(uint32 volatile *val, int32 delta)</span><br><span class="line">// Atomically:</span><br><span class="line">//*val += delta;</span><br><span class="line">//return *val;</span><br><span class="line">TEXT ·Xadd(SB), NOSPLIT, $0-20</span><br><span class="line">MOVQptr+0(FP), BX</span><br><span class="line">MOVLdelta+8(FP), AX</span><br><span class="line">MOVLAX, CX</span><br><span class="line">LOCK</span><br><span class="line">XADDLAX, 0(BX)</span><br><span class="line">ADDLCX, AX</span><br><span class="line">MOVLAX, ret+16(FP)</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>可以再看一下 ARM64的汇编代码，我们会发现其中有：<code>LDADDALW</code>、<code>LDAXRW</code>和 <code>STLXRW</code> 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TEXT ·Xadd(SB), NOSPLIT, $0-20</span><br><span class="line">MOVDptr+0(FP), R0</span><br><span class="line">MOVWdelta+8(FP), R1</span><br><span class="line">#ifndef GOARM64_LSE</span><br><span class="line">MOVBUinternal∕cpu·ARM64+const_offsetARM64HasATOMICS(SB), R4</span><br><span class="line">CBZ R4, load_store_loop</span><br><span class="line">#endif</span><br><span class="line">LDADDALWR1, (R0), R2</span><br><span class="line">ADD R1, R2</span><br><span class="line">MOVWR2, ret+16(FP)</span><br><span class="line">RET</span><br><span class="line">#ifndef GOARM64_LSE</span><br><span class="line">load_store_loop:</span><br><span class="line">LDAXRW(R0), R2</span><br><span class="line">ADDWR2, R1, R2</span><br><span class="line">STLXRWR2, (R0), R3</span><br><span class="line">CBNZR3, load_store_loop</span><br><span class="line">MOVWR2, ret+16(FP)</span><br><span class="line">RET</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>概括来说：</p><blockquote><p>[!IMPORTANT]</p><p>原子操作的底层实现依赖于 86 的 <code>lock</code> 前缀或 ARM 的<code>LL/SC</code>，而这二者又依赖于硬件级别的协同机制，其核心是通过<strong>缓存一致性协议</strong>、<strong>总线仲裁</strong> 和<strong>指令集层面的特殊支持</strong>来保证多核环境下的原子性和内存顺序。</p></blockquote><p>对于原子操作的底层原理和硬件层面的细节，感兴趣的读者可以阅读我这两篇笔记：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><ahref="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust原理丨从汇编角度看原子操作</a></li></ul><h2 id="sema-锁">1.2 sema 锁</h2><h3 id="概述">1.2.1 概述</h3><ul><li>sema 锁全称 semaphore，也叫信号锁 / 信号量锁。</li><li>sema 的核心是一个 <code>uint32</code>类型的值，含义是同时可并发的协程数量。</li><li>每一个 sema 锁都对应一个 <code>semaRoot</code>结构体。</li><li><code>semaRoot</code> 中有一个平衡二叉树用于协程排队。</li></ul><h3 id="数据结构">1.2.2 数据结构</h3><p>在 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/sync/mutex.go#L20">internal/sync/mutex.go#L20</a>定义了 <code>Mutex</code> 的数据结构，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Mutex is a mutual exclusion lock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See package [sync.Mutex] documentation.</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="type">int32</span></span><br><span class="line">sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中第二个元素 <code>sema</code>，便是一个 sema 锁，它本质上是一个<code>semaRoot</code> 结构体的值。</p><p><code>semaRoot</code> 定义在 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/sema.go#L40">runtime/sema.go#L40</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Asynchronous semaphore for sync.Mutex.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A semaRoot holds a balanced tree of sudog with distinct addresses (s.elem).</span></span><br><span class="line"><span class="comment">// Each of those sudog may in turn point (through s.waitlink) to a list</span></span><br><span class="line"><span class="comment">// of other sudogs waiting on the same address.</span></span><br><span class="line"><span class="comment">// The operations on the inner lists of sudogs with the same address</span></span><br><span class="line"><span class="comment">// are all O(1). The scanning of the top-level semaRoot list is O(log n),</span></span><br><span class="line"><span class="comment">// where n is the number of distinct addresses with goroutines blocked</span></span><br><span class="line"><span class="comment">// on them that hash to the given semaRoot.</span></span><br><span class="line"><span class="comment">// See golang.org/issue/17953 for a program that worked badly</span></span><br><span class="line"><span class="comment">// before we introduced the second level of list, and</span></span><br><span class="line"><span class="comment">// BenchmarkSemTable/OneAddrCollision/* for a benchmark that exercises this.</span></span><br><span class="line"><span class="keyword">type</span> semaRoot <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock  mutex          <span class="comment">// 保护整个数据结构的锁</span></span><br><span class="line">    treap *sudog         <span class="comment">// Treap 的根节点</span></span><br><span class="line">    nwait atomic.Uint32  <span class="comment">// 等待者数量（可无锁读取，用于快速判断）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单理解：Runtime 内部专用锁</span></span><br><span class="line"><span class="comment">// 通过一个 uintptr 字段同时存储状态标志位和等待 M 线程的指针栈（低 10 位是状态，高位是 M 链表头），</span></span><br><span class="line"><span class="comment">// 直接用 OS 信号量阻塞 M 线程，禁用抢占，零分配，不触发 GC。</span></span><br><span class="line"><span class="keyword">type</span> mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">lockRankStruct</span><br><span class="line">key <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sudog (pseudo-g) 代表的是一个在等待队列中的 goroutine</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g                <span class="comment">// 指向等待的 goroutine</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === Treap 二叉树指针 ===</span></span><br><span class="line">    parent *sudog       <span class="comment">// 父节点</span></span><br><span class="line">    prev   *sudog       <span class="comment">// 左子节点</span></span><br><span class="line">    next   *sudog       <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 同地址等待链表 ===</span></span><br><span class="line">    waitlink *sudog     <span class="comment">// 链表中的下一个等待者</span></span><br><span class="line">    waittail *sudog     <span class="comment">// 链表尾部（只在头节点有效）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 地址和优先级 ===</span></span><br><span class="line">    elem   unsafe.Pointer  <span class="comment">// 等待的地址（如 &amp;mutex.sema）</span></span><br><span class="line">    ticket <span class="type">uint32</span>          <span class="comment">// Treap 的堆优先级（随机数）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 统计和性能分析 ===</span></span><br><span class="line">    waiters     <span class="type">uint16</span>  <span class="comment">// 链表中其他等待者的数量（头节点）</span></span><br><span class="line">    acquiretime <span class="type">int64</span>   <span class="comment">// 开始等待的时间</span></span><br><span class="line">    releasetime <span class="type">int64</span>   <span class="comment">// 被唤醒的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5d2yqk87zj21gc0mq3zt.jpg" style="zoom: 33%;" /></p><h3 id="操作">1.2.3 操作</h3><p><strong>当 unit32 &gt; 0 时，表示可以并发的协程个数</strong></p><ul><li>获取锁：sema - 1， 获得锁成功</li><li>释放锁：sema + 1，释放锁成功</li></ul><p><strong>当 unit32 = 0 时，表示没锁了，sema锁退化成一个专用的休眠队列</strong></p><ul><li>获取锁：进入堆树等待，协程休眠；</li><li>释放锁：从堆树中取出一个协程并唤醒</li></ul><h3 id="semeacquire">1.2.4 semeacquire()</h3><p><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/sema.go#L146">semaacuqire()</a>尝试递减计数器，失败则创建 <code>sudog</code>加入等待队列并休眠，等待被唤醒。</p><ul><li>sema &gt; 0：sema --</li><li>sema = 0：将协程放入堆树中等待，并休眠</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5dalgurqyj223d0u0whl.jpg" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semacquire1</span><span class="params">(addr *<span class="type">uint32</span>, lifo <span class="type">bool</span>, profile semaProfileFlags, skipframes <span class="type">int</span>, reason waitReason)</span></span> &#123;</span><br><span class="line">gp := getg()</span><br><span class="line"><span class="keyword">if</span> gp != gp.m.curg &#123;</span><br><span class="line">throw(<span class="string">&quot;semacquire not on the G stack&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快捷路径，先进行一次简单的原子操作尝试获取锁，成功则直接返回</span></span><br><span class="line"><span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 慢速路径：</span></span><br><span class="line"><span class="comment">// Harder case:</span></span><br><span class="line"><span class="comment">//increment waiter count</span></span><br><span class="line"><span class="comment">//try cansemacquire one more time, return if succeeded</span></span><br><span class="line"><span class="comment">//enqueue itself as a waiter</span></span><br><span class="line"><span class="comment">//sleep</span></span><br><span class="line"><span class="comment">//(waiter descriptor is dequeued by signaler)</span></span><br><span class="line">  <span class="comment">// 获取 sema 底层的 semaRoot，并为它赋初始值</span></span><br><span class="line">s := acquireSudog()</span><br><span class="line">root := semtable.rootFor(addr)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line"><span class="comment">// 1. 自增等待者数量</span></span><br><span class="line">root.nwait.Add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 2. 再次尝试获取锁，成功则可以返回了</span></span><br><span class="line"><span class="keyword">if</span> cansemacquire(addr) &#123;</span><br><span class="line">root.nwait.Add(<span class="number">-1</span>)</span><br><span class="line">unlock(&amp;root.lock)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 3. 还是失败，则进入休眠队列</span></span><br><span class="line">root.queue(addr, s, lifo)</span><br><span class="line">    <span class="comment">// 4. 调用 gopark() 休眠协程（不了解 gopark 可以先去了解一下 GMP 底层原理）</span></span><br><span class="line">goparkunlock(&amp;root.lock, reason, traceBlockSync, <span class="number">4</span>+skipframes)</span><br><span class="line"><span class="keyword">if</span> s.ticket != <span class="number">0</span> || cansemacquire(addr) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(s.releasetime-t0, <span class="number">3</span>+skipframes)</span><br><span class="line">&#125;</span><br><span class="line">releaseSudog(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否可以获取 sema 锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cansemacquire</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v := atomic.Load(addr)</span><br><span class="line">    <span class="comment">// sema 为 0，表示没锁了，这个时候是一个等待队列，无法直接获取锁</span></span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// sema 大于 0，说明这个时候有可以并发的协程个数，尝试进行 cas 获取锁，成功则返回 true</span></span><br><span class="line"><span class="keyword">if</span> atomic.Cas(addr, v, v<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="semarelease">1.2.5 semarelease()</h3><p><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/sema.go#L207">semarelease()</a>递增计数器，如果有等待者则从队列中取出一个 <code>sudog</code>并唤醒对应的 goroutine，<strong>handoff</strong> 模式下直接移交锁并让出CPU。</p><ul><li>无等待中的协程：直接返回</li><li>有等待中的协程：从堆树中出队一个协程，唤醒，并调度到当前 P 的 runq中</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5dapxzf8jj20u00uidh6.jpg" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semrelease1 释放一个信号量，如果有等待者则唤醒一个 goroutine</span></span><br><span class="line"><span class="comment">// addr: 信号量地址（如 &amp;mutex.sema）</span></span><br><span class="line"><span class="comment">// handoff: 是否直接移交（饥饿模式下为 true，直接把锁交给被唤醒者）</span></span><br><span class="line"><span class="comment">// skipframes: 用于性能分析时跳过的栈帧数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semrelease1</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 通过 addr 的哈希值找到对应的 semaRoot</span></span><br><span class="line">root := semtable.rootFor(addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 关键操作：先递增信号量计数器 =====</span></span><br><span class="line"><span class="comment">// 无论有没有等待者，都原子地将 *addr 加 1</span></span><br><span class="line"><span class="comment">// 这相当于传统信号量的 V 操作，释放一个&quot;资源&quot;</span></span><br><span class="line">atomic.Xadd(addr, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== Fast Path：快速检查是否有等待者 =====</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意顺序很重要！必须先执行 Xadd，再检查 nwait</span></span><br><span class="line"><span class="comment">// 原因：防止 &quot;错过唤醒&quot; 的竞态条件</span></span><br><span class="line"><span class="comment">// - semacquire 的顺序是：先 nwait++，再 cansemacquire，最后 gopark</span></span><br><span class="line"><span class="comment">// - 如果我们先检查 nwait 再 Xadd，可能在两步之间 semacquire 刚好 nwait++</span></span><br><span class="line"><span class="comment">//   导致我们误以为没有等待者而不唤醒，但 goroutine 已经睡眠了</span></span><br><span class="line"><span class="keyword">if</span> root.nwait.Load() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="comment">// 没有等待者，直接返回（信号量值已经被递增了）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== Slow Path：有等待者，需要唤醒一个 =====</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"><span class="comment">// 获取 semaRoot 的锁，保护等待队列的并发访问</span></span><br><span class="line">lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持锁后再次检查 nwait，因为可能在获取锁之前已经被其他人消费了</span></span><br><span class="line"><span class="keyword">if</span> root.nwait.Load() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 场景：我们在获取锁期间，另一个 goroutine 可能：</span></span><br><span class="line"><span class="comment">// 1. 调用了 semacquire 并通过 cansemacquire 成功获取（消费了我们递增的值）</span></span><br><span class="line"><span class="comment">// 2. 减少了 nwait 计数</span></span><br><span class="line"><span class="comment">// 所以不需要再唤醒任何人了</span></span><br><span class="line">unlock(&amp;root.lock)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从等待队列中取出一个等待者（sudog）</span></span><br><span class="line"><span class="comment">// s: 要唤醒的 sudog</span></span><br><span class="line"><span class="comment">// t0: 当前时间（用于性能统计）</span></span><br><span class="line"><span class="comment">// tailtime: 队尾等待者的开始等待时间（用于计算平均等待时间）</span></span><br><span class="line">s, t0, tailtime := root.dequeue(addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 成功取出一个等待者，减少等待者计数</span></span><br><span class="line">root.nwait.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽快释放锁，因为后续操作可能很慢（甚至可能让出 CPU）</span></span><br><span class="line">unlock(&amp;root.lock)</span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// ===== Handoff 模式：直接移交锁 =====</span></span><br><span class="line"><span class="keyword">if</span> handoff &amp;&amp; cansemacquire(addr) &#123;</span><br><span class="line"><span class="comment">// handoff=true 表示饥饿模式</span></span><br><span class="line"><span class="comment">// 尝试提前消费信号量（将 *addr 减 1）</span></span><br><span class="line"><span class="comment">// 如果成功，设置 ticket=1，告诉被唤醒的 goroutine：</span></span><br><span class="line"><span class="comment">// &quot;你不需要竞争了，锁已经是你的了&quot;</span></span><br><span class="line">s.ticket = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 唤醒 goroutine =====</span></span><br><span class="line"><span class="comment">// 将 sudog 对应的 goroutine 标记为可运行</span></span><br><span class="line"><span class="comment">// 并将其加入到当前 P 的 runnext 位置（优先运行）</span></span><br><span class="line">readyWithTime(s, <span class="number">5</span>+skipframes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== Direct G Handoff：直接切换到被唤醒者 =====</span></span><br><span class="line"><span class="keyword">if</span> s.ticket == <span class="number">1</span> &amp;&amp; getg().m.locks == <span class="number">0</span> &amp;&amp; getg() != getg().m.g0 &#123;</span><br><span class="line"><span class="comment">// 条件满足时，主动让出 CPU 给被唤醒者立即运行：</span></span><br><span class="line"><span class="comment">// - s.ticket == 1：已经直接移交了锁</span></span><br><span class="line"><span class="comment">// - getg().m.locks == 0：当前没有持有其他 runtime 锁</span></span><br><span class="line"><span class="comment">// - getg() != getg().m.g0：不在系统栈上</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// readyWithTime 已经把被唤醒者放到了 P 的 runnext 位置</span></span><br><span class="line"><span class="comment">// 现在调用 goyield() 主动让出时间片：</span></span><br><span class="line"><span class="comment">// - 被唤醒者继承我们的时间片，立即开始运行</span></span><br><span class="line"><span class="comment">// - 避免高竞争场景下某个 goroutine 霸占 P</span></span><br><span class="line"><span class="comment">// - goyield 会把当前 G 放到本地队列（不是全局队列）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 只在饥饿模式（handoff=true）下这样做，因为：</span></span><br><span class="line"><span class="comment">// - 正常模式：被唤醒者可能竞争失败，让出 CPU 会浪费</span></span><br><span class="line"><span class="comment">// - 饥饿模式：已经直接移交，保证能获取锁，不会浪费</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 相关讨论见 issue 33747</span></span><br><span class="line">goyield()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度理解">1.2.6 深度理解</h3><p><code>sema</code> 是 Go <code>sync.Mutex</code> 连接 <strong>Go运行时 (Runtime)</strong> 和 <strong>操作系统 (OS)</strong> 的关键枢纽。<code>sema</code> 就是用来解决"<u><strong>拿不到锁的 Goroutine到底去了哪里、怎么睡、怎么醒</strong></u>"的关键问题。</p><p>我们要从以下三个层次由浅入深地理解 <code>sema</code>：</p><ol type="1"><li><strong>数据结构层</strong>：它是怎么存储等待者的？</li><li><strong>运行时层 (Runtime)</strong>：Go如何高效管理成千上万个锁？</li><li><strong>操作系统层 (OS)</strong>：底层的 <code>futex</code>到底在做什么？</li></ol><h4 id="第一层它在内存中是什么">1.2.6.1 第一层：它在内存中是什么？</h4><p>在 <code>sync.Mutex</code> 的定义中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="type">int32</span></span><br><span class="line">    sema  <span class="type">uint32</span> <span class="comment">// &lt;--- 就是它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们讨论过，<strong><code>sema</code>本质上只是一个内存地址（Address）</strong>。</p><ul><li><strong>作为 Key</strong>：Go 运行时并不关心 <code>sema</code>变量里存的具体数值是多少（虽然它确实会变），运行时真正关心的是<code>&amp;sema</code>（这个变量在内存中的地址）。</li><li><strong>全局哈希表</strong>：Go运行时维护了一个全局的哈希表（<code>semTable</code>），在这个表中：<ul><li><strong>Key</strong> <code>&amp;sema</code> (Mutex 中 sema字段的内存地址)。</li><li><strong>Value</strong>一个等待队列（平衡二叉树），里面躺着一个个正在睡觉的 Goroutine。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> semtable semTable</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prime to not correlate with any user patterns.</span></span><br><span class="line"><span class="keyword">const</span> semTabSize = <span class="number">251</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> semTable [semTabSize]<span class="keyword">struct</span> &#123;</span><br><span class="line">root semaRoot</span><br><span class="line">pad  [cpu.CacheLinePadSize - unsafe.Sizeof(semaRoot&#123;&#125;)]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *semTable)</span></span> rootFor(addr *<span class="type">uint32</span>) *semaRoot &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;t[(<span class="type">uintptr</span>(unsafe.Pointer(addr))&gt;&gt;<span class="number">3</span>)%semTabSize].root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么这么设计？</strong> 如果每个 Mutex都向操作系统申请一个专门的内核信号量对象，开销太大了。Go程序中可能有数百万个Mutex，通过把它们映射到一个固定大小的全局哈希表中，Go实现了极高的扩展性。</p><h4 id="第二层运行时调度-gmp">1.2.6.2 第二层：运行时调度 (GMP)</h4><p>当 <code>state</code> 字段判断需要阻塞时，Go 会调用<code>runtime_SemacquireMutex(&amp;m.sema, ...)</code>（其实背后就是上面提到的<code>semacuqire()</code>）。这背后发生了什么？这是与 <strong>GMP模型</strong> 交互的核心。</p><p>当 <code>state</code> 字段判断需要阻塞时，Go 会调用<code>runtime_SemacquireMutex(&amp;m.sema, ...)</code>。这背后发生了什么？这是与<strong>GMP 模型</strong> 交互的核心。</p><p><strong>1. 包装：从 G 到 Sudog</strong></p><p>Goroutine (<code>G</code>) 是不能直接挂在链表上的。Go使用了一个中间结构体叫 <code>sudog</code>。</p><ul><li>当一个 G 需要阻塞时，运行时会创建一个 <code>sudog</code>，把这个 G包装进去。</li><li>这个 <code>sudog</code> 代表了"一个在特定信号量上等待的 G"。</li></ul><p><strong>2. 入队与休眠</strong></p><ol type="1"><li><strong>计算哈希</strong>：根据 <code>&amp;sema</code>的地址，算出它在全局 <code>semTable</code> 中的位置。</li><li><strong>挂载</strong>：把包装好的 <code>sudog</code> 挂到该位置的Treap 尾部。</li><li><strong>切出 (Park)</strong>：<ul><li>调用 <code>goparkunlock</code>。</li><li><strong>关键点</strong>：当前的 <strong>M (系统线程)</strong>会断开与当前 <strong>G</strong> 的关系。</li><li>G 的状态从 <code>Running</code> 变为 <code>Waiting</code>。</li><li><strong>M</strong> 并没有睡觉，它会去 <strong>P (处理器)</strong>的本地队列里找<strong>下一个</strong>可运行的 G 来执行。</li><li><strong>这就是 Go高并发的精髓</strong>：用户层面的阻塞锁，并没有阻塞底层的系统线程（除非没有其他工作可做）。</li></ul></li></ol><p><strong>3. 唤醒 (Handoff)</strong></p><p>当 <code>Unlock</code> 调用<code>runtime_Semrelease(&amp;m.sema)</code> （即<code>semarelease()</code>）时：</p><ol type="1"><li><strong>查找</strong>：再次根据 <code>&amp;sema</code>地址去全局哈希表里找。</li><li><strong>出队</strong>：取出链表头部的 <code>sudog</code>。</li><li><strong>调度</strong>：<ul><li>把 <code>sudog</code> 里的 G 取出来。</li><li>将 G 的状态从 <code>Waiting</code> 改为 <code>Runnable</code>。</li><li>把它扔到当前 P 的运行队列或者全局运行队列中，等待被 M 执行。</li></ul></li></ol><h4 id="第三层操作系统原语">1.2.6.3 第三层：操作系统原语</h4><p>这就到了物理实现的底座了。如果 M 发现没有别的 G 可以执行了，或者 Go运行时本身的某些同步需要，它最终必须依赖操作系统的能力来让 CPU停下来。</p><p>在 Linux 平台上，<code>sema</code> 的底层实现依赖于 <strong>Futex(Fast Userspace Mutex)</strong>。</p><p><code>Futex</code> 是 Linux内核提供的一种机制，它的核心理念是：<strong>即使需要内核介入，也要尽量减少陷入内核的次数。</strong></p><p>它包含两个操作：</p><ol type="1"><li><strong>User Space Check(用户态检查)</strong>：先检查内存中的一个整数（就是 <code>sema</code>的值）。如果条件满足（比如有信号），直接走人，完全不涉及内核。</li><li><strong>Kernel Wait(内核态等待)</strong>：只有当条件不满足时，才发起系统调用（SystemCall），让内核把线程挂起。</li></ol><p>在 <code>runtime/os_linux.go</code>中，你会看到类似这样的汇编或封装调用：</p><ul><li><strong>休眠 (<code>futexsleep</code>)</strong>： 调用<code>futex(addr, FUTEX_WAIT, val, ...)</code>。意思就是：<em>“内核老兄，请你看看 <code>addr</code>这个内存地址的值是不是 <code>val</code>？如果是，就把我（当前线程M）挂起；如果不是，说明中间有人改过（可能有信号了），那我就不睡了，直接返回。”</em></li><li><strong>唤醒 (<code>futexwakeup</code>)</strong>： 调用<code>futex(addr, FUTEX_WAKE, count, ...)</code>。意思就是：<em>“内核老兄，在这个地址上睡觉的线程，请帮我叫醒<code>count</code> 个。”</em></li></ul><p>关于 Futex 的更多细节，推荐阅读笔者整理的：<ahref="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a>。</p><h2 id="总结">1.3 总结</h2><p>atomic 和 sema 是 Go 并发的"阴阳二元"：</p><table><thead><tr><th style="text-align: left;"></th><th style="text-align: left;">atomic</th><th style="text-align: left;">sema</th></tr></thead><tbody><tr><td style="text-align: left;">哲学</td><td style="text-align: left;">乐观（假设无竞争）</td><td style="text-align: left;">悲观（接受竞争）</td></tr><tr><td style="text-align: left;">机制</td><td style="text-align: left;">硬件指令</td><td style="text-align: left;">OS/Runtime 调度</td></tr><tr><td style="text-align: left;">速度</td><td style="text-align: left;">极快（纳秒）</td><td style="text-align: left;">较慢（微秒）</td></tr><tr><td style="text-align: left;">能力</td><td style="text-align: left;">状态变更</td><td style="text-align: left;">休眠/唤醒</td></tr><tr><td style="text-align: left;">使用</td><td style="text-align: left;">所有路径</td><td style="text-align: left;">慢速路径</td></tr><tr><td style="text-align: left;">目标</td><td style="text-align: left;">性能</td><td style="text-align: left;">正确性 + 公平性</td></tr></tbody></table><p>所有 Go 的同步原语都是这两者的不同组合方式，遵循 "Fast Path withAtomic, Slow Path with Semaphore" 的设计模式！🎯</p><p>用一句话总结就是：</p><blockquote><p>[!IMPORTANT]</p><p>Atomic 提供无锁的快速状态管理（CAS、加减），sema 提供有竞争时的goroutine 休眠/唤醒机制，两者组合实现"乐观尝试 +悲观等待"的高效并发模型。</p></blockquote><pre class="mermaid">graph LR    subgraph "性能层级"        A[atomic<br/>纳秒级<br/>99% 场景]        B[sema<br/>微秒级<br/>1% 竞争]    end    A -->|无竞争| Fast[Fast Path]    A -->|低竞争<br/>自旋| Spin[Spin]    B -->|高竞争| Slow[Slow Path<br/>休眠/唤醒]    style A fill:#ccffcc    style B fill:#e1f5ff    style Fast fill:#90EE90    style Slow fill:#FFB6C1</pre><h1 id="sync.mutex">2. sync.Mutex</h1><h2 id="概述-1">2.1 概述</h2><p>Go 语言的 <code>sync.Mutex</code>是一种并发原语，旨在保证同一时间只有一个 Goroutine可以访问共享资源，从而实现互斥（MutualExclusion）。它的底层实现是基于两个核心字段和一套复杂的自旋、排队和唤醒逻辑，以在性能和公平性之间取得平衡。</p><p><code>sync.Mutex</code>类型只有两个公开的指针方法：<code>Lock()</code> 和<code>Unlock()</code>。</p><ul><li><code>m.Lock()</code>：锁定当前的共享资源</li><li><code>m.Unlock()</code>：进行解锁</li></ul><h2 id="数据结构-1">2.2 数据结构</h2><p>前面我们已经展示过 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/sync/mutex.go#L20">sync.Mutex</a>的数据结构了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="type">int32</span></span><br><span class="line">sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言的 sync.Mutex 结构体非常精简，仅包含两个字段：</p><ul><li><code>state (int32)</code>：这是一个 32位整数，用于原子地表示互斥锁的当前状态。通过不同的位（Bit）来编码多种信息，实现了极高的效率。</li><li><code>sema (uint32)</code>：这是我们前面提到的 sema 锁，用于实现Goroutine 的阻塞和唤醒机制。当 Goroutine无法立即获取锁时，它会在该信号量上阻塞休眠，等待锁的持有者释放信号量将其唤醒。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5d5mp6h8kj21520l23zu.jpg" style="zoom:50%;" /></p><p>如何理解这 2 个字段呢？在我看来：</p><ul><li><code>state</code> 字段是在用户态（UserSpace）解决"谁拿到锁"的逻辑。</li><li><code>sema</code> 字段是用来解决"拿不到锁的 Goroutine到底去了哪里、怎么睡、怎么醒"的物理问题。</li></ul><h2 id="state-字段">2.3 state 字段</h2><p><code>sema</code> 前面已经介绍得非常清楚了，下面我们重点来分析一下<code>state</code> 字段。</p><p>为了最大化性能，<code>state</code>字段通过位运算存储了四个关键信息，这些信息共同决定了锁的运行模式和竞争程度：</p><table><colgroup><col style="width: 12%" /><col style="width: 13%" /><col style="width: 75%" /></colgroup><thead><tr><th><strong>位 (Bit)</strong></th><th><strong>含义</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>0</strong></td><td><code>Locked</code></td><td><strong>1</strong> 表示已加锁，<strong>0</strong> 表示未加锁。</td></tr><tr><td><strong>1</strong></td><td><code>Woken</code></td><td><strong>1</strong> 表示已有 Goroutine被唤醒（正在尝试获取锁），此时不需要再唤醒其他人。</td></tr><tr><td><strong>2</strong></td><td><code>Starvation</code></td><td><strong>1</strong> 表示进入<strong>饥饿模式</strong>（Go 1.9+引入的关键优化）。</td></tr><tr><td><strong>3-31</strong></td><td><code>WaiterCount</code></td><td>记录当前有多少个 Goroutine 在排队等待。</td></tr></tbody></table><p>如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 31                           3  2  1  0</span><br><span class="line">┌─────────────────────────────┬──┬──┬──┐</span><br><span class="line">│    等待者数量 29 bits         │S │W │L │</span><br><span class="line">└─────────────────────────────┴──┴──┴──┘</span><br><span class="line">                               │  │  └─ mutexLocked (锁定状态)</span><br><span class="line">                               │  └──── mutexWoken (唤醒标志)</span><br><span class="line">                               └─────── mutexStarving (饥饿模式)</span><br></pre></td></tr></table></figure><p>使用一个 int32 来存储这么多信息有三大好处：</p><ol type="1"><li><p><strong>满足多个状态修改的原子性</strong>：所有状态必须在一个原子操作中一起更新，避免状态不一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的设计（如果分开存储）</span></span><br><span class="line">mutex.locked = <span class="literal">true</span>      <span class="comment">// ← 这里可能被中断</span></span><br><span class="line">mutex.waiterCount++      <span class="comment">// ← 状态不一致的窗口期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的设计（单个原子操作）</span></span><br><span class="line">atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>)  <span class="comment">// 一次性更新所有状态</span></span><br></pre></td></tr></table></figure></li><li><p><strong>CPU Cache Line 效率</strong>：一个 int32 只占 4字节，极度缓存友好，所有状态信息在同一个 cache line中，读取/修改只需要一次内存访问，避免 false sharing。</p></li><li><p><strong>Fast Path 快速路径优化</strong>：在无竞争情况下，即 state== 0 表示完全空闲（无锁、无等待、无标志），一次 CAS就能完成加锁，编译器可以内联这段代码，这是 99%无竞争场景的关键优化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Acquire(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">m.lockSlow()</span><br></pre></td></tr></table></figure></li></ol><p><code>state</code> 的状态转换示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始状态</span></span><br><span class="line">state = <span class="number">0</span>b00000000_00000000_00000000_00000000</span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine A 获取锁</span></span><br><span class="line">state = <span class="number">0</span>b00000000_00000000_00000000_00000001  <span class="comment">// L=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine B 尝试获取，进入等待队列</span></span><br><span class="line">state = <span class="number">0</span>b00000000_00000000_00000000_00001001  <span class="comment">// L=1, waiter=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine B 设置了 woken 标志（自旋中）</span></span><br><span class="line">state = <span class="number">0</span>b00000000_00000000_00000000_00001011  <span class="comment">// L=1, W=1, waiter=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待超过 1ms，进入饥饿模式</span></span><br><span class="line">state = <span class="number">0</span>b00000000_00000000_00000000_00001101  <span class="comment">// L=1, S=1, waiter=1</span></span><br></pre></td></tr></table></figure><h2 id="上锁">2.4 上锁</h2><ul><li>正常模式：获得锁直接返回，得不到锁就自旋，自旋多次后进入 sema队列中休眠，超过 1ms 就转为饥饿模式；</li><li>饥饿模式：<ul><li>新来的协程不自旋，直接今年入 sema 队列中；</li><li>依次从 sema 队列中唤醒协程，并直接获得锁，当 sema队列为空时，跳回正常模式</li></ul></li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5daz7hk4nj22a80u077s.jpg" /></p><p>上锁的源码位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/sync/mutex.go#L61">sync/mutex.go#L61</a>，代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line"><span class="comment">// ===== 初始化局部变量 =====</span></span><br><span class="line"><span class="keyword">var</span> waitStartTime <span class="type">int64</span>  <span class="comment">// 开始等待的时间戳（用于判断是否饥饿）</span></span><br><span class="line">starving := <span class="literal">false</span>        <span class="comment">// 当前 goroutine 是否处于饥饿状态</span></span><br><span class="line">awoke := <span class="literal">false</span>           <span class="comment">// 当前 goroutine 是否从休眠中被唤醒</span></span><br><span class="line">iter := <span class="number">0</span>                <span class="comment">// 自旋迭代次数</span></span><br><span class="line">old := m.state           <span class="comment">// 保存当前 mutex 的状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 主循环：不断尝试获取锁 =====</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"><span class="comment">// 第一阶段：自旋尝试（Active Spinning）</span></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"><span class="comment">// 自旋条件：</span></span><br><span class="line"><span class="comment">// 1. old&amp;mutexLocked != 0：锁已被持有</span></span><br><span class="line"><span class="comment">// 2. old&amp;mutexStarving == 0：不在饥饿模式（饥饿模式下新来的不能竞争）</span></span><br><span class="line"><span class="comment">// 3. runtime_canSpin(iter)：满足自旋条件（多核、迭代次数 &lt; 4、有其他 P 等）</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line"><span class="comment">// 尝试设置 mutexWoken 标志，条件：</span></span><br><span class="line"><span class="comment">// 1. !awoke：我们还没设置过</span></span><br><span class="line"><span class="comment">// 2. old&amp;mutexWoken == 0：当前没有其他 goroutine 设置</span></span><br><span class="line"><span class="comment">// 3. old&gt;&gt;mutexWaiterShift != 0：有等待者（不然设置 woken 没意义）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 目的：告诉 Unlock &quot;有人在自旋，不要唤醒休眠的 goroutine&quot;，减少不必要的唤醒开销</span></span><br><span class="line"><span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行实际的自旋（CPU 级别的忙等待）</span></span><br><span class="line">runtime_doSpin()</span><br><span class="line">iter++</span><br><span class="line">old = m.state  <span class="comment">// 重新读取状态</span></span><br><span class="line"><span class="keyword">continue</span>       <span class="comment">// 继续下一轮尝试</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"><span class="comment">// 第二阶段：准备新的状态值（CAS 更新）</span></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">new</span> := old  <span class="comment">// 基于旧状态构造新状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不在饥饿模式，尝试设置 mutexLocked 位</span></span><br><span class="line"><span class="comment">// （在饥饿模式下，新来的 goroutine 不能直接抢锁，必须排队）</span></span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果锁已被持有或处于饥饿模式，增加等待者计数（即将进入等待队列）</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift  <span class="comment">// 等待者数量 +1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前 goroutine 已经饥饿（等待超过 1ms），并且锁还被持有</span></span><br><span class="line"><span class="comment">// 则尝试将 mutex 切换到饥饿模式</span></span><br><span class="line"><span class="comment">// 注意：只在锁被持有时切换，因为 Unlock 期望饥饿模式必有等待者</span></span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前 goroutine 是被唤醒的，需要清除 mutexWoken 标志</span></span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line"><span class="comment">// 清除 mutexWoken 标志（用 &amp;^ 位清除操作）</span></span><br><span class="line"><span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"><span class="comment">// 第三阶段：CAS 更新状态</span></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试用 CAS 将状态从 old 更新为 new</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line"><span class="comment">// CAS 成功！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否成功获取了锁</span></span><br><span class="line"><span class="comment">// 条件：旧状态既没锁定也不在饥饿模式</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">// 成功获取锁，退出循环！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"><span class="comment">// 第四阶段：进入等待队列并休眠</span></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果之前已经等待过（被唤醒后重新竞争失败），插入队首（LIFO）</span></span><br><span class="line"><span class="comment">// 否则插入队尾（FIFO）</span></span><br><span class="line">queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录开始等待的时间（只记录一次）</span></span><br><span class="line"><span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">waitStartTime = runtime_nanotime()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用 semacuqire 进入休眠 &lt;--- 阻塞在这里，直到被唤醒</span></span><br><span class="line">runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"><span class="comment">// 被唤醒了！从这里继续执行</span></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否应该进入饥饿模式</span></span><br><span class="line"><span class="comment">// 条件：之前已经饥饿 || 等待时间超过 1ms</span></span><br><span class="line">starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新读取当前状态</span></span><br><span class="line">old = m.state</span><br><span class="line"></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"><span class="comment">// 饥饿模式的特殊处理</span></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 饥饿模式下被唤醒，说明锁被直接移交给我们了</span></span><br><span class="line"><span class="comment">// 但此时状态还不一致：</span></span><br><span class="line"><span class="comment">// - mutexLocked 还没设置（需要我们设置）</span></span><br><span class="line"><span class="comment">// - 我们还被计入等待者（需要减 1）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算状态变化：</span></span><br><span class="line"><span class="comment">// +mutexLocked：设置锁定标志</span></span><br><span class="line"><span class="comment">// -1&lt;&lt;mutexWaiterShift：等待者数量减 1</span></span><br><span class="line">delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 决定是否退出饥饿模式</span></span><br><span class="line"><span class="comment">// 条件：</span></span><br><span class="line"><span class="comment">// 1. 当前 goroutine 不再饥饿（等待时间 &lt; 1ms）</span></span><br><span class="line"><span class="comment">// 2. 或者我们是最后一个等待者</span></span><br><span class="line"><span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// 退出饥饿模式（清除 mutexStarving 标志）</span></span><br><span class="line"><span class="comment">// 注意：必须在这里退出，考虑实际等待时间</span></span><br><span class="line"><span class="comment">// 饥饿模式效率低，如果不及时退出，两个 goroutine</span></span><br><span class="line"><span class="comment">// 可能会无限期地在饥饿模式下来回切换</span></span><br><span class="line">delta -= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子更新状态</span></span><br><span class="line">atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line"><span class="keyword">break</span>  <span class="comment">// 成功获取锁，退出循环！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"><span class="comment">// 正常模式被唤醒：重新开始竞争</span></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"></span><br><span class="line">awoke = <span class="literal">true</span>   <span class="comment">// 标记为已唤醒</span></span><br><span class="line">iter = <span class="number">0</span>       <span class="comment">// 重置自旋计数器（可以重新自旋）</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// CAS 失败：状态被其他 goroutine 改变了</span></span><br><span class="line"><span class="comment">// 重新读取状态，继续下一轮循环</span></span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ===== 成功获取锁，退出循环 =====</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键步骤：</p><ol type="1"><li>自旋（Spinning）：在正常模式且满足条件时自旋等待</li><li>设置 mutexWoken：告诉 Unlock 不要唤醒其他 goroutine</li><li>更新等待者计数：增加 waiter 数量</li><li>进入信号量等待：调用 runtime_SemacquireMutex</li><li>饥饿模式切换：等待时间超过 1ms 切换到饥饿模式</li></ol><p>自旋条件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">active_spin     = <span class="number">4</span>  <span class="comment">// referenced in proc.go for sync.Mutex implementation</span></span><br><span class="line">active_spin_cnt = <span class="number">30</span> <span class="comment">// referenced in proc.go for sync.Mutex implementation</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internal_sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="comment">// 必须同时满足：</span></span><br><span class="line"><span class="comment">// - 自旋次数 &lt; 4</span></span><br><span class="line"><span class="comment">// - 多核 CPU（numCPU &gt; 1）</span></span><br><span class="line"><span class="comment">//  - 有其他运行的 P</span></span><br><span class="line">  <span class="comment">//  - 本地运行队列为空</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= active_spin || numCPUStartup &lt;= <span class="number">1</span> || gomaxprocs &lt;= sched.npidle.Load()+sched.nmspinning.Load()+<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解锁">2.5 解锁</h2><ul><li>正常模式：解锁后新来的协程和 sema 队列中的协程一起竞争；</li><li>饥饿模式：新来的协程直接入 sema 队列，依次从 sema队列中唤醒协程并直接交付锁；</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5db20m37pj21pc0m475r.jpg" /></p><p>上锁的源码位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/internal/sync/mutex.go#L202">sync/mutex.go#L202</a>，代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line"><span class="comment">// ===== Fast Path：快速路径（无竞争情况）=====</span></span><br><span class="line"><span class="comment">// 原子地将 state 减去 mutexLocked（即清除锁定标志位）</span></span><br><span class="line"><span class="comment">// 如果 mutex 完全空闲（无等待者、无其他标志），new 将等于 0</span></span><br><span class="line">  <span class="comment">// 如果 new == 0，说明没有等待者，直接返回（最快路径）</span></span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// new != 0 说明还有其他信息（等待者、标志位等）</span></span><br><span class="line"><span class="comment">// 需要进入慢速路径处理</span></span><br><span class="line">m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlockSlow 是 Unlock 的慢速路径，处理有等待者或特殊标志的情况</span></span><br><span class="line"><span class="comment">// 参数 new：已经减去 mutexLocked 后的新状态值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line"><span class="comment">// 不允许对未加锁的 mutex 进行 unlock!</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">fatal(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"><span class="comment">// 分支 1：正常模式（Normal Mode）</span></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 正常模式下的唤醒逻辑：不保证被唤醒者一定能获取锁</span></span><br><span class="line">old := <span class="built_in">new</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// ===== 检查是否需要唤醒等待者 =====</span></span><br><span class="line"><span class="comment">// 以下任一条件满足，都无需唤醒：</span></span><br><span class="line"><span class="comment">// 1. old&gt;&gt;mutexWaiterShift == 0</span></span><br><span class="line"><span class="comment">//    → 没有等待者</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 2. old&amp;mutexLocked != 0</span></span><br><span class="line"><span class="comment">//    → 锁已经被其他 goroutine 抢走了</span></span><br><span class="line"><span class="comment">//       （在我们 Unlock 之后，有新来的 goroutine 直接 CAS 获取了锁）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 3. old&amp;mutexWoken != 0</span></span><br><span class="line"><span class="comment">//    → 已经有一个 goroutine 被标记为唤醒状态</span></span><br><span class="line"><span class="comment">//       （可能在自旋，或者已经被其他 Unlock 唤醒）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 4. old&amp;mutexStarving != 0</span></span><br><span class="line"><span class="comment">//    → 进入饥饿模式了</span></span><br><span class="line"><span class="comment">//       （虽然我们检查的是 new&amp;mutexStarving == 0 才进这个分支，</span></span><br><span class="line"><span class="comment">//        但在循环中 old 可能被其他 goroutine 更新了）</span></span><br><span class="line"><span class="comment">//       饥饿模式有专门的处理逻辑，我们不应该干预</span></span><br><span class="line"><span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="comment">// 不需要唤醒，直接返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 准备唤醒一个等待者 =====</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造新状态：</span></span><br><span class="line"><span class="comment">// 1. old - 1&lt;&lt;mutexWaiterShift：等待者数量减 1</span></span><br><span class="line"><span class="comment">// 2. | mutexWoken：设置 mutexWoken 标志</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mutexWoken 的作用：</span></span><br><span class="line"><span class="comment">// - 告诉正在 Lock 的 goroutine：&quot;已经有人被唤醒了&quot;</span></span><br><span class="line"><span class="comment">// - 避免多个 Unlock 重复唤醒</span></span><br><span class="line"><span class="comment">// - 被唤醒的 goroutine 会清除这个标志</span></span><br><span class="line"><span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 CAS 更新状态</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line"><span class="comment">// CAS 成功！我们获得了唤醒的权利</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 runtime 的信号量释放操作，唤醒一个等待者</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// - &amp;m.sema：信号量地址</span></span><br><span class="line"><span class="comment">// - false：handoff=false，正常模式，不直接移交</span></span><br><span class="line"><span class="comment">//          被唤醒的 goroutine 需要重新竞争锁</span></span><br><span class="line"><span class="comment">// - 2：skipframes（用于性能分析）</span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS 失败：状态被其他 goroutine 改变了</span></span><br><span class="line"><span class="comment">// 重新读取状态，继续下一轮循环</span></span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line"><span class="comment">// 分支 2：饥饿模式（Starvation Mode）</span></span><br><span class="line"><span class="comment">// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 饥饿模式的特殊处理：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 1. 直接移交所有权（handoff=true）</span></span><br><span class="line"><span class="comment">//    - 被唤醒的 goroutine 保证能获取锁</span></span><br><span class="line"><span class="comment">//    - 不需要重新竞争</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 2. mutexLocked 位不设置</span></span><br><span class="line"><span class="comment">//    - 被唤醒的 goroutine 会自己设置</span></span><br><span class="line"><span class="comment">//    - 见 lockSlow 中 old&amp;mutexStarving != 0 分支</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 3. mutexStarving 标志保持</span></span><br><span class="line"><span class="comment">//    - 新来的 goroutine 看到这个标志，知道不能竞争</span></span><br><span class="line"><span class="comment">//    - 必须排队等待</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 4. 当前 goroutine 会主动让出 CPU（在 semrelease1 中 goyield）</span></span><br><span class="line"><span class="comment">//    - 让被唤醒者立即运行</span></span><br><span class="line"><span class="comment">//    - 避免延迟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 semarelease() 释放操作</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// - &amp;m.sema：信号量地址</span></span><br><span class="line"><span class="comment">// - true：handoff=true，饥饿模式，直接移交</span></span><br><span class="line"><span class="comment">//         semrelease1 会设置 ticket=1，并调用 goyield()</span></span><br><span class="line"><span class="comment">// - 2：skipframes（用于性能分析）</span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键步骤：</p><ol type="1"><li>原子清除锁定位：atomic.AddInt32(&amp;state, -mutexLocked)，结果为 0则直接返回</li><li>检查是否需要唤醒：无等待者/已有锁持有者/已有被唤醒者则跳过</li><li>正常模式：设置 mutexWoken 标志 + 减少等待者计数 +semrelease(handoff=false) 唤醒但需重新竞争</li><li>饥饿模式：semrelease(handoff=true) 直接移交所有权 + goyield() 让出CPU</li></ol><h2 id="总结-1">2.6 总结</h2><p>到这里，我们已经深入探析了 <code>sync.Mutex</code>的核心机制和底层数据结构。归纳下来，Go 的 <code>Mutex</code>实现，<strong>本质上是通过 atomic 乐观抢占为主、sema信号量排队休眠为辅，辅以饥饿/公平模式动态切换</strong>，来最大化锁的性能与公平性。</p><p><strong>精髓：抢得快靠 "atomic"，等得稳靠 "sema"。</strong></p><ul><li><strong>快速路径（Fast Path）：</strong> 绝大多数情况下，goroutine利用 <code>atomic</code>硬件指令快速抢占锁，纳秒级切换，无需操作内核。</li><li><strong>慢速路径（Slow Path）：</strong> 发生竞争时，goroutine 通过<code>sema</code>跳入排队睡眠，只有唤醒才参与下一轮抢占。这部分涉及用户/内核态切换，耗时微秒级，但能极大减少资源消耗与CPU 干扰。</li><li><strong>三层状态编码：</strong> 利用一个 <code>int32</code>整数位操作，节省空间同时高效追踪锁的"持有""等待""唤醒""饥饿"等复杂状态。</li><li><strong>饥饿模式保障公平性：</strong>当长时间得不到锁时，自动切换到饥饿模式，保证队列排头的人下一次必定抢到锁，杜绝饥饿和“惊群”。</li></ul><h1 id="sync.rwmutex">3. sync.RWMutex</h1><h2 id="概述-2">3.1 概述</h2><ul><li>同时只能有一个 Goroutine 能够获得写锁</li><li>同时可以有任意多个 Gorouinte 获得读锁</li><li>同时只能存在写锁或读锁（读和写互斥）</li></ul><p><code>sync.RWMutex</code> 提供了 4 个方法：</p><ul><li><code>rwm.RLock()</code>：上读锁</li><li><code>rwm.RUnlock()</code>：解读锁</li><li><code>rwm.Lock()</code>：上写锁</li><li><code>rwm.Unlock()</code>：解读锁</li></ul><h2 id="数据结构-2">3.2 数据结构</h2><p><code>sync.RWMutex</code> 定义在 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/sync/rwmutex.go#L39">sync/rwmutex.go#L39</a>，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">w           Mutex        <span class="comment">// held if there are pending writers</span></span><br><span class="line">writerSem   <span class="type">uint32</span>       <span class="comment">// semaphore for writers to wait for completing readers</span></span><br><span class="line">readerSem   <span class="type">uint32</span>       <span class="comment">// semaphore for readers to wait for completing writers</span></span><br><span class="line">readerCount atomic.Int32 <span class="comment">// number of pending readers</span></span><br><span class="line">readerWait  atomic.Int32 <span class="comment">// number of departing readers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>w</code>：写锁，拿到它直接有了上写锁的资格，有可能还需要等待读锁全部释放</li><li><code>writerSem</code>：写协程等待队列</li><li><code>readerSem</code>：读协程等待队列</li><li><code>readerCount</code>：正值表示正值读的协程个数，负值表示加了写锁；</li><li><code>readerWait</code>：上写锁应该等待读协程的个数</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5dc3vpgidj21fy0p6wft.jpg" /></p><h2 id="上写锁">3.3 上写锁</h2><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5edigi0eqj22c409cab9.jpg" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span> <span class="comment">// 最多的读者个数，是一个非常大的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line"><span class="comment">// 1. 抢占获取写锁的资格</span></span><br><span class="line">rw.w.Lock()</span><br><span class="line"><span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">  <span class="comment">// 2. 原子变量 readerCount 减去 rwmutexMaxReaders 表明当前有写的需求，</span></span><br><span class="line">  <span class="comment">// 阻止后续读锁的抢占，写者优先！</span></span><br><span class="line">  <span class="comment">// 再加回去是要恢复原来的值，以得到抢锁之前正常读的协程的个数 r</span></span><br><span class="line">r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">  <span class="comment">// 3. 陷入 writerSem，等待 readerWait 个正在读的协程释放读锁</span></span><br><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; rw.readerWait.Add(r) != <span class="number">0</span> &#123;</span><br><span class="line">runtime_SemacquireRWMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 4. 抢锁成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解写锁">3.4 解写锁</h2><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5edvrcnjzj21ns0d4751.jpg" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">  <span class="comment">// 1. 把 rwmutexMaxReaders 加回去，表示已经没有写协程了</span></span><br><span class="line">r := rw.readerCount.Add(rwmutexMaxReaders)</span><br><span class="line"><span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;</span><br><span class="line">    <span class="comment">// 不允许对未上锁的锁进行 Unlock！</span></span><br><span class="line">fatal(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 2. 唤醒所有阻塞在 readerSem 中的读协程</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 允许其他协程抢占写锁</span></span><br><span class="line">rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上读锁">3.5 上读锁</h2><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5ednp240kj21py07idgq.jpg" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">  <span class="comment">// 1. readerCount++，检查是否有写锁</span></span><br><span class="line"><span class="keyword">if</span> rw.readerCount.Add(<span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 2. 有写锁，则陷入 readerSem，等待写锁释放</span></span><br><span class="line">runtime_SemacquireRWMutexR(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 3. 没有写锁或者写锁释放后唤醒 readerSem，则获得读锁成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解读锁">3.6 解读锁</h2><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5edvrcnjzj21ns0d4751.jpg" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">  <span class="comment">// 1. 释放当前读锁，将 readerCount --</span></span><br><span class="line">  <span class="comment">// 2. 检查是否有写协程正在等待</span></span><br><span class="line"><span class="keyword">if</span> r := rw.readerCount.Add(<span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 3. 如果有写协程等待，则往下走</span></span><br><span class="line">rw.rUnlockSlow(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;</span><br><span class="line">fatal(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 4. readerWait--</span></span><br><span class="line">  <span class="comment">// 5. 判断是否是最后一个释放读锁的协程</span></span><br><span class="line"><span class="keyword">if</span> rw.readerWait.Add(<span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 6. 是的话，就从 writerSem 中唤醒写协程</span></span><br><span class="line">runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-2">3.7 总结</h2><p>总的来说，Go 的 <code>RWMutex</code> 遵循的是<strong>写者优先（WriterPriority）</strong> 原则，防止写者饥饿。四个核心方法的要点总结如下：</p><ul><li><p><strong>上写锁</strong>：竞争写锁，看看有无读协程：</p><ul><li><p>没有读协程的话直接获得写锁；</p></li><li><p>有读协程的话，阻塞后来的读协程，等待当前读协程释放；</p></li></ul></li><li><p><strong>解写锁</strong>：解写锁，唤醒 readerSem；</p></li><li><p><strong>上读锁</strong>：readerCount++，并检查是否有写锁：</p><ul><li><p>没有写锁，则上锁完毕；</p></li><li><p>有写锁，则陷入 readerSem，等待写锁释放；</p></li></ul></li><li><p><strong>解读锁</strong>：readerCount--，并检测是否有写协程被阻塞：</p><ul><li><p>无，则返回；</p></li><li><p>有，则 readerWait --；判断是否是最后一个释放读锁的协程：</p><ul><li>不是，则返回；</li><li>是，则唤醒 writerSem，解锁完毕；</li></ul></li></ul></li></ul><h1 id="sync.waitgroup">4. sync.WaitGroup</h1><h2 id="概述-3">4.1 概述</h2><p>WaitGroup 等待一组 Goroutine 完成。主 Goroutine 调用 Add来设置要等待的 Goroutine 的数量。然后每个 Goroutine 运行并在完成时调用Done。同时，主 Goroutine 可以使用 Wait 来阻塞，直到所有 Goroutine完成。</p><ul><li><code>wg.Add(delta int)</code>：Add 将 delta（可能为负）添加到WaitGroup 计数器。如果计数器变为 0，所有在 Wait 时阻塞的 Goroutine将被释放。如果计数器变成负值，Add 会 panic。</li><li><code>wg.Done()</code>：当 WaitGroup 同步等待组中的某个 Goroutine执行完毕后，设置这个 WaitGroup 的 counter 数值减 1。</li><li><code>wg.Wait()</code>：表示让当前的 Goroutine等待，进入阻塞状态。一直到 WaitGroup 的计数器为 0，才能解除阻塞，这个Goroutine 才能继续执行。</li></ul><h2 id="数据结构-3">4.2 数据结构</h2><p><code>sync.WaitGroup</code> 源码位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/sync/waitgroup.go#L48">sync/waitgroup.go#L48</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy noCopy   <span class="comment">// 防止拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bits (high to low):</span></span><br><span class="line"><span class="comment">//   bits[0:32]  counter</span></span><br><span class="line"><span class="comment">//   bits[32]    flag: synctest bubble membership</span></span><br><span class="line"><span class="comment">//   bits[33:64] wait count</span></span><br><span class="line">state atomic.Uint64  <span class="comment">// 核心状态字段（64位）</span></span><br><span class="line">sema  <span class="type">uint32</span> <span class="comment">// sema 锁地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是看 <code>state</code> 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 63                    33  32  31                     0</span><br><span class="line">┌─────────────────────┬───┬───┬─────────────────────┐</span><br><span class="line">│   waiter count      │ B │ 0 │      counter        │</span><br><span class="line">│    (31 bits)        │ u │   │    (32 bits)        │</span><br><span class="line">│                     │ b │   │                     │</span><br><span class="line">│                     │ b │   │                     │</span><br><span class="line">│                     │ l │   │                     │</span><br><span class="line">│                     │ e │   │                     │</span><br><span class="line">└─────────────────────┴───┴───┴─────────────────────┘</span><br><span class="line">  bits[33:64]         bit32   bits[0:32]</span><br><span class="line"></span><br><span class="line">counter:      当前待完成的任务数（Add 增加，Done 减少）</span><br><span class="line">bubble flag:  synctest 相关（测试用）</span><br><span class="line">waiter count: 有多少个 goroutine 在 Wait 中阻塞</span><br></pre></td></tr></table></figure><p>为什么要用一个字段？</p><ol type="1"><li>原子操作：可以用一次原子操作同时读写两个值</li><li>避免竞态：counter 和 waiter 总是一致的快照</li><li>零分配：整个 WaitGroup 只需 16 字节（8+4+padding）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state := wg.state.Load()</span><br><span class="line">counter := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)     <span class="comment">// 取高32位</span></span><br><span class="line">waiter := <span class="type">uint32</span>(state &amp; <span class="number">0x7fffffff</span>) <span class="comment">// 取低31位（忽略bubble flag）</span></span><br></pre></td></tr></table></figure><h2 id="wg.wait">4.3 wg.Wait()</h2><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5eepe7yxij21f806y0td.jpg" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := wg.state.Load()</span><br><span class="line">        v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)    <span class="comment">// counter</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. Fast Path: counter == 0，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Slow Path: counter &gt; 0，需要等待</span></span><br><span class="line">        <span class="comment">// 用 CAS 增加 waiter 计数</span></span><br><span class="line">        <span class="keyword">if</span> wg.state.CompareAndSwap(state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// CAS 成功，进入等待</span></span><br><span class="line">            runtime_SemacquireWaitGroup(&amp;wg.sema, <span class="literal">false</span>)</span><br><span class="line">            <span class="comment">// 被唤醒后返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CAS 失败，重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wg.add">4.4 wg.Add()</h2><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5eexehxpaj220g0eg75w.jpg" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 原子地将 delta 加到 counter（高32位）</span></span><br><span class="line">    state := wg.state.Add(<span class="type">uint64</span>(delta) &lt;&lt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 解析 state</span></span><br><span class="line">    v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)  <span class="comment">// counter</span></span><br><span class="line">    w := <span class="type">uint32</span>(state &amp; <span class="number">0x7fffffff</span>) <span class="comment">// waiter count</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 错误检查</span></span><br><span class="line">    <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;negative counter&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="type">int32</span>(delta) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;Add called concurrently with Wait&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 快速返回：counter &gt; 0 或没有 waiter</span></span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 关键时刻：counter 降到 0，且有 waiter 在等待</span></span><br><span class="line">    <span class="comment">//    → 唤醒所有 waiter！</span></span><br><span class="line">    wg.state.Store(<span class="number">0</span>)  <span class="comment">// 重置状态</span></span><br><span class="line">    <span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">        runtime_Semrelease(&amp;wg.sema, <span class="literal">false</span>, <span class="number">0</span>)  <span class="comment">// 唤醒一个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wg.done">4.5 wg.Done()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done() &#123;</span><br><span class="line">  <span class="comment">// 就是执行 counnter--</span></span><br><span class="line">wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sync.once">5. sync.Once</h1><h2 id="概述-4">5.1 概述</h2><p><code>sync.Once</code> 可以让并发中的一段代码只执行一次；</p><ul><li><strong>once.Do(func)</strong>：执行某一函数，该函数在多个协程中，只会被执行一次。</li></ul><h2 id="数据结构-4">5.2 数据结构</h2><p><code>sync.Once</code> 的源码位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/sync/once.go#L20">sync/once.go#L20</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">_ noCopy</span><br><span class="line"></span><br><span class="line">done atomic.Bool</span><br><span class="line">m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>done</code>：表示当前 once 是否已经执行过了；</li><li><code>m</code>：锁</li></ul><h2 id="once.do">5.3 once.Do()</h2><p>其实就一个简单的双重检测逻辑。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5efehy8jqj21tw0bo0tw.jpg" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果已经执行过的了，直接返回</span></span><br><span class="line"><span class="keyword">if</span> !o.done.Load() &#123;</span><br><span class="line">o.doSlow(f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> doSlow(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 上锁</span></span><br><span class="line">o.m.Lock()</span><br><span class="line"><span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">  <span class="comment">// 上锁后二次检查</span></span><br><span class="line"><span class="keyword">if</span> !o.done.Load() &#123;</span><br><span class="line"><span class="keyword">defer</span> o.done.Store(<span class="literal">true</span>)</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sync.cond">6. sync.Cond</h1><h2 id="概述-5">6.1 概述</h2><p>从第一性原理来看，<code>sync.Cond</code>解决的是<strong>轮询（Polling） vs 事件通知（EventNotification）</strong>的问题。当你需要等待某个<strong>特定条件</strong>（比如"队列不为空"或"缓冲区有空位"）满足时，你只有两种选择：</p><ol type="1"><li><strong>轮询 (Spinning)</strong>：在一个死循环里不断加锁检查。</li><li><strong>通知(Cond)</strong>：我去睡觉，等条件满足了，你把我叫醒。</li></ol><p>Go 的 <code>sync.Cond</code>实现非常独特，它没有直接使用操作系统层面的 Condition Variable（如Pthread Cond），而是自己在 Runtime层面实现了一套<strong>基于票号（Ticket）的通知队列</strong>。</p><p><code>sync.Cond</code> 提供了 3 个核心方法：</p><ul><li><code>c.Wait()</code>：阻塞，等待条件发生</li><li><code>c.Signal()</code>：唤醒一个等待的协程</li><li><code>c.Broadcast()</code>：唤醒所有等待的协程</li></ul><p>使用方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.L.Lock()          <span class="comment">// 1. 先加锁（保护条件 condition）</span></span><br><span class="line"><span class="keyword">for</span> !condition() &#123;  <span class="comment">// 2. 必须用 for 循环检查（防止虚假唤醒）</span></span><br><span class="line">    c.Wait()        <span class="comment">// 3. 挂起（内部会：解锁 -&gt; 睡 -&gt; 加锁）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行业务逻辑...</span></span><br><span class="line">c.L.Unlock()        <span class="comment">// 4. 最终解锁</span></span><br></pre></td></tr></table></figure><h2 id="数据结构-5">6.2 数据结构</h2><p><code>sync.Cond</code> 源码位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/sync/cond.go#L37">sync/cond.go#L37</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy  noCopy       <span class="comment">// 防止拷贝</span></span><br><span class="line">    L       Locker       <span class="comment">// 关联的锁（通常是 *Mutex 或 *RWMutex）</span></span><br><span class="line">    notify  notifyList   <span class="comment">// 等待队列（ticket-based）</span></span><br><span class="line">    checker copyChecker  <span class="comment">// 运行时拷贝检测</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">wait atomic.Uint32 <span class="comment">// 下一个等待者的票号（原子递增）</span></span><br><span class="line">notify <span class="type">uint32</span> <span class="comment">// 下一个要通知的票号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待者列表</span></span><br><span class="line">lock mutex</span><br><span class="line">head *sudog</span><br><span class="line">tail *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251121205142864.png" /></p><p>理解 <code>sync.Cond</code>的关键，在于理解它如何解决<strong>虚假唤醒</strong>和<strong>消息丢失</strong>的问题。Go使用了一种类似银行排号系统的逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait = 5, notify = 2</span><br><span class="line">         ↓</span><br><span class="line">当前排队: ticket 2, 3, 4 (还未通知)</span><br><span class="line">即将排队: ticket 5, 6, 7... (新来的)</span><br></pre></td></tr></table></figure><h2 id="c.wait">6.3 c.Wait()</h2><p>当一个 Goroutine 调用 <code>Wait()</code>时，发生了以下严密的步骤：</p><ol type="1"><li><strong>拿号 (Ticket Allocation)</strong>： 调用<code>runtime_notifyListAdd</code>。这本质上是一个原子操作，将<code>notifyList</code> 中的 <code>wait</code> 计数器加1，并返回当前的序列号（Ticket）。</li><li><strong>解锁 (Unlock)</strong>： 调用<code>c.L.Unlock()</code>。必须先拿号，再解锁。这保证了即使你在解锁后、睡觉前，有人发送了信号，你的号也已经排进去了，不会错过通知。</li><li><strong>睡觉 (Block)</strong>： 调用<code>runtime_notifyListWait(Ticket)</code>，把自己挂起，等待有人喊"第100 号"或者"所有人"醒来。</li><li><strong>重新加锁 (Lock)</strong>： 当被唤醒后，<code>Wait</code>函数返回前，会<strong>自动</strong>调用 <code>c.L.Lock()</code>。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">    <span class="comment">// 步骤 1: 拿号 (Ticket Allocation)</span></span><br><span class="line">    <span class="comment">// 关键点：在解锁之前先拿号！</span></span><br><span class="line">    <span class="comment">// 这保证了即使我还没睡着，Signal 发送者也能知道&quot;有一个持有 t 号的人正在赶来的路上&quot;。</span></span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2: 解锁 (Unlock User Lock)</span></span><br><span class="line">    <span class="comment">// 必须解锁，否则 Signal 的发送者无法获得锁来修改条件，死锁。</span></span><br><span class="line">    c.L.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3: 入队并休眠 (Enqueue &amp; Park)</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 4: 重新加锁 (Relock)</span></span><br><span class="line">    <span class="comment">// 醒来后，必须恢复到调用 Wait 前的状态，以便重新检查 for !condition()。</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line"><span class="comment">// This may be called concurrently, for example, when called from</span></span><br><span class="line"><span class="comment">// sync.Cond.Wait while holding a RWMutex in read mode.</span></span><br><span class="line"><span class="keyword">return</span> l.wait.Add(<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 notifyListWait 后，再次检查一下 l.notify），</span></span><br><span class="line">  <span class="comment">// 如果 l.notify &gt; t，说明已经被叫过了，</span></span><br><span class="line">  <span class="comment">// 那我就不睡了，直接返回。这完美解决了信号丢失问题。</span></span><br><span class="line"><span class="keyword">if</span> less(t, l.notify) &#123;</span><br><span class="line">unlock(&amp;l.lock)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队休眠</span></span><br><span class="line">s := acquireSudog()</span><br><span class="line">s.g = getg()</span><br><span class="line">s.ticket = t</span><br><span class="line">s.releasetime = <span class="number">0</span></span><br><span class="line">t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">s.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">l.head = s</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l.tail.next = s</span><br><span class="line">&#125;</span><br><span class="line">l.tail = s</span><br><span class="line">goparkunlock(&amp;l.lock, waitReasonSyncCondWait, traceBlockCondWait, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">releaseSudog(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="c.signal">6.4 c.Signal()</h2><p>当调用 <code>Signal()</code> 时：</p><ol type="1"><li>调用 <code>runtime_notifyListNotifyOne</code>。</li><li>它会查找 <code>notifyList</code>中<strong>最早</strong>那个还没被唤醒的 Ticket（比如第 99号已醒，现在叫第 100 号）。</li><li>通过 <code>sema</code>（信号量）精确唤醒持有该 Ticket 的那个Goroutine。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 如果 wait == notify，说明没有新的等待者，直接返回</span></span><br><span class="line"><span class="keyword">if</span> l.wait.Load() == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取锁，因为需要修改 notifylist</span></span><br><span class="line">lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双重检查，如果没有新的等待者，则直接返回</span></span><br><span class="line">t := l.notify</span><br><span class="line"><span class="keyword">if</span> t == l.wait.Load() &#123;</span><br><span class="line">unlock(&amp;l.lock)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新下一个 notify 的票号</span></span><br><span class="line">atomic.Store(&amp;l.notify, t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 notifyList 尝试唤醒一个休眠中的 G</span></span><br><span class="line"><span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line"><span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">n := s.next</span><br><span class="line"><span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">p.next = n</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l.head = n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">l.tail = p</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;l.lock)</span><br><span class="line">s.next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> s.g.bubble != <span class="literal">nil</span> &amp;&amp; getg().bubble != s.g.bubble &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;semaphore wake of synctest goroutine&quot;</span>, s.g.goid, <span class="string">&quot;from outside bubble&quot;</span>)</span><br><span class="line">fatal(<span class="string">&quot;semaphore wake of synctest goroutine from outside bubble&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 唤醒</span></span><br><span class="line">readyWithTime(s, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readyWithTime</span><span class="params">(s *sudog, traceskip <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">s.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(s.g, traceskip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c.broadcast">6.5 c.Broadcast()</h2><p>当调用 <code>Broadcast()</code> 时：</p><ol type="1"><li>调用 <code>runtime_notifyListNotifyAll</code>。</li><li>它不需一个一个叫，而是直接记下当前的 <code>wait</code>计数器值（比如当前排到了 150 号）。</li><li>它会唤醒从"当前已唤醒号"到"150 号"之间的<strong>所有</strong>Goroutine。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line"><span class="comment">// 没有新的等待者，直接返回</span></span><br><span class="line"><span class="keyword">if</span> l.wait.Load() == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上锁</span></span><br><span class="line">lockWithRank(&amp;l.lock, lockRankNotifyList)</span><br><span class="line">  <span class="comment">// 清空 notifyList，因为全部都会被唤醒</span></span><br><span class="line">s := l.head</span><br><span class="line">l.head = <span class="literal">nil</span></span><br><span class="line">l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 notify 为当前的 wait</span></span><br><span class="line">atomic.Store(&amp;l.notify, l.wait.Load())</span><br><span class="line">unlock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒旧的 notifyList 的所有 sudog</span></span><br><span class="line"><span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">next := s.next</span><br><span class="line">s.next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> s.g.bubble != <span class="literal">nil</span> &amp;&amp; getg().bubble != s.g.bubble &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;semaphore wake of synctest goroutine&quot;</span>, s.g.goid, <span class="string">&quot;from outside bubble&quot;</span>)</span><br><span class="line">fatal(<span class="string">&quot;semaphore wake of synctest goroutine from outside bubble&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 唤醒</span></span><br><span class="line">readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">s = next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-3">6.6 总结</h2><pre class="mermaid">graph TB    A[sync.Cond 核心机制]    A --> B[Ticket 系统<br/>wait & notify]    A --> C[三步原子操作<br/>Add→Unlock→Wait]    A --> D[按序唤醒<br/>FIFO]    B --> E[防止丢失唤醒]    C --> F[保证 happens-before]    D --> G[公平性]    style A fill:#ffcccc    style B fill:#e1f5ff    style C fill:#fff4e1    style D fill:#ccffcc</pre><p><code>sync.Cond</code> 的核心设计：</p><ul><li><strong>Ticket 系统</strong>：基于票号的通知机制，防止丢失唤醒</li><li><strong>三步原子操作</strong>：Add→Unlock→Wait，顺序不能错</li><li><strong>必须循环 Wait</strong>：防止虚假唤醒和竞态条件</li><li><strong>关联 Locker</strong>：Wait 自动释放和重新获取锁</li></ul><h1 id="排查锁异常问题">7. 排查锁异常问题</h1><h2 id="锁拷贝-go-vet">7.1 锁拷贝 go vet</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := sync.Mutex&#123;&#125;</span><br><span class="line">m.Lock()</span><br><span class="line">n := m <span class="comment">// n 拷贝 m</span></span><br><span class="line">m.Unlock()</span><br><span class="line">n.Lock()  <span class="comment">// 这里会报错，因为 n 在拷贝 m 的时候，把它已经 lock 的状态也拷贝了</span></span><br></pre></td></tr></table></figure><p>这个时候，可以用 Go 提供的 <code>go vet</code>工具来检查是否存在锁拷贝问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ go vet main.go</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">command-line-arguments</span></span><br><span class="line">./main.go:16:7: assignment copies lock value to n: sync.Mutex</span><br></pre></td></tr></table></figure><blockquote><p><code>go vet</code> 还能检测可能的 bug 和可疑的构造。</p></blockquote><h2 id="数据竞争问题---go-build--race">7.2 数据竞争问题 - go build-race</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处 i 有并发问题</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i *<span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">*i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="type">int32</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> add(&amp;c)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，可以用 Go 提供的 <code>go build -race</code>工具来检查是否存在数据竞争问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  go build -race main.go</span><br><span class="line">➜  ./main</span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Read at 0x00c000124000 by goroutine 7:</span><br><span class="line">  main.add()</span><br><span class="line">      /Users/hedon-/goProjects/leetcode/go_advance/13-mutex/atomic/main.go:6 +0x3a</span><br><span class="line"></span><br><span class="line">Previous write at 0x00c000124000 by goroutine 6:</span><br><span class="line">  main.add()</span><br><span class="line">      /Users/hedon-/goProjects/leetcode/go_advance/13-mutex/atomic/main.go:6 +0x4e</span><br><span class="line"></span><br><span class="line">Goroutine 7 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/hedon-/goProjects/leetcode/go_advance/13-mutex/atomic/main.go:12 +0x84</span><br><span class="line"></span><br><span class="line">Goroutine 6 (finished) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/hedon-/goProjects/leetcode/go_advance/13-mutex/atomic/main.go:12 +0x84</span><br><span class="line">==================</span><br><span class="line">Found 1 data race(s)</span><br></pre></td></tr></table></figure><h2 id="死锁-go-deadlock">7.3 死锁 go-deadlock</h2><ul><li>https://github.com/sasha-s/go-deadlock</li></ul><h1 id="再次看-go-锁的两大基础">8. 再次看 Go 锁的两大基础</h1><p>在分析完 Go 的各种并发工具之后，相信不少读者都能理解为什么 atomic 和sema 是 Go 锁的两大基础了。</p><pre class="mermaid">graph TB    subgraph "用户层并发工具"        Mutex[sync.Mutex]        RWMutex[sync.RWMutex]        WaitGroup[sync.WaitGroup]        Cond[sync.Cond]        Once[sync.Once]        Pool[sync.Pool]        Chan[Channel]    end    subgraph "Runtime 基础原语"        Atomic[Atomic 原子操作]        Sema[Semaphore<br/>sleep/wakeup]    end    Mutex --> Atomic    Mutex --> Sema    RWMutex --> Atomic    RWMutex --> Sema    WaitGroup --> Atomic    WaitGroup --> Sema    Cond --> Sema    Once --> Atomic    Pool --> Atomic    Chan --> Atomic    Chan --> Sema    style Atomic fill:#ffcccc    style Sema fill:#e1f5ff</pre><p>还是前面那句话：</p><blockquote><p>[!IMPORTANT]</p><p>atomic 提供无锁的快速状态管理（CAS、加减），sema 提供有竞争时的goroutine 休眠/唤醒机制，两者组合实现"乐观尝试 +悲观等待"的高效并发模型。</p></blockquote><pre class="mermaid">graph LR    subgraph "性能层级"        A[atomic<br/>纳秒级<br/>99% 场景]        B[sema<br/>微秒级<br/>1% 竞争]    end    A -->|无竞争| Fast[Fast Path]    A -->|低竞争<br/>自旋| Spin[Spin]    B -->|高竞争| Slow[Slow Path<br/>休眠/唤醒]    style A fill:#ccffcc    style B fill:#e1f5ff    style Fast fill:#90EE90    style Slow fill:#FFB6C1</pre><p>这里笔者再次梳理下各个并发工具的如何运用 atomic 和 sema 的：</p><ul><li><p><code>sync.Mutex</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="type">int32</span>   <span class="comment">// ← Atomic 操作的目标</span></span><br><span class="line">    sema  <span class="type">uint32</span>  <span class="comment">// ← Semaphore 使用的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock 流程：</span></span><br><span class="line"><span class="comment">// 1. atomic.CAS(state, 0, 1)           ← Atomic 快速路径</span></span><br><span class="line"><span class="comment">// 2. 失败 → 自旋 + atomic 操作          ← Atomic 重试</span></span><br><span class="line"><span class="comment">// 3. 还失败 → semacquire(&amp;sema)        ← Semaphore 休眠</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock 流程：</span></span><br><span class="line"><span class="comment">// 1. atomic.Add(state, -1)             ← Atomic 快速路径</span></span><br><span class="line"><span class="comment">// 2. 有等待者 → semrelease(&amp;sema)      ← Semaphore 唤醒</span></span><br></pre></td></tr></table></figure></li><li><p><code>sync.RWMutex</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Atomic: 管理 state（锁定/唤醒/饥饿/等待者）</span><br><span class="line">Sema:   竞争时休眠/唤醒</span><br></pre></td></tr></table></figure></li><li><p><code>sync.WaitGroup</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Atomic: 管理 reader 计数和 writer 等待标志</span><br><span class="line">Sema:   writer 等待、reader 等待（两个独立的 sema）</span><br></pre></td></tr></table></figure></li><li><p><code>sync.Once</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Atomic: 管理缓冲区索引、状态标志</span><br><span class="line">Sema:   发送/接收阻塞时休眠/唤醒</span><br></pre></td></tr></table></figure></li><li><p><code>sync.Cond</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Atomic: 管理计数器（Add/Done）</span><br><span class="line">Sema:   Wait() 时如果计数 &gt; <span class="number">0</span> 则休眠</span><br></pre></td></tr></table></figure></li><li><p><code>Channel</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Atomic: (底层 Mutex 用)</span><br><span class="line">Sema:   Wait() 休眠，Signal/Broadcast 唤醒</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">本文深入剖析 Go 语言中多种锁（Mutex、RWMutex、WaitGroup、Once、Cond）的底层实现原理，结合 atomic 原子操作与 sema 信号量机制，揭示锁的本质和并发安全保障机制，帮助读者以第一性原理理解 Go 并发锁的内部运作。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="锁" scheme="https://hedon.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Go 底层原理丨垃圾回收（green tea gc）</title>
    <link href="https://hedon.top/2025/11/19/go/go-gc-green-tea-gc/"/>
    <id>https://hedon.top/2025/11/19/go/go-gc-green-tea-gc/</id>
    <published>2025-11-19T13:30:00.000Z</published>
    <updated>2025-12-15T06:05:56.066Z</updated>
    
    <content type="html"><![CDATA[<p>前篇 <a href="https://hedon.top/2025/11/17/go/go-gc/">Go底层原理丨垃圾回收（三色标记法）</a>我们详细介绍了截止 Go1.25 版本中 Go一直使用的基于三色标记法的垃圾回收算法。在 2025 年 10 月 29 日 Go官方博客发布了一篇 <a href="https://go.dev/blog/greenteagc">The GreenTea Garbage Collector</a> 介绍了其将在 Go1.26版本默认开启的最新垃圾回收算法，当然，在 Go1.25 也可以通过<code>GOEXPERIMENT=greenteagc</code> 实验标识提前开启进行体验。</p><p>推荐可以提前看一遍 Go 官方成员在 Youtube 发布的对 Green Tea GC的基本介绍视频：</p><div class="tag-plugin video" style="aspect-ratio:1.7777777777777777;max-width:100%;">    <iframe style="border:none" src="https://www.youtube.com/embed/gPJkM95KpKo?rel=0&disablekb=1&playsinline=1&autoplay=0" picture-in-picture="true" allowfullscreen="true" >    </iframe>    </div>    <p>本篇将基于上面的视频和我跟 Gemini 2.5Pro的探讨，尝试从第一性原理来理解为什么要设计 Green Tea GC算法、以及其底层是如何实现的。</p><p>这里先给出结论：</p><blockquote><p>[!IMPORTANT]</p><p>针对传统 GC 随机指针追逐导致频繁 CPU Cache Miss 的问题，Green Tea GC采取 <strong>利用 FIFO 队列延迟累积、将操作粒度从单对象提升至物理连续Span</strong>的方法，达到将随机访问转化为缓存友好的批量顺序扫描、通过最大化空间局部性大幅提升吞吐量的效果。</p></blockquote><h2 id="冯诺依曼瓶颈与现代计算的微架构危机">1.冯·诺依曼瓶颈与现代计算的微架构危机</h2><p>在过去二十年的高性能计算演进中，硬件架构的发展呈现出一种极不均衡的态势。虽然摩尔定律在晶体管密度和核心数量上的预测在很大程度上得以维持，但动态随机存取存储器（DRAM）的访问延迟并未随之线性缩减。这种处理器时钟速度与内存访问速度之间日益扩大的差距，被称为<strong>内存墙（MemoryWall）</strong>。对于像 Go语言这样依赖自动内存管理的现代编程语言而言，内存墙已不再是一个理论上的瓶颈，而是阻碍吞吐量提升的物理现实。</p><p>传统的垃圾回收算法，特别是 Go长期采用的三色并发标记清除算法，在本质上是图论中的遍历问题。算法将堆内存视为一个抽象的图，节点是对象，边是某种形式的指针引用。虽然这种抽象在数学上是优雅的，但在物理实现上，它与现代CPU 的缓存层次结构（L1、L2、L3Cache）和转换后备缓冲器（TLB）不仅不兼容，甚至常常处于对立状态。根据 Go核心团队的分析，<u>传统的 GC 扫描循环中，超过 35% 的 CPU周期并不是在执行有效的标记指令，而是完全停滞，处于等待内存数据从主存取回的"空转"状态</u>。</p><p>随着 Go 1.25 实验性功能的发布，一种代号为 Green Tea的全新垃圾回收架构应运而生。该算法标志着 Go运行时设计哲学的一个根本性转变：从关注抽象的对象图遍历效率，转向对底层物理内存布局的极致利用。本篇将对Green Tea算法进行详尽的技术拆解，分析其如何通过以"页"（Page）或"跨度"（Span）为中心的扫描机制、先进的位图差分算法以及对FIFO（先进先出）工作队列的创新利用，来系统性地瓦解内存墙带来的性能桎梏。</p><h2 id="传统标记-清除算法的微架构缺陷分析">2.传统标记-清除算法的微架构缺陷分析</h2><p>要理解 Green Tea算法的革命性，必须首先深入剖析传统算法在现代硬件上的病理表现。Go 现有的GC 采用的是基于对象的图洪泛（GraphFlood）算法。在这个过程中，垃圾回收器从根对象（栈、全局变量）出发，递归地追踪所有可达的指针。</p><h3 id="城市街道困境与随机访问代价">2.1"城市街道"困境与随机访问代价</h3><p>Go 团队将传统 GC 的内存访问模式形象地比喻为"城市街道"（CityStreets）上的导航。在这种模式下，内存访问具有高度的随机性和不可预测性：</p><ol type="1"><li><strong>空间局部性的缺失</strong>：在堆内存中，逻辑上相互引用的对象（例如链表中的节点或树结构）在物理地址空间中往往是不连续的。当GC追踪一个指针时，它往往需要跳转到一个完全不同的内存页。<u>这种跳转导致了CPU 缓存行的频繁失效（CacheMiss），因为加载包含当前对象的缓存行对于处理下一个对象毫无帮助</u>。</li><li><strong>延迟链（LatencyChains）效应</strong>：在图遍历过程中，只有当当前对象被加载并解析后，GC才能知道下一个需要扫描的对象的地址。这种严格的数据依赖性使得现代 CPU强大的乱序执行（Out-of-Order Execution）和硬件预取（HardwarePrefetching）机制失效。CPU无法推测下一个地址在哪里，因此无法提前将数据拉入缓存。</li><li><strong>TLB 抖动</strong>：频繁的跨页访问不仅影响数据缓存，还会对TLB 造成巨大压力，导致虚拟地址到物理地址的转换延迟显著增加。</li></ol><h3 id="停顿周期的量化分析">2.2 停顿周期的量化分析</h3><p>根据 GitHub 上关于 Go 运行时问题的详细追踪（Issue73581），这种随机访问模式导致 GC扫描循环的效率极低。在总体的垃圾回收时间中，约 85%被消耗在扫描循环（Scan Loop）中，而在这些宝贵的计算时间内，<u>CPU实际上有超过三分之一的时间是在空等数据</u>。这种微架构层面的低效，意味着单纯增加CPU 核心数或提高主频，已无法线性地提升 GC的性能，因为瓶颈已经转移到了内存子系统。</p><h2 id="green-tea-的核心架构从对象中心到跨度中心">3. Green Tea的核心架构：从对象中心到跨度中心</h2><p>Green算法的核心假设是：通过牺牲图遍历的即时性（即不立即处理发现的指针），转而对内存操作进行批量化管理，可以重建内存访问的空间局部性。这一策略将GC的基本操作单元从单个"对象"提升到了物理上连续的内存块——"跨度"（Span），即我们上篇提到的<code>scanspan()</code>。</p><h3 id="跨度span与小对象特化策略">3.1 跨度（Span）与小对象特化策略</h3><p>在 Go 的内存分配器中，跨度是管理内存的基本单位，通常是 8 KiB的倍数。Green Tea 算法并非全盘替代现有的GC，而是一个针对特定问题的特化增强。它专门针对"小对象"（SmallObjects，定义为大小不超过 512 字节）进行优化。</p><p>为何专注于小对象？</p><p>大对象通常占据较大的连续内存空间，其扫描过程天然具有一定的顺序性。然而，小对象是造成内存碎片化和指针跳跃的主要元凶。在一个8 KiB 的页面中，可能挤满了数百个 32字节的小对象。如果按照传统的图遍历方式，GC可能会在这个页面访问一个对象，然后跳到几 GB外的另一个页面，稍后又跳回来访问该页面的另一个对象。这种反复横跳是缓存杀手。</p><p>Green Tea 算法强制将处理粒度对齐到 8 KiB的跨度上。对于小对象，算法不再维护对象的全局工作列表，而是维护<code>包含待扫描对象 span</code> 列表。由于这些 <code>span</code> 是严格8 KiB 对齐的，GC可以通过简单的指针算术（掩码操作）快速定位元数据，而无需昂贵的查表操作或依赖性内存加载。</p><h3 id="位图差分与惰性累积">3.2 位图差分与惰性累积</h3><p>在技术演示视频的 15:39 处，展示了 Green Tea算法最核心的机制：基于页面的元数据管理和位图差分逻辑。这是一个精妙的设计，旨在最大化单次内存加载的有效工作量。</p><p>传统的 GC 使用标记位来记录对象是否存活。而 Green Tea引入了更复杂的双位图系统，对于 <code>span</code>中的每个对象槽位，维护两个状态位：</p><ol type="1"><li><strong>SeenBit（已见位）</strong>：表示该对象已被其他存活对象引用，即它是可达的。在三色标记法中，这相当于对象被染成了“灰色”。</li><li><strong>Scanned Bit（已扫位）</strong>：表示该对象不仅可达，而且 GC已经扫描了该对象内部包含的所有指针。在三色标记法中，这相当于对象被染成了黑色。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/greentea-060.png" /></p><p>工作流程与逻辑推导：</p><p>当 GC发现一个指向小对象的指针时，它不会立即递归扫描该对象，而是执行以下操作：</p><ol type="1"><li><strong>设置 SeenBit</strong>：在目标对象所属跨度的元数据中，将对应的 Seen Bit 置为<code>1</code>。</li><li><strong>入队检查</strong>：检查该跨度是否已经在工作队列中。如果不在，则将整个<code>span</code> 推入工作队列。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/greentea-066.png" /></p><p>当工作线程最终从队列中取出该跨度时，算法执行一种差分操作来确定需要做哪些工作。在15:39 的示例中，演示者通过页面 A 的状态展示了这一逻辑：</p><ul><li><strong>计算 Delta</strong>：待处理对象集合 <spanclass="math inline">\(O\)</span> 等于 <spanclass="math inline">\(Seen\)</span> 位图与 <spanclass="math inline">\(Scanned\)</span>位图的差集。用布尔代数表示为：<span class="math inline">\(O = Seen \land(\neg Scanned)\)</span>。</li><li><strong>批量处理</strong>：算法仅扫描那些 <spanclass="math inline">\(Seen\)</span> 为 1 且 <spanclass="math inline">\(Scanned\)</span> 为 0 的对象。</li><li><strong>状态更新</strong>：扫描完成后，将 <spanclass="math inline">\(Seen\)</span> 位图的状态复制到 <spanclass="math inline">\(Scanned\)</span> 位图中，即 <spanclass="math inline">\(Scanned \leftarrow Seen\)</span>。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251119222527760.png" /></p><p>惰性累积（Lazy Accumulation）的价值：</p><p>这种机制的关键在于“延迟”。由于跨度在队列中停留了一段时间，当它被取出处理时，可能已经有多个对象被标记为<code>Seen</code>。例如，演示中提到在处理页面 A时，一次性处理了三个对象。这意味着加载该页面元数据的昂贵开销被这三个对象分摊了。更重要的是，如果在这期间有重复的引用指向同一个对象，差分逻辑会自动忽略已处理的对象，天然避免了重复扫描。</p><h3 id="先进先出fifo队列与高速公路效应">3.3先进先出（FIFO）队列与"高速公路"效应</h3><p>为了最大化上述的惰性累积效应，Green Tea算法颠覆了传统深度优先搜索（DFS）常用的后进先出（LIFO/Stack）模式，转而采用先进先出（FIFO/Queue）模式。</p><ul><li><strong>LIFO 的局限</strong>：虽然 LIFO 有助于保持 CPU缓存的热度（刚发现的对象立即被处理），但在图结构松散的堆内存中，这种局部性往往是虚幻的。</li><li><strong>FIFO 的优势</strong>：FIFO强制让跨度在队列中"陈酿"。在跨度等待被调度的过程中，应用程序和其他 GC线程可能会发现更多指向该跨度内对象的指针。当该跨度最终被处理时，其工作密度达到了最大化。</li></ul><p>这种策略将零散的内存访问转化为连续的、高密度的内存操作流。Go团队将其比喻为从"城市街道"驶上了"高速公路"（Highway）。在高速公路上，车辆（内存操作）首尾相接，全速前行。通过处理整个页面，GC能够利用 CPU的预取器，连续加载相邻的缓存行，极大地提升了内存带宽的利用率。</p><p>下表详细对比了传统图洪泛策略与 Green Tea内存感知策略的关键技术指标：</p><table><colgroup><col style="width: 18%" /><col style="width: 39%" /><col style="width: 42%" /></colgroup><thead><tr><th><strong>特性维度</strong></th><th><strong>传统图洪泛 GC (Go 1.24 及以前)</strong></th><th><strong>绿茶 GC (Go 1.25 实验性)</strong></th></tr></thead><tbody><tr><td><strong>基本调度单元</strong></td><td>单个对象 (Object)</td><td>内存跨度 (Span / 8 KiB Page)</td></tr><tr><td><strong>遍历顺序</strong></td><td>LIFO (栈) / 近似深度优先</td><td>FIFO (队列) / 广度优先延迟处理</td></tr><tr><td><strong>内存访问模式</strong></td><td>随机跳跃 (城市街道)</td><td>批量连续 (高速公路)</td></tr><tr><td><strong>元数据位置</strong></td><td>全局或分散在对象头</td><td>集中在跨度元数据区</td></tr><tr><td><strong>缓存利用策略</strong></td><td>依赖时间局部性 (Temporal Locality)</td><td>强制构建空间局部性 (Spatial Locality)</td></tr><tr><td><strong>主要性能瓶颈</strong></td><td>内存延迟 (Latency)</td><td>内存带宽 (Bandwidth)</td></tr><tr><td><strong>适用场景</strong></td><td>通用，对大对象友好</td><td>特化针对小对象密集型场景</td></tr></tbody></table><h3 id="针对单对象的微优化代表对象与命中标志">3.4针对单对象的微优化：代表对象与命中标志</h3><p>尽管页面级扫描在大规模数据下效率极高，但在某些边缘情况（例如一个跨度中仅有一个活跃对象）下，加载整个页面元数据的开销可能超过直接扫描对象的收益。为了解决这个问题，研发团队引入了"代表对象"（Representative）和"命中标志"（HitFlag）机制。</p><ul><li><strong>代表对象</strong>：当一个跨度第一次被加入队列时，触发该操作的那个特定对象被记录为"代表"。</li><li><strong>命中标志</strong>：如果在该跨度等待期间，有第二个不同的对象被标记为Seen，则设置"命中标志"。</li><li><strong>快速路径</strong>：当工作线程取出跨度时，首先检查命中标志。如果标志未设置，说明该跨度仅有一个待处理对象。此时，GC会跳过复杂的位图差分计算，直接扫描"代表对象"。这种回退机制确保了 GreenTea 算法在最坏情况下的性能也能逼近传统算法。</li></ul><h2 id="生产环境的现实性能收益与延迟倒挂">4.生产环境的现实：性能收益与延迟倒挂</h2><p>Green Tea算法并非银弹，其在真实生产环境中的表现呈现出复杂的权衡关系。根据 Google内部及早期采用者的反馈，该算法在 CPU吞吐量和请求延迟之间引入了新的变量。</p><h3 id="吞吐量的显著提升">4.1 吞吐量的显著提升</h3><p>在基准测试和大规模内存密集型应用中，Green Tea算法展现了强大的吞吐量优势。报告显示，GC 阶段的 CPU 消耗总体减少了 10%到 40%。对于拥有数万台服务器的超大规模数据中心而言，这种 CPU效率的提升直接转化为巨大的硬件成本节省和能源效率优化。这验证了解决"内存墙"问题对于提升现代软件性能的决定性作用。</p><h3 id="延迟倒挂现象">4.2 延迟倒挂现象</h3><p>然而，InfoQ 和 Github Issue 73581中的讨论揭示了一个反直觉的现象：部分应用在启用<code>GOEXPERIMENT=greenteagc</code> 后，虽然 GC运行的频率降低了，但单次 GC 循环的 CPU占用率却上升了，导致应用程序的长尾延迟（Tail Latency）恶化。</p><p><strong>原因分析：</strong></p><ol type="1"><li><strong>工作的突发性</strong>：由于 FIFO队列和惰性累积机制，当一个跨度最终被处理时，它可能包含了大量积累的工作。处理一个包含数百个对象的跨度，远比处理单个对象要耗时。这种批处理特性导致了GC 工作的突发性增强。</li><li><strong>应用层的感知</strong>：虽然总的 GC时间变短了，但这种高密度的 CPU占用可能会在短时间内挤占应用逻辑（Mutator）的计算资源，特别是在GOMAXPROCS 限制较紧的容器环境中。</li><li><strong>调度器争用</strong>：Green Tea采用了分布式的工作窃取（Work-Stealing）队列来替代全局锁，虽然减少了锁竞争，但在某些负载下，跨核的工作窃取可能会导致缓存一致性流量增加。</li></ol><p>针对这一问题，Go 团队已经在着手优化，预计在 Go 1.26版本中通过调整批处理的粒度和队列调度的启发式算法来平滑这种延迟尖峰。</p><h3 id="容器环境下的微架构干扰">4.3 容器环境下的微架构干扰</h3><p>社区反馈还指出，在 Docker 等容器化环境中，CPU 配额（CPUQuota）的设置可能会干扰 GC 的行为。在 Go 1.25之前，<code>GOMAXPROCS</code>默认是基于宿主机的逻辑核心数，而非容器的配额。这导致在受限容器中，GC线程可能会因为争抢时间片而加剧延迟。Green Tea算法的高密度计算特性可能会放大这种资源争夺，特别是在 CPU节流（Throttling）发生时。因此，配合 <code>uber-go/automaxprocs</code>等库正确设置线程数，对于发挥 Green Tea 算法的优势至关重要。</p><h2 id="代码生成与编译器级的微优化">5. 代码生成与编译器级的微优化</h2><p>除了运行时的架构调整，Green Tea算法的引入还伴随着编译器层面的深度优化。GitHub Issue 76212揭示了一个关于 <code>heapBitsSmallForAddrInline</code>函数的优化细节。</p><p>在扫描小对象的热路径（Hot Path）中，<code>scanObjectsSmall</code>函数会频繁调用 <code>heapBitsSmallForAddrInline</code>来获取对象的元数据位。在早期的实现中，这个内联函数包含了一些重复计算。由于在处理同一个<code>span</code>时，基地址和对象大小是固定不变的，编译器团队通过手动将这些循环不变量（LoopInvariants）提取到循环外部，消除了冗余的指令执行。</p><p>这种微优化虽然在代码层面看似微不足道，但在每秒执行数十亿次的 GC循环中，它对指令流水线的通畅起到了关键作用。基准测试显示，这种手动提升（Hoisting）在多种架构上都带来了统计学上显著的性能提升，且没有引起回归。这体现了系统编程中毫秒必争的优化哲学。</p><h2 id="为什么叫-green-tea">6. 为什么叫 Green Tea</h2><p>在计算机科学的历史中，重大的架构变革往往伴随着富有轶事色彩的命名。GreenTea 也不例外。该项目的命名并非源自任何技术缩写，而是源自其主要设计者Austin Clements 的一段生活经历。</p><p>2024 年，Go 团队的技术负责人 Austin Clements在日本期间，构思并开发了该算法的早期原型。为了验证基于跨度的扫描是否可行，他需要在不同的咖啡馆之间穿梭工作（CafeCrawling）。据 Austin本人回忆，在攻克算法核心难题的那段时间里，他摄入了大量的抹茶（Matcha）。这种富含咖啡因的绿茶（GreenTea）成为了项目诞生的燃料。</p><p>当原型证明了核心想法的可行性后，Green Tea这个代号便自然而然地保留了下来，成为了 Go语言对抗内存墙这一技术挑战的文化符号。这与 Java 的"Oak"（橡树）或Android 的甜点命名传统一脉相承，赋予了冷冰冰的代码以人文温度。</p><h2 id="硬件协同的未来simd-与向量化">7. 硬件协同的未来：SIMD与向量化</h2><p>Green Tea算法的跨度中心设计，不仅解决了当前的缓存问题，更为未来的硬件加速铺平了道路。其中最令人兴奋的前景是利用单指令多数据（SIMD）指令集（如x86 的 AVX-512 或 ARM64 的 NEON）来加速垃圾回收。</p><h3 id="向量化的可能性">7.1 向量化的可能性</h3><p>在传统的对象图遍历中，由于内存地址的随机性，根本无法利用 SIMD指令。你无法向量化一个随机游走（Random Walk）的过程。然而，Green Tea算法改变了这一局面：</p><ul><li><strong>连续的元数据</strong>：Seen 和 Scanned位图在内存中是连续存储的。这意味着 15:39 演示中的位图差分操作（AND, OR,XOR）可以被简单地映射为向量指令。一条 512 位的 AVX-512指令可以在单个时钟周期内处理数百个对象的状态更新。</li><li><strong>扫描内核的加速</strong>：除了元数据处理，核心团队还在探索使用SIMD来加速扫描内核本身。通过将多个指针的检查并行化，可以进一步压缩扫描时间。</li></ul><h3 id="集中器网络concentrator-network">7.2 集中器网络（ConcentratorNetwork）</h3><p>GitHub Issue 73581中还提到了一个更具野心的构想——使用"集中器网络"。这是一个排序网络，旨在提高指针的密度。通过在内存中重新排列指针或元数据，使其更加紧凑，可以为SIMD指令提供更高效的数据输入，从而在元数据操作之外，也能利用向量化加速。尽管由于复杂性原因，这一特性尚未包含在当前的实验版本中，但它指明了Go 运行时未来的演进方向：极致的硬件亲和性。</p><h2 id="结论与展望">8. 结论与展望</h2><p>Go 1.25 引入的 Green Tea垃圾回收算法，不仅是一次运行时的升级，更是对高性能计算未来趋势的一次深刻回应。它承认了在内存墙面前，算法的理论纯洁性必须向硬件的物理现实低头。</p><p>通过将分析单元从对象转移到跨度，并采用 FIFO 驱动的惰性累积策略，GreenTea成功地将垃圾回收过程中混乱的随机访问（城市街道）转化为高效的顺序流（高速公路）。15:39演示中的位图差分机制，以其简洁的逻辑展示了这种架构的优雅——不是通过复杂的图论技巧，而是通过对CPU 缓存层次结构的极致尊重来消除冗余工作。</p><p>尽管目前仍存在延迟倒挂等需要微调的工程挑战，但 Green Tea架构所展现出的 10-40% 的 CPU 节约潜力，以及其对 NUMA 架构和 SIMD指令集的天然亲和力，使其成为 Go语言在后摩尔定律时代保持竞争力的关键基石。随着 Go 1.26及后续版本的迭代，我们有理由相信，这种内存感知的 GC设计将成为管理语言运行时的新标准。</p><p>对于开发者而言，理解 Green Tea 不仅仅是为了调整 <code>GOGC</code> 或<code>GOMAXPROCS</code>参数，更是为了理解现代软件工程的一个核心真理：软件的性能极限，最终取决于它对底层硬件的理解与尊重。</p>]]></content>
    
    
    <summary type="html">本文基于 Go 官方资料和社区解读，全面分析 Go 1.26 起默认启用的 Green Tea GC 垃圾回收机制，包括其解决 CPU Cache Miss 的核心原理、算法的微架构优化设计、对开发实务和未来硬件的深远影响，帮助读者理解新 GC 的革命性变革。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="垃圾回收" scheme="https://hedon.top/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    <category term="GreenTea" scheme="https://hedon.top/tags/GreenTea/"/>
    
  </entry>
  
  <entry>
    <title>Go 底层原理丨垃圾回收（三色标记法）</title>
    <link href="https://hedon.top/2025/11/17/go/go-gc-tri-color-marking/"/>
    <id>https://hedon.top/2025/11/17/go/go-gc-tri-color-marking/</id>
    <published>2025-11-17T07:30:00.000Z</published>
    <updated>2025-12-12T04:17:27.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>特此声明，本篇是笔者基于 Go 1.25.3 版本源码、并与 Google Gemini 3Pro共创所作，非常庆幸在当今 AI时代下获取知识已是如此便利，且也为学习者从第一性原理理解所学知识大大降低了门槛。不过本篇的篇章安排和叙述逻辑，均由笔者把控和审阅，欢迎放心阅读。</p></blockquote><h2 id="垃圾回收">1. 垃圾回收</h2><p>抛开具体的语言，垃圾回收（GC）在计算机科学中解决的核心问题只有一个：<strong>对象生命周期的自动化管理</strong>。</p><p>如果手动管理内存（如 C/C++ 的<code>malloc/free</code>），我们面临的是由于"人为疏忽"导致的两个极端错误：</p><ul><li><strong>悬挂指针（DanglingPointer）</strong>：过早释放，导致后续访问出错。</li><li><strong>内存泄漏（MemoryLeak）</strong>：忘记释放，导致资源耗尽。</li></ul><p>GC的出现，是为了将"判断内存是否不再使用"这个逻辑，从<strong>业务代码</strong>剥离，下沉到<strong>运行时（Runtime）</strong>。</p><p>从大的方面来讲，实现垃圾回收主要是要解决 2 个问题：</p><ol type="1"><li>怎么判断哪些对象是垃圾？</li><li>如何清理垃圾？</li></ol><h3 id="垃圾搜索算法">1.1 垃圾搜索算法</h3><p>从原理上讲，一个对象被判定为垃圾，意味着<strong>当前程序的后续执行中，再也无法访问到它了</strong>。这在计算机科学中被称为对象存活性（ObjectLiveness）问题。</p><p>主要有 2 个思路：引用计数法和可达性分析。</p><h4 id="引用计数法">1.1.1 引用计数法</h4><ul><li>给每个对象贴一个计数器。只要有一个地方引用它，计数器就+1；引用失效（比如指针置空或离开作用域），计数器就-1。当计数器归零时，该对象即为垃圾。一旦变成垃圾，立刻就能被回收，不需要等待特定的GC 时间点。</li><li>但是存在<strong>循环引用</strong>的缺陷：假如对象 A 引用 B，B 也引用A，除此之外没有其他人引用它们。虽然它们在外部已经无法访问（本质是垃圾），但它们互相揪着对方，计数器永远是1，导致内存泄漏。</li><li>CPython（Python 的解释器）的主力 GC机制就是引用计数，但它配合了"标记-清除"来专门处理循环引用问题。PHP 和C++ 的 <code>std::shared_ptr</code> 也是基于此思路。</li></ul><h4 id="可达性分析">1.1.2 可达性分析</h4><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5upnu7sa5j21fg0laq4k.jpg" /></p><ul><li>从根（GCRoots）节点向下搜索对象节点，搜索走过的路经称为引用链，当一个对象到根之间没有连通的话，则对象不可用。</li><li>可以作为 GC Roots的对象通常是指那些<strong>肯定在使用中</strong>的对象：<ul><li>被栈上的指针引用；</li><li>被全局变量的指针引用；</li><li>被寄存器中的指针引用；</li></ul></li><li>可达性分析的核心挑战是在遍历过程中，如果程序还在运行（对象引用关系在变），图就在变，怎么保证准确性？传统的做法是<strong>STW (Stop The World)</strong>，暂停所有用户线程专门来做GC。现代的做法是 <strong>三色标记法 (Tri-color Marking)</strong>（如 Go语言），允许 GC线程和用户线程并发运行，用读写屏障（Barrier）技术来修正并发带来的标记误差，从而尽可能减少STW 的时长。</li></ul><h3 id="垃圾回收算法">1.2 垃圾回收算法</h3><p>找出了垃圾，下一步就是回收内存。这里的核心矛盾是：<strong>效率</strong>vs <strong>空间碎片</strong>。</p><h4 id="标记清理法">1.2.1 标记清理法</h4><p>算法分成 <strong>标记</strong> 和 <strong>清除</strong>两个阶段，先标记出要回收的对象，然后统一回收这些对象。</p><ul><li>简单。</li><li>效率不高，标记和清除的效率都不高。</li><li>标记清除后会产生大量不连续的内存碎片，从而导致在分配大对象时触发GC。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5upp3jgc0j21b00mmt8y.jpg" /></p><blockquote><p>Go 使用的就是标记清除法</p><p>虽然普通的标记清除法会造成内存碎片的问题，但是由于 Go的内存模型中，将内存天然划分成多个 span，所以不存在内存碎片问题。故 Go用了这种实现简单的标记清除法。对于 Go 内存模型不熟悉的读者，可参阅：<ahref="https://hedon.top/2025/11/17/go/go-memory-model/">Go底层原理丨内存模型</a>。</p></blockquote><h4 id="标记复制法">1.2.2 标记复制法</h4><p>把内存分成<strong>两块完全相同的区域</strong>，每次使用其中一块，当一块使用完了，就把这块上还存活的对象拷贝到另外一块，然后把这块清除掉。</p><ul><li>实现简单、运行高效，不用考虑内存碎片的问题。</li><li>内存有些浪费。</li></ul><blockquote><p>JVM 实际实现中，是将内存分为一块较大的 Eden 区和两块较小的 Survivor空间，每次使用 Eden 和一块 Survivor，回收时，把存活的对象复制到另外一块Survivor。</p><p>HotSpot 默认的 Eden 和 Survivor 比是 8:1，也就是每次能用 90%的新生代空间。</p><p>如果 Survivor空间不够，就要依赖老年代进行分配担保，把放不下的对象直接进入老年代。</p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5upp2o16yj21au0m60sy.jpg" /></p><h4 id="标记整理法">1.2.3 标记整理法</h4><p>标记过程跟标记清除一样，但后续不是直接清除可回收对象，而是让所有存活对象都向一端移动，然后直接清除边界以外的内存。</p><blockquote><p>标记整理法的开销较大，Java 的老年代就采用标记整理法，因为老年代的 GC频率较低。</p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5upp1xvtvj21580lqgnd.jpg" /></p><h2 id="宏观概述">2. 宏观概述</h2><p>在对 GC 有了一个简单的了解之后，我们先来详细了解 Go语言的垃圾回收机制的宏观详细设计，在下一章节我们将在 AI的帮助下，深入源码（Go1.25.3）去了解去背后的底层实现细节和那些令人叹为观止的优化思路。</p><p>截止 Go1.25，Go 还是使用的<strong>三色标记法 + 并发标记清理法 +混合写屏障</strong>进行垃圾回收，Go 官方透露在 Go1.26 将默认开启 GreenTea GC，关于 Green Tea GC，将会在下篇进行详细展开。</p><h3 id="核心架构特征">2.1 核心架构特征</h3><ul><li><strong>并发标记-清扫</strong>（Concurrent Mark-Sweep）</li><li><strong>类型精确</strong>（TypeAccurate）：知道内存中哪些是指针</li><li><strong>写屏障</strong>（Write Barrier）：保证并发标记的正确性</li><li><strong>非分代</strong>（Non-generational）</li><li><strong>非压缩</strong>（Non-compacting）</li><li><strong>Per-P 分配</strong>：减少锁竞争</li></ul><h3 id="三色标记法">2.2 三色标记法</h3><h4 id="基本原理">2.2.1 基本原理</h4><p>Go 将对象用三种颜色来进行标记：</p><ul><li><strong>黑色</strong>：本对象已经被 GC访问过，且本对象的子引用对象也已经被访问过了</li><li><strong>灰色</strong>：本对象已访问过，但是本对象的子引用对象还没有被访问过，全部访问完会变成黑色，属于中间态</li><li><strong>白色</strong>：尚未被 GC访问过的对象，如果全部标记已完成依旧为白色的，称为不可达对象，既垃圾对象</li></ul><h4 id="基本步骤">2.2.2 基本步骤</h4><ol type="1"><li>起初所有堆上的对象都是【白色】的；</li><li>将 GC Roots 直接引用到的对象挪到【灰色】中；</li><li>对【灰色】的对象进行根搜索算法：<ol type="1"><li>将该对象引用到的其他对象加入【灰色】中；</li><li>将自己挪到【黑色】中；</li></ol></li><li>重复 3 直到【灰色】为空；</li><li>回收【白色】中的对象。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5uq7o58zlg20jm0cjjuv.gif" /></p><h4 id="删除屏障">2.2.3 删除屏障</h4><blockquote><p>并发标记时，对指针释放的白色对象置灰。</p></blockquote><p>这样可以避免在并发 GC 的过程中，由于指针的转移造成对象被误清。</p><p>比如一开始 B → C，当 B 在灰色集合的时候，释放了对 C的指针，但是这个时候有一个在黑色集合的 E 指向了 C，也就是 E → C。由于 E已经分析过了，所以在对 B 进行分析的时候，就会漏掉 C，导致后面 C还是在白色集合中，就被误清了。</p><p>加入删除屏障后，C 会被强制置灰，就不会误清了。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5uqiowdqbj21e80awgm4.jpg" /></p><h4 id="插入屏障">2.2.4 插入屏障</h4><blockquote><p>并发标记时，对指针新指向的白色对象置灰。</p></blockquote><p>这样可以避免在并发 GC 的过程中，误清掉指针新指向的对象。</p><p>比如一开始并没有指向 C 的对象，但是在 GC 过程中，E → C，但是由于 E已经分析过了，已经进入黑色集合了，所以最后会漏掉 C，导致 C 被误清。</p><p>加入插入屏障后，C 会被强制置灰，就不会误清了。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5uqkss0rnj21je0buaam.jpg" /></p><h3 id="gc-四阶段循环">2.3 GC 四阶段循环</h3><pre class="mermaid">graph TB    %% 定义样式    classDef stw fill:#ffcdd2,stroke:#c62828,stroke-width:2px,color:#b71c1c;    classDef concurrent fill:#e1f5fe,stroke:#0277bd,stroke-width:2px,color:#01579b;    classDef trigger fill:#fff9c4,stroke:#fbc02d,stroke-dasharray: 5 5,color:#f57f17;    %% 节点定义    subgraph Cycle [GC 循环周期]        direction TB        P1(Phase 1: Sweep Termination<br/>清扫终止):::stw        P2(Phase 2: Concurrent Mark<br/>并发标记):::concurrent        P3(Phase 3: Mark Termination<br/>标记终止):::stw        P4(Phase 4: Concurrent Sweep<br/>并发清扫):::concurrent    end    %% 触发条件    Trigger(GC Trigger<br/>堆阈值/定时/手动):::trigger    %% 连线关系    Trigger --> P1    P1 -->|开启写屏障<br/>SetGCPhase: _GCmark| P2    P2 -->|所有对象标记完成<br/>gcMarkDone| P3    P3 -->|关闭写屏障<br/>SetGCPhase: _GCoff| P4    P4 -->|清理结束 & 等待下一轮| Trigger    %% 补充说明    note1[STW: 准备根对象, 清理上一轮残余] -.-> P1    note2[STW: 保证全局标记完成, 必须全局一致] -.-> P3</pre><h3 id="gc-触发机制">2.4 GC 触发机制</h3><ul><li><strong>堆大小触发</strong>：GOGC=100 时，堆增长 100%触发（4M→8M）</li><li><strong>定时触发</strong>：sysmon 会定时检查，如果 2min 内没有进行gc，那 runtime 就会进行一次 gc。</li><li><strong>手动触发</strong>：<code>runtime.GC()</code></li></ul><h2 id="源码解析">3. 源码解析</h2><p>结论先行，整个 GC 的全景图如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    GC 周期完整流程                            │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">触发 GC (gcStart)</span><br><span class="line">    ├─ 检查触发条件 (gcTrigger.test)</span><br><span class="line">    │   ├─ gcTriggerHeap: heapLive &gt;= trigger</span><br><span class="line">    │   ├─ gcTriggerTime: 距上次GC &gt; 2分钟</span><br><span class="line">    │   └─ gcTriggerCycle: 手动触发</span><br><span class="line">    │</span><br><span class="line">    ├─ 完成上一轮扫描 (sweepone)</span><br><span class="line">    │</span><br><span class="line">    └─ === 阶段 1: 扫描终止 (STW) ===</span><br><span class="line">        ├─ stopTheWorld(stwGCSweepTerm)</span><br><span class="line">        ├─ finishsweep_m()      // 完成剩余扫描</span><br><span class="line">        ├─ clearpools()         // 清理 sync.Pool</span><br><span class="line">        └─ gcResetMarkState()   // 重置标记状态</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    阶段 2: 并发标记                           │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">    ├─ setGCPhase(_GCmark)      // 启用写屏障</span><br><span class="line">    ├─ gcBgMarkPrepare()         // 准备后台工作者</span><br><span class="line">    ├─ gcPrepareMarkRoots()      // 准备根对象扫描</span><br><span class="line">    ├─ atomic.Store(&amp;gcBlackenEnabled, 1)  // 启用标记</span><br><span class="line">    └─ startTheWorld()           // 恢复世界</span><br><span class="line"></span><br><span class="line">    并发执行：</span><br><span class="line">    ├─ 标记工作者 (gcBgMarkWorker)</span><br><span class="line">    │   ├─ Dedicated Worker: 专用标记</span><br><span class="line">    │   ├─ Fractional Worker: 分数标记</span><br><span class="line">    │   └─ Idle Worker: 空闲标记</span><br><span class="line">    │</span><br><span class="line">    ├─ Mutator Assist (gcAssistAlloc)</span><br><span class="line">    │   └─ 分配者协助标记以保持节奏</span><br><span class="line">    │</span><br><span class="line">    └─ 根对象扫描</span><br><span class="line">        ├─ 扫描所有 goroutine 栈</span><br><span class="line">        ├─ 扫描全局变量</span><br><span class="line">        └─ 扫描 finalizer 队列</span><br><span class="line"></span><br><span class="line">    工作循环：</span><br><span class="line">    └─ while (有灰色对象) &#123;</span><br><span class="line">        obj = gcw.tryGetObj()  // 从队列获取灰色对象</span><br><span class="line">        scanobject(obj, gcw)   // 扫描对象，标记引用</span><br><span class="line">        // 将新发现的灰色对象加入队列</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│              阶段 3: 标记终止检测 (gcMarkDone)                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">检测循环：</span><br><span class="line">    ├─ 条件: work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable</span><br><span class="line">    │</span><br><span class="line">    ├─ === Ragged Barrier ===</span><br><span class="line">    │   └─ forEachP: 刷新所有 P 的本地缓冲</span><br><span class="line">    │       ├─ wbBufFlush1(pp)   // 写屏障缓冲</span><br><span class="line">    │       └─ pp.gcw.dispose()  // 工作缓冲</span><br><span class="line">    │</span><br><span class="line">    ├─ 发现新工作？goto 检测循环</span><br><span class="line">    │</span><br><span class="line">    └─ === 标记终止 (STW) ===</span><br><span class="line">        ├─ stopTheWorld(stwGCMarkTerm)</span><br><span class="line">        ├─ 最后检查: 处理 ragged barrier 后的写屏障</span><br><span class="line">        ├─ 发现新工作？startTheWorld, goto 检测循环</span><br><span class="line">        └─ 确认完成</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│                 阶段 4: 并发扫描 (gcSweep)                    │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">    ├─ atomic.Store(&amp;gcBlackenEnabled, 0)  // 禁用标记</span><br><span class="line">    ├─ setGCPhase(_GCoff)                  // 禁用写屏障</span><br><span class="line">    ├─ mheap_.sweepgen += 2                // 更新扫描代数</span><br><span class="line">    └─ startTheWorld()                     // 恢复世界</span><br><span class="line"></span><br><span class="line">    并发执行：</span><br><span class="line">    ├─ 后台扫描 (bgsweep)</span><br><span class="line">    │   └─ 循环调用 sweepone()</span><br><span class="line">    │</span><br><span class="line">    └─ 惰性扫描 (lazy sweep)</span><br><span class="line">        └─ 分配时按需扫描 span</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│                   阶段 5: 等待下次触发                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">    ├─ 计算下次触发点</span><br><span class="line">    │   ├─ heapGoal = heapMarked * (1 + GOGC/100)</span><br><span class="line">    │   └─ trigger = heapGoal - runway</span><br><span class="line">    │</span><br><span class="line">    └─ 在分配路径检查: heapLive &gt;= trigger</span><br><span class="line">        └─ 是 → gcStart (回到顶部)</span><br></pre></td></tr></table></figure><h3 id="gc-触发-gcstart">3.1 GC 触发 gcStart()</h3><p>GC 的触发通过 <code>gcTrigger</code> 机制来检测三种条件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gcTrigger <span class="keyword">struct</span> &#123;</span><br><span class="line">kind gcTriggerKind</span><br><span class="line">now  <span class="type">int64</span>  <span class="comment">// gcTriggerTime: 当前时间</span></span><br><span class="line">n    <span class="type">uint32</span> <span class="comment">// gcTriggerCycle: 要启动的周期编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// gcTriggerHeap: 当堆大小达到控制器计算的触发堆大小时启动</span></span><br><span class="line">gcTriggerHeap gcTriggerKind = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcTriggerTime: 距离上次GC超过 forcegcperiod (2分钟) 时启动</span></span><br><span class="line">gcTriggerTime</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcTriggerCycle: 手动触发</span></span><br><span class="line">gcTriggerCycle</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/mgc.go#L616">gcTrigger.test()</a>返回 <code>true</code> 时，就会执行 <code>gcStart()</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t gcTrigger)</span></span> test() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 必须满足：GC已启用、非panic状态、不在GC中</span></span><br><span class="line"><span class="keyword">if</span> !memstats.enablegc || panicking.Load() != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> t.kind &#123;</span><br><span class="line"><span class="keyword">case</span> gcTriggerHeap:</span><br><span class="line"><span class="comment">// 堆触发：heapLive &gt;= trigger</span></span><br><span class="line">trigger, _ := gcController.trigger()</span><br><span class="line"><span class="keyword">return</span> gcController.heapLive.Load() &gt;= trigger</span><br><span class="line"><span class="keyword">case</span> gcTriggerTime:</span><br><span class="line"><span class="comment">// 时间触发：距上次GC &gt; forcegcperiod (2分钟)</span></span><br><span class="line"><span class="keyword">if</span> gcController.gcPercent.Load() &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">lastgc := <span class="type">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line"><span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line"><span class="keyword">case</span> gcTriggerCycle:</span><br><span class="line"><span class="comment">// 手动触发</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">int32</span>(t.n-work.cycles.Load()) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/mgc.go#L643">gcStart()</a>函数的核心流程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 安全性检查 (Preamble)</span></span><br><span class="line">    <span class="comment">// 如果当前 Goroutine 正持有锁（如在 malloc 内部），或者不可抢占，</span></span><br><span class="line">    <span class="comment">// 强行启动 GC 可能会导致死锁或状态损坏。此时放弃，等待下一次机会。</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="keyword">if</span> gp := getg(); gp == mp.g0 || mp.locks &gt; <span class="number">1</span> || mp.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 清理上一轮的残余 (Finish Previous Sweep)</span></span><br><span class="line">    <span class="comment">// 在开启新一轮 GC 前，必须确保上一轮的垃圾清理（Sweep）完全结束。</span></span><br><span class="line">    <span class="comment">// 如果是后台触发，通常已经清完了；如果是手动强制触发，这里会循环清理直到干净。</span></span><br><span class="line">    <span class="keyword">for</span> trigger.test() &amp;&amp; sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抢占启动锁，防止多个 P 同时启动 GC</span></span><br><span class="line">    semacquire(&amp;work.startSema)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查触发条件（Double Check），防止在抢锁过程中条件已变化</span></span><br><span class="line">    <span class="keyword">if</span> !trigger.test() &#123;</span><br><span class="line">        semrelease(&amp;work.startSema)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">// 3. 阶段一：扫描终止 (Sweep Termination) - STW 开始</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒后台标记工作协程（gcBgMarkWorker），让它们准备好干活</span></span><br><span class="line">    gcBgMarkStartWorkers()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置标记相关的全局状态（如重置工作队列等）</span></span><br><span class="line">    systemstack(gcResetMarkState)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop The World!</span></span><br><span class="line">    <span class="comment">// 这是 GC 周期的第一个 STW。目的是为了在一个静止的世界里，</span></span><br><span class="line">    <span class="comment">// 安全地切换 GC 阶段标志位，并开启写屏障。</span></span><br><span class="line">    <span class="comment">// 此时，所有用户代码暂停。</span></span><br><span class="line">    <span class="keyword">var</span> stw worldStop</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stw = stopTheWorldWithSema(stwGCSweepTerm)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 STW 期间，确保所有 Span 的清理工作彻底完成（兜底）</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        finishsweep_m()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 sync.Pool。</span></span><br><span class="line">    <span class="comment">// 这是一个权衡：必须在 STW 期间清空，否则老对象会活到下一轮。</span></span><br><span class="line">    clearpools()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加 GC 计数器</span></span><br><span class="line">    work.cycles.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 GC 控制器，设定本轮的目标（基于 P 的数量等）</span></span><br><span class="line">    gcController.startCycle(now, <span class="type">int</span>(gomaxprocs), trigger)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">// 4. 阶段二：准备并发标记 (Prepare Concurrent Mark)</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【关键点】开启混合写屏障 (Hybrid Write Barrier)</span></span><br><span class="line">    <span class="comment">// setGCPhase 将全局状态改为 _GCmark。</span></span><br><span class="line">    <span class="comment">// 由于此时还在 STW，所有 P 在被唤醒后，都会看到这个新状态，</span></span><br><span class="line">    <span class="comment">// 从而在执行 pointer write 时自动触发屏障逻辑。</span></span><br><span class="line">    setGCPhase(_GCmark)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备根对象（Globals, Stack, Registers 等）</span></span><br><span class="line">    <span class="comment">// 这一步必须在 assist 开启前完成。</span></span><br><span class="line">    gcBgMarkPrepare()</span><br><span class="line">    gcPrepareMarkRoots()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记所有 tiny alloc 块为黑色。</span></span><br><span class="line">    <span class="comment">// 这是一个优化：小对象分配非常频繁，如果不预先染黑，</span></span><br><span class="line">    <span class="comment">// 每次分配都要触发屏障，性能会崩。</span></span><br><span class="line">    gcMarkTinyAllocs()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【关键点】启用 Mutator Assist (辅助标记)</span></span><br><span class="line">    <span class="comment">// 允许用户协程在分配内存太快时，“被迫”帮忙进行标记。</span></span><br><span class="line">    <span class="comment">// 必须在写屏障开启后才能启用。</span></span><br><span class="line">    atomic.Store(&amp;gcBlackenEnabled, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line">    <span class="comment">// 5. 恢复世界 (Start The World)</span></span><br><span class="line">    <span class="comment">// ============================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时状态已经切换为 _GCmark，写屏障已启用，后台 Worker 已就绪。</span></span><br><span class="line">    <span class="comment">// 恢复用户代码运行。</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        now = startTheWorldWithSema(<span class="number">0</span>, stw)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放启动锁</span></span><br><span class="line">    semrelease(&amp;work.startSema)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发标记-gcbgmarkworker">3.2 并发标记 gcBgMarkWorker</h3><p>在上面 <code>gcStart()</code> 中，会调用 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/mgc.go#L1350">gcBgMarkStartWorkers()</a>准备后台标记工作者：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span></span> &#123;</span><br><span class="line">ready := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> gcBgMarkWorkerCount &lt; gomaxprocs &#123;</span><br><span class="line"><span class="keyword">go</span> gcBgMarkWorker(ready)</span><br><span class="line">&lt;-ready</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的逻辑很简单，就是为每一个 P 调用一个 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/mgc.go#L1428">gcBgMarkWorker(ready)</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkWorker</span><span class="params">(ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">ready &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 根据不同标记的工作者类型调用不同的标记函数</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> pp.gcMarkWorkerMode &#123;</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">gcDrainMarkWorkerDedicated(&amp;pp.gcw, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line"><span class="keyword">if</span> drainQ := runqdrain(pp); !drainQ.empty() &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">globrunqputbatch(&amp;drainQ)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">gcDrainMarkWorkerDedicated(&amp;pp.gcw, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">gcDrainMarkWorkerFractional(&amp;pp.gcw)</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">gcDrainMarkWorkerIdle(&amp;pp.gcw)</span><br><span class="line">&#125;</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测标记终止</span></span><br><span class="line"><span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">gcMarkDone()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcBgMarkWorker()</code> 主要包含 2 个核心逻辑：</p><ol type="1"><li><p>根据不同标记的工作者类型调用不同的标记函数，如<code>gcDrainMarkWorkerDedicated()</code>、<code>gcDrainMarkWorkerFractional()</code>和 <code>gcDrainMarkWorkerIdle()</code>。而事实上，这 3个函数，都是调用了 <code>gcDrain()</code>。<code>gcDrain()</code> 函数是GC标记阶段的核心工作循环，负责"排空"（drain）标记工作队列，将灰色对象扫描并标记为黑色。这是标记工作者执行实际标记工作的主要函数。</p><p>调用层级如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcBgMarkWorker (后台工作者)</span><br><span class="line">    └─&gt; gcDrainMarkWorkerDedicated/Fractional/Idle</span><br><span class="line">            └─&gt; gcDrain</span><br><span class="line">                    ├─&gt; markroot (扫描根对象)</span><br><span class="line">                    ├─&gt; scanobject (扫描堆对象)</span><br><span class="line">                    └─&gt; scanSpan (扫描 span)</span><br></pre></td></tr></table></figure></li><li><p>检测标记终止：<code>gcMarkDone()</code>，我们将在 3.3章节进行详细展开。</p></li></ol><h4 id="标记工作者类型-gcmarkworkermode">3.2.1 标记工作者类型gcMarkWorkerMode</h4><p>Go GC 使用三种类型的标记工作者：</p><ul><li><code>gcMarkWorkerDedicatedMode</code>：专用标记工作者，持续标记直到没有更多工作或被抢占。</li><li><code>gcMarkWorkerFractionalMode</code>：分数标记工作者，按照目标使用率工作。</li><li><code>gcMarkWorkerIdleMode</code>：空闲标记工作者，仅在 P空闲时工作。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> pp.gcMarkWorkerMode &#123;</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line"><span class="comment">// Dedicated Worker: 专用标记工作者，持续标记直到没有更多工作或被抢占</span></span><br><span class="line">gcDrainMarkWorkerDedicated(&amp;pp.gcw, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line"><span class="comment">// 被抢占时，清空运行队列</span></span><br><span class="line"><span class="keyword">if</span> drainQ := runqdrain(pp); !drainQ.empty() &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">globrunqputbatch(&amp;drainQ)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">gcDrainMarkWorkerDedicated(&amp;pp.gcw, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line"><span class="comment">// Fractional Worker: 分数标记工作者，按照目标使用率工作</span></span><br><span class="line">gcDrainMarkWorkerFractional(&amp;pp.gcw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line"><span class="comment">// Idle Worker: 空闲标记工作者，仅在P空闲时工作</span></span><br><span class="line">gcDrainMarkWorkerIdle(&amp;pp.gcw)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标记工作队列-gcwork">3.2.2 标记工作队列 gcWork</h4><p><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/mgcwork.go#L82">gcWork</a>是 GC 标记工作的生产者-消费者接口，每个 P 都有自己的<code>gcWork</code>，通过双缓冲减少全局队列竞争。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gcWork <span class="keyword">struct</span> &#123;</span><br><span class="line">    wbuf1, wbuf2 *workbuf  <span class="comment">// 双缓冲：wbuf1 当前使用，wbuf2 备用</span></span><br><span class="line">    bytesMarked <span class="type">uint64</span>     <span class="comment">// 本地标记的字节数</span></span><br><span class="line">    flushedWork <span class="type">bool</span>       <span class="comment">// 是否将工作刷新到全局队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有两个核心方法：</p><ul><li><code>putObj()</code>：将一个灰色对象加入工作队列（生产）</li><li><code>tryGetObj()</code>：从工作队列取出一个灰色对象（消费）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// putObj 将一个灰色对象加入工作队列（生产）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> putObj(obj <span class="type">uintptr</span>) &#123;</span><br><span class="line">    wbuf := w.wbuf1</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化或检查缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line">        w.init()  <span class="comment">// 初始化双缓冲</span></span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;  <span class="comment">// wbuf1 满了</span></span><br><span class="line">        <span class="comment">// 双缓冲切换：wbuf1 &lt;-&gt; wbuf2</span></span><br><span class="line">        w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1</span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> wbuf.nobj == <span class="built_in">len</span>(wbuf.obj) &#123;  <span class="comment">// 两个缓冲区都满了</span></span><br><span class="line">            putfull(wbuf)  <span class="comment">// 将满的缓冲区放入全局 full 队列</span></span><br><span class="line">            w.flushedWork = <span class="literal">true</span></span><br><span class="line">            wbuf = getempty()  <span class="comment">// 获取新的空缓冲区</span></span><br><span class="line">            w.wbuf1 = wbuf</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将对象加入缓冲区</span></span><br><span class="line">    wbuf.obj[wbuf.nobj] = obj</span><br><span class="line">    wbuf.nobj++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tryGetObj 从工作队列取出一个灰色对象（消费）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *gcWork)</span></span> tryGetObj() <span class="type">uintptr</span> &#123;</span><br><span class="line">    wbuf := w.wbuf1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line">        w.init()</span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> wbuf.nobj == <span class="number">0</span> &#123;  <span class="comment">// wbuf1 空了</span></span><br><span class="line">        <span class="comment">// 双缓冲切换</span></span><br><span class="line">        w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1</span><br><span class="line">        wbuf = w.wbuf1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> wbuf.nobj == <span class="number">0</span> &#123;  <span class="comment">// 两个缓冲区都空了</span></span><br><span class="line">            owbuf := wbuf</span><br><span class="line">            wbuf = trygetfull()  <span class="comment">// 从全局 full 队列获取</span></span><br><span class="line">            <span class="keyword">if</span> wbuf == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>  <span class="comment">// 没有工作了</span></span><br><span class="line">            &#125;</span><br><span class="line">            putempty(owbuf)  <span class="comment">// 将空缓冲区归还全局 empty 队列</span></span><br><span class="line">            w.wbuf1 = wbuf</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓冲区取出对象</span></span><br><span class="line">    wbuf.nobj--</span><br><span class="line">    <span class="keyword">return</span> wbuf.obj[wbuf.nobj]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计要点：</p><ul><li>双缓冲机制：减少对全局队列的访问频率，降低锁竞争</li><li>本地优先：优先使用 P 本地缓冲区，只在必要时访问全局队列</li><li>滞后效应：一个缓冲区的容量作为滞后，摊销获取/放回缓冲区的成本</li></ul><h4 id="根对象扫描准备-gcpreparemarkroots">3.2.3 根对象扫描准备gcPrepareMarkRoots()</h4><p>在 <code>gcStart()</code> 的时候，会先执行 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/mgcmark.go#L60">gcPrepareMarkRoot()</a>扫描根对象，即所谓的 GC Roots，如我们前面的可达性分析章节所述， GC Roots的对象通常是指那些<strong>肯定在使用中</strong>的对象：</p><ul><li>被栈上的指针引用</li><li>被全局变量的指针引用</li><li>被寄存器中的指针引用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcPrepareMarkRoots</span><span class="params">()</span></span> &#123;</span><br><span class="line">assertWorldStopped()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 计算data段和bss段的根对象数量</span></span><br><span class="line">work.nDataRoots = <span class="number">0</span></span><br><span class="line">work.nBSSRoots = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">nDataRoots := nBlocks(datap.edata - datap.data)</span><br><span class="line"><span class="keyword">if</span> nDataRoots &gt; work.nDataRoots &#123;</span><br><span class="line">work.nDataRoots = nDataRoots</span><br><span class="line">&#125;</span><br><span class="line">nBSSRoots := nBlocks(datap.ebss - datap.bss)</span><br><span class="line"><span class="keyword">if</span> nBSSRoots &gt; work.nBSSRoots &#123;</span><br><span class="line">work.nBSSRoots = nBSSRoots</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 准备扫描span中的finalizer specials</span></span><br><span class="line">mheap_.markArenas = mheap_.heapArenas[:<span class="built_in">len</span>(mheap_.heapArenas):<span class="built_in">len</span>(mheap_.heapArenas)]</span><br><span class="line">work.nSpanRoots = <span class="built_in">len</span>(mheap_.markArenas) * (pagesPerArena / pagesPerSpanRoot)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 准备扫描所有goroutine的栈</span></span><br><span class="line"><span class="comment">// 在此点之后创建的G会从重置状态开始，所以不需要扫描</span></span><br><span class="line">work.stackRoots = allGsSnapshot()</span><br><span class="line">work.nStackRoots = <span class="built_in">len</span>(work.stackRoots)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算总的根对象扫描任务数</span></span><br><span class="line">work.markrootNext = <span class="number">0</span></span><br><span class="line">work.markrootJobs = <span class="type">uint32</span>(fixedRootCount + work.nDataRoots +</span><br><span class="line">                           work.nBSSRoots + work.nSpanRoots + work.nStackRoots)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算各类根对象的基础索引</span></span><br><span class="line">work.baseData = <span class="type">uint32</span>(fixedRootCount)</span><br><span class="line">work.baseBSS = work.baseData + <span class="type">uint32</span>(work.nDataRoots)</span><br><span class="line">work.baseSpans = work.baseBSS + <span class="type">uint32</span>(work.nBSSRoots)</span><br><span class="line">work.baseStacks = work.baseSpans + <span class="type">uint32</span>(work.nSpanRoots)</span><br><span class="line">work.baseEnd = work.baseStacks + <span class="type">uint32</span>(work.nStackRoots)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标记循环-gcdrain">3.2.4 标记循环 gcDrain()</h4><p>前面我们提到 <ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/mgcmark.go#L1169">gcDrain()</a>函数是 GC标记阶段的核心工作循环，负责"排空"（drain）标记工作队列，将灰色对象扫描并标记为黑色。它的核心流程很简单，就是<strong>从工作队列中持续取出灰色对象进行扫描，直到满足退出条件</strong>：</p><ol type="1"><li>工作队列为空</li><li>被抢占（如果允许抢占）</li><li>满足退出条件（空闲/分数模式）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">    <span class="comment">// === 1. 初始化和模式设置 ===</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置检查点：定期检查是否应该退出</span></span><br><span class="line">    checkWork := <span class="type">int64</span>(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)  <span class="comment">// 默认几乎不检查</span></span><br><span class="line">    <span class="keyword">var</span> check <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span></span><br><span class="line">    <span class="keyword">if</span> flags&amp;(gcDrainIdle|gcDrainFractional) != <span class="number">0</span> &#123;</span><br><span class="line">        checkWork = initScanWork + drainCheckThreshold  <span class="comment">// 每完成一定量工作就检查</span></span><br><span class="line">        <span class="keyword">if</span> idle &#123;</span><br><span class="line">            check = pollWork  <span class="comment">// 空闲模式：检查是否有其他工作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> flags&amp;gcDrainFractional != <span class="number">0</span> &#123;</span><br><span class="line">            check = pollFractionalWorkerExit  <span class="comment">// 分数模式：检查是否达到目标时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 2. 阶段一：排空根标记任务 ===</span></span><br><span class="line">    <span class="comment">// 根对象包括：全局变量、goroutine 栈、finalizer 等</span></span><br><span class="line">  <span class="comment">// 即前面 gcPrepareMarkRoots() 准备的内容</span></span><br><span class="line">    <span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">        <span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || sched.gcwaiting.Load() || pp.runSafePointFn != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 原子获取下一个根标记任务</span></span><br><span class="line">            job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment">// 所有根任务已完成</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            markroot(gcw, job, flushBgCredit)  <span class="comment">// 标记根对象</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定期检查退出条件</span></span><br><span class="line">            <span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">                <span class="keyword">goto</span> done  <span class="comment">// 空闲模式有其他工作 or 分数模式达到时间</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// GreenTeaGC: 如果需要，启动新工作者</span></span><br><span class="line">            <span class="keyword">if</span> goexperiment.GreenTeaGC &amp;&amp; gcw.mayNeedWorker &#123;</span><br><span class="line">                gcw.mayNeedWorker = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">if</span> gcphase == _GCmark &#123;</span><br><span class="line">                    gcController.enlistWorker()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 3. 阶段二：排空堆标记任务（主循环）===</span></span><br><span class="line">    <span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || sched.gcwaiting.Load() || pp.runSafePointFn != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 3.1 工作平衡：保持全局队列有工作，避免其他工作者等待</span></span><br><span class="line">        <span class="keyword">if</span> work.full == <span class="number">0</span> &#123;</span><br><span class="line">            gcw.balance()  <span class="comment">// 将本地缓冲的部分工作放回全局队列</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 按优先级顺序获取工作（见 mgcwork.go 注释）</span></span><br><span class="line">        <span class="keyword">var</span> b <span class="type">uintptr</span>  <span class="comment">// 对象指针</span></span><br><span class="line">        <span class="keyword">var</span> s objptr   <span class="comment">// span 指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优先级 1: P-local workbuf</span></span><br><span class="line">        <span class="keyword">if</span> b = gcw.tryGetObjFast(); b == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 优先级 2: P-local span queue (GreenTeaGC)</span></span><br><span class="line">            <span class="keyword">if</span> s = gcw.tryGetSpan(<span class="literal">false</span>); s == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 优先级 3: 全局 workbuf</span></span><br><span class="line">                <span class="keyword">if</span> b = gcw.tryGetObj(); b == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 刷新写屏障缓冲区，可能产生新工作</span></span><br><span class="line">                    wbBufFlush()</span><br><span class="line">                    <span class="keyword">if</span> b = gcw.tryGetObj(); b == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 优先级 4: 全局 span queue</span></span><br><span class="line">                        s = gcw.tryGetSpan(<span class="literal">true</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.3 处理获取到的工作</span></span><br><span class="line">        <span class="keyword">if</span> b != <span class="number">0</span> &#123;</span><br><span class="line">            scanobject(b, gcw)  <span class="comment">// 扫描对象：遍历其指针字段，标记引用</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> s != <span class="number">0</span> &#123;</span><br><span class="line">            scanSpan(s, gcw)    <span class="comment">// 扫描 span：批量处理 span 中的对象</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment">// 没有工作了，退出</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.4 可能启动新工作者</span></span><br><span class="line">        <span class="keyword">if</span> goexperiment.GreenTeaGC &amp;&amp; gcw.mayNeedWorker &#123;</span><br><span class="line">            gcw.mayNeedWorker = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">if</span> gcphase == _GCmark &#123;</span><br><span class="line">                gcController.enlistWorker()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.5 刷新扫描工作信用（用于 mutator assist 的记账）</span></span><br><span class="line">        <span class="keyword">if</span> gcw.heapScanWork &gt;= gcCreditSlack &#123;  <span class="comment">// 累积了 2000 字节扫描工作</span></span><br><span class="line">            gcController.heapScanWork.Add(gcw.heapScanWork)  <span class="comment">// 刷新到全局</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">                <span class="comment">// 后台标记：产生信用，让 mutator 可以借用</span></span><br><span class="line">                gcFlushBgCredit(gcw.heapScanWork - initScanWork)</span><br><span class="line">                initScanWork = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            checkWork -= gcw.heapScanWork</span><br><span class="line">            gcw.heapScanWork = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定期检查退出条件</span></span><br><span class="line">            <span class="keyword">if</span> checkWork &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                checkWork += drainCheckThreshold</span><br><span class="line">                <span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// === 4. 清理：刷新剩余的扫描工作 ===</span></span><br><span class="line">    <span class="keyword">if</span> gcw.heapScanWork &gt; <span class="number">0</span> &#123;</span><br><span class="line">        gcController.heapScanWork.Add(gcw.heapScanWork)</span><br><span class="line">        <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">            gcFlushBgCredit(gcw.heapScanWork - initScanWork)</span><br><span class="line">        &#125;</span><br><span class="line">        gcw.heapScanWork = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键设计点：</p><ol type="1"><li><strong>工作优先级</strong>：<code>P-local workbuf</code> →<code>P-local span</code> → <code>全局 workbuf</code> →<code>全局 span</code>，优先使用本地缓存，减少全局竞争。</li><li><strong>工作平衡</strong>：防止工作集中在某个 P，其他 P 空闲。</li><li><strong>抢占检查</strong>：响应抢占请求、STW 请求、forEachP调用。</li><li><strong>信用系统</strong>：后台标记工作产生"信用"，Mutator assist消耗"信用"，平衡 GC 工作和应用程序分配。</li></ol><p><code>gcDrain()</code> 包含了 3 个最重要的子逻辑：</p><ul><li><code>markroot()</code>: 标记 GC 的根集（rootset），这些是追踪的起点。</li><li><code>scanobject()</code>：扫描一个堆对象，标记它引用的所有对象。</li><li><code>scanSpan(</code>)：扫描 span，批量处理 span 中的对象，这是Green Tea GC 的优化，这个我们下一篇再进行展开。</li></ul><h4 id="标记根对象-markroot">3.2.5 标记根对象 markroot()</h4><p>关键点：</p><ul><li><p>根对象种类：全局变量（data/BSS）、栈、finalizer、cleanup、spanspecials</p></li><li><p>分片处理：大的根对象（如全局变量）被分成多个任务，并行处理</p></li><li><p>栈扫描：需要暂停 goroutine，扫描后恢复</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// markroot 标记第 i 个根对象任务</span></span><br><span class="line"><span class="comment">// 根对象是 GC 追踪的起点，包括全局变量、栈、finalizer 等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markroot</span><span class="params">(gcw *gcWork, i <span class="type">uint32</span>, flushBgCredit <span class="type">bool</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> workDone <span class="type">int64</span></span><br><span class="line">    <span class="keyword">var</span> workCounter *atomic.Int64</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="comment">// === 1. 全局变量（data 段）===</span></span><br><span class="line">    <span class="keyword">case</span> work.baseData &lt;= i &amp;&amp; i &lt; work.baseBSS:</span><br><span class="line">        workCounter = &amp;gcController.globalsScanWork</span><br><span class="line">        <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">            <span class="comment">// 扫描 data 段：已初始化的全局变量</span></span><br><span class="line">            workDone += markrootBlock(</span><br><span class="line">                datap.data,              <span class="comment">// 起始地址</span></span><br><span class="line">                datap.edata-datap.data,  <span class="comment">// 大小</span></span><br><span class="line">                datap.gcdatamask.bytedata, <span class="comment">// 指针位图</span></span><br><span class="line">                gcw,</span><br><span class="line">                <span class="type">int</span>(i-work.baseData),    <span class="comment">// 分片索引</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 2. 全局变量（BSS 段）===</span></span><br><span class="line">    <span class="keyword">case</span> work.baseBSS &lt;= i &amp;&amp; i &lt; work.baseSpans:</span><br><span class="line">        workCounter = &amp;gcController.globalsScanWork</span><br><span class="line">        <span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">            <span class="comment">// 扫描 BSS 段：未初始化的全局变量</span></span><br><span class="line">            workDone += markrootBlock(</span><br><span class="line">                datap.bss,</span><br><span class="line">                datap.ebss-datap.bss,</span><br><span class="line">                datap.gcbssmask.bytedata,</span><br><span class="line">                gcw,</span><br><span class="line">                <span class="type">int</span>(i-work.baseBSS),</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 3. Finalizer 队列 ===</span></span><br><span class="line">    <span class="keyword">case</span> i == fixedRootFinalizers:</span><br><span class="line">        <span class="keyword">for</span> fb := allfin; fb != <span class="literal">nil</span>; fb = fb.alllink &#123;</span><br><span class="line">            cnt := <span class="type">uintptr</span>(atomic.Load(&amp;fb.cnt))</span><br><span class="line">            <span class="comment">// 扫描 finalizer 结构体中的指针</span></span><br><span class="line">            scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;fb.fin[<span class="number">0</span>])),</span><br><span class="line">                      cnt*unsafe.Sizeof(fb.fin[<span class="number">0</span>]),</span><br><span class="line">                      &amp;finptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 4. 释放死亡 G 的栈 ===</span></span><br><span class="line">    <span class="keyword">case</span> i == fixedRootFreeGStacks:</span><br><span class="line">        systemstack(markrootFreeGStacks)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 5. Cleanup 队列 ===</span></span><br><span class="line">    <span class="keyword">case</span> i == fixedRootCleanups:</span><br><span class="line">        <span class="keyword">for</span> cb := (*cleanupBlock)(gcCleanups.all.Load()); cb != <span class="literal">nil</span>; cb = cb.alllink &#123;</span><br><span class="line">            n := <span class="type">uintptr</span>(atomic.Load(&amp;cb.n))</span><br><span class="line">            scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;cb.cleanups[<span class="number">0</span>])),</span><br><span class="line">                      n*goarch.PtrSize,</span><br><span class="line">                      &amp;cleanupBlockPtrMask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 6. Span 特殊对象（如 finalizer specials）===</span></span><br><span class="line">    <span class="keyword">case</span> work.baseSpans &lt;= i &amp;&amp; i &lt; work.baseStacks:</span><br><span class="line">        markrootSpans(gcw, <span class="type">int</span>(i-work.baseSpans))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 7. Goroutine 栈（最重要！）===</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        workCounter = &amp;gcController.stackScanWork</span><br><span class="line">        <span class="keyword">if</span> i &lt; work.baseStacks || work.baseEnd &lt;= i &#123;</span><br><span class="line">            throw(<span class="string">&quot;markroot: bad index&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gp := work.stackRoots[i-work.baseStacks]  <span class="comment">// 获取 goroutine</span></span><br><span class="line"></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 处理自扫描情况</span></span><br><span class="line">            userG := getg().m.curg</span><br><span class="line">            selfScan := gp == userG &amp;&amp; readgstatus(userG) == _Grunning</span><br><span class="line">            <span class="keyword">if</span> selfScan &#123;</span><br><span class="line">                casGToWaitingForSuspendG(userG, _Grunning, waitReasonGarbageCollectionScan)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停 goroutine 并扫描其栈</span></span><br><span class="line">            stopped := suspendG(gp)</span><br><span class="line">            <span class="keyword">if</span> stopped.dead &#123;</span><br><span class="line">                gp.gcscandone = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> gp.gcscandone &#123;</span><br><span class="line">                throw(<span class="string">&quot;g already scanned&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            workDone += scanstack(gp, gcw)  <span class="comment">// 扫描栈！</span></span><br><span class="line">            gp.gcscandone = <span class="literal">true</span></span><br><span class="line">            resumeG(stopped)  <span class="comment">// 恢复 goroutine</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> selfScan &#123;</span><br><span class="line">                casgstatus(userG, _Gwaiting, _Grunning)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新工作统计和信用</span></span><br><span class="line">    <span class="keyword">if</span> workCounter != <span class="literal">nil</span> &amp;&amp; workDone != <span class="number">0</span> &#123;</span><br><span class="line">        workCounter.Add(workDone)</span><br><span class="line">        <span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">            gcFlushBgCredit(workDone)  <span class="comment">// 产生 assist 信用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象扫描-scanobject">3.2.6 对象扫描 scanobject()</h4><p>关键点：</p><ul><li><p><strong>Oblet 机制</strong>：大对象（&gt;128KB）被拆分成多个oblet，每个 ≤128KB</p><ul><li><p>优势：提高并行性，降低扫描延迟（~100µs）</p></li><li><p>其他 oblet 被放入工作队列，可能被其他工作者处理</p></li></ul></li><li><p><strong>类型指针迭代器</strong>：高效遍历对象中的指针字段，跳过标量字段</p></li><li><p><strong>快速过滤</strong>：过滤 nil 和自引用，减少不必要的<code>findObject</code> 调用</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scanobject 扫描地址 b 处的对象，将其变黑，并将引用的对象变灰</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanobject</span><span class="params">(b <span class="type">uintptr</span>, gcw *gcWork)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 预取对象，提高缓存命中率</span></span><br><span class="line">    sys.Prefetch(b)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 1. 获取对象信息 ===</span></span><br><span class="line">    s := spanOfUnchecked(b)  <span class="comment">// 获取对象所在的 span</span></span><br><span class="line">    n := s.elemsize           <span class="comment">// 对象大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;scanobject n == 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.spanclass.noscan() &#123;</span><br><span class="line">        throw(<span class="string">&quot;scanobject of a noscan object&quot;</span>)  <span class="comment">// noscan 对象不应该到这</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 2. 处理大对象：拆分成 oblets ===</span></span><br><span class="line">    <span class="keyword">var</span> tp typePointers  <span class="comment">// 类型指针迭代器</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; maxObletBytes &#123;  <span class="comment">// 对象 &gt; 128KB</span></span><br><span class="line">        <span class="comment">// 大对象拆分成多个 128KB 的 oblet，提高并行性和降低延迟</span></span><br><span class="line">        <span class="keyword">if</span> b == s.base() &#123;</span><br><span class="line">            <span class="comment">// 只在第一次遇到对象时，将其他 oblet 入队</span></span><br><span class="line">            <span class="keyword">for</span> oblet := b + maxObletBytes; oblet &lt; s.base()+s.elemsize; oblet += maxObletBytes &#123;</span><br><span class="line">                <span class="keyword">if</span> !gcw.putObjFast(oblet) &#123;</span><br><span class="line">                    gcw.putObj(oblet)  <span class="comment">// 将 oblet 加入工作队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前 oblet 的大小</span></span><br><span class="line">        n = s.base() + s.elemsize - b</span><br><span class="line">        n = min(n, maxObletBytes)</span><br><span class="line">        tp = s.typePointersOfUnchecked(s.base())</span><br><span class="line">        tp = tp.fastForward(b-tp.addr, b+n)  <span class="comment">// 跳到当前 oblet</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 小对象，直接获取类型指针</span></span><br><span class="line">        tp = s.typePointersOfUnchecked(b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 3. 遍历对象中的所有指针 ===</span></span><br><span class="line">    <span class="keyword">var</span> scanSize <span class="type">uintptr</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> addr <span class="type">uintptr</span></span><br><span class="line">        <span class="comment">// 快速路径：尝试快速获取下一个指针</span></span><br><span class="line">        <span class="keyword">if</span> tp, addr = tp.nextFast(); addr == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 慢速路径：需要更多处理</span></span><br><span class="line">            <span class="keyword">if</span> tp, addr = tp.next(b + n); addr == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment">// 没有更多指针了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跟踪扫描进度（用于统计）</span></span><br><span class="line">        scanSize = addr - b + goarch.PtrSize</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 4. 读取指针值 ===</span></span><br><span class="line">        obj := *(*<span class="type">uintptr</span>)(unsafe.Pointer(addr))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 5. 快速过滤 ===</span></span><br><span class="line">        <span class="comment">// 过滤 nil 和指向当前对象内部的指针</span></span><br><span class="line">        <span class="keyword">if</span> obj != <span class="number">0</span> &amp;&amp; obj-b &gt;= n &#123;</span><br><span class="line">            <span class="comment">// === 6. 标记被引用的对象 ===</span></span><br><span class="line">            <span class="keyword">if</span> !tryDeferToSpanScan(obj, gcw) &#123;</span><br><span class="line">                <span class="comment">// 查找对象</span></span><br><span class="line">                <span class="keyword">if</span> obj, span, objIndex := findObject(obj, b, addr-b); obj != <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 将对象标记为灰色（核心！）</span></span><br><span class="line">                    greyobject(obj, b, addr-b, span, gcw, objIndex)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 7. 统计 ===</span></span><br><span class="line">    gcw.bytesMarked += <span class="type">uint64</span>(n)     <span class="comment">// 标记的字节数</span></span><br><span class="line">    gcw.heapScanWork += <span class="type">int64</span>(scanSize)  <span class="comment">// 扫描的字节数</span></span><br><span class="line">    <span class="keyword">if</span> debug.gctrace &gt; <span class="number">1</span> &#123;</span><br><span class="line">        gcw.stats[s.spanclass.sizeclass()].sparseObjsScanned++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象标记-greyobject">3.2.7 对象标记 greyobject()</h4><p><code>scanobject()</code> 会将正在扫描的堆对象引用的对象调用<code>greyobject()</code> 将其从白色标记为灰色。</p><p>关键点：</p><ul><li><p><strong>幂等性</strong>：重复标记同一对象是安全的（已标记则直接返回）</p></li><li><p><strong>原子操作</strong>：标记位和页位图的设置都是原子的，支持并发标记</p></li><li><p><strong>noscan优化</strong>：没有指针的对象直接变黑，不入队</p></li><li><p><strong>预取优化</strong>：将对象预取到缓存，提高后续扫描性能</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greyobject 将对象 obj 标记为灰色</span></span><br><span class="line"><span class="comment">// obj: 对象地址</span></span><br><span class="line"><span class="comment">// base, off: 用于调试，指示从哪里发现的这个引用</span></span><br><span class="line"><span class="comment">// span: 对象所在的 span</span></span><br><span class="line"><span class="comment">// gcw: 工作队列</span></span><br><span class="line"><span class="comment">// objIndex: 对象在 span 中的索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greyobject</span><span class="params">(obj, base, off <span class="type">uintptr</span>, span *mspan, gcw *gcWork, objIndex <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// === 1. 对齐检查 ===</span></span><br><span class="line">    <span class="keyword">if</span> obj&amp;(goarch.PtrSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;greyobject: obj not pointer-aligned&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 2. 获取标记位 ===</span></span><br><span class="line">    mbits := span.markBitsForIndex(objIndex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> useCheckmark &#123;</span><br><span class="line">        <span class="comment">// 调试模式：checkmark</span></span><br><span class="line">        <span class="keyword">if</span> setCheckmark(obj, base, off, mbits) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="comment">// 已标记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> debug.checkfinalizers &gt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;  mark &quot;</span>, hex(obj), <span class="string">&quot; found at *(&quot;</span>, hex(base), <span class="string">&quot;+&quot;</span>, hex(off), <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// === 3. 检查是否已标记 ===</span></span><br><span class="line">        <span class="keyword">if</span> mbits.isMarked() &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="comment">// 已经是灰色或黑色，跳过</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 4. 设置标记位（白→灰）===</span></span><br><span class="line">        mbits.setMarked()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 5. 标记 span 的页位图 ===</span></span><br><span class="line">        <span class="comment">// 用于快速判断某页是否有存活对象</span></span><br><span class="line">        arena, pageIdx, pageMask := pageIndexOf(span.base())</span><br><span class="line">        <span class="keyword">if</span> arena.pageMarks[pageIdx]&amp;pageMask == <span class="number">0</span> &#123;</span><br><span class="line">            atomic.Or8(&amp;arena.pageMarks[pageIdx], pageMask)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 6. noscan 对象快速路径 ===</span></span><br><span class="line">    <span class="comment">// noscan 对象（如 []byte）没有指针，直接变黑，不需要扫描</span></span><br><span class="line">    <span class="keyword">if</span> span.spanclass.noscan() &#123;</span><br><span class="line">        gcw.bytesMarked += <span class="type">uint64</span>(span.elemsize)</span><br><span class="line">        <span class="keyword">return</span>  <span class="comment">// 不入队，直接完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 7. 预取对象 ===</span></span><br><span class="line">    <span class="comment">// 对象即将被扫描，预取到 CPU 缓存</span></span><br><span class="line">    sys.Prefetch(obj)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 8. 将对象加入工作队列（灰色队列）===</span></span><br><span class="line">    <span class="comment">// 对象现在是灰色的，等待被扫描（变黑）</span></span><br><span class="line">    <span class="keyword">if</span> !gcw.putObjFast(obj) &#123;</span><br><span class="line">        gcw.putObj(obj)  <span class="comment">// 快速路径失败，使用慢速路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发标记小节">3.2.8 并发标记小节</h4><p><code>gcDrain</code>的核心逻辑是一个消费循环。它从本地或全局的工作缓冲区（<code>gcWork</code>）中提取指针（灰色对象），并调用<code>scanobject</code>对其进行处理。其工作流可以形式化为以下几个步骤：</p><ol type="1"><li><strong>本地获取（Local Fetch）</strong>：首先尝试从当前 P 的本地<code>gcWork</code>缓存中获取工作。这是一个无锁操作（Lock-free），效率极高。</li><li><strong>全局获取与窃取（Global Fetch &amp;Steal）</strong>：如果本地缓存为空，<code>gcDrain</code>必须尝试从全局队列获取工作，或者从其他 P的本地队列中窃取工作。这一步涉及到跨 P 的协调，是锁竞争的高发区。</li><li><strong>扫描与着色（Scan &amp;Shade）</strong>：对获取到的每一个对象调用<code>scanobject</code>，识别其引用的子对象，并通过<code>greyobject</code> 将子对象加入工作队列（即着色为灰色）。</li><li><strong>抢占检查（PreemptionCheck）</strong>：为了保证调度的公平性，<code>gcDrain</code>会周期性地检查是否需要让出 P。</li></ol><p>整个 <code>gcDrain()</code> 的标记循环流程可以总结为如下图所示：</p><pre class="mermaid">graph LR    A[灰色对象队列] -->|取出| B[gcDrain]    B --> C[扫描函数]    C -->|markroot| D[扫描根]    C -->|scanobject| E[扫描对象]    C -->|scanSpan| F[扫描Span]    D --> G[greyobject]    E --> G    F --> G    G -->|白→灰| H[设置标记位]    H -->|入队| A    style B fill:#e1f5ff,stroke:#0277bd,stroke-width:3px    style G fill:#ffebee,stroke:#c62828,stroke-width:3px    style A fill:#fff9c4,stroke:#f57f17,stroke-width:2px</pre><h3 id="标记终止检测-gcmarkdone">3.3 标记终止检测 gcMarkDone()</h3><p>为了进入并发清理阶段，需要先确保所有标记已经终止，即 MarkTermination。这是最复杂的阶段，Go 使用<strong>分布式终止算法</strong>和<strong>Ragged Barrier</strong> 来确保所有标记工作完成。</p><p>所谓检测并发标记阶段是否完成，即<u><strong>确认所有可达对象都已标记，没有遗漏的灰色对象</strong></u>。</p><p>在并发环境中，标记工作分散在多个位置：</p><ul><li><p>P-local buffers：每个 P 的 gcWork 缓冲区</p></li><li><p>Global work queues：全局工作队列 work.full</p></li><li><p>Write barrier buffers：写屏障缓冲区 wbBuf</p></li><li><p>Root scan jobs：根对象扫描任务</p></li></ul><p>那么问题就来了：<font color="red"><u>如何在不停止世界的情况下，确保检查所有缓冲区时，不会有新的工作产生？</u></font></p><blockquote><p>[!IMPORTANT]</p><p><code>gcMarkDone()</code>通过"<strong>检查所有工作者空闲(nwait==nproc)且全局队列为空 → RaggedBarrier 同步刷新所有 P 的写屏障缓冲和工作队列到全局 → STW后验证写屏障无残留工作</strong>"的三步循环检测，任一步骤发现新的灰色对象就回到起点重新检测，直到确认不存在任何隐藏的本地工作和灰色对象后才进入标记终止阶段。</p></blockquote><p>下面是 <code>gcMarkDone()</code> 的源码解析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkDone</span><span class="params">()</span></span> &#123;</span><br><span class="line">semacquire(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line"><span class="comment">// 检查终止条件：</span></span><br><span class="line"><span class="comment">// 1. 当前处于标记阶段</span></span><br><span class="line"><span class="comment">// 2. 所有worker都在等待 (nwait == nproc)</span></span><br><span class="line"><span class="comment">// 3. 没有可用的标记工作</span></span><br><span class="line"><span class="keyword">if</span> !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>)) &#123;</span><br><span class="line">semrelease(&amp;work.markDoneSema)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻止weak-&gt;strong转换产生额外的GC工作</span></span><br><span class="line">work.strongFromWeak.block = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// === Ragged Barrier ===</span></span><br><span class="line"><span class="comment">// 刷新所有P的本地缓冲区</span></span><br><span class="line">gcMarkDoneFlushed = <span class="number">0</span></span><br><span class="line">forEachP(waitReasonGCMarkTermination, <span class="function"><span class="keyword">func</span><span class="params">(pp *p)</span></span> &#123;</span><br><span class="line"><span class="comment">// 刷新写屏障缓冲</span></span><br><span class="line">wbBufFlush1(pp)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新gcWork缓冲</span></span><br><span class="line">pp.gcw.dispose()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集flushedWork标志</span></span><br><span class="line"><span class="keyword">if</span> pp.gcw.flushedWork &#123;</span><br><span class="line">atomic.Xadd(&amp;gcMarkDoneFlushed, <span class="number">1</span>)</span><br><span class="line">pp.gcw.flushedWork = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果发现新的灰色对象，重新开始检测</span></span><br><span class="line"><span class="keyword">if</span> gcMarkDoneFlushed != <span class="number">0</span> &#123;</span><br><span class="line">semrelease(&amp;worldsema)</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// === 标记终止 (STW) ===</span></span><br><span class="line">now := nanotime()</span><br><span class="line">work.tMarkTerm = now</span><br><span class="line">getg().m.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">stw = stopTheWorldWithSema(stwGCMarkTerm)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理ragged barrier后的写屏障产生的工作</span></span><br><span class="line">restart := <span class="literal">false</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">wbBufFlush1(p)</span><br><span class="line"><span class="keyword">if</span> !p.gcw.empty() &#123;</span><br><span class="line">restart = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果又发现新工作，重启并发标记</span></span><br><span class="line"><span class="keyword">if</span> restart &#123;</span><br><span class="line">getg().m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := startTheWorldWithSema(<span class="number">0</span>, stw)</span><br><span class="line">work.pauseNS += now - stw.startedStopping</span><br><span class="line">&#125;)</span><br><span class="line">semrelease(&amp;worldsema)</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用标记和assists</span></span><br><span class="line">atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line">gcWakeAllAssists()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束周期，计算下次GC触发点</span></span><br><span class="line">gcController.endCycle(now, <span class="type">int</span>(gomaxprocs), work.userForced)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行标记终止</span></span><br><span class="line">gcMarkTermination(stw)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再简单解释一下 <strong>Ragged Barrier</strong>：</p><blockquote><p>Ragged Barrier是分布式系统中的一个同步原语，名字来源于它的行为特征：不同处理器/线程到达屏障的时间是"参差不齐"（ragged）的。</p></blockquote><p>用一句话来解释就是 Ragged Barrier是一种异步同步原语，让多个处理单元独立完成各自的本地状态刷新操作，无需等待其他单元，最终达到全局状态一致的目的。</p><p>在并发标记完成检测时，通过 Ragged Barrier 将所有 P的本地缓冲区（写屏障缓冲和工作队列）刷新到全局，使隐藏的工作可见，从而能够正确判断是否真的没有剩余标记工作。</p><h3 id="并发清理-gcsweep">3.4 并发清理 gcSweep()</h3><p>标记完成后，进入扫描阶段，<code>gcSweep()</code>负责初始化和启动垃圾回收的扫描（清理）阶段，将未标记的对象回收，准备下一个GC 周期。</p><p><code>gcSweep()</code> 可以概括为：</p><ol type="1"><li><strong>递增 sweepgen（+2）</strong>：建立新旧 GC 周期的边界</li><li><strong>选择执行模式</strong>：同步立即完成 vs 并发后台进行</li><li><strong>启动扫描机制</strong>：直接调用 sweepone() 或唤醒bgsweep</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 bool：true = 同步扫描完成，false = 后台并发扫描</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcSweep</span><span class="params">(mode gcMode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="comment">// 必须在世界停止（STW）时调用</span></span><br><span class="line">assertWorldStopped()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GC 阶段必须已经切换到 _GCoff（标记已完成）</span></span><br><span class="line"><span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">throw(<span class="string">&quot;gcSweep being done but phase is not GCoff&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备扫描状态</span></span><br><span class="line">lock(&amp;mheap_.lock)</span><br><span class="line">mheap_.sweepgen += <span class="number">2</span>  <span class="comment">// 代数递增 2，后面解释</span></span><br><span class="line">sweep.active.reset()</span><br><span class="line">mheap_.pagesSwept.Store(<span class="number">0</span>)</span><br><span class="line">mheap_.sweepArenas = mheap_.heapArenas <span class="comment">// 记录要扫描的 arenas</span></span><br><span class="line">mheap_.reclaimIndex.Store(<span class="number">0</span>)</span><br><span class="line">mheap_.reclaimCredit.Store(<span class="number">0</span>)</span><br><span class="line">unlock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">sweep.centralIndex.clear()  <span class="comment">// 清空中心索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊情况：同步扫描</span></span><br><span class="line"><span class="keyword">if</span> !concurrentSweep || mode == gcForceBlockMode &#123;</span><br><span class="line">lock(&amp;mheap_.lock)</span><br><span class="line">mheap_.sweepPagesPerByte = <span class="number">0</span></span><br><span class="line">unlock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新所有mcache</span></span><br><span class="line"><span class="keyword">for</span> _, pp := <span class="keyword">range</span> allp &#123;</span><br><span class="line">pp.mcache.prepareForSweep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即扫描所有span</span></span><br><span class="line"><span class="keyword">for</span> sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放工作缓冲区</span></span><br><span class="line">prepareFreeWorkbufs()</span><br><span class="line"><span class="keyword">for</span> freeSomeWbufs(<span class="literal">false</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mProf_NextCycle()</span><br><span class="line">mProf_Flush()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台并发扫描</span></span><br><span class="line">lock(&amp;sweep.lock)</span><br><span class="line"><span class="keyword">if</span> sweep.parked &#123;</span><br><span class="line">sweep.parked = <span class="literal">false</span></span><br><span class="line">ready(sweep.g, <span class="number">0</span>, <span class="literal">true</span>)  <span class="comment">// 唤醒后台扫描 goroutine</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;sweep.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>sweepgen</code> 是一个单调递增的计数器，用于追踪<code>span</code> 的扫描状态，通过设置全局的<code>mheap_.sweepgen</code>，可以巧妙区分不同状态的<code>span</code>，从而避免重复扫描。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sweepgen 的三种状态（对于当前 sweepgen = N）：</span><br><span class="line"></span><br><span class="line">span.sweepgen = N-2  →  未扫描（unswept）</span><br><span class="line">span.sweepgen = N-1  →  正在扫描中</span><br><span class="line">span.sweepgen = N    →  已扫描（swept）</span><br><span class="line"></span><br><span class="line">通过 +2 递增，巧妙地区分了三个状态：</span><br><span class="line">- 当前周期的未扫描：sweepgen - 2</span><br><span class="line">- 当前周期的已扫描：sweepgen</span><br><span class="line">- 正在扫描：sweepgen - 1（CAS 操作时的中间状态）</span><br></pre></td></tr></table></figure><p>有两种扫描方式，分别是同步扫描和并发扫描，并发扫描实际上执行的是<code>bgsweep()</code>，它们俩的核心逻辑都在<code>sweepone()</code>，<code>sweepone()</code> 用于扫描单个<code>span</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sweepone</span><span class="params">()</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">gp := getg()</span><br><span class="line">gp.m.locks++  <span class="comment">// 防止抢占</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取扫描锁</span></span><br><span class="line">sl := sweep.active.begin()</span><br><span class="line"><span class="keyword">if</span> !sl.valid &#123;</span><br><span class="line">gp.m.locks--</span><br><span class="line"><span class="keyword">return</span> ^<span class="type">uintptr</span>(<span class="number">0</span>)  <span class="comment">// 没有工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 查找要扫描的 span</span></span><br><span class="line">npages := ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> noMoreWork <span class="type">bool</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">s := mheap_.nextSpanForSweep()</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">noMoreWork = sweep.active.markDrained()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 span 状态</span></span><br><span class="line"><span class="keyword">if</span> state := s.state.get(); state != mSpanInUse &#123;</span><br><span class="line"><span class="keyword">continue</span>  <span class="comment">// 跳过非使用中的 span</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 尝试获取 span 的扫描所有权，tryAcquire 里面就用到了 sweepgen</span></span><br><span class="line"><span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">npages = s.npages</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 执行扫描</span></span><br><span class="line"><span class="keyword">if</span> s.sweep(<span class="literal">false</span>) &#123;</span><br><span class="line"><span class="comment">// 整个 span 被释放，计入回收积分</span></span><br><span class="line">mheap_.reclaimCredit.Add(npages)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// span 仍在使用，返回 0 页</span></span><br><span class="line">npages = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sweep.active.end(sl)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 如果没有更多工作，唤醒清道夫</span></span><br><span class="line"><span class="keyword">if</span> noMoreWork &#123;</span><br><span class="line">scavenger.ready()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gp.m.locks--</span><br><span class="line"><span class="keyword">return</span> npages</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑都在 <code>s.sweep(false)</code>中，它的核心职责是<strong>回收未标记的对象，准备 span给下次分配使用</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sweep 回收未标记的对象，准备 span 给下次分配使用</span></span><br><span class="line"><span class="comment">// 返回 true 表示 span 已归还堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *sweepLocked)</span></span> sweep(preserve <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    s := sl.mspan</span><br><span class="line">    sweepgen := mheap_.sweepgen</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================== 1. 验证状态 ====================</span></span><br><span class="line">    <span class="comment">// 确保 span 正在使用且处于扫描中状态 (sweepgen-1)</span></span><br><span class="line">    <span class="keyword">if</span> state := s.state.get(); state != mSpanInUse || s.sweepgen != sweepgen<span class="number">-1</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;mspan.sweep: bad span state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================== 2. 处理 Specials ====================</span></span><br><span class="line">    <span class="comment">// 处理 finalizers、弱引用等特殊记录</span></span><br><span class="line">    hadSpecials := s.specials != <span class="literal">nil</span></span><br><span class="line">    siter := newSpecialsIter(s)</span><br><span class="line">    <span class="keyword">for</span> siter.valid() &#123;</span><br><span class="line">        objIndex := <span class="type">uintptr</span>(siter.s.offset) / size</span><br><span class="line">        p := s.base() + objIndex*size</span><br><span class="line">        mbits := s.markBitsForIndex(objIndex)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !mbits.isMarked() &#123;</span><br><span class="line">            <span class="comment">// 对象未标记（将被回收）</span></span><br><span class="line">            hasFinAndRevived := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Pass 1: 检查是否有 finalizer</span></span><br><span class="line">            <span class="keyword">for</span> tmp := siter.s; tmp != <span class="literal">nil</span> &amp;&amp; <span class="type">uintptr</span>(tmp.offset) &lt; endOffset; tmp = tmp.next &#123;</span><br><span class="line">                <span class="keyword">if</span> tmp.kind == _KindSpecialFinalizer &#123;</span><br><span class="line">                    <span class="comment">// 有 finalizer：复活对象！</span></span><br><span class="line">                    mbits.setMarkedNonAtomic()  <span class="comment">// 重新标记为存活</span></span><br><span class="line">                    hasFinAndRevived = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> hasFinAndRevived &#123;</span><br><span class="line">                <span class="comment">// Pass 2: 将 finalizer 加入执行队列，清除弱引用</span></span><br><span class="line">                <span class="keyword">for</span> siter.valid() &amp;&amp; <span class="type">uintptr</span>(siter.s.offset) &lt; endOffset &#123;</span><br><span class="line">                    special := siter.s</span><br><span class="line">                    p := s.base() + <span class="type">uintptr</span>(special.offset)</span><br><span class="line">                    <span class="keyword">if</span> special.kind == _KindSpecialFinalizer || special.kind == _KindSpecialWeakHandle &#123;</span><br><span class="line">                        siter.unlinkAndNext()</span><br><span class="line">                        freeSpecial(special, unsafe.Pointer(p), size)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        siter.next()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Pass 2: 对象真的死了，释放所有 specials</span></span><br><span class="line">                <span class="keyword">for</span> siter.valid() &amp;&amp; <span class="type">uintptr</span>(siter.s.offset) &lt; endOffset &#123;</span><br><span class="line">                    special := siter.s</span><br><span class="line">                    p := s.base() + <span class="type">uintptr</span>(special.offset)</span><br><span class="line">                    siter.unlinkAndNext()</span><br><span class="line">                    freeSpecial(special, unsafe.Pointer(p), size)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对象存活，保留 specials</span></span><br><span class="line">            <span class="keyword">if</span> siter.s.kind == _KindSpecialReachable &#123;</span><br><span class="line">                special := siter.unlinkAndNext()</span><br><span class="line">                (*specialReachable)(unsafe.Pointer(special)).reachable = <span class="literal">true</span></span><br><span class="line">                freeSpecial(special, unsafe.Pointer(p), size)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                siter.next()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================== 3. 检查僵尸对象 ====================</span></span><br><span class="line">    <span class="comment">// 僵尸对象 = 被标记但未分配（理论上不应存在）</span></span><br><span class="line">    <span class="keyword">if</span> s.freeindex &lt; s.nelems &#123;</span><br><span class="line">        obj := <span class="type">uintptr</span>(s.freeindex)</span><br><span class="line">        <span class="comment">// 检查：gcmarkBits 为 1 且 allocBits 为 0</span></span><br><span class="line">        <span class="keyword">if</span> (*s.gcmarkBits.bytep(obj/<span class="number">8</span>) &amp;^ *s.allocBits.bytep(obj/<span class="number">8</span>))&gt;&gt;(obj%<span class="number">8</span>) != <span class="number">0</span> &#123;</span><br><span class="line">            s.reportZombies()  <span class="comment">// 报告错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := obj/<span class="number">8</span> + <span class="number">1</span>; i &lt; divRoundUp(<span class="type">uintptr</span>(s.nelems), <span class="number">8</span>); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> *s.gcmarkBits.bytep(i) &amp;^ *s.allocBits.bytep(i) != <span class="number">0</span> &#123;</span><br><span class="line">                s.reportZombies()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================== 4. 【核心】位图交换 ====================</span></span><br><span class="line">    <span class="comment">// gcmarkBits 变成 allocBits（标记结果变成分配状态）</span></span><br><span class="line">    s.allocBits = s.gcmarkBits</span><br><span class="line">    <span class="comment">// 获取新的空白 gcmarkBits，为下次 GC 准备</span></span><br><span class="line">    s.gcmarkBits = newMarkBits(<span class="type">uintptr</span>(s.nelems))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新 pinnerBits（如果存在）</span></span><br><span class="line">    <span class="keyword">if</span> s.pinnerBits != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.refreshPinnerBits()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化分配位缓存</span></span><br><span class="line">    s.refillAllocCache(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================== 5. 更新 sweepgen ====================</span></span><br><span class="line">    <span class="comment">// 原子更新：sweepgen-1 → sweepgen（标记为已扫描）</span></span><br><span class="line">    atomic.Store(&amp;s.sweepgen, sweepgen)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================== 6. 归类 span ====================</span></span><br><span class="line">    <span class="keyword">if</span> spc.sizeclass() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 小对象 span</span></span><br><span class="line">        <span class="keyword">if</span> nfreed &gt; <span class="number">0</span> &#123;</span><br><span class="line">            s.needzero = <span class="number">1</span>  <span class="comment">// 标记需要清零</span></span><br><span class="line">            <span class="comment">// 更新统计信息</span></span><br><span class="line">            gcController.totalFree.Add(<span class="type">int64</span>(nfreed) * <span class="type">int64</span>(s.elemsize))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !preserve &#123;</span><br><span class="line">            <span class="keyword">if</span> nalloc == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 完全空闲：直接归还给堆</span></span><br><span class="line">                mheap_.freeSpan(s)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nalloc == s.nelems &#123;</span><br><span class="line">                <span class="comment">// 完全占满：放入 fullSwept 列表</span></span><br><span class="line">                mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 部分占用：放入 partialSwept 列表</span></span><br><span class="line">                mheap_.central[spc].mcentral.partialSwept(sweepgen).push(s)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !preserve &#123;</span><br><span class="line">        <span class="comment">// 大对象 span</span></span><br><span class="line">        <span class="keyword">if</span> nfreed != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 释放大对象到堆</span></span><br><span class="line">            gcController.totalFree.Add(<span class="type">int64</span>(size))</span><br><span class="line">            mheap_.freeSpan(s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加到 fullSwept 列表</span></span><br><span class="line">        mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理流程可参考下图进行理解：</p><pre class="mermaid">flowchart TD    Start([sweep 入口]) --> Verify[验证状态<br/>sweepgen == global-1]    Verify --> Specials[处理 Specials]    Specials --> FinCheck{有 finalizer?}    FinCheck -->|是| Revive[复活对象<br/>加入执行队列]    FinCheck -->|否| FreeSp[释放 specials]    Revive --> Zombie    FreeSp --> Zombie    Zombie[检查僵尸对象] --> ZombieCheck{存在?}    ZombieCheck -->|是| Error[throw]    ZombieCheck -->|否| Core    Core[核心: 位图交换]:::highlight    Core --> Swap["allocBits = gcmarkBits<br/>gcmarkBits = new()"]:::highlight    Swap --> Update[更新 sweepgen<br/>global-1 → global]    Update --> Classify[归类 span]    Classify --> CheckN{nalloc?}    CheckN -->|0| ToHeap[freeSpan<br/>归还堆]    CheckN -->|nelems| ToFull[fullSwept<br/>完全占满]    CheckN -->|其他| ToPartial[partialSwept<br/>部分占用]    ToHeap --> RetTrue[return true]    ToFull --> RetFalse[return false]    ToPartial --> RetFalse    RetTrue --> End([结束])    RetFalse --> End    Error --> End    classDef highlight fill:#ffeb3b,stroke:#f57c00,stroke-width:3px    style Start fill:#4caf50,color:#fff    style End fill:#4caf50,color:#fff</pre><h3 id="计算下次触发点">3.5 计算下次触发点</h3><p>GC 结束时，通过 pacer 计算下次触发点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 gcController.endCycle 中计算</span></span><br><span class="line"><span class="comment">// 基本公式：</span></span><br><span class="line"><span class="comment">// heapGoal = heapMarked * (1 + GOGC/100)</span></span><br><span class="line"><span class="comment">// trigger = heapGoal - runway</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中：</span></span><br><span class="line"><span class="comment">// - heapMarked: 标记阶段存活的堆大小</span></span><br><span class="line"><span class="comment">// - GOGC: 环境变量，默认100</span></span><br><span class="line"><span class="comment">// - runway: 给 GC 留出的缓冲空间，让它能在 heapGoal 前完成标记</span></span><br></pre></td></tr></table></figure><p>简单来说，Pacer 通过测量上次 GC的分配速率和扫描速率，计算出一个合适的触发点（Trigger），让 GC既不会太频繁（浪费CPU），也不会太晚（OOM），实现自适应的垃圾回收调度。</p><h3 id="stw-分析">3.6 STW 分析</h3><pre class="mermaid">graph TB    %% 定义样式    classDef stw fill:#ffcdd2,stroke:#c62828,stroke-width:2px,color:#b71c1c;    classDef concurrent fill:#e1f5fe,stroke:#0277bd,stroke-width:2px,color:#01579b;    classDef trigger fill:#fff9c4,stroke:#fbc02d,stroke-dasharray: 5 5,color:#f57f17;    %% 节点定义    subgraph Cycle [GC 循环周期]        direction TB        P1(Phase 1: Sweep Termination<br/>清扫终止):::stw        P2(Phase 2: Concurrent Mark<br/>并发标记):::concurrent        P3(Phase 3: Mark Termination<br/>标记终止):::stw        P4(Phase 4: Concurrent Sweep<br/>并发清扫):::concurrent    end    %% 触发条件    Trigger(GC Trigger<br/>堆阈值/定时/手动):::trigger    %% 连线关系    Trigger --> P1    P1 -->|开启写屏障<br/>SetGCPhase: _GCmark| P2    P2 -->|所有对象标记完成<br/>gcMarkDone| P3    P3 -->|关闭写屏障<br/>SetGCPhase: _GCoff| P4    P4 -->|清理结束 & 等待下一轮| Trigger    %% 补充说明    note1[STW: 准备根对象, 清理上一轮残余] -.-> P1    note2[STW: 保证全局标记完成, 必须全局一致] -.-> P3</pre><p>我们再来看一下这张图，分析一下为什么 ① ③ 阶段需要 STW，而 ② ④却不需要呢？</p><h4 id="sweep-termination---stw">Sweep Termination - STW</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">需要做的事：</span><br><span class="line">├─ 完成上一轮剩余的扫描</span><br><span class="line">├─ 清理 sync.Pool</span><br><span class="line">├─ 重置标记状态 (gcResetMarkState)</span><br><span class="line">├─ 启用写屏障 (setGCPhase(_GCmark))</span><br><span class="line">└─ 准备根对象扫描</span><br></pre></td></tr></table></figure><p><strong>必须 STW 的核心原因</strong>：</p><ul><li><strong>写屏障必须同时在所有 P 上生效</strong></li><li>如果不 STW，某些 P 开启了写屏障，某些还没开</li><li>会导致指针写入不一致，漏标记对象 ❌</li></ul><h4 id="mark-termination---stw">Mark Termination - STW</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">需要做的事：</span><br><span class="line">├─ 禁用 workers 和 assists</span><br><span class="line">├─ 刷新缓存 (mcache flush)</span><br><span class="line">├─ 禁用写屏障</span><br><span class="line">├─ 切换阶段 (setGCPhase(_GCoff))</span><br><span class="line">└─ 启动清扫 (gcSweep)</span><br></pre></td></tr></table></figure><p><strong>必须 STW 的核心原因</strong>：</p><ul><li><strong>需要全局一致性视图</strong>：确认所有标记工作真的完成了</li><li><strong>禁用写屏障必须原子</strong>：不能有些 P关了，有些还开着</li><li><strong>位图状态切换</strong>：sweepgen += 2需要在稳定状态下进行</li></ul><h4 id="mark-phase---并发">Mark Phase - 并发</h4><p><strong>为什么可以并发？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有写屏障保护：</span><br><span class="line">mutator 写指针 → 写屏障记录 → 标记为灰色</span><br><span class="line">workers 并发标记 → 不会漏标记对象 ✓</span><br><span class="line"></span><br><span class="line">三色不变式保证正确性：</span><br><span class="line">- 强三色：黑色对象不能直接指向白色对象</span><br><span class="line">- 弱三色：黑色→白色之间必有灰色对象</span><br></pre></td></tr></table></figure><p><strong>关键技术</strong>：</p><ul><li><strong>写屏障</strong>：Dijkstra 插入屏障，拦截所有指针写入</li><li><strong>并发安全</strong>：标记位操作是原子的</li><li><strong>增量处理</strong>：每个 worker 独立工作，不需要全局同步</li></ul><h4 id="sweep-phase---并发">Sweep Phase - 并发</h4><p><strong>为什么可以并发？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">扫描和分配互不干扰：</span><br><span class="line">├─ 扫描：检查 span.sweepgen，CAS 获取所有权</span><br><span class="line">├─ 分配：检查 span.sweepgen，只用已扫描的 span</span><br><span class="line">└─ sweepgen 机制保证不会重复扫描 ✓</span><br><span class="line"></span><br><span class="line">惰性扫描：</span><br><span class="line">分配时按需扫描，保证使用的 span 都是干净的</span><br></pre></td></tr></table></figure><p><strong>关键技术</strong>：</p><ul><li><strong>sweepgen 版本控制</strong>：每个 span 有独立状态</li><li><strong>CAS 操作</strong>：原子获取扫描所有权</li><li><strong>按需扫描</strong>：分配路径自动扫描，不阻塞其他操作</li></ul><h4 id="对比总结">对比总结</h4><blockquote><p>[!IMPORTANT]</p><p>Sweep Termination 和 Mark Termination 需要 STW是因为必须原子地切换写屏障状态和确认全局一致性，而 Mark Phase 和 SweepPhase 可以并发是因为有写屏障和 sweepgen 机制保护，不需要全局同步。</p><p><strong>本质</strong>：STW用于<strong>状态切换</strong>，并发用于<strong>实际工作</strong>。🎯</p></blockquote><table><thead><tr><th>阶段</th><th>STW</th><th>原因</th><th>时长</th></tr></thead><tbody><tr><td><strong>Sweep Termination</strong></td><td>✋ 是</td><td>同步启用写屏障</td><td>~100μs</td></tr><tr><td><strong>Mark Phase</strong></td><td>✅ 否</td><td>写屏障保护</td><td>~数十 ms</td></tr><tr><td><strong>Mark Termination</strong></td><td>✋ 是</td><td>全局一致性确认</td><td>~100μs</td></tr><tr><td><strong>Sweep Phase</strong></td><td>✅ 否</td><td>sweepgen + CAS</td><td>~数十 ms</td></tr></tbody></table><h3 id="核心机制总结">3.7 核心机制总结</h3><ol type="1"><li><strong>三色标记法</strong>：白色（未扫描）→ 灰色（已发现）→黑色（已扫描）</li><li><strong>混合写屏障</strong>：Dijkstra + Yuasa保证并发标记的正确性</li><li><strong>分布式终止检测</strong>：Ragged Barrier确保所有本地缓冲区都被刷新</li><li><strong>MutatorAssist</strong>：分配速度过快时，分配者协助标记以保持 GC 进 度</li><li><strong>代数机制</strong>：<code>sweepgen</code> 通过 +2的方式区分不同 GC 周期的 span 状态</li></ol><p>整个 GC周期是一个精密设计的并发系统，在保证程序正确性的同时，最大化地减少 STW时间，实现了低延迟的垃圾回收。</p><h2 id="工程建议">4. 工程建议</h2><h3 id="参数调优">4.1 参数调优</h3><h4 id="gogc-参数">4.1.1 GOGC 参数</h4><p>GOGC 控制 GC 的激进程度：</p><table><thead><tr><th style="text-align: left;">GOGC 值</th><th style="text-align: left;">含义</th><th style="text-align: left;">效果</th></tr></thead><tbody><tr><td style="text-align: left;">GOGC=off</td><td style="text-align: left;">禁用 GC</td><td style="text-align: left;">内存会无限增长</td></tr><tr><td style="text-align: left;">GOGC=50</td><td style="text-align: left;">堆增长 50% 触发</td><td style="text-align: left;">频繁 GC，低内存使用</td></tr><tr><td style="text-align: left;">GOGC=100</td><td style="text-align: left;">堆增长 100% 触发（默认）</td><td style="text-align: left;">平衡</td></tr><tr><td style="text-align: left;">GOGC=200</td><td style="text-align: left;">堆增长 200% 触发</td><td style="text-align: left;">低频 GC，高内存使用</td></tr><tr><td style="text-align: left;">GOGC=400</td><td style="text-align: left;">堆增长 400% 触发</td><td style="text-align: left;">极低频 GC，极高内存</td></tr></tbody></table><h4 id="gomemlimit">4.1.2 GOMEMLIMIT</h4><p>Go1.19 新增的软内存限制，优先级高于 GOGC，<code>GOMEMLIMIT</code> 让Go 程序知道"不能超过多少内存"，接近时自动加大 GC 力度，既防止 OOM又提高内存利用率，是容器化部署的必备配置。</p><p>建议配置为：<code>GOMEMLIMIT = 容器限制 × 0.9</code>。</p><h3 id="性能优化">4.2 性能优化</h3><ol type="1"><li>减少分配</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 避免：频繁小对象分配</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">    s := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, i)  <span class="comment">// 每次分配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 优化：复用 buffer</span></span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">    buf.Reset()</span><br><span class="line">    fmt.Fprintf(&amp;buf, <span class="string">&quot;%d&quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>对象池复用</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bufPool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">buf := bufPool.Get().(*bytes.Buffer)</span><br><span class="line"><span class="keyword">defer</span> bufPool.Put(buf)</span><br><span class="line">buf.Reset()</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>预分配切片</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 避免：动态扩容</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, i)  <span class="comment">// 多次扩容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 优化：预分配</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>避免指针密集结构</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 避免：大量指针</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Value *<span class="type">int</span></span><br><span class="line">    Next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 优化：值类型</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Value <span class="type">int</span></span><br><span class="line">    Next  *Node  <span class="comment">// 只保留必要指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>栈分配优先</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 逃逸到堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bad</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    x := <span class="number">42</span></span><br><span class="line">    <span class="keyword">return</span> &amp;x  <span class="comment">// 逃逸</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 栈分配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">good</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    x := <span class="number">42</span></span><br><span class="line">    <span class="keyword">return</span> x  <span class="comment">// 栈上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析工具">4.3 分析工具</h3><ul><li>go tool pprof</li><li>go tool trace</li><li>go build -gcflags -m</li><li>GODEBUG="gctrace=1"</li></ul><p>以下面程序为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line">  _ <span class="string">&quot;net/http/pprof&quot;</span><span class="comment">// pprof 需要</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> counter <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e10</span>; i++ &#123;</span><br><span class="line">counter++</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(&amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">_ = http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>go tool pprof</p><p>启动程序后，访问：http://127.0.0.1:8080/debug/pprof/heap?debug=1</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5urh515n9j225g0tk7aw.jpg" /></p></li><li><p>go build -gcflags -m</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  go build -gcflags -m main.go</span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./main.go:15:7: can inline main.func1.1</span><br><span class="line">./main.go:15:4: can inline main.func1.gowrap1</span><br><span class="line">./main.go:20:12: inlining call to <span class="built_in">sync</span>.(*WaitGroup).Done</span><br><span class="line">./main.go:21:5: inlining call to main.func1.1</span><br><span class="line">./main.go:21:5: inlining call to <span class="built_in">sync</span>.(*WaitGroup).Done</span><br><span class="line">./main.go:26:25: inlining call to http.ListenAndServe</span><br><span class="line">./main.go:15:12: leaking param: wg</span><br><span class="line">./main.go:12:3: moved to heap: wg</span><br><span class="line">./main.go:15:7: func literal escapes to heap</span><br><span class="line">./main.go:11:5: func literal escapes to heap</span><br><span class="line">./main.go:26:25: &amp;http.Server&#123;...&#125; escapes to heap</span><br></pre></td></tr></table></figure></li><li><p>GODEBUG="gctrace=1"</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  GODEBUG=&quot;gctrace=1&quot; go run main.go</span><br><span class="line">gc 1 @0.003s 3%: 0.056+0.93+0.074 ms clock, 0.68+0.18/0.53/0+0.89 ms cpu, 3-&gt;4-&gt;1 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 2 @0.005s 5%: 0.060+1.2+0.061 ms clock, 0.72+0.30/0.75/0+0.73 ms cpu, 3-&gt;4-&gt;1 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 3 @0.007s 6%: 0.037+0.92+0.079 ms clock, 0.45+0.32/0.80/0+0.95 ms cpu, 3-&gt;3-&gt;1 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 4 @0.008s 6%: 0.068+1.4+0.058 ms clock, 0.82+0.20/0.78/0+0.69 ms cpu, 3-&gt;4-&gt;1 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 5 @0.011s 6%: 0.015+0.44+0.013 ms clock, 0.18+0.020/0.85/1.0+0.15 ms cpu, 3-&gt;4-&gt;1 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 6 @0.014s 5%: 0.036+0.42+0.019 ms clock, 0.43+0.051/0.97/1.4+0.22 ms cpu, 3-&gt;3-&gt;2 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 7 @0.017s 6%: 0.067+1.0+0.029 ms clock, 0.81+0.23/2.4/4.8+0.35 ms cpu, 4-&gt;4-&gt;3 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 8 @0.027s 5%: 0.42+1.0+0.035 ms clock, 5.1+0.11/2.0/1.7+0.42 ms cpu, 5-&gt;6-&gt;4 MB, 6 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 9 @0.034s 5%: 0.078+0.83+0.023 ms clock, 0.94+0.28/1.9/1.6+0.28 ms cpu, 7-&gt;8-&gt;4 MB, 8 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 10 @0.037s 5%: 0.029+0.66+0.012 ms clock, 0.35+0.069/1.5/2.6+0.15 ms cpu, 8-&gt;8-&gt;3 MB, 9 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 11 @0.039s 5%: 0.041+0.58+0.003 ms clock, 0.49+0.059/1.4/2.5+0.045 ms cpu, 6-&gt;6-&gt;3 MB, 7 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 12 @0.041s 6%: 0.086+0.94+0.010 ms clock, 1.0+0.83/2.1/0.19+0.12 ms cpu, 6-&gt;8-&gt;4 MB, 7 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 13 @0.043s 6%: 0.064+0.73+0.008 ms clock, 0.77+0.30/1.6/1.2+0.096 ms cpu, 8-&gt;9-&gt;4 MB, 9 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 14 @0.044s 6%: 0.043+0.73+0.028 ms clock, 0.51+0.12/1.6/1.9+0.34 ms cpu, 7-&gt;9-&gt;4 MB, 9 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 15 @0.046s 7%: 0.077+1.0+0.022 ms clock, 0.92+2.5/2.3/0.047+0.27 ms cpu, 7-&gt;10-&gt;5 MB, 9 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 16 @0.048s 7%: 0.057+0.59+0.011 ms clock, 0.69+0.83/1.4/0.48+0.13 ms cpu, 8-&gt;10-&gt;4 MB, 10 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br><span class="line">gc 17 @0.050s 7%: 0.025+0.52+0.003 ms clock, 0.30+0.098/1.4/2.1+0.039 ms cpu, 8-&gt;9-&gt;3 MB, 10 MB goal, 0 MB stacks, 0 MB globals, 12 P</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">本文深入剖析 Go 语言中的三色标记法垃圾回收机制，从基本原理、核心算法到运行时实现细节，系统讲解可达性分析、对象标记过程、并发与屏障机制等关键技术，帮助读者全面理解 Go GC 的设计理念与实际应用场景。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="垃圾回收" scheme="https://hedon.top/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    <category term="三色标记法" scheme="https://hedon.top/tags/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Go 底层原理丨内存模型</title>
    <link href="https://hedon.top/2025/11/17/go/go-memory-model/"/>
    <id>https://hedon.top/2025/11/17/go/go-memory-model/</id>
    <published>2025-11-17T06:30:00.000Z</published>
    <updated>2025-12-08T06:23:52.446Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[!NOTE]</p><p>💡 本文基于 Go 1.25.3 源码编写，相比 Go 1.16 版本，增加了 UserArena、Weak Pointer、Cleanup机制等重要特性。后续版本可能会有变化。建议结合实际使用的 Go版本阅读相关源码。</p><p>特此声明，本篇是笔者与 Google Gemini 3Pro 共创所作，非常庆幸在当今 AI时代下获取知识已是如此便利，且也为学习者从第一性原理理解所学知识大大降低了门槛。不过本篇的篇章安排和叙述逻辑，均由笔者把控和审阅，欢迎放心阅读。</p></blockquote><h2 id="结论先行">结论先行</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f6536633964323465677931683575666b306f3079756a3231657a3075303736662e6a7067.jpeg"alt="Go内存模型架构" /><figcaption aria-hidden="true">Go内存模型架构</figcaption></figure><p>Go 的内存分配器设计源于<strong>TCMalloc</strong>，采用了多层级缓存架构来减少锁竞争并提高性能。核心设计如下：</p><h3 id="核心架构">核心架构</h3><ul><li>Go 将堆内存抽象为 <strong>mheap</strong> 结构体；</li><li>Go 进程会从虚拟内存中申请 n 个 <strong>heapArena</strong>（64位系统每个 64MB）；</li><li>每个 heapArena 被按需划分成不同 class 的<strong>mspan</strong>，共有 <strong>68</strong> 个 size class；</li><li>每个 mspan 由 n 个相同大小的 span 组成；</li><li>为了快速定位合适的 span，为 mheap 建立了 <strong>136</strong>个中央索引 <strong>mcentral</strong>；</li><li>每个 mcentral 存储对应 class 的 mspan，每种 mspan 又划分为 gc scan和 no scan 两种，故共有 68 × 2 = 136 个 mcentral；</li><li>为了解决中央索引的并发锁竞争问题，为每一个 P（线程）建立一个本地缓存<strong>mcache</strong>；</li><li>每个 mcache 存储 <strong>136</strong> 个 span，分别是每种 class 的mspan 的一个 scan 和 noscan 的 span。</li></ul><h3 id="内存分配策略">内存分配策略</h3><ul><li>Go 中根据对象大小分为 <strong>tiny</strong>、<strong>small</strong>和 <strong>large</strong> 三种对象；</li><li>tiny (0~16B 无指针) 对象主要分配到 class 2 的 span 中（通过 tinyallocator）；</li><li>small (16B~32KB) 对象会被分配到 class 2 ~ class 67 的 span 中；</li><li>class 1 (8B) 仅用于 64 位平台上的单指针对象，使用极少；</li><li>large (&gt;32KB) 对象会量身定做分配到 class0 的 span 中，直接从mheap 上申请；</li><li>为对象分配内存时，会先从 mcache 上找 span，找不到就去 mcentral上交换，还找不到就去 mheap 上申请，最后找不到就 OOM。</li></ul><h2 id="协程栈">1. 协程栈</h2><h3 id="作用">1.1 作用</h3><p>协程栈是 Go 协程执行的核心数据结构，主要用于：</p><ul><li><strong>记录执行路径</strong>：追踪函数调用链</li><li><strong>存储局部变量</strong>：每个栈帧保存函数的局部变量</li><li><strong>函数传参</strong>：通过栈传递函数参数</li><li><strong>保存返回值</strong>：存储函数的返回值</li></ul><h3 id="位置">1.2 位置</h3><ul><li>Go 协程栈位于 <strong>Go 堆内存</strong>上（而非操作系统栈）</li><li>Go 堆内存位于<strong>操作系统虚拟内存</strong>上</li><li>这种设计使得 Go 可以灵活管理协程栈的大小</li></ul><h3 id="图解">1.3 图解</h3><p>以下面的代码为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  sum := <span class="number">0</span></span><br><span class="line">  sum = a + b</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="number">3</span></span><br><span class="line">  b := <span class="number">5</span></span><br><span class="line">  <span class="built_in">print</span>(sum(a, b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈帧结构如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f65366339643234656779316835746934766b3936356a32316937307530676f772e6a7067.jpeg"alt="协程栈结构" /><figcaption aria-hidden="true">协程栈结构</figcaption></figure><h3 id="参数传递">1.4 参数传递</h3><p><strong>Go 采用值传递</strong></p><ul><li>传递结构体时：<strong>拷贝结构体中的全部内容</strong></li><li>传递结构体指针时：<strong>拷贝结构体指针</strong>（8 字节）</li></ul><h3 id="栈大小">1.5 栈大小</h3><p>Go 1.25.3 中，协程栈的初始大小为<strong>2KB</strong>，相比早期版本（如 Go 1.2 的 8KB）更加轻量。</p><h3 id="逃逸分析">1.6 逃逸分析</h3><p>不是所有的变量都能放在协程栈上。以下三种情况会导致变量<strong>逃逸到堆</strong>上：</p><h4 id="指针逃逸">1. 指针逃逸</h4><p>函数返回局部变量的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span></span> *<span class="type">int</span> &#123;</span><br><span class="line">    x := <span class="number">42</span></span><br><span class="line">    <span class="keyword">return</span> &amp;x  <span class="comment">// x 逃逸到堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空接口逃逸">2. 空接口逃逸</h4><p>函数参数为 <code>interface&#123;&#125;</code>，编译器无法确定具体类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">println</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  <span class="comment">// v 可能逃逸</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="大变量逃逸">3. 大变量逃逸</h4><p>变量太大，栈帧放不下。在 64 位机器中，一般超过 <strong>64KB</strong>的变量就会逃逸。</p><h3 id="栈扩容">1.7 栈扩容</h3><p>Go 栈的初始空间为 2KB。在函数调用前会执行 <code>morestack</code>判断栈空间是否足够。</p><h4 id="栈扩容策略演进">栈扩容策略演进</h4><ul><li><p><strong>分段栈</strong>（Go 1.3 之前）</p><ul><li>优点：没有空间浪费</li><li>缺点：栈帧在不连续的空间之间横跳，性能较差（"热分裂"问题）</li></ul></li><li><p><strong>连续栈</strong>（Go 1.3 及之后）</p><ul><li>优点：空间连续，性能更好</li><li>缺点：扩容时需要拷贝，开销较大</li><li>策略：小于 1KB 时翻倍，否则增长 25%</li></ul></li></ul><hr /><h2 id="虚拟内存单元-heaparena">2. 虚拟内存单元 heapArena</h2><h3 id="概述">2.1 概述</h3><ul><li>在物理内存为 64GB 的机器中，每个 Go 进程最多可被分配到<strong>256TB</strong> 的虚拟内存</li><li>Go 的虚拟内存单元为 <code>heapArena</code>，每次申请<strong>64MB</strong>（64 位非 Windows 系统）</li><li>最多可以申请 <strong>2²⁰</strong> (约 100 万) 个 heapArena</li><li>所有的 <code>heapArena</code> 组成了 <code>mheap</code>（Go堆内存）</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f6536633964323465677931683575647a7a6c3436316a3231696130656b6468772e6a7067.jpeg"alt="heapArena 结构" /><figcaption aria-hidden="true">heapArena 结构</figcaption></figure><blockquote><p>💡 <strong>相关阅读</strong>：<ahref="https://hedon954.github.io/noteSite/cs/os/04-os-store.html#_6-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">操作系统- 虚拟内存</a></p></blockquote><h3 id="底层结构">2.2 底层结构</h3><p><code>heapArena</code> 定义在 <ahref="https://github.com/golang/go/blob/go1.25.3/src/runtime/mheap.go#L266">runtime/mheap.go#L266</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> heapArena <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spans 将 arena 中的虚拟页 ID 映射到 mspan</span></span><br><span class="line">    spans [pagesPerArena]*mspan</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pageInUse 是位图，标记哪些页正在被使用</span></span><br><span class="line">    pageInUse [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pageMarks 用于 GC，标记哪些 span 有被标记的对象</span></span><br><span class="line">    pageMarks [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pageSpecials 标记哪些 span 有 special 记录（finalizer 等）</span></span><br><span class="line">    pageSpecials [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pageUseSpanInlineMarkBits 标记使用内联 mark bits 的 span</span></span><br><span class="line">    pageUseSpanInlineMarkBits [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// checkmarks 用于 GC 调试</span></span><br><span class="line">    checkmarks *checkmarksMap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zeroedBase 标记第一个未使用且已归零的页</span></span><br><span class="line">    zeroedBase <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分配策略对比">2.3 分配策略对比</h3><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr><th>线性分配</th><th>链表分配</th><th>分级分配</th></tr></thead><tbody><tr><td><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h5uebsvbasj21ei0ne76j.jpg"alt="线性分配" /></td><td><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h5ueba2f53j21fi0n641m.jpg"alt="链表分配" /></td><td><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h5uedvcmcdj21dw0mm79w.jpg"alt="分级分配" /></td></tr><tr><td>实现简单，但内存碎片较多</td><td>将空闲块连接起来，牺牲部分性能来缓解内存碎片</td><td>将内存按级别分成很多块，根据对象大小存放在能容纳它的最小块中</td></tr></tbody></table><blockquote><p><strong>Go 采用分级分配策略</strong>，参考了 <ahref="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc</a>，将每一个级定义为<code>mspan</code>。</p></blockquote><h2 id="内存管理单元-mspan">3. 内存管理单元 mspan</h2><h3 id="概述-1">3.1 概述</h3><ul><li>Go 使用内存时的基本单位是 <code>mspan</code></li><li>每个 <code>mspan</code> 由 N 个相同大小的 <code>span</code>组成</li><li>Go 1.25.3 中有 <strong>68</strong> 种 size class（class 0 ~ class67）</li></ul><h4 id="size-class-表部分">Size Class 表（部分）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/sizeclasses.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class  bytes/obj  bytes/span  objects  tail waste  max waste</span></span><br><span class="line"><span class="comment">//     0          0           0        0           0      0.00%</span></span><br><span class="line"><span class="comment">//     1          8        8192     1024           0     87.50%</span></span><br><span class="line"><span class="comment">//     2         16        8192      512           0     43.75%</span></span><br><span class="line"><span class="comment">//     3         24        8192      341           8     29.24%</span></span><br><span class="line"><span class="comment">//     4         32        8192      256           0     11.72%</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//    64      24576       24576        1           0     11.45%</span></span><br><span class="line"><span class="comment">//    65      27264       81920        3         128     10.00%</span></span><br><span class="line"><span class="comment">//    66      28672       57344        2           0      4.91%</span></span><br><span class="line"><span class="comment">//    67      32768       32768        1           0     12.50%</span></span><br></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h5uemrzou7j217a0kwadr.jpg"alt="mspan 结构" /><figcaption aria-hidden="true">mspan 结构</figcaption></figure><h3 id="底层结构-1">3.2 底层结构</h3><p><code>mspan</code> 定义在 <ahref="https://github.com/golang/go/blob/go1.25.3/src/runtime/mheap.go#L420">runtime/mheap.go#L420</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表</span></span><br><span class="line">    next *mspan</span><br><span class="line">    prev *mspan</span><br><span class="line">    list *mSpanList</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存地址和大小</span></span><br><span class="line">    startAddr <span class="type">uintptr</span>    <span class="comment">// 起始地址</span></span><br><span class="line">    npages    <span class="type">uintptr</span>    <span class="comment">// 页数（每页 8KB）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配信息</span></span><br><span class="line">    freeindex        <span class="type">uint16</span>      <span class="comment">// 下一个空闲对象的索引</span></span><br><span class="line">    freeIndexForScan <span class="type">uint16</span>      <span class="comment">// GC 扫描器使用的索引（Go 1.19+）</span></span><br><span class="line">    nelems           <span class="type">uint16</span>      <span class="comment">// 对象总数</span></span><br><span class="line">    allocCount       <span class="type">uint16</span>      <span class="comment">// 已分配对象数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位图</span></span><br><span class="line">    allocBits  *gcBits   <span class="comment">// 分配位图</span></span><br><span class="line">    gcmarkBits *gcBits   <span class="comment">// GC 标记位图</span></span><br><span class="line">    pinnerBits *gcBits   <span class="comment">// 固定对象位图（Go 1.21+）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元数据</span></span><br><span class="line">    spanclass  spanClass      <span class="comment">// size class 和 noscan 标志</span></span><br><span class="line">    elemsize   <span class="type">uintptr</span>        <span class="comment">// 对象大小</span></span><br><span class="line">    state      mSpanStateBox  <span class="comment">// mspan 状态</span></span><br><span class="line">    sweepgen   <span class="type">uint32</span>         <span class="comment">// 清扫代数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增字段（Go 1.20+）</span></span><br><span class="line">    isUserArenaChunk <span class="type">bool</span>       <span class="comment">// 是否为 user arena chunk</span></span><br><span class="line">    userArenaChunkFree addrRange <span class="comment">// user arena 管理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GreenTeaGC 实验字段（Go 1.24+）</span></span><br><span class="line">    scanIdx <span class="type">uint16</span>  <span class="comment">// 扫描索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大对象类型信息（Go 1.22+）</span></span><br><span class="line">    largeType *_type</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special 记录</span></span><br><span class="line">    speciallock mutex</span><br><span class="line">    specials    *special</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键字段说明">3.3 关键字段说明</h3><h4 id="分配位图allocbits">3.3.1 分配位图（allocBits）</h4><p>使用位图标记对象是否已分配：</p><ul><li><code>0</code> 表示空闲</li><li><code>1</code> 表示已分配</li></ul><h4 id="双索引设计go-1.19">3.3.2 双索引设计（Go 1.19+）</h4><ul><li><code>freeindex</code>：分配器使用</li><li><code>freeIndexForScan</code>：GC 扫描器使用</li></ul><p>这样设计避免了竞争条件，确保 GC 只在对象完全初始化后才能看到它。</p><h4 id="状态机">3.3.2 状态机</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mSpanDead   mSpanState = <span class="literal">iota</span>  <span class="comment">// 未使用</span></span><br><span class="line">    mSpanInUse                     <span class="comment">// 正在使用</span></span><br><span class="line">    mSpanManual                    <span class="comment">// 手动管理（如栈）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr /><h2 id="中心索引-mcentral">4. 中心索引 mcentral</h2><h3 id="概述-2">4.1 概述</h3><p>heapArena 中的 <code>mspan</code>不是一开始就全部划分好的，而是<strong>按需划分</strong>。</p><p>由于每个 heapArena 中的 mspan分布是动态的，为了给要分配空间的对象快速定位到合适的 mspan，Go定义了中心索引 <code>mcentral</code>。</p><ul><li>总共有 <strong>136</strong> 个 <code>mcentral</code> 结构体</li><li>其中 <strong>68</strong> 个用于需要 GC 扫描的对象（scan）</li><li>另外 <strong>68</strong> 个用于无需 GC 扫描的对象（noscan）</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5uf0kf27jj21iw0rg0xy.jpg"alt="mcentral 结构" /><figcaption aria-hidden="true">mcentral 结构</figcaption></figure><h3 id="底层结构-2">4.2 底层结构</h3><p><code>mcentral</code> 定义在 <ahref="https://github.com/golang/go/blob/go1.25.3/src/runtime/mcentral.go#L22">runtime/mcentral.go#L22</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    spanclass spanClass  <span class="comment">// size class 级别</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双缓冲设计：配合 GC 的 sweepgen</span></span><br><span class="line">    partial [<span class="number">2</span>]spanSet  <span class="comment">// 有空闲对象的 span 列表</span></span><br><span class="line">    full    [<span class="number">2</span>]spanSet  <span class="comment">// 无空闲对象的 span 列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双缓冲机制">4.3 双缓冲机制</h3><p><code>mcentral</code> 使用双缓冲配合 GC 的清扫机制：</p><ul><li><code>sweepgen</code> 每次 GC 增加 2</li><li><code>partial[sweepgen/2%2]</code> 是已清扫的 span</li><li><code>partial[1-sweepgen/2%2]</code> 是未清扫的 span</li></ul><p>这种设计使得 GC 和分配可以并发进行，无需等待所有 span都清扫完毕。</p><h2 id="线程缓存-mcache">5. 线程缓存 mcache</h2><h3 id="概述-3">5.1 概述</h3><p><code>mcentral</code>是一个中心索引，修改它需要使用互斥锁进行保护，锁竞争会造成性能问题。</p><p>Go 参考 <strong>GMP 模型</strong>，为每个P（逻辑处理器）建立了<strong>线程本地缓存</strong><code>mcache</code>，极大缓解了并发锁争夺的性能消耗。</p><p>设计要点：</p><ul><li>每个 <strong>P</strong> 有一个 <code>mcache</code></li><li>对于每一种 size class，取一个 scan 和一个 noscan span</li><li>一个 <code>mcache</code> 拥有 <strong>136</strong> 个<code>mspan</code>（68 个 scan + 68 个 noscan）</li><li>当本地缓存用完后，才需要上锁去 mcentral 交换</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5ufd5lnvxj21ez0u0n3h.jpg"alt="mcache 结构" /><figcaption aria-hidden="true">mcache 结构</figcaption></figure><h3 id="底层结构-3">5.2 底层结构</h3><p><code>mcache</code> 定义在 <ahref="https://github.com/golang/go/blob/go1.25.3/src/runtime/mcache.go#L20">runtime/mcache.go#L20</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分析相关</span></span><br><span class="line">    nextSample  <span class="type">int64</span>   <span class="comment">// 触发堆采样的字节数</span></span><br><span class="line">    memProfRate <span class="type">int</span>     <span class="comment">// 缓存的内存分析速率</span></span><br><span class="line">    scanAlloc   <span class="type">uintptr</span> <span class="comment">// 可扫描对象的已分配字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 微对象分配器（&lt;16B 的对象）</span></span><br><span class="line">    tiny       <span class="type">uintptr</span>  <span class="comment">// 当前 tiny block 的起始地址</span></span><br><span class="line">    tinyoffset <span class="type">uintptr</span>  <span class="comment">// tiny block 中的偏移</span></span><br><span class="line">    tinyAllocs <span class="type">uintptr</span>  <span class="comment">// tiny 分配次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心：136 个 mspan</span></span><br><span class="line">    alloc [numSpanClasses]*mspan  <span class="comment">// numSpanClasses = 136</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈缓存</span></span><br><span class="line">    stackcache [_NumStackOrders]stackfreelist</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC 相关</span></span><br><span class="line">    flushGen atomic.Uint32  <span class="comment">// 上次 flush 时的 sweepgen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与-p-的关系">5.3 与 P 的关系</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mcache *mcache</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 P 持有一个 mcache 指针，实现<strong>无锁快速路径</strong>。</p><h2 id="堆-mheap">6. 堆 mheap</h2><p><code>mheap</code> 是 Go 堆内存的全局管理者，统筹所有内存分配。</p><h3 id="底层结构-4">6.1 底层结构</h3><p><code>mheap</code> 定义在 <ahref="https://github.com/golang/go/blob/go1.25.3/src/runtime/mheap.go#L64">runtime/mheap.go#L64</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">    _ sys.NotInHeap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局锁（必须在系统栈上获取）</span></span><br><span class="line">    lock mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页分配器</span></span><br><span class="line">    pages pageAlloc</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GC 相关</span></span><br><span class="line">    sweepgen       <span class="type">uint32</span>           <span class="comment">// 清扫代数</span></span><br><span class="line">    pagesInUse     atomic.Uintptr   <span class="comment">// 使用中的页数</span></span><br><span class="line">    pagesSwept     atomic.Uint64    <span class="comment">// 已清扫的页数</span></span><br><span class="line">    sweepPagesPerByte <span class="type">float64</span>       <span class="comment">// 比例清扫速率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arena 管理（二级映射）</span></span><br><span class="line">    arenas [<span class="number">1</span> &lt;&lt; arenaL1Bits]*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena</span><br><span class="line">    heapArenas []arenaIdx  <span class="comment">// 所有已分配的 arena</span></span><br><span class="line">    curArena <span class="keyword">struct</span> &#123;      <span class="comment">// 当前正在增长的 arena</span></span><br><span class="line">        base, end <span class="type">uintptr</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中心索引（136 个）</span></span><br><span class="line">    central [numSpanClasses]<span class="keyword">struct</span> &#123;</span><br><span class="line">        mcentral mcentral</span><br><span class="line">        pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="type">byte</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mspan 是按需分级的，这里保存所有已划分的 mspan</span></span><br><span class="line">    allspans []*mspan</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 各种 fixalloc 分配器</span></span><br><span class="line">    spanalloc             fixalloc  <span class="comment">// 分配 mspan</span></span><br><span class="line">    cachealloc            fixalloc  <span class="comment">// 分配 mcache</span></span><br><span class="line">    specialfinalizeralloc fixalloc  <span class="comment">// 分配 finalizer</span></span><br><span class="line">    specialWeakHandleAlloc fixalloc <span class="comment">// 分配弱指针（Go 1.23+）</span></span><br><span class="line">    specialCleanupAlloc   fixalloc  <span class="comment">// 分配 cleanup（Go 1.24+）</span></span><br><span class="line">    specialPinCounterAlloc fixalloc <span class="comment">// 分配 pin counter（Go 1.21+）</span></span><br><span class="line">    <span class="comment">// ... 更多 special 分配器</span></span><br><span class="line"></span><br><span class="line">    speciallock mutex  <span class="comment">// 保护 special 分配器</span></span><br><span class="line">    arenaHintAlloc fixalloc</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【新特性】User Arena 状态（Go 1.20+）</span></span><br><span class="line">    userArena <span class="keyword">struct</span> &#123;</span><br><span class="line">        arenaHints     *arenaHint</span><br><span class="line">        quarantineList mSpanList  <span class="comment">// 等待释放的 span</span></span><br><span class="line">        readyList      mSpanList  <span class="comment">// 可复用的 span</span></span><br><span class="line">    &#125;</span><br><span class="line">    userArenaArenas []arenaIdx</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【新特性】Cleanup ID 计数器（Go 1.24+）</span></span><br><span class="line">    cleanupID <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【新特性】弱指针映射（Go 1.23+）</span></span><br><span class="line">    immortalWeakHandles immortalWeakHandleMap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键设计">6.2 关键设计</h3><h4 id="二级映射arenas">1. 二级映射（arenas）</h4><p>为了支持稀疏的虚拟地址空间，使用二级数组：</p><ul><li>L1 map：索引 arena 组</li><li>L2 map：索引具体的 heapArena</li></ul><p>在大多数 64位平台上，<code>arenaL1Bits = 0</code>，退化为单级映射。</p><h4 id="cache-line-对齐">2. Cache Line 对齐</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pad [(cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize) % cpu.CacheLinePadSize]<span class="type">byte</span></span><br></pre></td></tr></table></figure><p>填充字节避免伪共享（false sharing），提升多核性能。</p><h4 id="页回收器">3. 页回收器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reclaimIndex  atomic.Uint64  <span class="comment">// 下一个要回收的页索引</span></span><br><span class="line">reclaimCredit atomic.Uintptr <span class="comment">// 额外回收的页的信用</span></span><br></pre></td></tr></table></figure><p>后台异步回收未使用的页，减少内存占用。</p><h2 id="内存分配">7. 内存分配</h2><h3 id="对象分级">7.1 对象分级</h3><p>Go 根据对象大小将分配分为三类：</p><table><thead><tr><th>类型</th><th>大小范围</th><th>分配方式</th><th>Size Class</th></tr></thead><tbody><tr><td><strong>Tiny</strong></td><td>0 ~ 16B（无指针）</td><td>多个对象合并到 16B</td><td>class 2</td></tr><tr><td><strong>Tiny</strong></td><td>8B（单指针）</td><td>64 位上使用 class 1</td><td>class1</td></tr><tr><td><strong>Small</strong></td><td>16B ~ 32KB</td><td>从 mcache 分配</td><td>class 2 ~ 67</td></tr><tr><td><strong>Large</strong></td><td>&gt; 32KB</td><td>直接从 mheap 分配</td><td>class 0</td></tr></tbody></table><blockquote><p><strong>注意</strong>：Class 1 (8B) 在实践中使用极少，仅在 64位平台上分配恰好 8 字节且包含指针的对象时使用。绝大多数 8字节对象要么无指针（走 tiny allocator），要么是结构体的一部分。</p></blockquote><h4 id="tiny-对象分配">7.1.1 Tiny 对象分配</h4><p>对于 <strong>&lt; 16B</strong> 且<strong>无指针</strong>的对象，Go使用特殊的 <strong>tiny allocator</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mcache 中的 tiny allocator</span></span><br><span class="line">tiny       <span class="type">uintptr</span>  <span class="comment">// 当前 tiny block 起始地址</span></span><br><span class="line">tinyoffset <span class="type">uintptr</span>  <span class="comment">// 已使用的偏移量</span></span><br><span class="line">tinyAllocs <span class="type">uintptr</span>  <span class="comment">// tiny 分配计数</span></span><br></pre></td></tr></table></figure><ol type="1"><li>尝试在当前 tiny block 中分配（根据对齐要求）</li><li>如果空间不足，从 class 2 (16B) 的 span 中获取新的 tiny block</li><li>多个 tiny 对象共享同一个 16B 块，减少内存浪费</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h5ulg364i2j21nk09uq4s.jpg"alt="Tiny 对象分配" /><figcaption aria-hidden="true">Tiny 对象分配</figcaption></figure><blockquote><p><strong>Class 1 的特殊性</strong>：Class 1 (8B)在实践中使用极少，仅在 64 位平台上分配恰好 8字节且包含指针的对象时使用。典型例子如单个逃逸的指针变量。由于这种场景非常罕见，class1 基本处于"保留但不常用"的状态。大多数 8 字节对象要么：</p><ul><li>无指针 → 走 tiny allocator（class 2）</li><li>是结构体字段的一部分 → 随结构体一起分配</li><li>是栈上变量 → 不进行堆分配</li></ul></blockquote><h4 id="small-对象分配">7.1.2 Small 对象分配</h4><p>对于 <strong>16B ~ 32KB</strong> 的对象：</p><ol type="1"><li>根据对象大小查表确定 size class</li><li>在 mcache 中寻找对应 class 的 span</li><li>从 span 的 allocBits 中找到空闲 slot</li><li>如果 mcache 中 span 已满，去 mcentral 交换</li><li>如果 mcentral 也没有，去 mheap 申请</li></ol><h4 id="large-对象分配">7.1.3 Large 对象分配</h4><p>对于 <strong>&gt; 32KB</strong> 的大对象：量身定做 class0，直接从mheap 上申请内存。</p><h3 id="mcache-替换">7.2 mcache 替换</h3><p>在 mcache 中，每个 class 的 mspan 只有一个，当 mspan 满了之后，会从mcentral 中兑换一个新的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> refill(spc spanClass) &#123;</span><br><span class="line">    <span class="comment">// 1. 释放当前 span 回 mcentral</span></span><br><span class="line">    s := c.alloc[spc]</span><br><span class="line">    <span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">        <span class="keyword">if</span> s.sweepgen != mheap_.sweepgen+<span class="number">3</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;bad sweepgen in refill&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        mheap_.central[spc].mcentral.uncacheSpan(s)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从 mcentral 获取新的 span</span></span><br><span class="line">    s = mheap_.central[spc].mcentral.cacheSpan()</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 更新 mcache</span></span><br><span class="line">    c.alloc[spc] = s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mcentral-扩容">7.3 mcentral 扩容</h3><p>mcentral 中，只有有限数量的 mspan，当 mspan 缺少时，会像 mheap中开辟新的 heapArena，并申请对应 class 的 span。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> grow() *mspan &#123;</span><br><span class="line">    <span class="comment">// 1. 计算需要的页数</span></span><br><span class="line">    npages := <span class="type">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()])</span><br><span class="line">    size := <span class="type">uintptr</span>(class_to_size[c.spanclass.sizeclass()])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从 mheap 分配新的 span</span></span><br><span class="line">    s := mheap_.alloc(npages, c.spanclass)</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 初始化 span</span></span><br><span class="line">    n := (npages &lt;&lt; pageShift) / size</span><br><span class="line">    s.limit = s.base() + size*n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mallocgc-源码分析">7.4 mallocgc 源码分析</h3><p><ahref="https://github.com/golang/go/blob/release-branch.go1.25/src/runtime/malloc.go#L1014">mallocgc</a>是 Go 内存分配的核心函数，核心结构如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mallocgc</span><br><span class="line">├── mallocgcTiny // Tiny 对象 (0~16B, 无指针)</span><br><span class="line">├── mallocgcSmallNoscan // Small 对象 (16B~32KB, 无指针)</span><br><span class="line">├── mallocgcSmallScanNoHeader // Small 对象 (带指针, 无 header)</span><br><span class="line">├── mallocgcSmallScanHeader // Small 对象 (带指针, 有 header)</span><br><span class="line">└── mallocgcLarge // Large 对象 (&gt;32KB)</span><br></pre></td></tr></table></figure><p>源码注释如下（省略了与内存分配无关的次要代码）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 零大小分配的快速路径</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.Pointer(&amp;zerobase)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 核心分配逻辑 ==========</span></span><br><span class="line">    <span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">    <span class="keyword">var</span> elemsize <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> size &lt;= maxSmallSize-gc.MallocHeaderSize &#123;</span><br><span class="line">        <span class="comment">// 小对象分配</span></span><br><span class="line">        <span class="keyword">if</span> typ == <span class="literal">nil</span> || !typ.Pointers() &#123;</span><br><span class="line">            <span class="comment">// 无指针对象</span></span><br><span class="line">            <span class="keyword">if</span> size &lt; maxTinySize &#123;</span><br><span class="line">                x, elemsize = mallocgcTiny(size, typ)        <span class="comment">// Tiny 路径</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x, elemsize = mallocgcSmallNoscan(size, typ, needzero)  <span class="comment">// Small Noscan</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有指针对象（必须归零）</span></span><br><span class="line">            <span class="keyword">if</span> !needzero &#123;</span><br><span class="line">                throw(<span class="string">&quot;objects with pointers must be zeroed&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> heapBitsInSpan(size) &#123;</span><br><span class="line">                x, elemsize = mallocgcSmallScanNoHeader(size, typ)  <span class="comment">// 位图在 span 中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x, elemsize = mallocgcSmallScanHeader(size, typ)    <span class="comment">// 需要 malloc header</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 大对象分配</span></span><br><span class="line">        x, elemsize = mallocgcLarge(size, typ, needzero)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tiny-对象分配mallocgctiny">7.4.1 Tiny对象分配：mallocgcTiny</h4><blockquote><p>用于 &lt; 16B 且无指针的对象，多个对象合并到 16B块中。<code>mallocgcTiny</code> 进行了以下优化：</p></blockquote><ul><li><p>对齐优化：根据大小选择合适的对齐</p></li><li><p>空间复用：多个对象共享 16B 块</p></li><li><p>无锁快速路径：nextFreeFast 尝试无锁获取</p></li><li><p>平均浪费率：约 12.5%（远低于独立分配的 87.5%）</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcTiny</span><span class="params">(size <span class="type">uintptr</span>, typ *_type)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    <span class="comment">// ========== 1. 获取 M 和 mcache ==========</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line">    off := c.tinyoffset</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 2. 对齐计算 ==========</span></span><br><span class="line">    <span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">        off = alignUp(off, <span class="number">8</span>)   <span class="comment">// 8 字节对齐</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> goarch.PtrSize == <span class="number">4</span> &amp;&amp; size == <span class="number">12</span> &#123;</span><br><span class="line">        off = alignUp(off, <span class="number">8</span>)   <span class="comment">// 32 位特殊情况</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        off = alignUp(off, <span class="number">4</span>)   <span class="comment">// 4 字节对齐</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">        off = alignUp(off, <span class="number">2</span>)   <span class="comment">// 2 字节对齐</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 3. 尝试在现有 tiny block 中分配 ==========</span></span><br><span class="line">    <span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">        x := unsafe.Pointer(c.tiny + off)</span><br><span class="line">        c.tinyoffset = off + size</span><br><span class="line">        c.tinyAllocs++</span><br><span class="line">        mp.mallocing = <span class="number">0</span></span><br><span class="line">        releasem(mp)</span><br><span class="line">        <span class="keyword">return</span> x, maxTinySize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 4. 需要新的 tiny block ==========</span></span><br><span class="line">    span := c.alloc[tinySpanClass]</span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        v, span, _ = c.nextFree(tinySpanClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x := unsafe.Pointer(v)</span><br><span class="line">    (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span>  <span class="comment">// 清零前 16 字节</span></span><br><span class="line">    (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 5. 更新 tiny allocator 状态 ==========</span></span><br><span class="line">    <span class="keyword">if</span> !raceenabled &amp;&amp; (size &lt; c.tinyoffset || c.tiny == <span class="number">0</span>) &#123;</span><br><span class="line">        c.tiny = <span class="type">uintptr</span>(x)</span><br><span class="line">        c.tinyoffset = size</span><br><span class="line">    &#125;</span><br><span class="line">    size = maxTinySize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 发布屏障和返回</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小对象无扫描分配mallocgcsmallnoscan">7.4.2小对象无扫描分配：mallocgcSmallNoscan</h4><blockquote><p>用于 16B~32KB 且无指针的对象。</p></blockquote><p>关键点：</p><ul><li><p>查表优化：两个查找表覆盖不同大小范围</p></li><li><p>延迟归零：只在需要时归零</p></li><li><p>GC 协作：黑色分配或设置 freeIndexForScan</p></li><li><p>发布屏障：确保内存可见性</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcSmallNoscan</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 1. 确定 size class ==========</span></span><br><span class="line">    <span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= gc.SmallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">        sizeclass = gc.SizeToSizeClass8[divRoundUp(size, gc.SmallSizeDiv)]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sizeclass = gc.SizeToSizeClass128[divRoundUp(size-gc.SmallSizeMax, gc.LargeSizeDiv)]</span><br><span class="line">    &#125;</span><br><span class="line">    size = <span class="type">uintptr</span>(gc.SizeClassToSize[sizeclass])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 2. 从 mcache 分配 ==========</span></span><br><span class="line">    spc := makeSpanClass(sizeclass, <span class="literal">true</span>)  <span class="comment">// true = noscan</span></span><br><span class="line">    span := c.alloc[spc]</span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        v, span, checkGCTrigger = c.nextFree(spc)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 3. 按需归零 ==========</span></span><br><span class="line">    x := unsafe.Pointer(v)</span><br><span class="line">    <span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        memclrNoHeapPointers(x, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 4. 发布屏障 ==========</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 5. GC 期间分配黑色 ==========</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        span.freeIndexForScan = span.freeindex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 返回</span></span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小对象有扫描分配无-headermallocgcsmallscannoheader">7.4.3小对象有扫描分配（无 Header）：mallocgcSmallScanNoHeader</h4><blockquote><p>用于带指针的小对象，且堆位图在 span 中。</p></blockquote><p>关键点：</p><ul><li><p>堆位图设置：heapSetTypeNoHeader 根据类型设置指针位图</p></li><li><p>扫描统计：累加 scanAlloc 用于 GC 调度</p></li><li><p>8 字节优化：64 位平台的特殊处理</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcSmallScanNoHeader</span><span class="params">(size <span class="type">uintptr</span>, typ *_type)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 1. 确定 size class ==========</span></span><br><span class="line">    sizeclass := gc.SizeToSizeClass8[divRoundUp(size, gc.SmallSizeDiv)]</span><br><span class="line">    spc := makeSpanClass(sizeclass, <span class="literal">false</span>)  <span class="comment">// false = scan</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 2. 分配和归零 ==========</span></span><br><span class="line">    span := c.alloc[spc]</span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        v, span, checkGCTrigger = c.nextFree(spc)</span><br><span class="line">    &#125;</span><br><span class="line">    x := unsafe.Pointer(v)</span><br><span class="line">    <span class="keyword">if</span> span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        memclrNoHeapPointers(x, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 3. 设置堆位图（类型信息）==========</span></span><br><span class="line">    <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &amp;&amp; sizeclass == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 8 字节 class 在 64 位平台已预设指针位</span></span><br><span class="line">        c.scanAlloc += <span class="number">8</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c.scanAlloc += heapSetTypeNoHeader(<span class="type">uintptr</span>(x), size, typ, span)</span><br><span class="line">    &#125;</span><br><span class="line">    size = <span class="type">uintptr</span>(gc.SizeClassToSize[sizeclass])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 4. 发布屏障 + GC 协作 ==========</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        span.freeIndexForScan = span.freeindex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 返回</span></span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小对象有扫描分配有-headermallocgcsmallscanheader">7.4.4小对象有扫描分配（有 Header）：mallocgcSmallScanHeader</h4><blockquote><p>用于带指针的小对象，需要 malloc header 存储类型信息。</p></blockquote><p>Malloc Header 设计：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">| *_type (header)  丨  &lt;- 指向类型元数据的指针</span><br><span class="line">+------------------+</span><br><span class="line">| 实际对象数据       |  &lt;- x 指向这里</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><p>为什么需要 Header：</p><ul><li><p>当对象较大且堆位图不在 span 中时，需要额外存储类型信息</p></li><li><p>Header 存储类型指针，GC 可以快速找到对象的类型信息</p></li><li><p>权衡：增加少量空间换取更快的 GC 扫描</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcSmallScanHeader</span><span class="params">(size <span class="type">uintptr</span>, typ *_type)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 1. 增加 header 空间 ==========</span></span><br><span class="line">    size += gc.MallocHeaderSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 2. 确定 size class ==========</span></span><br><span class="line">    <span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= gc.SmallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">        sizeclass = gc.SizeToSizeClass8[divRoundUp(size, gc.SmallSizeDiv)]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sizeclass = gc.SizeToSizeClass128[divRoundUp(size-gc.SmallSizeMax, gc.LargeSizeDiv)]</span><br><span class="line">    &#125;</span><br><span class="line">    size = <span class="type">uintptr</span>(gc.SizeClassToSize[sizeclass])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 3. 分配和归零 ==========</span></span><br><span class="line">    spc := makeSpanClass(sizeclass, <span class="literal">false</span>)</span><br><span class="line">    span := c.alloc[spc]</span><br><span class="line">    v := nextFreeFast(span)</span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        v, span, checkGCTrigger = c.nextFree(spc)</span><br><span class="line">    &#125;</span><br><span class="line">    x := unsafe.Pointer(v)</span><br><span class="line">    <span class="keyword">if</span> span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        memclrNoHeapPointers(x, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 4. 设置 malloc header ==========</span></span><br><span class="line">    header := (**_type)(x)</span><br><span class="line">    x = add(x, gc.MallocHeaderSize)  <span class="comment">// 跳过 header</span></span><br><span class="line">    c.scanAlloc += heapSetTypeSmallHeader(<span class="type">uintptr</span>(x), size-gc.MallocHeaderSize, typ, header, span)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 5. 发布屏障 + GC 协作 ==========</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x)-gc.MallocHeaderSize)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        span.freeIndexForScan = span.freeindex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 返回</span></span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="大对象分配mallocgclarge">7.4.5 大对象分配：mallocgcLarge</h4><blockquote><p>用于 &gt; 32KB 的对象。</p></blockquote><p>大对象优化：</p><ul><li><p>直接分配：绕过 mcache/mcentral，直接从 mheap</p></li><li><p>largeType 字段：避免为大对象创建复杂的位图</p></li><li><p>分块归零：允许抢占，减少延迟</p></li><li><p>量身定做：每个大对象有专属的 span</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgcLarge</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> (unsafe.Pointer, <span class="type">uintptr</span>) &#123;</span><br><span class="line">    mp := acquirem()</span><br><span class="line">    mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 1. 直接从 mheap 分配 ==========</span></span><br><span class="line">    span := c.allocLarge(size, typ == <span class="literal">nil</span> || !typ.Pointers())</span><br><span class="line">    span.freeindex = <span class="number">1</span></span><br><span class="line">    span.allocCount = <span class="number">1</span></span><br><span class="line">    span.largeType = <span class="literal">nil</span>  <span class="comment">// 暂时设为 nil，防止 GC 过早扫描</span></span><br><span class="line"></span><br><span class="line">    size = span.elemsize</span><br><span class="line">    x := unsafe.Pointer(span.base())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 2. 发布屏障 ==========</span></span><br><span class="line">    publicationBarrier()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 3. GC 协作 ==========</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line">        gcmarknewobject(span, <span class="type">uintptr</span>(x))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        span.freeIndexForScan = span.freeindex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 4. 设置类型信息 ==========</span></span><br><span class="line">    <span class="keyword">if</span> typ != <span class="literal">nil</span> &amp;&amp; typ.Pointers() &#123;</span><br><span class="line">        <span class="keyword">if</span> !heapBitsInSpan(span.elemsize) &#123;</span><br><span class="line">            <span class="comment">// 大对象使用 largeType 字段</span></span><br><span class="line">            span.largeType = typ</span><br><span class="line">            <span class="comment">// 发布屏障确保 largeType 可见</span></span><br><span class="line">            publicationBarrier()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c.scanAlloc += heapSetTypeLarge(<span class="type">uintptr</span>(x), span.elemsize, typ, span)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== 5. 按需归零（可抢占） ==========</span></span><br><span class="line">    <span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> goexperiment.AllocHeaders &#123;</span><br><span class="line">            memclrNoHeapPointersChunked(size, x)  <span class="comment">// 分块归零</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memclrNoHeapPointers(x, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 返回</span></span><br><span class="line">    <span class="keyword">return</span> x, size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="go-1.20-新增特性">8. Go 1.20+ 新增特性</h2><p>Go 在 1.16 之后的版本中引入了多项重要的内存管理特性，极大地增强了 Go的能力和灵活性。</p><h3 id="user-arenago-1.20">8.1 User Arena（Go 1.20+）</h3><h4 id="概述-4">概述</h4><p>User Arena允许应用程序<strong>手动管理</strong>一组对象的生命周期，所有对象在同一个arena 中分配，可以一次性释放整个 arena。</p><h4 id="使用场景">使用场景</h4><ul><li><strong>临时数据处理</strong>：请求处理完后批量释放</li><li><strong>请求级别内存池</strong>：每个请求一个 arena</li><li><strong>减少 GC 压力</strong>：大量临时对象不进入 GC 扫描</li></ul><h4 id="数据结构">数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// mheap 中的 user arena 状态</span></span><br><span class="line">userArena <span class="keyword">struct</span> &#123;</span><br><span class="line">    arenaHints     *arenaHint   <span class="comment">// 分配提示</span></span><br><span class="line">    quarantineList mSpanList    <span class="comment">// 隔离列表（等待无指针引用）</span></span><br><span class="line">    readyList      mSpanList    <span class="comment">// 就绪列表（可复用）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// mspan 中的标记</span></span><br><span class="line">  isUserArenaChunk   <span class="type">bool</span>      <span class="comment">// 是否为 user arena chunk</span></span><br><span class="line">  userArenaChunkFree addrRange <span class="comment">// chunk 分配管理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用示例">使用示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;arena&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processRequest</span><span class="params">(data []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 arena</span></span><br><span class="line">    a := arena.NewArena()</span><br><span class="line">    <span class="keyword">defer</span> a.Free()  <span class="comment">// 批量释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 arena 中分配对象</span></span><br><span class="line">    obj := arena.New[MyStruct](a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用对象...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weak-pointergo-1.23">8.2 Weak Pointer（Go 1.23+）</h3><h4 id="概述-5">概述</h4><p>弱引用机制允许持有对象的引用，但<strong>不阻止 GC回收</strong>该对象。</p><h4 id="使用场景-1">使用场景</h4><ul><li><strong>缓存</strong>：缓存条目可以被 GC 回收</li><li><strong>Observer 模式</strong>：观察者不阻止被观察对象回收</li><li><strong>循环引用打破</strong>：避免内存泄漏</li></ul><h4 id="数据结构-1">数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mheap 中的弱指针映射</span></span><br><span class="line">immortalWeakHandles immortalWeakHandleMap  <span class="comment">// 不朽对象的弱指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Special 记录</span></span><br><span class="line">specialWeakHandle <span class="keyword">struct</span> &#123;</span><br><span class="line">    special special</span><br><span class="line">    handle *atomic.Uintptr  <span class="comment">// 弱指针句柄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用示例-1">使用示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;weak&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    items <span class="keyword">map</span>[<span class="type">string</span>]weak.Pointer[*Item]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span></span> Get(key <span class="type">string</span>) *Item &#123;</span><br><span class="line">    wp := c.items[key]</span><br><span class="line">    <span class="keyword">return</span> wp.Value()  <span class="comment">// 可能返回 nil（已被 GC）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span></span> Set(key <span class="type">string</span>, item *Item) &#123;</span><br><span class="line">    c.items[key] = weak.Make(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现细节">实现细节</h4><ul><li>弱指针本身不占用 GC 扫描时间</li><li>对象被回收后，弱指针自动变为 nil</li><li>弱指针转强指针需要确保 span 已清扫</li></ul><h3 id="cleanup-机制go-1.24">8.3 Cleanup 机制（Go 1.24+）</h3><h4 id="概述-6">概述</h4><p>类似 finalizer但更安全的资源清理机制，<strong>不会使对象复活</strong>。</p><h4 id="cleanup-vs-finalizer">Cleanup vs Finalizer</h4><table><thead><tr><th>特性</th><th>Finalizer</th><th>Cleanup</th></tr></thead><tbody><tr><td>对象复活</td><td>会</td><td>不会</td></tr><tr><td>执行时机</td><td>第一次变成不可达</td><td>对象真正释放前</td></tr><tr><td>多个回调</td><td>不支持</td><td>支持</td></tr><tr><td>GC 延迟</td><td>较大</td><td>较小</td></tr></tbody></table><h4 id="数据结构-2">数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mheap 中的 cleanup ID</span></span><br><span class="line">cleanupID <span class="type">uint64</span>  <span class="comment">// 全局唯一 ID 计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Special 记录</span></span><br><span class="line">specialCleanup <span class="keyword">struct</span> &#123;</span><br><span class="line">    special special</span><br><span class="line">    fn *funcval  <span class="comment">// 清理函数</span></span><br><span class="line">    id <span class="type">uint64</span>    <span class="comment">// 全局唯一 ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用示例-2">使用示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Resource <span class="keyword">struct</span> &#123;</span><br><span class="line">    handle <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewResource</span><span class="params">()</span></span> *Resource &#123;</span><br><span class="line">    r := &amp;Resource&#123;handle: openResource()&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 cleanup（不会使 r 复活）</span></span><br><span class="line">    runtime.AddCleanup(r, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        closeResource(r.handle)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pinner-机制go-1.21">8.4 Pinner 机制（Go 1.21+）</h3><h4 id="概述-7">概述</h4><p>固定对象在内存中的位置，防止 GC 移动（为未来的移动式 GC做准备）。</p><h4 id="使用场景-2">使用场景</h4><ul><li><strong>CGO 交互</strong>：C 代码持有 Go 对象指针</li><li><strong>DMA 操作</strong>：硬件直接访问内存</li><li><strong>性能优化</strong>：避免某些热点对象移动</li></ul><h4 id="数据结构-3">数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mspan 中的 pin 位图</span></span><br><span class="line">pinnerBits *gcBits  <span class="comment">// 标记哪些对象被固定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Special 记录（支持多次 pin）</span></span><br><span class="line">specialPinCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">    special special</span><br><span class="line">    counter <span class="type">uintptr</span>  <span class="comment">// pin 计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用示例-3">使用示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passToC</span><span class="params">(data []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pinner runtime.Pinner</span><br><span class="line">    pinner.Pin(&amp;data[<span class="number">0</span>])  <span class="comment">// 固定切片底层数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 C 函数</span></span><br><span class="line">    C.processData(unsafe.Pointer(&amp;data[<span class="number">0</span>]), C.<span class="type">int</span>(<span class="built_in">len</span>(data)))</span><br><span class="line"></span><br><span class="line">    pinner.Unpin()  <span class="comment">// 解除固定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="greenteagc实验性go-1.24">8.5 GreenTeaGC（实验性，Go 1.24+）</h3><h4 id="概述-8">概述</h4><p>实验性的新 GC 算法，旨在进一步降低延迟。</p><h4 id="关键改进">关键改进</h4><ul><li><strong>Span Inline Mark Bits</strong>：将 mark bits 内联到 span中</li><li><strong>增量标记</strong>：更细粒度的标记控制</li><li><strong>减少停顿</strong>：优化 STW 阶段</li></ul><h4 id="数据结构-4">数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mspan 中的 GreenTeaGC 字段</span></span><br><span class="line">scanIdx <span class="type">uint16</span>  <span class="comment">// 扫描索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// heapArena 中的位图</span></span><br><span class="line">pageUseSpanInlineMarkBits [pagesPerArena / <span class="number">8</span>]<span class="type">uint8</span></span><br></pre></td></tr></table></figure><h4 id="启用方式">启用方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOEXPERIMENT=greentea go build myapp.go</span><br></pre></td></tr></table></figure><h2 id="性能优化技巧">9. 性能优化技巧</h2><h3 id="减少内存分配">9.1 减少内存分配</h3><h4 id="复用对象sync.pool">1. 复用对象（sync.Pool）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bufferPool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">()</span></span> &#123;</span><br><span class="line">    buf := bufferPool.Get().(*bytes.Buffer)</span><br><span class="line">    <span class="keyword">defer</span> bufferPool.Put(buf)</span><br><span class="line">    buf.Reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 buf...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="预分配切片">2. 预分配切片</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line"><span class="keyword">var</span> items []Item</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    items = <span class="built_in">append</span>(items, Item&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line">items := <span class="built_in">make</span>([]Item, <span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    items = <span class="built_in">append</span>(items, Item&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串拼接优化">3. 字符串拼接优化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好</span></span><br><span class="line">s := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    s += <span class="string">&quot;a&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好</span></span><br><span class="line"><span class="keyword">var</span> b strings.Builder</span><br><span class="line">b.Grow(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    b.WriteString(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">s := b.String()</span><br></pre></td></tr></table></figure><h3 id="避免逃逸">9.2 避免逃逸</h3><h4 id="返回值而非指针">1. 返回值而非指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPoint</span><span class="params">()</span></span> *Point &#123;</span><br><span class="line">    p := Point&#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;p  <span class="comment">// 逃逸</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPoint</span><span class="params">()</span></span> Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point&#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用确定大小的数组">2. 使用确定大小的数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>([]<span class="type">byte</span>, n)  <span class="comment">// 如果 n 不是常量，可能逃逸</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data [<span class="number">1024</span>]<span class="type">byte</span>  <span class="comment">// 数组在栈上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检测工具">9.3 检测工具</h3><h4 id="逃逸分析-1">逃逸分析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags=<span class="string">&quot;-m&quot;</span> main.go</span><br></pre></td></tr></table></figure><h4 id="内存分析">内存分析</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.ListenAndServe(<span class="string">&quot;localhost:6060&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问 http://localhost:6060/debug/pprof/heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trace-分析">Trace 分析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -trace=trace.out</span><br><span class="line">go tool trace trace.out</span><br></pre></td></tr></table></figure><hr /><h2 id="总结">10. 总结</h2><h3 id="内存模型演进">10.1 内存模型演进</h3><p>从 Go 1.16 到 Go 1.25.3，内存模型的主要演进方向：</p><ol type="1"><li><p><strong>更灵活的内存管理</strong></p><ul><li>User Arena：用户可控的批量分配/释放</li><li>适应更多场景需求</li></ul></li><li><p><strong>更丰富的引用语义</strong></p><ul><li>Weak Pointer：支持弱引用</li><li>打破循环引用，优化缓存</li></ul></li><li><p><strong>更安全的资源管理</strong></p><ul><li>Cleanup 机制：不会使对象复活</li><li>减少 finalizer 带来的问题</li></ul></li><li><p><strong>更好的 CGO 支持</strong></p><ul><li>Pinner 机制：固定对象位置</li><li>安全地与 C 代码交互</li></ul></li><li><p><strong>持续的 GC 优化</strong></p><ul><li>GreenTeaGC：实验性的低延迟 GC</li><li>Inline mark bits：减少内存开销</li></ul></li></ol><h3 id="核心设计原则">10.2 核心设计原则</h3><p>Go 内存分配器的核心设计原则始终如一：</p><ol type="1"><li><strong>多层级缓存</strong>：<ul><li><strong>本地缓存</strong>：mcache（Per-P，无锁）</li><li><strong>中央索引</strong>：mcentral（按 size class，需要锁）</li><li><strong>全局堆</strong>：mheap（全局，需要全局锁）</li><li><strong>虚拟内存</strong>：heapArena（64MB 单元）</li></ul></li><li><strong>减少锁竞争</strong>：Per-P 缓存 + 细粒度锁</li><li><strong>分级管理</strong>：68 个 size class 减少碎片</li><li><strong>延迟归零</strong>：按需清零提高性能</li><li><strong>与 GC 协作</strong>：双缓冲、sweepgen 等机制</li></ol><h3 id="最佳实践">10.3 最佳实践</h3><ol type="1"><li><strong>理解内存分配路径</strong>：优先使用 mcache的无锁快速路径</li><li><strong>减少逃逸</strong>：让对象尽量在栈上分配</li><li><strong>复用对象</strong>：使用 sync.Pool 减少分配</li><li><strong>预分配容量</strong>：避免 slice/map 反复扩容</li><li><strong>选择合适的特性</strong>：根据场景使用 User Arena、WeakPointer 等</li></ol><h3 id="参考资料">10.4 参考资料</h3><ul><li><a href="https://go.dev/doc/">Go 官方文档</a></li><li><a href="https://github.com/golang/go/tree/master/src/runtime">Go运行时源码</a></li><li><ahref="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc论文</a></li><li><ahref="https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md">GoGC 设计文档</a></li></ul><h2 id="附录常用命令">附录：常用命令</h2><h3 id="内存相关环境变量">内存相关环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOGC=100          <span class="comment"># GC 触发时的堆增长百分比</span></span><br><span class="line">GOMEMLIMIT=4GiB   <span class="comment"># 内存限制（Go 1.19+）</span></span><br><span class="line">GODEBUG=gctrace=1 <span class="comment"># 打印 GC 跟踪信息</span></span><br></pre></td></tr></table></figure><h3 id="性能分析">性能分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CPU profile</span></span><br><span class="line">go <span class="built_in">test</span> -cpuprofile=cpu.prof</span><br><span class="line">go tool pprof cpu.prof</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory profile</span></span><br><span class="line">go <span class="built_in">test</span> -memprofile=mem.prof</span><br><span class="line">go tool pprof mem.prof</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace</span></span><br><span class="line">go <span class="built_in">test</span> -trace=trace.out</span><br><span class="line">go tool trace trace.out</span><br></pre></td></tr></table></figure><h3 id="逃逸分析-2">逃逸分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译时查看逃逸分析</span></span><br><span class="line">go build -gcflags=<span class="string">&quot;-m -m&quot;</span> main.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看汇编代码</span></span><br><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文基于 Go 1.25.3 源码，从第一性原理出发，深入探讨 Go 的内存模型，包括内存分配机制、实现原理、使用场景以及最新特性。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="内存管理" scheme="https://hedon.top/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="malloc" scheme="https://hedon.top/tags/malloc/"/>
    
  </entry>
  
  <entry>
    <title>Go 底层原理丨interface</title>
    <link href="https://hedon.top/2025/11/17/go/go-interface/"/>
    <id>https://hedon.top/2025/11/17/go/go-interface/</id>
    <published>2025-11-17T05:00:00.000Z</published>
    <updated>2025-12-05T05:35:02.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从第一性原理理解-go-的类型系统设计">1. 从第一性原理理解 Go的类型系统设计</h2><p>想要从根本上理解 Go 的<code>interface</code>，我们不仅要知道它是怎么实现的，更要知道为什么需要它，它的出现是为了解决什么问题。</p><blockquote><p>特此声明，本篇是笔者与 Google Gemini 3Pro 共创所作，非常庆幸在当今 AI时代下获取知识已是如此便利，且也为学习者从第一性原理理解所学知识大大降低了门槛。不过本篇的篇章安排和叙述逻辑，均由笔者把控和审阅，欢迎放心阅读。</p></blockquote><p>在静态类型语言中，我们面临一个根本性的矛盾：<strong><u>静态类型语言如何实现动态多态？</u></strong></p><ul><li><p>编译期：需要类型检查，确保类型安全</p></li><li><p>运行期：需要动态分发，实现多态</p></li></ul><p>Go 通过接口 <code>interface</code> 优雅地解决了这个问题。</p><p>Go 在运行时将接口分为两种表示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>eface（Empty Interface）：表示空接口 interface{} 或 any</p></li><li><p>iface（Non-empty Interface）：表示包含方法的接口</p></li></ul><h2 id="深入理解-iface-结构">2. 深入理解 iface 结构</h2><h3 id="iface-内存布局">2.1 iface 内存布局</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab          <span class="comment">// 接口表指针（8字节）</span></span><br><span class="line">    data unsafe.Pointer <span class="comment">// 实际数据指针（8字节）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个 16 字节（64 位系统）的结构，包含两个指针：</p><ul><li>tab：指向接口表（interface table），存储类型信息和方法集</li><li>data：指向实际的数据</li></ul><h3 id="itab-的核心结构">2.2 itab 的核心结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab = abi.ITab</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ITab <span class="keyword">struct</span> &#123;</span><br><span class="line">Inter *InterfaceType</span><br><span class="line">Type  *Type</span><br><span class="line">Hash  <span class="type">uint32</span>     <span class="comment">// copy of Type.Hash. Used for type switches.</span></span><br><span class="line">Fun   [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means Type does not implement Inter.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>itab</code> 是整个接口系统的核心，它包含：</p><ul><li><code>Inter</code>：指向接口类型的元数据（接口定义了哪些方法）</li><li><code>Type</code>：指向具体类型的元数据（实际存储的是什么类型）</li><li><code>Hash</code>：类型的哈希值，用于 type switch 快速匹配</li><li><code>Fun</code>：方法表，这是一个可变长度数组，存储该具体类型实现接口方法的函数指针</li></ul><h3 id="为什么需要-itab">2.3 为什么需要 itab</h3><p>为什么不直接在 <code>iface</code>中存储类型信息和方法？是为了<strong>性能优化 + 内存共享</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 Reader = &amp;File&#123;...&#125;</span><br><span class="line"><span class="keyword">var</span> r2 Reader = &amp;File&#123;...&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>r1</code> 和 <code>r2</code> 都是 <code>*File</code>类型实现 <code>Reader</code> 接口：</p><ul><li><p>它们的 <code>data</code> 指针不同（指向不同的 <code>File</code>实例）</p></li><li><p>但它们的 <code>tab</code> 指针相同（指向同一个<code>itab</code>）</p></li></ul><p><code>itab</code> 是全局唯一的，对于相同的 (接口类型, 具体类型)对，运行时只会创建一个<code>itab</code>，并被所有相同类型组合的接口值共享。</p><h2 id="接口赋值的运行时过程">3. 接口赋值的运行时过程</h2><h3 id="从具体类型到接口类型">3.1 从具体类型到接口类型</h3><p>下面这个过程，在运行时发生了什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strconv.Itoa(<span class="type">int</span>(m))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i fmt.Stringer = MyInt(<span class="number">42</span>)</span><br></pre></td></tr></table></figure><p><strong>1. 查找并创建 itab</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getitab</span><span class="params">(inter *interfacetype, typ *_type, canfail <span class="type">bool</span>)</span></span> *itab &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(inter.Methods) == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;internal error - misuse of itab&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// easy case</span></span><br><span class="line"><span class="keyword">if</span> typ.TFlag&amp;abi.TFlagUncommon == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> canfail &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">name := toRType(&amp;inter.Type).nameOff(inter.Methods[<span class="number">0</span>].Name)</span><br><span class="line"><span class="built_in">panic</span>(&amp;TypeAssertionError&#123;<span class="literal">nil</span>, typ, &amp;inter.Type, name.Name()&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m *itab</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, look in the existing table to see if we can find the itab we need.</span></span><br><span class="line"><span class="comment">// This is by far the most common case, so do it without locks.</span></span><br><span class="line"><span class="comment">// Use atomic to ensure we see any previous writes done by the thread</span></span><br><span class="line"><span class="comment">// that updates the itabTable field (with atomic.Storep in itabAdd).</span></span><br><span class="line">t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(&amp;itabTable)))</span><br><span class="line"><span class="keyword">if</span> m = t.find(inter, typ); m != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> finish</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not found.  Grab the lock and try again.</span></span><br><span class="line">lock(&amp;itabLock)</span><br><span class="line"><span class="keyword">if</span> m = itabTable.find(inter, typ); m != <span class="literal">nil</span> &#123;</span><br><span class="line">unlock(&amp;itabLock)</span><br><span class="line"><span class="keyword">goto</span> finish</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry doesn&#x27;t exist yet. Make a new entry &amp; add it.</span></span><br><span class="line">m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="type">uintptr</span>(<span class="built_in">len</span>(inter.Methods)<span class="number">-1</span>)*goarch.PtrSize, <span class="number">0</span>, &amp;memstats.other_sys))</span><br><span class="line">m.Inter = inter</span><br><span class="line">m.Type = typ</span><br><span class="line"><span class="comment">// The hash is used in type switches. However, compiler statically generates itab&#x27;s</span></span><br><span class="line"><span class="comment">// for all interface/type pairs used in switches (which are added to itabTable</span></span><br><span class="line"><span class="comment">// in itabsinit). The dynamically-generated itab&#x27;s never participate in type switches,</span></span><br><span class="line"><span class="comment">// and thus the hash is irrelevant.</span></span><br><span class="line"><span class="comment">// Note: m.Hash is _not_ the hash used for the runtime itabTable hash table.</span></span><br><span class="line">m.Hash = <span class="number">0</span></span><br><span class="line">itabInit(m, <span class="literal">true</span>)</span><br><span class="line">itabAdd(m)</span><br><span class="line">unlock(&amp;itabLock)</span><br><span class="line">finish:</span><br><span class="line"><span class="keyword">if</span> m.Fun[<span class="number">0</span>] != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> canfail &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this can only happen if the conversion</span></span><br><span class="line"><span class="comment">// was already done once using the , ok form</span></span><br><span class="line"><span class="comment">// and we have a cached negative result.</span></span><br><span class="line"><span class="comment">// The cached result doesn&#x27;t record which</span></span><br><span class="line"><span class="comment">// interface function was missing, so initialize</span></span><br><span class="line"><span class="comment">// the itab again to get the missing function name.</span></span><br><span class="line"><span class="built_in">panic</span>(&amp;TypeAssertionError&#123;concrete: typ, asserted: &amp;inter.Type, missingMethod: itabInit(m, <span class="literal">false</span>)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>运行时调用 getitab(interfaceType, concreteType)</p></li><li><p>先在全局 itabTable 中查找是否已存在</p></li><li><p>如果不存在，创建新的 itab 并初始化方法表</p></li></ul><p><strong>2. 初始化方法表 itabInit</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// itabInit fills in the m.Fun array with all the code pointers for</span></span><br><span class="line"><span class="comment">// the m.Inter/m.Type pair. If the type does not implement the interface,</span></span><br><span class="line"><span class="comment">// it sets m.Fun[0] to 0 and returns the name of an interface function that is missing.</span></span><br><span class="line"><span class="comment">// If !firstTime, itabInit will not write anything to m.Fun (see issue 65962).</span></span><br><span class="line"><span class="comment">// It is ok to call this multiple times on the same m, even concurrently</span></span><br><span class="line"><span class="comment">// (although it will only be called once with firstTime==true).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabInit</span><span class="params">(m *itab, firstTime <span class="type">bool</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">inter := m.Inter</span><br><span class="line">typ := m.Type</span><br><span class="line">x := typ.Uncommon()</span><br><span class="line"></span><br><span class="line"><span class="comment">// both inter and typ have method sorted by name,</span></span><br><span class="line"><span class="comment">// and interface names are unique,</span></span><br><span class="line"><span class="comment">// so can iterate over both in lock step;</span></span><br><span class="line"><span class="comment">// the loop is O(ni+nt) not O(ni*nt).</span></span><br><span class="line">ni := <span class="built_in">len</span>(inter.Methods)</span><br><span class="line">nt := <span class="type">int</span>(x.Mcount)</span><br><span class="line">xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]abi.Method)(add(unsafe.Pointer(x), <span class="type">uintptr</span>(x.Moff)))[:nt:nt]</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line">methods := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]unsafe.Pointer)(unsafe.Pointer(&amp;m.Fun[<span class="number">0</span>]))[:ni:ni]</span><br><span class="line"><span class="keyword">var</span> fun0 unsafe.Pointer</span><br><span class="line">imethods:</span><br><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123;</span><br><span class="line">i := &amp;inter.Methods[k]</span><br><span class="line">itype := toRType(&amp;inter.Type).typeOff(i.Typ)</span><br><span class="line">name := toRType(&amp;inter.Type).nameOff(i.Name)</span><br><span class="line">iname := name.Name()</span><br><span class="line">ipkg := pkgPath(name)</span><br><span class="line"><span class="keyword">if</span> ipkg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">ipkg = inter.PkgPath.Name()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ; j &lt; nt; j++ &#123;</span><br><span class="line">t := &amp;xmhdr[j]</span><br><span class="line">rtyp := toRType(typ)</span><br><span class="line">tname := rtyp.nameOff(t.Name)</span><br><span class="line"><span class="keyword">if</span> rtyp.typeOff(t.Mtyp) == itype &amp;&amp; tname.Name() == iname &#123;</span><br><span class="line">pkgPath := pkgPath(tname)</span><br><span class="line"><span class="keyword">if</span> pkgPath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">pkgPath = rtyp.nameOff(x.PkgPath).Name()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> tname.IsExported() || pkgPath == ipkg &#123;</span><br><span class="line">ifn := rtyp.textOff(t.Ifn)</span><br><span class="line"><span class="keyword">if</span> k == <span class="number">0</span> &#123;</span><br><span class="line">fun0 = ifn <span class="comment">// we&#x27;ll set m.Fun[0] at the end</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> firstTime &#123;</span><br><span class="line">methods[k] = ifn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span> imethods</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// didn&#x27;t find method</span></span><br><span class="line"><span class="comment">// Leaves m.Fun[0] set to 0.</span></span><br><span class="line"><span class="keyword">return</span> iname</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> firstTime &#123;</span><br><span class="line">m.Fun[<span class="number">0</span>] = <span class="type">uintptr</span>(fun0)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>遍历接口定义的方法</p></li><li><p>在具体类型的方法集中查找对应的实现</p></li><li><p>将函数指针填入 Fun 数组</p></li><li><p>如果找不到实现，设置 Fun[0] = 0 表示类型不匹配</p></li></ul><p><strong>3. 构造 iface</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iface &#123;</span><br><span class="line">    tab:  指向 (fmt.Stringer, MyInt) 的 itab,</span><br><span class="line">    data: 指向 MyInt(<span class="number">42</span>) 的内存地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口方法调用">3.2 接口方法调用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i.String()  <span class="comment">// 调用接口方法</span></span><br></pre></td></tr></table></figure><p>编译器生成的伪代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从 iface 中取出 tab</span></span><br><span class="line">tab := i.tab</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从 tab.Fun 中取出第一个方法（String 是第0个方法）</span></span><br><span class="line">fn := tab.Fun[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用该方法，传入 data 作为接收者</span></span><br><span class="line"><span class="keyword">return</span> fn(i.data)</span><br></pre></td></tr></table></figure><h2 id="eface-vs-iface-的设计哲学">4. eface vs iface 的设计哲学</h2><h3 id="为什么区分空接口和非空接口">4.1为什么区分空接口和非空接口？</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空接口 any 不需要方法表，因此直接存储类型指针，省去了 itab的开销：</p><table><thead><tr><th style="text-align: left;">接口类型</th><th style="text-align: left;">结构</th><th style="text-align: left;">用途</th></tr></thead><tbody><tr><td style="text-align: left;">eface</td><td style="text-align: left;">_type + data</td><td style="text-align: left;">不需要方法调用，只需要类型信息</td></tr><tr><td style="text-align: left;">iface</td><td style="text-align: left;">itab + data</td><td style="text-align: left;">需要动态方法分发</td></tr></tbody></table><p>这是一种针对性优化：</p><ul><li><p>空接口场景（如 fmt.Println(any)）非常常见</p></li><li><p>通过简化结构减少内存占用和间接访问</p></li></ul><h3 id="类型断言的实现">4.2 类型断言的实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := i.(MyInt); ok &#123;</span><br><span class="line">    <span class="comment">// 使用 v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 iface</span></span><br><span class="line"><span class="keyword">if</span> i.tab.Type == TypeOf(MyInt) &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*MyInt)(i.data), <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> zero, <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 eface</span></span><br><span class="line"><span class="keyword">if</span> i._type == TypeOf(MyInt) &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*MyInt)(i.data), <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> zero, <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="类型系统的完整图景">5. 类型系统的完整图景</h2><h3 id="类型元数据-_type">5.1 类型元数据 _type</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">struct</span> &#123;</span><br><span class="line">Size_       <span class="type">uintptr</span></span><br><span class="line">PtrBytes    <span class="type">uintptr</span> <span class="comment">// number of (prefix) bytes in the type that can contain pointers</span></span><br><span class="line">Hash        <span class="type">uint32</span>  <span class="comment">// hash of type; avoids computation in hash tables</span></span><br><span class="line">TFlag       TFlag   <span class="comment">// extra type information flags</span></span><br><span class="line">Align_      <span class="type">uint8</span>   <span class="comment">// alignment of variable with this type</span></span><br><span class="line">FieldAlign_ <span class="type">uint8</span>   <span class="comment">// alignment of struct field with this type</span></span><br><span class="line">Kind_       Kind    <span class="comment">// enumeration for C</span></span><br><span class="line"><span class="comment">// function for comparing objects of this type</span></span><br><span class="line"><span class="comment">// (ptr to object A, ptr to object B) -&gt; ==?</span></span><br><span class="line">Equal <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span></span> <span class="type">bool</span></span><br><span class="line"><span class="comment">// GCData stores the GC type data for the garbage collector.</span></span><br><span class="line"><span class="comment">// Normally, GCData points to a bitmask that describes the</span></span><br><span class="line"><span class="comment">// ptr/nonptr fields of the type. The bitmask will have at</span></span><br><span class="line"><span class="comment">// least PtrBytes/ptrSize bits.</span></span><br><span class="line"><span class="comment">// If the TFlagGCMaskOnDemand bit is set, GCData is instead a</span></span><br><span class="line"><span class="comment">// **byte and the pointer to the bitmask is one dereference away.</span></span><br><span class="line"><span class="comment">// The runtime will build the bitmask if needed.</span></span><br><span class="line"><span class="comment">// (See runtime/type.go:getGCMask.)</span></span><br><span class="line"><span class="comment">// Note: multiple types may have the same value of GCData,</span></span><br><span class="line"><span class="comment">// including when TFlagGCMaskOnDemand is set. The types will, of course,</span></span><br><span class="line"><span class="comment">// have the same pointer layout (but not necessarily the same size).</span></span><br><span class="line">GCData    *<span class="type">byte</span></span><br><span class="line">Str       NameOff <span class="comment">// string form</span></span><br><span class="line">PtrToThis TypeOff <span class="comment">// type for pointer to this type, may be zero</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 Go 类型在编译时都会生成一个 <code>_type</code> 结构，包含：</p><ul><li><p>类型大小、对齐</p></li><li><p>GC 信息（哪些字段是指针）</p></li><li><p>类型的唯一标识（Hash）</p></li><li><p>类型的 Kind（int, string, struct, ...）</p></li></ul><h3 id="接口类型-interfacetype">5.2 接口类型 InterfaceType</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InterfaceType <span class="keyword">struct</span> &#123;</span><br><span class="line">Type</span><br><span class="line">PkgPath Name      <span class="comment">// import path</span></span><br><span class="line">Methods []Imethod <span class="comment">// sorted by hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类型的元数据，包含：</p><ul><li><p>基础的 Type 信息</p></li><li><p>方法列表（按哈希排序，用于快速查找）</p></li></ul><h3 id="全局-itabtable">5.3 全局 itabTable</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> itabInitSize = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">itabLock      mutex                               <span class="comment">// lock for accessing itab table</span></span><br><span class="line">itabTable     = &amp;itabTableInit                    <span class="comment">// pointer to current table</span></span><br><span class="line">itabTableInit = itabTableType&#123;size: itabInitSize&#125; <span class="comment">// starter table</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itabTableType <span class="keyword">struct</span> &#123;</span><br><span class="line">size    <span class="type">uintptr</span>             <span class="comment">// length of entries array. Always a power of 2.</span></span><br><span class="line">count   <span class="type">uintptr</span>             <span class="comment">// current number of filled entries.</span></span><br><span class="line">entries [itabInitSize]*itab <span class="comment">// really [size] large</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个全局哈希表，键是 (接口类型, 具体类型) 对，值是 itab：</p><ul><li><p>避免重复创建相同的 itab</p></li><li><p>使用无锁读取（lock-free read）优化热路径</p></li><li><p>动态扩容（75% 负载因子）</p></li></ul><h2 id="设计权衡与优势">6. 设计权衡与优势</h2><h3 id="性能优势">6.1 性能优势</h3><ol type="1"><li>方法调用只需两次间接寻址：<code>iface.tab.Fun[i]</code></li><li><code>itab</code> 全局共享：内存效率高</li><li>无锁快速路径：大多数情况下不需要加锁</li></ol><h3 id="类型安全">6.2 类型安全</h3><ol type="1"><li>编译期检查：编译器确保接口实现完整</li><li>运行期验证：<code>itabInit</code> 时再次验证方法匹配</li><li>类型断言安全：通过比较 <code>_type</code> 指针实现</li></ol><h3 id="灵活性">6.3 灵活性</h3><ol type="1"><li>鸭子类型：不需要显式声明实现接口</li><li>动态组合：运行时可以将任何匹配的类型赋值给接口</li><li>反射基础：<code>reflect</code> 包通过 <code>_type</code> 和<code>itab</code> 实现</li></ol><h2 id="结构体和其指针实现接口的问题">7.结构体和其指针实现接口的问题</h2><p>如果是用结构体类型去实现接口，Go在编译的时候，会自动再为其对应的指针类型实现接口；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Truck)</span></span> Drive() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 底层会帮我们自动写这个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Truck)</span></span> Drive() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是用结构体指针类型去实现接口，Go在编译的时候，就不会为结构体类型去实现接口；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Truck)</span></span> Drive() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Go 底层不会帮我们写这个</span></span><br><span class="line"><span class="comment">func (t Truck) Drive() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="nil-空结构体-空指针">8. nil &amp; 空结构体 &amp; 空指针</h2><ul><li>nil 是六种类型的零值，不包括基本类型和 struct；</li><li>空接口可以承载任意类型，只有当 <code>_type</code> 和<code>data</code> 都为空的时候，它才是 nil；</li><li>空结构体的指针和值都不是 nil；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nil is a predeclared identifier representing the zero value for a</span></span><br><span class="line"><span class="comment">// pointer, channel, func, interface, map, or slice type.</span></span><br><span class="line"><span class="keyword">var</span> <span class="literal">nil</span> Type <span class="comment">// Type must be a pointer, channel, func, interface, map, or slice type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Type is here for the purposes of documentation only. It is a stand-in</span></span><br><span class="line"><span class="comment">// for any Go type, but represents the same type for any given function</span></span><br><span class="line"><span class="comment">// invocation.</span></span><br><span class="line"><span class="keyword">type</span> Type <span class="type">int</span></span><br></pre></td></tr></table></figure><h2 id="总结">9. 总结</h2><p>Go 的接口系统是一个精妙的工程设计：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20251205133500639.png" /></p><ol type="1"><li><strong>分离类型信息和数据</strong>：使得接口可以容纳任何类型</li><li><strong>分离接口定义和实现</strong>：通过 itab 连接两者</li><li><strong>缓存和共享</strong>：全局 itabTable 提升性能</li><li><strong>针对性优化</strong>：空接口和非空接口使用不同表示</li></ol><p>这种设计让 Go在保持静态类型安全的同时，实现了接近动态语言的灵活性，并且性能开销极小。这就是Go 类型系统的第一性原理！</p>]]></content>
    
    
    <summary type="html">本文系统解析 Go interface 的底层实现原理，剖析空接口（eface）与含方法接口（iface）的内存结构、类型方法表（itab）、动态类型匹配及多态分发机制，并探讨其设计哲学与应用场景。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
</feed>
