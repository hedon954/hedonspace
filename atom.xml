<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HedonSpace</title>
  
  
  <link href="https://hedon.top/atom.xml" rel="self"/>
  
  <link href="https://hedon.top/"/>
  <updated>2024-11-12T19:14:55.776Z</updated>
  <id>https://hedon.top/</id>
  
  <author>
    <name>Hedon Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</title>
    <link href="https://hedon.top/2024/11/11/rust-memory-order/"/>
    <id>https://hedon.top/2024/11/11/rust-memory-order/</id>
    <published>2024-11-11T05:06:49.000Z</published>
    <updated>2024-11-12T19:14:55.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="atomic">Atomic</h1><p>在 Rust 的 <code>std::sync::atomic</code>模块中包含了无锁并发编程的原子化类型，与通常的算术运算符和逻辑运算符不同，原子化类型会暴露执行原子化操作的方法，单独的加载、存储、交换和算术运算都会作为一个单元安全地进行，哪怕其他线程也在执行操作同一内存的原子化操作也没问题。</p><p>Rust 提供了以下几种原子化类型：</p><ul><li><code>AtomicIsize</code> 和 <code>AtomicUsize</code> 是与单线程<code>isize</code> 类型和 <code>usize</code>类型对应的共享整数类型。</li><li><code>AtomicI8</code>、<code>AtomicI16</code>、<code>AtomicI32</code>、<code>AtomicI64</code>及其无符号变体（如<code>AtomicU8</code>）是共享整数类型，对应于单线程中的类型<code>i8</code>、<code>i16</code> 等。</li><li><code>AtomicBool</code> 是一个共享的 <code>bool</code> 值。</li><li><code>AtomicPtr</code> 是不安全指针类型 <code>*mut T</code>的共享值。</li></ul><p>这些类型都会以下几类核心功能：</p><ul><li><code>Load</code> 、<code>Store</code>: 存取值</li><li><code>Fetch-and-Modify</code>: 获取并修改</li><li><code>Compare-and-Exchange</code>: 比较并交换</li></ul><p>下面我们对上述提到的几种核心功能进行举例。</p><h2 id="load-store">Load &amp; Store</h2><ul><li><strong>load</strong>:从原子化类型中获取起对应的基本数据类型的值。</li><li><strong>store</strong>:将一个基本数据类型的值存储到其对应的原子化类型中。</li></ul><p>在下面的例子中，我们使用 <code>AtomicUsize::new(0)</code>初始化了一个原子类型，它对应的基本数据类型是 <code>usize</code>。</p><p>我们起了一个子线程，在 for 循环中不断地使用 <code>store</code>函数修改 <code>num_done</code> 的值，然后在主线程中使用<code>load</code> 获取起对应的值，当发现值为 <code>100</code>时，就退出循环，进程结束。</p><p>得益于原子化类型的并发安全特性，所以这里两个线程对<code>num_done</code> 进行并发读写都是安全的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num_done</span> = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">main_thread</span> = thread::<span class="hljs-title function_ invoke__">current</span>();<br><br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> &#123;<br>                <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">10</span>));<br>                num_done.<span class="hljs-title function_ invoke__">store</span>(i + <span class="hljs-number">1</span>, std::sync::atomic::Ordering::Relaxed);  <span class="hljs-comment">// store 存储</span><br>                main_thread.<span class="hljs-title function_ invoke__">unpark</span>();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = num_done.<span class="hljs-title function_ invoke__">load</span>(std::sync::atomic::Ordering::Relaxed); <span class="hljs-comment">// load 获取</span><br>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">100</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Working... &#123;n&#125;/100 done&quot;</span>);<br>            thread::<span class="hljs-title function_ invoke__">park_timeout</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里我们暂且忽略 <code>std::sync::atomic::Ordering::Relaxed</code>这个参数的含义，在后续的「内存顺序」章节会进行详细阐述。</p></blockquote><h2 id="fetch-and-modify">Fetch-and-Modify</h2><p><strong>Fetch-and-Modify</strong>操作用于在获取当前值的同时对其进行修改。这类操作包括<code>fetch_add</code>、<code>fetch_sub</code>、<code>fetch_and</code>、<code>fetch_or</code>、<code>fetch_xor</code>等。</p><p>我们将上面的例子修改一下，不再是直接 <code>store</code>一个值，而是不断进行加 1 操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num_done</span> = &amp;AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> &#123;<br>                num_done.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, std::sync::atomic::Ordering::Relaxed); <span class="hljs-comment">// 使用 fetch_add 进行加 1</span><br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = num_done.<span class="hljs-title function_ invoke__">load</span>(std::sync::atomic::Ordering::Relaxed);<br>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">100</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Working... &#123;n&#125;/100 done&quot;</span>);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="compare-and-exchange">Compare-and-Exchange</h2><p><strong>Compare-and-Exchange</strong>是一种条件更新操作，只有在当前值等于预期值时才会更新。</p><p>下面的例子中我们实现了一个函数<code>allocate_new_id</code>，它支持在并发环境下分配新的<code>id</code>，这里我们使用了 <code>compare_exchange(id, id+1)</code>进行条件更新，只有当 <code>id</code>没有发生变化的时候，才运行对其进行加1，这就保证了在并发下，只有一个线程可以成功执行该语句，从而保证<code>id</code> 的递增性和唯一性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">allocate_new_id</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-keyword">static</span> NEXT_ID: AtomicU32 = AtomicU32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">id</span> = NEXT_ID.<span class="hljs-title function_ invoke__">load</span>(std::sync::atomic::Ordering::Relaxed);<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">assert!</span>(id &lt; <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;Too many IDs!&quot;</span>);<br>        <span class="hljs-keyword">match</span> NEXT_ID.<span class="hljs-title function_ invoke__">compare_exchange</span>(  <span class="hljs-comment">// 只有 id 没有发生变化，才允许进行加 1</span><br>            id,<br>            id + <span class="hljs-number">1</span>,<br>            std::sync::atomic::Ordering::Relaxed,<br>            std::sync::atomic::Ordering::Relaxed,<br>        ) &#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-keyword">return</span> id,<br>            <span class="hljs-title function_ invoke__">Err</span>(v) =&gt; id = v,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>在 Rust中，原子化类型还提供了另外一个函数：<code>compare_exchange_weak</code>，它与<code>compare_exchange</code>的主要区别在于它们在<strong>失败时</strong>的行为：</p><p><strong>compare_exchange</strong>:</p><ul><li>只会在实际值不等于期望值时失败。</li><li>提供更强的保证，但可能性能较低。</li><li>适用于不在循环中的单次比较交换操作。</li></ul><p><strong>compare_exchange_weak</strong>:</p><ul><li>即使实际值等于期望值时也可能失败（称为“虚假失败”或“spuriousfailure”）。</li><li>性能可能更好，因为允许在某些架构上生成更高效的代码。</li><li>最适合在循环中使用，因为需要处理可能的虚假失败。</li></ul><p>在实际应用中:</p><ul><li>如果操作在循环中,使用 <code>compare_exchange_weak</code>通常更好。</li><li>如果是单次操作,使用 <code>compare_exchange</code> 更合适。</li><li>在某些平台上，这两个操作可能没有性能差异,但<code>compare_exchange_weak</code> 的行为仍然可能不同。</li></ul><p>这种区别的存在是因为在某些 CPU架构上,允许虚假失败可以生成更高效的机器码。比如在 ARM架构上，<code>compare_exchange_weak</code> 可以直接映射到单个LL/SC（Load-Link/Store-Conditional）指令。</p>          </div><h2 id="硬件原理">硬件原理</h2><p>在一些处理器架构中，当一个 CPU执行需要原子性的操作时，它可以通过锁定内存总线来确保在操作完成之前，其他CPU 无法访问相关的内存地址。</p><p>基本工作流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">CPU 发出 LOCK 信号<br>   └── 激活处理器的 LOCK# 引脚<br>      └── 获得总线的独占访问权<br>          └── 执行原子操作<br>              └── 释放 LOCK 信号<br>                  └── 其他处理器可以访问内存<br></code></pre></td></tr></table></figure><p>主流的有 2 种锁定机制：</p><ul><li><p><strong>总线锁定（BusLocking）</strong>：总线锁定是一种机制，它通过锁定内存总线来确保在执行原子操作时，其他处理器无法访问内存。这种方法虽然简单，但会导致总线的其他操作被阻塞，从而影响系统性能。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">优点：<br><span class="hljs-bullet">-</span> 绝对的原子性保证<br><span class="hljs-bullet">-</span> 适用于所有内存位置<br><br>缺点：<br><span class="hljs-bullet">-</span> 性能开销大<br><span class="hljs-bullet">-</span> 会阻塞其他 CPU 对内存的访问<br></code></pre></td></tr></table></figure></li><li><p><strong>缓存锁定（CacheLocking）</strong>：现代处理器通常使用缓存锁定来实现原子操作。缓存锁定通过锁定处理器的缓存行来实现，而不是锁定整个总线。这种方法可以减少对总线的影响，提高系统的并发性能。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">优点：<br><span class="hljs-bullet">-</span> 性能更好<br><span class="hljs-bullet">-</span> 不会完全阻塞内存访问<br><br>条件：<br><span class="hljs-bullet">-</span> 数据必须在缓存行中<br><span class="hljs-bullet">-</span> 缓存行必须是独占状态<br></code></pre></td></tr></table></figure></li></ul><p>缓存锁定通常依赖于缓存一致性协议（如 <strong>MESI</strong>协议）来确保在多个处理器之间的数据一致性。通过这些协议，处理器可以在本地缓存中执行原子操作，并在必要时与其他处理器同步。</p><p><strong>MESI</strong> 协议即：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">M (Modified)：已修改<br>E (Exclusive)：独占<br>S (Shared)：共享<br>I (Invalid)：无效<br><br>操作流程：<br><span class="hljs-bullet">1.</span> 检查数据是否在缓存中<br><span class="hljs-bullet">2.</span> 如果在，将状态改为 Exclusive<br><span class="hljs-bullet">3.</span> 执行原子操作<br><span class="hljs-bullet">4.</span> 通知其他 CPU 使其缓存失效<br></code></pre></td></tr></table></figure><p>不同的架构有不同的锁定方式：</p><ul><li>x86/x64：使用 LOCK 前缀</li><li>ARM：使用 exclusive load/store 指令</li><li>PowerPC：使用 load-linked/store-conditional</li></ul><p>以下是 x86 汇编的一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; 原子加法操作<br>lock add dword ptr [memory], 1<br><br>; 比较并交换<br>lock cmpxchg dword ptr [memory], eax<br></code></pre></td></tr></table></figure><p>为了充分利用<strong>缓存锁定</strong>的优势，我们在编写代码时，可以有以下的性能考虑：</p><ul><li><p><strong>缓存行对齐，避免伪共享</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicI32, Ordering&#125;;<br><br><span class="hljs-comment">// 在 Rust 中，可以使用 #[repr(align(N))] 属性来确保结构体或变量的对齐方式，以避免伪共享。</span><br><span class="hljs-comment">// 伪共享是指多个线程访问不同的变量，但这些变量共享同一个缓存行，从而导致不必要的缓存一致性流量。</span><br><span class="hljs-meta">#[repr(align(64))]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlignedCounter</span> &#123;<br>    counter: AtomicI32,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = AlignedCounter &#123;<br>        counter: AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>),<br>    &#125;;<br>    <span class="hljs-comment">// 使用 counter.counter.fetch_add(...) 进行操作</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>避免频繁的总线锁定</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicI32, Ordering&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 不好的做法：频繁的原子操作</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1000</span> &#123;<br>        counter.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Ordering::SeqCst);<br>    &#125;<br><br>    <span class="hljs-comment">// 更好的做法：本地累加后一次性更新</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">local_sum</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1000</span> &#123;<br>        local_sum += <span class="hljs-number">1</span>;<br>    &#125;<br>    counter.<span class="hljs-title function_ invoke__">fetch_add</span>(local_sum, Ordering::SeqCst);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="rust-实战查看汇编">Rust 实战查看汇编</h3><blockquote><p>笔者使用的是 ARM64 架构的 macbook。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicI64, Ordering&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">static</span> ATOMIC: AtomicI64 = AtomicI64::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        ATOMIC.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">10086</span>, Ordering::Release);<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">val</span> = ATOMIC.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire);<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;val&#125;&quot;</span>);<br>    &#125;);<br><br>    t1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    t2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>rustc</code> 编译并输出汇编代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rustc -O --emit asm src/main.rs<br></code></pre></td></tr></table></figure><p>代码中我特地设置了 <code>10086</code>这个特殊的值，这是为了可以在输出的 <code>main.s</code> 文件中快速找到<code>store</code> 对应的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__ZN3std3sys9backtrace28__rust_begin_short_backtrace17h750d7a3a9c81fc67E:<br>.cfi_startproc<br>Lloh8:<br>adrpx8, __ZN4main6ATOMIC17hd0b0dbf92e477148E.0@PAGE<br>Lloh9:<br>addx8, x8, __ZN4main6ATOMIC17hd0b0dbf92e477148E.0@PAGEOFF<br>movw9, #10086 ; 将值 10086 移入寄存器<br>stlrx9, [x8] ; Store-Release 指令，原子地存储值<br>; InlineAsm Start<br>; InlineAsm End<br>ret<br>.loh AdrpAddLloh8, Lloh9<br>.cfi_endproc<br></code></pre></td></tr></table></figure><p>在这个代码中，<code>stlr</code> 就是 <code>Store Release</code>的意思，另外一个关键字是 <code>ladpr</code>，表示<code>Load Acquire</code> 的意思，通过这个关键字，你可以找到<code>load</code> 对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Lloh11:<br>addx8, x8, __ZN4main6ATOMIC17hd0b0dbf92e477148E.0@PAGEOFF<br>ldaprx8, [x8] ; ; Load-Acquire 指令，原子地加载值<br>strx8, [sp, #8]<br></code></pre></td></tr></table></figure><h3 id="go-实战查看汇编">Go 实战查看汇编</h3><blockquote><p>笔者使用的是 ARM64 架构的 macbook。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>data := atomic.Int64&#123;&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>data.Store(<span class="hljs-number">10086</span>)<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>a := data.Load()<br><span class="hljs-built_in">println</span>(a)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>使用如下命令，可以输出优化后的汇编代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go build -gcflags=-S -ldflags=-w main.go 2&gt; assembly.txt<br></code></pre></td></tr></table></figure><p>查看输出的文件，我们同样搜索 <code>10086</code>，可以快速找到<code>store</code> 的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x0008 00008 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:109)MOVD$10086, R1<br>0x000c 00012 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:109)STLRR1, (R0)<br></code></pre></td></tr></table></figure><p>可以看到，这里同样也是使用了 <code>STLR</code> 指令。接着我们看第 14行代码的位置对应的汇编：可以发现这里使用的 <code>LDAR</code>指令，也就是 <code>Load Acuqire</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x001c 00028 (/Users/wangjiahan/goStudy/go-atomic/main.go:14)HINT$0<br>0x0020 00032 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:106)LDAR(R0), R0<br>0x0024 00036 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:106)MOVDR0, main..autotmp_6-8(SP)<br></code></pre></td></tr></table></figure><h1 id="内存顺序">内存顺序</h1><p>在了解了 Rust Atomic的基本用法和基本原理之后，我们回过头来谈一谈原子操作参数中的<code>std::sync::atomic::Ordering::Relaxed</code>，这个就是本篇的主题：<strong>内存顺序</strong>。内存顺序要解决的核心问题是<u>如何合理地限制单一线程中的代码执行顺序，使得在不使用锁的情况下，既能最大化利用CPU 的计算能力，又能保证多线程环境下不会出现逻辑错误。</u></p><h2 id="指令乱序">指令乱序</h2><p>CPU和编译器都会在保证程序运行结果不发生改变的前提下，尽一切可能让我们的程序运行得尽可能快。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>(a: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>, b: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>) &#123;<br>  *a += <span class="hljs-number">1</span>;<br>  *b += <span class="hljs-number">1</span>;<br>  *a += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>像上述代码，编译器完全可以优化成下面的代码，从而提高程序的运行效率：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>(a: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>, b: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>) &#123;<br>  *a += <span class="hljs-number">2</span>;<br>  *b += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个过程中，就可能会出现<strong>指令重排</strong>，甚至是<strong>代码重写</strong>，不过这带来了指令乱序的问题，即<u>程序的实际执行顺序跟我们的代码顺序是不一致的</u>。</p><p>不过，编译器保证的是<strong>在单线程环境下，执行的结果最终一致</strong>，所以，指令乱序在单线程环境下完全是允许的。对于编译器来说，它只知道：在当前线程中，数据的读写以及数据之间的依赖关系。但是，<strong>编译器并不知道哪些数据是在线程间共享，而且是有可能会被修改的</strong>。而这些是需要开发人员去保证的。</p><h2 id="内存模型">内存模型</h2><p>为了解决指令乱序带来的并发问题，Rust 采用了内存模型（MemoryModel）这一概念。这个概念主要借鉴自 C++11中引入的内存模型，它定义了在多线程环境下内存访问的行为规范。</p><p>内存模型的核心目标是在以下三方面之间取得平衡：</p><ol type="1"><li><strong>正确性保证</strong>：确保多线程程序的行为是可预测和一致的。</li><li><strong>性能优化</strong>：允许编译器和 CPU在不违反正确性的前提下进行优化。</li><li><strong>跨平台兼容</strong>：提供一个统一的抽象层，使代码可以在不同的硬件架构上正确运行。</li></ol><p>具体来说，内存模型：</p><ul><li>为开发者提供了清晰的规则，说明在多线程环境下，什么样的内存访问行为是合法的，什么样的行为会导致未定义行为。</li><li>为编译器开发者提供了明确的标准，指导他们在不同平台上实现必要的内存同步原语。</li><li>通过定义不同的内存顺序级别（如 Relaxed、Release/Acquire、SeqCst等），让开发者可以根据需要选择合适的同步强度。</li></ul><p>这种抽象让开发者可以专注于并发逻辑本身，而不必过分关注底层硬件的具体实现细节。</p><h2 id="sequenced-before">Sequenced-Before</h2><p>在讨论内存顺序之前，我们需要先对 2 个重要关系术语进行简单阐述，分别是<code>Sequenced-Before</code> 和 <code>Happens-Before</code>。</p><p><strong>Sequenced-Before</strong>描述的是<strong>单个线程内</strong>的操作顺序。它基于程序的源代码顺序，表示在同一线程中，一个操作在程序中出现在另一个操作之前。</p><p>具体来说，如果操作 A sequenced-before 操作 B，那么：</p><ol type="1"><li><p><strong>数据依赖关系</strong>：如果 B 依赖于 A 的结果，那么 A一定会在 B 之前执行。例如： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;      <span class="hljs-comment">// 操作 A</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 操作 B - 依赖于 A 的结果</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>原子操作的顺序</strong>：对同一个原子变量的操作会保持程序顺序。例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">5</span>, Relaxed);    <span class="hljs-comment">// 一定先执行</span><br>X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">10</span>, Relaxed);   <span class="hljs-comment">// 一定后执行</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>独立操作的可重排性</strong>：如果两个操作之间没有数据依赖关系，且操作的是不同的变量，那么它们可能会被重排序。例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">X.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, Relaxed);  <span class="hljs-comment">// 这两个操作可能会被重排序</span><br>Y.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">2</span>, Relaxed);  <span class="hljs-comment">// 因为它们操作的是不同的变量</span><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="happens-before">Happens-Before</h2><p><strong>Happens-Before</strong>则描述了<strong>跨线程</strong>的操作顺序。它定义了不同线程中的操作之间的可见性和顺序关系。如果操作A Happens-Before 操作 B，那么 A 的内存写入对 B 是可见的。</p><p>典型的 Happens-Before 有：</p><ol type="1"><li>同一线程内，如果先调用 <code>f()</code>，再调佣 <code>g()</code>，则<code>f()</code> happens-before <code>g()</code>，其实这就是<code>sequenced-before</code>。</li><li><code>spawing</code> happens-before <code>joining</code>。</li><li><code>lock</code> happens-before <code>unlock</code>。</li></ol><p>举个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> X: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(f);<br>    X.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">2</span>, Relaxed);<br>    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    X.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">3</span>, Relaxed);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-built_in">assert!</span>(x == <span class="hljs-number">1</span> || x == <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子的执行顺序如下图所示，因为 <code>spawn</code>happens-before<code>join</code>，所以我们可以确定的执行顺序是：<strong>“store 1 toX”→“store 2 to X”→“store 3 to X”</strong>。而 <strong>load fromX</strong> 介于 spawn 和 join之间，且没有进行任何其他的内存顺序限制，所以它和 <strong>store 2 toX</strong> 之间的顺序是不确定的，但是可以肯定的是，它一定在<strong>store 3 to X</strong> 之前，所以<code>assert!(x == 1 || x == 2);</code> 是永远成立的。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241111160041436.png" alt="spawn-happens-before-join" style="zoom:33%;" /></p><p>到这里，相信不少读者已经能够理解为什么需要内存顺序这个东西了，核心问题就是在于<strong>store 2 to X</strong> 和 <strong>load from X</strong>的执行顺序是否会影响我们的业务逻辑，如果不会，那么我们可以指定最松散的内存顺序要求，如果会，那么我们就要利用指定合适的内存顺序来使得其按照我们的预期顺序进行执行，从而保证业务逻的正确。</p><h2 id="rust-内存顺序">Rust 内存顺序</h2><p>Rust 支持五种内存顺序（Ordering），从最松散到最严格依次为：</p><table><thead><tr class="header"><th>内存顺序</th><th>说明</th><th>保证</th><th>适用场景</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>Relaxed</td><td>最宽松的内存顺序</td><td>- 仅保证操作的原子性<br>- 不提供任何同步保证<br>- 不建立happens-before 关系</td><td>- 简单计数器<br>- 性能要求极高且确定不需要同步<br>-已通过其他方式确保同步</td><td><code>counter.fetch_add(1, Ordering::Relaxed)</code></td></tr><tr class="even"><td>Release</td><td>用于存储操作</td><td>- 之前的内存访问不会被重排到此操作之后<br>- 与 Acquire配对使用可建立 happens-before 关系</td><td>- 生产者-消费者模式<br>- 发布共享数据<br>- 初始化完成标志</td><td><code>data.store(42, Ordering::Release)</code></td></tr><tr class="odd"><td>Acquire</td><td>用于加载操作</td><td>- 之后的内存访问不会被重排到此操作之前<br>- 与 Release配对使用可建立 happens-before 关系</td><td>- 生产者-消费者模式<br>- 获取共享数据<br>- 检查初始化标志</td><td><code>data.load(Ordering::Acquire)</code></td></tr><tr class="even"><td>AcqRel</td><td>同时包含 Acquire 和 Release 语义</td><td>- 结合了 Acquire 和 Release 的所有保证<br>- 用于读改写操作</td><td>- 需要双向同步的原子操作<br>- 锁的实现<br>- 复杂的同步原语</td><td><code>value.fetch_add(1, Ordering::AcqRel)</code></td></tr><tr class="odd"><td>SeqCst</td><td>最严格的内存顺序</td><td>- 包含 AcqRel 的所有保证<br>- 所有线程看到的所有 SeqCst操作顺序一致<br>- 提供全局的顺序一致性</td><td>- 需要严格的全局顺序<br>- 不确定使用哪种顺序时<br>-对性能要求不高的场景</td><td><code>flag.store(true, Ordering::SeqCst)</code></td></tr></tbody></table><p>在 C++ 中，其实还有另外一种内存顺序 <code>Consume</code>，它是<code>Acquire</code> 的一个更弱的版本：</p><ul><li><p><strong>Acquire</strong>:保证后续的所有读写操作不会重排到这个操作前面</p></li><li><p><strong>Consume</strong>:只保证后续与这个操作结果相关的读写操作不会重排到这个操作前面</p></li></ul><p>理论上，Consume 在某些架构上可以提供比 Acquire更好的性能，因为它只需要对数据依赖的操作进行同步。</p><p>然而，由于以下原因，Rust 选择不支持 Consume 顺序：</p><ol type="1"><li><strong>实现复杂性</strong>：很多编译器实现者发现正确实现 Consume语义非常困难。</li><li><strong>性能收益不确定</strong>：在实践中，大多数编译器都将 Consume视为 Acquire 来处理。</li><li><strong>标准困惑</strong>：C++ 标准委员会也承认当前的 Consume语义定义存在问题，正在考虑重新设计。</li></ol><div class="note note-info">            <p>选择建议：</p><ol type="1"><li><strong>不确定选择哪种顺序时</strong>：<ul><li>使用 SeqCst（最安全但性能最低）</li><li>或咨询有经验的开发者</li></ul></li><li><strong>性能优化时</strong>：<ul><li>先使用 SeqCst 开发</li><li>在性能测试后，根据需要降低到 Release/Acquire</li><li>只有在确实需要时才使用 Relaxed</li></ul></li><li><strong>常见组合</strong>：<ul><li>Release 写 + Acquire 读：最常见的生产者-消费者模式</li><li>AcqRel：用于原子的读改写操作</li><li>Relaxed：用于简单的计数器场景</li></ul></li></ol>          </div><p>下面我们来对每种内存顺序进行举例阐述。</p><h3 id="relaxed">Relaxed</h3><p><code>Relaxed</code>是最宽松的内存顺序，它只保证了原子操作在并发下的安全性，但不保证执行顺序。</p><p>考虑如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> X: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">5</span>, Relaxed);<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">10</span>, Relaxed); <br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">b</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;a&#125; &#123;b&#125; &#123;c&#125; &#123;d&#125;&quot;</span>);  <span class="hljs-comment">// 这个输出不一定</span><br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(a);<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(b);<br>    &#125;);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, X.<span class="hljs-title function_ invoke__">load</span>(Relaxed)); <span class="hljs-comment">// 最终结果一定是 15</span><br>&#125;<br></code></pre></td></tr></table></figure><p>基于我们上面提到的 <code>sequenced-before</code> 规则，我们可以确定<code>a</code> 和 <code>b</code> 两个线程内的<code>happens-before</code> 规则，但是二者之间的<code>happens-before</code> 是无法确定的，但是我们可以确定最后的结果是<code>15</code>。下图展示了上述代码的执行顺序示意图：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241111164259913.png" alt="relaxed-ordering" style="zoom:50%;" /></p><p>虽然两个线程之间的 <code>happens-before</code>是无法确定的，但是我们可以确定 <code>X</code>的变化顺序：0→5→15。所以线程 <code>b</code> 输出<code>0 0 0 0</code>、<code>0 0 5 15</code> 和 <code>0 15 15 15</code>都是可能的，而永远不可能输出 <code>0 5 0 15</code> 或<code>0 0 10 15</code> 类似的结果。</p><p>但是如果是这样子的话，就不一定了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> X: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a1</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">5</span>, Relaxed);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a2</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">10</span>, Relaxed); <br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">b</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;a&#125; &#123;b&#125; &#123;c&#125; &#123;d&#125;&quot;</span>);  <span class="hljs-comment">// 这个输出不一定</span><br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(a1);<br>      s.<span class="hljs-title function_ invoke__">apawn</span>(a2);<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(b);<br>    &#125;);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, X.<span class="hljs-title function_ invoke__">load</span>(Relaxed)); <span class="hljs-comment">// 最终结果一定是 15</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子，<code>X</code> 的变化顺序可以是 0→5→15，也可以是0→10→15，这取决于哪个 <code>fetch_add</code> 先被执行。</p><p>再举个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> DATA: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        <span class="hljs-comment">// 线程 A - 写入者</span><br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">123</span>, Ordering::Relaxed);     <span class="hljs-comment">// ① 准备数据</span><br>            READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Relaxed);   <span class="hljs-comment">// ② 发出数据就绪信号</span><br>        &#125;);<br><br>        <span class="hljs-comment">// 线程 B - 读取者</span><br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed) &#123;  <span class="hljs-comment">// ③ 等待数据就绪信号</span><br>                thread::<span class="hljs-title function_ invoke__">yield_now</span>();<br>            &#125;<br>            <span class="hljs-built_in">assert_eq!</span>(DATA.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed), <span class="hljs-number">123</span>); <span class="hljs-comment">// ④ 获取数据，这里断言一定成功吗？</span><br>        &#125;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子中，线程 A 执行了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">123</span>, Ordering::Relaxed);     <span class="hljs-comment">// 准备数据</span><br>READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Relaxed);   <span class="hljs-comment">// 发出数据就绪信号</span><br></code></pre></td></tr></table></figure><p>这是 2 个没有依赖关系的原子操作，且使用的是 <code>Relaxed</code>内存顺序，所以对于线程 B 来说，这 2个操作的顺序是不确定的。所以是很可能在<code>READY.load(Ordering::Relaxed)</code> 返回 <code>true</code>的时候，<code>DATA.load(Ordering::Relaxed)</code> 依旧还是<code>0</code>。</p><p>那如何确保这个断言一定成功呢？那就需要“升级”一下了~ 这个时候就轮到<code>Release</code> 和 <code>Acquire</code> 的出场了。</p><h3 id="release-acquire">Release &amp; Acquire</h3><p><code>Release</code> 和 <code>Acquire</code>一般成对出现，它们共同建立了线程间的同步关系：</p><ul><li><code>Release</code>:作用于写操作（store），确保该操作之前的所有内存访问不会被重排到这个Release 操作之后。</li><li><code>Acquire</code>:作用于读操作（load），确保该操作之后的所有内存访问不会被重排到这个Acquire 操作之前。</li></ul><p>当一个线程通过 <code>Acquire</code> 读取到另一个线程通过<code>Release</code> 写入的值时，会建立一个 happens-before关系：<strong><font color="orange">线程 A 中 Release写入之前的所有内存写操作，对于线程 B 中 Acquire读取之后的所有内存读操作都是可见的</font></strong>。</p><p>修改一下上面的例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> DATA: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">123</span>, Ordering::Relaxed);   <br>            READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Release);   <span class="hljs-comment">// 这里改为 release</span><br>        &#125;);<br><br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire) &#123;  <span class="hljs-comment">// 这里改为 acquire</span><br>                thread::<span class="hljs-title function_ invoke__">yield_now</span>();<br>            &#125;<br>            <span class="hljs-built_in">assert_eq!</span>(DATA.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed), <span class="hljs-number">123</span>); <span class="hljs-comment">// 必定成功</span><br>        &#125;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241111165714772.png" alt="release-acquire-ordering" style="zoom:50%;" /></p><p>如上图所示，在这个例子中：</p><ol type="1"><li>Release-Acquire 同步确保了 <code>READY</code> 的写入和读取之间建立了happens-before 关系</li><li>由于 <code>DATA</code> 的写入在 <code>READY</code> 的 Release写入之前，而 <code>DATA</code> 的读取在 <code>READY</code> 的 Acquire读取之后</li><li>因此可以保证线程 B 一定能看到线程 A 写入的值 123</li></ol><p>更进一步，我们通过观察，可以发现 <code>DATA</code> 都没必要使用<code>Atomic</code> 类型，因为由 <code>READY</code> 建议的<code>happens-before</code> 规则已经能保证对 <code>DATA</code>的读写不可能并发执行了。��过因为 Rust的类型系统并不允许跨线程进行非原子类型的读写操作，所以这里我们需要使用<code>unsafe</code>才能使编译通过，但通过我们之前的分析，我们可以确保下面这段代码是安全的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> DATA: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-comment">// Safety: 此时没有其他线程访问 DATA，</span><br>        <span class="hljs-comment">// 因为我们还没有设置 READY 标志</span><br>        <span class="hljs-keyword">unsafe</span> &#123; DATA = <span class="hljs-number">123</span> &#125;;<br>        READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Release); <span class="hljs-comment">// 在这个存储操作之前的所有内存操作 ..</span><br>    &#125;);<br>    <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Acquire) &#123; <span class="hljs-comment">// .. 在这个加载操作返回 true 后都是可见的</span><br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">100</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// Safety: 没有线程会修改 DATA，因为 READY 已经被设置</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; DATA &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <h3 id="释放序列release-sequence">释放序列（Release Sequence）</h3><p>我们再来看一段代码示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;sync::atomic::AtomicU8, thread&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> DATA: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i64</span>&gt; = <span class="hljs-built_in">vec!</span>[];<br><span class="hljs-keyword">static</span> FLAG: AtomicU8 = AtomicU8::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread_1</span>() &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        DATA.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">42</span>);<br>    &#125;<br>    FLAG.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, std::sync::atomic::Ordering::Release);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread_2</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">expected</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// memory_order_relaxed is okay because this is an RMW,</span><br>    <span class="hljs-comment">// and RMWs (with any ordering) following a release form a release sequence</span><br>    <span class="hljs-keyword">while</span> FLAG<br>        .<span class="hljs-title function_ invoke__">compare_exchange</span>(<br>            expected,<br>            <span class="hljs-number">2</span>,<br>            std::sync::atomic::Ordering::Relaxed,<br>            std::sync::atomic::Ordering::Relaxed,<br>        )<br>        .<span class="hljs-title function_ invoke__">is_err</span>()<br>    &#123;<br>        expected = <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread_3</span>() &#123;<br>    <span class="hljs-keyword">while</span> FLAG.<span class="hljs-title function_ invoke__">load</span>(std::sync::atomic::Ordering::Acquire) &lt; <span class="hljs-number">2</span> &#123;&#125;<br>    <span class="hljs-comment">// if we read the value 2 from the atomic flag, we see 42 in the vector</span><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(DATA[<span class="hljs-number">0</span>], <span class="hljs-number">42</span>); <span class="hljs-comment">// will never fire</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(thread_1);<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(thread_2);<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(thread_3);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是参考 <ahref="https://en.cppreference.com/w/cpp/atomic/memory_order">cppreference</a>而翻译成 Rust 代码的，在上述代码中，即使 <code>thread_2</code>中我们使用的是 <code>Relaxed</code>， 这段代码中的<code>assert_eq!(DATA[0], 42)</code>也是一定成功的。为什么呢？这涉及到一个重要的概念——<strong>释放序列（ReleaseSequence）</strong>：</p><ul><li>当一个 <code>release</code>操作后面跟着一系列的原子<code>"读-修改-写"(RMW)</code>操作时，这些操作会形成一个释放序列。</li><li>在这个序列中，后续的 RMW 操作<strong>不需要</strong>使用 release 或acquire 语义也能保证同步。</li></ul><p>在这段代码中：当 <code>thread_2</code> 的 <code>RMW</code>操作成功的时候，说明 <code>FLAG</code> 是 <code>1</code>，即<code>thread_1</code> 已经执行了 <code>release</code>操作，这个时候：</p><ol type="1"><li><code>thread_1</code> 的 <code>release</code> 操作建立了同步点</li><li><code>thread_2</code> 的 <code>RMW</code>操作自动成为释放序列的一部分</li><li>当 <code>thread_3</code> 通过 <code>acquire</code> 看到值 2时，它能看到整个释放序列的所有修改。</li><li>因此能保证看到 <code>DATA</code> 中的 42。</li></ol><p>所以在这种场景下使用 <code>relaxed</code> 既安全又高效，因为：</p><ul><li>它是释放序列的一部分</li><li>不需要额外的同步开销</li><li>仍然能保证正确的内存顺序</li></ul><p>为什么这样设计呢？</p><ul><li><strong>原子性保证</strong>：RMW操作本身就是原子的，不会产生数据竞争</li><li><strong>连续性</strong>：每个 RMW操作都直接或间接地基于前一个操作的结果</li><li><strong>因果关系</strong>：形成了一个清晰的修改链条</li><li><strong>性能考虑</strong>：中间的 RMW 操作不需要额外的同步开销</li></ul>          </div><h3 id="sequentially-consistent">Sequentially Consistent</h3><p><code>SeqCst</code> 是最严格的内存顺序，它包括获取<code>release</code> 和 <code>acquire</code>的所有保证，还保证了全局一致的操作顺序。简单理解就是，你代码的顺序是怎么样，实际的执行顺序就是什么样。</p><p>我们来看一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::Ordering::SeqCst;<br><br><span class="hljs-keyword">static</span> A: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">static</span> B: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> S: <span class="hljs-type">String</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        A.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, SeqCst);<br>        <span class="hljs-keyword">if</span> !B.<span class="hljs-title function_ invoke__">load</span>(SeqCst) &#123;<br>            <span class="hljs-keyword">unsafe</span> &#123; S.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&#x27;!&#x27;</span>) &#125;;<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        B.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, SeqCst);<br>        <span class="hljs-keyword">if</span> !A.<span class="hljs-title function_ invoke__">load</span>(SeqCst) &#123;<br>            <span class="hljs-keyword">unsafe</span> &#123; S.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&#x27;!&#x27;</span>) &#125;;<br>        &#125;<br>    &#125;);<br><br>    a.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    b.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，两个线程都是希望将自己的原子变量设置为<code>true</code>，从而阻止另外一个线程对 <code>S</code> 进行<code>push</code> 操作，其实就类似于锁。因为这里使用了<code>SeqCst</code>，所以代码的执行顺序是跟代码编写顺序是一致的，那么就可能出现以下3 种执行情况：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241112113535084.png"alt="seqcst-memory-order" /><figcaption aria-hidden="true">seqcst-memory-order</figcaption></figure><p>即：同一时刻，<strong>最多</strong>只可能有一个线程会对<code>S</code> 进行操作。</p><h1 id="内存屏障">内存屏障</h1><p>除了内存顺序（MemoryOrder），还有另外一种方式可以控制程序的执行顺序，就是内存屏障（MemoryBarrier）。内存屏障是一种底层的同步原语，它能强制处理器按照特定的顺序执行内存操作。内存屏障通过阻止或限制指令重排序，来确保内存操作的可见性和顺序性。</p><h2 id="基本概念">基本概念</h2><p>内存屏障主要分为以下几种类型：</p><ol type="1"><li><strong>Load Barrier（读屏障）</strong><ul><li>确保在屏障之前的所有读操作都执行完成</li><li>防止后续读操作被重排到屏障之前</li><li>对应 Acquire 语义</li></ul></li><li><strong>Store Barrier（写屏障）</strong><ul><li>确保在屏障之前的所有写操作都执行完成</li><li>防止后续写操作被重排到屏障之前</li><li>对应 Release 语义</li></ul></li><li><strong>Full Barrier（全屏障）</strong><ul><li>同时包含读屏障和写屏障的功能</li><li>防止任何内存操作的重排序</li><li>对应 SeqCst 语义</li></ul></li></ol><p>即下面这 2 种实现方式是等价的：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241112123652784.png" alt="fench" style="zoom:50%;" /></p><p>所以到这里，我们可以更好地理解<strong>为什么 <code>release</code>是阻止其前面的内存访问越过它，而 <code>acquire</code>是阻止其后面的内存访问越过它了</strong>。因为有个 <code>fence</code>在前面或后面拦着！</p><p>但是一般来说，下面的写法相比上面的写法会有一丢丢的性能损失，因为这会增加一些额外的处理指令。那<code>fence</code> 的用武之地是什么呢？</p><ol type="1"><li>可以同时对多个原子操作进行 <code>fench</code>；</li><li>可以根据条件判断，选择是否进行 <code>fench</code>。</li></ol><p>举个例子：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241112125023036.png" alt="fence-multi-atomics" style="zoom:50%;" /></p><p>这个例子的关键点是：</p><ol type="1"><li>如果线程 2 中的任何一个 load 操作观察到了线程 1 中对应的 store操作的值：<ul><li>比如 A.load() 读到了值 1，或</li><li>B.load() 读到了值 2，或</li><li>C.load() 读到了值 3</li></ul></li><li>那么：线程 1 中的 release fence 就会 happens-before 线程 2 中的acquire fence。这意味着线程 1 中 release fence 之前的所有内存操作对线程2 中 acquire fence 之后的操作都是可见的。</li></ol><p>这展示了内存屏障的一个重要优势：<strong>一个屏障可以同时为多个原子操作建立同步关系，而不需要在每个原子操作上都使用Release/Acquire 内存序。这在某些场景下可能会更高效。</strong></p><p>用更通俗的话说：这就像在线程 1 设置了一个"检查点"（releasefence），在线程 2 也设置了一个"检查点"（acquire fence），只要线程 2看到了线程 1 在其检查点之后做的任何一个改动，那么线程 1检查点之前的所有操作对线程 2 的检查点之后都是可见的。</p><h2 id="硬件实现">硬件实现</h2><p>不同的处理器架构实现内存屏障的方式不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; x86/x64<br>MFENCE  ; 全屏障<br>LFENCE  ; 读屏障<br>SFENCE  ; 写屏障<br><br>; ARM<br>DMB     ; 数据内存屏障<br>DSB     ; 数据同步屏障<br>ISB     ; 指令同步屏障<br></code></pre></td></tr></table></figure><h2 id="与内存顺序的关系">与内存顺序的关系</h2><p>Rust 的内存顺序实际上是通过内存屏障来实现的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Release 写入会插入 Store Barrier</span><br>atomic.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">42</span>, Ordering::Release);  <span class="hljs-comment">// 编译器会在此处插入 Store Barrier</span><br><br><span class="hljs-comment">// Acquire 读取会插入 Load Barrier</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = atomic.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire);  <span class="hljs-comment">// 编译器会在此处插入 Load Barrier</span><br><br><span class="hljs-comment">// SeqCst 操作会插入 Full Barrier</span><br>atomic.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">42</span>, Ordering::SeqCst);  <span class="hljs-comment">// 编译器会在此处插入 Full Barrier</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>注意：直接使用内存屏障是非常底层的操作，通常我们应该使用 Rust提供的高级抽象（如原子类型和它们的内存顺序）来实现同步。内存屏障的知识主要用于理解这些高级抽象的工作原理。</p>          </div><h1 id="go-atomic">Go Atomic</h1><p>熟悉 Go 语言的读者应该会意识到在使用 Go语言的原子类型的时候，好像都没见过 Memory Order 这个东西，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>data := atomic.Int64&#123;&#125;<br>data.Add(<span class="hljs-number">1</span>)<br>data.And(<span class="hljs-number">2</span>)<br>data.Or(<span class="hljs-number">3</span>)<br>data.Swap(<span class="hljs-number">4</span>)<br>data.Store(<span class="hljs-number">5</span>)<br>data.Load()<br>data.CompareAndSwap(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <ahref="https://github.com/golang/go/blob/release-branch.go1.23/src/sync/atomic/doc.go">atomic/doc.go</a>源码中我们可以看到这段话：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The load and store operations, implemented by the LoadT and StoreT</span><br><span class="hljs-comment">// functions, are the atomic equivalents of &quot;return *addr&quot; and</span><br><span class="hljs-comment">// &quot;*addr = val&quot;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// In the terminology of [the Go memory model], if the effect of</span><br><span class="hljs-comment">// an atomic operation A is observed by atomic operation B,</span><br><span class="hljs-comment">// then A “synchronizes before” B.</span><br><span class="hljs-comment">// Additionally, all the atomic operations executed in a program</span><br><span class="hljs-comment">// behave as though executed in some sequentially consistent order.</span><br><span class="hljs-comment">// This definition provides the same semantics as</span><br><span class="hljs-comment">// C++&#x27;s sequentially consistent atomics and Java&#x27;s volatile variables.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// [the Go memory model]: https://go.dev/ref/mem</span><br></code></pre></td></tr></table></figure><p>Go语言设计者认为让程序员选择内存序会增加复杂性和出错的可能，所以为了程序的简单性和可预测性，直接就<strong>使用了最安全的<code>Seq-Cst</code> 内存顺序</strong>了。</p><p><a href="https://go.dev/ref/mem">the Go memory model</a>中还提了一句：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">If you must read the rest of this document to understand the behavior of your program, you are being too clever.<br>Don&#x27;t be clever.<br></code></pre></td></tr></table></figure><p>这也呼应了 Go 的设计理念：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Share memory by communicating; don&#x27;t communicate by sharing memory.<br></code></pre></td></tr></table></figure><p>所以总结一下：</p><ol type="1"><li>Go 的原子操作采用了最强的顺序一致性内存序；</li><li>这是一个有意识的设计选择，为了简单性和可预测性；</li><li>如果你需要更细粒度的内存序控制，那么 Go 可能不是最佳选择；</li><li>Go 更推荐使用 channels 和其他同步原语来进行并发控制。</li></ol><h1 id="参考">参考</h1><ul><li><a href="https://marabos.nl/atomics/memory-ordering.html">RustAtomics And Lock</a></li><li><ahref="https://mp.weixin.qq.com/s/t5_Up2YZEZt1NLbvgYz9FQ">聊一聊内存模型与内存序</a></li><li><ahref="https://en.cppreference.com/w/cpp/atomic/memory_order">cppreference</a></li><li><a href="https://go.dev/ref/mem">the Go memory model</a></li></ul>]]></content>
    
    
    <summary type="html">本文深入探讨了 Rust 中的原子操作和内存顺序模型。从硬件层面的原子操作实现原理出发,详细介绍了 Rust 提供的各种原子类型及其操作,并重点阐述了内存顺序(Memory Ordering)的概念、分类及其在并发编程中的应用。通过大量示例代码和图解,帮助读者全面理解 Rust 的内存模型和并发安全机制。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 底层原理" scheme="https://hedon.top/categories/Rust/Rust-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="内存顺序" scheme="https://hedon.top/tags/%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F/"/>
    
    <category term="内存屏障" scheme="https://hedon.top/tags/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    
    <category term="并发控制" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
    <category term="Atomic" scheme="https://hedon.top/tags/Atomic/"/>
    
    <category term="Happens-Before" scheme="https://hedon.top/tags/Happens-Before/"/>
    
  </entry>
  
  <entry>
    <title>KCP 源码分析与原理总结</title>
    <link href="https://hedon.top/2024/06/12/kcp/"/>
    <id>https://hedon.top/2024/06/12/kcp/</id>
    <published>2024-06-12T03:08:02.000Z</published>
    <updated>2024-11-12T19:14:55.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>本文很大部分参考了 <ahref="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP协议的原理和实现</a>，非常感谢该文作者的讲解。本文再此基础上，加入了一些笔者的思考和分析图示，以期更好地理解KCP 的底层原理。</p><h1 id="结论先行">结论先行</h1><p>KCP 是一个快速可靠协议，能以比 TCP 浪费 10%-20%的带宽的代价，换取平均延迟降低30%-40%，且最大延迟降低三倍的传输效果。</p><p>TCP 是为流量设计的（每秒内可以传输多少 KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以 10%-20%带宽浪费的代价换取了比 TCP 快 30%-40% 的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而 KCP是水流湍急的小激流。</p><h2 id="kcp-增加的带宽在哪里增加的速度又在哪里">KCP增加的带宽在哪里？增加的速度又在哪里？</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612111337839.png"alt="为什么 KCP 能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%？" /><figcaption aria-hidden="true">为什么 KCP 能以比 TCP 浪费 10%-20%的带宽的代价，换取平均延迟降低 30%-40%？</figcaption></figure><h2 id="kcp-核心特性">KCP 核心特性</h2><p><strong>快速重传</strong>： KCP支持快速重传机制，不像 TCP那样依赖超时重传。KCP可以根据接收方返回的确认信息快速判断哪些数据包已经丢失，并迅速进行重传。</p><p><strong>选择性确认（Selective Acknowledgment, SACK）</strong>： KCP支持SACK，这允许接收端告知发送端哪些包已经收到，从而仅重传未被确认接收的数据包，减少不必要的重传。</p><p><strong>无连接操作</strong>： 基于 UDP 的实现使得 KCP在传输数据前不需要像 TCP那样进行三次握手建立连接，这减少了初始的延迟，并使其能在连接性较差的网络环境下更加灵活和快速。</p><p><strong>拥塞控制</strong>： KCP 实现了类似 TCP的拥塞控制算法，但更为简化，能够快速适应网络条件的变化，如带宽波动和丢包。</p><p><strong>流量控制</strong>： KCP允许调整发送和接收的窗口大小，使得发送方可以根据接收方的处理能力和网络条件调整数据发送速率，优化网络利用率和减少拥塞。</p><p><strong>可配置的传输策略</strong>： KCP允许用户根据应用需求调整内部参数，如传输间隔、窗口大小等，以达到最优的传输效率和延迟。</p><p><strong>前向错误校正（Forward Error Correction, FEC）</strong>： KCP还可以结合使用 FEC技术，通过发送额外的冗余数据来恢复丢失的包，进一步提高在高丢包环境下的数据传输可靠性。</p><h2 id="为什么-tcp-做不到-kcp-这样">为什么 TCP 做不到 KCP 这样？</h2><p>TCP作为一种成熟且广泛使用的传输协议，在设计上注重可靠性和通用性，因此在拥塞控制和流量控制方面相对保守，以确保在各种网络条件下都能稳定运行。然而，这些设计上的保守性也导致了TCP 在某些情况下的灵活性和自适应性不如 KCP。</p><table><thead><tr class="header"><th>特性类别</th><th>协议</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>拥塞控制机制</td><td>TCP</td><td>固定算法（慢启动、拥塞避免等），保守的调整策略（指数和线性增长）</td></tr><tr class="even"><td></td><td>KCP</td><td>灵活算法，动态调整策略，快速调整窗口大小</td></tr><tr class="odd"><td>重传机制的延迟</td><td>TCP</td><td>固定重传间隔（RTO），多次确认触发重传</td></tr><tr class="even"><td></td><td>KCP</td><td>快速重传，选择性重传，减少重传延迟</td></tr><tr class="odd"><td>流量控制</td><td>TCP</td><td>固定流量控制（依赖接收窗口和发送窗口），通用性设计</td></tr><tr class="even"><td></td><td>KCP</td><td>自适应流量控制，应用层反馈调整发送窗口和重传策略</td></tr><tr class="odd"><td>应用场景</td><td>TCP</td><td>广泛应用于各种网络环境，标准化要求高</td></tr><tr class="even"><td></td><td>KCP</td><td>优化特定场景（如高丢包率和高延迟网络），灵活实现</td></tr></tbody></table><h3 id="拥塞控制机制的固定性">1. 拥塞控制机制的固定性</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定算法</strong>：TCP 的拥塞控制算法，如慢启动（SlowStart）、拥塞避免（Congestion Avoidance）、快速重传（FastRetransmit）和快速恢复（FastRecovery），在设计时考虑了广泛的兼容性和可靠性。这些算法虽然有效，但其调整机制相对固定，响应速度较慢。</li><li><strong>保守的调整策略</strong>：TCP的拥塞控制算法采用了保守的调整策略，例如指数增长和线性增长，这在高丢包率或高延迟网络中，可能会导致拥塞窗口（cwnd）增长速度较慢，影响传输效率。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>灵活算法</strong>：KCP的拥塞控制机制更为灵活，可以根据实时网络状况进行快速调整。例如，KCP的快速重传和选择性重传机制，使其能更快速地响应网络丢包情况。</li><li><strong>动态调整策略</strong>：KCP的拥塞窗口调整更为灵活，可以根据网络状况快速增加或减少窗口大小，提高传输效率。</li></ul><h3 id="重传机制的延迟">2. 重传机制的延迟</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定重传间隔</strong>：TCP使用固定的重传超时（RTO），并随着每次重传逐渐增加（指数回退），这种保守的重传机制在高延迟和高丢包率网络中可能导致重传延迟较长。</li><li><strong>多次确认触发重传</strong>：TCP 的快速重传需要等待三个重复的ACK 才能触发，这在丢包率较高的情况下，可能会导致较长的延迟。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>快速重传</strong>：KCP在检测到丢包后立即进行重传，而不需要等待多个重复的ACK，这显著减少了重传延迟。</li><li><strong>选择性重传</strong>：KCP只重传丢失的数据包，而不是所有未确认的数据包，减少了不必要的重传开销。</li></ul><h3 id="流量控制的灵活性">3. 流量控制的灵活性</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定流量控制</strong>：TCP的流量控制主要依赖于接收窗口（rwnd）和发送窗口（swnd），在处理突发流量或变化较大的网络条件时，调整速度较慢。</li><li><strong>通用性设计</strong>：TCP作为一种通用协议，其设计必须兼顾各种网络环境，因此在流量控制上相对保守，以确保在任何环境下都能稳定运行。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>自适应流量控制</strong>：KCP的流量控制机制可以根据实际应用需求进行更细粒度的调整。例如，KCP可以根据延迟抖动、丢包率等动态参数调整发送速率，确保在不同网络条件下都能保持高效传输。</li><li><strong>应用层反馈</strong>：KCP可以根据应用层的实时反馈，动态调整发送窗口和重传策略，进一步优化传输效率。</li></ul><h3 id="应用场景的差异">4. 应用场景的差异</h3><p><strong>TCP</strong>：</p><ul><li><strong>广泛应用</strong>：TCP设计用于广泛的网络环境，包括稳定的有线网络和不稳定的无线网络，因此其机制必须足够通用和保守，保证在各种情况下的可靠性。</li><li><strong>标准化要求</strong>：作为互联网的基础协议，TCP的各项机制经过严格标准化，任何修改都需要广泛测试和验证，以确保不会影响现有网络的稳定性。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>特定优化</strong>：KCP设计初衷是优化特定场景下的传输性能，特别是高丢包率和高延迟网络，因此在设计上更加灵活，能够根据实时网络状况进行调整。</li><li><strong>灵活实现</strong>：KCP可以根据具体应用需求进行优化，例如在实时通信和在线游戏等场景中，灵活的流量控制和快速重传机制显著提升了传输效率。</li></ul><h3 id="结论">结论</h3><p>虽然 TCP在拥塞控制和流量控制方面具备基本的动态调整能力，但其保守的设计和标准化要求使得其在高丢包率和高延迟网络中的适应性和灵活性不如KCP。KCP通过灵活的拥塞控制、快速重传和自适应流量控制机制，能够更有效地应对不同网络条件下的传输需求，提供更高效的传输性能。</p><h2 id="kcp-一定比-tcp-快吗">KCP 一定比 TCP 快吗？</h2><p><font color="red">不一定</font>。KCP 并不一定在所有情况下都比 TCP快。虽然 KCP在某些特定网络环境（如高丢包率和高延迟的网络）中表现更优异，但在某些情况下，TCP可能更合适。</p><h3 id="网络环境">1. 网络环境</h3><p><strong>高丢包率和高延迟网络</strong>：</p><ul><li><strong>KCP</strong>：KCP通过快速重传和选择性重传机制，以及动态调整的窗口和重传间隔，能够更好地应对高丢包率和高延迟网络，减少传输延迟，提高传输效率。</li><li><strong>TCP</strong>：TCP的重传机制和保守的拥塞控制在这种环境中可能导致较高的延迟和较低的带宽利用率。</li></ul><p><strong>低丢包率和低延迟网络</strong>：</p><ul><li><strong>KCP</strong>：在稳定的低丢包率和低延迟网络中，KCP的频繁重传和控制报文可能会导致额外的带宽开销，未必有明显的性能优势。</li><li><strong>TCP</strong>：TCP在这种环境中表现稳定，且由于其带宽开销较小，可能比 KCP 更高效。</li></ul><h3 id="带宽利用率">2. 带宽利用率</h3><p><strong>带宽充足的网络</strong>：</p><ul><li><strong>KCP</strong>：KCP由于其频繁的重传和控制报文，可能会占用更多的带宽，但如果带宽充足，这种开销对整体性能影响较小，且其低延迟优势可能更明显。</li><li><strong>TCP</strong>：TCP的带宽利用率较高，适合带宽充足的环境。</li></ul><p><strong>带宽受限的网络</strong>：</p><ul><li><strong>KCP</strong>：KCP的额外带宽开销在带宽受限的网络中可能会显著影响整体传输效率。</li><li><strong>TCP</strong>：TCP的较低带宽开销使其在带宽受限的环境中更有优势。</li></ul><h3 id="应用场景">3. 应用场景</h3><p><strong>实时应用</strong>（如在线游戏、视频会议）：</p><ul><li><strong>KCP</strong>：KCP的低延迟和快速响应能力使其非常适合实时应用，在这些场景中，传输的及时性比带宽利用率更重要。</li><li><strong>TCP</strong>：TCP 在这些场景中的表现可能不如KCP，特别是在高丢包率和高延迟的网络中。</li></ul><p><strong>非实时应用</strong>（如文件传输、网页浏览）：</p><ul><li><strong>KCP</strong>：KCP 在这些场景中可能不如 TCP高效，特别是在网络稳定且带宽有限的情况下。</li><li><strong>TCP</strong>：TCP的可靠性和高带宽利用率使其非常适合非实时应用。</li></ul><h3 id="实现和配置">4. 实现和配置</h3><p><strong>实现复杂性</strong>：</p><ul><li><strong>KCP</strong>：实现和配置 KCP 可能比 TCP更复杂，需要根据具体应用和网络环境进行优化和调整。</li><li><strong>TCP</strong>：TCP是一个成熟的协议，系统和库的支持较好，配置和使用相对简单。</li></ul><h3 id="总结">总结</h3><p>KCP 在某些特定环境和应用场景中确实比 TCP更快，尤其是高丢包率和高延迟的网络环境，以及对低延迟要求较高的实时应用。但在网络稳定、带宽有限或非实时应用场景中，TCP可能表现更好。因此，选择使用 KCP 还是 TCP应根据具体的网络条件和应用需求进行权衡。</p><h1 id="前置准备">前置准备</h1><p>笔者不想那么快就贴出大段大段的代码进行分析，这可能会使读者不知所云。为了更好地阐述KCP的底层原理，笔者的设想是先对原理部分进行概要总结，然后再带着这些结论去分析源码，进一步填充里面的边角细节。</p><p>但是呢，为了更好地理解 KCP的原理，又不得不对涉及源码的一些重要设计，为了避免在原理分析阶段，对源码进行过多的涉及，笔者决定添加这单独的一章内容，对KCP 的“接口设计”、“报文段”、“KCP控制块”以及“队列和缓冲区”先进行简要概述，以辅助读者更好地理解后续的内容。</p><h2 id="接口设计">接口设计</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612171839051.png"alt="KCP 工作简约图" /><figcaption aria-hidden="true">KCP 工作简约图</figcaption></figure><p>在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h">kcp.h</a>文件中，定义了 KCP 最核心的几个接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个新的 KCP 控制对象</span><br>ikcpcb* <span class="hljs-title function_">ikcp_create</span><span class="hljs-params">(IUINT32 conv, <span class="hljs-type">void</span> *user)</span>;<br><br><span class="hljs-comment">// 释放一个 KCP 控制对象。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_release</span><span class="hljs-params">(ikcpcb *kcp)</span>;<br><br><span class="hljs-comment">// 设置 KCP 的输出回调函数，这个回调函数在 KCP 需要发送数据时被调用。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_setoutput</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">int</span> (*output)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> len, </span><br><span class="hljs-params">ikcpcb *kcp, <span class="hljs-type">void</span> *user))</span>;<br><br><span class="hljs-comment">// 从 KCP 的接收队列中接收数据，用于上层从 KCP 中读取数据。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_recv</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> len)</span>;<br><br><span class="hljs-comment">// 向 KCP 的发送队列中添加数据，用于上层向 KCP 发送数据，KCP 会管理这些数据并负责其可靠传输。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_send</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> len)</span>;<br><br><span class="hljs-comment">// 更新 KCP 的内部状态，通常需要定期调用。</span><br><span class="hljs-comment">// 这个函数负责处理 KCP 的超时、重传等操作，需要在一定的时间间隔内反复调用（通常每 10-100 毫秒）。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_update</span><span class="hljs-params">(ikcpcb *kcp, IUINT32 current)</span>;<br><br><span class="hljs-comment">// 判断是否要调用 ikcp_update</span><br>IUINT32 <span class="hljs-title function_">ikcp_check</span><span class="hljs-params">(<span class="hljs-type">const</span> ikcpcb *kcp, IUINT32 current)</span>;<br><br><span class="hljs-comment">// 处理接收到的低层数据包（例如 UDP 包）。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_input</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">long</span> size)</span>;<br><br><span class="hljs-comment">// 将缓冲区可以发送的包发送出去，会在 ikcp_update 中被调用。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_flush</span><span class="hljs-params">(ikcpcb *kcp)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>ikcp_create</code>:</p><ul><li><code>conv</code>:会话标识符，用于标识两个端点之间的连接。这个标识符在两个通信端点之间必须一致。</li><li><code>user</code>: 用户数据指针，可以传递任意用户数据，这个数据在KCP 的 <code>output</code> 回调中会被传递回去。</li><li><strong>返回值</strong>: 一个指向新创建的 KCP控制块（<code>ikcpcb</code>）的指针。</li></ul></li><li><p><code>ikcp_release</code>: 释放一个 KCP 控制对象。</p></li><li><p><code>ikcp_setoutput</code>: 设置 KCP 的输出回调函数。</p><ul><li><p><code>output</code>: 输出回调函数指针。这个回调函数在 KCP需要发送数据时被调用。</p><ul><li><code>buf</code>: 要发送的数据缓冲区。</li><li><code>len</code>: 数据长度。</li><li><code>kcp</code>: 当前的 KCP 对象。</li><li><code>user</code>: 用户数据。</li></ul><p>通过这个回调，KCP 可以将要发送的数据传递给下层的网络层，比如 UDP套接字。</p></li></ul></li><li><p><code>ikcp_recv</code>: 从 KCP 的接收队列中接收数据。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>buffer</code>: 用户提供的缓冲区，用于存储接收到的数据。</li><li><code>len</code>: 缓冲区的长度。</li><li><strong>返回值</strong>:成功接收的数据大小；如果没有数据可接收，返回负值（例如，EAGAIN）。</li></ul><p>这个函数用于上层从 KCP 中读取数据。</p></li><li><p><code>ikcp_send</code>: 向 KCP 的发送队列中添加数据。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>buffer</code>: 要发送的数据缓冲区。</li><li><code>len</code>: 数据的长度。</li><li><strong>返回值</strong>:成功发送的数据大小；如果发送失败，返回负值。</li></ul><p>这个函数用于上层向 KCP 发送数据，KCP会管理这些数据并负责其可靠传输。</p></li><li><p><code>ikcp_update</code>: 更新 KCP的内部状态，通常需要定期调用。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>current</code>: 当前的时间戳（以毫秒为单位）。</li></ul><p>这个函数负责处理 KCP的超时、重传等操作，需要在一定的时间间隔内反复调用（通常每 10-100毫秒）。</p></li><li><p><code>ikcp_input</code>: 处理接收到的低层数据包（例如 UDP包）。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>data</code>: 收到的数据缓冲区。</li><li><code>size</code>: 数据的长度。</li><li><strong>返回值</strong>:成功处理的数据大小；如果处理失败，返回负值。</li></ul></li><li><p><code>ikcp_flush</code>: 刷新待发送的数据。</p></li></ul><p>其中最重要的是这 4 个：</p><ul><li><code>ikcp_send</code>: 将数据放在发送队列中等待发送。</li><li><code>ikcp_recv</code>: 从接收队列中读取数据。</li><li><code>ikcp_input</code>:读取下层协议输入数据，解析报文段，如果是数据，就将数据放入接收缓冲区，如果是ACK，就在发送缓冲区中标记对应的报文段已送达。</li><li><code>ikcp_flush</code>:调用输出回调将发送缓冲区的数据发送出去。</li></ul><p>这里就先简要介绍到这里，后面在源码分析篇章再对这些接口进行详细分析。</p><h2 id="报文段">报文段</h2><p>KCP 的报文段大小为 24 字节，结构如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612172557464.png" alt="KCP 报文段" style="zoom: 33%;" /></p><p>每个字段的含义如下：</p><ul><li><code>conv</code>: 连接标识</li><li><code>cmd</code>：报文类型</li><li><code>frg</code>：分片数量，表示随后还有多少个报文属于同一个包</li><li><code>wnd</code>：发送方剩余接收窗口的大小</li><li><code>ts</code>：时间戳</li><li><code>sn</code>：报文编号</li><li><code>una</code>：发送方的接收缓冲区中最小还未收到的报文段的编号，也就是说，比它小的报文段都已全部接收</li><li><code>len</code>：数据段长度</li><li><code>data</code>：数据段，只有数据报文会有这个字段</li></ul><p>其中 <code>cmd</code> 共有 4 种报文类型：</p><ul><li>数据报文：IKCP_CMD_PUSH</li><li>确认报文：IKCP_CMD_ACK</li><li>窗口探测报文：IKCP_CMD_WASK 询问对端剩余接收窗口的大小</li><li>窗口通知报文：IKCP_CMD_WINS 通知对端剩余接收窗口的大小</li></ul><p>在 KCP 中，报文段结构定义在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h">kcp.h</a>文件中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPSEG</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">node</span>;</span><br>IUINT32 conv;<br>IUINT32 cmd;<br>IUINT32 frg;<br>IUINT32 wnd;<br>IUINT32 ts;<br>IUINT32 sn;<br>IUINT32 una;<br>IUINT32 len;<br>IUINT32 resendts;<br>IUINT32 rto;<br>IUINT32 fastack;<br>IUINT32 xmit;<br><span class="hljs-type">char</span> data[<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>IKCPSEG</code> 结构还多出了几个字段，这是为了支持 KCP协议的可靠性和效率：</p><ul><li><code>resendts</code>:记录报文的下次重传时间，用于实现重传机制。如果报文在一定时间内没有被确认收到，就会在这个时间戳之后被重新发送。</li><li><code>rto</code>: 表示当前报文的重传超时时间（RTT的估计值）。用于计算每个报文的重传时间，如果超过 <code>rto</code>时间没有收到 ACK，会触发重传。</li><li><code>fastack</code>:快速重传计数，记录该报文被跳过的次数。如果一个报文的 ACK连续接收到多个对同一报文的确认，而不是新的报文，会增加这个计数，用于实现快速重传机制。</li><li><code>xmit</code>:记录报文已经被发送的次数。用于统计一个报文的重传次数，帮助判断传输的可靠性。如果操作<code>dead_link</code> 次，则会判断为连接失效，KCP 会断开连接。</li><li><code>node</code>: 链表节点，用于将多个 <code>IKCPSEG</code>结构体链接在一起。KCP 的队列和缓冲区都是循环双链表结构。</li></ul><p>这些字段共同作用，帮助 KCP 实现以下功能：</p><ul><li><strong>可靠性</strong>：通过 <code>sn</code>、<code>una</code> 和<code>ack</code> 确保数据包按顺序接收和重传。</li><li><strong>流量控制</strong>：通过 <code>wnd</code>控制数据流量，避免接收方过载。</li><li><strong>高效传输</strong>：通过 <code>resendts</code> 和<code>rto</code> 进行超时和重传控制，<code>fastack</code>提供快速重传机制。</li><li><strong>灵活管理</strong>：使用链表节点 <code>node</code>组织数据，便于内部管理。</li></ul><h2 id="kcp-控制块-ikcpcb">KCP 控制块 ikcpcb</h2><p>上面我们提到的 <code>ikcp_create</code> 和 <code>ikcp_release</code>就是对 KCP 控制块 <code>ikcpcb</code> 的创建和释放，每个 KCP连接都对应一个 KCP 控制块。它定义在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h#L343">kcp.h</a>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPCB</span></span><br><span class="hljs-class">&#123;</span><br>IUINT32 conv, mtu, mss, state;<br>IUINT32 snd_una, snd_nxt, rcv_nxt;<br>IUINT32 ts_recent, ts_lastack, ssthresh;<br>IINT32 rx_rttval, rx_srtt, rx_rto, rx_minrto;<br>IUINT32 snd_wnd, rcv_wnd, rmt_wnd, cwnd, probe;<br>IUINT32 current, interval, ts_flush, xmit;<br>IUINT32 nrcv_buf, nsnd_buf;<br>IUINT32 nrcv_que, nsnd_que;<br>IUINT32 nodelay, updated;<br>IUINT32 ts_probe, probe_wait;<br>IUINT32 dead_link, incr;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_buf</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_buf</span>;</span><br>IUINT32 *acklist;<br>IUINT32 ackcount;<br>IUINT32 ackblock;<br><span class="hljs-type">void</span> *user;<br><span class="hljs-type">char</span> *buffer;<br><span class="hljs-type">int</span> fastresend;<br><span class="hljs-type">int</span> fastlimit;<br><span class="hljs-type">int</span> nocwnd, stream;<br><span class="hljs-type">int</span> logmask;<br><span class="hljs-type">int</span> (*output)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> len, <span class="hljs-keyword">struct</span> IKCPCB *kcp, <span class="hljs-type">void</span> *user);<br><span class="hljs-type">void</span> (*writelog)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-built_in">log</span>, <span class="hljs-keyword">struct</span> IKCPCB *kcp, <span class="hljs-type">void</span> *user);<br>&#125;;<br></code></pre></td></tr></table></figure><p>字段的含义如下，读者可在后续分析过程回过来查阅：</p><table><thead><tr class="header"><th>字段名</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>conv</code></td><td>连接标识符，用于识别一个特定的会话。</td></tr><tr class="even"><td><code>mtu</code></td><td>最大传输单元（Maximum TransmissionUnit），表示网络层传输数据包的最大字节数。</td></tr><tr class="odd"><td><code>mss</code></td><td>最大报文段长度（Maximum SegmentSize），表示应用层传输数据的最大字节数。</td></tr><tr class="even"><td><code>state</code></td><td>连接状态，标识当前的传输状态。</td></tr><tr class="odd"><td><code>snd_una</code></td><td>未确认的发送序号，表示最早未确认的包的序号。</td></tr><tr class="even"><td><code>snd_nxt</code></td><td>下一个发送序号，表示即将发送的包的序号。</td></tr><tr class="odd"><td><code>rcv_nxt</code></td><td>下一个接收序号，表示期望接收的下一个包的序号。</td></tr><tr class="even"><td><code>ts_recent</code></td><td>最近的时间戳，用于延迟测量。</td></tr><tr class="odd"><td><code>ts_lastack</code></td><td>最近的确认时间戳，用于 RTT 计算。</td></tr><tr class="even"><td><code>ssthresh</code></td><td>拥塞避免的慢启动阈值。</td></tr><tr class="odd"><td><code>rx_rttval</code></td><td>RTT 的偏差，用于计算 RTT 的波动。</td></tr><tr class="even"><td><code>rx_srtt</code></td><td>平滑的 RTT 值，用于计算平均 RTT。</td></tr><tr class="odd"><td><code>rx_rto</code></td><td>重新传输超时时间，根据 RTT 动态调整。</td></tr><tr class="even"><td><code>rx_minrto</code></td><td>最小的重新传输超时时间。</td></tr><tr class="odd"><td><code>snd_wnd</code></td><td>发送窗口大小，控制发送流量的窗口。</td></tr><tr class="even"><td><code>rcv_wnd</code></td><td>接收窗口大小，控制接收流量的窗口。</td></tr><tr class="odd"><td><code>rmt_wnd</code></td><td>远端窗口大小，表示对方接收窗口的大小。</td></tr><tr class="even"><td><code>cwnd</code></td><td>拥塞窗口大小，控制发送流量的窗口，用于拥塞控制。</td></tr><tr class="odd"><td><code>probe</code></td><td>探测标志，表示是否需要进行窗口探测。</td></tr><tr class="even"><td><code>current</code></td><td>当前的时间戳。</td></tr><tr class="odd"><td><code>interval</code></td><td>刷新间隔时间，表示定期刷新 KCP 状态的间隔。</td></tr><tr class="even"><td><code>ts_flush</code></td><td>下次刷新时间戳，用于确定何时执行下一次状态刷新。</td></tr><tr class="odd"><td><code>xmit</code></td><td>发送次数，表示数据包重传的次数。</td></tr><tr class="even"><td><code>nrcv_buf</code></td><td>接收缓冲区的数据包数量。</td></tr><tr class="odd"><td><code>nsnd_buf</code></td><td>发送缓冲区的数据包数量。</td></tr><tr class="even"><td><code>nrcv_que</code></td><td>接收队列中的数据包数量。</td></tr><tr class="odd"><td><code>nsnd_que</code></td><td>发送队列中的数据包数量。</td></tr><tr class="even"><td><code>nodelay</code></td><td>延迟模式标志，表示是否启用无延迟模式。</td></tr><tr class="odd"><td><code>updated</code></td><td>更新标志，表示是否需要更新 KCP 状态。</td></tr><tr class="even"><td><code>ts_probe</code></td><td>下次探测时间戳，用于窗口探测。</td></tr><tr class="odd"><td><code>probe_wait</code></td><td>探测等待时间，表示等待多长时间后进行下一次窗口探测。</td></tr><tr class="even"><td><code>dead_link</code></td><td>死链标志，表示连接是否已经失效。</td></tr><tr class="odd"><td><code>incr</code></td><td>增量，用于控制流量的增加速率。</td></tr><tr class="even"><td><code>snd_queue</code></td><td>发送队列，用于存储待发送的数据包。</td></tr><tr class="odd"><td><code>rcv_queue</code></td><td>接收队列，用于存储待处理的数据包。</td></tr><tr class="even"><td><code>snd_buf</code></td><td>发送缓冲区，用于存储已经发送但未确认的数据包。</td></tr><tr class="odd"><td><code>rcv_buf</code></td><td>接收缓冲区，用于存储已经接收到但未处理的数据包。</td></tr><tr class="even"><td><code>acklist</code></td><td>确认列表，用于存储待发送的确认序号。</td></tr><tr class="odd"><td><code>ackcount</code></td><td>确认计数，表示确认列表中的条目数量。</td></tr><tr class="even"><td><code>ackblock</code></td><td>确认块大小，表示确认列表的内存分配大小。</td></tr><tr class="odd"><td><code>user</code></td><td>用户数据指针，用于存储用户自定义的数据。</td></tr><tr class="even"><td><code>buffer</code></td><td>缓冲区，用于临时存储发送的数据。</td></tr><tr class="odd"><td><code>fastresend</code></td><td>快速重传标志，表示启用快速重传功能。</td></tr><tr class="even"><td><code>fastlimit</code></td><td>快速重传限制，表示在一个 RTT 内允许的最大重传次数。</td></tr><tr class="odd"><td><code>nocwnd</code></td><td>无拥塞窗口控制标志，表示是否禁用拥塞窗口控制。</td></tr><tr class="even"><td><code>stream</code></td><td>流模式标志，表示是否启用流模式。</td></tr><tr class="odd"><td><code>logmask</code></td><td>日志掩码，用于控制日志输出的级别。</td></tr><tr class="even"><td><code>output</code></td><td>发送数据回调函数，用于发送数据。</td></tr><tr class="odd"><td><code>writelog</code></td><td>日志回调函数，用于输出日志。</td></tr></tbody></table><h2 id="队列和缓冲区">队列和缓冲区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPCB</span></span><br><span class="hljs-class">&#123;</span><br>  ...<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_buf</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_buf</span>;</span><br>  ...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">prev</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>KCP中队列和缓冲区都是循环双链表，链表由宏实现，笔者并不擅长，所以本文就不探讨该链表的实现了，有数据结构基础的笔者应该很好理解这一块。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612175626865.png"alt="队列和缓冲区的实现：循环双链表" /><figcaptionaria-hidden="true">队列和缓冲区的实现：循环双链表</figcaption></figure><p>队列和缓冲区是 KCP最核心的部分，它们的作用流程大概如下图所示，读者可以自行阅读尝试理解，后续我们会进行详细的分析。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612175950432.png"alt="KCP 队列和缓冲区作用流程" /><figcaption aria-hidden="true">KCP 队列和缓冲区作用流程</figcaption></figure><h1 id="原理分析">原理分析</h1><p>这一节我们详细讨论 KCP 的整个 ARQ流程。首先我们会对整体流程进行简要概述，然后详细讨论滑动窗口中的发送和接收过程，接着讨论超时重传和快速重传，在这之后我们会将KCP 和 TCP 的重传策略进行简单对比，最后介绍一下拥塞控制策略。</p><h2 id="整体流程">1. 整体流程</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612192523848.png"alt="KCP 全流程" /><figcaption aria-hidden="true">KCP 全流程</figcaption></figure><p>KCP 的全流程如上图所示：</p><ol type="1"><li>发送方调用 <code>ikcp_send</code>将发送数据，这个时候会创建报文段实例，并放入 <code>snd_queue</code>发送队列中。</li><li>KCP 会定时调用 <code>ikcp_update</code> 判断是否要调用<code>ikcp_flush</code>。</li><li>调用 <code>ikcp_flush</code> 时会将合适的报文段放入<code>snd_buf</code> 缓冲区中，具体包括：<ol type="1"><li>发送 ACK 列表中所有 ACK；</li><li>根据是否需要发送窗口探测和通知报文，需要则发；</li><li>根据发送窗口大小，将适量的报文段从 <code>snd_queue</code> 移入<code>snd_buf</code> 中；</li><li>发送 <code>snd_buf</code>中的报文，包括<strong>新加入的</strong>、<strong>RTO 内未收到ACK</strong> 的和 <strong>ACK 失序若干次</strong>的；</li><li>根据丢包情况计算 <code>ssthresh</code> 和 <code>cwnd</code>。</li></ol></li><li>发送的时候会调用由 <code>ikcp_setoutput</code>设置的回调函数，将数据发送到对端。</li><li>接收方收到数据后，会调用 <code>ikcp_input</code>，将数据放入<code>rcv_buf</code> 缓冲区，具体包括：<ol type="1"><li>根据所有报文的 una 将相应的报文标记为已送达；</li><li>如果是 ACK，就将相应的报文标记为已送达；</li><li>如果是数据报文，就将它放入 <code>rcv_buf</code>，然后将<code>rcv_buf</code> 中顺序正确的报文移入 <code>rcv_queue</code>接收队列中，接着将相关信息插入 ACK 列表，在稍后的<code>ikcp_flush</code> 中会发送相应的 ACK；</li><li>如果是窗口探测报文，就标记“需要发送窗口通知”，在稍后的<code>ikcp_flush</code> 中会发送窗口通知报文；</li><li>包括窗口通知报文在内的所有报文都有 wnd 字段，据此更新 rmt_wnd；</li><li>根据 ACK 失序情况决定是否进行快速重传；</li><li>计算 cwnd。</li></ol></li><li>调用 <code>ikcp_recv</code> 从 <code>rcv_queue</code>中接收数据。</li></ol><h2 id="滑动窗口">2. 滑动窗口</h2><p>发送缓冲区 <code>snd_buf</code> 和接收缓冲区 <code>rcv_buf</code>中活动的报文都是在滑动窗口之中的。这对于我们理解 KCP的发送和接收流程非常重要，所有我们先从滑动窗口开始介绍。</p><p>滑动窗口实际是一个抽象的概念,不能简单地认为它是缓冲区的一部分，准确的说，滑动窗口是由队列加缓冲区共同组成的。</p><h3 id="发送">2.1 发送</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612193023604.png"alt="发送窗口" /><figcaption aria-hidden="true">发送窗口</figcaption></figure><p><code>snd_una</code> 和 <code>snd_nxt</code>会努力往<strong>右</strong>移动：</p><ol type="1"><li><code>ikcp_flush</code> 时，会从 <code>snd_queue</code>中取出报文插入到 <code>snd_nxt</code> 的位置上；</li><li>如果<code>snd_nxt - snd_una &gt;= cwnd</code>，则不允许新的报文插入；</li><li>当 <code>snd_una</code> 的 ACK 报文到达时，<code>snd_una</code>就会右移到第一个没有收到 ACK 报文的位置；</li></ol><p>发送窗口中未确认到达的报文何时重传？</p><ul><li>报文在一个 RTO 时间内仍未确认到达，就会重传。报文 RTO 初始值是rx_rto ，会持续增长，速率支持配置。</li></ul><h3 id="接收">2.2 接收</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612193238859.png"alt="接收窗口" /><figcaption aria-hidden="true">接收窗口</figcaption></figure><ol type="1"><li>每收到一个数据报文, 都会根据它的编号将它插入到 <code>rcv_buf</code>对应的位置中；</li><li>接着检查 <code>rcv_nxt</code> 能否向右移动,只有当报文的顺序正确且连续才能移动；</li><li>在上图的例子中由于 4 号报文的缺失, <code>rcv_nxt</code> 只能处于 4号位置等待，5, 6 号报文也不能移动到 <code>rcv_queue</code> 中；</li><li>等到 4 号报文到达后，才能将 4, 5, 6 号报文一并移动到<code>rcv_queue</code> 中，同时 <code>rcv_nxt</code> 会右移到 7号位置。</li></ol><h3 id="案例分析">2.3 案例分析</h3><p>我们举个简单的例子演示整个 ARQ的流程。下图中实线箭头表示数据报文，虚线箭头表示 ACK。</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/kcp_5.svg"alt="KCP ARQ 流程" /><figcaption aria-hidden="true">KCP ARQ 流程</figcaption></figure><p>① t1 时刻发送方发送 1 号报文, 1 号报文放入发送缓冲区中, snd_una 指向1, snd_nxt 指向 2.</p><p>② t2 至 t3 时刻发送方依次发送 2 至 3 号报文, snd_nxt 依次后移.</p><p>③ 1 号报文丢包.</p><p>④ t4, t5 时刻接收方收到 3 号和 2 号报文, 放入 rcv_buf 中; 随后回复 3号和 2 号 ACK. 此时由于 1 号报文缺失, rcv_nxt 始终指向 1.</p><p>⑤ 3 号 ACK 丢包.</p><p>⑥ t7 时刻发送方收到 2 号 ACK, 将 2 号报文标记为已送达. 此时由于 3 号ACK 丢包, 3 号报文未标记为已送达. 由于 1 号报文未确认送达, snd_una亦指向 1.</p><p>⑦ t8 时刻 1 号报文超时, 重传.</p><p>⑧ t9 时刻接收方收到 1 号报文, 放入 rcv_buf 中; 这时 1, 2, 3号报文顺序正确, rcv_nxt 右移到 4 号位置. 接收方回复 1 号 ACK, 同时带上una = 4.</p><p>⑨ t10 时刻发送方收到 1 号 ACK, 将 1 号报文标记为已送达. 同时 una 表明1, 2, 3 号报文均已送达, 因此也将 3 号报文标记为已送达. snd_una 移动到4.</p><h2 id="超时重传">3. 超时重传</h2><p>超时重传是当发送的数据包在预定时间内未被确认时，重新发送该数据包的机制。在KCP 中，这个时间由重新传输超时（RTO）决定。KCP 计算 RTO 初始值的方法是TCP 的标准方法, 规定在 <ahref="https://www.rfc-editor.org/rfc/rfc6298.html">RFC 6298</a> 中。</p><p>这里还是贴出源码讲比较直观：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_update_ack</span><span class="hljs-params">(ikcpcb *kcp, IINT32 rtt)</span><br>&#123;<br>IINT32 rto = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (kcp-&gt;rx_srtt == <span class="hljs-number">0</span>) &#123;<br>kcp-&gt;rx_srtt = rtt;<br>kcp-&gt;rx_rttval = rtt / <span class="hljs-number">2</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">long</span> delta = rtt - kcp-&gt;rx_srtt;<br><span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>) delta = -delta;<br>kcp-&gt;rx_rttval = (<span class="hljs-number">3</span> * kcp-&gt;rx_rttval + delta) / <span class="hljs-number">4</span>;<br>kcp-&gt;rx_srtt = (<span class="hljs-number">7</span> * kcp-&gt;rx_srtt + rtt) / <span class="hljs-number">8</span>;<br><span class="hljs-keyword">if</span> (kcp-&gt;rx_srtt &lt; <span class="hljs-number">1</span>) kcp-&gt;rx_srtt = <span class="hljs-number">1</span>;<br>&#125;<br>rto = kcp-&gt;rx_srtt + _imax_(kcp-&gt;interval, <span class="hljs-number">4</span> * kcp-&gt;rx_rttval);<br>kcp-&gt;rx_rto = _ibound_(kcp-&gt;rx_minrto, rto, IKCP_RTO_MAX);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个计算过程笔者就不做详细介绍了，代码里面的公式读者可以尝试自行画图进行理解，这里就不花大篇幅画公式了，下面我尝试以更通俗易懂的话语解释RTO，只需要理解它在做什么，为什么这么做，就可以了，个人觉得对公式的细节可以暂且忽略。</p><h3 id="rto-计算目的">3.1 RTO 计算目的</h3><p>KCP 的 RTO计算是为了确定在多长时间内未收到确认（ACK）时，应该重新发送数据包。这段时间被称为重传超时时间（RTO）。计算RTO的目的是在网络条件变化的情况下，既能快速响应数据丢失，也能避免不必要的重传，从而保持高效的传输。</p><h3 id="rto-计算涉及的变量解释">3.2 RTO 计算涉及的变量解释</h3><p><strong>RTT 和 SRTT 的概念:</strong></p><ul><li>RTT（Round-Trip Time）:是从发送一个数据包到收到其确认（ACK）所花的时间。</li><li>SRTT（Smoothed RTT）: 是 RTT 的加权平均值，它代表了 RTT的一个更稳定的估计值。SRTT 的目的是减少 RTT 的短期波动对 RTO的影响。</li></ul><p><strong>RTT 变化值（RTTvariance）</strong>：网络传输时间并不总是固定的，有时会因为网络拥塞或其他原因出现波动。我们通过计算RTT 变化值（RTT variance）来估计这种波动的大小。</p><p><strong>为什么需要 SRTT 和 RTT 变化值：</strong></p><ul><li>SRTT 给我们一个平均的 RTT 估计值。</li><li>RTT 变化值告诉我们网络的波动性。如果波动很大，我们希望 RTO更大，以免因为短暂的网络延迟就触发不必要的重传。</li></ul><h3 id="rto-计算步骤">3.3 RTO 计算步骤</h3><p><strong>1. 初始化</strong>：初次计算时，我们没有历史 RTT值，所以直接用第一次测量的 RTT 来初始化 SRTT，并将 RTT 变化值设为 RTT的一半。</p><p><strong>2. 更新 SRTT 和 RTT 变化值</strong>:</p><ul><li>每次我们测量新的 RTT，就用它来更新 SRTT 和 RTT 变化值。</li><li>更新 SRTT：我们不直接替换旧的SRTT，而是用一个平滑的方式（即加权平均），使得 SRTT 逐渐靠近新RTT，但又不会剧烈变化。</li><li>更新 RTT 变化值：计算新的 RTT 与 SRTT 的差值，用这个差值来更新 RTT变化值，使其反映当前网络波动的大小。</li></ul><p><strong>3. 计算 RTO</strong>:</p><ul><li>用 SRTT 加上四倍的 RTT 变化值来计算 RTO，这样可以确保 RTO足够长，能涵盖大部分的网络波动。</li><li>我们还要确保 RTO 不小于一个最小值（<code>rx_minrto</code>），以防止RTO过小导致频繁重传；也不能大于一个最大值（<code>IKCP_RTO_MAX</code>），以防止RTO 过大影响响应速度。</li></ul><h3 id="rto-计算效果">4. RTO 计算效果</h3><ul><li><strong>稳定的传输</strong>: SRTT 提供了一个稳定的平均 RTT估计，使得 RTO 能适应网络的长期变化。</li><li><strong>适应网络波动</strong>: RTT 变化值使得 RTO能够应对网络的短期波动，减少因短暂延迟而导致的重传。</li><li><strong>快速响应</strong>: RTO设置合理后，能够在数据丢失时快速重传，保持传输的高效和及时性。</li></ul><p>通过这样的计算方式，KCP能够在不同的网络条件下，自动调整重传策略，从而在保证数据可靠性的同时，保持较高的传输效率。</p><h2 id="快速重传">4. 快速重传</h2><p>在网络传输中，数据包可能会由于网络拥塞、丢包等原因而丢失。超时重传依赖于重传超时时间（RTO）来判断是否需要重传，这可能会导致响应延迟。而快速重传通过检测重复的确认包（ACK）来快速判断数据包的丢失，并立即触发重传，显著缩短了数据丢失的恢复时间。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612200038895.png"alt="KCP 快速重传" /><figcaption aria-hidden="true">KCP 快速重传</figcaption></figure><h3 id="何时快速重传">4.1 何时快速重传？</h3><ul><li>每个报文的 <code>fastack</code> 记录了它检测到 ACK 失序的次数，每当KCP 收到一个编号为 sn 的 ACK 时，就会检查 snd_buf 中编号小于 sn且未确认送达的报文，并将其 <code>fastack</code> 加 1。</li><li>可以通过配置 <code>fastresend</code>指定失序多少次就执行快速重传。</li><li>每次调用 ikcp_flush 都会重传 snd_buf 中<code>fastask &gt;= fastresend</code> 的报文。</li></ul><h3 id="无限快速重传吗">4.2 无限快速重传吗？</h3><ul><li>每个报文的 <code>xmit</code> 记录它被传输的次数，可以配置<code>fastlimit</code> 规定传输次数小于 <code>fastlimit</code>的报文才能执行快速重传。</li></ul><h2 id="比较-tcp-的超时重传和快速重传">5. 比较 TCP的超时重传和快速重传</h2><p>TCP 也实现了类似的机制，但在复杂性和应用场景上有所不同。</p><h3 id="tcp-的超时重传">5.1 TCP 的超时重传</h3><p><strong>1. RTT 估算</strong>:</p><ul><li><p>TCP 通过接收确认包来估算 RTT，并使用 RTT 的变化范围来计算RTO。</p></li><li><p>TCP 使用 Jacobson/Karels 算法进行 RTT 估算和 RTO 计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// SRTT and RTTVAR calculation</span><br>RTTVAR = (<span class="hljs-number">1</span> - β) * RTTVAR + β * |RTTsample - SRTT|<br>SRTT = (<span class="hljs-number">1</span> - α) * SRTT + α * RTTsample<br>RTO = SRTT + <span class="hljs-number">4</span> * RTTVAR<br></code></pre></td></tr></table></figure><p>其中，SRTT 是平滑的 RTT，RTTVAR 是 RTT 的变化范围，α 和 β是权重因子。</p></li></ul><p><strong>2. 重传策略</strong>:</p><ul><li>如果在 RTO 时间内未收到 ACK，TCP 会重传未确认的数据包。</li><li>每次重传，RTO 值会按照指数增长（指数退避算法）。</li></ul><p><strong>3. 拥塞控制</strong>:</p><ul><li>TCP使用复杂的拥塞控制机制，如慢启动、拥塞避免等，来调整发送窗口和传输速率。</li></ul><h3 id="tcp-的快速重传">5.2 TCP 的快速重传</h3><ul><li>当接收到三个重复的 ACK 时，TCP 会立即重传丢失的数据包，而不等待 RTO超时。</li><li>快速重传后，TCP进入快速恢复状态，调整拥塞窗口，避免拥塞窗口过度收缩。</li></ul><h3 id="比较分析">5.3 比较分析</h3><table><thead><tr class="header"><th>特性</th><th>KCP</th><th>TCP</th></tr></thead><tbody><tr class="odd"><td><strong>RTT 估算</strong></td><td>基于加权移动平均，较为简单</td><td>使用 Jacobson/Karels 算法，复杂但精确</td></tr><tr class="even"><td><strong>RTO 计算</strong></td><td>简化的计算公式</td><td>基于 RTT 的复杂计算</td></tr><tr class="odd"><td><strong>重传机制</strong></td><td>超时重传和快速重传</td><td>超时重传和快速重传</td></tr><tr class="even"><td><strong>拥塞控制</strong></td><td>简单的拥塞控制，适合低延迟应用</td><td>复杂的拥塞控制，适合广泛的传输场景</td></tr><tr class="odd"><td><strong>适用场景</strong></td><td>实时应用，如游戏、视频会议</td><td>通用应用，如文件传输、HTTP</td></tr><tr class="even"><td><strong>实现复杂度</strong></td><td>较为简单，易于理解和实现</td><td>复杂，需处理更多的网络状态和控制</td></tr><tr class="odd"><td><strong>可靠性</strong></td><td>依赖于用户自定义的重传和控制策略</td><td>内置可靠性和流控制机制</td></tr><tr class="even"><td><strong>响应速度</strong></td><td>高效快速，适用于低延迟和高吞吐量场景</td><td>可靠但响应速度较慢，适合稳定传输场景</td></tr></tbody></table><p>KCP 和 TCP 都提供了可靠的传输机制，但它们适用于不同的应用场景。KCP设计简单，适合对延迟敏感的实时应用，而 TCP拥有完善的拥塞控制和可靠性机制，适合广泛的网络应用。</p><h2 id="拥塞控制">6. 拥塞控制</h2><p>拥塞控制是网络传输协议中的一个重要机制，用于防止发送过多的数据包导致网络拥塞。在KCP中，拥塞控制相对简单，主要通过发送窗口（<code>snd_wnd</code>）和拥塞窗口（<code>cwnd</code>）来管理数据发送速率。</p><h3 id="三种策略">6.1 三种策略</h3><p>KCP 有 3 种拥塞控制的策略：</p><ul><li>慢启动（slow start）</li><li>拥塞避免（congestion avoidance）</li><li>快速恢复（fast recovery）</li></ul><p><strong>慢启动</strong>：先将 cwnd 设置为 1，随后平均每经过一个 RTT时间，<code>cwnd = cwnd * 2</code>，直到阈值 <code>ssthresh</code>。</p><p><strong>拥塞避免</strong>：cwnd 到 <code>ssthresh</code> 后，cwnd呈<strong>线性</strong>增长。</p><p>当慢启动或者拥塞避免造成 <strong>丢包</strong>后，就采取相应的退让策略：</p><ol type="1"><li><code>fastack &gt;= fastresend</code> -&gt; 发生快速重传：将<code>ssthresh = cwnd / 2</code>，<code>cwnd = ssthresh + fastresend</code>进入<strong>快恢复</strong>。</li><li><code>current &gt;= resentts</code> -&gt;超时重传：<code>ssthresh = ssthresh / 2</code>，<code>cwnd = 1</code>，进入<strong>慢启动</strong>。</li></ol><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/kcp_7.svg"alt="拥塞控制中 cwnd 和 ssthresh 的变化情况" /><figcaption aria-hidden="true">拥塞控制中 cwnd 和 ssthresh的变化情况</figcaption></figure><h3 id="核心概念">6.2 核心概念</h3><p>KCP 的拥塞控制基于以下几个核心概念：</p><ul><li><strong>发送窗口(<code>snd_wnd</code>)</strong>：表示发送端在未收到接收端确认之前，允许发送的数据包的数量。它类似于TCP 中的发送窗口，控制了数据流的速率。</li><li><strong>接收窗口(<code>rcv_wnd</code>)</strong>：表示接收端能够处理的最大数据包数量。发送端通过接收端的窗口大小来调整自己的发送速率。</li><li><strong>远端窗口(<code>rmt_wnd</code>)</strong>：表示接收端的窗口大小，发送端会根据这个值调整自己的发送窗口，以避免发送的数据超出接收端的处理能力。</li><li><strong>拥塞窗口(<code>cwnd</code>)</strong>：用于控制传输中的数据包数量。它基于网络的拥塞情况动态调整，以避免网络拥塞。</li><li><strong>慢启动阈值(<code>ssthresh</code>)</strong>：用于确定拥塞控制的模式。当<code>cwnd</code> 小于 <code>ssthresh</code> 时，KCP处于慢启动模式，否则进入拥塞避免模式。</li></ul><h3 id="窗口探测window-probing">6.3 窗口探测（Window Probing）</h3><p>在某些情况下，接收端的窗口可能会被关闭（即 <code>rmt_wnd</code> 为0），这意味着接收端无法接收任何新的数据。为了应对这种情况，KCP实现了窗口探测机制：</p><ul><li>当 <code>rmt_wnd</code> 为 0 时，KCP不会立即停止发送数据，而是会定期发送一个探测包，以检测接收端窗口是否已经打开。</li><li>这个探测包会触发接收端返回一个ACK，其中包含最新的接收窗口大小信息。</li></ul><h3 id="调节和配置">6.4 调节和配置</h3><p>KCP的拥塞控制机制提供了一些配置参数，用户可以通过调整这些参数来优化传输性能：</p><ul><li><strong><code>snd_wnd</code></strong>:发送窗口大小，用户可以根据应用的需求调整该值，以控制数据发送的最大量。</li><li><strong><code>rcv_wnd</code></strong>:接收窗口大小，表示接收端能够处理的最大数据包数量。</li><li><strong><code>ssthresh</code></strong>:慢启动阈值，初始值通常设置为较大的一个常量，用户可以根据网络情况调整。</li><li><strong><code>cwnd</code></strong>: 拥塞窗口大小，初始值通常设置为1，随传输情况动态调整。</li></ul><h2 id="比较-tcp-的拥塞控制">7. 比较 TCP 的拥塞控制</h2><h3 id="四个阶段">7.1 四个阶段</h3><p>TCP 拥塞控制有四个关键阶段</p><p><strong>慢启动（Slow Start）</strong>：</p><ul><li><strong>目的</strong>：快速探测网络的可用带宽。</li><li><strong>机制</strong>：当一个连接刚建立或者从丢包恢复时，<code>cwnd</code>（拥塞窗口）从一个较小的值（通常是1 个 MSS，即最大报文段大小）开始，并以指数增长的方式增加。</li><li><strong>过程</strong>：每次收到一个 ACK，<code>cwnd</code> 增加一个MSS，使得 <code>cwnd</code> 每 RTT 增加一倍，直到 <code>cwnd</code>达到慢启动阈值（<code>ssthresh</code>）。</li></ul><p><strong>拥塞避免（Congestion Avoidance）</strong>:</p><ul><li><strong>目的</strong>：逐步探测网络的最大容量，并避免拥塞。</li><li><strong>机制</strong>：当 <code>cwnd</code> 达到或超过<code>ssthresh</code> 时，TCP 进入拥塞避免阶段，此时 <code>cwnd</code>以线性增长的方式增加。</li><li><strong>过程</strong>：每个 RTT，<code>cwnd</code> 增加<code>1/cwnd</code> 个MSS，这种增长方式较为保守，旨在防止过度发送导致的拥塞。</li></ul><p><strong>快速重传（Fast Retransmit）</strong>:</p><ul><li><strong>目的</strong>：快速响应丢包，提高传输效率。</li><li><strong>机制</strong>：当发送端收到三个重复的 ACK时，立即重传被确认丢失的数据包，而不等待 RTO 超时。</li><li><strong>过程</strong>：快速重传的目的是迅速恢复丢失的数据包，从而减少因丢包导致的等待时间。</li></ul><p><strong>快速恢复（Fast Recovery）</strong>:</p><ul><li><strong>目的</strong>：在拥塞后快速恢复到适当的传输速率。</li><li><strong>机制</strong>：在快速重传后，TCP不会直接进入慢启动，而是保持 <code>cwnd</code>的一部分，以较快的速度恢复到拥塞避免状态。</li><li><strong>过程</strong>：将 <code>ssthresh</code> 设置为当前<code>cwnd</code> 的一半，<code>cwnd</code> 被临时减小，然后在接收新 ACK时快速增加 <code>cwnd</code>，直到恢复到 <code>ssthresh</code>为止。</li></ul><h3 id="比较分析-1">7.2 比较分析</h3><table><thead><tr class="header"><th>特性</th><th>TCP</th><th>KCP</th></tr></thead><tbody><tr class="odd"><td><strong>实现复杂度</strong></td><td>复杂，包含多个阶段和算法</td><td>简单，主要通过窗口大小控制</td></tr><tr class="even"><td><strong>拥塞检测</strong></td><td>通过 RTT 估算和 ACK 检测丢包</td><td>主要通过 ACK 和窗口大小检测丢包</td></tr><tr class="odd"><td><strong>响应速度</strong></td><td>响应相对较慢，适合稳定传输</td><td>响应较快，适合实时性高的传输</td></tr><tr class="even"><td><strong>适应性</strong></td><td>能适应广泛的网络条件</td><td>适应性较好，但更适合低延迟网络</td></tr><tr class="odd"><td><strong>配置灵活性</strong></td><td>较为固定，依赖于系统配置和优化</td><td>提供更多的配置选项，用户可根据需求调整</td></tr><tr class="even"><td><strong>应用场景</strong></td><td>适用于各种需要可靠传输的应用</td><td>适用于实时性要求高的应用，如游戏和视频会议</td></tr><tr class="odd"><td><strong>窗口调整</strong></td><td>慢启动、拥塞避免、快速重传、快速恢复等机制</td><td>主要通过发送窗口和拥塞窗口调整</td></tr><tr class="even"><td><strong>丢包响应</strong></td><td>丢包时通过减小 <code>cwnd</code> 和 <code>ssthresh</code>来调整</td><td>丢包时迅速调整 <code>cwnd</code> 和重传</td></tr><tr class="odd"><td><strong>拥塞控制策略</strong></td><td>慢启动、拥塞避免、快速重传、快速恢复等多种策略</td><td>主要通过调整 <code>cwnd</code> 和 <code>ssthresh</code>进行简单控制</td></tr><tr class="even"><td><strong>优点</strong></td><td>稳定可靠、机制全面、应用广泛</td><td>实现简单、响应快、灵活性高、适合实时应用</td></tr><tr class="odd"><td><strong>缺点</strong></td><td>复杂、响应慢、初始阶段保守</td><td>无法应对更加复杂的网络状况、应用场景有限</td></tr></tbody></table><p>TCP 和 KCP 都有各自的拥塞控制机制，适用于不同的应用场景。TCP提供了复杂而全面的拥塞控制，适合于各种网络条件下的可靠传输，而 KCP提供了简单高效的控制机制，适合于低延迟和高响应速度的实时应用。选择使用哪种协议取决于具体的应用需求和网络环境。</p><h1 id="源码分析">源码分析</h1><h1 id="材料">材料</h1><ul><li>excalidraw 分析文件：</li></ul><h1 id="参考">参考</h1><ul><li><a href="https://github.com/skywind3000/kcp">KCP repo</a></li><li><a href="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP协议的原理和实现</a></li></ul>]]></content>
    
    
    <summary type="html">本文将详细介绍游戏开发中场景的网络协议 KCP 的底层原理，并提供源码分析。文中包含大量的图示和原理总结，以帮助读者更好地理解 KCP 协议的工作原理。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="KCP" scheme="https://hedon.top/tags/KCP/"/>
    
    <category term="TCP" scheme="https://hedon.top/tags/TCP/"/>
    
    <category term="网络" scheme="https://hedon.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨SSE(Server-Sent Events)</title>
    <link href="https://hedon.top/2024/06/06/rust-action-sse/"/>
    <id>https://hedon.top/2024/06/06/rust-action-sse/</id>
    <published>2024-06-06T13:30:51.000Z</published>
    <updated>2024-06-06T13:40:05.329Z</updated>
    
    <content type="html"><![CDATA[<p>📌 SSE（Server-SentEvents）是一种允许服务器向客户端浏览器推送信息的技术。它是 HTML5的一部分，专门用于建立一个单向的从服务器到客户端的通信连接。SSE的使用场景非常广泛，包括实时消息推送、实时通知更新等。</p><h1 id="sse-的本质">SSE 的本质</h1><p>严格地说，<ahref="https://en.wikipedia.org/wiki/HTTP">HTTP</a>无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息（streaming）。</p><p>也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。本质上，这种通信就是以流信息的方式，完成一次用时很长的下载。</p><p>SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 HTTP协议，目前除了 IE/Edge，其他浏览器都支持。</p><h1 id="特点">特点</h1><ol type="1"><li><strong>持续连接</strong>：与传统的 HTTP 请求不同，SSE保持连接开放，服务器可以随时发送消息。</li><li><strong>文本数据流</strong>：SSE主要传输文本数据，这些数据以特定的格式流式传输，使得每条消息都是简单的文本格式。</li><li><strong>内置重连机制</strong>：浏览器会自动处理连接中断和重连，包括在重连请求中发送最后接收的事件ID，以便服务器从正确的位置恢复发送事件。</li><li><strong>简单的客户端处理</strong>：在浏览器中，使用 JavaScript 的<code>EventSource</code> 接口处理 SSE非常简单，只需几行代码即可监听服务器发来的事件。</li></ol><h1 id="工作原理">工作原理</h1><ol type="1"><li><strong>建立连接</strong>：客户端通过创建一个<code>EventSource</code> 对象请求特定的 URL 来启动 SSE连接。这个请求是一个标准的 HTTP请求，但会要求服务器以特定方式响应。</li><li><strong>服务器响应</strong>：服务器响应必须设置<code>Content-Type</code> 为<code>text/event-stream</code>，然后保持连接打开。</li><li><strong>发送消息</strong>：服务器可以通过持续发送数据格式为特定事件流的消息来推送更新。每个消息包括一个可选的事件类型、数据和一个可选的ID。<ul><li><strong>数据</strong>：实际的消息内容，以 <code>data:</code>开头，多行数据以双换行符 <code>\n\n</code> 结束。</li><li><strong>事件类型</strong>：允许客户端根据事件类型来监听，以<code>event:</code> 开头。</li><li><strong>ID</strong>：如果连接中断，客户端将发送包含上次接收的最后一个ID的<code>Last-Event-ID</code> 头，以便服务器从断点继续发送数据。</li></ul></li></ol><h1 id="实战">实战</h1><h2 id="客户端">客户端</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>SSE Test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Server-Sent Events Test<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;events&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 确保这里的URL匹配你的服务器地址和端口</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&#x27;http://localhost:8000/events&#x27;</span>);</span><br><span class="language-javascript">    eventSource.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;New event:&#x27;</span>, event.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;events&#x27;</span>).<span class="hljs-property">innerHTML</span> += event.<span class="hljs-property">data</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="rust-服务端">Rust 服务端</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/20240606213652.gif"alt="Rust 实现演示" /><figcaption aria-hidden="true">Rust 实现演示</figcaption></figure><p>依赖：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-attr">anyhow</span> = <span class="hljs-string">&quot;1.0.86&quot;</span><br><span class="hljs-attr">axum</span> = &#123; version = <span class="hljs-string">&quot;0.7.5&quot;</span> &#125;<br><span class="hljs-attr">chrono</span> = <span class="hljs-string">&quot;0.4.38&quot;</span><br><span class="hljs-attr">futures-core</span> = <span class="hljs-string">&quot;0.3.30&quot;</span><br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1.38.0&quot;</span>, features = [<span class="hljs-string">&quot;macros&quot;</span>, <span class="hljs-string">&quot;rt-multi-thread&quot;</span>, ] &#125;<br><span class="hljs-attr">tokio-stream</span> = <span class="hljs-string">&quot;0.1.15&quot;</span><br><span class="hljs-attr">tower-http</span> = &#123; version = <span class="hljs-string">&quot;0.5.2&quot;</span>, features = [<span class="hljs-string">&quot;cors&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">use</span> axum::&#123;<br>    response::&#123;sse::Event, Sse&#125;,<br>    routing::get,<br>    Router,<br>&#125;;<br><span class="hljs-keyword">use</span> tokio::&#123;net::TcpListener, time::interval&#125;;<br><span class="hljs-keyword">use</span> tokio_stream::&#123;wrappers::IntervalStream, StreamExt&#125;;<br><span class="hljs-keyword">use</span> tower_http::cors::&#123;Any, CorsLayer&#125;;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cors</span> = CorsLayer::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">allow_headers</span>(Any)<br>        .<span class="hljs-title function_ invoke__">allow_origin</span>(Any)<br>        .<span class="hljs-title function_ invoke__">allow_headers</span>(Any)<br>        .<span class="hljs-title function_ invoke__">allow_credentials</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;0.0.0.0:8000&quot;</span>).<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Router::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/events&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(sse_handler)).<span class="hljs-title function_ invoke__">layer</span>(cors);<br>    axum::<span class="hljs-title function_ invoke__">serve</span>(listener, app).<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sse_handler</span>() <span class="hljs-punctuation">-&gt;</span> Sse&lt;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">futures_core</span>::Stream&lt;Item = <span class="hljs-type">Result</span>&lt;Event, axum::Error&gt;&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">interval</span> = <span class="hljs-title function_ invoke__">interval</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = IntervalStream::<span class="hljs-title function_ invoke__">new</span>(interval).<span class="hljs-title function_ invoke__">map</span>(|_| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">data</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;\n\n&quot;</span>, chrono::Local::<span class="hljs-title function_ invoke__">now</span>().<span class="hljs-title function_ invoke__">to_rfc2822</span>());<br>        <span class="hljs-title function_ invoke__">Ok</span>(Event::<span class="hljs-title function_ invoke__">default</span>().<span class="hljs-title function_ invoke__">data</span>(data))<br>    &#125;);<br><br>    Sse::<span class="hljs-title function_ invoke__">new</span>(stream)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="go-服务端">Go 服务端</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/20240606195749.gif"alt="Go 实现演示" /><figcaption aria-hidden="true">Go 实现演示</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sseHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 设置头部信息，确保允许跨域，并且告诉浏览器这是一个事件流</span><br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/event-stream&quot;</span>)<br>w.Header().Set(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>)<br>w.Header().Set(<span class="hljs-string">&quot;Connection&quot;</span>, <span class="hljs-string">&quot;keep-alive&quot;</span>)<br>w.Header().Set(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)<br><br><span class="hljs-comment">// 不断发送消息</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 生成服务器时间，并发送给客户端</span><br>now := time.Now()<br><span class="hljs-comment">// 生成消息，格式为 data: &#123;content&#125; \n\n</span><br>msg := fmt.Sprintf(<span class="hljs-string">&quot;data: %s\n\n&quot;</span>, now.Format(time.DateTime))<br><span class="hljs-comment">// 发送消息</span><br><span class="hljs-keyword">if</span> _, err := fmt.Fprintf(w, msg); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;write error:&quot;</span>, err)<br><span class="hljs-keyword">break</span><br>&#125;<br><br><span class="hljs-comment">// 刷新响应缓冲，确保即时发送</span><br>flusher, ok := w.(http.Flusher)<br><span class="hljs-keyword">if</span> !ok &#123;<br>log.Println(<span class="hljs-string">&quot;Streaming unsupported!&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br>flusher.Flush()<br><br><span class="hljs-comment">// 每秒发送一次</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/events&quot;</span>, sseHandler)<br>log.Println(<span class="hljs-string">&quot;Server started on port 8000...&quot;</span>)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文详细介绍了 SSE 的工作原理，并通过示例代码展示了如何使用 Go 和 Rust 实现一个简单的 SSE 服务端，展示了在实际项目中应用 SSE 的方法。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="SSE" scheme="https://hedon.top/tags/SSE/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨通过实现 json! 掌握声明宏</title>
    <link href="https://hedon.top/2024/05/28/rust-action-macro-json/"/>
    <id>https://hedon.top/2024/05/28/rust-action-macro-json/</id>
    <published>2024-05-28T07:37:23.000Z</published>
    <updated>2024-05-28T15:13:08.694Z</updated>
    
    <content type="html"><![CDATA[<p>在 Rust编程语言中，宏是一种强大的工具，可以用于在编译时生成代码。<code>json!</code>是一个在 Rust 中广泛使用的宏，它允许我们在 Rust 代码中方便地创建 JSON数据。</p><p>声明宏（declarative macros）是 Rust 中的一种宏，它们使用<code>macro_rules!</code> 关键字定义。</p><p>本文将参考《Rust 程序设计（第二版）》，通过实现 <code>json!</code>宏，深入理解声明宏的工作原理。</p><h1 id="结论先行">结论先行</h1><p>本文我们将构建一个 <code>json!</code> 宏，它支持我们以字符串 JSON风格的语法来编写 Json 值。如下面这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">students</span> = json![<br>&#123;<br><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Hedon Wang&quot;</span>,<br><span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">2022</span>,<br><span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Software engineering&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jun Lei&quot;</span>,<br><span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">1991</span>,<br><span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Computor science&quot;</span><br>&#125;<br>]<br></code></pre></td></tr></table></figure><blockquote><p><a href="#完整代码">完整代码</a></p></blockquote><h1 id="实现-json">实现 <code>json!</code></h1><h2 id="定义-json-enum">定义 Json enum</h2><p>首先我们需要思考一下 Json 结构是什么样子的？主要是以下 3 种模式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Wuhan University&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hubwi Wuhan&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;john&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-literal"><span class="hljs-keyword">null</span></span><br></code></pre></td></tr></table></figure><p>为此我们定义一个 Json 结构的枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone, PartialEq, Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Json</span> &#123;<br>    Null,<br>    <span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-type">bool</span>),<br>    <span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">String</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-type">Vec</span>&lt;Json&gt;),<br>    <span class="hljs-title function_ invoke__">Object</span>(HashMap&lt;<span class="hljs-type">String</span>, Json&gt;),<br>&#125;<br></code></pre></td></tr></table></figure><p>你应该可以感到非常奇妙，使用一个这么简单的枚举，居然就可以表示所有的Json 结构了。遗憾的是，现在这个结构编写 Json 值的语法相当冗长。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">people</span> = Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>    (<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hedon&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>    (<span class="hljs-string">&quot;age&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">10.0</span>)),<br>    (<span class="hljs-string">&quot;is_student&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)),<br>    (<br>        <span class="hljs-string">&quot;detail&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            (<span class="hljs-string">&quot;address&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;beijing&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>            (<span class="hljs-string">&quot;phone&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()))<br>        ]))<br>    )<br>]))<br></code></pre></td></tr></table></figure><p>我们期望可以以下面这种方式来声明 Json变量，这看起来就清爽许多了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">students</span> = json!([<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jim Blandy&quot;</span>,<br>        <span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">1926</span>,<br>        <span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Tibetan throat singing&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jason Orendorff&quot;</span>,<br>        <span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">1702</span>,<br>        <span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Knots&quot;</span><br>    &#125;<br>]);<br></code></pre></td></tr></table></figure><h2 id="猜想-json">猜想 <code>json!</code></h2><p>我们可以预见 Json 宏内部将会有多条规则，因为 JSON数据有多种类型：对象、数组、数值等。事实上，我们可以合理地猜测每种 JSON类型都将有一条规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null)    =&gt; &#123; Json::Null &#125;;<br>    ([ ... ]) =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Array</span>(...) &#125;;<br>    (&#123; ... &#125;) =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Object</span>(...) &#125;;<br>    (???)     =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Boolean</span>(...) &#125;;<br>    (???)     =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Number</span>(...) &#125;;<br>    (???)     =&gt; &#123; Json::<span class="hljs-title function_ invoke__">String</span>(...) &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而这不太正确，因为宏模式无法区分最后 3种情况，稍后我们会讨论如何处理。至于前 3种情况，显然它们是以不同的语法标记开始的，所以这几种情况比较好处理。</p><h2 id="实现-null">实现 Null</h2><p>我们先从最简单的 <code>Null</code> 分支开始，先编写如下测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_null_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(null);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::Null);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要通过上述测试用例非常简单，我们只需要在 <code>macro_rules!</code>支持中匹配这种情况即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>#[macro_export]</code> 注解是 Rust中的一个属性，用于指示这个宏应该被导出到调用者的作用域中，这样其他模块也可以使用它。</li><li><code>macro_rules!</code>宏定义了一个自定义的宏。在这里，它创建了一个名为 <code>json</code>的宏，用于生成 JSON 数据。</li><li>宏定义中 <code>(null)</code> 是匹配模式。这意味着当你调用<code>json!</code> 宏并传递 <code>null</code>作为参数时，将会触发这个规则。</li><li><code>=&gt;</code>符号用于指示匹配模式后的代码块。在这里，它指定了当匹配<code>(null)</code> 时应该生成的代码块。</li><li><code>Json::Null</code> 是一个 JSON 类型的枚举值，表示 JSON 中的null 值。这个宏的目的是将传入的 <code>null</code> 转换为<code>Json::Null</code>。</li></ul><h2 id="实现-booleannumberstring">实现 Boolean/Number/String</h2><p>我们先准备如下测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_boolean_number_string_json</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察分析，它们其实都是同一种模式：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240528114725679.png"alt="Boolean/Number/String 分析" /><figcaption aria-hidden="true">Boolean/Number/String 分析</figcaption></figure><p>现在需要解决的问题就是，如何将这 3 种模式进行统一，这样在<code>macro_rules!</code> 中才可以统一匹配模式并进行代码生成。</p><p>这里我们其实需要做的就是将 <code>bool</code>、<code>f64</code> 和<code>&amp;str</code> 转为对应的 <code>Json</code>类型。那就需要用到标准库中的 <code>From</code> trait 了。</p><p>做法很简单，我们实现如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">Boolean</span>(value)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;&amp;<span class="hljs-type">str</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">String</span>(value.<span class="hljs-title function_ invoke__">to_string</span>())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">f64</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">Number</span>(value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后完善我们的 <code>json!</code>，目前的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们使用 <code>$value</code>作 为变量来承接匹配到的元素，其类型为<code>tt</code> ，表示任意的语法标记树。具体可以参考：<ahref="#片段类型">片段类型</a>。</p><p>这时运行上述测试用例，是没有问题的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">PASS [   0.004s] json-macro tests::test_boolean_number_string_json<br>PASS [   0.004s] json-macro tests::test_null_json<br></code></pre></td></tr></table></figure><p>美中不足的是，JSON 结构中的数字类型，其实不一定是 f64，也可以是i32、u32、f32 或其他的数字类型，如果我们要为这全部的数字类型都实现到Json 的 <code>From</code> trait，那就多冗余。</p><p>这个时候我们又可以实现一个宏，用于快速生成<code>impl From&lt;T&gt; for Json</code>。这个实现比较简单，本文就不赘述了，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> impl_from_for_primitives &#123;<br>    (  $( $<span class="hljs-keyword">type</span>: ty ) * ) =&gt; &#123;<br>        $(<br>            <span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;$<span class="hljs-keyword">type</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>                <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: $<span class="hljs-keyword">type</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>                    Json::<span class="hljs-title function_ invoke__">Number</span>(value <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>)<br>                &#125;<br>            &#125;<br>        )*<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们只需要用下面这一行代码，就可以为所有的数字类型实现<code>From</code> trait 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">impl_from_for_primitives!(<span class="hljs-type">u8</span> <span class="hljs-type">u16</span> <span class="hljs-type">u32</span> <span class="hljs-type">u64</span> <span class="hljs-type">i8</span> <span class="hljs-type">i16</span> <span class="hljs-type">i32</span> <span class="hljs-type">i64</span> <span class="hljs-type">f32</span> <span class="hljs-type">f64</span> <span class="hljs-type">isize</span> <span class="hljs-type">usize</span>);<br></code></pre></td></tr></table></figure><p>记得这个时候你要删除上面手动实现的<code>impl From&lt;f64&gt; for Json</code>，不然会有 impl 冲突错误。</p><p>再次运行测试，也是可以通过的。</p><h2 id="实现-array">实现 Array</h2><p>准备如下测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_json</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!([<span class="hljs-number">1</span>, null, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-literal">true</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        json,<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<br>            Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>),<br>            Json::Null,<br>            Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>            Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)<br>        ])<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>要匹配<code>[1, null, "string", true]</code>这个模式，笔者的分析过程如下：</p><ol type="1"><li>首先是外面的两个中括号 <code>[</code> 和 <code>]</code> ；</li><li>再往里，是一个重复匹配的模式，以 <code>,</code> 分割，可以匹配 0到任意多个元素，所以是 <code>$(  ,*)</code> ，具体可以参考：<ahref="#重复模式">重复模式</a>；</li><li>最里面就是第 2 步要匹配的元素了，我们先用 <code>$element</code>作为变量来承接每一个元素，其类型为 <code>tt</code>，表示任意的语法标记树。</li></ol><p>分析完匹配的表达式后，我们就可以得到：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">([ $( $element:tt ), * ]) =&gt; &#123; <span class="hljs-comment">/* TODO */</span> &#125;<br></code></pre></td></tr></table></figure><p>我们要生成的代码长这个样子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust">Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<br>    Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>),<br>    Json::Null,<br>    Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>    Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)<br>])<br></code></pre></td></tr></table></figure><p>其实就是一个 <code>vec!</code>，然后里面每个元素都是一个<code>Json</code>，如此递归下去。</p><p>即可以得到代码生成部分的逻辑为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[$(json!($element)),* ])<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240528134133088.png"alt="Json::Array 宏分析" /><figcaption aria-hidden="true">Json::Array 宏分析</figcaption></figure><p>综上，我们实现的代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ([ $( $element: tt),* ]) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[ $( json!($element)), * ])<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试用例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">PASS [   0.003s] json-macro tests::test_null_json<br>PASS [   0.003s] json-macro tests::test_boolean_number_string_json<br>PASS [   0.004s] json-macro tests::test_array_json<br></code></pre></td></tr></table></figure><h2 id="实现-object">实现 Object</h2><p>写好如下测试用例，这次我们顺带把 Null、Boolean、Number 和 String带上了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_object_json</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(&#123;<br>        <span class="hljs-string">&quot;null&quot;</span>: null,<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hedon&quot;</span>,<br>        <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&quot;is_student&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;detail&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;beijing&quot;</span>,<br>            <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span><br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        json,<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            (<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hedon&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>            (<span class="hljs-string">&quot;age&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">10.0</span>)),<br>            (<span class="hljs-string">&quot;is_student&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)),<br>            (<br>                <span class="hljs-string">&quot;detail&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>                Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>                    (<span class="hljs-string">&quot;address&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;beijing&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>                    (<span class="hljs-string">&quot;phone&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()))<br>                ]))<br>            )<br>        ]))<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>对比预期的 <code>json!</code> 宏内容和展开后的代码：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240528133040062.png"alt="Json::Object 宏分析" /><figcaption aria-hidden="true">Json::Object 宏分析</figcaption></figure><p>完善我们的 <code>macro_rules! json</code> ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ([ $( $element: tt),* ]) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[ $( json!($element)), * ])<br>    &#125;;<br>    (&#123; $( $key:tt : $value:tt ),* &#125;) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            $(<br>                ( $key.<span class="hljs-title function_ invoke__">to_string</span>(), json!($value) )<br>            ), *<br>        ]))<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试用例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">PASS [   0.004s] json-macro tests::test_object_json<br>PASS [   0.005s] json-macro tests::test_array_json<br>PASS [   0.004s] json-macro tests::test_null_json<br>PASS [   0.005s] json-macro tests::test_boolean_number_string_json<br></code></pre></td></tr></table></figure><p>至此，我们就完成了 <code>json!</code> 宏的构建了！完整源码可见：<ahref="https://www.notion.so/e90c161d8e3743b2a4f788e3d7b75181?pvs=21">完整代码</a></p><p>Peace! Enjoy coding~</p><h1 id="附录">附录</h1><h2 id="重复模式">重复模式</h2><p>在 <ahref="https://www.notion.so/Array-c914526ab9474ccd9cb92c7eb17225b6?pvs=21">实现Array</a> 中，我们匹配了这样一个模式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">([ $( $element:tt ), * ]) =&gt; &#123; <span class="hljs-comment">/* TODO */</span> &#125;<br></code></pre></td></tr></table></figure><p>其中 <code>$($element:tt), *)</code>就是一个重复模式，其可以进一步抽象为 <code>$( ... ),*</code> ，表示匹配0 次或多次，以 <code>,</code> 分隔。</p><p>Rust 支持以下全部重复模式：</p><table><thead><tr class="header"><th>模式</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>$( … ) *</td><td>匹配 0 次或多次，没有分隔符</td></tr><tr class="even"><td>$( … ), *</td><td>匹配 0 次或多次，以逗号分隔</td></tr><tr class="odd"><td>$( … ); *</td><td>匹配 0 次或多次，以分号分隔</td></tr><tr class="even"><td>$( … ) +</td><td>匹配 1 次或多次，没有分隔符</td></tr><tr class="odd"><td>$( … ), +</td><td>匹配 1 次或多次，以逗号分隔</td></tr><tr class="even"><td>$( … ); +</td><td>匹配 1 次或多次，以分号分隔</td></tr><tr class="odd"><td>$( … ) ?</td><td>匹配 0 次或 1 次，没有分隔符</td></tr></tbody></table><p>即：</p><ul><li><code>*</code> 表示 0 次或多次</li><li><code>+</code> 表示 1 次或多次</li><li><code>?</code> 表示 0 次或 1 次</li><li>可在上述 3 者之前加入分隔符</li></ul><h2 id="片段类型">片段类型</h2><p>在 <a href="#实现-array">实现 Array</a>中，我们匹配了这样一个模式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">([ $( $element:tt ), * ]) =&gt; &#123; <span class="hljs-comment">/* TODO */</span> &#125;<br></code></pre></td></tr></table></figure><p>这里我们将 <code>$element</code> 指定为 <code>tt</code>，这个<code>tt</code> 就是宏中的一种片段类型。</p><p><code>tt</code> 能匹配单个语法标记树，包含：</p><ul><li>一对括号，如 <code>(..)</code>、<code>[..]</code>、或<code>&#123;..&#125;</code> ，以及位于其中的所有内容，包括嵌套的语法标记树。</li><li>单独的非括号语法标记，比如 <code>1926</code> 或 <code>Knots</code>。</li></ul><p>所以为了匹配任意类型的 <code>Json</code> ，我们选择了 <code>tt</code>作为 <code>$element</code> 的片段类型。</p><p><code>macro_rules!</code> 支持的片段类型如下所示：</p><table><thead><tr class="header"><th>片段类型</th><th>匹配（带例子）</th><th>后面可以跟 ······</th></tr></thead><tbody><tr class="odd"><td>expr</td><td>表达式：2 + 2, "udon", x.len()</td><td>=&gt;,;</td></tr><tr class="even"><td>stmt</td><td>表达式或声明，不包括任何尾随分号（很难用，请尝试使用 expr 或block）</td><td>=&gt;,;</td></tr><tr class="odd"><td>ty</td><td>类型：String, Vec<u8>, (&amp;str, bool), dyn Read + Send</td><td>=&gt;,; =</td></tr><tr class="even"><td>path</td><td>路径：ferns, ::std::sync::mpsc</td><td>=&gt;,; =</td></tr><tr class="odd"><td>pat</td><td>模式：_, Some(ref x)</td><td>=&gt;,=</td></tr><tr class="even"><td>item</td><td>语法项：struct Point { x: f64, y: f64 }, mod ferns;</td><td>任意</td></tr><tr class="odd"><td>block</td><td>块：{ s += "ok"; true }</td><td>任意</td></tr><tr class="even"><td>meta</td><td>属性的主体：inline, derive(Copy, Clone), doc="3D models."</td><td>任意</td></tr><tr class="odd"><td>literal</td><td>字面量值：1024, "Hello, world!", 1_000_000f64</td><td>任意</td></tr><tr class="even"><td>lifetime</td><td>生命周期：'a, 'item, 'static</td><td>任意</td></tr><tr class="odd"><td>vis</td><td>可见性说明符：pub, pub(crate), pub(in module::submodule)</td><td>任意</td></tr><tr class="even"><td>ident</td><td>标识符：std, Json, longish_variable_name</td><td>任意</td></tr><tr class="odd"><td>tt</td><td>语法标记树：;, &gt;=, {}, [0 1 (+ 0 1)]</td><td>任意</td></tr></tbody></table><h2 id="完整代码">完整代码</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-meta">#[derive(Debug, Clone, PartialEq)]</span><br><span class="hljs-meta">#[allow(unused)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Json</span> &#123;<br>    Null,<br>    <span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-type">bool</span>),<br>    <span class="hljs-title function_ invoke__">String</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-type">Vec</span>&lt;Json&gt;),<br>    <span class="hljs-title function_ invoke__">Object</span>(HashMap&lt;<span class="hljs-type">String</span>, Json&gt;),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">Boolean</span>(value)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;&amp;<span class="hljs-type">str</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">String</span>(value.<span class="hljs-title function_ invoke__">to_string</span>())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">String</span>(value)<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> impl_from_for_primitives &#123;<br>    (  $( $<span class="hljs-keyword">type</span>: ty ) * ) =&gt; &#123;<br>        $(<br>            <span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;$<span class="hljs-keyword">type</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>                <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: $<span class="hljs-keyword">type</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>                    Json::<span class="hljs-title function_ invoke__">Number</span>(value <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>)<br>                &#125;<br>            &#125;<br>        )*<br>    &#125;<br>&#125;<br><br>impl_from_for_primitives!(<span class="hljs-type">u8</span> <span class="hljs-type">u16</span> <span class="hljs-type">u32</span> <span class="hljs-type">u64</span> <span class="hljs-type">i8</span> <span class="hljs-type">i16</span> <span class="hljs-type">i32</span> <span class="hljs-type">i64</span> <span class="hljs-type">f32</span> <span class="hljs-type">f64</span> <span class="hljs-type">isize</span> <span class="hljs-type">usize</span>);<br><br><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ([ $( $element: tt),* ]) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[ $( json!($element)), * ])<br>    &#125;;<br>    (&#123; $( $key:tt : $value:tt ),* &#125;) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            $(<br>                ( $key.<span class="hljs-title function_ invoke__">to_string</span>(), json!($value) )<br>            ), *<br>        ]))<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_null_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(null);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::Null);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_boolean_number_string_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-literal">true</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>));<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-number">1.0</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>));<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()));<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_object_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(&#123;<br>            <span class="hljs-string">&quot;null&quot;</span>: null,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hedon&quot;</span>,<br>            <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">10</span>,<br>            <span class="hljs-string">&quot;is_student&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-string">&quot;detail&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;beijing&quot;</span>,<br>                <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-built_in">assert_eq!</span>(<br>            json,<br>            Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>                (<span class="hljs-string">&quot;null&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::Null),<br>                (<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hedon&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>                (<span class="hljs-string">&quot;age&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">10.0</span>)),<br>                (<span class="hljs-string">&quot;is_student&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)),<br>                (<br>                    <span class="hljs-string">&quot;detail&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>                    Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>                        (<span class="hljs-string">&quot;address&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;beijing&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>                        (<span class="hljs-string">&quot;phone&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()))<br>                    ]))<br>                )<br>            ]))<br>        )<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!([<span class="hljs-number">1</span>, null, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-literal">true</span>]);<br>        <span class="hljs-built_in">assert_eq!</span>(<br>            json,<br>            Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<br>                Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>),<br>                Json::Null,<br>                Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>                Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)<br>            ])<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文分步展示了实现 json! 宏的过程，包括定义 Json 枚举和不同类型的匹配规则。通过这个过程，读者可以掌握声明宏的基本概念和实现方法。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="宏" scheme="https://hedon.top/tags/%E5%AE%8F/"/>
    
    <category term="元编程" scheme="https://hedon.top/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>xgo 原理探索</title>
    <link href="https://hedon.top/2024/05/23/go-xgo-explore/"/>
    <id>https://hedon.top/2024/05/23/go-xgo-explore/</id>
    <published>2024-05-23T13:15:10.000Z</published>
    <updated>2024-05-28T15:13:08.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go-单测-mock-方案">Go 单测 mock 方案</h1><table><thead><tr class="header"><th>Mock 方法</th><th>原理</th><th>依赖</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>接口 Mock</td><td>为依赖项定义接口，并提供接口的 Mock 实现。</td><td>需要定义接口和 Mock 实现。</td><td>灵活，遵循 Go 的类型系统；易于替换实现。</td><td>需要更多的样板代码来定义接口和 Mock 实现。</td></tr><tr class="even"><td>Monkey Patching（bouk/moneky）</td><td>直接修改函数指针的内存地址来实现对函数的替换。</td><td>内存保护；汇编代码。</td><td>强大，可以 Mock 任何函数，甚至第三方库的函数。</td><td>复杂，容易出错；线程不安全；依赖系统指令集。</td></tr></tbody></table><h1 id="boukmonkey-弊端">bouk/monkey 弊端</h1><blockquote><p><a href="https://github.com/bouk/monkey">bouk/monkey</a> 🐒</p></blockquote><p>monkey 的核心功能是能够在运行时替换某个函数的实现。</p><p><strong>原理：</strong></p><ol type="1"><li><strong>函数指针替换</strong>：在 Go语言中，函数的地址存储在内存中。bouk/monkey通过直接修改函数指针的内存地址来实现对函数的替换。</li><li><strong>汇编代码</strong>：使用了汇编代码来实现对函数入口的跳转。这些汇编代码会在函数被调用时，将执行流重定向到新的函数实现。</li><li><strong>内存保护</strong>：为了修改内存中的函数指针，bouk/monkey需要临时修改内存页面的保护属性（例如，将页面设为可写）。在修改完毕后，它会恢复原来的保护属性。</li><li><strong>反射与 unsafe 包</strong>：利用 Go 的反射机制和 unsafe包，bouk/monkey 可以获取并操作函数的底层实现细节。</li></ol><p><strong>实现步骤：</strong></p><ol type="1"><li><strong>保存原函数</strong>：在替换函数之前，bouk/monkey会保存原始函数的指针，以便在需要时恢复或调用原始函数。</li><li><strong>生成跳转代码</strong>：bouk/monkey生成一段汇编跳转代码，这段代码会在函数调用时，将执行流跳转到新的函数实现。</li><li><strong>修改函数指针</strong>：使用 unsafe 包，bouk/monkey修改目标函数的入口地址，指向生成的跳转代码。</li><li><strong>恢复内存保护</strong>：在完成上述修改后，恢复内存页面的保护属性。</li></ol><p><strong>有以下几个弊端：</strong></p><ol type="1"><li>如果启用了内联，Monkey有时无法修补函数。尝试在禁用内联的情况下运行测试，例如:<code>go test -gcflags=-l</code>。同样的命令行参数也可以用于构建。</li><li>Monkey不能在一些面向安全的操作系统上工作，这些操作系统不允许同时写入和执行内存页。目前的方法并没有真正可靠的解决方案。</li><li>线程不安全的。</li><li>依赖指令集。</li></ol><h1 id="先看-xgo-怎么用">先看 xgo 怎么用</h1><blockquote><p><a href="https://github.com/xhd2015/xgo">xgo</a> 😈</p></blockquote><p>代码结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">.<br>├── greet.<span class="hljs-keyword">go</span><br>└── greet_test.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>现在在 <code>greet.go</code> 中有一个函数 <code>greet</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>在真实的生产环境中，<code>greet</code>可能要复杂得多，它可能会依赖各种第三方API，也可能会依赖数据库等多种外部组件。所以在测试的时候，我们希望对其进行<strong>mock</strong>，使其返回一个固定的值，便于我们撰写单元测试。</p><p><code>xgo</code> 参考了 <code>go-monkey</code> 的思想，但是不从<strong>修改指令</strong> 这个途径入手，而是另辟蹊径，从<strong>代码重写</strong> 的角度实现了 <strong>mock</strong>的能力。</p><p>为了使用 <code>xgo</code>，我们需要先安装 <code>xgo</code>这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install github.com/xhd2015/xgo/cmd/xgo@latest<br></code></pre></td></tr></table></figure><p>同时在我们的项目中需要引入 <code>xgo</code> 依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get <span class="hljs-string">&quot;github.com/xhd2015/xgo/runtime/mock&quot;</span><br></code></pre></td></tr></table></figure><p>我们编写的 <code>greet_test.go</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> xgo_use<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/xhd2015/xgo/runtime/mock&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestOriginGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMockGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.Patch(greet, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在 <code>TestMockGreet</code> 这个单元测试中，我们将<code>greet</code> 进行了 mock，返回 <code>"mock " + s</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mock.Patch(greet, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br></code></pre></td></tr></table></figure><p>为了使用 <code>xgo</code>的能力，我们在执行单元测试的时候，需要运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xgo <span class="hljs-built_in">test</span> -v ./<br></code></pre></td></tr></table></figure><p>输出大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  xgo-use git:(master) xgo <span class="hljs-built_in">test</span> -v ./<br>xgo is taking a <span class="hljs-keyword">while</span> to setup, please <span class="hljs-built_in">wait</span>...<br>=== RUN   TestOriginGreet<br>--- PASS: TestOriginGreet (0.00s)<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>PASS<br>ok      xgo-explore/xgo-use     (cached)<br></code></pre></td></tr></table></figure><h1 id="xgo-的核心原理">xgo 的核心原理</h1><p><code>xgo</code> 的核心原理是利用 <code>go build -toolexec</code>的能力。</p><p>运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">help</span> build<br></code></pre></td></tr></table></figure><p>找到 <code>toolexec</code> 的相关说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">-toolexec <span class="hljs-string">&#x27;cmd args&#x27;</span><br>        a program to use to invoke toolchain programs like vet and asm.<br>        For example, instead of running asm, the go <span class="hljs-built_in">command</span> will run<br>        <span class="hljs-string">&#x27;cmd args /path/to/asm &lt;arguments for asm&gt;&#x27;</span>.<br>        The TOOLEXEC_IMPORTPATH environment variable will be <span class="hljs-built_in">set</span>,<br>        matching <span class="hljs-string">&#x27;go list -f &#123;&#123;.ImportPath&#125;&#125;&#x27;</span> <span class="hljs-keyword">for</span> the package being built.<br></code></pre></td></tr></table></figure><p>一言以蔽之：<code>-toolexec</code> 允许对 go 工具链进行拦截，包括<code>vet</code>、<code>asm</code>、<code>compile</code> 和<code>link</code>。</p><p>这种技术也被称为：插桩（stubbing）、增强（instrumentation）和代码重写（rewriting）。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Km9eLWtYFJMiFYP0uC-B29J__5mGvLlSsrD52hWgS_S2nOGSx9PnMybHuqcQljAtTUr5QVVqaHGyyAEwqVPowhPqJvAZHLALdQpj6gzHzb60NLLe91tX87_sAerIGq2mwYMVdBcptglQpJ0QkfmDC-ZHoQ=s2048.png"alt="-toolexec 示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）" /><figcaption aria-hidden="true">-toolexec示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）</figcaption></figure><p>基于上述分析，<code>xgo</code> 提出了 <strong>代码重写</strong>的思路，实现了 <strong>在编译过程中插入拦截器代码</strong> 的功能：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240523164815047.png"alt="xgo 在 go build 中的作用位置（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）" /><figcaption aria-hidden="true">xgo 在 go build中的作用位置（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）</figcaption></figure><p>所以上述我们的 <code>greet.go</code> 文件中的源代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>经过 <code>xgo</code> 编译后最终实际编译的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;runtime&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (r0 <span class="hljs-type">string</span>) &#123;<br>  stop, post := runtime.__xgo_trap(Greet, &amp;s, &amp;r0)<br>  <span class="hljs-keyword">if</span> stop &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">defer</span> post()<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/5e020865-fd1d-49d3-be72-7ee2233a3c5f.png"alt="greet 函数重写变化示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）" /><figcaption aria-hidden="true">greet函数重写变化示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）</figcaption></figure><p>如图所示，一旦函数被调用，它的控制流首先转移到<code>Trap</code>，然后一系列拦截器将根据其目的检查当前调用是否应该被Mock、修改、记录或停止。</p><p>如果 <code>greet</code> 注册了 mock 函数，那么就会在<code>__xgo_trap</code> 中调用 mock 的函数，并将返回值设置到<code>r0</code> 上进行返回，而跳过原始的执行逻辑。</p><h1 id="第-1-步死代码实现">第 1 步：死代码实现</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  01-deadcode git:(master) tree<br>.<br>├── greet.go<br>├── greet_test.go<br>└── mock.go<br></code></pre></td></tr></table></figure><p>我们先从最简单的实现开始，采用侵入性代码实现 <code>xgo</code>的核心功能，这里我们还用不到 <code>-toolexec</code>。</p><p>代码结构如上所示，在 <code>mock.go</code> 中，我们有如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mockFuncs = sync.Map&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterMockFunc</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>, fun <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>mockFuncs.Store(funcName, fun)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>mockFuncs</code>: 用于承载函数与 mock 函数的对应关系，其中 key为函数名称，value 为 mock 函数。我们使用 <code>sync.Map</code>来保证并发安全。</li><li><code>RegisterMockFunc</code> 用于为指定的 funcName 注册 mock函数。</li></ul><p>在 <code>greet.go</code> 中，我们有一个 <code>Greet</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们要对其支持 mock，那么需要修改其实现为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fun, ok := mockFuncs.Load(<span class="hljs-string">&quot;Greet&quot;</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>f, ok := fun.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br><span class="hljs-keyword">return</span> f(s)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>在修改后的代码中，我们先判断是否存在 mock 函数，如果存在，则执行 mock函数，否则执行原始逻辑。</p><p>现在我们在 <code>greet_test.go</code> 中编写测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMockGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestOriginGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 单独执行 TestMockGreet</span><br>➜  01-deadcode git:(master) ✗ go <span class="hljs-built_in">test</span> -v -run TestMockGreet<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>PASS<br>ok      xgo-explore/01-deadcode 0.103s<br><br><span class="hljs-comment"># 单独执行 TestOriginGreet</span><br>➜  01-deadcode git:(master) ✗ go <span class="hljs-built_in">test</span> -v -run TestOriginGreet<br>=== RUN   TestOriginGreet<br>--- PASS: TestOriginGreet (0.00s)<br>PASS<br>ok      xgo-explore/01-deadcode 0.102s<br><br><span class="hljs-comment"># 一起执行</span><br>➜  01-deadcode git:(master) ✗ go <span class="hljs-built_in">test</span> -v -run $Test$<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>=== RUN   TestOriginGreet<br>    greet_test.go:20: Greet() = <span class="hljs-string">&quot;mock world&quot;</span>; want <span class="hljs-string">&quot;hello world&quot;</span><br>--- FAIL: TestOriginGreet (0.00s)<br>FAIL<br><span class="hljs-built_in">exit</span> status 1<br>FAIL    xgo-explore/01-deadcode 0.102s<br></code></pre></td></tr></table></figure><p>我们会发现单独执行都是 ok 的，不过一起执行的话<code>TestOriginGreet</code> 就失败了，这是因为先执行了<code>TestMockGreet</code>，这个时候已经往 <code>mockFunc</code>中注册了 mock 函数了，所以 <code>TessOriginGreet</code>就执行失败了。</p><p>这里需要在协程层面上做 mock 隔离，<code>xgo</code>的思路是在编译时注入 <code>getg()</code>函数来获取当前协程信息从而实现在注册 mock函数时进行协程隔离。本文将聚焦在 <code>xgo</code> 的核心原理<strong>代码重写</strong> 上，故暂时不考虑这一块。</p><p>Ok，那么短短几行代码，我们就将 <code>xgo</code>的最核心思想给展示出来了。可以看到，<code>xgo</code>的核心思想是往源代码中加入 <strong>合法的 Go代码</strong>，所以不涉及指令重写，故而只要你的机器能执行 Go程序，天然就支持 mock功能，这就天然达到了架构无关的兼容性了。同时我们也使用了<code>sync.Map</code> 来保证了并发安全。</p><h1 id="第-2-步死代码拦截器">第 2 步：死代码拦截器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  02-deadcode-interceptor git:(master) tree<br>.<br>├── greet.go<br>├── greet_test.go<br>└── mock.go<br></code></pre></td></tr></table></figure><p>在第 1 步中，这段代码我觉得有点冗长了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">fun, ok := mockFuncs.Load(<span class="hljs-string">&quot;Greet&quot;</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>  f, ok := fun.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<br>  <span class="hljs-keyword">if</span> ok &#123;<br>    <span class="hljs-keyword">return</span> f(s)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考 <code>xgo</code> 的函数签名，我们对其进行优化，在<code>mock.go</code> 中加入一个 <strong>丐版拦截器</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// mock.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InterceptMock</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>, arg <span class="hljs-type">string</span>, result *<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>fn, ok := mockFuncs.Load(funcName)<br><span class="hljs-keyword">if</span> ok &#123;<br>f, ok := fn.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>*result = f(arg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对应 <code>greet.go</code> 中 <code>Greet</code> 函数就修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>这看起来就清爽多了。再次执行测试代码，一样是可以通过的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  02-deadcode-interceptor git:(master) go <span class="hljs-built_in">test</span> -v -run TestOriginGreet<br>=== RUN   TestOriginGreet<br>--- PASS: TestOriginGreet (0.00s)<br>PASS<br>ok      xgo-explore/02-deadcode-interceptor     0.331s<br><br>➜  02-deadcode-interceptor git:(master) go <span class="hljs-built_in">test</span> -v -run TestMockGreet<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>PASS<br>ok      xgo-explore/02-deadcode-interceptor     0.103s<br></code></pre></td></tr></table></figure><h1 id="第-3-步toolexec-初探">第 3 步：toolexec 初探</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>这里 <code>mock.go</code> 没有任何变化。我们期望使用<code>-toolexec</code> 来修改源代码，以实现 mock无源代码侵入的特性，所以我们在 <code>greet.to</code> 中将<code>Greet</code> 函数恢复为只关注实际功能的样子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>同时为了更好地测试使用 <code>-toolexec</code>编译后的运行结果，这里将 <code>greet_test.go</code> 删除了并新增了<code>main.go</code> 文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>那么 <code>-toolexec</code> 要执行的命令怎么实现呢？在 Google 搜索<strong>go toolexec</strong> 你会看到官方给出的一个案例：<ahref="https://go.dev/src/cmd/go/testdata/script/toolexec.txt">toolexec.txt</a>。</p><p>核心部分在最下面，参考这个示例，我们来实现自己的<code>toolexec</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p cmd/mytool<br><span class="hljs-built_in">touch</span> cmd/mytool/mytool.go<br></code></pre></td></tr></table></figure><p>在<code>mytool.go</code>中，我们先写这么点代码，看一下会输出什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tool, args := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>:]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;-V=full&quot;</span> &#123;<br><span class="hljs-comment">// don&#x27;t do anything to infuence the version full output.</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;tool: %s\n&quot;</span>, tool)<br>fmt.Printf(<span class="hljs-string">&quot;args: %v\n&quot;</span>, args)<br>&#125;<br>  <span class="hljs-comment">// 继续执行之前的命令</span><br>cmd := exec.Command(tool, args...)<br>cmd.Stdout = os.Stdout<br>cmd.Stderr = os.Stderr<br><br><span class="hljs-keyword">if</span> err := cmd.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;run command error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们企图输出执行的工具 <code>tool</code> 及传给它的参数<code>args</code>。由于 <code>-V=full</code>的作用是在终端输出版本信息，所以我们要跳过它，避免产生干扰。输出日志后，我们暂且先继续执行原始的命令，不对编译过程做其他的干扰。</p><p>Ok，现在就来看看这个 <code>-toolexec</code> 到底做了什么，在<code>03-toolexec-static</code> 目录下执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清除缓存，一直使用最新的编译结果</span><br>go clean -cache -modcache -i -r<br><span class="hljs-comment"># 编译 mytool</span><br>go build ./cmd/mytool<br><span class="hljs-comment"># 编译业务程序</span><br>go build -toolexec=./mytool -o main<br></code></pre></td></tr></table></figure><p>因为这几个命令经常会用到，所以我们可以将其封装到<code>script.sh</code> 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> script.sh<br><span class="hljs-built_in">chmod</span> +x script.sh<br></code></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>go clean -cache -modcache -i -r<br>go build ./cmd/mytool<br>go build -toolexec=./mytool -o main<br></code></pre></td></tr></table></figure><p>执行上述命令后，可以看到以下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ./script.sh<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/compile<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/_pkg_.a -trimpath <span class="hljs-variable">$WORK</span>/b001=&gt; -p main -lang=go1.22 -complete -buildid PcS9clqF_ny_Ds5N0i_s/PcS9clqF_ny_Ds5N0i_s -goversion go1.22.3 -c=4 -shared -nolocalimports -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg -pack ./greet.go ./main.go ./mock.go]<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/link<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/exe/a.out -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg.link -buildmode=pie -buildid=KgnnCoU_6enHkOm-T62Z/PcS9clqF_ny_Ds5N0i_s/H80dtgGZw1L8mTtVqJBf/KgnnCoU_6enHkOm-T62Z -extld=cc <span class="hljs-variable">$WORK</span>/b001/_pkg_.a]<br></code></pre></td></tr></table></figure><p>可以看到执行了 <code>compile</code> 和 <code>link</code>两个工具，<code>compile</code> 是编译过程，将生成 <code>&#123;&#125;.out</code>文件，而 <code>link</code> 是将多个 <code>&#123;&#125;.out</code>文件链接成一个可执行文件。这是很经典的编译过程，如果对 Go语言的编译过程感兴趣，也可以参考官方的 <ahref="https://github.com/golang/go/tree/release-branch.go1.22/src/cmd/compile">GoCompile Readme</a>，或者笔者撰写的 <ahref="https://hedon.top/2023/11/29/go-compilation/">Go1.21.0程序编译过程</a>。</p><p>这里我们需要重点关注的是 <code>compile</code>命令，它是负责编译源代码的，涉及到的源代码文件会通过<code>-pack ./greet.go ./main.go ./mock.go</code> 传递给<code>compile</code> 命令。</p><p>结合 <code>-toolexec</code> 的帮助信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">-toolexec <span class="hljs-string">&#x27;cmd args&#x27;</span><br>        a program to use to invoke toolchain programs like vet and asm.<br>        For example, instead of running asm, the go <span class="hljs-built_in">command</span> will run<br>        <span class="hljs-string">&#x27;cmd args /path/to/asm &lt;arguments for asm&gt;&#x27;</span>.<br>        The TOOLEXEC_IMPORTPATH environment variable will be <span class="hljs-built_in">set</span>,<br>        matching <span class="hljs-string">&#x27;go list -f &#123;&#123;.ImportPath&#125;&#125;&#x27;</span> <span class="hljs-keyword">for</span> the package being built.<br></code></pre></td></tr></table></figure><p>我们只需要在执行 <code>compile</code> 命令之前，在<code>cmd args</code> 这个环节，进行 <strong>代码重写</strong>就可以实现我们想要的功能了。</p><p>我们现在是要对 <code>greet.go</code> 里面的 <code>Greet</code>函数进行重写，先看看之前的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>重写后的代码应该跟我们之前 <strong>第 2 步</strong> 是一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br> <span class="hljs-keyword">return</span> res<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有 n多种方式可以做到，现在笔者决定使用最暴力的方式，直接临时创建一个包含这段代码的文件<code>tmp.go</code>，并替换掉传给 <code>compile</code> 的参数，即将<code>-pack ./greet.go ./main.go ./mock.go</code> 替换为<code>-pack tmp.go ./main.go ./mock.go</code></p><p>综上，<code>cmd/mytool/mytool/go</code> 实现的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tool, args := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>:]<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;-V=full&quot;</span> &#123;<br><span class="hljs-comment">// don&#x27;t do anything to infuence the version full output.</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> filepath.Base(tool) == <span class="hljs-string">&quot;compile&quot;</span> &#123;<br>index := findGreetFile(args)<br><span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">-1</span> &#123;<br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><span class="hljs-keyword">defer</span> os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br>_, _ = f.WriteString(newCode)<br>args[index] = <span class="hljs-string">&quot;tmp.go&quot;</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;tool: %s\n&quot;</span>, tool)<br>fmt.Printf(<span class="hljs-string">&quot;args: %v\n&quot;</span>, args)<br>&#125;<br><span class="hljs-comment">// 继续执行之前的命令</span><br>cmd := exec.Command(tool, args...)<br>cmd.Stdout = os.Stdout<br>cmd.Stderr = os.Stderr<br><br><span class="hljs-keyword">if</span> err := cmd.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;run command error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findGreetFile</span><span class="hljs-params">(args []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br><span class="hljs-keyword">if</span> strings.Contains(arg, <span class="hljs-string">&quot;greet.go&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-keyword">var</span> newCode = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func Greet(s string) (res string) &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;Greet&quot;, s, &amp;res) &#123;</span><br><span class="hljs-string"> return res</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">return &quot;hello &quot; + s</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这里我先使用 <code>findGreetFile</code> 来查找 <code>greet.go</code>文件所处的参数位置，如果找到了，则生成新的 <code>tmp.go</code>文件，并替换参数，最后在 本次 <code>compile</code> 命令执行完毕后，删除<code>tmp.go</code>，“毁尸灭迹”。</p><p>执行 <code>./script.sh</code> 重新编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ✗ ./script.sh<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/compile<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/_pkg_.a -trimpath <span class="hljs-variable">$WORK</span>/b001=&gt; -p main -lang=go1.22 -complete -buildid PcS9clqF_ny_Ds5N0i_s/PcS9clqF_ny_Ds5N0i_s -goversion go1.22.3 -c=4 -shared -nolocalimports -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg -pack tmp.go ./main.go ./mock.go]<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/link<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/exe/a.out -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg.link -buildmode=pie -buildid=KgnnCoU_6enHkOm-T62Z/PcS9clqF_ny_Ds5N0i_s/H80dtgGZw1L8mTtVqJBf/KgnnCoU_6enHkOm-T62Z -extld=cc <span class="hljs-variable">$WORK</span>/b001/_pkg_.a]<br></code></pre></td></tr></table></figure><p>输出的结果中可以看到已经将 <code>compile</code> 的参数替换为<code>-pack tmp.go ./main.go ./mock.go</code> 了。</p><p>现在我们来执行生成的程序文件，可以看到是执行成功的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ✗ ./main<br>2024/05/23 17:53:52 run successfully<br></code></pre></td></tr></table></figure><p>如果我们不使用 <code>-toolexec</code>，是执行不成功的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ✗ go clean -cache -modcache -i -r<br>➜  03-toolexec-static git:(master) ✗ go build -o main<br>➜  03-toolexec-static git:(master) ✗ ./main<br>2024/05/23 17:54:33 Greet() = <span class="hljs-string">&quot;hello world&quot;</span>; want <span class="hljs-string">&quot;mock world&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第-4-步使用-ast-在函数前插入代码">第 4 步：使用 AST在函数前插入代码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  04-toolexec-ast git:(master) ✗ tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>暴力替换源代码文件的方式可能是不太优雅哈，假如我们的<code>greet.go</code> 内容改成下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet2</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 2 &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想对 <code>Greet2</code> 也进行<strong>代码重写</strong>，那就需要修改前面 <code>newCode</code>字段的内容，而且它是写死的，确实不太优雅。现在我们正式来面对这件事，对比修改后的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br> <span class="hljs-keyword">return</span> res<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是在每个函数前加上这么一段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>了解过编译原理的读者应该可以想到，我们可以通过操作源代码的 AST结构，往函数的开头插入这段代码即可。如果我们先不考虑参数和返回值的话，那这段代码我们需要替换的地方就是函数名称了，所以它的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;$&#123;funcName&#125;&quot;</span>, s, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们需要用到几个标准库工具：</p><ul><li><code>go/ast</code>: 包定义了 Go编程语言的抽象语法树（AST），核心有以下几种类型：<ul><li><code>File</code>: 表示一个 Go 源文件。</li><li><code>Decl</code>:表示一个声明，包括函数声明、变量声明、类型声明等。</li><li><code>Stmt</code>: 表示一个语句。</li><li><code>Expr</code>: 表示一个表达式。</li></ul></li><li><code>go/token</code>: 定义了处理 Go源代码的词法元素的基础设施，包括位置、标记和标识符等。这个包提供了用于管理源代码位置的信息，可以帮助定位代码中的特定部分。</li><li><code>go/parser</code>: 将一个 <code>.go</code> 文件以解析成 AST结构。</li><li><code>go/printer</code>: 提供了将 AST 格式化并输出为 Go源码的功能</li></ul><p>修改后的 <code>cmd/mytool/mytool.go</code> 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tool, args := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>:]<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;-V=full&quot;</span> &#123;<br><span class="hljs-comment">// don&#x27;t do anything to infuence the version full output.</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> filepath.Base(tool) == <span class="hljs-string">&quot;compile&quot;</span> &#123;<br>index := findGreetFile(args)<br><span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">-1</span> &#123;<br>filename := args[index]<br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()<br><span class="hljs-keyword">defer</span> os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(insertCode(filename))<br>args[index] = <span class="hljs-string">&quot;tmp.go&quot;</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;tool: %s\n&quot;</span>, tool)<br>fmt.Printf(<span class="hljs-string">&quot;args: %v\n&quot;</span>, args)<br>&#125;<br><span class="hljs-comment">// 继续执行之前的命令</span><br>cmd := exec.Command(tool, args...)<br>cmd.Stdout = os.Stdout<br>cmd.Stderr = os.Stderr<br><br><span class="hljs-keyword">if</span> err := cmd.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;run command error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findGreetFile</span><span class="hljs-params">(args []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br><span class="hljs-keyword">if</span> strings.Contains(arg, <span class="hljs-string">&quot;greet.go&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertCode</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fset := token.NewFileSet()<br>fast, err := parser.ParseFile(fset, filename, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse file error: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, decl := <span class="hljs-keyword">range</span> fast.Decls &#123;<br>fun, ok := decl.(*ast.FuncDecl)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>f, err := os.Create(<span class="hljs-string">&quot;tmp2.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp2.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(fmt.Sprintf(newCodeFormat, fun.Name.Name))<br>f.Close()<br><br>tmpFset := token.NewFileSet()<br>tmpF, err := parser.ParseFile(tmpFset, <span class="hljs-string">&quot;tmp2.go&quot;</span>, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse tmp2.go error: %v\n&quot;</span>, err)<br>&#125;<br>fun.Body.List = <span class="hljs-built_in">append</span>(tmpF.Decls[<span class="hljs-number">0</span>].(*ast.FuncDecl).Body.List, fun.Body.List...)<br>os.Remove(<span class="hljs-string">&quot;tmp2.go&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>printer.Fprint(&amp;buf, fset, fast)<br><br>fmt.Println(buf.String())<br><br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, s, &amp;res) &#123;</span><br><span class="hljs-string"> return res</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>核心的修改在于 <code>insertCode</code> 函数：</p><ol type="1"><li><p>使用 <code>parser.ParseFile</code> 将源代码文件解析成 AST结构；</p></li><li><p>遍历 AST 结构，找到所有的声明（Decl）结构，并使用<code>decl(.ast.FuncDecl)</code> 找到所有的函数；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">FuncDecl <span class="hljs-keyword">struct</span> &#123;<br>  Doc  *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span><br>  Recv *FieldList    <span class="hljs-comment">// receiver (methods); or nil (functions)</span><br>  Name *Ident        <span class="hljs-comment">// function/method name</span><br>  Type *FuncType     <span class="hljs-comment">// function signature: type and value parameters, results, and position of &quot;func&quot; keyword</span><br>  Body *BlockStmt    <span class="hljs-comment">// function body; or nil for external (non-Go) function</span><br>&#125;<br><br>BlockStmt <span class="hljs-keyword">struct</span> &#123;<br>  Lbrace token.Pos <span class="hljs-comment">// position of &quot;&#123;&quot;</span><br>  List   []Stmt<br>  Rbrace token.Pos <span class="hljs-comment">// position of &quot;&#125;&quot;, if any (may be absent due to syntax error)</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查看 <code>ast.FuncDecl</code> 的结构后，可以得出下一步就是往<code>FuncDecl.Body.List</code> 列表前面插入一些<code>Stmt</code>；</p></li><li><p>笔者没找到类似 <code>parseStmt</code>方法，所以取了个巧，我定义了一段代码的 <code>format</code>，里面的<code>%s</code> 会使用 <code>fun.Name.Name</code>获取函数名并进行替换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, s, &amp;res) &#123;</span><br><span class="hljs-string"> return res</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure></li><li><p>创建一个临时文件 <code>tmp2.go</code>并写入格式化后的代码，然后再次调用 <code>parser.ParseFile</code>得到解析这段代码的抽象语法树结构 <code>tmpF</code> 了；</p></li><li><p>然后通过 <code>tmpF.Decls[0].(*ast.FuncDecl).Body.List</code>就可以得到 <code>TmpFunc</code> 中的语句 <code>Stmt</code> 了；</p></li><li><p>将其加在源代码函数的前面即可：<code>fun.Body.List = append(tmpF.Decls[0].(*ast.FuncDecl).Body.List, fun.Body.List...)</code>；</p></li><li><p>然后再使用 <code>go/printer</code> 将修改后的 AST输出为新文件内容。</p></li></ol><p>通过上述步骤，我们就可以为 <code>greet.go</code>中的每个函数前面都插入打桩代码了。</p><p>修改 <code>main.go</code> 里面的内容，加入对 <code>Greet2</code>的测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s<br>&#125;)<br>res = Greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet2() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 2 successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>输出应该还是跟之前是一样的，我们运行生成的可执行函数，得到如下结果那就说明我们又成功进了一步了~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  04-toolexec-ast git:(master) ✗ ./main<br>2024/05/23 20:03:22 run greet 1 successfully<br>2024/05/23 20:03:22 run greet 2 successfully<br></code></pre></td></tr></table></figure><h1 id="第-5-步使用-reflect-反射动态获取参数和返回值名称">第 5 步：使用reflect 反射动态获取参数和返回值名称</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  05-toolexec-general git:(master) ✗ tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>接下来我们来处理函数签名中的参数和返回值部分，我们的样板代码中，写死了参数的名称和返回值的名称，现在我们需要来动态获取函数参数的名称和返回值的名称，如果返回值没有名称，那我们还需要手动设置名称。</p><p>我们将 <code>greet.to</code> 修改为以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet2</span><span class="hljs-params">(s2 <span class="hljs-type">string</span>)</span></span> (res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 2 &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet3</span><span class="hljs-params">(s3 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 3 &quot;</span> + s3<br>&#125;<br></code></pre></td></tr></table></figure><p>函数的信息当然都在前面获得的 <code>ast.FuncDecl</code>结构中，再次观察其结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">FuncDecl <span class="hljs-keyword">struct</span> &#123;<br>Doc  *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span><br>Recv *FieldList    <span class="hljs-comment">// receiver (methods); or nil (functions)</span><br>Name *Ident        <span class="hljs-comment">// function/method name</span><br>Type *FuncType     <span class="hljs-comment">// function signature: type and value parameters, results, and position of &quot;func&quot; keyword</span><br>Body *BlockStmt    <span class="hljs-comment">// function body; or nil for external (non-Go) function</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过注释就可以知道 <code>Type</code>字段就包含了参数和返回值的相关信息，查看 <code>FuncType</code>结构，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">FuncType <span class="hljs-keyword">struct</span> &#123;<br>  Func       token.Pos  <span class="hljs-comment">// position of &quot;func&quot; keyword (token.NoPos if there is no &quot;func&quot;)</span><br>  TypeParams *FieldList <span class="hljs-comment">// type parameters; or nil</span><br>  Params     *FieldList <span class="hljs-comment">// (incoming) parameters; non-nil</span><br>  Results    *FieldList <span class="hljs-comment">// (outgoing) results; or nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Params</code>：函数参数</li><li><code>Results</code>：函数返回值</li></ul><p>查看 <code>FieldList</code> 结构，可知参数列表和返回值列表都在相应的<code>List</code> 字段中，而其中的 <code>Names</code>字段就是参数的名称了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FieldList <span class="hljs-keyword">struct</span> &#123;<br>Opening token.Pos <span class="hljs-comment">// position of opening parenthesis/brace/bracket, if any</span><br>List    []*Field  <span class="hljs-comment">// field list; or nil</span><br>Closing token.Pos <span class="hljs-comment">// position of closing parenthesis/brace/bracket, if any</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Field <span class="hljs-keyword">struct</span> &#123;<br>Doc     *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span><br>Names   []*Ident      <span class="hljs-comment">// field/method/(type) parameter names; or nil</span><br>Type    Expr          <span class="hljs-comment">// field/method/parameter type; or nil</span><br>Tag     *BasicLit     <span class="hljs-comment">// field tag; or nil</span><br>Comment *CommentGroup <span class="hljs-comment">// line comments; or nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>补充一下，这里为什么 <code>Names</code> 类型是 <code>[]*Ident</code>呢？因为函数有以下的命名方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (r1, r1 <span class="hljs-type">string</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>那么在当下，只有 1 个参数和只有 1 个返回值的情况下，我们就可以通过<code>fun.Type.Params.List[0].Names[0].Name</code>来获取参数名称，也可以通过 <code>fun.Type.Results.List[0].Names</code>来获取返回值名称，如果返回值没有名称，那我们就为其设置名称<code>__xgo_res_1</code> 并写回源 AST结构。这样就都有名称，就很好处理了。</p><p>经上分析， <code>cmd/mytool/mytool.go</code> 中我们只需要修改<code>insertCode</code> 部分，修改的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertCode</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fset := token.NewFileSet()<br>fast, err := parser.ParseFile(fset, filename, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse file error: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, decl := <span class="hljs-keyword">range</span> fast.Decls &#123;<br>fun, ok := decl.(*ast.FuncDecl)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(newCode(fun))<br>f.Close()<br><br>tmpFset := token.NewFileSet()<br>tmpF, err := parser.ParseFile(tmpFset, <span class="hljs-string">&quot;tmp.go&quot;</span>, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>fun.Body.List = <span class="hljs-built_in">append</span>(tmpF.Decls[<span class="hljs-number">0</span>].(*ast.FuncDecl).Body.List, fun.Body.List...)<br>os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>printer.Fprint(&amp;buf, fset, fast)<br><br>fmt.Println(buf.String())<br><br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCode</span><span class="hljs-params">(fun *ast.FuncDecl)</span></span> <span class="hljs-type">string</span> &#123;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[s] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[res] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[s2] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[res2] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[s3] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 函数名称</span><br>funcName := fun.Name.Name<br><br><span class="hljs-comment">// 参数列表</span><br>argName := fun.Type.Params.List[<span class="hljs-number">0</span>].Names[<span class="hljs-number">0</span>].Name<br><br><span class="hljs-comment">// 返回值列表</span><br>resNames := fun.Type.Results.List[<span class="hljs-number">0</span>].Names<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(resNames) == <span class="hljs-number">0</span> &#123;<br>resNames = <span class="hljs-built_in">append</span>(resNames, &amp;ast.Ident&#123;Name: <span class="hljs-string">&quot;_xgo_res_1&quot;</span>&#125;)<br>fun.Type.Results.List[<span class="hljs-number">0</span>].Names = resNames<br>&#125;<br>resName := resNames[<span class="hljs-number">0</span>].Name<br><span class="hljs-keyword">return</span> fmt.Sprintf(newCodeFormat, funcName, argName, resName, resName)<br>&#125;<br><br><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, %s, &amp;%s) &#123;</span><br><span class="hljs-string"> return %s</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>现在我们就可以动态获取参数名称和返回值名称了。</p><p>修改我们的 <code>main.go</code>，以测试所有的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s<br>&#125;)<br>res = Greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet2() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 2 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 3 &quot;</span> + s<br>&#125;)<br>res = Greet3(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 3 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet3() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 3 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 3 successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行编译脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>执行编译产生的可执行程序，输出如下就说明我们又成功进了一大步~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  05-toolexec-general git:(master) ✗ ./main<br>2024/05/23 20:15:08 run greet 1 successfully<br>2024/05/23 20:15:08 run greet 2 successfully<br>2024/05/23 20:15:08 run greet 3 successfully<br></code></pre></td></tr></table></figure><h1 id="第-6-步支持多参数和多返回值">第 6 步：支持多参数和多返回值</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  06-toolexec-multi git:(master) ✗ tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>本文的最后一步，我们来面对一下多参数和多返回值的问题。假设我们又如下函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair1</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候我们 <strong>代码重写</strong>后应该长什么样子呢？可以是下面这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair1</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Pair1&quot;</span>, s1, s2, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>按照这个思路，下面这个函数呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>那就是这样的？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Pair2&quot;</span>, s1, s2, &amp;res1, &amp;res2) &#123;<br><span class="hljs-keyword">return</span> res1, res2<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>这种思路当然也能实现，换一种更优雅的思路呢？既然是一个列表，那么就可以用切片来承载，也就是可以是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Pair2&quot;</span>, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;s1, s2&#125;, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&amp;res1, &amp;res2&#125;) &#123;<br><span class="hljs-keyword">return</span> res1, res2<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>那我们就可以抽象出插入代码的模板了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;$&#123;funcName&#125;&quot;</span>, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;$&#123;paramList&#125;&#125;, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;$&#123;returnListWith&amp;&#125;&#125;) &#123;<br>  <span class="hljs-keyword">return</span> $&#123;returnListWithout&amp;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了实现这个，我们需要先修改一下 <code>mock.go</code> 中的<code>InterceptMock</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InterceptMock</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>, args []<span class="hljs-keyword">interface</span>&#123;&#125;, results []<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>mockFn, ok := mockFuncs.Load(funcName)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><br>in := <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-built_in">len</span>(args))<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br>in[i] = reflect.ValueOf(arg)<br>&#125;<br><br>  mockFnValue := reflect.ValueOf(mockFn)<br>out := mockFnValue.Call(in)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(out) != <span class="hljs-built_in">len</span>(results) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;mock function return value number is not equal to results number&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> i, result := <span class="hljs-keyword">range</span> results &#123;<br>reflect.ValueOf(result).Elem().Set(out[i])<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器的具体实现如下：</p><ol type="1"><li>判断是否注册了 mock 函数，没有则直接返回；</li><li>将所有参数都放到 <code>[]refect.Value</code> 中；</li><li>通过反射 <code>refect.ValueOf</code> 获取 mockFn 的值；</li><li>调用 <code>mockFnValue.Call()</code>来执行函数，并返回结果列表；</li><li>遍历传进来的返回值引用列表，调用<code>reflect.ValueOf(result).Elem().Set(out[i])</code>将返回值设置回去。</li></ol><p>现在我们来修改我们的 <code>-toolexec</code> 工具，来根据函数的 AST结构，获取参数列表和返回值列表，生成代插入的模板代码，并将其插入到每个函数的开头。这次在<code>cmd/mytool/mytool.go</code> 中，我们只需修改 <code>newCode</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertCode</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fset := token.NewFileSet()<br>fast, err := parser.ParseFile(fset, filename, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse file error: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, decl := <span class="hljs-keyword">range</span> fast.Decls &#123;<br>fun, ok := decl.(*ast.FuncDecl)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(newCode(fun))<br>f.Close()<br><br>tmpFset := token.NewFileSet()<br>tmpF, err := parser.ParseFile(tmpFset, <span class="hljs-string">&quot;tmp.go&quot;</span>, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>fun.Body.List = <span class="hljs-built_in">append</span>(tmpF.Decls[<span class="hljs-number">0</span>].(*ast.FuncDecl).Body.List, fun.Body.List...)<br>os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>printer.Fprint(&amp;buf, fset, fast)<br><br>fmt.Println(buf.String())<br><br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCode</span><span class="hljs-params">(fun *ast.FuncDecl)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// 函数名称</span><br>funcName := fun.Name.Name<br><br><span class="hljs-comment">// 参数列表</span><br>args := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> fun.Type.Params.List &#123;<br><span class="hljs-keyword">for</span> _, name := <span class="hljs-keyword">range</span> arg.Names &#123;<br>args = <span class="hljs-built_in">append</span>(args, name.Name)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 返回值列表</span><br>returns := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>returnRefs := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>returnNames := fun.Type.Results.List[<span class="hljs-number">0</span>].Names<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(returnNames) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; fun.Type.Results.NumFields(); i++ &#123;<br>fun.Type.Results.List[<span class="hljs-number">0</span>].Names = <span class="hljs-built_in">append</span>(fun.Type.Results.List[<span class="hljs-number">0</span>].Names,<br>&amp;ast.Ident&#123;Name: fmt.Sprintf(<span class="hljs-string">&quot;_xgo_res_%d&quot;</span>, i+<span class="hljs-number">1</span>)&#125;)<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> _, re := <span class="hljs-keyword">range</span> fun.Type.Results.List[<span class="hljs-number">0</span>].Names &#123;<br>returns = <span class="hljs-built_in">append</span>(returns, re.Name)<br>returnRefs = <span class="hljs-built_in">append</span>(returnRefs, <span class="hljs-string">&quot;&amp;&quot;</span>+re.Name)<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(newCodeFormat,<br>funcName,<br>strings.Join(args, <span class="hljs-string">&quot;,&quot;</span>),<br>strings.Join(returnRefs, <span class="hljs-string">&quot;,&quot;</span>),<br>strings.Join(returns, <span class="hljs-string">&quot;,&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, []interface&#123;&#125;&#123;%s&#125;, []interface&#123;&#125;&#123;%s&#125;) &#123;</span><br><span class="hljs-string">return %s</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>思路跟之前第 5步大同小异，不过是用遍历的方式来支持多个参数和多个返回值罢了。</p><p>现在我们为 <code>greet.go</code> 添加更多的测试函数，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet2</span><span class="hljs-params">(s2 <span class="hljs-type">string</span>)</span></span> (res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 2 &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet3</span><span class="hljs-params">(s3 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 3 &quot;</span> + s3<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair1</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Other</span><span class="hljs-params">(i <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, f <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;int: %d, string: %s, float: %f&quot;</span>, i, s, f)<br>&#125;<br></code></pre></td></tr></table></figure><p>为了测试，我们再次修改 <code>main.go</code>，使其覆盖所有的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Other&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, f <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;mock %d %s %.2f&quot;</span>, i, s, f)<br>&#125;)<br>res := Other(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">3.14</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 1 hello 3.14&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Other() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 1 hello 3.14&quot;</span>)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;run other successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Pair1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;)<br>res = Pair1(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 1 hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Pair1() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 1 hello world&quot;</span>)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;run pair1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Pair2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s1, <span class="hljs-string">&quot;mock 2 &quot;</span> + s2<br>&#125;)<br>res1, res2 := Pair2(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res1 != <span class="hljs-string">&quot;mock 2 hello&quot;</span> || res2 != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Pair2() = %q, %q; want %q, %q&quot;</span>, res1, res2, <span class="hljs-string">&quot;mock 2 hello&quot;</span>, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;run pair2 successfully&quot;</span>)<br><br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s<br>&#125;)<br>res = Greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet2() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 2 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 3 &quot;</span> + s<br>&#125;)<br>res = Greet3(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 3 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet3() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 3 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 3 successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>编译代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>执行生成的可执行程序，如果有以下输出，那我们就又成功进了一大大步了~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  06-toolexec-multi git:(master) ✗ ./main<br>2024/05/23 20:31:10 run other successfully<br>2024/05/23 20:31:10 run pair1 successfully<br>2024/05/23 20:31:10 run pair2 successfully<br>2024/05/23 20:31:10 run greet 1 successfully<br>2024/05/23 20:31:10 run greet 2 successfully<br>2024/05/23 20:31:10 run greet 3 successfully<br></code></pre></td></tr></table></figure><h1 id="更进一步">更进一步</h1><p>通过上面 6 个简单的小阶段，我们就已经把 <code>xgo</code>最最核心的功能给实现了，在一些小场景下还勉强能用？🤡</p><p>我们来看看包含测试代码和样例函数，总共用了多少代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  06-toolexec-multi git:(master) ✗ tokei .<br>===============================================================================<br> Language            Files        Lines         Code     Comments       Blanks<br>===============================================================================<br> Go                      4          281          224           11           46<br> Shell                   1            5            3            1            1<br>===============================================================================<br> Total                   5          286          227           12           47<br>===============================================================================<br></code></pre></td></tr></table></figure><p>短短 <strong>224</strong> 行代码，这是一个非常了不起的成就！</p><p>当然，优秀的读者肯定可以发现我们这个 <strong>丐版 xgo</strong>有太多的不足和缺陷了。这是必然的，我们来看看 <code>xgo</code> 截止<code>1.0.37</code> 版本，总共有多少行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">➜  xgo git:(master) tokei .<br>===============================================================================<br> Language            Files        Lines         Code     Comments       Blanks<br>===============================================================================<br> BASH                    <span class="hljs-number">1</span>          <span class="hljs-number">104</span>           <span class="hljs-number">81</span>           <span class="hljs-number">11</span>           <span class="hljs-number">12</span><br> CSS                     <span class="hljs-number">1</span>          <span class="hljs-number">153</span>          <span class="hljs-number">118</span>            <span class="hljs-number">5</span>           <span class="hljs-number">30</span><br> Go                    <span class="hljs-number">369</span>        <span class="hljs-number">33232</span>        <span class="hljs-number">26836</span>         <span class="hljs-number">2588</span>         <span class="hljs-number">3808</span><br> JavaScript              <span class="hljs-number">1</span>          <span class="hljs-number">170</span>          <span class="hljs-number">146</span>           <span class="hljs-number">10</span>           <span class="hljs-number">14</span><br> JSON                    <span class="hljs-number">2</span>          <span class="hljs-number">435</span>          <span class="hljs-number">435</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> PowerShell              <span class="hljs-number">1</span>           <span class="hljs-number">28</span>           <span class="hljs-number">16</span>            <span class="hljs-number">3</span>            <span class="hljs-number">9</span><br> Shell                   <span class="hljs-number">3</span>          <span class="hljs-number">288</span>          <span class="hljs-number">251</span>            <span class="hljs-number">4</span>           <span class="hljs-number">33</span><br> SVG                     <span class="hljs-number">1</span>           <span class="hljs-number">41</span>           <span class="hljs-number">41</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> Plain Text              <span class="hljs-number">7</span>          <span class="hljs-number">192</span>            <span class="hljs-number">0</span>          <span class="hljs-number">174</span>           <span class="hljs-number">18</span><br>-------------------------------------------------------------------------------<br> HTML                    <span class="hljs-number">1</span>           <span class="hljs-number">19</span>           <span class="hljs-number">16</span>            <span class="hljs-number">3</span>            <span class="hljs-number">0</span><br> |- JavaScript           <span class="hljs-number">1</span>            <span class="hljs-number">6</span>            <span class="hljs-number">6</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> (Total)                             <span class="hljs-number">25</span>           <span class="hljs-number">22</span>            <span class="hljs-number">3</span>            <span class="hljs-number">0</span><br>-------------------------------------------------------------------------------<br> Markdown               <span class="hljs-number">17</span>         <span class="hljs-number">1455</span>            <span class="hljs-number">0</span>         <span class="hljs-number">1083</span>          <span class="hljs-number">372</span><br> |- Go                   <span class="hljs-number">8</span>          <span class="hljs-number">820</span>          <span class="hljs-number">635</span>           <span class="hljs-number">72</span>          <span class="hljs-number">113</span><br> |- JSON                 <span class="hljs-number">1</span>           <span class="hljs-number">80</span>           <span class="hljs-number">80</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> (Total)                           <span class="hljs-number">2355</span>          <span class="hljs-number">715</span>         <span class="hljs-number">1155</span>          <span class="hljs-number">485</span><br>===============================================================================<br> Total                 <span class="hljs-number">404</span>        <span class="hljs-number">36117</span>        <span class="hljs-number">27940</span>         <span class="hljs-number">3881</span>         <span class="hljs-number">4296</span><br>===============================================================================<br></code></pre></td></tr></table></figure><p>光 Go 代码就有 <strong>26836</strong> 行了。所以可知 <code>xgo</code>的作者是做了很多的付出和努力的。不过我们用了不到百分之一的代码量，就将<code>xgo</code>最核心的原理展示得淋漓尽致了，感兴趣的读者可以进一步阅读<code>xgo</code> 的源码，可以进一步探索如何抽象出更通用更简洁更易扩展的interceptor，如何支持协程隔离，如何优化依赖管理，以及如何实现其他的trace、coverage 功能。再次为 <code>xgo</code> 打 call 👏！</p><h1 id="参考">参考</h1><ul><li><a href="https://github.com/xhd2015/xgo">xgo repo</a></li><li><ahref="https://docs.google.com/presentation/d/1U5yTdrUjnManxztzsMPGBAePrE3HvJcDtRjV6h3HelA/edit#slide=id.g2705943ae25_0_50">xgo:基于代码重写实现 Monkey Patch 和 Trace</a></li><li><ahref="https://github.com/golang/go/tree/release-branch.go1.22/src/cmd/compile">gocompile README</a></li><li><ahref="https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/">xgo:在 go 中使用-toolexec 实现猴子补丁</a></li></ul>]]></content>
    
    
    <summary type="html">xgo 是一个通过代码重写来实现 mock、trace 和 coverage 功能的单元测试框架。本文将探讨 xgo 最核心的底层原理 -toolexec，并通过 6 个简单的小阶段，一步步实现一个丐版 xgo，进一步展示 xgo 的设计理念。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="开源项目" scheme="https://hedon.top/categories/Go/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="开源项目" scheme="https://hedon.top/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>xgo 使用经验</title>
    <link href="https://hedon.top/2024/05/21/go-xgo-use/"/>
    <id>https://hedon.top/2024/05/21/go-xgo-use/</id>
    <published>2024-05-21T08:32:51.000Z</published>
    <updated>2024-05-22T13:26:45.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="patch">Patch</h1><h2 id="mock-函数">mock 函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPatchFunc</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.Patch(greet, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br><br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced mock world got %s&quot;</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mock-变量">mock 变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> value = <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> value + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPatchVar</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.Patch(&amp;value, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span><br>&#125;)<br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced mock world got %s&quot;</span>, res)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPatchVarByName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.PatchByName(<span class="hljs-string">&quot;learn-xgo/api&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span><br>&#125;)<br>res := greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced mock world got %s&quot;</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="mock">Mock</h1><blockquote><p>因此，当函数含有未导出类型时，<code>Patch</code>无法使用，此时可以使用 <code>Mock</code>。</p></blockquote><h2 id="mockbyname">MockByName</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// learn-xgo/funcs/funcs.go</span><br><span class="hljs-keyword">package</span> funcs<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CallUnexportedFunc</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> unexportedFunc(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unexportedFunc</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;origin unexported func, your msg is &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// learn-xgo/api/mock_test.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMockByName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.MockByName(<span class="hljs-string">&quot;learn-xgo/funcs&quot;</span>, <span class="hljs-string">&quot;unexportedFunc&quot;</span>,<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, fn *core.FuncInfo, args core.Object, results core.Object)</span></span> <span class="hljs-type">error</span> &#123;<br>results.GetFieldIndex(<span class="hljs-number">0</span>).Set(<span class="hljs-string">&quot;mock funcs &quot;</span> + args.GetFieldIndex(<span class="hljs-number">0</span>).Value().(<span class="hljs-type">string</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><br>msg := funcs.CallUnexportedFunc(<span class="hljs-string">&quot;hedon&quot;</span>)<br><span class="hljs-keyword">if</span> msg != <span class="hljs-string">&quot;mock funcs hedon&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced `mock funcs hedon` got %s&quot;</span>, msg)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">x</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="开源项目" scheme="https://hedon.top/categories/Go/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="开源项目" scheme="https://hedon.top/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 负载均衡挑战及解决思路</title>
    <link href="https://hedon.top/2024/05/20/kafka-load-balance/"/>
    <id>https://hedon.top/2024/05/20/kafka-load-balance/</id>
    <published>2024-05-20T02:37:10.000Z</published>
    <updated>2024-05-21T14:41:10.216Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自 Agoda Engineering，介绍了在实际应用中，如何应对 Kafka负载均衡所遇到的各种挑战，并提出相应的解决思路。本文简要阐述了 Kafka的并行性机制、常用的分区策略以及在实际操作中遇到的异构硬件、不均匀工作负载等问题。通过深入分析这些挑战，并提供具体的解决方案，本文旨在帮助读者更好地理解和应用Kafka 的负载均衡技术，从而提高系统的整体性能和稳定性。</p><p>以下大部分内容翻译自原文 <ahref="https://medium.com/agoda-engineering/how-we-solve-load-balancing-challenges-in-apache-kafka-8cd88fdad02b">how-we-solve-load-balancing-challenges-in-apache-kafka</a>，并已获得原作者同意。</p><h1 id="思维导图">思维导图</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Kafka%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"alt="Kafka 负载均衡解决方案" /><figcaption aria-hidden="true">Kafka 负载均衡解决方案</figcaption></figure><h1 id="kafka-并行性">Kafka 并行性</h1><p>Kafka通过分区来实现并行性，如下图所示，生产者（Producer）产生的消息会按照一定的分区策略分配到多个分区（Partition）中，消费组中的每个消费者会分别负责消费其中的若干个分区。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*ixosAmhBDsyBBhoS.png"alt="Kafka 分区演示" /><figcaption aria-hidden="true">Kafka 分区演示</figcaption></figure><p>分区策略：</p><ul><li>轮询（Round Robin）：默认情况下，Kafka使用轮询策略将消息均匀地分配到所有分区。</li><li>哈希（Key Hashing）：如果消息有分区键，Kafka会对键进行哈希计算，将消息分配到特定的分区。</li><li>自定义分区策略：开发者可以实现自定义的分区器（Partitioner）逻辑，以满足特定需求。</li></ul><p>如果要使用轮询或者哈希策略来达到“负载均衡”的目的，那么需要满足以下 2个假设：</p><ol type="1"><li>消费者拥有相同的处理能力，</li><li>消息的工作量相等。</li></ol><p>然而，在实践中，这些假设往往不成立。</p><h1 id="现实挑战">现实挑战</h1><h2 id="异构硬件">1. 异构硬件</h2><p>不同代的服务器硬件性能不同，导致处理速率存在差异。例如，使用不同代硬件进行处理的基准显示性能存在显着差异：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1*B6svY0ZjYVy-uJ7ZA18Jtg.png"alt="不同服务器处理速率差异举例" /><figcaption aria-hidden="true">不同服务器处理速率差异举例</figcaption></figure><h2 id="每条-kafka-消息的工作负载不均匀">2. 每条 Kafka消息的工作负载不均匀</h2><p>下图显示了在一个时间窗口内到达的 12条消息。在这里，生产者向该主题中的六个分区中的每一个发布两条消息。因此，每个worker 消耗来自 2 个分区的数据，这意味着每个 worker 需要处理 4条消息。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*VwPda5gNsHRL2tJV.png"alt="使用循环分区器和循环分配器来分发消息的先前供应系统的演示。每个 worker 都分配有相同数量的消息。" /><figcaptionaria-hidden="true">使用循环分区器和循环分配器来分发消息的先前供应系统的演示。每个worker 都分配有相同数量的消息。</figcaption></figure><p>不同的消息可能需要不同的处理步骤集。例如，处理消息可能涉及调用第三方HTTP端点，并且不同的响应大小或延迟可能会影响处理速率。此外，对于涉及数据库操作的应用程序，其数据库查询的延迟可能会根据查询参数而波动，从而导致处理速率发生变化。</p><h2 id="过度配置问题">3. 过度配置问题</h2><p>由于工作负载和处理效率不同，为了达到系统吞吐量的需求，可能会出现过度配置问题，从而导致资源浪费。</p><p>假设我们的高吞吐量和低吞吐量的处理速率分别为 20 msg/s 和 10msg/s（根据表 1中的数据进行简化）。使用两个较快的处理器和一个较慢的处理器，我们预计总容量为20+20+10 = 50条消息/秒。但是，当保持消息的循环分配时，我们无法达到此容量。下图显示了如果流量持续达到每秒50 条消息时会发生什么情况。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*P-Qa3gyPgXtIeZMx.png"alt="如果传入流量保持在 50 条消息/秒，则慢速处理器无法处理总体消息 1/3 的负载，从而导致累积延迟。为了避免高延迟，向该系统添加了额外的资源以维持处理。" /><figcaption aria-hidden="true">如果传入流量保持在 50条消息/秒，则慢速处理器无法处理总体消息 1/3的负载，从而导致累积延迟。为了避免高延迟，向该系统添加了额外的资源以维持处理。</figcaption></figure><p>从这个例子中我们可以看到，我们的处理器服务一次最多只能接受 30条消息，以防止滞后并确保及时传递更新。</p><p>在这种情况下，要实际每秒处理 50 条消息，我们必须总共扩展到 5台机器，以保证及时处理所有消息。由于这种不适当的分配逻辑（66.7％的过度配置），我们会向该系统过度配置额外的两台机器。</p><p>为了每秒处理 50条消息，我们需要扩展到五台机器以确保及时处理所有消息。由于这种不适当的分配逻辑（66.7%的过度配置），这会导致向该系统过度配置两台额外的机器。</p><h1 id="静态解决方案">静态解决方案</h1><h2 id="在相同的-pod机器上部署">1. 在相同的 Pod（机器）上部署</h2><p>考虑控制服务部署中使用的硬件类型以缓解问题。如果您在虚拟机上部署服务并拥有充足的资源和性能相同的硬件，则此方法是可行的。</p><p>然而，由于成本效益和灵活性下降，在私有云环境中通常不建议采用这种策略，主要是因为同时升级所有现有硬件可能具有挑战性。如果它非常适合您的情况，则可以使用<ahref="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/">Kubernetes关联性将 Pod 分配给某些类型的节点。</a></p><h2 id="加权负载均衡">2. 加权负载均衡</h2><p>如果容量是可预测的并且大部分时间保持静态，则为不同的消费者分配不同的权重可以帮助最大限度地利用可用资源。例如，在为表现较好的消费者赋予更高的权重后，我们可以将更多流量路由给这些消费者。</p><h1 id="动态解决方案">动态解决方案</h1><p>虽然我们可以估计消息的容量和工作负载来设计静态规则来确定加权负载平衡策略，但由于以下几个因素，这种方法在实际生产环境中可能并不总是可行：</p><ul><li>消息的工作负载并不统一，这使得估计机器容量变得困难。</li><li>依赖关系（例如网络和第三方连接）不稳定，有时会导致实际处理中的容量发生变化。</li><li>该系统经常添加新功能，增加额外的维护工作以保持权重更新。</li></ul><p>为了解决这些问题，我们可以动态监控每个分区中的当前滞后并根据当前流量状况做出相应响应。</p><p>有 2 种思路：</p><ol type="1"><li><strong>生产者角度</strong>：使用自定义算法根据滞后的消息数量来确定每个分区的流量，这种生产者称为滞后感知生产者（Lag-awareProducer）。</li><li><strong>消费者角度</strong>：这些消费者旨在监控当前滞后的消息数量，并可以在必要时取消订阅以触发负载重新平衡。通常，可以采用自定义的重新平衡策略来调整分区分配。这种消费者称为滞后感知消费者（Lag-awareComsumer）。</li></ol><h2 id="从生产者角度出发">1. 从生产者角度出发</h2><p>如此图所示，生产者可以使用自定义算法根据滞后确定每个分区的流量。为了减少对Kafka代理的调用次数，系统可以维护一个内部延迟缓存，而不是在发布每条消息之前调用Kafka 代理。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*Mg1lxKzMTy7LRAXT.png"alt="在此示例中，分区 4 和 6 的延迟比其他分区高得多。应减少从内部生产者发送到这些分区的流量。" /><figcaption aria-hidden="true">在此示例中，分区 4 和 6的延迟比其他分区高得多。应减少从内部生产者发送到这些分区的流量。</figcaption></figure><p>使用滞后数据，定制的算法被设计为向经历高滞后的分区发布更少的流量，向低滞后的分区发布更多流量，以平衡每个分区上的工作负载。当滞后平衡且稳定时，此方法应确保消息的均匀分布。</p><p>不适用情况：</p><ol type="1"><li><strong>纯消费者应用程序</strong>：您的应用程序不控制消息生成。</li><li><strong>多个消费者组：</strong>当生成的消息被多个消费者组消费时，生产者可能会为其他消费者组产生不必要的倾斜负载，因为滞后只是特定于一个消费者组的信息。</li></ol><h3 id="相同队列长度算法">相同队列长度算法</h3><p>该算法将每个分区滞后视为处理的队列大小。获取滞后信息后，它会发布适当数量的消息以填充短队列。此方法更适合由于异构硬件而导致的倾斜滞后分布，其中高性能Pod（机器）在大多数情况下能够更快地处理。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*zp-S1Y_GbIzbjCX4.png"alt="相同队列长度算法的演示。最初，不同队列的长度不同。该算法尝试生成不同数量的消息，以在所有队列中实现相同的队列长度。这里，队列长度和 Kafka lag 是同一个概念，代表尚未处理的消息数量" /><figcaptionaria-hidden="true">相同队列长度算法的演示。最初，不同队列的长度不同。该算法尝试生成不同数量的消息，以在所有队列中实现相同的队列长度。这里，队列长度和Kafka lag 是同一个概念，代表尚未处理的消息数量</figcaption></figure><h3 id="异常值检测算法">异常值检测算法</h3><p>该算法利用统计方法来确定所有分区的上离群值，并暂时停止那些慢速离群值的发布过程。在原文章中，针对Agoda 的特定需求，他们提出了 IQR（四分位距）和STD（标准差）异常值检测算法。算法流程图如下所示。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*pjkj5kF6aFcWwBwU.png"alt="异常值检查算法流程" /><figcaption aria-hidden="true">异常值检查算法流程</figcaption></figure><ul><li><strong>慢速分区：</strong>（已关闭）由于存在延迟，这些分区的消息生成已停止。</li><li><strong>好的分区</strong>：（打开）照常发布并均匀分发到所有好的分区。</li><li><strong>OK分区：</strong>（观察/半开放）为了提高性能不佳的机器的性能，当系统尝试将慢速分区提升为良好分区时，会添加一个观察期。通过仅生成一小部分消息并进行观察，可以将该观察阶段优化为“半开放”状态。当滞后获取间隔相对较长时，半开放是有益的，因为它可以防止消费者延迟等待传入消息而更新的滞后数据尚未查询的情况。</li></ul><h2 id="从消费者角度出发">2. 从消费者角度出发</h2><p>这里 Adoga提出的思路是：<strong>遇到高延迟的实例可以主动取消订阅主题以触发重新平衡。在重新平衡期间，可以使用自定义的分配器来平衡所有消费者实例之间的分区。</strong></p><p>触发重新平衡的成本非常昂贵，因为急切的重新平衡会停止消费者组中的所有处理。Kafka2.4中引入的<ahref="https://www.confluent.io/blog/incremental-cooperative-rebalancing-in-kafka/">增量协作再平衡协议</a>已经最大限度地减少了性能影响，允许更频繁的再平衡以更好地分配每个分区上的负载。</p><p>为了增强重新分配的灵活性，分区的数量应该大于 worker的数量。这一比率应根据应用程序而有所不同，并假设一个工作线程至少可以处理来自一个分区的负载以避免饥饿。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*68P7QtdFGeIzwZSs.png"alt="在此示例中，工作程序 3 在速度较慢的硬件上运行，导致分区 5 和 6 出现更高的延迟。因此，工作程序 3 可能会主动取消订阅主题以触发重新平衡并更有效地重新分配分区。在此示例中，应实现自定义分配器以根据机器指标和滞后信息重新分配分区。" /><figcaption aria-hidden="true">在此示例中，工作程序 3在速度较慢的硬件上运行，导致分区 5 和 6 出现更高的延迟。因此，工作程序 3可能会主动取消订阅主题以触发重新平衡并更有效地重新分配分区。在此示例中，应实现自定义分配器以根据机器指标和滞后信息重新分配分区。</figcaption></figure><h1 id="总结">总结</h1><p>本文从 Kafka 并行性的一般实现出发，探讨了 Kafka实现负载均衡在现实实践中可能遇到的各种挑战，并从静态调整和动态调整两个方面给出了解决思路，特别注重讨论了动态调整策略，并分别从生产者和消费者的角度提出了解决方案。</p><p>总之，通过在 Kafka中实现负载均衡，可以有效地将工作负载分配到可用资源之间，从而显著提高服务性能。具体的算法和策略需要根据实际情况进行选择和调整。</p>]]></content>
    
    
    <summary type="html">本文转载自 Agoda Enginnering, 介绍了 Kafka 负载均衡的实际应用过程中的负载均衡挑战及解决思路。</summary>
    
    
    
    <category term="Kafka" scheme="https://hedon.top/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://hedon.top/tags/Kafka/"/>
    
    <category term="中间件" scheme="https://hedon.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="消息队列" scheme="https://hedon.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>学习记录：用 Go 自制解释器 Monkey</title>
    <link href="https://hedon.top/2024/05/12/monkey-language/"/>
    <id>https://hedon.top/2024/05/12/monkey-language/</id>
    <published>2024-05-11T19:44:15.000Z</published>
    <updated>2024-05-12T11:59:36.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="词法分析">词法分析</h1><p>TDD：测试驱动开发</p><p>先写测试用例，再进行词法分析逻辑的完善。</p><h1 id="语法分析">语法分析</h1><p>递归下降语法分析伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go">function parseProgram() &#123;<br>    program = newProgramASTNode()<br>    advanceTokens()<br>    <span class="hljs-keyword">for</span> (currentToken() != EOF_TOKEN) &#123;<br>        statement = null<br>        <span class="hljs-keyword">if</span> (currentToken() == LET_TOKEN) &#123;<br>            statement = parseLetStatement()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken() == RETURN_TOKEN) &#123;<br>            statement = parseReturnStatement()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken() == IF_TOKEN) &#123;<br>            statement = parseIfStatement()<br>        &#125;<br>        <span class="hljs-keyword">if</span> (statement != null) &#123;<br>            program.Statements.push(statement)<br>        &#125;<br>        advanceTokens()<br>    &#125;<br>    <span class="hljs-keyword">return</span> program<br>&#125;<br>function parseLetStatement() &#123;<br>    advanceTokens()<br>    identifier = parseIdentifier()<br>    advanceTokens()<br>    <span class="hljs-keyword">if</span> currentToken() != EQUAL_TOKEN &#123;<br>        parseError(<span class="hljs-string">&quot;no equal sign!&quot;</span>)<br>        <span class="hljs-keyword">return</span> null<br>    &#125;<br>    advanceTokens()<br>    value = parseExpression()<br>    variableStatement = newVariableStatementASTNode()<br>    variableStatement.identifier = identifier<br>    variableStatement.value = value<br>    <span class="hljs-keyword">return</span> variableStatement<br>&#125;<br>function parseIdentifier() &#123;<br>    identifier = newIdentifierASTNode()<br>    identifier.token = currentToken()<br>    <span class="hljs-keyword">return</span> identifier<br>&#125;<br>function parseExpression() &#123;<br>    <span class="hljs-keyword">if</span> (currentToken() == INTEGER_TOKEN) &#123;<br>        <span class="hljs-keyword">if</span> (nextToken() == PLUS_TOKEN) &#123;<br>            <span class="hljs-keyword">return</span> parseOperatorExpression()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextToken() == SEMICOLON_TOKEN) &#123;<br>            <span class="hljs-keyword">return</span> parseIntegerLiteral()<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken() == LEFT_PAREN) &#123;<br>        <span class="hljs-keyword">return</span> parseGroupedExpression()<br>    &#125;<br><span class="hljs-comment">// [...]</span><br>&#125;<br>function parseOperatorExpression() &#123;<br>    operatorExpression = newOperatorExpression()<br>    operatorExpression.left = parseIntegerLiteral()<br>    operatorExpression.operator = currentToken()<br>    operatorExpression.right = parseExpression()<br>    <span class="hljs-keyword">return</span> operatorExpression()<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512042659060.png"alt="递归下降分析法" /><figcaption aria-hidden="true">递归下降分析法</figcaption></figure><h2 id="let-x5">let x=5</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512035446100.png"alt="let stmt AST structure" /><figcaption aria-hidden="true">let stmt AST structure</figcaption></figure><h2 id="return-5">return 5</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512045650041.png"alt="return stmt AST structue" /><figcaption aria-hidden="true">return stmt AST structue</figcaption></figure><h2 id="普拉特解析">普拉特解析</h2>]]></content>
    
    
    <summary type="html">本文主要是记录笔者在学习《用 Go 自制解释器 Monkey》过程中涉及的重要设计理念和思考。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="Go 实战" scheme="https://hedon.top/categories/Go/Go-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="编译原理" scheme="https://hedon.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>时间处理基础：Rust 的 chrono 库教程</title>
    <link href="https://hedon.top/2024/05/11/rust-crate-chrono/"/>
    <id>https://hedon.top/2024/05/11/rust-crate-chrono/</id>
    <published>2024-05-11T15:52:55.000Z</published>
    <updated>2024-05-11T17:02:48.217Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中，我们经常有对时间和日期处理的需求。不论是日历应用、日程安排、还是时间戳记录，准确的时间数据处理都是必不可少的。Rust社区提供的 <code>chrono</code> 库以其强大的功能和灵活的接口，在 Rust开发者中广受欢迎。本文将简单介绍 <code>chrono</code>库，展示如何利用它来精确处理和转换时间和日期，帮助你在任何 Rust项目中都能高效地管理时间。</p><h1 id="版本">版本</h1><ul><li><code>chrono</code>: 0.4.38</li></ul><h1 id="结论先行">结论先行</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512010241356.png"alt="chrono 各种时间类型转换图" /><figcaption aria-hidden="true">chrono 各种时间类型转换图</figcaption></figure><h1 id="时间相关概念">时间相关概念</h1><table><thead><tr class="header"><th>概念</th><th>理解</th></tr></thead><tbody><tr class="odd"><td>UNIX 时间戳（UNIX Timestamp）</td><td>也称为 POSIX 时间或 Epoch 时间，是自 1970 年 1 月 1 日（UTC时区）以来经过的秒数，不计入闰秒。这是一种非常通用的时间表示方法，在编程中广泛使用，因为它可以简化时间差的计算。</td></tr><tr class="even"><td>UTC（协调世界时）</td><td>全称为协调世界时（Coordinated UniversalTime），是目前国际上广泛采用的时间标准。它基本上与格林威治平均时（GMT）相同，但在技术上更加精确，因为它使用原子钟来保持时间准确。世界各地的时间都是以UTC 为基础，加上或减去一定的小时数来定义的。</td></tr><tr class="odd"><td>时区（Time Zone）</td><td>时区是地球上划分的标准时间区域。由于地球自西向东旋转，每向东移动一定角度，当地的太阳时间就会相应地提前。世界被分成了24个时区，每个时区通常相差一小时。时区允许地区内的人们能在大致相同的时间内，经历类似的日夜更替模式。</td></tr><tr class="even"><td>UTC+8</td><td>UTC+8 是 UTC 时间加上 8小时的时间区。中国大陆就是位于这个时区。例如，当 UTC 时间为 00:00时，UTC+8 的时间就是 08:00。</td></tr></tbody></table><h1 id="chrono-关键类型">chrono 关键类型</h1><table><thead><tr class="header"><th>类型</th><th>含义</th><th>适用场景</th></tr></thead><tbody><tr class="odd"><td>DateTime&lt;Tz&gt;</td><td>一个带有时区的日期和时间类型，其中 <code>Tz</code> 是实现了<code>TimeZone</code> 特质的类型，如 <code>Utc</code> 和<code>Local</code> 。这意味着 <code>DateTime</code>考虑了时区的影响，可以表示全球任意地点的精确时间。</td><td>广泛用于需要考虑时区转换的场景，如存储用户的本地时间或在不同地区之间转换时间。</td></tr><tr class="even"><td>NaiveDateTime</td><td>一个“天真的”日期和时间，即不包含任何时区信息的日期和时间。这种类型仅仅表示一个日历日期和一天中的时间，而没有任何关于地理或政治时区的数据。</td><td>对于一些时区不重要的场景非常有用，比如记录电影的发行日期或历史事件的日期。</td></tr><tr class="odd"><td>NaiveDate</td><td>仅表示一个日历日期，不包括时间或时区信息。</td><td>它用于处理只需要日期而不关心具体时间的场景，如生日、节日等。</td></tr><tr class="even"><td>NaiveTime</td><td>是一个只表示一天中时间的类型，它不包含日期或时区信息。</td><td>这个类型适用于需要处理具体某个时间点（如开会时间、日常活动的开始时间）但不需要日期数据的情景。</td></tr></tbody></table><h1 id="chrono-时区类型">chrono 时区类型</h1><p><code>chrono</code>支持多种时区类型，方便进行全球时间的转换和计算：</p><ul><li><strong><code>Utc</code></strong>: 用于处理协调世界时。</li><li><strong><code>Local</code></strong>:代表服务器或用户的本地时区。</li><li><strong><code>FixedOffset</code></strong>:允许定义任意的小时和分钟偏移量，适合固定偏移的时间计算。</li></ul><h1 id="常用功能">常用功能</h1><h2 id="获取当前时间">获取当前时间</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span>: DateTime&lt;Local&gt; = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">utc_datetime</span>: DateTime&lt;Utc&gt; = Utc::<span class="hljs-title function_ invoke__">now</span>();<br></code></pre></td></tr></table></figure><h2 id="datetime-转-string">DateTime 转 String</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">to_rfc2822</span>()); <span class="hljs-comment">// Sun, 12 May 2024 00:15:55 +0800</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">to_rfc3339</span>()); <span class="hljs-comment">// 2024-05-12T00:15:55.325058+08:00</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">to_string</span>()); <span class="hljs-comment">// 2024-05-12 00:15:55.325058 +08:00</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.format(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)) <span class="hljs-comment">// 2024-05-12 00:15:55</span><br></code></pre></td></tr></table></figure><h2 id="string-转-datetime">String 转 DateTime</h2><p>字符串带时区信息，使用<code>DateTime::parse_from_str(s, f)</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">format_withzone</span> = <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">datetime_withzone_str</span> = <span class="hljs-string">&quot;2024-01-01 00:00:00 +08:00&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span> =<br>    DateTime::<span class="hljs-title function_ invoke__">parse_from_str</span>(&amp;datetime_withzone_str, &amp;format_withzone).<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><p>字符串无时区信息，使用<code>NaiveDateTime::parse_from_str(s, f)</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">format</span> = <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">datetime_str</span> = <span class="hljs-string">&quot;2024-01-01 00:00:00&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span> = NaiveDateTime::<span class="hljs-title function_ invoke__">parse_from_str</span>(&amp;datetime_str, &amp;format)<br>    .<span class="hljs-title function_ invoke__">unwrap</span>()<br>    .<span class="hljs-title function_ invoke__">and_local_timezone</span>(Local) <span class="hljs-comment">// 转为带时区的 DateTime</span><br>    .<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><h2 id="datetime-转-timestamp">DateTime 转 timestamp</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span> = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;seconds: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp</span>()); <span class="hljs-comment">// 1715444324</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;millis: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp_millis</span>()); <span class="hljs-comment">// 1715444338610</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;micros: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp_micros</span>()); <span class="hljs-comment">// 1715444338610873</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;nacos: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp_nanos_opt</span>().<span class="hljs-title function_ invoke__">unwrap</span>()); <span class="hljs-comment">// 1715444338610873000</span><br></code></pre></td></tr></table></figure><h2 id="timestamp-转-datetime">timestamp 转 DateTime</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">utc_datetime</span>: DateTime&lt;Utc&gt; = DateTime::<span class="hljs-title function_ invoke__">from_timestamp</span>(<span class="hljs-number">1704139200</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// 默认是 Utc</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span>: DateTime&lt;Local&gt; = DateTime::<span class="hljs-title function_ invoke__">from_timestamp</span>(<span class="hljs-number">1704139200</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">into</span>(); <span class="hljs-comment">// 使用 into() 转为 Local</span><br></code></pre></td></tr></table></figure><h2 id="时区转换">时区转换</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> chrono::&#123;DateTime, FixedOffset, Utc&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">utc_date_time</span>: DateTime&lt;Utc&gt; = Utc::<span class="hljs-title function_ invoke__">now</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">fixed_offset</span> = FixedOffset::<span class="hljs-title function_ invoke__">east</span>(<span class="hljs-number">8</span> * <span class="hljs-number">3600</span>); <span class="hljs-comment">// 转为 utc+8 东八区</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">local_date_time</span> = utc_date_time.<span class="hljs-title function_ invoke__">with_timezone</span>(&amp;fixed_offset);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Local time in UTC+8: &#123;&#125;&quot;</span>, local_date_time);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间计算">时间计算</h2><p>时间加减：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> chrono::&#123;Duration, Local&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">now</span> = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">yesterday</span> = now - Duration::<span class="hljs-title function_ invoke__">hours</span>(<span class="hljs-number">24</span>);<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512002330526.png"alt="chrono time duration methods" /><figcaption aria-hidden="true">chrono time duration methods</figcaption></figure><p>时间间隔：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> chrono::&#123;Duration, Local&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">now</span> = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">yesterday</span> = now - Duration::<span class="hljs-title function_ invoke__">hours</span>(<span class="hljs-number">24</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">hour_interval</span> = (now - yesterday).<span class="hljs-title function_ invoke__">num_hours</span>();<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512002106738.png"alt="chrono time interval methods" /><figcaption aria-hidden="true">chrono time interval methods</figcaption></figure><h1 id="总结">总结</h1><p>通过本文的详细介绍和实用示例，我们了解了如何使用 Rust 的<code>chrono</code> 库来精确处理时间和日期。<code>chrono</code>不仅支持复杂的时区计算和全球时间管理，还提供了方便的日期时间解析和格式化工具，以及灵活的时间运算功能。掌握了这些技能后，你将能够在任何需要精确时间数据处理的Rust 应用中，提供稳定和高效的解决方案。</p><p>时间是每个程序的基石，而 <code>chrono</code>就是那把能够操纵时间的魔杖。</p><p>希望本文能对你有帮助，peace! enjoy coding~</p><blockquote><p>参考：</p><ul><li><a href="https://docs.rs/chrono/latest/chrono/">chronocrate</a></li><li><ahref="https://blog.stackademic.com/rust-working-with-date-and-time-30e003cd59e8">rust-working-with-date-and-time</a></li></ul><p>作图：</p><ul><li>https://excalidraw.com/</li></ul></blockquote>]]></content>
    
    
    <summary type="html">本文全面的指南深入介绍了如何在 Rust 中使用 chrono 库来精确处理和转换时间与日期。从基本概念到高级功能，本文提供了实用的代码示例和详尽的解释，帮助你在任何 Rust 项目中高效管理时间。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 常用库" scheme="https://hedon.top/categories/Rust/Rust-%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>epoll</title>
    <link href="https://hedon.top/2024/04/28/epoll/"/>
    <id>https://hedon.top/2024/04/28/epoll/</id>
    <published>2024-04-28T12:27:29.000Z</published>
    <updated>2024-05-06T09:11:27.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><code>epoll</code> 是一种 I/O多路复用技术，主要用于高性能的网络服务器中，特别是在处理大量并发连接时。它是Linux 特有的，自 Linux 内核 2.5.44版本引入，并在后续版本中不断优化。<code>epoll</code>能够帮助服务器高效地管理数以千计的客户端连接，是 <code>select</code> 和<code>poll</code> 方法的现代替代品。</p><p>本文不对 <code>epoll</code>的源码进行分析，仅做原理上的总结，方便快速查阅回顾。各大论坛很多大佬都对<code>epoll</code>的源码进行了详尽的分析，感兴趣的读者可以看「参考」篇章。</p><h1 id="主要特点">主要特点</h1><ol type="1"><li><strong>效率高</strong>: 相较于 <code>select</code> 和<code>poll</code>，<code>epoll</code>可以更高效地处理大量的并发连接。<code>select</code> 和 <code>poll</code>的效率随着监视的文件描述符数量增加而线性下降，而 <code>epoll</code>则不会因为监视的文件描述符数量增加而显著降低效率。</li><li><strong>扩展性好</strong>: <code>epoll</code>使用一种称为事件通知的机制，只会处理那些真正发生了事件的文件描述符。这意味着系统不必重新检查所有文件描述符，从而大大减少了不必要的CPU 开销。</li><li><strong>支持边缘触发和水平触发</strong>: <code>epoll</code> 支持<code>Edge Triggered</code> 和水平触发 <code>Level Triggered</code>两种模式。边缘触发模式只在文件描述符状态改变时才通知应用程序，适用于非阻塞I/O；而水平触发模式则在有事件可读或可写时都会通知应用程序，更容易使用但效率略低。</li></ol><h1 id="结论先行">结论先行</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240429121302958.png"alt="epoll flow chart" /><figcaption aria-hidden="true">epoll flow chart</figcaption></figure><h1 id="工作原理">工作原理</h1><p><code>epoll</code> 的工作可以分为三个主要步骤：</p><ol type="1"><li><strong>创建 epoll 实例</strong>: 使用 <code>epoll_create</code>函数创建一个 <code>epoll</code> 实例。</li><li><strong>添加/修改/删除文件描述符</strong>: 使用<code>epoll_ctl</code> 函数将新的文件描述符添加到 <code>epoll</code>实例中，或者修改、删除已存在的文件描述符。这些操作与文件描述符的数量无关，因此执行速度非常快。</li><li><strong>等待事件发生</strong>: 使用 <code>epoll_wait</code>函数等待事件的发生。这个函数可以同时监控多个文件描述符，当指定的文件描述符上发生了注册的事件时，函数返回，并告知哪些文件描述符上发生了事件。</li></ol><h1 id="et-lt">ET &amp; LT</h1><p>在 <code>epoll</code> 中，边缘触发（ET, EdgeTriggered）和水平触发（LT, LevelTriggered）是两种不同的事件通知方式，它们定义了操作系统如何通知应用程序文件描述符上的I/O 事件。</p><p>这两种模式的主要区别在于何时以及如何多次通知应用程序关于某个文件描述符的事件。</p><h2 id="水平触发level-triggered">水平触发（Level Triggered）</h2><ul><li><strong>定义</strong>: 在水平触发模式下，只要文件描述符上有未处理的I/O 事件存在，<code>epoll_wait</code>就会通知应用程序。这意味着，如果数据可读取但未被完全读取，<code>epoll_wait</code>会在下次调用时再次返回该文件描述符。</li><li><strong>行为</strong>:这种模式更容易编程，因为应用程序可以不用担心在一个操作中处理所有数据。如果数据还在，<code>epoll_wait</code>会继续通知你。</li><li><strong>适用场景</strong>:更适合那些简单的应用或者对实时性要求不是非常高的应用，因为它简化了处理逻辑。</li></ul><h2 id="边缘触发edge-triggered">边缘触发（Edge Triggered）</h2><ul><li><strong>定义</strong>:在边缘触发模式下，只有状态变化时（例如从无数据到有数据），<code>epoll_wait</code>才会通知应用程序。一旦通知了应用程序某事件发生，除非有新的数据到达或状态再次发生变化，否则不会再次通知应用程序该事件。</li><li><strong>行为</strong>:这要求应用程序必须立即处理所有事件，因为之后不会再收到关于这些事件的通知。这意味着应用程序必须循环读取或写入，直到数据被完全处理完，以确保不遗漏任何事件。</li><li><strong>适用场景</strong>:适合需要高性能的场景，因为它减少了事件处理的次数，但要求程序必须更加小心地管理I/O 操作。</li></ul><h2 id="比较和选择">比较和选择</h2><ul><li><strong>性能</strong>:边缘触发通常提供更高的性能，因为它减少了系统调用的次数和不必要的事件处理。</li><li><strong>编程复杂性</strong>:边缘触发模式编程比水平触发复杂，因为需要确保每次事件被彻底处理，并且更容易遇到如“惊群效应”（多个进程或线程被同一个事件唤醒）等问题。</li><li><strong>可靠性</strong>:水平触发因为其简单的行为模式，在可靠性处理上更为直接和容易。</li></ul><p>通常，选择哪种模式取决于应用的具体需求、预期的负载以及开发者对事件处理逻辑的控制程度。高性能服务器通常选择边缘触发模式，以最大化其效率，而简单的或者低负载应用可能会更倾向于使用水平触发，以简化开发和调试过程。</p><h1 id="数据结构">数据结构</h1><p><code>epoll</code> 使用 2种关键的数据结构来维护和跟踪文件描述符（FD）和事件：</p><ol type="1"><li><strong>红黑树（Red-Black Tree）</strong>:用于存储所有注册的文件描述符及其事件。红黑树是一种自平衡二叉搜索树，能够在对数时间内完成插入、删除和查找操作，这使得管理大量文件描述符变得高效。</li><li><strong>就绪列表（Ready List）</strong>:当事件发生（如可读、可写等）并被内核检测到时，相应的 FD会被添加到一个就绪列表中。这个列表仅包含实际有事件发生的文件描述符，从而减少了<code>epoll_wait</code> 调用的处理时间。</li></ol><h1 id="工作细节">工作细节</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/epoll_principle.jpg"alt="epoll data structure" /><figcaption aria-hidden="true">epoll data structure</figcaption></figure><ol type="1"><li>通过调用 <code>epoll_create()</code> 函数创建并初始化一个<code>eventpoll</code> 对象。</li><li>通过调用 <code>epoll_ctl()</code> 函数把被监听的文件句柄 (如 socket句柄) 封装成 <code>epitem</code> 对象并且添加到 <code>eventpoll</code>对象的红黑树中进行管理。</li><li>通过调用 <code>epoll_wait()</code>函数等待被监听的文件状态发生改变。</li><li>当被监听的文件状态发生改变时（如 socket接收到数据），会把文件句柄对应 <code>epitem</code> 对象添加到<code>eventpoll</code> 对象的就绪队列 <code>rdllist</code>中。并且把就绪队列的文件列表复制到 <code>epoll_wait()</code> 函数的<code>events</code> 参数中。</li><li>唤醒调用 <code>epoll_wait()</code> 函数被阻塞（睡眠）的进程。</li></ol><h1 id="事件监听">事件监听</h1><p>内核中的事件监听和回调机制是通过高效的事件驱动模型实现的，而不是简单的循环检查（如在用户空间中的轮询）。这种机制利用了现代操作系统的中断和回调系统，以及针对异步事件的优化处理策略。</p><p>以下是这个过程的详细解释：</p><h2 id="中断和中断处理">1. 中断和中断处理</h2><p>在硬件层面，大多数 I/O 操作（如网络通信、磁盘I/O）都是通过中断驱动的。当一个 I/O设备准备好数据或需要服务时，它会产生一个中断信号，这个信号被发送到CPU。CPU 响应中断，并执行一个预定的中断处理程序（Interrupt ServiceRoutine, ISR），该程序是由设备的驱动程序提供的。</p><h2 id="事件和回调">2. 事件和回调</h2><p>在 ISR中，与设备相关的事件（例如网络包的接收、硬盘读取完成）会被检测到，并且可以在此阶段调用特定的回调函数。这些回调函数是在设备驱动或相关的内核模块中定义的，用来通知内核其他部分或者相关的进程有关事件的发生。</p><h2 id="文件描述符的回调机制">3. 文件描述符的回调机制</h2><p>对于 <code>epoll</code> 等 I/O多路复用技术，内核为每个文件描述符维护了一个事件处理机制。当文件描述符被创建时，相关的设备或资源会注册一组回调函数，这些函数会在特定的操作（如读、写、错误）上被触发。例如，一个网络套接字可能会在数据到达时触发一个“可读”事件的回调。</p><h2 id="epoll-的事件绑定">4. <code>epoll</code> 的事件绑定</h2><p>当一个文件描述符被加入到 <code>epoll</code>监听队列中，<code>epoll</code>会利用这些回调来获得事件通知。<code>epoll</code>操作相关的代码会将一个额外的回调函数绑定到这些文件描述符上。当文件描述符的状态改变时（如数据可读），这个回调函数将被触发，然后它会将相应的文件描述符标记为“就绪”，并放入<code>epoll</code> 的就绪队列。</p><h2 id="事件通知和唤醒">5. 事件通知和唤醒</h2><p>当 <code>epoll_wait</code>被调用且有事件就绪时，内核会检查就绪队列，并将这些事件传递给等待的进程。如果没有事件就绪，进程将被挂起直到有事件发生。事件的发生会触发内核调度程序唤醒相应的进程。</p><h2 id="效率和性能">6. 效率和性能</h2><p>这种基于中断的事件通知机制意味着内核不需要不断循环检查每个文件描述符的状态，从而极大地提高了效率。事件只有在实际发生时才被处理，且处理通常是由硬件中断直接触发的，这使得整个系统更加响应快速，减少了无效的CPU 使用。</p><p>这种设计使得 Linux 内核在处理大量并发 I/O操作时能够保持高效和稳定，适合构建高性能的网络服务和应用。</p><h1 id="中断">中断</h1><p>中断机制是计算机硬件和操作系统核心功能之一，它允许外设或硬件异步地通知CPU 需要处理某些事件。中断机制的实现并不依赖于类似于 <code>for</code>循环的轮询检查，而是建立在更为直接和高效的硬件和处理器架构支持之上。</p><p>当 CPU接收到中断信号时，它是通过一套内建于硬件的协调机制来识别和响应中断的。这个过程涉及硬件电路设计、处理器架构和操作系统的中断管理功能。</p><p>以下是 CPU 如何知道有中断发生，并且如何处理这一中断的详细步骤：</p><h2 id="中断信号的检测和响应">中断信号的检测和响应</h2><ol type="1"><li><p><strong>中断请求线（IRQ）</strong>：外部设备通过连接到处理器的一个特定的硬件线路（IRQ）发送中断信号。这个线路直接与处理器内的中断控制单元（InterruptController）相连。</p></li><li><p><strong>中断控制器</strong>：大多数现代计算机系统使用一个或多个中断控制器来管理中断信号。中断控制器的任务是接收来自各种外部设备的中断请求，并将这些请求优先级排序后发送给CPU。</p></li><li><p><strong>中断向量</strong>：当中断控制器接收到一个中断信号后，它会根据中断源确定一个中断向量。这个向量是一个数字，指向中断向量表中对应的入口，该入口包含了处理该中断的中断服务例程（ISR）的地址。</p></li></ol><h2 id="cpu-如何处理中断">CPU 如何处理中断</h2><ol type="1"><li><p><strong>当前指令的完成</strong>：当 CPU接收到中断控制器发出的中断信号时，它首先会完成当前执行的指令。这是为了保证程序的状态能够正确保存，从而在中断处理完毕后可以无缝地恢复执行。</p></li><li><p><strong>保存上下文</strong>：一旦当前指令执行完毕，CPU会自动保存当前的程序状态，包括程序计数器（PC）、寄存器和其他必要的状态信息。这些信息通常被推送到当前的栈上。</p></li><li><p><strong>跳转到 ISR</strong>：CPU使用中断向量来访问中断向量表，找到与中断号对应的中断服务例程（ISR）的地址，并跳转到该地址开始执行ISR。这个过程是自动的，由处理器的内部机制控制。</p></li><li><p><strong>执行ISR</strong>：中断服务例程会执行必要的操作来处理中断，比如读取数据缓冲区、清除设备状态或发送信号等。</p></li><li><p><strong>恢复上下文并返回</strong>：一旦 ISR执行完成，处理器会从栈上恢复之前保存的程序状态，并将控制权返回到被中断的程序，继续执行。</p></li></ol><h2 id="硬件支持">硬件支持</h2><p>这一过程大量依赖于处理器的硬件支持，如中断向量表通常是固定在处理器的特定内存地址上的。此外，现代处理器如x86架构还提供了更高级的功能，比如支持多重中断控制器和高级可编程中断控制器（APIC）等。</p><p>这种基于硬件的中断响应机制允许 CPU快速有效地处理各种外部事件，确保系统的响应性和稳定性。</p><h1 id="参考">参考</h1><ul><li><ahref="https://blog.csdn.net/zhangyanfei01/article/details/114959103">图解| 深入揭秘 epoll 是如何实现 IO 多路复用的！</a></li><li><ahref="https://blog.csdn.net/zhpCSDN921011/article/details/125580548">一图总结epoll 的总体工作流程</a></li><li><ahref="https://thetechsolo.wordpress.com/2016/02/29/scalable-io-events-vs-multithreading-based/">scalable-io-events-vs-multithreading-based</a></li><li><ahref="https://github.com/liexusong/linux-source-code-analyze/blob/master/epoll-principle.md">Epoll实现原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/667412830">网络编程之 epoll源码深度剖析</a></li></ul>]]></content>
    
    
    <summary type="html">本文总结了高性能网络服务器中大量使用的 I/O 多路复用技术 epoll，涵盖工作原理、数据结构、事件监听和中断等相关内容。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="epoll" scheme="https://hedon.top/tags/epoll/"/>
    
    <category term="网络编程" scheme="https://hedon.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="非阻塞 I/0" scheme="https://hedon.top/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E-I-0/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨并发构建倒排索引</title>
    <link href="https://hedon.top/2024/04/23/rust-action-inverted-index-concurrency/"/>
    <id>https://hedon.top/2024/04/23/rust-action-inverted-index-concurrency/</id>
    <published>2024-04-23T15:13:27.000Z</published>
    <updated>2024-04-23T15:49:04.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>继上篇 <ahref="https://hedon.top/2024/04/15/rust-action-inverted-index-demo/">Rust实战丨倒排索引</a>，本篇我们将参考《Rust程序设计（第二版）》中并发编程篇章来实现高并发构建倒排索引。</p><p>本篇主要分为以下几个部分：</p><ol type="1"><li>功能展示：展示我们最终实现的 2个工具的效果（构建索引、搜索功能）</li><li>阅读源码：阅读书中源码的实现，理清大体思路。</li><li>构建索引：实战构建索引的每个具体环节，并对核心逻辑进行解释和阐述缘由。</li><li>搜索功能：这是书中未曾提供的功能，笔者根据自身理解，对齐上篇提供的功能，实现了一个搜索功能。</li></ol><p>能学到：</p><ul><li>Rust 各种迭代器的使用</li><li>Rust 文件常用操作</li><li>Rust 字符串常用操作</li><li>Rust channel 实战</li><li>Rust 并发编程</li><li>多路合并文件实际应用</li><li>使用 <code>byteorder</code> 进行位操作</li><li>使用 <code>clap</code> 进行 CLI 开发</li><li>终端高亮输出</li><li>深入理解倒排索引高性能的核心细节</li></ul><h1 id="阅读建议">阅读建议</h1><p>本篇内容较为冗长，涉及到的细节讲解可能比较啰嗦，推荐<strong>直接阅读源码，然后对不理解的地方再来本篇对应的章节进行阅读</strong>。</p><p>完成源码位于：https://github.com/hedon-rust-road/inverted-index-concurrency</p><h1 id="版本声明">版本声明</h1><ul><li>Rust: 1.76</li><li>byteordrr: 1.5.0</li><li>clap: 4.5.0</li><li>运行环境：macbookPro Apple M2 Max</li></ul><h1 id="功能展示">功能展示</h1><h2 id="create.rs">create.rs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: create [OPTIONS] &lt;FILENAMES&gt;...<br><br>Arguments:<br>  &lt;FILENAMES&gt;...<br><br>Options:<br>  -s, --single-threaded  Default <span class="hljs-literal">false</span><br>  -h, --<span class="hljs-built_in">help</span>             Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>指定文件目录，构建索引，可以使用 <code>-s</code>使用单线程构建，默认使用并发构建。</p><p>执行示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  inverted-index-concurrency git:(master) ✗ cargo run --bin create ./texts<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.08s<br>     Running `/Users/wangjiahan/rust-target/debug/create ./texts`<br>indexed document 0:<span class="hljs-string">&quot;./texts/text1.txt&quot;</span>, 22 bytes, 5 words<br>indexed document 1:<span class="hljs-string">&quot;./texts/text3.txt&quot;</span>, 27 bytes, 5 words<br>indexed document 2:<span class="hljs-string">&quot;./texts/text2.txt&quot;</span>, 39 bytes, 6 words<br>word count: 16<br>351 bytes main, 736 bytes total<br>wrote file <span class="hljs-string">&quot;./tmp00000001.dat&quot;</span><br></code></pre></td></tr></table></figure><h2 id="search.rs">search.rs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: search --index-file &lt;INDEX_FILE&gt; --term &lt;TERM&gt;<br><br>Options:<br>  -i, --index-file &lt;INDEX_FILE&gt;  Specify index file path<br>  -t, --term &lt;TERM&gt;              Specify search term<br>  -h, --<span class="hljs-built_in">help</span>                     Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>指定索引文件和搜索词来进行搜索。</p><p>执行示例如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423201406903.png"alt="search.rs 执行示例" /><figcaption aria-hidden="true">search.rs 执行示例</figcaption></figure><h1 id="阅读源码">阅读源码</h1><blockquote><p>书中的源码位于：<ahref="https://github.com/ProgrammingRust/fingertips/tree/master">fingertips</a></p></blockquote><p>第一部分我们先来阅读源码，书中展示了这样一张图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image00882.jpeg"alt="索引构建器管道，其中箭头表示通过通道将值从一个线程发送到另一个线程（未展示磁盘 I/O）" /><figcaptionaria-hidden="true">索引构建器管道，其中箭头表示通过通道将值从一个线程发送到另一个线程（未展示磁盘I/O）</figcaption></figure><p>从这张图我们大概可以猜想本案例中构建并发索引的过程可能是：</p><ol type="1"><li>读取文件内容；</li><li>根据文件内容构建索引；</li><li>多个索引进行合并；</li><li>将索引写入文件；</li><li>多个索引文件进行合并。</li></ol><p>按照这个思路的指引，我们打开源码，从 <code>main.rs</code> 的<code>main()</code> 出发：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">single_threaded</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">filenames</span> = <span class="hljs-built_in">vec!</span>[];<br><br>  <span class="hljs-comment">// 命令行参数解析</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ap</span> = ArgumentParser::<span class="hljs-title function_ invoke__">new</span>();<br>        ap.<span class="hljs-title function_ invoke__">set_description</span>(<span class="hljs-string">&quot;Make an inverted index for searching documents.&quot;</span>);<br>        ap.<span class="hljs-title function_ invoke__">refer</span>(&amp;<span class="hljs-keyword">mut</span> single_threaded).<span class="hljs-title function_ invoke__">add_option</span>(<br>            &amp;[<span class="hljs-string">&quot;-1&quot;</span>, <span class="hljs-string">&quot;--single-threaded&quot;</span>],<br>            StoreTrue,<br>            <span class="hljs-string">&quot;Do all the work on a single thread.&quot;</span>,<br>        );<br>        ap.<span class="hljs-title function_ invoke__">refer</span>(&amp;<span class="hljs-keyword">mut</span> filenames).<span class="hljs-title function_ invoke__">add_argument</span>(<br>            <span class="hljs-string">&quot;filenames&quot;</span>,<br>            Collect,<br>            <span class="hljs-string">&quot;Names of files/directories to index. \</span><br><span class="hljs-string">                           For directories, all .txt files immediately \</span><br><span class="hljs-string">                           under the directory are indexed.&quot;</span>,<br>        );<br>        ap.<span class="hljs-title function_ invoke__">parse_args_or_exit</span>();<br>    &#125;<br><br>  <span class="hljs-comment">// 构建索引</span><br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">run</span>(filenames, single_threaded) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(()) =&gt; &#123;&#125;<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error: &#123;&#125;&quot;</span>, err),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>解析命令行参数，这里使用 <code>argparse</code> 这个比较古老的 crate来解析，现在一般是使用 <code>clap</code>。<ul><li><code>single_threaded:</code> 是否使用单线程，默认是多线程。</li><li><code>filenames</code>: 指定的文本文件或目录。</li></ul></li><li><code>run</code> 函数执行构建索引。</li></ol><p>看一下 <code>run</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Generate an index for a bunch of text files.</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(filenames: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;, single_threaded: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">output_dir</span> = PathBuf::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">documents</span> = <span class="hljs-title function_ invoke__">expand_filename_arguments</span>(filenames)?;<br><br>    <span class="hljs-keyword">if</span> single_threaded &#123;<br>        <span class="hljs-title function_ invoke__">run_single_threaded</span>(documents, output_dir)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">run_pipeline</span>(documents, output_dir)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>单线程：run_single_threaded</li><li>多线程：run_pipeline</li></ul><p>先从简单看，单线程，忽略掉源码中定义的特殊数据结构，可以发现跟我们上篇介绍的简单版倒排索引思路基本是一致的，只不过本案例中数据是从文件中读，最后又会将索引写入到文件中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_single_threaded</span>(documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">accumulated_index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">merge</span> = FileMerge::<span class="hljs-title function_ invoke__">new</span>(&amp;output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp_dir</span> = TmpDir::<span class="hljs-title function_ invoke__">new</span>(&amp;output_dir);<br><br>    <span class="hljs-comment">// 迭代每个文本文件</span><br>    <span class="hljs-keyword">for</span> (doc_id, filename) <span class="hljs-keyword">in</span> documents.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>      <span class="hljs-comment">// 打开文件，并将内容读取到 `text` 上</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(filename)?;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>        f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> text)?;<br><br>        <span class="hljs-comment">// 构建索引</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_single_document</span>(doc_id, text);<br>        accumulated_index.<span class="hljs-title function_ invoke__">merge</span>(index);<br>        <span class="hljs-keyword">if</span> accumulated_index.<span class="hljs-title function_ invoke__">is_large</span>() &#123;<br>            <span class="hljs-comment">// 当索引足够大的时候，将其写到文件中</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(accumulated_index, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>            merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>            accumulated_index = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将最后一个索引写入到文件中</span><br>    <span class="hljs-keyword">if</span> !accumulated_index.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(accumulated_index, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>        merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>    &#125;<br>    merge.<span class="hljs-title function_ invoke__">finish</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看本文的重头戏，多线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_pipeline</span>(documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// 将构建索引分为 5 个过程</span><br>    <span class="hljs-keyword">let</span> (texts, h1) = <span class="hljs-title function_ invoke__">start_file_reader_thread</span>(documents);<br>    <span class="hljs-keyword">let</span> (pints, h2) = <span class="hljs-title function_ invoke__">start_file_indexing_thread</span>(texts);<br>    <span class="hljs-keyword">let</span> (gallons, h3) = <span class="hljs-title function_ invoke__">start_in_memory_merge_thread</span>(pints);<br>    <span class="hljs-keyword">let</span> (files, h4) = <span class="hljs-title function_ invoke__">start_index_writer_thread</span>(gallons, &amp;output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">merge_index_files</span>(files, &amp;output_dir);<br><br>    <span class="hljs-comment">// 等待所有线程执行完毕</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = h1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h3.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = h4.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    r1?;<br>    r4?;<br>    result<br>&#125;<br></code></pre></td></tr></table></figure><p>首先将索引构建分成 5 个阶段：</p><p><strong>1. start_file_reader_thread</strong></p><p>就是从文件中读取文本信息，并将其扔进<code>Receiver&lt;String&gt;</code> channel 中，传到下一个阶段。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_reader_thread</span>(<br>    documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;<span class="hljs-type">String</span>&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">filename</span> <span class="hljs-keyword">in</span> documents &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(filename)?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>          <span class="hljs-comment">// 读取文件内容</span><br>            f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> text)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(text).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. start_file_indexing_thread</strong></p><p>从第 1 步传过来的文本信息中调用<code>InMemoryIndex::from_single_document</code> 构建索引。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_indexing_thread</span>(<br>    texts: Receiver&lt;<span class="hljs-type">String</span>&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> (doc_id, text) <span class="hljs-keyword">in</span> texts.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>          <span class="hljs-comment">// 构建索引</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_single_document</span>(doc_id, text);<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. start_in_memory_merge_thread</strong></p><p>将第 2 步构建的单一索引进行合并，并将合并后的索引传到下一个阶段。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_in_memory_merge_thread</span>(<br>    file_indexes: Receiver&lt;InMemoryIndex&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">accumulated_index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">fi</span> <span class="hljs-keyword">in</span> file_indexes &#123;<br>          <span class="hljs-comment">// 将索引进行合并</span><br>            accumulated_index.<span class="hljs-title function_ invoke__">merge</span>(fi);<br>            <span class="hljs-keyword">if</span> accumulated_index.<span class="hljs-title function_ invoke__">is_large</span>() &#123;<br>              <span class="hljs-comment">// 如果索引大小到达阈值，则传到下一阶段</span><br>                <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                accumulated_index = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !accumulated_index.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index);<br>        &#125;<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. start_index_writer_thread</strong></p><p>将第 3 步传来的内存索引写入到临时文件中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_index_writer_thread</span>(<br>    big_indexes: Receiver&lt;InMemoryIndex&gt;,<br>    output_dir: &amp;Path,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;PathBuf&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp_dir</span> = TmpDir::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">index</span> <span class="hljs-keyword">in</span> big_indexes &#123;<br>          <span class="hljs-comment">// 将索引写入临时文件中</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(index, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(file).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5. merge_index_files</strong></p><p>将临时文件进行合并，生成最终的索引文件。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_index_files</span>(files: Receiver&lt;PathBuf&gt;, output_dir: &amp;Path) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">merge</span> = FileMerge::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">file</span> <span class="hljs-keyword">in</span> files &#123;<br>        merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>    &#125;<br>    merge.<span class="hljs-title function_ invoke__">finish</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>这 5 个步骤跟书中给出的示意图基本一致，我们再来看<code>run_pipeline</code> 是如何合并并行的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 join() 等待所有线程完成</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = h1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>h2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>h3.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = h4.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br><span class="hljs-comment">// 阶段 2 和阶段 3 都是纯内存操作，不会有错误</span><br><span class="hljs-comment">// 阶段 1 是读文件，阶段 4 是写文件，所以有可能会报错</span><br>r1?;<br>r4?;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240416001044618.png"alt="run_pipeline 示意图" /><figcaption aria-hidden="true">run_pipeline 示意图</figcaption></figure><p>源码阅读部分差不多就到这了，大的思想架构你应该都能 Get到了，其中每个数据结构的具体实现细节，我们在后面的实战中进行拆解。</p><h1 id="构建索引">构建索引</h1><h2 id="代码结构">代码结构</h2><p>书中源码代码结构如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  fingertips git:(master) ✗ tree<br>.<br>├── Cargo<span class="hljs-selector-class">.lock</span><br>├── Cargo<span class="hljs-selector-class">.toml</span><br>├── LICENSE-MIT<br>├── README<span class="hljs-selector-class">.md</span><br>├── <span class="hljs-attribute">src</span><br>│   ├── index<span class="hljs-selector-class">.rs</span><br>│   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.rs</span><br>│   ├── merge<span class="hljs-selector-class">.rs</span><br>│   ├── read<span class="hljs-selector-class">.rs</span><br>│   ├── tmp<span class="hljs-selector-class">.rs</span><br>│   └── write.rs<br></code></pre></td></tr></table></figure><p>书中给出的源码并没有实现使用构建好的索引文件进行搜索的功能，笔者将在此基础上实现该功能，所以对代码结构进行了简单的调整：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  inverted_index git:(master) ✗ tree<br>.<br>├── Cargo<span class="hljs-selector-class">.lock</span><br>├── Cargo<span class="hljs-selector-class">.toml</span><br>├── index<span class="hljs-selector-class">.bat</span><br>├── <span class="hljs-attribute">src</span><br>│   ├── bin<br>│   │   ├── create<span class="hljs-selector-class">.rs</span><br>│   │   └── search<span class="hljs-selector-class">.rs</span><br>│   ├── index<span class="hljs-selector-class">.rs</span><br>│   ├── lib<span class="hljs-selector-class">.rs</span><br>│   ├── merge<span class="hljs-selector-class">.rs</span><br>│   ├── read<span class="hljs-selector-class">.rs</span><br>│   ├── tmp<span class="hljs-selector-class">.rs</span><br>│   └── write<span class="hljs-selector-class">.rs</span><br>└── texts<br>    ├── text1<span class="hljs-selector-class">.txt</span><br>    ├── text2<span class="hljs-selector-class">.txt</span><br>    └── text3.txt<br></code></pre></td></tr></table></figure><p>可以看到我将核心代码从 <code>bin</code> 改成了 <code>lib</code>，这是为了支持我后面要实现的两个 <code>bin</code>:</p><ul><li><code>create</code>: 构建索引，基本上就是源代码中的<code>main.rs</code></li><li><code>search</code>: 基于生成的索引文件实现搜索功能</li></ul><p><code>texts</code> 是我提供的文本文件样例。</p><p><code>src</code> 目录中的代码阅读顺序及功能划分如下：</p><ul><li><code>index</code>: 定义了内存索引数据结构InMemoryIndex，实现了从文件内容中构建内存索引的基本逻辑，也实现了从索引文件重建内存索引的功能。</li><li><code>tmp</code>: 定义了临时目录数据结构TmpDir，用于存放临时索引文件。</li><li><code>write</code>: 定义了索引文件写入器 IndexFileWriter，实现了将InMemoryIndex 写入文件中的逻辑。</li><li><code>merge</code>: 定义了文件合并器 FileMerge，用于合并 TmpDir的所有索引文件。</li><li><code>read</code>: 定义了索引文件读取器IndexFileWrite，实现了解析索引文件的逻辑。</li></ul><h2 id="项目准备">项目准备</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new --lib inverted_index_concurrency<br></code></pre></td></tr></table></figure><p>Cargo.toml</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;inverted-index-concurrency&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><span class="hljs-attr">license</span> = <span class="hljs-string">&quot;mit&quot;</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">&quot;hedon&quot;</span>]<br><span class="hljs-attr">description</span> = <span class="hljs-string">&quot;a tool to concurrently build an inverted index.&quot;</span><br><br><span class="hljs-section">[[bin]]</span><br><span class="hljs-attr">name</span>=<span class="hljs-string">&quot;create&quot;</span><br><span class="hljs-attr">path</span>=<span class="hljs-string">&quot;src/bin/create.rs&quot;</span><br><br><span class="hljs-section">[[bin]]</span><br><span class="hljs-attr">name</span>=<span class="hljs-string">&quot;search&quot;</span><br><span class="hljs-attr">path</span>=<span class="hljs-string">&quot;src/bin/search.rs&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">byteorder</span> = <span class="hljs-string">&quot;1.5.0&quot;</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.4&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><h2 id="lib.rs">lib.rs</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> index;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> merge;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> read;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> tmp;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> write;<br></code></pre></td></tr></table></figure><p>在 <code>lib.rs</code> 中我们将这 5 个 mod 公开出去，这样就可以给<code>bin</code> 目录中的 <code>crate.rs</code> 和<code>search.rs</code> 使用了。</p><h2 id="index.rs">index.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/index.rs">index.rs</a></p></blockquote><p>第一部分是内存索引的构建。</p><h3 id="tokenize">tokenize</h3><p>我们先定义一个分词函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tokenize</span>(text: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;(&amp;<span class="hljs-type">str</span>, <span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>)&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">res</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">token_start</span> = <span class="hljs-literal">None</span>;<br>    <span class="hljs-keyword">for</span> (idx, ch) <span class="hljs-keyword">in</span> text.<span class="hljs-title function_ invoke__">char_indices</span>() &#123;<br>        <span class="hljs-keyword">match</span> (ch.<span class="hljs-title function_ invoke__">is_alphanumeric</span>(), token_start) &#123;<br>            (<span class="hljs-literal">true</span>, <span class="hljs-literal">None</span>) =&gt; token_start = <span class="hljs-title function_ invoke__">Some</span>(idx),  <span class="hljs-comment">// 每个单词的开始</span><br>            (<span class="hljs-literal">false</span>, <span class="hljs-title function_ invoke__">Some</span>(start)) =&gt; &#123;  <span class="hljs-comment">// 每个单词的结尾</span><br>                res.<span class="hljs-title function_ invoke__">push</span>((&amp;text[start..idx], start, idx - <span class="hljs-number">1</span>));<br>                token_start = <span class="hljs-literal">None</span><br>            &#125;<br>            _ =&gt; &#123;&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(start) = token_start &#123;<br>        res.<span class="hljs-title function_ invoke__">push</span>((&amp;text[start..], start, text.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>))<br>    &#125;<br>    res<br>&#125;<br></code></pre></td></tr></table></figure><p>这个分词函数跟书中源码提供的不一样，为了实现文本高亮，我们需要记录每个分词在原文本中的起始位置和结束位置。它的核心逻辑如下：</p><ol type="1"><li><p>通过 <code>char_indices()</code> 获取 <code>text</code>的字符迭代器，这是一种懒加载的方法，避免一次性将所有 char加载到内存中。</p></li><li><p>匹配 <code>(ch.is_alphanumeric(), token_start)</code>：</p><ul><li>如果是 <code>(true, None)</code>则表示这是一个单词的开始，我们纪录其开始的位置<code>Some(idx)</code>；</li><li>如果是 <code>(false, Some(idx))</code>则表示这是一个单词的结束，我们将其加入到 <code>res</code>中，并记录起始位置和结束位置。</li><li>其他情况，不做处理，要么是非法字符，要么是处于单词中间。</li></ul><p>从这个简单的理解中，你应该可以感受到 Rust 中 match pattern的强大和便捷了，666 👍🏻</p></li></ol><h3 id="struct-inmemoryindex">struct: InMemoryIndex</h3><p>在 <code>index.rs</code> 中，我们定义了三个数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">InMemoryIndex</span> &#123;<br>    <span class="hljs-keyword">pub</span> word_count: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> terms: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;Hit&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> docs: HashMap&lt;<span class="hljs-type">usize</span>, Document&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Document</span> &#123;<br>    <span class="hljs-keyword">pub</span> id: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> path: PathBuf,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Hit</span> = <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;;<br></code></pre></td></tr></table></figure><ul><li><p><code>Document</code>: 文档封装。</p><ul><li><code>id</code>: 文档 id，唯一标识符。</li><li><code>path</code>: 源文件路径。</li></ul></li><li><p><code>Hit</code>:它是一个字节数组，我们按照小端序进行存储，它的存储结构如下：</p><ul><li>[0..3] 存储一个 <code>HITS_SEPERATOR = -1</code>，表示一个<code>Hit</code> 的开始。</li><li>[4..7] 存储一个 u32 的 <code>document_id</code>。</li><li>后面每 8 个 u8 会存在一个 u32 的 <code>start_pos</code> 和一个 u32的 <code>end_pos</code>。</li></ul></li><li><p><code>InMemoryIndex</code>: 内存索引。</p><ul><li><code>word_count</code>:包含的单词（word/term）个数，记录它是为了判断索引是否过大，以便对索引进行分片存储。</li><li><code>terms</code>: 存储 word 到 Hits 的映射，每个 <code>word</code>是一个搜索项。</li><li><code>docs</code>: 存储了 document_id到文档的映射，用于查询原始文档信息。</li></ul></li></ul><p>接下来我们来为 <code>InMemoryIndex</code>实现一系列方法，因为我们期望使用小端序存储 <code>Hit</code>中的数据，所以我们需要引入 <code>byteorder</code> 这个 crate:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add byteorder<br></code></pre></td></tr></table></figure><p>具体实现可参考源码，核心逻辑是 <code>from_single_document</code> 和<code>merge</code>。</p><h3 id="from_single_document">from_single_document</h3><p><strong>from_single_document</strong>的核心逻辑在这一段，它其实跟我们之前实现的简易版倒排索引很相似：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> (token, start_pos, end_pos) <span class="hljs-keyword">in</span> tokens.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hits</span> = index.terms.<span class="hljs-title function_ invoke__">entry</span>(token.<span class="hljs-title function_ invoke__">to_string</span>()).<span class="hljs-title function_ invoke__">or_insert_with</span>(|| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hits</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span>);<br>        hits.write_i32::&lt;LittleEndian&gt;(<span class="hljs-keyword">Self</span>::HITS_SEPERATOR)<br>            .<span class="hljs-title function_ invoke__">unwrap</span>();<br>        hits.write_u32::&lt;LittleEndian&gt;(document_id).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-built_in">vec!</span>[hits]<br>    &#125;);<br><br>    hits[<span class="hljs-number">0</span>].write_u32::&lt;LittleEndian&gt;(*start_pos <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    hits[<span class="hljs-number">0</span>].write_u32::&lt;LittleEndian&gt;(*end_pos <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    index.word_count += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>遍历每个 <code>token</code> 和它在文本中的位置。</li><li>对于每个 <code>token</code>，尝试在索引的 <code>map</code>中查找一个现有的条目。如果不存在，则创建一个新的 <code>Hit</code>记录，并初始化它：<ul><li>创建一个新的 <code>Hit</code> 向量，预留 24字节的容量，这是因为至少要存储 1 个分隔符、1 个 document_id、1 个start_pos 和 1 个 end_pos。</li><li>首先写入 <code>HITS_SEPERATOR</code> 和<code>document_id</code>（使用小端序）。</li></ul></li><li>向对应的 <code>Hit</code> 向量中添加当前单词的位置。</li><li>累加处理的单词总数到 <code>index.word_count</code>。</li></ul><p>这里给个示例，希望可以帮助你理解 <code>InMemoryIndex</code>的内存结构：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">InMemoryIndex</span><br><span class="hljs-string">│</span><br><span class="hljs-string">├──</span> <span class="hljs-attr">word_count:</span> <span class="hljs-string">usize</span><br><span class="hljs-string">│</span><br><span class="hljs-string">├──</span> <span class="hljs-attr">terms:</span> <span class="hljs-string">HashMap&lt;String,</span> <span class="hljs-string">Vec&lt;Hit&gt;&gt;</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span><br><span class="hljs-string">│</span>   <span class="hljs-string">├──</span> <span class="hljs-attr">Key:</span> <span class="hljs-string">&quot;example&quot;</span> <span class="hljs-string">(String)</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Vec&lt;Hit&gt;</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span>       <span class="hljs-string">├──</span> [<span class="hljs-string">HITS_SEPERATOR</span>, <span class="hljs-attr">Document ID:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">Positions:</span> [<span class="hljs-number">10</span>, <span class="hljs-number">19</span>, <span class="hljs-number">30</span>, <span class="hljs-number">39</span>]] <span class="hljs-string">(Hit)</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span>       <span class="hljs-string">└──</span> [<span class="hljs-string">HITS_SEPERATOR</span>, <span class="hljs-attr">Document ID:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">Positions:</span> [<span class="hljs-number">15</span>, <span class="hljs-number">25</span>]] <span class="hljs-string">(Hit)</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span><br><span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-attr">Key:</span> <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-string">│</span>       <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Vec&lt;Hit&gt;</span><br><span class="hljs-string">│</span>           <span class="hljs-string">└──</span> [<span class="hljs-string">HITS_SEPERATOR</span>, <span class="hljs-attr">Document ID:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">Positions:</span> [<span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">50</span>, <span class="hljs-number">69</span>]] <span class="hljs-string">(Hit)</span><br><span class="hljs-string">│</span><br><span class="hljs-string">└──</span> <span class="hljs-attr">docs:</span> <span class="hljs-string">HashMap&lt;u32,</span> <span class="hljs-string">Document&gt;</span><br>    <span class="hljs-string">├──</span> <span class="hljs-attr">Key:</span> <span class="hljs-number">1</span> <span class="hljs-string">(u32)</span><br>    <span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Document</span> &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;path/to/file1.txt&quot;</span>&#125;<br>    <span class="hljs-string">└──</span> <span class="hljs-attr">Key:</span> <span class="hljs-number">2</span><br>        <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Document</span> &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;path/to/file2.txt&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="merge">merge</h3><p><strong>merge</strong> 是用于合并多个<code>InMemoryIndex</code>，起到批处理的目的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, other: InMemoryIndex) &#123;<br>    <span class="hljs-keyword">for</span> (term, hits) <span class="hljs-keyword">in</span> other.terms &#123;<br>        <span class="hljs-keyword">self</span>.terms.<span class="hljs-title function_ invoke__">entry</span>(term).<span class="hljs-title function_ invoke__">or_default</span>().<span class="hljs-title function_ invoke__">extend</span>(hits)<br>    &#125;<br>    <span class="hljs-keyword">self</span>.word_count += other.word_count;<br>    <span class="hljs-keyword">self</span>.docs.<span class="hljs-title function_ invoke__">extend</span>(other.docs);<br>&#125;<br></code></pre></td></tr></table></figure><p>实现完了 <code>InMemoryIndex</code> 后，我们就可以先来完成<code>create.rs</code> 的 <code>run_pipeline</code> 的前 3个阶段了。</p><h3 id="step1-start_file_reader_thread">step1:start_file_reader_thread</h3><ol type="1"><li>读取文件信息：我们需要在独立的线程中依次打开给定的文件列表，并将文件内容读取到一个String 中，并利用 channel 传送出去。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_reader_thread</span>(<br>    documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;(PathBuf, <span class="hljs-type">String</span>)&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handler</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">filename</span> <span class="hljs-keyword">in</span> documents &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(filename.<span class="hljs-title function_ invoke__">clone</span>())?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>            f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> text)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>((filename, text)).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br><br>    (receiver, handler)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="step2-start_file_indexing_thread">step2:start_file_indexing_thread</h3><ol start="2" type="1"><li>构建索引：通过 channel 从第 1 阶段中获取文档文本信息，通过from_single_document 构建索引 InMemoryIndex 后，将索引通过 channel传送出去。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_indexing_thread</span>(<br>    docs: Receiver&lt;(PathBuf, <span class="hljs-type">String</span>)&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handler</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> (doc_id, (path, text)) <span class="hljs-keyword">in</span> docs.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_single_document</span>(doc_id <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>, path, text);<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    (receiver, handler)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="step3-start_in_memory_merge_thread">step3:start_in_memory_merge_thread</h3><ol start="3" type="1"><li>合并索引：通过 channel 从第 2 阶段中获得构建的 InMemoryIndex并将其合并成大索引，然后通过 channel 传送出去。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_in_memory_merge_thread</span>(<br>    indexes: Receiver&lt;InMemoryIndex&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">accumulated_index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> indexes &#123;<br>            accumulated_index.<span class="hljs-title function_ invoke__">merge</span>(i);<br>            <span class="hljs-keyword">if</span> accumulated_index.<span class="hljs-title function_ invoke__">is_large</span>() &#123;<br>                <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                accumulated_index = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !accumulated_index.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index);<br>        &#125;<br>    &#125;);<br><br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><big><strong>补充：为什么采用这种“复杂”的方式来存储数据呢？可否使用JSON 或者 Protobuf 呢？</strong></big></p><p>选择如何组织和存储数据，特别是在实现一个搜索引擎或数据库索引时，是一个关键决策，这会直接影响到程序的性能、可维护性以及扩展性。在这些情况下，使用像<code>byteorder</code> 这样的低级数据格式存储索引信息可能比使用 JSON 或Protobuf 等高级格式更有优势。</p><p>读写速度：</p><ul><li><strong>二进制格式</strong>：直接操作二进制格式通常比解析文本或半结构化的数据格式（如JSON）要快，因为它减少了解析时间和内存使用。在二进制格式中，数据通常是紧密打包的，没有额外的格式标记（如JSON 中的花括号和逗号），这减少了磁盘 I/O 需求。</li><li><strong>文本/半结构化格式</strong>：例如JSON，每次读取时都需要解析文本，转换数据类型，这会增加 CPU的负担，尤其是在大规模数据处理时。</li></ul><p>空间效率：</p><ul><li><strong>二进制格式</strong>：使用最少的字节表示数据，例如使用定长的整数存储文档ID 和位置索引，不仅节省空间，还能提高缓存利用率。</li><li><strong>文本/半结构化格式</strong>：文本格式需要存储额外的字符来标识数据（例如引号和键名），这增加了存储需求。</li></ul><p>适用场景：</p><ul><li><strong>二进制格式</strong>：非常适合需要高性能和大数据处理的后端系统，如搜索引擎和数据库索引。这种格式可以有效地支持快速的数据读取和写入，特别是在资源受限的环境中（如嵌入式系统或低延迟应用）。</li><li><strong>JSON/Protobuf</strong>：更适合需要跨平台兼容性和易于调试的应用场景。例如，在Web 应用中使用 JSON 作为数据交换格式，可以简化前后端的集成和测试。</li></ul>          </div><h2 id="tmp.rs">tmp.rs</h2><p>完成内存索引的构建后，我们需要将构建过程中产生的大索引先临时落盘，后面再进行合并。为了临时存储这些数据文件，我们需要将他们放在一个临时目录中，为此，我们定义了<code>TmpDir</code> 数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TmpDir</span> &#123;<br>    dir: PathBuf,<br>    n: <span class="hljs-type">usize</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>dir</code>: 目录</li><li><code>n</code>: 自增器，用于区分临时文件命名</li></ul><p>接下来为 <code>TmpDir</code> 实现 2 个方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">TmpDir</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>&lt;P: <span class="hljs-built_in">AsRef</span>&lt;Path&gt;&gt;(dir: P) <span class="hljs-punctuation">-&gt;</span> TmpDir &#123;<br>        TmpDir &#123;<br>            dir: dir.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">to_owned</span>(),<br>            n: <span class="hljs-number">1</span>,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">create</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;(PathBuf, BufWriter&lt;File&gt;)&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">r</span>#<span class="hljs-keyword">try</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">filename</span> = <span class="hljs-keyword">self</span><br>                .dir<br>                .<span class="hljs-title function_ invoke__">join</span>(PathBuf::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;tmp&#123;:08x&#125;.dat&quot;</span>, <span class="hljs-keyword">self</span>.n)));<br>            <span class="hljs-keyword">self</span>.n += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">match</span> fs::OpenOptions::<span class="hljs-title function_ invoke__">new</span>()<br>                .<span class="hljs-title function_ invoke__">write</span>(<span class="hljs-literal">true</span>)<br>                .<span class="hljs-title function_ invoke__">create_new</span>(<span class="hljs-literal">true</span>)<br>                .<span class="hljs-title function_ invoke__">open</span>(&amp;filename)<br>            &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(f) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>((filename, BufWriter::<span class="hljs-title function_ invoke__">new</span>(f))),<br>                <span class="hljs-title function_ invoke__">Err</span>(exc) =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> r#<span class="hljs-keyword">try</span> &lt; <span class="hljs-number">999</span> &amp;&amp; exc.<span class="hljs-title function_ invoke__">kind</span>() == io::ErrorKind::AlreadyExists &#123;<br>                        <span class="hljs-comment">// keep going</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(exc);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            r#<span class="hljs-keyword">try</span> += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>new</strong> 方法是 <code>TmpDir</code>的构造函数，其中我们将 <code>n</code> 设置为 1，即文件名从 1开始生成。<code>dir.as_ref().to_owned()</code>接受一个可能是任何类型的路径，将其标准化为一个 <code>Path</code>类型的引用，然后再复制这个引用，创建一个完全独立的、拥有所有权的<code>PathBuf</code> 对象，</p><p><strong>create</strong> 方法是在 <code>TmpDir</code>目录下创建一个临时文件。</p><h2 id="write.rs">write.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/write.rs">write.rs</a></p></blockquote><p>准备好内存索引和临时文件，那我们就需要实现将内存索引写入到文件中的功能了。</p><h3 id="struct-inmemoryindex-1">struct: InMemoryIndex</h3><p>我们先来分析一下如何将 <code>InMemoryIndex</code> 落盘。首先<code>InMemoryIndex</code> 的结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">InMemoryIndex</span> &#123;<br>    <span class="hljs-keyword">pub</span> word_count: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> terms: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;Hit&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> docs: HashMap&lt;<span class="hljs-type">u32</span>, Document&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Document</span> &#123;<br>    <span class="hljs-keyword">pub</span> id: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> path: PathBuf,<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>word_count</code>不需要存储，我们可以计算出来。那我们就需要存储索引 <code>map</code>和文档原数据 <code>docs</code>。为了能精确定位到各个数据，我们需要：</p><p>terms:</p><ul><li>写入 Vec&lt;Hit&gt;</li></ul><p>docs:</p><ul><li>写入 docs 中的每个 Document<ul><li>写入 id</li><li>写入 path 大小</li><li>写入 path</li></ul></li></ul><p>而为了快速定位到每个 term 和 doc的位置，我们需要下面几个值，这几个值将组合起来辅助我们快速定位 terms 或docs，我们后面会将其称为 <strong>Entry</strong>，它包含以下几个值：</p><ul><li><code>term</code>: 索引单词。为了统一，如果 <code>term</code>为空，则表示当前表示的是 doc，否则为 terms。</li><li><code>df</code>: term 的出现次数。为了统一，如果 <code>df</code> 为0，则表示当前表示的是 doc，否则为 terms。</li><li><code>offset</code>: 对应的 terms 或 docs 在文件中的偏移。</li><li><code>nbytes</code>: 对应的 terms 或 docs 的总长度。</li></ul><p>所以文件的内存结构大概如下：</p><table><thead><tr class="header"><th>文件区域</th><th>描述</th><th>指向内容</th></tr></thead><tbody><tr class="odd"><td>头部 （8 字节）</td><td>包含一个指向目录表开始位置的偏移量。</td><td>header</td></tr><tr class="even"><td>主条目</td><td>这些条目按顺序紧密存储，没有额外的元数据。这部分包含实际的数据条目。</td><td>terms + docs</td></tr><tr class="odd"><td>目录表</td><td>存储在文件的最后，包括每个条目的术语信息、文档频率、偏移和大小。</td><td>entries</td></tr></tbody></table><p>示意图如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423194529529.png"alt="索引文件内存结构示意图" /><figcaption aria-hidden="true">索引文件内存结构示意图</figcaption></figure><p>为此我们定义了 <code>IndexFileWriter</code>，它专门用于将<code>InMemoryIndex</code> 写入到临时文件中，定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// A structure to manage writing to an index file efficiently.</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IndexFileWriter</span> &#123;<br>    offset: <span class="hljs-type">u64</span>,<br>    writer: BufWriter&lt;File&gt;,<br>    contents_buf: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>offset</code>: 用于追踪文件中当前的写入位置。</li><li><code>writer</code>:一个缓冲写入器，它包装了一个文件，用于输出操作。</li><li><code>contents_buf</code>:一个向量，用来存储内容条目，在全部写入文件之前暂存在这个缓冲区。</li></ul><p>接下来我们为 <code>IndexFileWriter</code> 实现几个方法：</p><ul><li><code>new</code>:这是一个构造函数，它初始化文件并设置初始偏移量。在文件的开始处写入一个占位符作为头部，这个头部最终会存储主数据区的大小。</li><li><code>write_document</code>:用于将一个文档以二进制格式写入到文件中，同时更新偏移量。</li><li><code>write_main</code>:这个方法接受一段数据，并将它写入文件中，同时更新偏移量。</li><li><code>write_contents_entry</code>: 将一个内容 Entry追加到内部的缓冲区中。Entry包括一个术语、文档频率、术语数据的起始偏移和大小，它用于快速定位 terms或 docs。</li><li><code>finish</code>:完成文件写入过程，将内部缓冲区的内容写入文件，并更新文件头部的主数据大小。</li></ul><h3 id="new">new</h3><p>我们先来看构造方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(<span class="hljs-keyword">mut</span> f: BufWriter&lt;File&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;IndexFileWriter&gt; &#123;<br>    <span class="hljs-keyword">const</span> HEADER_SIZE: <span class="hljs-type">u64</span> = <span class="hljs-number">8</span>;<br>    f.write_u64::&lt;LittleEndian&gt;(<span class="hljs-number">0</span>)?; <span class="hljs-comment">// content start</span><br>    <span class="hljs-title function_ invoke__">Ok</span>(IndexFileWriter &#123;<br>        offset: HEADER_SIZE,<br>        writer: f,<br>        contents_buf: <span class="hljs-built_in">vec!</span>[],<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>new</strong> 分为以下几步：</p><ol type="1"><li><strong>定义头部大小</strong>：<code>const HEADER_SIZE: u64 = 8;</code>：定义一个常量<code>HEADER_SIZE</code>，其值为 8字节，这表示文件头部的大小。这个头部将用于后续在文件的开始处写入主数据区的起始位置。</li><li><strong>写入头部占位符</strong>：<code>f.write_u64::&lt;LittleEndian&gt;(0)?;</code>：在文件的开始处写入一个8字节的占位符，这个值是以小端字节序（<code>LittleEndian</code>）存储的。初始时这里写入的是0，意味着“主数据区的起始位置未知”，这个值在后续的 <code>finish</code>函数中会被更新。</li><li><strong>返回一个新的 IndexFileWriter实例</strong>：<code>Ok(IndexFileWriter &#123; offset: HEADER_SIZE, writer: f, contents_buf: vec![], &#125;)</code>：构造并返回一个<code>IndexFileWriter</code> 实例。这个实例的 <code>offset</code>字段被初始化为 <code>HEADER_SIZE</code>（8字节），表示实际数据将从文件的第 17 个字节开始写入。<code>writer</code>字段就是传入的文件写入器，<code>contents_buf</code>是一个新的空向量，用于临时存储内容条目数据。</li></ol><div class="note note-info">            <p><big><strong>为什么这样设计？</strong></big></p><p>这个实现方式有几个设计上的考虑：</p><ol type="1"><li><strong>预留头部空间</strong>：通过在文件开始处预留 8字节空间来存储主数据区的大小，这样做可以在数据写入完成后，方便地回填这个信息。这是文件格式设计中常见的做法，允许读取者快速定位主数据区和内容索引区。</li><li><strong>使用小端字节序</strong>：小端字节序是一种在二进制文件中常用的字节序，尤其是在Windows平台下。使用小端字节序可以提高文件的兼容性，并且对于多数处理器架构来说，小端字节序的读写操作更为高效。</li><li><strong>灵活的数据写入</strong>：通过将 <code>writer</code> 和<code>contents_buf</code>组合使用，这个结构体可以灵活地处理不同的数据写入需求。<code>writer</code>直接写入文件，适合连续大块数据的写入；而 <code>contents_buf</code>用于聚集多个小片段的数据，可以在最后统一写入，减少磁盘操作次数。</li></ol><p>总的来说，这个构造函数的实现为高效和灵活的文件写操作提供了良好的基础，同时通过合理的错误处理和数据组织方式，确保了程序的健壮性和高性能。</p>          </div><h3 id="write_main">write_main</h3><p>Hit 本身就是一个 Vec&lt;u8&gt;， 将其写入文件很简单，调用<code>write_all</code>，即可，我们为其封装 <code>write_main</code>方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_main</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">write_all</span>(buf)?;<br>    <span class="hljs-keyword">self</span>.offset += buf.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="write_document">write_document</h3><p>为了将 Docuemnt本以二进制结构写入到文件中，我们需要拆分成几个部分：</p><ol type="1"><li>文件 id</li><li>文件路径大小</li><li>文件路径</li></ol><p>为此我们为 <code>IndexFileWriter</code> 封装了<code>write_document</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_document</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, doc: &amp;Document) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.writer.write_u32::&lt;LittleEndian&gt;(doc.id)?;<br>    <span class="hljs-keyword">self</span>.writer<br>        .write_u64::&lt;LittleEndian&gt;(doc.path.<span class="hljs-title function_ invoke__">as_os_str</span>().<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>)?;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">write_all</span>(doc.path.<span class="hljs-title function_ invoke__">as_os_str</span>().<span class="hljs-title function_ invoke__">as_bytes</span>())?;<br>    <span class="hljs-keyword">self</span>.offset += <span class="hljs-number">4</span> + <span class="hljs-number">8</span> + doc.path.<span class="hljs-title function_ invoke__">as_os_str</span>().<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="write_contents_entry">write_contents_entry</h3><p>Entry的数据量一般较小，我们会先写入缓冲中，后面再一次性刷盘，为此我们为<code>IndexFileWriter</code> 封装了<code>write_contents_entry</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Appends a content entry to the internal buffer.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// # Arguments</span><br><span class="hljs-comment">/// * `term` - The term associated with the entry</span><br><span class="hljs-comment">/// * `df` - Document frequency for the term</span><br><span class="hljs-comment">/// * `offset` - Offset where the term data starts in the file</span><br><span class="hljs-comment">/// * `nbytes` - Number of bytes of the term data</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_contents_entry</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, term: <span class="hljs-type">String</span>, df: <span class="hljs-type">u32</span>, offset: <span class="hljs-type">u64</span>, nbytes: <span class="hljs-type">u64</span>) &#123;<br>    <span class="hljs-keyword">self</span>.contents_buf.write_u64::&lt;LittleEndian&gt;(offset).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf.write_u64::&lt;LittleEndian&gt;(nbytes).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf.write_u32::&lt;LittleEndian&gt;(df).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = term.<span class="hljs-title function_ invoke__">bytes</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf<br>        .write_u32::&lt;LittleEndian&gt;(bytes.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>)<br>        .<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf.<span class="hljs-title function_ invoke__">extend</span>(bytes);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="finish">finish</h3><p>刷盘的过程我们封装在 <code>finish</code> 中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">finish</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contents_start</span> = <span class="hljs-keyword">self</span>.offset;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">write_all</span>(&amp;<span class="hljs-keyword">self</span>.contents_buf)?;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">seek</span>(SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(<span class="hljs-number">0</span>))?;<br>    <span class="hljs-keyword">self</span>.writer.write_u64::&lt;LittleEndian&gt;(contents_start)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="write_index_to_tmp_file">write_index_to_tmp_file</h3><p>综合下来，我们就可以实现最核心的函数<code>write_index_to_tmp_file</code> 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_index_to_tmp_file</span>(index: InMemoryIndex, tmp_dir: &amp;<span class="hljs-keyword">mut</span> TmpDir) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;PathBuf&gt; &#123;<br>    <span class="hljs-keyword">let</span> (filename, f) = tmp_dir.<span class="hljs-title function_ invoke__">create</span>()?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">writer</span> = IndexFileWriter::<span class="hljs-title function_ invoke__">new</span>(f)?;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index_as_vec</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = index.terms.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    index_as_vec.<span class="hljs-title function_ invoke__">sort_by</span>(|(a, _), (b, _)| a.<span class="hljs-title function_ invoke__">cmp</span>(b));<br><br>    <span class="hljs-keyword">for</span> (term, hits) <span class="hljs-keyword">in</span> index_as_vec &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">df</span> = hits.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span> = writer.offset;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">buffer</span> <span class="hljs-keyword">in</span> hits &#123;<br>            writer.<span class="hljs-title function_ invoke__">write_main</span>(&amp;buffer)?;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stop</span> = writer.offset;<br>        writer.<span class="hljs-title function_ invoke__">write_contents_entry</span>(term, df, start, stop - start);<br>    &#125;<br><br>    <span class="hljs-comment">// if term == &quot;&quot; &amp;&amp; df == 0 &#123; type = document &#125;</span><br>    <span class="hljs-keyword">for</span> (_, doc) <span class="hljs-keyword">in</span> index.docs &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span> = writer.offset;<br>        writer.<span class="hljs-title function_ invoke__">write_document</span>(&amp;doc)?;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stop</span> = writer.offset;<br>        writer.<span class="hljs-title function_ invoke__">write_contents_entry</span>(<span class="hljs-string">&quot;&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">0</span>, start, stop - start)<br>    &#125;<br><br>    writer.<span class="hljs-title function_ invoke__">finish</span>()?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;wrote file &#123;:?&#125;&quot;</span>, filename);<br>    <span class="hljs-title function_ invoke__">Ok</span>(filename)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>我们在临时目录中创建一个临时文件，并初始化 IndexFileWriter；</li><li>将索引的 <code>terms</code> 转换成一个向量并按照键排序；</li><li>对于每个<code>term</code>，计算文档频率（<code>df</code>），记录开始和结束位置，然后调用<code>write_main</code> 方法将数据写入文件，然后使用<code>write_contents_entry</code> 方法写入 <code>Entry</code>的元数据到目录表；</li><li>对于 <code>index.docs</code>中的每个文档，计算起止位置，并使用一个特殊的条目（空字符串作为条目名和 0作为文档频率）标记在文件中；</li><li>最后我们使用 <code>finish</code> 将缓存中所有的 <code>Entry</code>刷盘，并设置 <code>entries</code> 的起始位置。</li></ol><p>文件的内存结构如上面给出的图一样，这里我们可以再看一次：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423194529529-20240423195227516.png"alt="索引文件内存结构示意图" /><figcaption aria-hidden="true">索引文件内存结构示意图</figcaption></figure><h3 id="step4-start_index_writer_thread">step4:start_index_writer_thread</h3><p>实现了将内存索引写入到文件的功能后，我们就可以继续在<code>create.rs</code> 中实现下一个流程了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_index_writer_thread</span>(<br>    big_indexes: Receiver&lt;InMemoryIndex&gt;,<br>    output_dir: &amp;Path,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;PathBuf&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp_dir</span> = TmpDir::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> big_indexes &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;word count: &#123;&#125;&quot;</span>, i.word_count);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(i, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(file).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br><br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>start_index_writer_thread</code>流程中，我们将构建好的内存索引一个个写入到文件中，并将生成的文件句柄传入下一个流程。</p><h2 id="merge.rs">merge.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/merge.rs">merge.rs</a></p></blockquote><p>前面 <code>start_index_writer_thread</code> 是将一个个<code>InMemoryIndex</code> 写入到 <code>TmpDir</code>临时目录中。现在我们要将这些临时文件合并成一个最终的索引文件，以优化查询效率和节省存储空间。</p><h3 id="srtuct-filemerge">srtuct: FileMerge</h3><p>我们定义一下结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">FileMerge</span> &#123;<br>    output_dir: PathBuf,<br>    tmp_dir: TmpDir,<br>    stacks: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;PathBuf&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>output_dir</code>: 用于存储最终合并文件的输出目录。</li><li><code>tmp_dir</code>: 前面 <code>tmp.rs</code>定义的结构，用于管理合并过程中产生的临时文件。</li><li><code>stacks</code>:这是一个二维向量，每个内部向量代表一个合并“层”，存储了该层待合并的文件路径。</li></ul><p>关于 <code>stacks</code>，再多说两点：</p><ul><li><strong>多级合并策略</strong>: <code>FileMerge</code>使用一个多层合并策略，这种策略在处理大量文件时尤为有效。基本思想是，当一层的文件数量达到一个预设的阈值（<code>NSTREAMS</code>）时，这些文件会被合并成一个新的文件，新文件则被推送到上一层。这种层级式的处理方式可以显著减少最终合并步骤需要处理的文件数量，从而优化性能。</li><li><strong>动态扩展</strong>：使用<code>Vec&lt;Vec&lt;PathBuf&gt;&gt;</code>允许动态地添加新的合并层，这在处理不确定数量的文件时非常有用。向量的灵活性意味着无需预先知道将处理多少文件，它可以根据实际需要进行扩展。</li></ul><p>接下来我们会为 <code>FileMerge</code> 实现 2 个方法：</p><ul><li><code>add_file</code>:添加一个文件到合并栈中，并使用多级合并策略进行合并。</li><li><code>finish</code>: 执行最后的合并操作，生成最终的索引文件，输出到<code>output_dir</code> 中。</li></ul><h3 id="add_file">add_file</h3><p>首先我们来看<code>add_file</code>，它的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_file</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, <span class="hljs-keyword">mut</span> file: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><span class="hljs-comment">// 从第一层开始检查</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">level</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 使用循环来处理文件的添加和可能的合并。</span><br>    <span class="hljs-keyword">loop</span> &#123;<br><br>      <span class="hljs-comment">// 如果当前的 level （层级）不存在于 stacks 中，</span><br>        <span class="hljs-comment">// 就在 stacks 中添加一个新的空向量。</span><br>        <span class="hljs-comment">// 这是为了存放该层级的文件。</span><br>        <span class="hljs-keyword">if</span> level == <span class="hljs-keyword">self</span>.stacks.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-keyword">self</span>.stacks.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-built_in">vec!</span>[]);<br>        &#125;<br><br>        <span class="hljs-comment">// 将当前的文件添加到对应层级的向量中。</span><br>        <span class="hljs-keyword">self</span>.stacks[level].<span class="hljs-title function_ invoke__">push</span>(file);<br><br>        <span class="hljs-comment">// 如果这个级别的堆栈已满，就合并这个级别的文件。</span><br>      <span class="hljs-comment">// 如果没满，则不进行合并，直接退出。</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.stacks[level].<span class="hljs-title function_ invoke__">len</span>() &lt; NSTREAMS &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建一个新文件来存储合并结果，并更新堆栈。</span><br>        <span class="hljs-keyword">let</span> (filename, out) = <span class="hljs-keyword">self</span>.tmp_dir.<span class="hljs-title function_ invoke__">create</span>()?;<br><br>        <span class="hljs-comment">// 初始化一个空的 to_merge 向量，</span><br>      <span class="hljs-comment">// 然后使用 mem::swap 交换当前层级的文件列表和这个空向量，</span><br>        <span class="hljs-comment">// 这样 to_merge 向量就包含了需要合并的文件，</span><br>        <span class="hljs-comment">// 而当前层级变为空，可以用来存放新的合并文件。</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">to_merge</span> = <span class="hljs-built_in">vec!</span>[];<br>        mem::<span class="hljs-title function_ invoke__">swap</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.stacks[level], &amp;<span class="hljs-keyword">mut</span> to_merge);<br><br>        <span class="hljs-comment">// 调用 merge_streams 函数将 to_merge 中的文件合并到新创建的文件中。</span><br>        <span class="hljs-title function_ invoke__">merge_streams</span>(to_merge, out)?;<br><br>        <span class="hljs-comment">// 将合并后得到的新文件路径赋值给 file 变量，用于下一轮循环。</span><br>        file = filename;<br>        <span class="hljs-comment">// level 加一，表示移动到下一个层级。</span><br>        level += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法通过层级的方式管理文件合并，每个层级可以有多个文件，但数量上限为<code>NSTREAMS</code>。如果某层满了，就将该层的文件合并成一个新文件，并将这个新文件移动到上一层继续参与合并。这种设计有效地将多个文件逐步合并成一个文件，同时控制内存和I/O 资源的使用。</p><p>其中 <code>merge_streams</code>就是具体的合并过程，它的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_streams</span>(files: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, out: BufWriter&lt;File&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>  <span class="hljs-comment">// 从索引文件中构建 IndexFileReader 列表</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">streams</span>: <span class="hljs-type">Vec</span>&lt;IndexFileReader&gt; = files<br>        .<span class="hljs-title function_ invoke__">into_iter</span>()<br>        .<span class="hljs-title function_ invoke__">map</span>(|p| IndexFileReader::<span class="hljs-title function_ invoke__">open_and_delete</span>(p, <span class="hljs-literal">true</span>))<br>        .collect::&lt;io::<span class="hljs-type">Result</span>&lt;_&gt;&gt;()?;<br><br>  <span class="hljs-comment">// 针对输出文件生成一个 IndexFileWriter 用于写入索引信息</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">output</span> = IndexFileWriter::<span class="hljs-title function_ invoke__">new</span>(out)?;<br>  <span class="hljs-comment">// 用于记录当前写入的位置（或者数据偏移量）。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">point</span>: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 记录还有数据未处理的文件流数量，用 peek() 方法检查。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = streams.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|s| s.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">is_some</span>()).<span class="hljs-title function_ invoke__">count</span>();<br><br>  <span class="hljs-comment">// 只要 count 大于0，表示还有文件未完全处理，就继续循环。</span><br>    <span class="hljs-keyword">while</span> count &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">term</span> = <span class="hljs-literal">None</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">nbytes</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">df</span> = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 这段代码通过遍历每个文件流，使用 peek() 方法预览每个文件的当前数据条目</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> &amp;streams &#123;<br>            <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">peek</span>() &#123;<br>                <span class="hljs-literal">None</span> =&gt; &#123;&#125;<br>                <span class="hljs-title function_ invoke__">Some</span>(entry) =&gt; &#123;<br>                  <span class="hljs-comment">// term 是空的，则说明这是表示 doc 的 entry。</span><br>                  <span class="hljs-comment">// 直接退出 for 循环，因为 doc 的 entry 没有顺序且唯一，不会进行累加。</span><br>                    <span class="hljs-keyword">if</span> entry.term.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                        term = <span class="hljs-title function_ invoke__">Some</span>(entry.term.<span class="hljs-title function_ invoke__">clone</span>());<br>                        nbytes = entry.nbytes;<br>                        df = entry.df;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                  <span class="hljs-comment">// term 不是空的，则说明这是表示 terms 的 entry。</span><br>                    <span class="hljs-comment">// 选择词条最小的一个（字典序），并且累加其出现的频次和字节大小。</span><br>                    <span class="hljs-comment">// 这是多路归并的核心，确保输出文件是有序的。</span><br>                    <span class="hljs-keyword">if</span> term.<span class="hljs-title function_ invoke__">is_none</span>() || entry.term &lt; *term.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>() &#123;<br>                        term = <span class="hljs-title function_ invoke__">Some</span>(entry.term.<span class="hljs-title function_ invoke__">clone</span>());<br>                        nbytes = entry.nbytes;<br>                        df = entry.df<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> entry.term == *term.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>() &#123;<br>                        nbytes += entry.nbytes;<br>                        df += entry.df<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">term</span> = term.<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;bug in algorithm&quot;</span>);<br><br>      <span class="hljs-comment">// 对于每个文件流，如果当前数据条目与选择的 term 相同，</span><br>        <span class="hljs-comment">// 则将该条目写入输出文件，并更新该流的读取位置。</span><br>      <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> streams &#123;<br>            <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">is_at</span>(&amp;term) &#123;<br>                s.<span class="hljs-title function_ invoke__">move_entry_to</span>(&amp;<span class="hljs-keyword">mut</span> output)?;<br>                <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>                    count -= <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> term.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        output.<span class="hljs-title function_ invoke__">write_contents_entry</span>(term, df, point, nbytes);<br>        point += nbytes<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到了一个新的结构<code>IndexFileReader</code>，它是索引文件的读取器，我们将在<code>read.rs</code> 中实现它。这里先不展开，你只需要知道：</p><ul><li><code>IndexFileReader::open_and_delete(p, true)</code>:打开一个索引文件，并根据传入的参数判断是否要删除这个文件，在合并过程中，因为都是临时文件，所以我们会指定为删除文件。但是在后面从索引文件中重建<code>InMemoryIndex</code> 的时候，我们不希望删除原始的索引文件。</li><li><code>s.peek()</code>: 查看下一个 Entry，它的返回值是Option&lt;Entry&gt;。</li><li><code>s.move_entry_to(&amp;mut output)</code>: 将<code>s.peek()</code> 指向的 Entry 写入到 output 文件中，并移动到一下Entry。</li></ul><p>总结下来，这个函数实现多路归并的核心部分，它将多个索引文件合并成一个单一的有序文件。</p><h3 id="finish-1">finish</h3><p>我们再来看 <code>FileMerge</code> 的另外一个方法<code>finish</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">finish</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><br>    <span class="hljs-comment">// 初始化一个临时向量 tmp，用来暂存需要合并的文件路径。</span><br>    <span class="hljs-comment">// 这个向量的容量设置为 NSTREAMS，这是预先定义的常量，表示一次可以合并的最大文件数。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(NSTREAMS);<br><br>    <span class="hljs-comment">// 方法遍历 self.stacks 中的每个堆栈。每个堆栈代表一个合并层级，包含若干待合并的文件。</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stack</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.stacks &#123;<br>        <span class="hljs-comment">// 对于每个堆栈，方法使用 .into_iter().rev() 迭代器反向遍历文件，</span><br>      <span class="hljs-comment">// 以确保按正确的顺序处理（先进后出）。</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">file</span> <span class="hljs-keyword">in</span> stack.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>            <span class="hljs-comment">// 将文件逐个添加到 tmp 向量中。</span><br>            tmp.<span class="hljs-title function_ invoke__">push</span>(file);<br>            <span class="hljs-comment">// 当 tmp 的长度达到 NSTREAMS 时，</span><br>          <span class="hljs-comment">// 调用 merge_reversed 函数进行合并。</span><br>            <span class="hljs-keyword">if</span> tmp.<span class="hljs-title function_ invoke__">len</span>() == NSTREAMS &#123;<br>                <span class="hljs-title function_ invoke__">merge_reversed</span>(&amp;<span class="hljs-keyword">mut</span> tmp, &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.tmp_dir)?;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">// 对于剩余文件进行最终的合并。</span><br>    <span class="hljs-keyword">if</span> tmp.<span class="hljs-title function_ invoke__">len</span>() &gt; <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-title function_ invoke__">merge_reversed</span>(&amp;<span class="hljs-keyword">mut</span> tmp, &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.tmp_dir)?;<br>    &#125;<br><br>  <span class="hljs-comment">// 最后应该只有一个最终文件</span><br>    <span class="hljs-built_in">assert!</span>(tmp.<span class="hljs-title function_ invoke__">len</span>() == <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">match</span> tmp.<span class="hljs-title function_ invoke__">pop</span>() &#123;<br>      <span class="hljs-comment">// 对文件进行重命名</span><br>        <span class="hljs-title function_ invoke__">Some</span>(last_file) =&gt; fs::<span class="hljs-title function_ invoke__">rename</span>(last_file, <span class="hljs-keyword">self</span>.output_dir.<span class="hljs-title function_ invoke__">join</span>(MERGED_FILENAME)),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-title function_ invoke__">Err</span>(io::Error::<span class="hljs-title function_ invoke__">new</span>(<br>            io::ErrorKind::Other,<br>            <span class="hljs-string">&quot;no ducuments were parsed or none contained any words&quot;</span>,<br>        )),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到了另外一个函数 <code>merge_reversed</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_reversed</span>(filenames: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, tmp_dir: &amp;<span class="hljs-keyword">mut</span> TmpDir) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    filenames.<span class="hljs-title function_ invoke__">reverse</span>();<br>    <span class="hljs-keyword">let</span> (merge_filename, out) = tmp_dir.<span class="hljs-title function_ invoke__">create</span>()?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">to_merge</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(NSTREAMS);<br>    mem::<span class="hljs-title function_ invoke__">swap</span>(filenames, &amp;<span class="hljs-keyword">mut</span> to_merge);<br>    <span class="hljs-title function_ invoke__">merge_streams</span>(to_merge, out)?;<br>    filenames.<span class="hljs-title function_ invoke__">push</span>(merge_filename);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>它其实就是将 <code>filenames</code> 翻转，清空并将内容转移到<code>to_merge</code>，然后调用 <code>merge_streams</code>合并，并将合并后的文件重新放回被清空的<code>filenames</code>，也就是我们在 <code>finish</code> 中声明的<code>tmp</code> 变量。</p><div class="note note-info">            <p><big><strong>为什么这里需要翻转 filenames？</strong></big></p><p>假设 NSTREAMS = 3，我们执行 <code>add_file</code>，从<code>file1</code> 到 <code>file8</code>，那么过程如下：</p><table><thead><tr class="header"><th>Action</th><th>Stack 0</th><th>Stack 1</th><th>Notes</th></tr></thead><tbody><tr class="odd"><td>Add file1</td><td>file1</td><td></td><td></td></tr><tr class="even"><td>Add file2</td><td>file1, file2</td><td></td><td></td></tr><tr class="odd"><td>Add file3</td><td>file1, file2, file3</td><td></td><td></td></tr><tr class="even"><td>Merge S1</td><td>(empty)</td><td>merge1</td><td><code>merge1</code> is the result of merging file1-file3</td></tr><tr class="odd"><td>Add file4</td><td>file4</td><td>merge1</td><td></td></tr><tr class="even"><td>Add file5</td><td>file4, file5</td><td>merge1</td><td></td></tr><tr class="odd"><td>Add file6</td><td>file4, file5, file6</td><td>merge1</td><td></td></tr><tr class="even"><td>Merge S2</td><td>(empty)</td><td>merge1, merge2</td><td><code>merge2</code> is the result of merging file4-file6</td></tr><tr class="odd"><td>Add file7</td><td>file7</td><td>merge1, merge2</td><td></td></tr><tr class="even"><td>Add file8</td><td>file7, file8</td><td>merge1, merge2</td><td>Trigger merge because 8 files are reached</td></tr></tbody></table><p>最后我们获得的结果是：</p><table><thead><tr class="header"><th>stack0</th><th>stack1</th></tr></thead><tbody><tr class="odd"><td>file7, file8</td><td>merge1, merge2</td></tr></tbody></table><p>按照文件的添加顺序，我们期望在 <code>finish</code>中合并的顺序应该是：merge1, merge2, file7, file8。所以我们遍历<code>stacks</code> 的时候，从第 1 层开始遍历的话，我们就需要反向遍历<code>rev()</code>，这个时候我们组成的 <code>tmp</code> 就是：file8,file7, merge2, merge1。最后我们传入 <code>merge_reversed</code>的时候，再进行 <code>reverse()</code>，就可以获得我们期望的顺序 merge1,merge2, file7, file8。</p>          </div><p>回过头来，我们总结一下<code>finish</code>：这个方法通过多级合并的方式，逐层处理并最终合并所有文件到一个文件。这个方法确保在多个文件频繁合并的环境中，能有效地管理和减少临时存储使用，并保持合并操作的效率。通过最后的重命名操作，它还处理了文件的最终存放，确保合并结果的正确性和可用性。</p><p>实现了 <code>merge.rs</code> 的相关内容，我们就可以来实现<code>create.rs</code> 中的最后一步了。</p><h3 id="step5-merge_index_files">step5: merge_index_files</h3><p>我们将第 4 阶段构建的临时文件合并成一个最终的索引文件并输出到<code>output_dir</code> 目录中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_index_files</span>(files: Receiver&lt;PathBuf&gt;, output_dir: &amp;Path) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">merge</span> = FileMerge::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">file</span> <span class="hljs-keyword">in</span> files &#123;<br>        merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>    &#125;<br>    merge.<span class="hljs-title function_ invoke__">finish</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="run_pipeline">run_pipeline</h3><p>至此，我们就完成了并发构建倒排索引的 5个步骤了，对其进行组织，就可以实现我们的并发构建函数<code>run_pipeline</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_pipeline</span>(documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// Launch all five stages of the pipeline.</span><br>    <span class="hljs-keyword">let</span> (texts, h1) = <span class="hljs-title function_ invoke__">start_file_reader_thread</span>(documents);<br>    <span class="hljs-keyword">let</span> (pints, h2) = <span class="hljs-title function_ invoke__">start_file_indexing_thread</span>(texts);<br>    <span class="hljs-keyword">let</span> (gallons, h3) = <span class="hljs-title function_ invoke__">start_in_memory_merge_thread</span>(pints);<br>    <span class="hljs-keyword">let</span> (files, h4) = <span class="hljs-title function_ invoke__">start_index_writer_thread</span>(gallons, &amp;output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">merge_index_files</span>(files, &amp;output_dir);<br><br>    <span class="hljs-comment">// Wait for threads to finish, holding on to any errors that they encounter.</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = h1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h3.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = h4.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// Return the first error encountered, if any.</span><br>    <span class="hljs-comment">// (As it happens, h2 and h3 can&#x27;t fail: those threads</span><br>    <span class="hljs-comment">// are pure in-memory data processing.)</span><br>    r1?;<br>    r4?;<br>    result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="read.rs">read.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/read.rs">read.rs</a></p></blockquote><p>在 <code>merge.rs</code> 中，我们还剩最后一个结构没有解析，那就是<code>IndexFileReader</code>，它是索引文件的读取器。</p><h3 id="struct-indexfilereader">struct: IndexFileReader</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IndexFileReader</span> &#123;<br>    <span class="hljs-keyword">pub</span> terms_docs: BufReader&lt;File&gt;,<br>    entries: BufReader&lt;File&gt;,<br>    next: <span class="hljs-type">Option</span>&lt;Entry&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">pub</span> term: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> df: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> offset: <span class="hljs-type">u64</span>,<br>    <span class="hljs-keyword">pub</span> nbytes: <span class="hljs-type">u64</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 <code>IndexFileReader</code> 结构体中定义两个<code>BufReader&lt;File&gt;</code>，这是为了有效管理和操作索引文件中的不同数据段。具体来说，这种设计使得代码能够更加灵活和高效地处理索引文件中的“主数据区”和“内容表区”。</p><p>即用来分别处理下图的 <code>terms&amp;doc</code> 和<code>entries</code> 两个区域：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423194529529-20240423195227516.png"alt="索引文件内存结构示意图" /><figcaption aria-hidden="true">索引文件内存结构示意图</figcaption></figure><p>这有几个好处：</p><ul><li><strong>独立的文件指针</strong>：每个<code>BufReader&lt;File&gt;</code>维护自己的文件读取位置（文件指针）。这意味着读取或搜索内容表时，不会影响主数据区的文件指针，反之亦然。这样可以避免频繁地重新定位文件指针，提高文件操作的效率。</li><li><strong>缓冲读取</strong>：<code>BufReader</code>提供了缓冲读取功能，可以减少直接对硬盘的读取次数，从而优化读取性能。对于需要频繁读取小块数据的索引操作，使用缓冲读取可以显著提高效率。</li><li><strong>并行操作</strong>：在多线程环境中，可能需要同时读取主数据区和内容表区。使用两个独立的<code>BufReader</code>实例可以简化并行读取的管理，每个读取操作都可以在不干扰另一个操作的情况下独立进行。</li></ul><p><code>Entry</code> 就是我们在 <code>write.rs</code> 中<code>write_contents_entry</code> 时传入的参数，这里我们将其封装成一个struct，再次回顾下这几个字段的含义：</p><ul><li><code>term</code>: 索引单词。为了统一，如果 <code>term</code>为空，则表示当前表示的是 doc，否则为 terms。</li><li><code>df</code>: term 的出现次数。为了统一，如果 <code>df</code> 为0，则表示当前表示的是 doc，否则为 terms。</li><li><code>offset</code>: 对应的 terms 或 docs 在文件中的偏移。</li><li><code>nbytes</code>: 对应的 terms 或 docs 的总长度。</li></ul><h3 id="read_entry">read_entry</h3><p>这里我们重点解释一下 <code>read_entry</code>方法，其他的都比较简单，请在源码中查找。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_entry</span>(f: &amp;<span class="hljs-keyword">mut</span> BufReader&lt;File&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">Option</span>&lt;Entry&gt;&gt; &#123;<br>  <span class="hljs-comment">// 获取偏移值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">offset</span> = <span class="hljs-keyword">match</span> f.read_u64::&lt;LittleEndian&gt;() &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(value) =&gt; value,<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> err.<span class="hljs-title function_ invoke__">kind</span>() == io::ErrorKind::UnexpectedEof &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-literal">None</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(err);<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>  <span class="hljs-comment">// 读取 nbytes</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">nbytes</span> = f.read_u64::&lt;LittleEndian&gt;()?;<br>  <span class="hljs-comment">// 读取 df</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">df</span> = f.read_u32::&lt;LittleEndian&gt;()?;<br>  <span class="hljs-comment">// 读取 term_len，并初始化一块内存 bytes 用来读取完整的 term</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">term_len</span> = f.read_u32::&lt;LittleEndian&gt;()? <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">bytes</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; term_len];<br>    f.<span class="hljs-title function_ invoke__">read_exact</span>(&amp;<span class="hljs-keyword">mut</span> bytes)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">term</span> = <span class="hljs-keyword">match</span> <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(bytes) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(s) =&gt; s,<br>        <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(io::Error::<span class="hljs-title function_ invoke__">new</span>(io::ErrorKind::Other, <span class="hljs-string">&quot;unicode fail&quot;</span>)),<br>    &#125;;<br><br>  <span class="hljs-comment">// 返回构建的 Entry</span><br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">Some</span>(Entry &#123;<br>        term,<br>        df,<br>        offset,<br>        nbytes,<br>    &#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>结合下面这张图，很容易理解 <code>read_entry</code> 就是前面<code>write_contents_entry</code> 的逆向过程。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423224035544.png"alt="entries 区域布局，每个 entry 紧贴排布" /><figcaption aria-hidden="true">entries 区域布局，每个 entry紧贴排布</figcaption></figure><h2 id="create.rs-1">create.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/bin/create.rs">create.rs</a></p></blockquote><p>至此，我们就分析完并发构建索引的整个过程了，在 <code>create.rs</code>中，我们使用 <code>clap</code> 命令解析框架来构建一个 CLI工具用以支持构建索引，我们同时支持单线程构建和并发构建，具体可看完整源码。</p><p>如果对 <code>clap</code> 不熟悉的读者，可参考：<ahref="https://hedon.top/2024/03/02/rust-crate-clap/">深入探索 Rust 的clap 库：命令行解析的艺术</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Opts</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, default_value_t = false, help = <span class="hljs-string">&quot;Default false&quot;</span>)]</span><br>    single_threaded: <span class="hljs-type">bool</span>,<br><br>    <span class="hljs-meta">#[arg(required = true)]</span><br>    filenames: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">opts</span> = Opts::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">run</span>(opts.filenames, opts.single_threaded) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(()) =&gt; &#123;&#125;<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error: &#123;&#125;&quot;</span>, err),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="搜索功能">搜索功能</h1><p>在《Rust程序设计（第二版）》中，作者并没有实现搜索功能，笔者对其进行扩展，目标是对标我们前篇所构建的<ahref="https://hedon.top/2024/04/15/rust-action-inverted-index-demo/">Rust实战丨倒排索引</a>。这个搜索功能，会根据现有的索引文件重建内存索引<code>InMemoryIndex</code>，支持指定 <code>term</code>进行搜索，并将包含这个 <code>term</code>的文件在响应的位置中进行高亮显示并输出到终端。</p><h2 id="search.rs-1">search.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/bin/search.rs">search.rs</a></p></blockquote><p>程序入口如下所示，比较简单，就不赘述了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Opts</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, required = true, help = <span class="hljs-string">&quot;Specify index file path&quot;</span>)]</span><br>    index_file: <span class="hljs-type">String</span>,<br>    <span class="hljs-meta">#[arg(short, long, required = true, help = <span class="hljs-string">&quot;Specify search term&quot;</span>)]</span><br>    term: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">opts</span> = Opts::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_index_file</span>(opts.index_file)?;<br>    index.<span class="hljs-title function_ invoke__">search</span>(&amp;opts.term)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有 2 个核心逻辑：</p><ul><li><code>InMemoryIndex::from_index_file</code>:根据索引文件重建内存索引。</li><li><code>index.search(term)</code>: 搜索。</li></ul><h2 id="index.rs-1">index.rs</h2><p>我们在 <code>index.rs</code> 中为 <code>InMemoryIndex</code> 实现上述2 个方法。</p><h3 id="from_index_file">from_index_file</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_index_file</span>&lt;P: <span class="hljs-built_in">AsRef</span>&lt;Path&gt;&gt;(filename: P) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;InMemoryIndex&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br><br>  <span class="hljs-comment">// 获取 IndexFileReader</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">reader</span> = IndexFileReader::<span class="hljs-title function_ invoke__">open_and_delete</span>(filename, <span class="hljs-literal">false</span>)?;<br><br>  <span class="hljs-comment">// 依次解析每个 Entry</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(entry) = reader.<span class="hljs-title function_ invoke__">iter_next_entry</span>() &#123;<br>        <span class="hljs-keyword">if</span> entry.term.<span class="hljs-title function_ invoke__">is_empty</span>() &amp;&amp; entry.df == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 当前 Entry 指向的是一个 Document。</span><br>          <span class="hljs-comment">// 通过 terms_docs 读取 Document 所在位置并进行解析。</span><br>            reader.terms_docs.<span class="hljs-title function_ invoke__">seek</span>(io::SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(entry.offset))?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">doc_id</span> = reader.terms_docs.read_u32::&lt;LittleEndian&gt;()?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">path_len</span> = reader.terms_docs.read_u64::&lt;LittleEndian&gt;()?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">path</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0u8</span>; path_len <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];<br>            reader.terms_docs.<span class="hljs-title function_ invoke__">read_exact</span>(&amp;<span class="hljs-keyword">mut</span> path)?;<br>            index.docs.<span class="hljs-title function_ invoke__">insert</span>(<br>                doc_id,<br>                Document &#123;<br>                    id: doc_id,<br>                    path: <span class="hljs-title function_ invoke__">vec_to_pathbuf</span>(path),<br>                &#125;,<br>            );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当前 Entry 指向的是一个 terms。</span><br>          <span class="hljs-comment">// 通过 terms_docs 读取 terms 所在位置并进行解析。</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hits</span> = <span class="hljs-built_in">vec!</span>[];<br>            reader.terms_docs.<span class="hljs-title function_ invoke__">seek</span>(io::SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(entry.offset))?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">data</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0u8</span>; entry.nbytes <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];<br>            reader.terms_docs.<span class="hljs-title function_ invoke__">read_exact</span>(&amp;<span class="hljs-keyword">mut</span> data)?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cursor</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(data);<br><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = entry.df;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">has_hit</span> = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">quit</span> = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; !quit &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hit</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span>); <span class="hljs-comment">// cannot use vec![0;12]</span><br>                <span class="hljs-keyword">loop</span> &#123;<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(item) = cursor.read_i32::&lt;LittleEndian&gt;() &#123;<br>                        <span class="hljs-comment">// the start of next hit</span><br>                        <span class="hljs-keyword">if</span> item == <span class="hljs-keyword">Self</span>::HITS_SEPERATOR &amp;&amp; has_hit &#123;<br>                            hits.<span class="hljs-title function_ invoke__">push</span>(hit);<br>                            i -= <span class="hljs-number">1</span>;<br>                            index.word_count -= <span class="hljs-number">2</span>;<br>                            hit = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span>);<br>                        &#125;<br>                        has_hit = <span class="hljs-literal">true</span>;<br>                        hit.write_u32::&lt;LittleEndian&gt;(item <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>                        index.word_count += <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        quit = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">if</span> !hit.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                            hits.<span class="hljs-title function_ invoke__">push</span>(hit);<br>                            index.word_count -= <span class="hljs-number">2</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            index.terms.<span class="hljs-title function_ invoke__">insert</span>(entry.term, hits);<br>        &#125;<br>    &#125;<br>    index.word_count /= <span class="hljs-number">2</span>;<br>    <span class="hljs-title function_ invoke__">Ok</span>(index)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="search">search</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">self</span>, term: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>  <span class="hljs-comment">// 获取 term 出现的位置</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span>: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;&gt;&gt; = <span class="hljs-keyword">self</span>.terms.<span class="hljs-title function_ invoke__">get</span>(term);<br>    <span class="hljs-keyword">if</span> m.<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;can not found &#123;&#125; in all documents&quot;</span>, term);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(());<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hits</span> = m.<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>  <span class="hljs-comment">// 遍历每个出现的位置</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">hit</span> <span class="hljs-keyword">in</span> hits &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cursor</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(hit);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = cursor.read_i32::&lt;LittleEndian&gt;().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>      <span class="hljs-comment">// 获取文档原始信息</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">document_id</span> = cursor.read_u32::&lt;LittleEndian&gt;().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">doc</span> = <span class="hljs-keyword">self</span>.docs.<span class="hljs-title function_ invoke__">get</span>(&amp;document_id);<br>        <span class="hljs-keyword">if</span> doc.<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;cannot found document &#123;&#125;&quot;</span>, document_id);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">doc</span> = doc.<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>      <span class="hljs-comment">// hits 存储的内容：[HITS_SEPERATOR, document_id, start_pos1, end_pos1, ...]</span><br>      <span class="hljs-comment">// 解析 term 出现在 doc 中的每个位置</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">poss</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(hits.<span class="hljs-title function_ invoke__">len</span>() / <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">pos</span> = TokenPos::<span class="hljs-title function_ invoke__">default</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">has_pos</span> = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(p) = cursor.read_u32::&lt;LittleEndian&gt;() &#123;<br>            <span class="hljs-keyword">if</span> !has_pos &#123;<br>                pos.start_pos = p;<br>                has_pos = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pos.end_pos = p;<br>                poss.<span class="hljs-title function_ invoke__">push</span>(pos);<br>                pos = TokenPos::<span class="hljs-title function_ invoke__">default</span>();<br>                has_pos = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>      <span class="hljs-comment">// 对每个出现的位置进行高亮处理</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">highlight_file</span>(doc.path.<span class="hljs-title function_ invoke__">clone</span>(), &amp;<span class="hljs-keyword">mut</span> poss)?;<br>      <span class="hljs-comment">// 输出高亮后的结果</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;\n&#123;:?&#125;: \n&#123;&#125;&quot;</span>, doc.path, result);<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>至此，我们就实现了高并发构建索引和根据索引进行搜索的功能，本篇某些部分可能比较复杂，篇幅也比较冗长，笔者在阅读书中原实现的时候，也是获益颇丰，想不到一个简单的倒排索引竟涉及这么多的处理细节。也希望本篇文章能对感兴趣的读者有些许帮助。</p><p>peace! enjoy coding~</p><h1 id="绘图工具">绘图工具</h1><ul><li><ahref="https://link.zhihu.com/?target=https%3A//excalidraw.com/">https://excalidraw.com/</a></li></ul><h1 id="参考资料">参考资料</h1><ul><li><ahref="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Inverted_index">维基百科·倒排索引</a></li><li><ahref="https://link.zhihu.com/?target=https%3A//book.douban.com/subject/36547630/">Rust程序设计（第二版）</a></li></ul>]]></content>
    
    
    <summary type="html">本文详细阐述了使用 Rust channel 并发构建倒排索引的详细过程。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="倒排索引" scheme="https://hedon.top/tags/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="通道" scheme="https://hedon.top/tags/%E9%80%9A%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨倒排索引</title>
    <link href="https://hedon.top/2024/04/15/rust-action-inverted-index-demo/"/>
    <id>https://hedon.top/2024/04/15/rust-action-inverted-index-demo/</id>
    <published>2024-04-15T02:24:17.000Z</published>
    <updated>2024-04-21T15:53:41.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>倒排索引（InvertedIndex）是一种索引数据结构，用于存储某个单词（词项）在一组文档中的所有出现情况的映射。它是搜索引擎执行快速全文搜索的核心技术，也广泛用于数据库中进行文本搜索。我们熟知的ElasticSearch 最核心底层原理便就是倒排索引。</p><p>倒排索引的基本原理是<strong>将文档中的词汇进行反转，形成倒排列表</strong>。在倒排列表中，每个词汇都对应一个文档标识符的列表，这些标识符指明了该词汇出现在哪些文档中。通过查询倒排列表，可以快速地找到包含特定词汇的文档。</p><p>本文将使用 Rust语言来实现一个简单的倒排索引，包括倒排索引的构建和搜索过程。在下一篇文章中，笔者会基于《Rust程序设计（第二版）》并发编程篇章，解读该书作者是如何基于 Rust通道实现更优秀、更高性能的倒排索引。</p><h1 id="可以学到">可以学到</h1><ol type="1"><li>倒排索引的原理、优势和使用</li><li>常用 crate：<code>colored</code>、<code>regex</code></li><li>Rust HashMap</li><li>Rust 迭代器</li></ol><h1 id="开发思路">开发思路</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240414112337590.png"alt="倒排索引构建过程" /><figcaption aria-hidden="true">倒排索引构建过程</figcaption></figure><p>一个简单的倒排索引开发思路大概如上图所示：</p><ol type="1"><li>读取文档</li><li>分词</li><li>构建每个词到每个文档的映射</li></ol><h1 id="开发过程">开发过程</h1><blockquote><p>完整源码位于：<ahref="https://github.com/hedon-rust-road/inverted-index">inverted_index</a>。</p></blockquote><h2 id="最终效果">最终效果</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index</span> = InvertedIndex::<span class="hljs-title function_ invoke__">new</span>();<br>    index.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Rust is safe and fast.&quot;</span>);<br>    index.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Rust is a systems programming language.&quot;</span>);<br>    index.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Programming in Rust is fun.&quot;</span>);<br><br>    <span class="hljs-comment">// query &quot;Rust&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">results</span> = index.<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;Rust&quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">result</span> <span class="hljs-keyword">in</span> results &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-comment">// query &quot;Programming&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">results</span> = index.<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;Programming&quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">result</span> <span class="hljs-keyword">in</span> results &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo run<br></code></pre></td></tr></table></figure><p>输出：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240414122848805.png"alt="inverted index 输出示例" /><figcaption aria-hidden="true">inverted index 输出示例</figcaption></figure><h2 id="版本声明">版本声明</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;inverted_index&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">colored</span> = <span class="hljs-string">&quot;2.1.0&quot;</span><br><span class="hljs-attr">regex</span> = <span class="hljs-string">&quot;1.10.4&quot;</span><br></code></pre></td></tr></table></figure><h2 id="项目准备">项目准备</h2><p>首先我们创建项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new inverted_index<br></code></pre></td></tr></table></figure><p>准备依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add regex<br>cargo add colored<br></code></pre></td></tr></table></figure><ul><li>colored:终端高亮，后面我们将实现搜索词的高亮显示，使结果更美观。</li><li>regex: 正则库，用于实现不区分大小写替换匹配到的搜索词。</li></ul><h2 id="实现过程">实现过程</h2><p>首先我们定义两个数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Document</span> &#123;<br>    id: <span class="hljs-type">usize</span>,<br>    content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>    indexes: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt;&gt;,<br>    documents: HashMap&lt;<span class="hljs-type">usize</span>, Document&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> InvertedIndex &#123;<br>        InvertedIndex &#123;<br>            indexes: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>            documents: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Document: 封装原始文档</li><li>IndexedIndex: 我们将构建的倒排索引</li></ul><p>接下来我们要实现 2 个辅助函数，一个是<code>tokenize</code>，用于将原始的文档信息拆分成独立的词（word/term），另一个是<code>hightlight</code>，用于将匹配到的文本进行替换，使其在中断可以以<font color="purple">紫色</font>输出。</p><p><code>tokenize</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tokenize</span>(text: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-type">str</span>&gt; &#123;<br>    text.<span class="hljs-title function_ invoke__">split</span>(|ch: <span class="hljs-type">char</span>| !ch.<span class="hljs-title function_ invoke__">is_alphanumeric</span>())<br>        .<span class="hljs-title function_ invoke__">filter</span>(|c| !c.<span class="hljs-title function_ invoke__">is_empty</span>())<br>        .<span class="hljs-title function_ invoke__">collect</span>()<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tokenize_test</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        <span class="hljs-title function_ invoke__">tokenize</span>(<span class="hljs-string">&quot;This is\nhedon&#x27;s tokenize function.&quot;</span>),<br>        <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;This&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;hedon&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;tokenize&quot;</span>, <span class="hljs-string">&quot;function&quot;</span>]<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>highlight</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">highlight</span>(term: &amp;<span class="hljs-type">str</span>, content: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">regex</span> = Regex::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-built_in">format!</span>(<span class="hljs-string">r&quot;(?i)&#123;&#125;&quot;</span>, term)).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">highlighted_content</span> = regex<br>        .<span class="hljs-title function_ invoke__">replace_all</span>(content, |caps: &amp;regex::Captures| &#123;<br>            caps[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">purple</span>().<span class="hljs-title function_ invoke__">to_string</span>()<br>        &#125;)<br>        .<span class="hljs-title function_ invoke__">to_string</span>();<br>    highlighted_content<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">highlight_test</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        <span class="hljs-title function_ invoke__">highlight</span>(<span class="hljs-string">&quot;programming&quot;</span>, <span class="hljs-string">&quot;I like programming with Rust Programming&quot;</span>),<br>        <span class="hljs-string">&quot;I like \u&#123;1b&#125;[35mprogramming\u&#123;1b&#125;[0m with Rust \u&#123;1b&#125;[35mProgramming\u&#123;1b&#125;[0m&quot;</span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以为 <code>InvertedIndex</code> 实现构建索引的方法<code>add</code>了，它会接收原始文档，对其进行分词，并将记录每个分词和文档 id的映射。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, doc_id: <span class="hljs-type">usize</span>, content: &amp;<span class="hljs-type">str</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">content_lowercase</span> = content.<span class="hljs-title function_ invoke__">to_lowercase</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">words</span> = <span class="hljs-title function_ invoke__">tokenize</span>(&amp;content_lowercase);<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> words &#123;<br>            <span class="hljs-keyword">self</span>.indexes<br>                .<span class="hljs-title function_ invoke__">entry</span>(word.<span class="hljs-title function_ invoke__">to_string</span>())<br>                .<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-built_in">vec!</span>[])<br>                .<span class="hljs-title function_ invoke__">push</span>(doc_id)<br>        &#125;<br><br>        <span class="hljs-keyword">self</span>.documents.<span class="hljs-title function_ invoke__">insert</span>(<br>            doc_id,<br>            Document &#123;<br>                id: doc_id,<br>                content: content.<span class="hljs-title function_ invoke__">to_string</span>(),<br>            &#125;,<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们再实现对应的根据分词 <code>term</code>搜索原始文档的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">query</span>(&amp;<span class="hljs-keyword">self</span>, term: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">term_lowercase</span> = term.<span class="hljs-title function_ invoke__">to_lowercase</span>();<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(doc_ids) = <span class="hljs-keyword">self</span>.indexes.<span class="hljs-title function_ invoke__">get</span>(&amp;term_lowercase) &#123;<br>            doc_ids<br>                .<span class="hljs-title function_ invoke__">iter</span>()<br>                .<span class="hljs-title function_ invoke__">filter_map</span>(|doc_id| &#123;<br>                    <span class="hljs-keyword">self</span>.documents<br>                        .<span class="hljs-title function_ invoke__">get</span>(doc_id)<br>                        .<span class="hljs-title function_ invoke__">map</span>(|doc| <span class="hljs-title function_ invoke__">highlight</span>(&amp;term_lowercase, &amp;doc.content))<br>                &#125;)<br>                .<span class="hljs-title function_ invoke__">collect</span>()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一个简单的倒排索引构建和搜索功能就完成了，具体的执行效果你可以回到前面的「最终效果」进行查阅。</p><h1 id="总结预告">总结预告</h1><p>本文实现的倒排索引虽然非常简单，但是也基本体现了倒排索引的最核心思想和应用方式了。在《Rust程序设计（第二版）》的并发编程篇章中，该书提出了使用通道 channel来并发构建倒排索引，同时给出了更加丰富和优雅的实现。在下篇文章中，笔者将阅读这部分的源码，解析并重现当中的实战过程，并进行适当扩展。</p><p>peace! enjoy coding~</p><h1 id="绘图工具">绘图工具</h1><ul><li>https://excalidraw.com/</li></ul><h1 id="参考资料">参考资料</h1><ul><li><ahref="https://en.wikipedia.org/wiki/Inverted_index">维基百科·倒排索引</a></li><li><a href="https://book.douban.com/subject/36547630/">Rust程序设计（第二版）</a></li></ul>]]></content>
    
    
    <summary type="html">本文将使用 Rust 实现一个简单的倒排索引。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="倒排索引" scheme="https://hedon.top/tags/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Go 语言的 defer 机制</title>
    <link href="https://hedon.top/2024/03/28/go-defer/"/>
    <id>https://hedon.top/2024/03/28/go-defer/</id>
    <published>2024-03-28T12:34:50.000Z</published>
    <updated>2024-04-14T15:12:49.119Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言以其简洁的语法和强大的并发支持而闻名。在这些特性中，<code>defer</code>语句是 Go语言提供的一项独特功能，它允许我们推迟函数的执行直到包含它的函数即将返回。这个简单而强大的机制不仅可以帮助我们处理资源释放和错误处理，还能让代码更加简洁和安全。本文将深入浅出地介绍<code>defer</code>的工作原理，探究其背后的机制，并通过丰富的案例来展示它的实际应用。</p><p>笔者本来以为 Go 语言的 <code>defer</code>其实东西不多，就是类似于“栈”的操作罢了，无非就是用于释放资源、后进先出而已。但是最近在阅读完《深入理解Go 语言》、《Go 底层原理剖析》和《Go 语言设计与实现》中关于<code>defer</code>的篇章。发现其中隐含的道道和坑还是比较有意思的，特此整理这篇文章，希望能对Go <code>defer</code> 原理感兴趣的读者带来一些帮助。</p><p>本文具体会包含以下内容：</p><ul><li><strong><code>defer</code> 机制简介</strong>：介绍<code>defer</code> 关键字的基本概念和它在 Go 语言中的作用。</li><li><strong><code>defer</code> 的工作原理</strong>：深入探讨<code>defer</code> 在函数执行结束时如何工作的细节。</li><li><strong><code>defer</code> 的执行顺序</strong>：解释<code>defer</code> 语句是如何按照后进先出（LIFO）的顺序执行的。</li><li><strong>参数预计算和值传递</strong>：讨论 <code>defer</code>语句中参数是如何被预先计算和传递的。</li><li><strong>环境变量和闭包</strong>：探讨 <code>defer</code>如何与闭包一起工作，以及如何捕获和影响环境变量。</li><li><strong><code>defer</code> 与错误处理</strong>：说明如何利用<code>defer</code> 和 <code>recover</code> 进行错误处理和异常捕获。</li><li><strong><code>defer</code> 的实现细节</strong>：深入分析<code>defer</code>的不同实现策略，包括堆上分配、栈上分配和开放编码。</li></ul><h1 id="版本声明">版本声明</h1><ul><li>Go1.22</li></ul><h1 id="思维导图">思维导图</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Go%20defer.png"alt="Go defer" /><figcaption aria-hidden="true">Go defer</figcaption></figure><h1 id="核心要点">核心要点</h1><p>对于后面将要分析的各种各样的情况，在分析的时候只要遵循以下几个核心点，基本上就不会跑偏：</p><ol type="1"><li>延迟执行：在函数结束时执行，包括正常返回或遭遇 panic。</li><li>栈式执行顺序：后定义的 <code>defer</code> 先执行（LIFO）。</li><li>参数预计算：<code>defer</code> 语句定义时即计算并固定参数值。</li><li>值传递原则：<code>defer</code> 拷贝参数，使用定义时的值。</li><li>环境变量捕获：在 <code>defer</code>中可以跟一个闭包，闭包可以捕获环境变量，当然这包括具名返回值。</li></ol><p>特别说明的是，虽然我们通常将 <code>defer</code>想象为使用栈进行管理，但是实际实现上，<code>defer</code>并不都是存放在栈上的，我们后面会具体分析到。这种实现细节通常对于编写正确的Go代码并不重要，但了解这一点对于深入理解语言内部机制可能是有帮助的。</p><h1 id="基本用法">基本用法</h1><p>在 Go 语言中，<code>defer</code>语句通常用于确保一个函数调用在程序执行结束时发生，常见的用例包括文件关闭、锁释放、资源回收等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    f, err := os.Open(filename)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-comment">// 确保文件在函数返回时关闭</span><br>    <span class="hljs-keyword">defer</span> f.Close()<br><br>    <span class="hljs-comment">// ... 处理文件 ...</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>defer f.Close()</code> 保证了无论<code>readFile</code>函数如何返回（正常返回或发生错误），<code>f.Close()</code>都会被调用，从而避免了资源泄露。</p><h1 id="执行顺序">执行顺序</h1><p><code>defer</code>的执行顺序是先进后出，即“栈”操作。这里借用刘丹冰老师的一张图来演示这个过程：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1651037338287-fd17c81d-a1ad-4bc7-ae7e-eec8a264af5f.jpeg"alt="Go defer 执行顺序" /><figcaption aria-hidden="true">Go defer 执行顺序</figcaption></figure><p>我们可以通过以下代码进行验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func1...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func2...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func3...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> func1()<br><span class="hljs-keyword">defer</span> func2()<br><span class="hljs-keyword">defer</span> func3()<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">func3</span></span>...<br><span class="hljs-function"><span class="hljs-title">func2</span></span>...<br><span class="hljs-function"><span class="hljs-title">func1</span></span>...<br></code></pre></td></tr></table></figure><h1 id="参数求值与陷阱">参数求值与陷阱</h1><p>关于 <code>defer</code>参数这一块，是一个比较容易出错的地方。我们先来看一个例子，你可以分析下它的输出会是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printI</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;printI i:&quot;</span>, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">10</span><br><span class="hljs-keyword">defer</span> printI(i * <span class="hljs-number">10</span>)<br>i = i + <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;main i:&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure><p>按照我们之前总结的核心点：<strong>参数预计算：<code>defer</code>语句定义时即计算并固定参数值</strong>。具体来说，在把 <code>defer</code>压入“栈”时，会同时压入<strong>函数地址</strong>和<strong>函数形参</strong>，也就是会在这个时候就把参数先算好。所以在执行到第7 行代码的时候，就会把 <code>i*10</code> 算好，然后同<code>printI</code> 一同压入到延迟执行栈中。</p><p>所以最后的结果就是：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">i</span>: <span class="hljs-number">11</span><br><span class="hljs-selector-tag">printI</span> <span class="hljs-selector-tag">i</span>: <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>关于<strong>参数值传递</strong>，笔者这里再举两个例子进行比较，体会后你应该就理解了。</p><p>第一个例子中，<code>defer</code>后面参数是指针，本质上<strong>值传递</strong>，但是拷贝的是指针，所以在<code>defer</code> 中修改的东西，最后会反馈到指针指向的对象，所以对<code>testUser</code> 的返回值是有影响的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span>&#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testUser</span><span class="hljs-params">()</span></span> *User &#123;<br>user := &amp;User&#123;&#125;<br>user.name = <span class="hljs-string">&quot;name-1&quot;</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u *User)</span></span> &#123;<br>u.name = <span class="hljs-string">&quot;name-defer&quot;</span><br>&#125;(user)<br><br>user.name = <span class="hljs-string">&quot;name-2&quot;</span><br><span class="hljs-keyword">return</span> user<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>user := testUser()<br>fmt.Println(user)<br>&#125;<br><span class="hljs-comment">// &amp;&#123;name-defer&#125;</span><br></code></pre></td></tr></table></figure><p>第二个例子中，我们传入的就是结构体示例本身了，因为值传递，即拷贝了一份新的<code>user</code>，所以闭包内的修改对外面是不产生影响的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testUser</span><span class="hljs-params">()</span></span> User &#123;<br>user := User&#123;&#125;<br>user.name = <span class="hljs-string">&quot;name-1&quot;</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u User)</span></span> &#123;<br>u.name = <span class="hljs-string">&quot;name-defer&quot;</span><br>&#125;(user)<br><br>user.name = <span class="hljs-string">&quot;name-2&quot;</span><br><span class="hljs-keyword">return</span> user<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>user := testUser()<br>fmt.Println(user)<br>&#125;<br><span class="hljs-comment">// &#123;name-2&#125;</span><br></code></pre></td></tr></table></figure><h1 id="环境变量捕获">环境变量捕获</h1><p>将上面的一个例子进行简单修改，会输出什么呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printI</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;printI i:&quot;</span>, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">10</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>printI(i * <span class="hljs-number">10</span>)<br>&#125;()<br>i = i + <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;main i:&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候其实没有参数，所以会直接将下面闭包压入延迟栈中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  printI(i * <span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>而闭包是可以捕获环境变量的，所以在 <code>main</code> return后，<code>defer</code> 可以捕获到 <code>i</code> 的值，为更新后的<code>i+1</code>，最后再进行 <code>printI(i * 10)</code>。</p><p>所以输出结果是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">main i: <span class="hljs-number">11</span><br>printI i: <span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>所以说，<code>defer</code>后面的闭包，是可以捕获环境变量的，如果这个变量是返回值的话，那么理所应当也是可以对其产生作用的，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getI</span><span class="hljs-params">()</span></span> (i <span class="hljs-type">int</span>) &#123;<br>i = <span class="hljs-number">1</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i *= <span class="hljs-number">10</span><br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(getI())<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，<code>getI</code> 的返回值是有名字的<code>i</code>，<code>getI</code> 执行了<code>return 20</code>，其实就是将 <code>i</code> 设置为<code>20</code>，所以在执行到 <code>defer</code> 闭包的时候，捕获到了<code>i=20</code>，并将其进行了修改。所以最终输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h1 id="错误处理与-defer">错误处理与 defer</h1><p>我们都知道 Go 程序中遇到 <code>panic</code>就会中断后面的执行流程直接返回，这个时候我们可以在 <code>defer</code>中结合 <code>recover</code> 来捕获这个<code>panic</code>，从而保护程序不崩溃。</p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panicAndRecover</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;函数中正常流程&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;出现异常&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;panic 后的语句永远执行不到&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>panicAndRecover()<br>fmt.Println(<span class="hljs-string">&quot;正常回到 main&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 函数中正常流程</span><br><span class="hljs-comment">// 出现异常</span><br><span class="hljs-comment">// 正常回到 main</span><br></code></pre></td></tr></table></figure><p>更进一步，如果我们在 <code>defer</code> 中也有 <code>panic</code>呢？请思考下列代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panicAndRecover</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;第 1 个入栈的 defer&quot;</span>)<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;最终捕获的 panic:&quot;</span>, err)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;第 2 个入栈的 defer&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;第 2 个入栈的 defer 发生 panic&quot;</span>)<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;panicAndRecover 函数中正常流程&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panicAndRecover 出现异常&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;panic 后的语句永远执行不到&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>panicAndRecover()<br>fmt.Println(<span class="hljs-string">&quot;正常回到 main&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们在 <code>panicAndRecover</code> 强行抛出<code>panic</code>，由于 <code>defer</code> 先进后出，所以我们会先执行第2 个 <code>defer</code>，其中也发生了 <code>panic</code>，我们在第 1 个<code>defer</code> 中对 <code>panic</code> 进行<code>recover</code>，最终的现象是只捕获到了后面抛出的<code>panic</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">panicAndRecover 函数中正常流程<br>第 <span class="hljs-number">2</span> 个入栈的 <span class="hljs-keyword">defer</span><br>第 <span class="hljs-number">1</span> 个入栈的 <span class="hljs-keyword">defer</span><br>最终捕获的 <span class="hljs-built_in">panic</span>: 第 <span class="hljs-number">2</span> 个入栈的 <span class="hljs-keyword">defer</span> 发生 <span class="hljs-built_in">panic</span><br>正常回到 main<br></code></pre></td></tr></table></figure><p>这是为什么呢？</p><p>在 Go 语言中，<code>panic</code> 函数实际上是创建了一个<code>panic</code> 对象，并抛出这个对象。</p><p>当一个 <code>panic</code> 发生并开始向上传播时，Go 运行时会检查每个<code>defer</code>。如果 <code>defer</code> 中包含 <code>recover</code>调用，并且它被执行，那么 <code>recover</code> 会捕获当前的<code>panic</code>，并且防止它继续向上传播。如果 <code>defer</code>中再次发生 <code>panic</code>，那么原来的 <code>panic</code> 就不会被<code>recover</code> 捕获，因为 <code>defer</code>函数已经退出了。在这种情况下，新的 <code>panic</code>会导致程序崩溃，因为没有更多的 <code>defer</code> 函数去<code>recover</code> 这个新的 <code>panic</code>。</p><p>这说明了 Go 程序中不允许同时有多个活跃的 <code>panic</code>存在，这个设计确保了在任何给定的时刻，只有一个 <code>panic</code>能够被处理。这样做有几个原因：</p><ol type="1"><li><strong>简化错误处理：</strong> 如果同时存在多个<code>panic</code>，就会变得非常复杂去确定如何处理它们，尤其是在它们之间存在依赖关系的时候。一个<code>panic</code>应该表示一个不可恢复的错误，如果有多个这样的错误同时存在，程序的状态可能会变得非常不确定。</li><li><strong>保持一致性：</strong> <code>panic</code>通常表示程序中出现了严重错误，可能会破坏程序的一致性或安全性。如果允许多个<code>panic</code> 同时存在，就很难保证程序状态的一致性，因为不同的<code>panic</code> 可能需要回退不同的操作。</li><li><strong>避免资源泄漏：</strong> <code>defer</code>语句用于确保资源被释放，例如文件和锁。如果在处理一个 <code>panic</code>的过程中，又发生了另一个 <code>panic</code>，可能会导致<code>defer</code> 语句中剩余的清理代码无法执行，从而引起资源泄漏。</li><li><strong>控制流程清晰：</strong> <code>panic</code> 和<code>recover</code> 的设计使得错误的控制流程清晰且可预测。一旦一个<code>panic</code> 被 <code>recover</code>捕获，程序可以选择是否继续执行，或者是通过重新 <code>panic</code>来终止程序。这种决策过程在多个 <code>panic</code>情况下会变得复杂且难以管理。</li></ol><p>因此，在 Go 的设计中，不允许同时存在多个活跃的<code>panic</code>。一旦发生 <code>panic</code>，它必须被<code>recover</code>处理，否则程序将会终止。这确保了错误处理的清晰性和程序的稳定性。</p><h1 id="defer-放在哪">defer 放在哪</h1><p><code>defer</code> 实际上不一定是放在栈上的，截止Go1.22，<code>defer</code> 其实用 3 种分配策略：</p><ul><li>堆上分配</li><li>栈上分配</li><li>开放编码</li></ul><h2 id="执行机制">执行机制</h2><p>在 <ahref="https://github.com/golang/go/blob/release-branch.go1.22/src/cmd/compile/internal/ssagen/ssa.go">ssa.go</a>文件中，我们可以找到 <code>state.stmt()</code>，这个函数是负责在 Go程序编译过程中中间代码生成阶段时对不同语句的处理过程，其中对于<code>ODEFER</code> 即 <code>defer</code> 语句的处理逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// stmt converts the statement n to SSA and adds it to s.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *state)</span></span> stmt(n ir.Node) &#123;<br>s.stmtList(n.Init())<br><span class="hljs-keyword">switch</span> n.Op() &#123;<br><span class="hljs-keyword">case</span> ir.ODEFER:<br>      n := n.(*ir.GoDeferStmt)<br>      <span class="hljs-keyword">if</span> base.Debug.Defer &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">var</span> defertype <span class="hljs-type">string</span><br>        <span class="hljs-keyword">if</span> s.hasOpenDefers &#123;<br>          defertype = <span class="hljs-string">&quot;open-coded&quot;</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n.Esc() == ir.EscNever &#123;<br>          defertype = <span class="hljs-string">&quot;stack-allocated&quot;</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          defertype = <span class="hljs-string">&quot;heap-allocated&quot;</span><br>        &#125;<br>        base.WarnfAt(n.Pos(), <span class="hljs-string">&quot;%s defer&quot;</span>, defertype)<br>      &#125;<br>...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，总共有 3 种分配策略：</p><ul><li><strong>open-coded</strong>: s.hasOpenDefers == true</li><li><strong>stack-allocated</strong>: n.Esc() == ir.EscNever</li><li><strong>heap-allocated</strong>: 默认</li></ul><p>默认是堆分配，在 Go1.13以前，也只有堆分配这一种策略，不过该实现的性能较差。Go 语言在 1.13中引入栈上分配的结构体，<ahref="https://go-review.googlesource.com/c/go/+/171758">减少了 30%的额外开销</a>，并在 1.14 中引入了基于开放编码的<code>defer</code>，使得该关键字的额外开销<ahref="https://go-review.googlesource.com/c/go/+/190098/6">几乎可以忽略不计</a>。</p><p>本文中不对具体的分配机制进行分析，这一块会比较复杂，笔者本身也不是很感兴趣，便决定对此不过分深究，感兴趣的读者推荐详细阅读《Go语言设计与实现》中关于 <code>defer</code>关键字的分析：https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/。</p><p>本文只讨论什么情况下会使用什么分配策略。由于堆分配是默认的，我们就不作分析了，具体来看看<code>s.hasOpenDefers == true</code> 和<code>n.Esc() == ir.EscNever</code> 什么时候会成立。</p><h2 id="栈上分配">栈上分配</h2><p>我们先来看栈上分配，要满足栈上分配，则需要满足<code>n.Esc() == ir.EscNever</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>EscUnknown = <span class="hljs-literal">iota</span><br>EscNone    <span class="hljs-comment">// Does not escape to heap, result, or parameters.</span><br>EscHeap    <span class="hljs-comment">// Reachable from the heap</span><br>EscNever   <span class="hljs-comment">// By construction will not escape.</span><br>)<br></code></pre></td></tr></table></figure><p>当 <code>n</code> 的逃逸分析结果是 <code>ir.EscNever</code>，则表明该<code>defer</code>语句从不逃逸（不会在函数调用结束后仍然被引用），这种情况下<code>defer</code> 将被分配到栈上（stack-allocated）。否则，如果<code>defer</code> 逃逸了，就会被分配到堆上（heap-allocated）。</p><p>那 <code>defer</code> 语句什么时候会逃逸呢？</p><blockquote><p>在 Go中，一个变量的逃逸意味着它的生命周期超出了当前函数的范围。在函数内定义的变量通常分配在栈上，而在堆上分配内存需要更复杂的管理。在一些情况下，编译器可能会选择将变量分配在堆上，这种情况下我们称之为逃逸。</p></blockquote><p>对于 <code>defer</code> 语句，如果它引用了函数外的变量，这个<code>defer</code> 就会逃逸。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(x) <span class="hljs-comment">// 这里引用了外部变量 x</span><br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>defer</code> 函数内部引用了 <code>x</code>这个外部变量，因此 <code>defer</code> 语句需要确保 <code>x</code> 在<code>defer</code> 函数执行时仍然有效。为了满足这个条件，编译器可能会将<code>x</code> 分配在堆上，而不是栈上。</p><h2 id="开放编码">开放编码</h2><p>先给结论，在开发过程中，要使用开放编码策略，你只需要关注以下 4点即可：</p><ol type="1"><li>函数的 <code>defer</code> 数量不能超过 8 个；</li><li>函数的 <code>defer</code> 关键字不能在循环中执行；</li><li>函数的 <code>defer</code> 中不能发生逃逸；</li><li>函数的 <code>return</code> 语句与 <code>defer</code>语句的乘积小于或者等于 15 个；</li></ol><hr /><p>Ok，下面是具体的分析过程。</p><p>借助 Goland 的能力，将鼠标光标放在 <code>s.hasOpenDefers</code>上，按住 <strong>Command</strong>加点击鼠标，可以看到该属性的使用情况：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328133312845-20240328202233278.png"alt="s.hasOpenDefers" /><figcaption aria-hidden="true">s.hasOpenDefers</figcaption></figure><p>可以看到该属性的判断逻辑都在 <ahref="https://github.com/golang/go/blob/release-branch.go1.22/src/cmd/compile/internal/ssagen/ssa.go">ssa.go</a>文件中的 <code>buildssa()</code>函数中。去掉一些无关的代码，核心逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// buildssa builds an SSA function for fn.</span><br><span class="hljs-comment">// worker indicates which of the backend workers is doing the processing.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildssa</span><span class="hljs-params">(fn *ir.Func, worker <span class="hljs-type">int</span>)</span></span> *ssa.Func &#123;<br>...<br>  <span class="hljs-comment">// ①</span><br>s.hasOpenDefers = base.Flag.N == <span class="hljs-number">0</span> &amp;&amp; s.hasdefer &amp;&amp; !s.curfn.OpenCodedDeferDisallowed()<br><span class="hljs-keyword">switch</span> &#123;<br>  <span class="hljs-comment">// ②</span><br><span class="hljs-keyword">case</span> base.Debug.NoOpenDefer != <span class="hljs-number">0</span>:<br>s.hasOpenDefers = <span class="hljs-literal">false</span><br><span class="hljs-keyword">case</span> s.hasOpenDefers &amp;&amp; (base.Ctxt.Flag_shared || base.Ctxt.Flag_dynlink) &amp;&amp; base.Ctxt.Arch.Name == <span class="hljs-string">&quot;386&quot;</span>:<br>    <span class="hljs-comment">// ③</span><br><span class="hljs-comment">// Don&#x27;t support open-coded defers for 386 ONLY when using shared</span><br><span class="hljs-comment">// libraries, because there is extra code (added by rewriteToUseGot())</span><br><span class="hljs-comment">// preceding the deferreturn/ret code that we don&#x27;t track correctly.</span><br>s.hasOpenDefers = <span class="hljs-literal">false</span><br>&#125;<br>  <span class="hljs-comment">// ④</span><br><span class="hljs-keyword">if</span> s.hasOpenDefers &amp;&amp; <span class="hljs-built_in">len</span>(s.curfn.Exit) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Skip doing open defers if there is any extra exit code (likely</span><br><span class="hljs-comment">// race detection), since we will not generate that code in the</span><br><span class="hljs-comment">// case of the extra deferreturn/ret segment.</span><br>s.hasOpenDefers = <span class="hljs-literal">false</span><br>&#125;<br>  <span class="hljs-comment">// ⑤</span><br><span class="hljs-keyword">if</span> s.hasOpenDefers &#123;<br><span class="hljs-comment">// Similarly, skip if there are any heap-allocated result</span><br><span class="hljs-comment">// parameters that need to be copied back to their stack slots.</span><br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> s.curfn.Type().Results().FieldSlice() &#123;<br><span class="hljs-keyword">if</span> !f.Nname.(*ir.Name).OnStack() &#123;<br>s.hasOpenDefers = <span class="hljs-literal">false</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br>  <span class="hljs-comment">// ⑥</span><br><span class="hljs-keyword">if</span> s.hasOpenDefers &amp;&amp;<br>s.curfn.NumReturns*s.curfn.NumDefers &gt; <span class="hljs-number">15</span> &#123;<br><span class="hljs-comment">// Since we are generating defer calls at every exit for</span><br><span class="hljs-comment">// open-coded defers, skip doing open-coded defers if there are</span><br><span class="hljs-comment">// too many returns (especially if there are multiple defers).</span><br><span class="hljs-comment">// Open-coded defers are most important for improving performance</span><br><span class="hljs-comment">// for smaller functions (which don&#x27;t have many returns).</span><br>s.hasOpenDefers = <span class="hljs-literal">false</span><br>&#125;<br>  ...<br><span class="hljs-keyword">return</span> s.f<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到总共有 6个条件，我已在注释中进行标注，我们来进行逐一分析：</p><h3 id="base.flag.n-0-s.hasdefer-s.curfn.opencodeddeferdisallowed">①base.Flag.N == 0 &amp;&amp; s.hasdefer &amp;&amp;!s.curfn.OpenCodedDeferDisallowed()</h3><blockquote><p>如果<code>base.Flag.N</code> 等于 0且当前函数有延迟调用且没有禁止开放式延迟，那么设置<code>s.hasOpenDefers</code>为<code>true</code>。</p></blockquote><p>在 Go编译器中，<code>-N</code>标志通常用于禁用优化。在这段代码中，如果<code>base.Flag.N</code>等于0，意味着没有禁用优化，因此编译器可能会尝试使用更高级的优化技术，比如开放式延迟（open-codeddefers）。</p><p><code>OpenCodedDeferDisallowed()</code>即禁用开放编码，它的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> funcOpenCodedDeferDisallowed <span class="hljs-comment">// can&#x27;t do open-coded defers</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Func)</span></span> OpenCodedDeferDisallowed() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> f.flags&amp;funcOpenCodedDeferDisallowed != <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p>按住 Command 后点击 <code>funcOpenCodedDeferDisallowed</code>可以看到只有 <code>funcOpenCodedDeferDisallowed(b)</code>可以修改它的值。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328140733594.png"alt="funcOpenCodedDeferDisallowed" /><figcaption aria-hidden="true">funcOpenCodedDeferDisallowed</figcaption></figure><p>我们来看看哪个地方会调用<code>funcOpenCodedDeferDisallowed()</code>，并将<code>funcOpenCodedDeferDisallowed</code> 设置为 <code>true</code>：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328140859879.png"alt="将 funcOpenCodedDeferDisallowed 设置为 true 的地方" /><figcaption aria-hidden="true">将 funcOpenCodedDeferDisallowed 设置为true 的地方</figcaption></figure><p>调用它的地方在 <ahref="https://github.com/golang/go/blob/release-branch.go1.22/src/cmd/compile/internal/walk/stmt.go">stmt.go</a>文件中的 <code>walkStmt()</code> 函数，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The max number of defers in a function using open-coded defers. We enforce this</span><br><span class="hljs-comment">// limit because the deferBits bitmask is currently a single byte (to minimize code size)</span><br><span class="hljs-keyword">const</span> maxOpenDefers = <span class="hljs-number">8</span><br><br><span class="hljs-comment">// The result of walkStmt MUST be assigned back to n, e.g.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//n.Left = walkStmt(n.Left)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkStmt</span><span class="hljs-params">(n ir.Node)</span></span> ir.Node &#123;<br>  ...<br><span class="hljs-keyword">switch</span> n.Op() &#123;<br>    ...<br>    <span class="hljs-keyword">case</span> ir.ODEFER:<br>      n := n.(*ir.GoDeferStmt)<br>      ir.CurFunc.SetHasDefer(<span class="hljs-literal">true</span>)<br>      ir.CurFunc.NumDefers++<br>      <span class="hljs-keyword">if</span> ir.CurFunc.NumDefers &gt; maxOpenDefers &#123;<br>        <span class="hljs-comment">// Don&#x27;t allow open-coded defers if there are more than</span><br>        <span class="hljs-comment">// 8 defers in the function, since we use a single</span><br>        <span class="hljs-comment">// byte to record active defers.</span><br>        ir.CurFunc.SetOpenCodedDeferDisallowed(<span class="hljs-literal">true</span>)<br>      &#125;<br>      <span class="hljs-keyword">if</span> n.Esc() != ir.EscNever &#123;<br>        <span class="hljs-comment">// If n.Esc is not EscNever, then this defer occurs in a loop,</span><br>        <span class="hljs-comment">// so open-coded defers cannot be used in this function.</span><br>        ir.CurFunc.SetOpenCodedDeferDisallowed(<span class="hljs-literal">true</span>)<br>      &#125;<br>      <span class="hljs-keyword">fallthrough</span><br>    ...<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>第一点是：当前函数中 <code>defer</code> 个数超过 8的话，则禁用开放编码。</p><p>第二点是当 <code>n.Esc() != ir.EscNever</code>使，就禁用开放编码。这个要求跟前面分析的“栈上分配”要求是一样的。</p><p>这里再补充一点：什么时候 <code>n.Esc()</code> 会被设置为<code>ir.EscNever</code> 呢？</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328192005520.png"alt="n.SetEsc(ir.EscNever)" /><figcaption aria-hidden="true">n.SetEsc(ir.EscNever)</figcaption></figure><p>这里面核心点是第一个，它对应的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *escape)</span></span> goDeferStmt(n *ir.GoDeferStmt) &#123;<br>k := e.heapHole()<br><span class="hljs-keyword">if</span> n.Op() == ir.ODEFER &amp;&amp; e.loopDepth == <span class="hljs-number">1</span> &#123;<br>...<br>n.SetEsc(ir.EscNever)<br>&#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>e.loopDepth == 1</code> 时就设置，换言之，<code>defer</code>不在循环中的时候，才允许开放编码。</p><p>总而言之，第 ① 个条件约束了要采用<code>open-coded 开放编码</code>策略的 3 个条件：</p><ol type="1"><li>函数中 <code>defer</code> 个数不能超过 <strong>8</strong>；</li><li><code>defer</code> 不能在循环中；</li><li><code>defer</code> 不能发生逃逸。</li></ol><h3 id="base.debug.noopendefer-0">② base.Debug.NoOpenDefer != 0</h3><blockquote><p>如果<code>base.Debug.NoOpenDefer</code>不为0，那么禁用开放式延迟。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">NoOpenDefer           <span class="hljs-type">int</span>    <span class="hljs-string">`help:&quot;disable open-coded defers&quot; concurrent:&quot;ok&quot;`</span><br></code></pre></td></tr></table></figure><h3id="base.ctxt.flag_shared-base.ctxt.flag_dynlink-base.ctxt.arch.name-386">③(base.Ctxt.Flag_shared || base.Ctxt.Flag_dynlink) &amp;&amp;base.Ctxt.Arch.Name == "386"</h3><blockquote><p>如果当前架构是<code>386</code>，并且使用共享库或动态链接，那么不支持开放式延迟，因为存在一些额外的代码（由<code>rewriteToUseGot()</code>添加）可能无法正确追踪。</p></blockquote><h3 id="lens.curfn.exit">④ len(s.curfn.Exit)</h3><blockquote><p>如果存在任何额外的退出代码（比如可能是竞态检测相关的代码），则跳过开放式延迟。</p></blockquote><h3 id="f.nname.ir.name.onstack">⑤ !f.Nname.(*ir.Name).OnStack()</h3><blockquote><p>如果有任何堆分配的结果参数需要复制回它们的栈槽，也跳过开放式延迟。</p></blockquote><h3 id="s.curfn.numreturnss.curfn.numdefers-15">⑥s.curfn.NumReturns*s.curfn.NumDefers &gt; 15</h3><blockquote><p>如果函数的返回数乘以延迟调用数大于<strong>15</strong>，考虑到每个退出点都要生成延迟调用，并且开放式延迟对于小函数（没有多个返回）的性能提升最为重要，所以在这种情况下也不使用开放式延迟。</p></blockquote><h2 id="堆上分配">堆上分配</h2><p>当不满足开放编码和栈上分配的时候，默认就是堆上分配（heap-allocated），性能最差，这里不做分析。</p><hr /><p>以上就是本文关于 Go 语言中 <code>defer</code> 关键字的具体分析，HappyCoding! Peace~</p><h1 id="参考">参考</h1><ul><li><a href="https://book.douban.com/subject/36403287/">深入理解 Go语言</a></li><li><a href="https://book.douban.com/subject/35556889/">Go语言底层原理剖析</a></li><li><ahref="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/">Go语言设计与实现</a></li><li>ChatGPT4</li></ul>]]></content>
    
    
    <summary type="html">本文将深入浅出地介绍 defer 的工作原理，探究其背后的机制，并通过丰富的案例来展示它的实际应用。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>深入 Go 语言核心：结构体的全方位解析</title>
    <link href="https://hedon.top/2024/03/09/go-struct/"/>
    <id>https://hedon.top/2024/03/09/go-struct/</id>
    <published>2024-03-09T08:59:34.000Z</published>
    <updated>2024-11-12T19:14:55.775Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言，作为一种高效、静态类型的编程语言，自其问世以来便以其并发处理能力和简洁的语法结构广受开发者欢迎。虽然Go不是传统意义上的面向对象语言，它却以独特的方式支持面向对象编程的核心概念，其中结构体扮演了非常关键的角色。</p><p>结构体在 Go语言中是一种复合数据类型，允许我们将不同类型的数据聚合到一起。它不仅提高了数据管理的效率和逻辑清晰度，还是Go语言中实现面向对象编程思想如封装、组合等概念的基石。了解和掌握结构体的使用，对于深入理解Go 语言的特性和编写高效、可维护的 Go 代码至关重要。</p><p>本文将带您全面深入地探索 Go语言中结构体的各个方面，从基本定义、初始化和使用，到高级特性如结构体的组合、方法定义、内存对齐等，每一个细节都将一一展开。无论您是Go语言的新手，还是有一定经验的开发者，相信本文都能为您提供有价值的见解和帮助。让我们一起探索Go结构体的奥秘，揭开其背后的原理，优化我们的代码结构，提升编程效率。</p><h1 id="版本声明">版本声明</h1><ul><li>Go 1.22.1</li><li>gopkg.in/yaml.v3 v3.0.1</li><li>os: m2max</li></ul><h1 id="全文概览">全文概览</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/go-struct.png"alt="Go 语言结构体" /><figcaption aria-hidden="true">Go 语言结构体</figcaption></figure><h1 id="结构体的基本使用">1. 结构体的基本使用</h1><h2 id="定义结构体">1.1 定义结构体</h2><p>结构体类型的定义形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>  Field T1,<br>  Field T2,<br>  ....<br>  FieldN Tn,<br>&#125;<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  Name <span class="hljs-type">string</span><br>  Age <span class="hljs-type">int</span><br>  ExtraInfo <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体内部，也可以内嵌<strong>匿名结构体</strong>，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>  Age <span class="hljs-type">int</span><br>  School <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Address <span class="hljs-type">string</span><br>    Phone <span class="hljs-type">string</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但是！注意，如果 Person 中包含了 Person 呢？</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>person  Person<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会报错：不允许引用自身。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./main.go:5:6: invalid recursive <span class="hljs-built_in">type</span>: Person refers to itself<br></code></pre></td></tr></table></figure><p>这是因为 Go语言在编译时需要知道每个类型的确切大小，以便正确地分配内存。但在这个定义中，因为<code>Person</code> 包含自身，编译器无法确定 <code>Person</code>的大小，因此会报错。</p><p>如果你需要在一个结构体中引用相同类型的数据，你应该使用指针。指针的大小是固定的，因此编译器可以确定结构体的大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  person *Person<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化结构体">1.2 初始化结构体</h2><p>假设我们有以下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name      <span class="hljs-type">string</span><br>Age       <span class="hljs-type">int</span><br>ExtraInfo <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以有以下几种初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 逐个字段赋值，顺序不重要，也可以只赋值部分字段</span><br>person1 := Person&#123;<br>  Age:       <span class="hljs-number">18</span>,<br>  Name:      <span class="hljs-string">&quot;hedon&quot;</span>,<br>  ExtraInfo: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;),<br>&#125;<br>fmt.Println(person1) <span class="hljs-comment">// &#123;hedon 18 map[]&#125;</span><br><br><span class="hljs-comment">// 可以不指定字段，严格按照顺序</span><br>person2 := Person&#123;<span class="hljs-string">&quot;hedon2&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)&#125;<br>fmt.Println(person2) <span class="hljs-comment">// &#123;hedon2 19 map[]&#125;</span><br><br><span class="hljs-comment">// 默认初始化，则结构体中的每个字段都会被默认赋予其对应类型的“零值”</span><br><span class="hljs-keyword">var</span> person3 Person<br>fmt.Println(person3)                  <span class="hljs-comment">// &#123; 0 map[]&#125;</span><br>fmt.Println(person3.ExtraInfo == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 也可以使用 new() 或 &amp; 来初始化并返回指针</span><br>person3 := <span class="hljs-built_in">new</span>(Person)<br>fmt.Println(person3)  <span class="hljs-comment">// &amp;&#123; 0 map[]&#125;</span><br></code></pre></td></tr></table></figure><h2 id="空结构体">1.3 空结构体</h2><p>有一种特殊的结构体，它一个字段都没有，我们称之为“空结构体”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>空结构体非常特殊，它不占据任何空间！你可以自己验证一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;the size of empty:&quot;</span>, unsafe.Sizeof(Empty&#123;&#125;)) <span class="hljs-comment">// the size of empty: 0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而且，所有空结构体的地址都一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">type</span> Empty1 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>e := Empty&#123;&#125;<br>e1 := Empty1&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;the address of empty: %p\n&quot;</span>, &amp;e) <span class="hljs-comment">// the address of empty: 0x10460f520</span><br>fmt.Printf(<span class="hljs-string">&quot;the address of empty1: %p\n&quot;</span>, &amp;e1)  <span class="hljs-comment">// the address of empty1: 0x10460f520</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为 Go 语言为所有大小为 0 的变量都指向了同一个值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// base address for all 0-byte allocations</span><br><span class="hljs-keyword">var</span> zerobase <span class="hljs-type">uintptr</span><br></code></pre></td></tr></table></figure><p>好处就是减少了内存的浪费。典型的用法就是我们可以使用 map 来实现Set，这样就只花费了存储键的空间，而值不占用任何空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="访问和修改结构体">1.4 访问和修改结构体</h2><ul><li>结构体属性的可见性跟 Go包的可见性规则一样：大写对包外可见，小写仅包内可见。</li><li>使用 <code>.</code> 访问和修改结构体中的属性。</li><li>Go语言中只有“<strong>值传递</strong>”，所以如果你要将结构体示例传入一个func 进行修改，则需要传入其引用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>UpdatePersonName(p)<br>fmt.Println(<span class="hljs-string">&quot;1:&quot;</span>, p)<br>UpdatePersonNameWithRef(&amp;p)<br>fmt.Println(<span class="hljs-string">&quot;2:&quot;</span>, p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdatePersonName</span><span class="hljs-params">(p Person)</span></span> &#123;<br>p.Name = <span class="hljs-string">&quot;hedon-1&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdatePersonNameWithRef</span><span class="hljs-params">(p *Person)</span></span> &#123;<br>p.Name = <span class="hljs-string">&quot;hedon-2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">1: &#123;hedon 18&#125;<br>2: &#123;hedon-2 18&#125;<br></code></pre></td></tr></table></figure><h1 id="结构体的高级特性">2. 结构体的高级特性</h1><h2 id="结构体组合">2.1 结构体组合</h2><p>在 Go语言中，倡导的是“组合优于继承”的哲学，即倡导使用组合而不是继承来实现代码的复用。该理念鼓励开发者通过组合和接口来构建灵活、可维护的代码，而不是依赖于更严格、更易出错的继承关系。这种方式促进了代码的解耦，增强了代码的灵活性和可重用性，同时也使得代码更加清晰和易于理解。</p><p>在 Go中，组合是通过将一个或多个类型（通常是结构体）嵌入到另一个结构体中来实现的。这使得嵌入的类型的方法被“提升”到包含它的结构体中，允许你调用这些方法就像它们是外部结构体的一部分一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    Power <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Engine)</span></span> Start() &#123;<br>    <span class="hljs-comment">// 启动引擎的逻辑</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Car <span class="hljs-keyword">struct</span> &#123;<br>    Engine <span class="hljs-comment">// 通过组合的方式嵌入 Engine</span><br>&#125;<br><br><span class="hljs-comment">// 现在 Car 可以直接调用 Start 方法</span><br>car := Car&#123;Engine&#123;Power: <span class="hljs-number">100</span>&#125;&#125;<br>car.Start() <span class="hljs-comment">// 调用的是 Engine 的 Start 方法</span><br></code></pre></td></tr></table></figure><h2 id="结构体的方法">2.2 结构体的方法</h2><p>假设我们定义了一个结构体 Person：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Go 中，你可以为结构体的值或指针实现特定的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>  p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *Person)</span></span> SetName(name <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>  p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>这两者最核心的区别是：<strong>当你为结构体的指针类型定义方法时，该方法会在原始结构体实例上操作。这意味着方法内部对结构体的任何修改都会影响到原始结构体。</strong></p><p>所以这两段代码的输出是不一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(p.Name)   <span class="hljs-comment">// name_name</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(p.Name)  <span class="hljs-comment">// hedon</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这里我想再补充两个小点。请先思考一下下面这两段代码是否可以编译通过？如果可以输出是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;person name after set:&quot;</span>, p.Name)<br><br>pt := reflect.TypeOf(p)<br>fmt.Println(<span class="hljs-string">&quot;the number of person&#x27;s method: &quot;</span>, pt.NumMethod())<br><br>p2 := &amp;Person&#123;&#125;<br>pt = reflect.TypeOf(p2)<br>fmt.Println(<span class="hljs-string">&quot;the number of &amp;person&#x27;s method: &quot;</span>, pt.NumMethod())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;person name after set:&quot;</span>, p.Name)<br><br>pt := reflect.TypeOf(p)<br>fmt.Println(<span class="hljs-string">&quot;the number of person&#x27;s method: &quot;</span>, pt.NumMethod())<br><br>p2 := &amp;Person&#123;&#125;<br>pt = reflect.TypeOf(p2)<br>fmt.Println(<span class="hljs-string">&quot;the number of &amp;person&#x27;s method: &quot;</span>, pt.NumMethod())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显这两段代码的唯一区别就是，第一段代码我们是为<code>*Person</code> 实现了 <code>SetName</code>方法，而第二段代码我们是为 <code>Person</code> 实现了<code>SetName</code> 方法。两段代码我们都打印了调用 <code>SetName</code>后 <code>p.name</code> 的值，以及利用方式分别获取 <code>Person</code> 和<code>*Person</code> 实现的方法个数。</p><p>第一段代码的输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">person name after set: new<span class="hljs-built_in">_</span>name<br>the number of person&#x27;s method:  0<br>the number of <span class="hljs-built_in">&amp;</span>person&#x27;s method:  1<br></code></pre></td></tr></table></figure><p>第二段代码的输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">person name after set: hedon<br>the number of person&#x27;s method:  1<br>the number of <span class="hljs-built_in">&amp;</span>person&#x27;s method:  1<br></code></pre></td></tr></table></figure><p>这里我们可以得出 2 个结论：</p><p><strong>① 结构体的修改依赖于方法接收器的类型</strong>：</p><ul><li>当方法的接收器为值类型（<code>Person</code>）时，对结构体的修改不会影响原始结构体实例，因为方法作用于结构体的副本上。</li><li>当方法的接收器为指针类型（<code>*Person</code>）时，对结构体的修改会影响原始结构体实例，因为方法作用于结构体的引用上。</li></ul><p><strong>② 方法集依赖于接收器的类型</strong>：</p><ul><li>为值类型（<code>Person</code>）实现的方法，既属于值类型也属于指针类型（<code>*Person</code>）的方法集。</li><li>为指针类型（<code>*Person</code>）实现的方法，只属于指针类型的方法集。</li></ul><p>对于 ②，我们可以通过 Plan9 汇编代码一探究竟。</p><p>我们为第一段代码执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -gcflags -S main.go<br></code></pre></td></tr></table></figure><p>在输出的最上面，可以看到只有<code>main.(*Person).GetName</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"># command-line-arguments<br>main.main STEXT size=<span class="hljs-number">128</span> args=<span class="hljs-number">0x0</span> locals=<span class="hljs-number">0x48</span> funcid=<span class="hljs-number">0x0</span> align=<span class="hljs-number">0x0</span><br>        ...<br>main.(*Person).GetName STEXT size=<span class="hljs-number">16</span> args=<span class="hljs-number">0x8</span> locals=<span class="hljs-number">0x0</span> funcid=<span class="hljs-number">0x0</span> align=<span class="hljs-number">0x0</span> leaf<br>       ...<br></code></pre></td></tr></table></figure><p>我们再来为第二段代码执行相同的命令。可以在输出的最上面，看到不仅有<code>main.Person.GetName</code>，还可以发现编译器自动帮我们生成了<code>main.(*Person).GetName</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># command-line-arguments</span><br>main.main STEXT size=480 args=0x0 locals=0xe8 funcid=0x0 align=0x0<br>...<br>main.Person.SetName STEXT size=16 args=0x28 locals=0x0 funcid=0x0 align=0x0 leaf<br>   ...<br>main.(*Person).SetName STEXT dupok size=128 args=0x18 locals=0x8 funcid=0x16 align=0x0<br>...<br></code></pre></td></tr></table></figure><p>对于 ②，笔者其实有一个不太理解的地方，比如下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := &amp;Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;person name after set:&quot;</span>, p.Name) <span class="hljs-comment">// hedon</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>p</code> 是引用类型，下面实现的是<code>Person.SetName</code>，按照我们上面的结论，编译器会自动帮我们实现<code>(*Person).SetName</code>。按照这种思路，输出 <code>new_name</code>也是解释得通的。因为既然我们声明的是一个引用类型，那么 <code>p</code>完全可以去调用自动生成的<code>(*Person).SetName</code>。但是最终的结果还是输出<code>hedon</code>，所以这里编译器自动帮我们将 <code>p</code>进行解引用，然后调用了 <code>Person.SetName</code>。</p><p>这是比较困扰笔者的一个地方，欢迎评论区讨论~</p><p>可能编译器还是更希望对于开发者来说“所见即所得”，既然开发者实现的是<code>Person.SetName</code>，那么对于开发者来说，应该就是希望不影响原始结构体的值，所以编译器还是选择遵循这种“意愿”，不乱操作。</p><h2 id="结构体比较">2.3 结构体比较</h2><p>Go 允许直接比较两个结构体实例，但有一定的限制：</p><ol type="1"><li><strong>可比较性</strong>：只有当结构体中的所有字段都是可比较的时，结构体才是可比较的。基本数据类型（如int、string 等）是可比较的，但切片、映射、函数等类型不可比较。</li><li><strong>相等性检测</strong>：当两个结构体的对应字段都相等时，这两个结构体被认为是相等的。可以使用<code>==</code> 和 <code>!=</code> 操作符来进行比较。</li></ol><p>下面这段示例，<code>p3==p4</code> 返回了<code>true</code>，这符合我们上面总结的结论。<code>p1==p2</code> 返回了<code>false</code>，因为这其实不是结构体之间的比较了，这是指针的比较了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">p1 := &amp;Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>p2 := &amp;Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>fmt.Println(p1 == p2) <span class="hljs-comment">// false</span><br>p3 := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>p4 := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>fmt.Println(p3 == p4) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>结构体的比较只支持 <code>==</code> 和 <code>!=</code>，不支持<code>&lt;</code> 和 <code>&gt;</code> 等其他运算符的比较。而 Go语言又不支持比较符重载。所以如果你要比较两个结构体的大小，那么只能自行封装类型<code>compare</code>的函数。在这我们排序结构体数组或切片的时候，经常使用到，比如我们希望按<code>Age</code> 字段从小到大排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Slice(persons, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">return</span> persons[i].Age &lt; persons[j].Age<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="结构体复制">2.4 结构体复制</h2><p>在 Go中，结构体也是值类型，这意味着当它们被赋值给新的变量或作为函数参数传递时，实际上是进行了一次深拷贝：</p><ol type="1"><li><strong>值复制</strong>：当将一个结构体赋值给一个新变量时，新变量会获得原始结构体的一个副本，它们在内存中占有不同的位置。</li><li><strong>独立性</strong>：因为是深拷贝，所以原始结构体和副本结构体是完全独立的；修改其中一个不会影响另一个。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">int</span><br>&#125;<br><br>original := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><span class="hljs-built_in">copy</span> := original<br><span class="hljs-built_in">copy</span>.X = <span class="hljs-number">3</span><br><br>fmt.Println(original) <span class="hljs-comment">// &#123;1, 2&#125;</span><br>fmt.Println(<span class="hljs-built_in">copy</span>)     <span class="hljs-comment">// &#123;3, 2&#125;</span><br></code></pre></td></tr></table></figure><h1 id="结构体与接口">3. 结构体与接口</h1><p>在 Go语言中，如果一个类型实现了接口中所有的方法，则这个类型就实现了该接口。关于接口部分的知识点，比如接口定义、多态和断言等，本文就不赘述了。</p><p>在这里我主要想从另外一个角度继续来验证前面我们总结的：<strong>为值类型（<code>Person</code>）实现的方法，既属于值类型也属于指针类型（<code>*Person</code>）的方法集</strong>。</p><p>请看这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">interface</span> &#123;<br>GetName() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Man <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m Man)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> m.Name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintPersonName</span><span class="hljs-params">(p Person)</span></span> &#123;<br>fmt.Println(p.GetName())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m1 := Man&#123;Name: <span class="hljs-string">&quot;hedon1&quot;</span>&#125;<br>PrintPersonName(m1)<br>m2 := &amp;Man&#123;Name: <span class="hljs-string">&quot;hedon2&quot;</span>&#125;<br>PrintPersonName(m2)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码我们定义了 <code>Person</code> 接口，它只有一个方法<code>GetName</code>。然后我们定义了一个结构体<code>Man</code>，并为它的值类型实现了 <code>Person</code>接口。通过我们上面的结论，这里 <code>Man</code> 和 <code>*Man</code>其实都实现了 <code>Person</code>接口，所以上面的代码是可以编译通过的。</p><p>如果改成为指针类型实现接口呢？你可以试一下~</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Man)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> m.Name<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="泛型结构体">4. 泛型结构体</h1><p>Go 语言在其 1.18版本中引入了泛型支持，这包括了对泛型结构体的支持。通过使用泛型，你可以创建更灵活和可重用的数据结构和函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Container[T any] <span class="hljs-keyword">struct</span> &#123;<br>items []T<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 Go 语言用 <code>[]</code> 来实现泛型，而不像其他语言一样用<code>&lt;&gt;</code>，真是喜欢搞特殊啊 🤡，又丑又容易跟 map 和 slice混淆。</p><h1 id="结构体的标签tag">5. 结构体的标签（Tag）</h1><p>在结构体字段后面，我们可以用 <strong>``</strong>来指定标签，这允许我们对结构体定制化一些常用操作，最经典的就是序列化与反序列化。</p><h2 id="序列化与反序列化">5.1 序列化与反序列化</h2><p>对于常见的数据结构，如<code>json</code>、<code>yaml</code>、<code>xml</code> 或<code>toml</code>，我们都可以通过在结构体中指定标签，然后使用对应解析库进行序列化和反序列化。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>bs, _ := json.Marshal(p) <span class="hljs-comment">// 序列化</span><br>fmt.Println(<span class="hljs-type">string</span>(bs))  <span class="hljs-comment">// &#123;&quot;name&quot;:&quot;hedon&quot;,&quot;age&quot;:18&#125;</span><br>newP := Person&#123;&#125;<br>_ = json.Unmarshal(bs, &amp;newP) <span class="hljs-comment">// 反序列化</span><br>fmt.Println(newP)             <span class="hljs-comment">// &#123;hedon 18&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在笔者的实践过程中，在结构体组合的场景下，不同数据格式的解析会有一些小差别，这在实战过程中你需要重点关注和验证。比如<code>json</code> 和 <code>yaml</code> 就会有一些不同。</p><p>比如说我这里定义了下面 2 个结构体，其中 <code>Person</code> 组合了<code>School</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot; yaml:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot; yaml:&quot;age&quot;`</span><br>School<br>&#125;<br><br><span class="hljs-keyword">type</span> School <span class="hljs-keyword">struct</span> &#123;<br>SchoolName    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;school_name&quot; yaml:&quot;school_name&quot;`</span><br>SchoolAddress <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;school_address&quot; json:&quot;school_address&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它们都加上了 <code>json</code> 和 <code>yaml</code> 标签，对于<code>json</code> 类型，你可以用标准库的 <code>encoding/json</code>来进行序列化和反序列化，而 <code>yaml</code> 你可以使用第三方库：<ahref="https://github.com/go-yaml/yaml">go-yaml</a>。</p><p>先来看系列化结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>, School: School&#123;SchoolName: <span class="hljs-string">&quot;nb_school&quot;</span>, SchoolAddress: <span class="hljs-string">&quot;a_good_school_place&quot;</span>&#125;&#125;<br>bs, _ := json.Marshal(p)<br>fmt.Println(<span class="hljs-string">&quot;json:\n&quot;</span>, <span class="hljs-type">string</span>(bs))<br>bs, _ = yaml.Marshal(p)<br>fmt.Println(<span class="hljs-string">&quot;yaml:\n&quot;</span>, <span class="hljs-type">string</span>(bs))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">json:<br> &#123;&quot;name&quot;:&quot;hedon&quot;,&quot;age&quot;:18,&quot;school<span class="hljs-built_in">_</span>name&quot;:&quot;nb<span class="hljs-built_in">_</span>school&quot;,&quot;school<span class="hljs-built_in">_</span>address&quot;:&quot;a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>school<span class="hljs-built_in">_</span>place&quot;&#125;<br>yaml:<br> name: hedon<br> age: 18<br> school:<br>    school<span class="hljs-built_in">_</span>name: nb<span class="hljs-built_in">_</span>school<br>    school<span class="hljs-built_in">_</span>address: a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>school<span class="hljs-built_in">_</span>place<br></code></pre></td></tr></table></figure><p>通过观察你可以发现哈，在 <code>json</code> 中，组合的时候（没有给School 加标签）直接将 <code>School</code> 平铺在 <code>Person</code>中，所以在序列化的结果中，找不到 <code>"school": &#123;&#125;</code>。而在<code>yaml</code> 中，并不是直接平铺的。</p><p>这个区别在你解析配置文件的时候尤其重要，如果不注意，那么可能会导致配置解析失败。</p><p>我准备了 4 个配置文件，分别是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// person1.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon_json&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;school_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nb_json_school&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;school_address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_good_place_in_json&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># person1.yaml</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;hedon_yaml&quot;</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">school:</span><br>  <span class="hljs-attr">school_name:</span> <span class="hljs-string">&quot;nb_yaml_school&quot;</span><br>  <span class="hljs-attr">school_address:</span> <span class="hljs-string">&quot;a_good_price_in_yaml&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// person2.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon_json&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nb_json_school&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school_address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_good_place_in_json&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># person2.yaml</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;hedon_yaml&quot;</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">school_name:</span> <span class="hljs-string">&quot;nb_yaml_school&quot;</span><br><span class="hljs-attr">school_address:</span> <span class="hljs-string">&quot;a_good_price_in_yaml&quot;</span><br></code></pre></td></tr></table></figure><p>解析代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filenames := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;person1.json&quot;</span>, <span class="hljs-string">&quot;person1.yaml&quot;</span>, <span class="hljs-string">&quot;person2.json&quot;</span>, <span class="hljs-string">&quot;person2.yaml&quot;</span>&#125;<br><span class="hljs-keyword">for</span> i, fn := <span class="hljs-keyword">range</span> filenames &#123;<br>bs := readFileIntoBytes(fn)<br>p := Person&#123;&#125;<br><span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>_ = json.Unmarshal(bs, &amp;p)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>_ = yaml.Unmarshal(bs, &amp;p)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s -&gt; %v\n&quot;</span>, fn, p)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFileIntoBytes</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>f, err := os.Open(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>bs, _ := io.ReadAll(f)<br><span class="hljs-keyword">return</span> bs<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">person1.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123; &#125;&#125;<br>person1.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123;nb<span class="hljs-built_in">_</span>yaml<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>price<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>yaml&#125;&#125;<br>person2.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123;nb<span class="hljs-built_in">_</span>json<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>place<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>json&#125;&#125;<br>person2.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123; &#125;&#125;<br></code></pre></td></tr></table></figure><p>如果给 <code>School</code> 字段加上 <code>json tag</code>的话，结果又是不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot; yaml:&quot;name&quot;`</span><br>Age    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot; yaml:&quot;age&quot;`</span><br>School <span class="hljs-string">`json:&quot;school&quot; yaml:&quot;school&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">person1.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123;nb<span class="hljs-built_in">_</span>json<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>place<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>json&#125;&#125;<br>person1.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123;nb<span class="hljs-built_in">_</span>yaml<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>price<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>yaml&#125;&#125;<br>person2.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123; &#125;&#125;<br>person2.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123; &#125;&#125;<br></code></pre></td></tr></table></figure><p>可以看到受影响的只有 <code>json</code>。</p><p>到这里我们可以总结：<strong>在组合场景下，如果不明确指定<code>tag</code>，<code>yaml</code> 解析期望字段是嵌套的，而<code>json</code> 解析期望字段是平铺的</strong>。</p><h2 id="自定义-tag">5.2 自定义 Tag</h2><p>在 Go中，你可以为结构体字段定义任意的标签。这些标签在编译时会被存储，并且可以在运行时通过反射（reflection）来访问。</p><p>假设我们定义一个名为 <code>check</code>的标签，它用于我们对结构体字段的检查，假设我们这个标签支持以下功能：</p><ul><li><code>check:"strnoempty"</code>: 字符串不可以为空。</li></ul><p>假如加入 <code>check</code> 标签的 <code>Person</code>结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`check:&quot;strnoempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来为 <code>check</code> 实现解析函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckPerson</span><span class="hljs-params">(p Person)</span></span> <span class="hljs-type">error</span> &#123;<br>pt := reflect.TypeOf(p)<br>pv := reflect.ValueOf(p)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; pt.NumField(); i++ &#123;<br>field := pt.Field(i)<br>tagValue := field.Tag.Get(<span class="hljs-string">&quot;check&quot;</span>)<br><span class="hljs-keyword">if</span> tagValue == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> field.Type.Kind() == reflect.String &amp;&amp; tagValue == <span class="hljs-string">&quot;strnoempty&quot;</span> &#123;<br><span class="hljs-keyword">if</span> err := checkStrNoEmpty(field.Name, pv.Field(i).Interface()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkStrNoEmpty</span><span class="hljs-params">(fieldName <span class="hljs-type">string</span>, v any)</span></span> <span class="hljs-type">error</span> &#123;<br>s, ok := v.(<span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%v is not string&quot;</span>, v)<br>&#125;<br><span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;[check] %s should not be empty&quot;</span>, fieldName)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p1 := Person&#123;&#125;<br>p2 := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>fmt.Println(CheckPerson(p1)) <span class="hljs-comment">// [check] Name should not be empty</span><br>fmt.Println(CheckPerson(p2)) <span class="hljs-comment">// &lt;nil&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结构体内存对齐">6. 结构体内存对齐</h1><p>在本小节中，我们将探讨 Go 语言结构体的内存结构和对齐策略。</p><h2 id="问题引出">6.1 问题引出</h2><p>思考下面这段代码的输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num2 <span class="hljs-type">int8</span><br>num1 <span class="hljs-type">int16</span><br>flag <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S2 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int8</span><br>flag <span class="hljs-type">bool</span><br>num2 <span class="hljs-type">int16</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(unsafe.Sizeof(S1&#123;&#125;))<br>fmt.Println(unsafe.Sizeof(S2&#123;&#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么仅是字段顺序不同，<code>S1&#123;&#125;</code> 和 <code>S2&#123;&#125;</code>的大小就不一样了？</p><p>我们可以写个简单的程序来输出 <code>S1</code> 和 <code>S2</code>的内存结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := S1&#123;&#125;<br>s2 := S2&#123;&#125;<br>fmt.Print(<span class="hljs-string">&quot;s1: &quot;</span>)<br>printMemory(s1)<br>fmt.Print(<span class="hljs-string">&quot;s2: &quot;</span>)<br>printMemory(s2)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMemory</span><span class="hljs-params">(a any)</span></span> &#123;<br>t := reflect.TypeOf(a)<br>mem := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>(t.Size()))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>field := t.Field(i)<br>offset := <span class="hljs-type">int</span>(field.Offset)<br>size := <span class="hljs-type">int</span>(field.Type.Size())<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; size; j++ &#123;<br>mem[j+offset] = i + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>fmt.Println(mem)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s1: [<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span>]<br>s2: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>其中 <code>1</code>、<code>2</code>、<code>3</code>分别替代结构体中的第 1/2/3 个字段所占用的内存。这里可以看到<code>s1</code> 的长度是 6 字节，而 <code>s2</code> 是 4 字节。这里<code>s1</code> 比 <code>s2</code> 多出的 2 个字节就是这两个填充的<code>0</code>。这而 2个字节的填充，就是为了<strong>内存对齐</strong>。</p><h2 id="内存对齐">6.2 内存对齐</h2><p>如上分析，<code>s1</code> 的内存结构如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310154903219.png"alt="s1 内存结构" /><figcaption aria-hidden="true">s1 内存结构</figcaption></figure><p>如果没有内存对齐呢？<code>s1</code> 的结构可能如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310155353882.png"alt="没有内存对齐的 s1 内存结构" /><figcaption aria-hidden="true">没有内存对齐的 s1 内存结构</figcaption></figure><p>如果是 16 位系统的话，那么没有内存对齐的情况下，要访问<code>s1.num2</code> 字段，就需要跨过 2个系统字长的内存，效率就低了。具体来说，内存对齐是计算机内存分配的一种优化方式，用于确保数据结构的存储按照特定的字节边界对齐。这种对齐是为了提高计算机处理数据的效率。</p><h2 id="对齐系数">6.3 对齐系数</h2><ul><li>对齐系数：变量的内存地址必须被对齐系数整除。</li><li><code>unsafe.Alignof()</code>: 可以查看值在内存中的对齐系数。</li></ul><h2 id="基本类型对齐">6.4 基本类型对齐</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;bool size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">bool</span>(<span class="hljs-literal">true</span>)), unsafe.Alignof(<span class="hljs-type">bool</span>(<span class="hljs-literal">true</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;byte size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">byte</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">byte</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int8 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int8</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int8</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int16 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int16</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int16</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int32 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int64 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int64</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int64</span>(<span class="hljs-number">0</span>)))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">bool</span> size: <span class="hljs-number">1</span>, align: <span class="hljs-number">1</span><br><span class="hljs-type">byte</span> size: <span class="hljs-number">1</span>, align: <span class="hljs-number">1</span><br><span class="hljs-type">int8</span> size: <span class="hljs-number">1</span>, align: <span class="hljs-number">1</span><br><span class="hljs-type">int16</span> size: <span class="hljs-number">2</span>, align: <span class="hljs-number">2</span><br><span class="hljs-type">int32</span> size: <span class="hljs-number">4</span>, align: <span class="hljs-number">4</span><br><span class="hljs-type">int64</span> size: <span class="hljs-number">8</span>, align: <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>结论：基本类型的对齐系数跟它的长度一致。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310160412598.png"alt="基本类型内存对齐" /><figcaption aria-hidden="true">基本类型内存对齐</figcaption></figure><h2 id="结构体内部对齐">6.5 结构体内部对齐</h2><p>结构体内存对齐分为内部对齐和结构体之间对齐。</p><p>我们先来看结构体内部对齐：</p><ul><li>指的是结构体内部成员的相对位置（偏移量）；</li><li>每个成员的偏移量是 <strong>自身大小</strong> 和<strong>对齐系数</strong> 的较小值的倍数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br>  a <span class="hljs-type">bool</span><br>  b <span class="hljs-type">string</span><br>  c <span class="hljs-type">int16</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假如我们定义了上面的结构体 <code>Demo</code>，如果在 64位系统上（字长为 8 字节）通过上面的规则，可以判断出：（单位为字节）</p><ul><li>a: size=1, align=1</li><li>b: size=16, align=8</li><li>c: size=2, align=2</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310163126556.png"alt="Demo 内存结构" /><figcaption aria-hidden="true">Demo 内存结构</figcaption></figure><p>当然我们也可以通过程序输出来验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">bool</span>   <span class="hljs-comment">// size=1, align=1</span><br>b <span class="hljs-type">string</span> <span class="hljs-comment">// size=16, align=8</span><br>c <span class="hljs-type">int16</span>  <span class="hljs-comment">// size=2, align=2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>d := Demo&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(d.a), unsafe.Alignof(d.a))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(d.b), unsafe.Alignof(d.b))<br>fmt.Printf(<span class="hljs-string">&quot;c: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(d.c), unsafe.Alignof(d.c))<br>printMemory(d)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMemory</span><span class="hljs-params">(a any)</span></span> &#123;<br>t := reflect.TypeOf(a)<br>mem := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>(t.Size()))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>field := t.Field(i)<br>offset := <span class="hljs-type">int</span>(field.Offset)<br>size := <span class="hljs-type">int</span>(field.Type.Size())<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; size; j++ &#123;<br>mem[j+offset] = i + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>fmt.Println(mem)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>c: size=<span class="hljs-number">2</span>, align=<span class="hljs-number">2</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="结构体长度填充">6.6 结构体长度填充</h2><p>上面 Demo 结构体最后还填了 6 个字节的 0，这就是结构体长度填充：</p><ul><li>结构体通过填充长度，来对齐系统字长。</li><li>结构体长度是 <strong>最大成员长度</strong> 和<strong>系统字长</strong> 较小值的整数倍。</li></ul><p>我的系统环境是 m2max，系统字长是 8 字节，Demo 最大成员长度是<code>b string</code>，即 16 个字节，所以 <code>Demo</code> 的长度应该是<code>8</code> 的倍数，所以最后填充了 6 个字节的 0。</p><h2 id="结构体之间对齐">6.7 结构体之间对齐</h2><ul><li>结构体之间对齐，是为了确定结构体的第一个成员变量的内存地址，以让后面的成员地址都合法。</li><li>结构体的对齐系数是 <strong>其成员的最大对齐系数</strong>；</li></ul><h2 id="空结构体对齐">6.8 空结构体对齐</h2><p>前面我们专门讨论了空结构体<code>struct&#123;&#125;</code>，它们的内存地址统一指向<code>zerobase</code>，而且内存长度为0。这也导致了它的内存对齐规则，有一些不同。具体可以分为以下 4个情况。</p><h3 id="空结构体单独存在">6.8.1 空结构体单独存在</h3><p>空结构体单独存在时，其内存地址为<code>zerobase</code>，不额外分配内存。</p><h3 id="空结构体在结构体最前">6.8.2 空结构体在结构体最前</h3><p>空结构体是结构体第一个字段时，它的地址跟结构体本身及结构体第 2个字段一样，不占据内存空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestEmpty <span class="hljs-keyword">struct</span> &#123;<br>empty <span class="hljs-keyword">struct</span>&#123;&#125;<br>a     <span class="hljs-type">bool</span><br>b     <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>te := TestEmpty&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;address of te: %p\n&quot;</span>, &amp;te)<br>fmt.Printf(<span class="hljs-string">&quot;address of te.empty: %p\n&quot;</span>, &amp;(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;address of te.a: %p\n&quot;</span>, &amp;(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;empty: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.empty), unsafe.Alignof(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.a), unsafe.Alignof(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.b), unsafe.Alignof(te.b))<br>printMemory(te)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">address of te: <span class="hljs-number">0x140000ba000</span><br>address of te.empty: <span class="hljs-number">0x140000ba000</span><br>address of te.a: <span class="hljs-number">0x140000ba000</span><br>empty: size=<span class="hljs-number">0</span>, align=<span class="hljs-number">1</span><br>a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>[<span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="空结构体在结构体中间">6.8.3 空结构体在结构体中间</h3><p>空结构体出现在结构体中时，地址跟随前一个变量。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310165025700.png"alt="空结构体在结构体中间内存对齐" /><figcaption aria-hidden="true">空结构体在结构体中间内存对齐</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestEmpty <span class="hljs-keyword">struct</span> &#123;<br>a     <span class="hljs-type">bool</span><br>empty <span class="hljs-keyword">struct</span>&#123;&#125;<br>b     <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>te := TestEmpty&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;address of te: %p\n&quot;</span>, &amp;te)<br>fmt.Printf(<span class="hljs-string">&quot;address of te.a: %p\n&quot;</span>, &amp;(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;address of te.empty: %p\n&quot;</span>, &amp;(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.a), unsafe.Alignof(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;empty: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.empty), unsafe.Alignof(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.b), unsafe.Alignof(te.b))<br>printMemory(te)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">address of te: <span class="hljs-number">0x14000128000</span><br>address of te.a: <span class="hljs-number">0x14000128000</span><br>address of te.empty: <span class="hljs-number">0x14000128001</span><br>a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>empty: size=<span class="hljs-number">0</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="空结构体在结构体最后">6.8.4 空结构体在结构体最后</h3><p>空结构体出现在结构体最后，如果开启了一个新的系统字长，则需要补零，防止与其他结构体混用地址。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310164933867.png"alt="空结构体在结构体最后内存对齐" /><figcaption aria-hidden="true">空结构体在结构体最后内存对齐</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestEmpty <span class="hljs-keyword">struct</span> &#123;<br>a     <span class="hljs-type">bool</span><br>b     <span class="hljs-type">string</span><br>empty <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>te := TestEmpty&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;address of te: %p\n&quot;</span>, &amp;te)<br>fmt.Printf(<span class="hljs-string">&quot;address of te.a: %p\n&quot;</span>, &amp;(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;address of te.empty: %p\n&quot;</span>, &amp;(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.a), unsafe.Alignof(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.b), unsafe.Alignof(te.b))<br>fmt.Printf(<span class="hljs-string">&quot;empty: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.empty), unsafe.Alignof(te.empty))<br>printMemory(te)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">address of te: <span class="hljs-number">0x1400006a020</span><br>address of te.a: <span class="hljs-number">0x1400006a020</span><br>address of te.empty: <span class="hljs-number">0x1400006a038</span><br>a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>empty: size=<span class="hljs-number">0</span>, align=<span class="hljs-number">1</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="使用-fieldalignment--fix-工具优化结构体内存对齐">6.9 使用fieldalignment -fix 工具优化结构体内存对齐</h2><p>还记得我们最开始提出的问题吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num2 <span class="hljs-type">int8</span><br>num1 <span class="hljs-type">int16</span><br>flag <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S2 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int8</span><br>flag <span class="hljs-type">bool</span><br>num2 <span class="hljs-type">int16</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(unsafe.Sizeof(S1&#123;&#125;))<br>fmt.Println(unsafe.Sizeof(S2&#123;&#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p><code>S1</code> 和 <code>S2</code> 提供的程序功能是一样的，但是<code>S1</code> 却比 <code>S2</code>花费了更多的内存空间。所以有时候我们可以通过仅仅调整结构体内部字段的顺序就减少不少的内存空间消耗。在这个时候<code>fieldalignment</code> 可以帮助我们自动检测并优化。</p><p>你可以运行下面命令安装 <code>fieldalignment</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest<br></code></pre></td></tr></table></figure><p>然后在项目根目录下运行下面命令，对我们的代码进行检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go vet -vettool=$(<span class="hljs-built_in">which</span> fieldalignment) ./...<br></code></pre></td></tr></table></figure><p>这里会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./main.go:9:9: struct of size 6 could be 4<br></code></pre></td></tr></table></figure><p>这个时候可以执行 <code>fieldalignment -fix 目录|文件</code>，它会自动帮我们的代码进行修复，但是<strong>强烈建议你在运行之前，备份你的代码，因为注释会被删除！</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fieldalignment -fix ./...<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">/Users/hedon/GolandProjects/learn-<span class="hljs-keyword">go</span>-<span class="hljs-keyword">struct</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>:<span class="hljs-number">9</span>: <span class="hljs-keyword">struct</span> of size <span class="hljs-number">6</span> could be <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>这个时候 <code>S1</code> 已经被优化好了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int16</span><br>num2 <span class="hljs-type">int8</span><br>flag <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文将带您全面深入地探索 Go 语言中结构体的各个方面，从基本定义、初始化和使用，到高级特性如结构体的组合、方法定义、内存对齐等。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨HTTPie</title>
    <link href="https://hedon.top/2024/03/06/rust-action-httpie/"/>
    <id>https://hedon.top/2024/03/06/rust-action-httpie/</id>
    <published>2024-03-06T14:22:02.000Z</published>
    <updated>2024-03-06T15:05:03.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>之前学习过《陈天·Rust 编程第一课 - 04｜get hands dirty：来写个实用的CLI 小工具》，学的时候迷迷糊糊。后来在系统学习完 Rust后，重新回过头来看这个实战小案例，基本上都能掌握，并且有了一些新的理解。所以我决定以一个Rust 初学者的角度，并以最新版本的 Rust（1.7.6）和clap（4.5.1）来重新实现这个案例，期望能对 Rust感兴趣的初学者提供一些帮助。</p><p>本文将实现的应用叫 HTTPie，HTTPie 是一个用 Python 编写的命令行 HTTP客户端，其目标是使 CLI 与 web 服务的交互尽可能愉快。它被设计为一个<code>curl</code> 和 <code>wget</code>的替代品，提供易于使用的界面和一些用户友好的功能，如 JSON支持、语法高亮和插件。它对于测试、调试和通常与 HTTP 服务器或 RESTful API进行交云的开发人员来说非常有用。</p><p>HTTPie 的一些关键特性包括：</p><ol type="1"><li><strong>JSON 支持</strong>：默认情况下，HTTPie 会自动发送JSON，并且可以轻松地通过命令行发送 JSON 请求体。</li><li><strong>语法高亮</strong>：它会为 HTTP响应输出提供语法高亮显示，使得结果更加易于阅读。</li><li><strong>插件</strong>：HTTPie 支持插件，允许扩展其核心功能。</li><li><strong>表单和文件上传</strong>：可以很容易地通过表单上传文件。</li><li><strong>自定义 HTTP 方法和头部</strong>：可以发送任何 HTTP方法的请求，自定义请求头部。</li><li><strong>HTTPS、代理和身份验证支持</strong>：支持 HTTPS请求、使用代理以及多种 HTTP 身份验证机制。</li><li><strong>流式上传和下载</strong>：支持大文件的流式上传和下载。</li><li><strong>会话支持</strong>：可以保存和重用常用的请求和集合。</li></ol><p>本文我们将实现其中的 <code>1</code>、<code>2</code> 和<code>5</code>。我们会支持发送 GET 和 POST 请求，其中 POST支持设置请求头和 JSON 数据。</p><p>在本文中，你可以学习到：</p><ul><li>如何用 <code>clap</code> 解析命令行参数。</li><li>如何用 <code>tokio</code> 进行异步编程。</li><li>如何用 <code>reqwest</code> 发送 HTTP 请求。</li><li>如何用 <code>colored</code> 在终端输出带颜色的内容。</li><li>如何用 <code>jsonxf</code> 美化 json 字符串。</li><li>如何用 <code>anyhow</code> 配合 <code>?</code> 进行错误传播。</li><li>如何使用 <code>HTTPie</code> 来进行 HTTP 接口测试。</li></ul><p>在进行实际开发之前，推荐你先了解一下：</p><ul><li><a href="https://hedon.top/2024/03/02/rust-crate-reqwest/">Rustreqwest 简明教程</a></li><li><a href="https://hedon.top/2024/03/05/rust-crate-anyhow/">Rustanyhow 简明教程</a></li><li><a href="https://hedon.top/2024/03/02/rust-crate-clap/">深入探索Rust 的 clap 库：命令行解析的艺术</a></li></ul><p>本文完整代码：<ahref="https://github.com/hedon954/httpie">hedon954/httpie</a></p><h1 id="开发思路">开发思路</h1><h2 id="http-协议">HTTP 协议</h2><p>回顾一下 HTTP 协议的请求体和响应体结构。</p><p>请求结构：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240303131157545.png"alt="http request structure" /><figcaption aria-hidden="true">http request structure</figcaption></figure><p>响应结构：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240303131123618.png"alt="http response structure" /><figcaption aria-hidden="true">http response structure</figcaption></figure><h2 id="命令分析">命令分析</h2><p>在本文中，我们就实现 HTTPie cli 官方的这个<ahref="https://github.com/httpie/cli?tab=readme-ov-file#examples">示例</a>：即允许指定请求方法、携带headers 和 json 数据发送请求。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240303131445159.png"alt="HTTPie 官方示例" /><figcaption aria-hidden="true">HTTPie 官方示例</figcaption></figure><p>我们来拆解一下，这个命令可以分为以下几个部分：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">httpie &lt;METHOD&gt; &lt;URL&gt; [headers | params]...<br></code></pre></td></tr></table></figure><ul><li><code>&lt;METHOD&gt;</code>: 请求方法，本案例中，我们仅支持 GET 和POST。</li><li><code>&lt;URL&gt;</code>: 请求地址。</li><li><code>&lt;HEADERS&gt;</code>: 请求头，格式为<code>h1:v1</code>。</li><li><code>&lt;PARAMS&gt;</code>: 请求参数，格式为<code>k1=v1</code>，最终以 json 结构发送。</li></ul><h2 id="效果展示">效果展示</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  httpie git:(master) ✗ ./Httpie --<span class="hljs-built_in">help</span>                                              <br>Usage: Httpie &lt;COMMAND&gt;<br><br>Commands:<br>  get   <br>  post  <br>  <span class="hljs-built_in">help</span>  Print this message or the <span class="hljs-built_in">help</span> of the given subcommand(s)<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br></code></pre></td></tr></table></figure><p>其中 post 子命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: Httpie post &lt;URL&gt; &lt;BODY&gt;...<br><br>Arguments:<br>  &lt;URL&gt;      Specify the url you wanna request to<br>  &lt;BODY&gt;...  Set the request body. Examples: headers: header1:value1 params: key1=value1<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>  Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>请求示例：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240305225846224.png"alt="httpie response demo" /><figcaption aria-hidden="true">httpie response demo</figcaption></figure><h2 id="思路梳理">思路梳理</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240306223319742.png"alt="httpie 开发思路梳理" /><figcaption aria-hidden="true">httpie 开发思路梳理</figcaption></figure><p><strong>第 1 步：解析命令行参数</strong></p><p>本案例中 httpie 支持 2 个子命令：</p><ul><li>get 支持 url 参数</li><li>post 支持 url、body 参数，因为其中 headers 和 params是变长的，我们统一用 <code>Vec&lt;String&gt;</code> 类型的 body来接收，然后用 <code>:</code> 和 <code>=</code> 来区分它们。</li></ul><p><strong>第 2 步：发送请求</strong></p><ol type="1"><li>使用 reqwest 创建 http client；</li><li>设置 url；</li><li>设置 method；</li><li>设置 headers；</li><li>设置 params；</li><li>发送请求；</li><li>获取响应体。</li></ol><p><strong>第 3 步：打印响应</strong></p><ol type="1"><li>打印 http version 和 status，并使用 colored 赋予蓝色；</li><li>打印 response headers，并使用 colored 赋予绿色；</li><li>确定 content-type，如果是 json，我们就用 jsonxf 美化 json 串并使用colored 赋予蓝绿色输出，如果是其他类型，这里我们就输出原文即可。</li></ol><h1 id="实战过程">实战过程</h1><h2 id="创建项目">1. 创建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new httpie<br></code></pre></td></tr></table></figure><h2 id="添加依赖">2. 添加依赖</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;httpie&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">anyhow</span> = <span class="hljs-string">&quot;1.0.80&quot;</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.1&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;<br><span class="hljs-attr">colored</span> = <span class="hljs-string">&quot;2.1.0&quot;</span><br><span class="hljs-attr">jsonxf</span> = <span class="hljs-string">&quot;1.1.1&quot;</span><br><span class="hljs-attr">mime</span> = <span class="hljs-string">&quot;0.3.17&quot;</span><br><span class="hljs-attr">reqwest</span> = &#123; version = <span class="hljs-string">&quot;0.11.24&quot;</span>, features = [<span class="hljs-string">&quot;json&quot;</span>] &#125;<br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1.36.0&quot;</span>, features = [<span class="hljs-string">&quot;rt&quot;</span>, <span class="hljs-string">&quot;rt-multi-thread&quot;</span>, <span class="hljs-string">&quot;macros&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><ul><li><code>anyhow</code>: 用于简化异常处理。</li><li><code>clap</code>: 解析命令行参数。</li><li><code>colored</code>: 为终端输出内容赋予颜色。</li><li><code>jsonxf</code>: 美化 json 串。</li><li><code>mime</code>: 提供了各种 Media Type 的类型封装。</li><li><code>reqwest</code>: http 客户端。</li><li><code>tokio</code>: 异步库，本案例种我们使用 reqwest的异步功能。</li></ul><h2 id="完整源码">3. 完整源码</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// src/main.rs  为减小篇幅，省略了单元测试，读者可自行补充。</span><br><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">use</span> reqwest::&#123;Client, header, Response&#125;;<br><span class="hljs-keyword">use</span> std::<span class="hljs-type">str</span>::FromStr;<br><span class="hljs-keyword">use</span> anyhow::anyhow;<br><span class="hljs-keyword">use</span> clap::&#123;Args, Parser, Subcommand&#125;;<br><span class="hljs-keyword">use</span> colored::Colorize;<br><span class="hljs-keyword">use</span> mime::Mime;<br><span class="hljs-keyword">use</span> reqwest::header::&#123;HeaderMap, HeaderName, HeaderValue&#125;;<br><span class="hljs-keyword">use</span> reqwest::Url;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Httpie</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    methods: Method,<br>&#125;<br><br><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-title function_ invoke__">Get</span>(Get),<br>    <span class="hljs-title function_ invoke__">Post</span>(Post)<br>&#125;<br><br><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Get</span> &#123;<br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-comment">/// Specify the url you wanna request to.</span><br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-comment">/// Set the request body.</span><br>    <span class="hljs-comment">/// Examples:</span><br>    <span class="hljs-comment">///     headers:</span><br>    <span class="hljs-comment">///         header1:value1</span><br>    <span class="hljs-comment">///     params:</span><br>    <span class="hljs-comment">///         key1=value1</span><br>    <span class="hljs-meta">#[arg(required = true, value_parser = parse_kv_pairs)]</span><br>    body: <span class="hljs-type">Vec</span>&lt;KvPair&gt;<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    k: <span class="hljs-type">String</span>,<br>    v: <span class="hljs-type">String</span>,<br>    t: KvPairType,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug,Clone)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">KvPairType</span> &#123;<br>    Header,<br>    Param,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">FromStr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Err</span> = anyhow::Error;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_str</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::<span class="hljs-literal">Err</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pair_type</span>: KvPairType;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">split_char</span> = <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">contains</span>(<span class="hljs-string">&#x27;:&#x27;</span>) &#123;<br>            pair_type = KvPairType::Header;<br>            <span class="hljs-string">&#x27;:&#x27;</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pair_type = KvPairType::Param;<br>            <span class="hljs-string">&#x27;=&#x27;</span><br>        &#125;;<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">split</span> = s.<span class="hljs-title function_ invoke__">split</span>(split_char);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">err</span> = || anyhow!(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;failed to parse pairs &#123;&#125;&quot;</span>,s));<br>        <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-keyword">Self</span> &#123;<br>            k: (split.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">ok_or_else</span>(err)?).<span class="hljs-title function_ invoke__">to_string</span>(),<br>            v: (split.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">ok_or_else</span>(err)?).<span class="hljs-title function_ invoke__">to_string</span>(),<br>            t: pair_type,<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_url</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_url</span>: Url = s.<span class="hljs-title function_ invoke__">parse</span>()?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">into</span>())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_kv_pairs</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;KvPair&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">parse</span>()?)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(client: Client, args: &amp;Get) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">resp</span> = client.<span class="hljs-title function_ invoke__">get</span>(&amp;args.url).<span class="hljs-title function_ invoke__">send</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">print_resp</span>(resp).<span class="hljs-keyword">await</span>?)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">post</span>(client: Client, args: &amp;Post) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">body</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">header_map</span> = HeaderMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">pair</span> <span class="hljs-keyword">in</span> args.body.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">match</span> pair.t &#123;<br>            KvPairType::Param =&gt;  &#123;body.<span class="hljs-title function_ invoke__">insert</span>(&amp;pair.k, &amp;pair.v);&#125;<br>            KvPairType::Header =&gt; &#123;<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(name) = HeaderName::<span class="hljs-title function_ invoke__">from_str</span>(pair.k.<span class="hljs-title function_ invoke__">as_str</span>()) &#123;<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(value) = HeaderValue::<span class="hljs-title function_ invoke__">from_str</span>(pair.v.<span class="hljs-title function_ invoke__">as_str</span>()) &#123;<br>                        header_map.<span class="hljs-title function_ invoke__">insert</span>(name,value);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Invalid header value for key: &#123;&#125;&quot;</span>, pair.v);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Invalid header key: &#123;&#125;&quot;</span>, pair.k);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">resp</span> = client.<span class="hljs-title function_ invoke__">post</span>(&amp;args.url)<br>        .<span class="hljs-title function_ invoke__">headers</span>(header_map)<br>        .<span class="hljs-title function_ invoke__">json</span>(&amp;body).<span class="hljs-title function_ invoke__">send</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">print_resp</span>(resp).<span class="hljs-keyword">await</span>?)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_resp</span>(resp: Response) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-title function_ invoke__">print_status</span>(&amp;resp);<br>    <span class="hljs-title function_ invoke__">print_headers</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mime</span> = <span class="hljs-title function_ invoke__">get_content_type</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = resp.<span class="hljs-title function_ invoke__">text</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">print_body</span>(mime, &amp;body);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_status</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">status</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;:?&#125; &#123;&#125;&quot;</span>, resp.<span class="hljs-title function_ invoke__">version</span>(), resp.<span class="hljs-title function_ invoke__">status</span>()).<span class="hljs-title function_ invoke__">blue</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>, status);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_headers</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">for</span> (k,v) <span class="hljs-keyword">in</span> resp.<span class="hljs-title function_ invoke__">headers</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, k.<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">green</span>(), v);<br>    &#125;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_body</span>(mime: <span class="hljs-type">Option</span>&lt;Mime&gt;, resp: &amp;<span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-keyword">match</span> mime &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(v) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> v == mime::APPLICATION_JSON &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, jsonxf::<span class="hljs-title function_ invoke__">pretty_print</span>(resp).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">cyan</span>())<br>            &#125;<br>        &#125;<br>        _ =&gt; <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, resp),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_content_type</span>(resp: &amp;Response) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Mime&gt; &#123;<br>    resp.<span class="hljs-title function_ invoke__">headers</span>()<br>        .<span class="hljs-title function_ invoke__">get</span>(header::CONTENT_TYPE)<br>        .<span class="hljs-title function_ invoke__">map</span>(|v|v.<span class="hljs-title function_ invoke__">to_str</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>())<br>&#125;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt;&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">httpie</span> = Httpie::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">match</span> httpie.methods &#123;<br>        Method::<span class="hljs-title function_ invoke__">Get</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">get</span>(client, args).<span class="hljs-keyword">await</span>?,<br>        Method::<span class="hljs-title function_ invoke__">Post</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">post</span>(client, args).<span class="hljs-keyword">await</span>?,<br>    &#125;;<br>    <span class="hljs-title function_ invoke__">Ok</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，即使算上 <code>use</code> 部分，总代码也不过160行左右，Rust 的 <code>clap</code> 库在 CLI 开发上确实 yyds！</p><p>接下来我们来一一拆解这部分的代码，其中关于 <code>clap</code>的部分我不会过多展开，刚兴趣的读者可以参阅：<ahref="https://hedon.top/2024/03/02/rust-crate-clap/">深入探索 Rust 的clap 库：命令行解析的艺术</a>。</p><h3 id="命令行解析">3.1 命令行解析</h3><p>我们先从 <code>main()</code> 开始：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt;&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">httpie</span> = Httpie::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">match</span> httpie.methods &#123;<br>        Method::<span class="hljs-title function_ invoke__">Get</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">get</span>(client, args).<span class="hljs-keyword">await</span>?,<br>        Method::<span class="hljs-title function_ invoke__">Post</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">post</span>(client, args).<span class="hljs-keyword">await</span>?,<br>    &#125;;<br>    <span class="hljs-title function_ invoke__">Ok</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望使用 <code>clap</code> 的异步功能，所以使用了<code>async</code> 关键字，同时加上了 <code>tokio</code> 提供的属性宏<code>#[tokio::main]</code>，用于设置异步环境。为了能够使用<code>?</code> 快速传播错误，我们设置返回值为<code>anyhow::Result&lt;()&gt;</code>，本项目中我们不对错误进行过多处理，所以这种方式可以大大简化我们的错误处理过程。</p><p><code>main()</code> 中我们使用 <code>Httpie::parse()</code>解析命令行中的参数，使用 <code>Client::new()</code> 创建一个 httpclient，根据解析到的命令行参数，我们匹配子命令<code>methods</code>，分别调用 <code>get()</code> 和 <code>post()</code>来发送 GET 和 POST 请求。</p><p><code>Httpie</code> 的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Httpie</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    methods: Method,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Parser)]</code> 是一个过程宏（proceduralmacro），用于自动为结构体实现 <code>clap::Parser</code>trait。这使得该结构体可以用来解析命令行参数。</p><p>在 <code>Httpie</code> 中我们定义了子命令 <code>Method</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-title function_ invoke__">Get</span>(Get),<br>    <span class="hljs-title function_ invoke__">Post</span>(Post)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Subcommand)]</code>属性宏会自动为枚举派生一些代码，以便它可以作为子命令来解析命令行参数。目前支持<code>Get</code> 和 <code>Post</code> 两个子命令，它们分别接收<code>Get</code> 和 <code>Post</code> 参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Get</span> &#123;<br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br>  <br>    <span class="hljs-meta">#[arg(value_parser = parse_kv_pairs)]</span><br>    body: <span class="hljs-type">Vec</span>&lt;KvPair&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Args)]</code> 属性宏表明当前 struct 是命令的参数，其中<code>Get</code> 仅支持 <code>url</code> 参数，<code>Post</code> 支持<code>url</code> 和 <code>body</code> 参数。</p><p><code>url</code> 参数我们使用 <code>parse_url</code>函数来进行解析：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest::Url;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_url</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_url</span>: Url = s.<span class="hljs-title function_ invoke__">parse</span>()?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">into</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>reqwest::Url</code> 已经实现了 <code>FromStr</code>trait，所以这里我们可以直接调用 <code>s.parse()</code> 来解析<code>url</code>。</p><p>而 <code>body</code>，因为我们期望 CLI 使用起来像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">httpie url header1:value1 param1=v1<br></code></pre></td></tr></table></figure><p><code>body</code> 就是 <code>header1:value1 param1=v1</code>，一对 kv就代表着一个 header 或者 param，用 <code>:</code> 和 <code>=</code>来区分。因为 kv 对的个数的变长的，所以我们使用<code>Vec&lt;KvPair&gt;</code> 来接收 <code>body</code> 这个参数，并使用<code>parse_kv_pairs</code> 来解析 kv 对。</p><p><code>KvPair</code> 是我们自定义的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    k: <span class="hljs-type">String</span>,<br>    v: <span class="hljs-type">String</span>,<br>    t: KvPairType,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug,Clone)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">KvPairType</span> &#123;<br>    Header,<br>    Param,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>parse_kv_pairs</code> 的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_kv_pairs</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;KvPair&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">parse</span>()?)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，你可以在 <code>parse_kv_pairs()</code> 函数中，对<code>s</code> 进行解析并返回<code>anyhow::Result&lt;KvPair&gt;</code>。不过，更优雅，更统一的方式是什么呢？就是像<code>reqwest::Url</code> 一样，为 <code>KvPair</code> 实现<code>FromStr</code> trait，这样就可以直接调用 <code>s.parse()</code>来进行解析了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">FromStr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Err</span> = anyhow::Error;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_str</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::<span class="hljs-literal">Err</span>&gt; &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发送请求">3.2 发送请求</h3><p>参数解析完，就到了发送请求的地方了，这里使用 <code>reqwest</code>crate 就非常方便了，这里就不赘述了，具体可以参考：<ahref="https://hedon.top/2024/03/02/rust-crate-reqwest/">Rust reqwest简明教程</a>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(client: Client, args: &amp;Get) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123; ... &#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">post</span>(client: Client, args: &amp;Post) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="打印响应">3.3 打印响应</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240305225846224.png"alt="httpie response demo" /><figcaption aria-hidden="true">httpie response demo</figcaption></figure><p>响应分为 3 个部分：</p><ul><li>print_status()</li><li>print_headers()</li><li>print_body()</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_resp</span>(resp: Response) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-title function_ invoke__">print_status</span>(&amp;resp);<br>    <span class="hljs-title function_ invoke__">print_headers</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mime</span> = <span class="hljs-title function_ invoke__">get_content_type</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = resp.<span class="hljs-title function_ invoke__">text</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">print_body</span>(mime, &amp;body);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p><code>print_status()</code> 比较简单，就是打印 HTTP版本和响应状态码，然后我们使用 <code>colored</code> crate 的<code>blue()</code> 使其在终端以<font color="blue">蓝色</font>输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_status</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">status</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;:?&#125; &#123;&#125;&quot;</span>, resp.<span class="hljs-title function_ invoke__">version</span>(), resp.<span class="hljs-title function_ invoke__">status</span>()).<span class="hljs-title function_ invoke__">blue</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>, status);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>print_headers()</code> 中，我们使用 <code>green()</code> 使header_name 在终端以<font color="green">绿色</font>输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_headers</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">for</span> (k,v) <span class="hljs-keyword">in</span> resp.<span class="hljs-title function_ invoke__">headers</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, k.<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">green</span>(), v);<br>    &#125;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>响应体的格式（Media Type）有很多，本案例中我们仅支持<code>application/json</code>，所以在 <code>print_body()</code>之前，我们需要先读取 response header 中的 content-type：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_content_type</span>(resp: &amp;Response) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Mime&gt; &#123;<br>    resp.<span class="hljs-title function_ invoke__">headers</span>()<br>        .<span class="hljs-title function_ invoke__">get</span>(header::CONTENT_TYPE)<br>        .<span class="hljs-title function_ invoke__">map</span>(|v|v.<span class="hljs-title function_ invoke__">to_str</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>print_resp()</code> 中，对于<code>application/json</code>，我们使用 <code>jsonxf</code> crate对进行美化，并使用 <code>cyan()</code>使其在终端以<font color="cyan">蓝绿色</font>输出。对于其他类型，我们姑且照原文输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_body</span>(mime: <span class="hljs-type">Option</span>&lt;Mime&gt;, resp: &amp;<span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-keyword">match</span> mime &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(v) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> v == mime::APPLICATION_JSON &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, jsonxf::<span class="hljs-title function_ invoke__">pretty_print</span>(resp).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">cyan</span>())<br>            &#125;<br>        &#125;<br>        _ =&gt; <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, resp),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>在本文中，我们深入探讨了如何使用 Rust 语言来实现一个类似于 HTTPie的命令行工具。这个过程包括了对 HTTP 协议的理解、命令行参数的解析、HTTP客户端的创建和请求发送，以及对响应的处理和展示。通过本文，读者不仅能够获得一个实用的命令行工具，还能够学习到如何使用Rust 的库来构建实际的应用程序，包括<code>clap</code>、<code>reqwest</code>、<code>tokio</code> 和<code>colored</code> 等。此外，文章也说明了在 Rust中进行异步编程和错误处理的一些常见模式。尽管示例代码的错误处理较为简单，但它提供了一个良好的起点，开发者可以在此基础上进行扩展和改进，以适应更复杂的应用场景。</p>]]></content>
    
    
    <summary type="html">我们深入探讨了如何使用 Rust 语言来实现一个类似于 HTTPie 的命令行工具。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust anyhow 简明教程</title>
    <link href="https://hedon.top/2024/03/05/rust-crate-anyhow/"/>
    <id>https://hedon.top/2024/03/05/rust-crate-anyhow/</id>
    <published>2024-03-05T15:44:00.000Z</published>
    <updated>2024-05-11T15:53:19.389Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.rs/anyhow/latest/anyhow/index.html">anyhow</a>是 Rust 中的一个库，旨在提供灵活的、具体的错误处理能力，建立在<code>std::error::Error</code>基础上。它主要用于那些需要简单错误处理的应用程序和原型开发中，尤其是在错误类型不需要被严格区分的场景下。</p><p>以下是 <code>anyhow</code> 的几个关键特性：</p><ul><li><strong>易用性</strong>: <code>anyhow</code> 提供了一个<code>Error</code> 类型，这个类型可以包含任何实现了<code>std::error::Error</code> 的错误。这意味着你可以使用<code>anyhow::Error</code>来包装几乎所有类型的错误，无需担心具体的错误类型。</li><li><strong>简洁的错误链</strong>: <code>anyhow</code> 支持通过<code>?</code>操作符来传播错误，同时保留错误发生的上下文。这让错误处理更加直观，同时还能保留错误链，便于调试。</li><li><strong>便于调试</strong>: <code>anyhow</code> 支持通过<code>&#123;:#&#125;</code>格式化指示符来打印错误及其所有相关的上下文和原因，这使得调试复杂的错误链变得更加简单。</li><li><strong>无需关心错误类型</strong>:在很多情况下，特别是在应用程序的顶层，你可能不需要关心错误的具体类型，只需要知道出错了并且能够将错误信息传递给用户或日志。<code>anyhow</code>让这一过程变得简单，因为它可以包装任何错误，而不需要显式地指定错误类型。</li></ul><p>使用 <code>anyhow</code>的典型场景包括快速原型开发、应用程序顶层的错误处理，或者在库中作为返回错误类型的一个简便选择，尤其是在库的使用者不需要关心具体错误类型的时候。</p><h2 id="anyhowerror">anyhow::Error</h2><p><code>anyhow::Error</code> 是 <code>anyhow</code>库定义的一个错误类型。它是一个包装器（wrapper）类型，可以包含任何实现了<code>std::error::Error</code> trait的错误类型。这意味着你可以将几乎所有的错误转换为<code>anyhow::Error</code>类型，从而在函数之间传递，而不需要在意具体的错误类型。这在快速原型开发或应用程序顶层错误处理中特别有用，因为它简化了错误处理的逻辑。</p><p>它的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg_attr(not(doc), repr(transparent))]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Error</span> &#123;<br>    inner: Own&lt;ErrorImpl&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p>其中核心是 <code>ErrorImpl</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[repr(C)]</span><br><span class="hljs-title function_ invoke__">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ErrorImpl</span>&lt;E = ()&gt; &#123;<br>    vtable: &amp;<span class="hljs-symbol">&#x27;static</span> ErrorVTable,<br>    backtrace: <span class="hljs-type">Option</span>&lt;Backtrace&gt;,<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Don&#x27;t use directly. Use only through vtable. Erased type may have</span><br>    <span class="hljs-comment">// different alignment.</span><br>    _object: E,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ErrorImpl</code> 是一个内部结构体，用于实现<code>anyhow::Error</code> 类型的具体功能。它包含了三个主要字段：</p><ul><li><code>vtable</code>是一个指向静态虚拟表的指针，用于动态派发错误相关的方法。</li><li><code>backtrace</code>是一个可选的回溯（Backtrace）类型，用于存储错误发生时的调用栈信息。</li><li><code>_object</code>字段用于存储具体的错误对象，其类型在编译时被擦除以提供类型安全的动态错误处理。</li></ul><p>这种设计允许 <code>anyhow</code>错误封装并表示各种不同的错误类型，同时提供了方法动态派发和回溯功能，以便于错误调试。</p><p><code>anyhow::Error</code> 可以包含任何实现了<code>std::error::Error</code> trait 的错误类型，这里因为下面的<code>impl</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">impl&lt;E&gt; StdError <span class="hljs-keyword">for</span> ErrorImpl&lt;E&gt;<br>where<br>    E: StdError,<br>&#123;<br>    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn StdError + <span class="hljs-string">&#x27;static)&gt; &#123;</span><br><span class="hljs-string">        unsafe &#123; ErrorImpl::error(self.erase()).source() &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    #[cfg(error_generic_member_access)]</span><br><span class="hljs-string">    fn provide&lt;&#x27;</span>a&gt;(&amp;<span class="hljs-string">&#x27;a self, request: &amp;mut Request&lt;&#x27;</span>a&gt;) &#123;<br>        unsafe &#123; ErrorImpl::provide(self.erase(), request) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="anyhowresult">anyhow::Result</h2><p><code>anyhow::Result</code> 是一个别名（type alias），它是<code>std::result::Result&lt;T, anyhow::Error&gt;</code> 的简写。在使用<code>anyhow</code>库进行错误处理时，你会频繁地看到这个类型。它基本上是标准的<code>Result</code> 类型，但错误类型被固定为<code>anyhow::Error</code>。这使得你可以很容易地在函数之间传递错误，而不需要声明具体的错误类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span>&lt;T, E = Error&gt; = core::result::<span class="hljs-type">Result</span>&lt;T, E&gt;;<br></code></pre></td></tr></table></figure><p>使用 <code>anyhow::Result</code>的好处在于它提供了一种统一的方式来处理错误。你可以使用 <code>?</code>操作符来传播错误，同时保留错误的上下文信息和回溯。这极大地简化了错误处理代码，尤其是在多个可能产生不同错误类型的操作链中。</p><h2 id="个核心使用技巧">3 个核心使用技巧</h2><ul><li>使用 <code>Result&lt;T, anyhow::Error&gt;</code> 或者<code>anyhow::Result&lt;T&gt;</code> 作为返回值，然后利用 <code>?</code>语法糖无脑传播报错。</li><li>使用 with_context(f) 来附加错误信息。</li><li>使用 downcast 反解具体的错误类型。</li></ul><h2 id="实战案例">实战案例</h2><p>下面我们用一个案例来体会 <code>anyhow</code> 的使用方式：</p><p>我们的需求是：打开一个文件，解析文件中的数据并进行大写化，然后输出处理后的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> anyhow::&#123;<span class="hljs-type">Result</span>, Context&#125;;<br><span class="hljs-keyword">use</span> std::&#123;fs, io&#125;;<br><br><span class="hljs-comment">// 1. 读取文件、解析数据和执行数据操作都可能出现错误，</span><br><span class="hljs-comment">// 所以我们需要返回 Result 来兼容异常情况。</span><br><span class="hljs-comment">// 这里我们使用 anyhow::Result 来简化和传播错误。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_and_process_file</span>(file_path: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// 尝试读取文件</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">data</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(file_path)<br>        <span class="hljs-comment">// 2. 使用 with_context 来附加错误信息，然后利用 ? 语法糖传播错误。</span><br>        .<span class="hljs-title function_ invoke__">with_context</span>(||<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;failed to read file `&#123;&#125;`&quot;</span>, file_path))?;<br><br>    <span class="hljs-comment">// 解析数据</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">processed_data</span> = <span class="hljs-title function_ invoke__">parse_data</span>(&amp;data)<br>        .<span class="hljs-title function_ invoke__">with_context</span>(||<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;failed to parse data from file `&#123;&#125;`&quot;</span>, file_path))?;<br><br>    <span class="hljs-comment">// 执行数据操作</span><br>    <span class="hljs-title function_ invoke__">perform_some_operation</span>(processed_data)<br>        .<span class="hljs-title function_ invoke__">with_context</span>(|| <span class="hljs-string">&quot;failed to perform operation based on file data&quot;</span>)?;<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_data</span>(data: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(data.<span class="hljs-title function_ invoke__">to_uppercase</span>())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">perform_some_operation</span>(data: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;processed data: &#123;&#125;&quot;</span>, data);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">file_path</span> = <span class="hljs-string">&quot;./anyhow.txt&quot;</span>;<br>  <span class="hljs-comment">// 执行处理逻辑</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> =  <span class="hljs-title function_ invoke__">read_and_process_file</span>(file_path);<br>  <span class="hljs-comment">// 处理结果</span><br>    <span class="hljs-keyword">match</span> res &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;successfully!&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; &#123;<br>            <span class="hljs-comment">// 3. 使用 downcast 来反解出实际的错误实例，本案例中可能出现的异常是 io::Error。</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(my_error) = e.downcast_ref::&lt;io::Error&gt;() &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;has io error: &#123;:#&#125;&quot;</span>, my_error);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;unknown error: &#123;:?&#125;&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">探索 Rust 的 anyhow 库，它提供了一个简单而强大的方式来处理错误。本教程将引导你了解 anyhow 的核心特性，包括易用性、错误链、调试便利性，以及如何在不同场景下利用 anyhow 来简化错误处理。无论是快速原型开发还是应用程序顶层错误处理，anyhow 都是 Rust 开发者的得力助手。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 常用库" scheme="https://hedon.top/categories/Rust/Rust-%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>深入探索 Rust 的 clap 库：命令行解析的艺术</title>
    <link href="https://hedon.top/2024/03/02/rust-crate-clap/"/>
    <id>https://hedon.top/2024/03/02/rust-crate-clap/</id>
    <published>2024-03-02T12:08:59.000Z</published>
    <updated>2024-03-06T14:47:39.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="版本声明">版本声明</h1><ul><li>Rust: 1.76</li><li><a href="https://docs.rs/clap/4.5.1/clap/index.html">clap:4.5.1</a></li><li><ahref="https://docs.rs/clap_complete/4.5.1/clap_complete/index.html">clap_complete4.5.1</a></li><li><ahref="https://docs.rs/rpassword/7.3.1/rpassword/index.html">rpassword:7.3.1</a></li></ul><h1 id="结论先行">结论先行</h1><p>本文将从 CLI（Command LineInterface）命令行工具的概述讲起，介绍一个优秀的命令行工具应该具备的功能和特性。然后介绍Rust 中一个非常优秀的命令行解析工具 <code>clap</code>经典使用方法，并利用 <code>clap</code> 实现一个类似于 <code>curl</code>的工具 <code>httpie</code>。文章最后还将 <code>clap</code> 于 Go语言中同样优秀的命令行解析工具 <code>cobra</code>进行一个简单对比，便于读者进一步体会 <code>clap</code>的简洁和优秀。</p><p>本文将包含以下几个部分：</p><ol type="1"><li><strong>CLI 概述</strong>：从 CLI的基本概念出发，介绍优秀命令行工具应该具备的功能特性，并以 curl作为经典范例进行说明。</li><li><strong>详细介绍 clap</strong>：基于 clap 官方文档，分别详细介绍clap 以 derive 和 builder 两个方式构建 cli 的常用方法。</li><li><strong>实战 httpie</strong>：参考陈天老师的《Rust编程第一课》，用最新的 clap 版本（1.7.6）实现 httpie 工具。</li><li><strong>对比cobra</strong>：从设计理念和目标、功能特点、使用场景等方面简要对比 clap和 Go 流行的命令行解析库 cobra。</li></ol><p>特此声明，本文包含 AI 辅助生成内容，如有错误遗漏之处，敬请指出。</p><h1 id="cli-概述">CLI 概述</h1><p>CLI（Command LineInterface，命令行界面）是一种允许用户通过文本命令与计算机程序或操作系统进行交互的接口。与图形用户界面（GUI，GraphicalUser Interface）相比，CLI不提供图形元素，如按钮或图标，而是依赖于文本输入。用户通过键盘输入特定的命令行指令，命令行界面解释这些指令并执行相应的操作。</p><p>一款优秀的 CLI工具应该具备以下的功能和特性，以提升用户体验和效率：</p><p>一个优秀的命令行工具（CLI, Command LineInterface）应该具备以下功能和特性，以提升用户体验和效率：</p><ol type="1"><li><strong>直观易用</strong>：<ul><li><strong>简洁的命令语法</strong>：命令和参数的设计应直观易懂，方便用户记忆和使用。</li><li><strong>自动补全</strong>：支持命令和参数的自动补全功能，提高用户输入效率。</li><li><strong>命令别名</strong>：提供常用命令的简短别名，减少输入的工作量。</li></ul></li><li><strong>强大的帮助系统</strong>：<ul><li><strong>详细的帮助文档</strong>：每个命令和参数都应有清晰的说明文档。</li><li><strong>示例使用方式</strong>：提供常见的使用示例，帮助用户快速理解和应用。</li><li><strong>内置帮助命令</strong>：通过如<code>--help</code>或<code>-h</code>参数轻松访问帮助信息。</li></ul></li><li><strong>错误处理与反馈</strong>：<ul><li><strong>清晰的错误信息</strong>：出现错误时，提供明确、具体的错误信息，帮助用户快速定位问题。</li><li><strong>建议和解决方案</strong>：在可能的情况下，给出错误解决的建议或自动修复选项。</li></ul></li><li><strong>高效的执行和输出</strong>：<ul><li><strong>快速响应</strong>：命令执行应迅速，减少用户等待时间。</li><li><strong>格式化的输出</strong>：提供易于阅读和解析的输出格式，如表格、JSON或 XML 等。</li><li><strong>输出过滤和排序</strong>：允许用户根据需要过滤和排序输出结果，提高信息的查找效率。</li></ul></li><li><strong>跨平台兼容</strong>：<ul><li><strong>多平台支持</strong>：能够在不同的操作系统上运行，如Windows、macOS、Linux 等。</li><li><strong>环境适应性</strong>：自动适应不同的终端环境和字符编码，确保输出显示正确。</li></ul></li><li><strong>安全性</strong>：<ul><li><strong>安全的默认设置</strong>：默认配置应强调安全，避免暴露敏感信息。</li><li><strong>数据加密</strong>：在处理敏感信息（如密码）时，应使用加密手段保护数据安全。</li></ul></li><li><strong>版本管理</strong>：<ul><li><strong>版本控制</strong>：提供命令查看工具版本，支持多版本共存或升级。</li><li><strong>向后兼容</strong>：新版本应尽量保持与旧版本的兼容性，避免破坏用户现有的工作流程。</li></ul></li></ol><p>这些特性不仅能够提高用户的工作效率，还能增强用户体验，使命令行工具更加强大和易用。</p><p>下面我们以 <code>curl</code> 为例，看看优秀的 CLI工具大概长什么样子。</p><p><code>curl</code>是一种命令行工具和库，用于传输数据。它支持多种协议，包括HTTP、HTTPS、FTP、FTPS、SCP、SFTP、TFTP、TELNET、DICT、LDAP、LDAPS、IMAP、POP3、SMTP和 RTSP 等。<code>curl</code>是一个非常强大和灵活的工具，广泛应用于自动化脚本、系统测试、数据收集和许多其他用途。</p><p>进入终端，我们可以用下面命令查看 <code>curl</code> 的说明文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ curl --<span class="hljs-built_in">help</span><br>Usage: curl [options...] &lt;url&gt;<br> -d, --data &lt;data&gt;          HTTP POST data<br> -f, --fail                 Fail fast with no output on HTTP errors<br> -h, --<span class="hljs-built_in">help</span> &lt;category&gt;      Get <span class="hljs-built_in">help</span> <span class="hljs-keyword">for</span> commands<br> -i, --include              Include protocol response headers <span class="hljs-keyword">in</span> the output<br> -o, --output &lt;file&gt;        Write to file instead of stdout<br> -O, --remote-name          Write output to a file named as the remote file<br> -s, --silent               Silent mode<br> -T, --upload-file &lt;file&gt;   Transfer <span class="hljs-built_in">local</span> FILE to destination<br> -u, --user &lt;user:password&gt; Server user and password<br> -A, --user-agent &lt;name&gt;    Send User-Agent &lt;name&gt; to server<br> -v, --verbose              Make the operation more talkative<br> -V, --version              Show version number and quit<br><br>This is not the full <span class="hljs-built_in">help</span>, this menu is stripped into categories.<br>Use <span class="hljs-string">&quot;--help category&quot;</span> to get an overview of all categories.<br>For all options use the manual or <span class="hljs-string">&quot;--help all&quot;</span>.<br></code></pre></td></tr></table></figure><p>使用示例：</p><ul><li>下载文件： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -O http://example.com/file.txt<br></code></pre></td></tr></table></figure></li><li>发送 POST 请求： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&quot;param1=value1&amp;param2=value2&quot;</span> http://example.com/resource<br></code></pre></td></tr></table></figure></li><li>使用 HTTPS 并忽略证书验证： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -k https://example.com<br></code></pre></td></tr></table></figure></li><li>使用基本认证： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -u username:password http://example.com<br></code></pre></td></tr></table></figure></li></ul><p><code>curl</code>的这些特性使其成为开发者、系统管理员和自动化脚本中广泛使用的工具之一。</p><h1 id="clap">clap</h1><h2 id="概述">概述</h2><p><code>clap</code>，代表 <em>Command Line ArgumentParser</em>，是一个旨在创建直观、易用且功能强大的命令行界面的 Rust库。截至目前（2024.2），<code>clap</code> 已经发展到了 4.5.1版本，它通过简化命令行参数的处理，让开发者能更专注于应用逻辑的构建。</p><p><code>clap</code> 之所以在 Rust社区如此流行，得益于以下几个优点：</p><p><strong>1. 易于使用</strong></p><p><code>clap</code>的设计理念是让命令行参数的解析变得简单而直观。即使是没有经验的开发者也能快速上手，通过几行代码就能实现复杂的命令行参数解析。</p><p><strong>2. 功能丰富</strong></p><p><code>clap</code>提供了广泛的功能来满足各种命令行解析需求，包括但不限于：</p><ul><li><strong>自动生成的帮助信息</strong>：<code>clap</code>能根据定义的参数自动生成帮助信息，包括参数的说明、类型、默认值等。</li><li><strong>强大的错误提示</strong>：当用户输入无效的命令行参数时，<code>clap</code>会提供清晰且有用的错误提示，帮助用户快速定位问题。</li><li><strong>参数验证</strong>：开发者可以为参数设定验证规则，确保输入的参数符合预期。</li><li><strong>复杂的命令结构</strong>：支持子命令的嵌套，允许构建复杂的命令行应用结构。</li><li><strong>自定义派生</strong>：通过 <code>clap</code>的派生宏，可以简化命令行解析器的定义，使代码更加清晰。</li></ul><p><strong>3. 高度可定制</strong></p><p><code>clap</code>允许开发者高度定制命令行解析的行为和外观，包括自定义帮助信息的格式、控制错误消息的显示方式等。这种灵活性意味着你可以根据应用程序的需求调整<code>clap</code> 的行为。</p><p><strong>4. 性能优异</strong></p><p>尽管 <code>clap</code>功能强大，但它仍然非常注重性能。<code>clap</code>经过优化，以尽可能少的性能开销处理命令行参数。</p><p><strong>5. 活跃的社区支持</strong></p><p><code>clap</code> 有一个非常活跃的社区，在 GitHub上不断有新的贡献者加入。这意味着 <code>clap</code>不断地得到改进和更新，同时也有大量的社区资源可供参考。</p><h2 id="derive-vs-builder-1-初探">Derive vs Builder (1) 初探</h2><p><code>clap</code> 提供了 2 种构建命令行的方式，分别为<code>Derive</code> 和<code>Builder</code>。顾名思义，<code>Derive</code>就是利用宏强大的功能来构建命令行，而 <code>Builder</code>则采用构建者模式链式构建命令行工具。</p><p>在这里我们先给出示例来直观感受这 2 种构建方式的不同：</p><p>Derive:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-comment">/// Specify your name</span><br>    name: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-comment">/// Specify your age optionally</span><br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    age: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i8</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name: &#123;&#125;&quot;</span>, cli.name);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;age: &#123;:?&#125;&quot;</span>, cli.age);<br>&#125;<br></code></pre></td></tr></table></figure><p>Builder:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;myapp&quot;</span>)<br>  .<span class="hljs-title function_ invoke__">version</span>(<span class="hljs-string">&quot;1.0.0&quot;</span>)<br>  .<span class="hljs-title function_ invoke__">author</span>(<span class="hljs-string">&quot;hedon&quot;</span>)<br>  .<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;this is the short about&quot;</span>)<br>  .<span class="hljs-title function_ invoke__">long_about</span>(<span class="hljs-string">&quot;this is the long about&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!([NAME]).<span class="hljs-title function_ invoke__">required</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your name&quot;</span>))<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(-a --age &lt;AGE&gt;)<br>            .<span class="hljs-title function_ invoke__">value_parser</span>(clap::value_parser!(<span class="hljs-type">u8</span>))<br>            .<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your age optionally&quot;</span>))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name: &#123;:?&#125;&quot;</span>, matches.get_one::&lt;<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;NAME&quot;</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;age: &#123;:?&#125;&quot;</span>, matches.get_one::&lt;<span class="hljs-type">u8</span>&gt;(<span class="hljs-string">&quot;age&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这 2 个程序都实现了相同的功能，使用 <code>--help</code>，输出的内容大致都如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: derive [OPTIONS] &lt;NAME&gt;<br><br>Arguments:<br>  &lt;NAME&gt;  Specify your name<br><br>Options:<br>  -a, --age &lt;AGE&gt;  Specify your age optionally<br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>通过观察，可以发现 Derive 模式下，宏中的每一个属性，如<code>version</code>、<code>author</code> 等，都对应到 Builder模式下一个同名的函数。</p><p>下面我们将从<strong>「应用配置」</strong>、<strong>「参数类型」</strong>和<strong>「参数校验」</strong>三个方面，分别介绍<code>clap</code> 中 Derive 和 Builder 两种模式构建 CLI 的常用方法。</p><p>特别说明：后续的例子均在 <code>examples</code>目录下实现，故编译和执行命令都包含 example。</p><p>目录结构大概如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ tree         <br>.<br>├── Cargo.lock<br>├── Cargo.toml<br>├── examples<br>│   ├── optional.rs<br>├── src<br>│   └── main.rs<br>└── target<br>    └── release<br>        └── examples<br>        └── optional<br></code></pre></td></tr></table></figure><h2 id="derive">Derive</h2><p>要使用 <code>clap</code> 的 Derive 模式，需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add clap --features derive<br></code></pre></td></tr></table></figure><h3 id="应用配置">1. 应用配置</h3><p>我们需要定义一个 <code>strut</code> 来表示我们的<code>application</code>，利用它来承载应用的参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// The example of clap derive</span><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-comment">/// Specify your name</span><br>    name: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-comment">/// Specify your age optionally</span><br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    age: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i8</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name: &#123;&#125;&quot;</span>, cli.name);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;age: &#123;:?&#125;&quot;</span>, cli.age);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Parser)]</code> 是一个过程宏（proceduralmacro），用于自动为结构体实现 <code>clap::Parser</code>trait。这使得该结构体可以用来解析命令行参数。</p><ul><li>使用<code>#[derive(Parser)]</code>，你可以简化命令行解析的代码，因为<code>clap</code> 会根据结构体的字段自动生成命令行解析的逻辑。</li><li>每个字段都对应一个命令行参数，字段的类型和属性用来决定参数的解析方式和验证规则。</li></ul><p><code>#[command(version, about, long_about = None)]</code>属性用于为整个命令行程序提供元信息，它支持以下几个元素：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240301202114143.png"alt="#[command] 支持的元素" /><figcaption aria-hidden="true">#[command] 支持的元素</figcaption></figure><p><code>#[arg(short, long)]</code>属性用于配置命令参数的元信息，它支持以下几个属性：</p><table><thead><tr class="header"><th>属性</th><th>方法</th><th>默认值/行为</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>id</td><td>Arg::id</td><td>field’s name</td><td>当属性不存在时，使用字段名</td></tr><tr class="even"><td>value_parser</td><td>Arg::value_parser</td><td>auto-select based on field type</td><td>当属性不存在时，会基于字段类型自动选择实现</td></tr><tr class="odd"><td>action</td><td>Arg::action</td><td>auto-select based on field type</td><td>当属性不存在时，会基于字段类型自动选择动作</td></tr><tr class="even"><td>help</td><td>Arg::help</td><td>Doc comment summary</td><td>当属性不存在时，使用文档注释摘要</td></tr><tr class="odd"><td>long_help</td><td>Arg::long_help</td><td>Doc comment with blank line, else nothing</td><td>当属性不存在时，使用文档注释，如果有空行</td></tr><tr class="even"><td>verbatim_doc_comment</td><td>Minimizes preprocessing</td><td>-</td><td>将文档注释转换为 help/long_help 时最小化预处理</td></tr><tr class="odd"><td>short</td><td>Arg::short</td><td>no short set</td><td>当属性不存在时，没有短名称设置</td></tr><tr class="even"><td>long</td><td>Arg::long</td><td>no long set</td><td>当属性不存在时，没有长名称设置</td></tr><tr class="odd"><td>env</td><td>Arg::env</td><td>no env set</td><td>当属性不存在时，没有环境变量设置</td></tr><tr class="even"><td>from_global</td><td>Read Arg::global</td><td>-</td><td>无论在哪个子命令中，都读取 Arg::global 参数</td></tr><tr class="odd"><td>value_enum</td><td>Parse with ValueEnum</td><td>-</td><td>使用 ValueEnum 解析值</td></tr><tr class="even"><td>skip</td><td>Ignore this field</td><td>fills the field with Default::default()</td><td>忽略此字段，用 &lt;expr&gt; 或 Default::default() 填充</td></tr><tr class="odd"><td>default_value</td><td>Arg::default_value</td><td>Arg::required(false)</td><td>设置默认值，并将 Arg 设置为非必须</td></tr><tr class="even"><td>default_value_t</td><td>Arg::default_value</td><td>Arg::required(false)</td><td>要求 std::fmt::Display 与 Arg::value_parser 相匹配</td></tr><tr class="odd"><td>default_values_t</td><td>Arg::default_values</td><td>Arg::required(false)</td><td>要求字段类型为 Vec&lt;T&gt;，T 实现 std::fmt::Display</td></tr><tr class="even"><td>default_value_os_t</td><td>Arg::default_value_os</td><td>Arg::required(false)</td><td>要求 std::convert::Into&lt;OsString&gt;</td></tr><tr class="odd"><td>default_values_os_t</td><td>Arg::default_values_os</td><td>Arg::required(false)</td><td>要求字段类型为 Vec&lt;T&gt;，T实现std::convert::Into&lt;OsString&gt;</td></tr></tbody></table><h3 id="参数类型">2. 参数类型</h3><h4 id="arguments-options">2.1 Arguments &amp; Options</h4><p>从上面这个输出样例中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">the example of clap derive<br><br>Usage: derive [OPTIONS] &lt;NAME&gt;<br><br>Arguments:<br>  &lt;NAME&gt;  Specify your name<br><br>Options:<br>  -a, --age &lt;AGE&gt;  Specify your age optionally<br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>可以看到跟在命令后面有 2 中参数类型：</p><ul><li><strong>Arguments</strong>: 直接在命令后面指定值，如<code>cmd hedon</code>，有严格的顺序要求。</li><li><strong>Options</strong>: 需要用 <code>-&#123;short&#125;</code> 或<code>--&#123;long&#125;</code> 来指定是哪个参数，无严格的顺序要求。</li></ul><p>它们的定义区别就是是否使用了 <code>#[arg]</code>：</p><ul><li><strong>Options</strong>: 指定了 short 或 long。</li><li><strong>Arguments</strong>: 没有 short 和 long。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>  <span class="hljs-comment">/// 会被解析成 [NAME]</span><br>  name: <span class="hljs-type">String</span>,<br>  <br>  <span class="hljs-comment">/// 会被解析成 -a &lt;AGE&gt;</span><br>  <span class="hljs-meta">#[arg(short, long)]</span><br>  age: <span class="hljs-type">u8</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可选参数">2.2 可选参数</h4><p>可以使用 <code>Option</code> 来实现可选参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    name: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br><br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    age: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u8</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name: &#123;:?&#125;&quot;</span>, cli.name);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;age: &#123;:?&#125;&quot;</span>, cli.age);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build --example optional --release<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/target/release/examples/optional --<span class="hljs-built_in">help</span> <br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">this is the about from Cargo.toml<br><br>Usage: optional [OPTIONS] [NAME]<br><br>Arguments:<br>  [NAME]  <br><br>Options:<br>  -a, --age &lt;AGE&gt;  <br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br>  -V, --version    Print version<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/optional       <br>name: None<br>age: None<br>➜  learn-clap git:(master) ✗ ./target/release/examples/optional -a 1  <br>name: None<br>age: Some(1)<br>➜  learn-clap git:(master) ✗ ./target/release/examples/optional hedon  <br>name: Some(<span class="hljs-string">&quot;hedon&quot;</span>)<br>age: None<br>➜  learn-clap git:(master) ✗ ./target/release/examples/optional hedon -a 18<br>name: Some(<span class="hljs-string">&quot;hedon&quot;</span>)<br>age: Some(18)<br></code></pre></td></tr></table></figure><h4 id="枚举参数">2.3 枚举参数</h4><p>可以使用 <code>enum</code> 搭配 <code>value_enum</code>来实现多选一参数，并限制可选参数的取值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Parser, ValueEnum&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-comment">/// Choose the program mode run in</span><br>    <span class="hljs-meta">#[arg(value_enum)]</span><br>    mode: Mode,<br>&#125;<br><br><span class="hljs-meta">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Mode</span> &#123;<br>    <span class="hljs-comment">/// run in fast mode</span><br>    Fast,<br>    <span class="hljs-comment">/// run in slow mode</span><br>    Slow,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">match</span> cli.mode &#123;<br>        Mode::Fast =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;fast!!!!!&quot;</span>),<br>        Mode::Slow =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;slow......&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: enum &lt;MODE&gt;<br><br>Arguments:<br>  &lt;MODE&gt;<br>          Choose the program mode run <span class="hljs-keyword">in</span><br><br>          Possible values:<br>          - fast: run <span class="hljs-keyword">in</span> fast mode<br>          - slow: run <span class="hljs-keyword">in</span> slow mode<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span><br>          Print <span class="hljs-built_in">help</span> (see a summary with <span class="hljs-string">&#x27;-h&#x27;</span>)<br><br>  -V, --version<br>          Print version<br></code></pre></td></tr></table></figure><h4 id="累计参数">2.4 累计参数</h4><p>累积参数允许用户通过重复指定同一个标志（例如<code>-d</code>）来累加值或效果，通常用于控制命令行应用的详细级别（verbositylevel）或其他需要根据次数变化的行为。</p><p>在很多命令行工具中，累积参数常见于控制日志输出的详细程度。例如，一个<code>-v</code>（verbose）标志可能每被指定一次，就增加一层详细级别。所以，<code>-vvv</code>（等价于<code>-v -v -v</code>） 会比单个 <code>-v</code>提供更多的详细信息。</p><p>在 <code>clap</code> 中可以通过 <code>clap::ArgAction::Count</code>来实现这种累积参数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, action = clap::ArgAction::Count)]</span><br>    verbose: <span class="hljs-type">u8</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;verbose: &#123;&#125;&quot;</span>, cli.verbose);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/accurate --<span class="hljs-built_in">help</span><br>this is the about from Cargo.toml<br><br>Usage: accurate [OPTIONS]<br><br>Options:<br>  -v, --verbose...  <br>  -h, --<span class="hljs-built_in">help</span>        Print <span class="hljs-built_in">help</span><br>  -V, --version     Print version<br>➜  learn-clap git:(master) ✗ ./target/release/examples/accurate -v    <br>verbose: 1<br>➜  learn-clap git:(master) ✗ ./target/release/examples/accurate -vvvv<br>verbose: 4<br></code></pre></td></tr></table></figure><h4 id="变长参数">2.5 变长参数</h4><p>有时候我们希望接收变长参数，比如说：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">del file1 file2 file3<br></code></pre></td></tr></table></figure><p>这个时候可以使用 <code>Vec&lt;&gt;</code> 来实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    files: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;files: &#123;:?&#125;&quot;</span>, cli.files);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/var_length --<span class="hljs-built_in">help</span><br>this is the about from Cargo.toml<br><br>Usage: var_length [FILES]...<br><br>Arguments:<br>  [FILES]...  <br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br>➜  learn-clap git:(master) ✗ ./target/release/examples/var_length       <br>files: []<br>➜  learn-clap git:(master) ✗ ./target/release/examples/var_length file1 <br>files: [<span class="hljs-string">&quot;file1&quot;</span>]<br>➜  learn-clap git:(master) ✗ ./target/release/examples/var_length file1 file2<br>files: [<span class="hljs-string">&quot;file1&quot;</span>, <span class="hljs-string">&quot;file2&quot;</span>]<br>➜  learn-clap git:(master) ✗ ./target/release/examples/var_length file1 file2 file3<br>files: [<span class="hljs-string">&quot;file1&quot;</span>, <span class="hljs-string">&quot;file2&quot;</span>, <span class="hljs-string">&quot;file3&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="标志参数">2.6 标志参数</h4><p>对于标志参数，只要指定类型为<code>bool</code>，就可以自动实现了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    verbose: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;verbose: &#123;&#125;&quot;</span>, cli.verbose);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/flag --<span class="hljs-built_in">help</span><br>Usage: flag [OPTIONS]<br><br>Options:<br>  -v, --verbose  <br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br>➜  learn-clap git:(master) ✗ ./target/release/examples/flag       <br>verbose: <span class="hljs-literal">false</span><br>➜  learn-clap git:(master) ✗ ./target/release/examples/flag -v    <br>verbose: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="子命令">2.7 子命令</h4><p>在更复杂的命令行工具中，除了主命令，还有子命令，甚至子命令下面还有子命令，其实就是一颗命令树。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/hedon954/mapStorage/img/image-20240228183301763.png"alt="command tree" /><figcaption aria-hidden="true">command tree</figcaption></figure><p>在 <code>clap</code> 中可以使用 <code>#[command(subcommand)]</code>搭配 <code>#[derive(Subcommand)]</code> 实现子命令功能。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Parser, Subcommand&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    test: <span class="hljs-type">Option</span>&lt;Test&gt;,<br>&#125;<br><br><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-comment">/// Add a number</span><br>    Add &#123;<br>        <span class="hljs-meta">#[arg(short, long)]</span><br>        num: <span class="hljs-type">u16</span>,<br>    &#125;,<br>    <span class="hljs-comment">/// Sub a number</span><br>    Sub &#123;<br>        <span class="hljs-meta">#[arg(short, long)]</span><br>        num: <span class="hljs-type">u16</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(test) = cli.test &#123;<br>        <span class="hljs-keyword">match</span> test &#123;<br>            Test::Add &#123;num&#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;test add num: &#123;:?&#125;&quot;</span>, num),<br>            Test::Sub &#123;num&#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;test sub num: &#123;:?&#125;&quot;</span>, num),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/subcommand --<span class="hljs-built_in">help</span>      <br>this is the about from Cargo.toml<br><br>Usage: subcommand [COMMAND]<br><br>Commands:<br>  add   Add a number<br>  sub   Sub a number<br>  <span class="hljs-built_in">help</span>  Print this message or the <span class="hljs-built_in">help</span> of the given subcommand(s)<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br>➜  learn-clap git:(master) ✗ ./target/release/examples/subcommand add --<span class="hljs-built_in">help</span><br>Add a number<br><br>Usage: subcommand add --num &lt;NUM&gt;<br><br>Options:<br>  -n, --num &lt;NUM&gt;  <br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br>➜  learn-clap git:(master) ✗ ./target/release/examples/subcommand add -n 1  <br><span class="hljs-built_in">test</span> add num: 1<br>➜  learn-clap git:(master) ✗ ./target/release/examples/subcommand sub -n 2<br><span class="hljs-built_in">test</span> sub num: 2<br></code></pre></td></tr></table></figure><h3 id="参数校验">3. 参数校验</h3><h4 id="类型校验">3.1 类型校验</h4><p>可以发现，使用 Derive模式的时候，我们在参数后面指定参数类型的时候，<code>clap</code>就会对我们输入参数进行类型检查，不匹配的时候会输出丰富的报错信息和指导建议。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">error: invalid value <span class="hljs-string">&#x27;xxxx&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;--num &lt;NUM&gt;&#x27;</span>: invalid digit found <span class="hljs-keyword">in</span> string<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br></code></pre></td></tr></table></figure><p>默认支持：</p><ul><li>原生类型：<code>bool</code>, <code>String</code>,<code>OsString</code>,<code>PathBuf</code>、<code>usize</code>、<code>isize</code></li><li>范围数据：<code>u8</code>, <code>i8</code>, <code>u16</code>,<code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>,<code>i64</code></li><li>实现了 <code>ValueEnum</code> 的 enum 类型</li><li>实现了<code>From&lt;OsString&gt;</code>、<code>From&lt;&amp;OsStr&gt;</code>、<code>FromStr</code> 的类型</li></ul><p>这是因为他们都实现了 <code>TypedValueParser</code>trait，你自定义的类型也可以实现这个triat，这样就可以自动进行类型校验了。</p><p><code>clap</code> 还提供了一些更加严格的参数校验功能。👇🏻</p><h4 id="枚举校验">3.2 枚举校验</h4><p>对于实现 <code>ValueEnum</code>的枚举类型，如果输入的值不是枚举中定义的，则 <code>clap</code>会报错并提示可选值。</p><p>我们复用上面介绍「多选一参数」的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Parser, ValueEnum&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-comment">/// Choose the program mode run in</span><br>    <span class="hljs-meta">#[arg(value_enum)]</span><br>    mode: Mode,<br>&#125;<br><br><span class="hljs-meta">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Mode</span> &#123;<br>    <span class="hljs-comment">/// run in fast mode</span><br>    Fast,<br>    <span class="hljs-comment">/// run in slow mode</span><br>    Slow,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">match</span> cli.mode &#123;<br>        Mode::Fast =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;fast!!!!!&quot;</span>),<br>        Mode::Slow =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;slow......&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用错误的值进行尝试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/enum xxxx               <br>error: invalid value <span class="hljs-string">&#x27;xxxx&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;&lt;MODE&gt;&#x27;</span><br>  [possible values: fast, slow]<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br></code></pre></td></tr></table></figure><h4 id="范围校验">3.3 范围校验</h4><p>如果你想要实现数字类型范围限制的话，比如端口号参数的范围应该是 [1,65535]，那可以使用<code>value_parser! = clap::value_parser!(u16).range(1..)</code>来实现这个功能：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, value_parser = clap::value_parser!(u16).range(1..))]</span><br>    port: <span class="hljs-type">u16</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;port: &#123;:?&#125;&quot;</span>, cli.port);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/range --<span class="hljs-built_in">help</span>             <br>this is the about from Cargo.toml<br><br>Usage: range --port &lt;PORT&gt;<br><br>Options:<br>  -p, --port &lt;PORT&gt;  <br>  -h, --<span class="hljs-built_in">help</span>         Print <span class="hljs-built_in">help</span><br>  -V, --version      Print version<br>  <br>➜  learn-clap git:(master) ✗ ./target/release/examples/range -p 0  <br>error: invalid value <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;--port &lt;PORT&gt;&#x27;</span>: 0 is not <span class="hljs-keyword">in</span> 1..=65535<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/range -p 11111111<br>error: invalid value <span class="hljs-string">&#x27;11111111&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;--port &lt;PORT&gt;&#x27;</span>: 11111111 is not <span class="hljs-keyword">in</span> 1..=65535<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/range -p 1111    <br>port: 1111<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>value_parser = clap::value_parser!(u16).range(1..)</code>的含义可以分为两部分解释：</p><p><strong>1. clap::value_parser!(u16)</strong></p><p>这部分使用 <code>value_parser!</code> 宏为命令行参数指定了<code>u16</code> 类型的解析器。这意味着输入的参数值会被尝试解析为无符号16 位整数（<code>u16</code>）。如果输入不能被成功解析为 <code>u16</code>类型（例如，输入是非数字字符串或者数字过大/过小而不符合 <code>u16</code>的范围），<code>clap</code> 会报错并提示用户输入有效的参数值。</p><p><strong>2. .range(1..)</strong></p><p>这部分进一步限制了参数值的有效范围。<code>.range(1..)</code>指定了参数值必须大于或等于 1（包含 1），但没有上限。换句话说，任何小于 1的值都将被认为是无效的，<code>clap</code>会因此报错并要求用户输入一个符合范围要求的值。这在需要限定参数值为正数时非常有用。</p><p>结合起来，<code>value_parser = clap::value_parser!(u16).range(1..)</code>创建了一个规则，要求命令行参数必须是一个大于或等于 1 的 <code>u16</code>类型的数值。这在很多场景下都非常有用，比如当你需要用户指定一个正数端口号时。</p><p>在 RustRover 中，你可以在 Builder 模式，通过在<code>clap::value_parser!()</code> 中指定其他的类型，然后输入<code>.</code> 获得其他类型的内置校验规则。</p><h4 id="自定义校验">3.4 自定义校验</h4><p>对于更复杂的规则，<code>clap</code> 还支持自定义校验规则。比如上面对port 的校验，也可以自己实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::RangeInclusive;<br><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, value_parser = parse_port)]</span><br>    port: <span class="hljs-type">u16</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> PORT_RANGE: RangeInclusive&lt;<span class="hljs-type">usize</span>&gt; = <span class="hljs-number">1</span>..=<span class="hljs-number">65535</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_port</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u16</span>, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">port</span>: <span class="hljs-type">usize</span> = s<br>        .<span class="hljs-title function_ invoke__">parse</span>()<br>        .<span class="hljs-title function_ invoke__">map_err</span>(|_| <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;`&#123;s&#125;` isn&#x27;t a port number`&quot;</span>))?;<br><br>    <span class="hljs-keyword">if</span> PORT_RANGE.<span class="hljs-title function_ invoke__">contains</span>(&amp;port) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(port <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-built_in">format!</span>(<br>            <span class="hljs-string">&quot;port not in range &#123;&#125;-&#123;&#125;&quot;</span>,<br>            PORT_RANGE.<span class="hljs-title function_ invoke__">start</span>(),<br>            PORT_RANGE.<span class="hljs-title function_ invoke__">end</span>(),<br>        ))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;port: &#123;:?&#125;&quot;</span>, cli.port);<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码中，我们直接使用 <code>value_parser = parse_port</code>来指定自定义的校验规则。</p><p>我们自定义的校验规则为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_port</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u16</span>, <span class="hljs-type">String</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>它需要满足：</p><ul><li>入参是 &amp;str</li><li>出参是 Result&lt;参数类型, String&gt;</li></ul><p>可以测试输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/custom --<span class="hljs-built_in">help</span><br>this is the about from Cargo.toml<br><br>Usage: custom --port &lt;PORT&gt;<br><br>Options:<br>  -p, --port &lt;PORT&gt;  <br>  -h, --<span class="hljs-built_in">help</span>         Print <span class="hljs-built_in">help</span><br>  -V, --version      Print version<br>  <br>➜  learn-clap git:(master) ✗ ./target/release/examples/custom -p xxx<br>error: invalid value <span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;--port &lt;PORT&gt;&#x27;</span>: `xxx` isn<span class="hljs-string">&#x27;t a port number`</span><br><span class="hljs-string"></span><br><span class="hljs-string">For more information, try &#x27;</span>--<span class="hljs-built_in">help</span><span class="hljs-string">&#x27;.</span><br><span class="hljs-string"></span><br><span class="hljs-string">➜  learn-clap git:(master) ✗ ./target/release/examples/custom -p 0  </span><br><span class="hljs-string">error: invalid value &#x27;</span>0<span class="hljs-string">&#x27; for &#x27;</span>--port &lt;PORT&gt;<span class="hljs-string">&#x27;: port not in range 1-65535</span><br><span class="hljs-string"></span><br><span class="hljs-string">For more information, try &#x27;</span>--<span class="hljs-built_in">help</span><span class="hljs-string">&#x27;.</span><br><span class="hljs-string"></span><br><span class="hljs-string">➜  learn-clap git:(master) ✗ ./target/release/examples/custom -p 9527</span><br><span class="hljs-string">port: 9527</span><br></code></pre></td></tr></table></figure><h4 id="关联参数">3.5 关联参数</h4><p>有时候参数直接还有关联关系，比如说：</p><ul><li>依赖：必须存在 <code>-a</code> 参数，<code>-b</code>参数才有意义，即要使用 <code>-b</code> 参数时，必须指定 <code>-a</code>参数。</li><li>互斥：<code>-a</code> 和 <code>-b</code> 只能同时存在一个。</li></ul><p><strong>可以使用 requires 实现依赖关系：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    a: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br><br>    <span class="hljs-meta">#[arg(short, long,requires = <span class="hljs-string">&quot;a&quot;</span>)]</span><br>    b: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a: &#123;:?&#125;&quot;</span>, cli.a);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;b: &#123;:?&#125;&quot;</span>, cli.b);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们在参数 <code>b</code> 中加入了<code>requires = "a"</code>，表示要使用 <code>b</code> 参数必须要有<code>a</code> 参数。</p><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/relation      <br>a: None<br>b: None<br>➜  learn-clap git:(master) ✗ ./target/release/examples/relation -b 1 <br>error: the following required arguments were not provided:<br>  --a &lt;A&gt;<br><br>Usage: relation --a &lt;A&gt; --b &lt;B&gt;<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/relation -a 1<br>a: Some(<span class="hljs-string">&quot;1&quot;</span>)<br>b: None<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/relation -a 1 -b 2<br>a: Some(<span class="hljs-string">&quot;1&quot;</span>)<br>b: Some(<span class="hljs-string">&quot;2&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>可以使用 #[group(required = true, mutiple = false)]来实现互斥关系：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Args, Parser&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[command(flatten)]</span><br>    args: Only,<br>&#125;<br><br><span class="hljs-meta">#[derive(Args, Debug)]</span><br><span class="hljs-meta">#[group(required = true, multiple = false)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Only</span> &#123;<br>    <span class="hljs-meta">#[arg(long)]</span><br>    a: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>    <span class="hljs-meta">#[arg(long)]</span><br>    b: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>    <span class="hljs-meta">#[arg(long)]</span><br>    c: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>    <span class="hljs-meta">#[arg(long)]</span><br>    d: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;only: &#123;:?&#125;&quot;</span>, cli.args)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[command(flattern)]</code> 直接将结构体里面的参数平铺。</p><p><code>#[group]</code>用于将一组参数归为一个组，<code>required = true</code> 表示必须提供该group 中的参数，<code>multiple = false</code>表示只能有一个参数被提供。</p><p>测试输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/only_one --<span class="hljs-built_in">help</span><br>this is the about from Cargo.toml<br><br>Usage: only_one &lt;--a &lt;A&gt;|--b &lt;B&gt;|--c &lt;C&gt;|--d &lt;D&gt;&gt;<br><br>Options:<br>      --a &lt;A&gt;    <br>      --b &lt;B&gt;    <br>      --c &lt;C&gt;    <br>      --d &lt;D&gt;    <br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br>  <br>➜  learn-clap git:(master) ✗ ./target/release/examples/only_one       <br>error: the following required arguments were not provided:<br>  &lt;--a &lt;A&gt;|--b &lt;B&gt;|--c &lt;C&gt;|--d &lt;D&gt;&gt;<br><br>Usage: only_one &lt;--a &lt;A&gt;|--b &lt;B&gt;|--c &lt;C&gt;|--d &lt;D&gt;&gt;<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/only_one --a 1      <br>only: Only &#123; a: Some(<span class="hljs-string">&quot;1&quot;</span>), b: None, c: None, d: None &#125;<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/only_one --a 1 --b 2<br>error: the argument <span class="hljs-string">&#x27;--a &lt;A&gt;&#x27;</span> cannot be used with <span class="hljs-string">&#x27;--b &lt;B&gt;&#x27;</span><br><br>Usage: only_one &lt;--a &lt;A&gt;|--b &lt;B&gt;|--c &lt;C&gt;|--d &lt;D&gt;&gt;<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/only_one --b 2      <br>only: Only &#123; a: None, b: Some(<span class="hljs-string">&quot;2&quot;</span>), c: None, d: None &#125;<br></code></pre></td></tr></table></figure><h2 id="builder">Builder</h2><p>使用 <code>clap</code> 的 Builder模式，一般情况下不需要额外引入其他的 features：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add clap<br></code></pre></td></tr></table></figure><p>但是如果要使用 <code>command!</code> 来构建应用的话，需要引入<code>cargo</code> 这个 features：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add clap --features cargo<br></code></pre></td></tr></table></figure><h3 id="应用配置-1">1. 应用配置</h3><p>在 Builder 模式下，你可以使用 <code>command!()</code> 或<code>Command::new("appname")</code> 来构建一个命令行应用，其中<code>command!()</code> 默认将 appname 设置应用名称，而<code>Command::new()</code> 必须显示指定 appname。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, Arg, Command, command, value_parser&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// let matches = command!()</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;MyApp&quot;</span>)<br>        <span class="hljs-comment">// Application configuration</span><br>        .<span class="hljs-title function_ invoke__">version</span>(<span class="hljs-string">&quot;1.0.0&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">author</span>(<span class="hljs-string">&quot;hedon&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;This the intro of the cli application&quot;</span>)<br>        <span class="hljs-comment">// Application args</span><br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!([NAME]).<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your name&quot;</span>))<br>        .<span class="hljs-title function_ invoke__">arg</span>(<br>            Arg::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-title function_ invoke__">short</span>(<span class="hljs-string">&#x27;a&#x27;</span>).<span class="hljs-title function_ invoke__">long</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">u8</span>))<br>        )<br>    .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-comment">// Read and parse command args</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(name) = matches.get_one::&lt;<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;NAME&quot;</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value for name: &#123;name&#125;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(age) = matches.get_one::&lt;<span class="hljs-type">u8</span>&gt;(<span class="hljs-string">&quot;age&quot;</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value for age: &#123;age&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码分为以下几个部分：</p><p><strong>1. 创建命令行应用实例</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;MyApp&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里使用 <code>Command::new</code>方法创建了一个新的命令行应用实例，命名为 <code>"MyApp"</code>。</p><p><strong>2. 配置应用</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">version</span>(<span class="hljs-string">&quot;1.0.0&quot;</span>)<br>.<span class="hljs-title function_ invoke__">author</span>(<span class="hljs-string">&quot;hedon&quot;</span>)<br>.<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;This the intro of the cli application&quot;</span>)<br></code></pre></td></tr></table></figure><p>接下来，使用链式调用方法配置应用的版本号为<code>"1.0.0"</code>，作者为<code>"hedon"</code>，并添加了一个简短的描述。</p><p>这里等价于 Builder 模式下的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[command(version, author, about)]</span><br></code></pre></td></tr></table></figure><p><strong>3. 添加命令行参数</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!([NAME]).<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your name&quot;</span>))<br>.<span class="hljs-title function_ invoke__">arg</span>(<br>    Arg::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-title function_ invoke__">short</span>(<span class="hljs-string">&#x27;a&#x27;</span>).<span class="hljs-title function_ invoke__">long</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">u8</span>))<br>)<br></code></pre></td></tr></table></figure><p>这部分代码添加了两个命令行参数： -<code>.arg(arg!([NAME]).required(true).help("Specify your name"))</code>使用 <code>arg!</code> 宏添加了一个名为 <code>NAME</code>的必需参数，并提供了一些帮助信息。 -<code>.arg(Arg::new("age").short('a').long("age").value_parser(value_parser!(u8)))</code>创建了另一个参数 <code>age</code>，可以通过 <code>-a</code> 或<code>--age</code> 来指定。这个参数使用了 <code>value_parser</code>宏来指明它的值应被解析为 <code>u8</code> 类型的数字。</p><p><strong>4. 解析命令行参数</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">get_matches</span>();<br></code></pre></td></tr></table></figure><p>使用 <code>.get_matches()</code> 方法来解析命令行参数并将结果存储在<code>matches</code> 变量中。</p><p><strong>5. 读取并打印参数值</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(name) = matches.get_one::&lt;<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;NAME&quot;</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value for name: &#123;name&#125;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(age) = matches.get_one::&lt;<span class="hljs-type">u8</span>&gt;(<span class="hljs-string">&quot;age&quot;</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value for age: &#123;age&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，使用 <code>matches.get_one::&lt;T&gt;("arg_name")</code>方法尝试获取指定名称的参数值。如果成功找到，则将其打印出来。这里分别尝试获取<code>"NAME"</code> 和 <code>"age"</code> 参数的值，并使用<code>println!</code> 宏将它们打印到控制台。</p><p>使用 <code>-- help</code> 测试输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">This the intro of the cli application<br><br>Usage: app2 [OPTIONS] [NAME]<br><br>Arguments:<br>  [NAME]  Specify your name<br><br>Options:<br>  -a, --age &lt;AGE&gt;  <br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br>  -V, --version    Print version<br></code></pre></td></tr></table></figure><p>你可以将其与「Derive -应用配置」进行比较，应该很容易找到它们之间的对应关系。</p><p>在 Derive 中 <code>#[command]</code> 和 <code>#[arg]</code>支持的属性，都可以在 Builder中找到对应的同名的函数，这里就不赘述了。</p><h3 id="参数类型-1">2. 参数类型</h3><p>在 Builder 模式中，配置参数有两种方式：</p><ul><li>arg!([-short] [--long] id)</li><li>Args::new("id").short('s').long("long")</li></ul><h4 id="arguments-options-1">2.1 Arguments &amp; Options</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Arguments:<br>  [NAME]  Specify your name<br><br>Options:<br>  -a, --age &lt;AGE&gt;  <br></code></pre></td></tr></table></figure><ul><li><strong>Argument:</strong> 不包含 <code>-&#123;short&#125;</code> 和<code>--&#123;long&#125;</code>。</li><li><strong>Options:</strong> 包含 <code>-&#123;short&#125;</code> 或<code>--&#123;long&#125;</code>。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!([NAME]).<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your name&quot;</span>))<br>.<span class="hljs-title function_ invoke__">arg</span>(arg!(-a --age &lt;AGE&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">u16</span>)))<br></code></pre></td></tr></table></figure><h4 id="可选参数-1">2.2 可选参数</h4><p>根据约定，<code>&lt;&gt;</code> 表示必须，而 <code>[]</code>表示可选：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;NAME&gt;)   <span class="hljs-comment">// 必须</span><br>.<span class="hljs-title function_ invoke__">arg</span>(arg!([ADDRESS]))  <span class="hljs-comment">// 可选</span><br></code></pre></td></tr></table></figure><p>你也可以使用 <code>.required(bool)</code> 函数明确指出是否必须：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;NAME&gt;).<span class="hljs-title function_ invoke__">required</span>(<span class="hljs-literal">true</span>))<br></code></pre></td></tr></table></figure><p><code>.required()</code> 的优先级高于 <code>&lt;&gt;</code> 和<code>[]</code>，但是建议你在构建的时候还是遵循约定。</p><h4 id="枚举参数-1">2.3 枚举参数</h4><p><strong>第 1 种：在 value_parser()中直接指定可选的枚举参数</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;MODE&gt;).<span class="hljs-title function_ invoke__">value_parser</span>([<span class="hljs-string">&quot;fast, slow&quot;</span>]))<br></code></pre></td></tr></table></figure><p><strong>第 2 种：使用枚举，但是枚举需要实现 ValueEnumtrait</strong></p><p>这里又有 2 种方式，你可以向 Derive 一样引入 <code>derive</code>features，然后直接 <code>#[derive(ValueElem)]</code>使用默认实现，也可以手动实现。我更倾向于前者。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, command, value_parser, ValueEnum&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = command!()<br>        <span class="hljs-comment">// .arg(arg!(&lt;MODE&gt;).value_parser([&quot;fast, slow&quot;]))</span><br>        .<span class="hljs-title function_ invoke__">arg</span>(<br>            arg!(&lt;MODE&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(Mode)).<span class="hljs-title function_ invoke__">required</span>(<span class="hljs-literal">true</span>)<br>        )<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-keyword">match</span> matches.get_one::&lt;Mode&gt;(<span class="hljs-string">&quot;MODE&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;&#x27;Mode&#x27; is required and parsing will fail if its missing&quot;</span>)&#123;<br>        Mode::Fast =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;fast&quot;</span>),<br>        Mode::Slow =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;slow&quot;</span>),<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, ValueEnum)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Mode</span> &#123;<br>    <span class="hljs-comment">/// Run in fast mode</span><br>    Fast,<br>    <span class="hljs-comment">/// Run in slow mode</span><br>    Slow,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="累计参数-1">2.4 累计参数</h4><p>使用 <code>clap::ArgAction::Count</code> 设置参数为累计参数，然后使用<code>get_count(id)</code> 获取参数的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, command&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = command!()<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(-v --verbose...).<span class="hljs-title function_ invoke__">action</span>(clap::ArgAction::Count))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;v count: &#123;:?&#125;&quot;</span>, matches.<span class="hljs-title function_ invoke__">get_count</span>(<span class="hljs-string">&quot;verbose&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，<code>arg!()</code> 中参数的定义，也要符合累计参数的格式<code>-&#123;short&#125; --&#123;long&#125;...</code>。</p><h4 id="变长参数-1">2.5 变长参数</h4><p>使用 <code>clap::ArgAction::Append</code>设置参数为变长参数，然后使用 <code>get_many::&lt;类型&gt;("id")</code>获取参数的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, Command&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;append-application&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!([FILES]...).<span class="hljs-title function_ invoke__">action</span>(clap::ArgAction::Append))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">files</span> = matches<br>        .get_many::&lt;<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;FILES&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">unwrap_or_default</span>()<br>        .<span class="hljs-title function_ invoke__">map</span>(|v|v.<span class="hljs-title function_ invoke__">as_str</span>())<br>        .collect::&lt;<span class="hljs-type">Vec</span>&lt;_&gt;&gt;();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;files: &#123;:?&#125;&quot;</span>, files);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，<code>arg!()</code> 中参数的定义，也要符合变长参数的格式<code>[arg]|&lt;arg&gt;...</code>。</p><h4 id="标志参数-1">2.6 标志参数</h4><p>使用 <code>clap::ArgAction::SetTrue</code> 或<code>clap::ArgAction::SetFalse</code> 设置参数为标志参数，然后使用<code>get_flag()</code> 获取参数的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, command&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = command!()<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(-d --debug).<span class="hljs-title function_ invoke__">action</span>(clap::ArgAction::SetTrue))<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(-v --verbose).<span class="hljs-title function_ invoke__">action</span>(clap::ArgAction::SetFalse))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;debug: &#123;:?&#125;&quot;</span>, matches.<span class="hljs-title function_ invoke__">get_flag</span>(<span class="hljs-string">&quot;debug&quot;</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;verbose: &#123;:?&#125;&quot;</span>, matches.<span class="hljs-title function_ invoke__">get_flag</span>(<span class="hljs-string">&quot;verbose&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>clap::ArgAction::SetTrue</code> : 设置参数的话，则为true，否则 false（默认）。</li><li><code>clap::ArgAction::SetFalse</code> : 设置参数的话，则为false，否则 true（默认）。</li></ul><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap-builder git:(master) ✗ ./target/release/examples/flag      <br>debug: <span class="hljs-literal">false</span><br>verbose: <span class="hljs-literal">true</span><br>➜  learn-clap-builder git:(master) ✗ ./target/release/examples/flag -d   <br>debug: <span class="hljs-literal">true</span><br>verbose: <span class="hljs-literal">true</span><br>➜  learn-clap-builder git:(master) ✗ ./target/release/examples/flag -v   <br>debug: <span class="hljs-literal">false</span><br>verbose: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h4 id="子命令-1">2.7 子命令</h4><p>可以使用 <code>subcommand(sub_cmd)</code> 和<code>subcommand([sub_cmd1, sub_cmd2])</code>来添加子命令，解析的时候使用 <code>matches.subcommand()</code>匹配子命令，再按照之前的规则解析子命令中对应的参数即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, Command, value_parser&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;myapp&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">subcommands</span>([<br>            Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;add&quot;</span>)<br>                .<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;NUM&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">i16</span>))),<br>            Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;sub&quot;</span>)<br>                .<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;NUM&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">i16</span>))),<br>        ])<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-keyword">match</span> matches.<span class="hljs-title function_ invoke__">subcommand</span>() &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-string">&quot;add&quot;</span>, add_cmd)) =&gt; <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;&#x27;myapp add&#x27; was used, num is: &#123;:?&#125;&quot;</span>,<br>            add_cmd.get_one::&lt;<span class="hljs-type">i16</span>&gt;(<span class="hljs-string">&quot;NUM&quot;</span>),<br>        ),<br>        <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-string">&quot;sub&quot;</span>, sub_cmd)) =&gt; <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;&#x27;myapp sub&#x27; was used, num is: &#123;:?&#125;&quot;</span>,<br>            sub_cmd.get_one::&lt;<span class="hljs-type">i16</span>&gt;(<span class="hljs-string">&quot;NUM&quot;</span>),<br>        ),<br>        _ =&gt; <span class="hljs-built_in">unreachable!</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参数校验-1">3. 参数校验</h3><h4 id="类型校验-1">3.1 类型校验</h4><p>使用 <code>value_parser!()</code> 在括号中指定类型，<code>clap</code>就会自动帮我们对参数进行类型校验，当然你在获取参数值<code>get_one::&lt;类型&gt;()</code> 的时候，类型要对上，否则会panic。</p><p>默认支持：</p><ul><li>原生类型：<code>bool</code>, <code>String</code>,<code>OsString</code>,<code>PathBuf</code>、<code>usize</code>、<code>isize</code></li><li>范围数据：<code>u8</code>, <code>i8</code>, <code>u16</code>,<code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>,<code>i64</code></li><li>实现了 <code>ValueEnum</code> 的 enum 类型</li><li>实现了<code>From&lt;OsString&gt;</code>、<code>From&lt;&amp;OsStr&gt;</code>、<code>FromStr</code> 的类型</li></ul><h4 id="枚举校验-1">3.2 枚举校验</h4><p>2.3 中枚举参数的说明中，已经体现了枚举校验的功能了，这里不赘述。</p><h4 id="范围校验-1">3.3 范围校验</h4><p>对于上述提到的「范围数据」，可以使用<code>value_parser!(类型).range()</code> 进行范围校验。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">arg!(&lt;PORT&gt;)<br>  .<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">u16</span>).<span class="hljs-title function_ invoke__">range</span>(<span class="hljs-number">1</span>..))<br></code></pre></td></tr></table></figure><h4 id="自定义校验-1">3.4 自定义校验</h4><p><code>value_parser()</code>中也可以传自定义的校验函数，该函数的签名需要满足的条件跟我们在介绍Derive 时一样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::RangeInclusive;<br><span class="hljs-keyword">use</span> clap::&#123;arg, command&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = command!()<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;PORT&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(port_in_range))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;port: &#123;:?&#125;&quot;</span>, matches.get_one::&lt;<span class="hljs-type">u16</span>&gt;(<span class="hljs-string">&quot;PORT&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">const</span> PORT_RANGE: RangeInclusive&lt;<span class="hljs-type">usize</span>&gt; = RangeInclusive::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>, <span class="hljs-number">65535</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">port_in_range</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u16</span>, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">port</span>: <span class="hljs-type">usize</span> = s<br>        .<span class="hljs-title function_ invoke__">parse</span>()<br>        .<span class="hljs-title function_ invoke__">map_err</span>(|_|<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;`&#123;s&#125;` is not a port number&quot;</span>))?;<br>    <span class="hljs-keyword">if</span> PORT_RANGE.<span class="hljs-title function_ invoke__">contains</span>(&amp;port) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(port <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-built_in">format!</span>(<br>            <span class="hljs-string">&quot;port not in range &#123;&#125;-&#123;&#125;&quot;</span>,<br>            PORT_RANGE.<span class="hljs-title function_ invoke__">start</span>(),<br>            PORT_RANGE.<span class="hljs-title function_ invoke__">end</span>(),<br>        ))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关联参数-1">3.5 关联参数</h4><ul><li><strong>依赖关系：</strong>使用<code>requires(id | group)</code></li><li><strong>排斥关系</strong>：使用<code>group().multiple(false).required(true)</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">group</span>(<br>    ArgGroup::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;vers&quot;</span>)<br>  <span class="hljs-comment">// 表示 &quot;set-ver&quot;, &quot;major&quot;, &quot;minor&quot;, &quot;patch&quot; 必须有一个且只能有一个存在</span><br>        .<span class="hljs-title function_ invoke__">multiple</span>(<span class="hljs-literal">false</span>)<br>        .<span class="hljs-title function_ invoke__">required</span>(<span class="hljs-literal">true</span>)<br>        .<span class="hljs-title function_ invoke__">args</span>([<span class="hljs-string">&quot;set-ver&quot;</span>, <span class="hljs-string">&quot;major&quot;</span>, <span class="hljs-string">&quot;minor&quot;</span>, <span class="hljs-string">&quot;patch&quot;</span>]),<br>)<br>.<span class="hljs-title function_ invoke__">arg</span>(<br>    arg!([INPUT_FILE] <span class="hljs-string">&quot;some regular input&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(PathBuf))<br>        .<span class="hljs-title function_ invoke__">group</span>(<span class="hljs-string">&quot;input&quot;</span>),<br>)<br>.<span class="hljs-title function_ invoke__">arg</span>(<br>    arg!(config: -c &lt;CONFIG&gt;)<br>        .<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(PathBuf))<br>   <span class="hljs-comment">// 表示 -c 需要有 group 为 input 的命令存在才可以使用</span><br>        .<span class="hljs-title function_ invoke__">requires</span>(<span class="hljs-string">&quot;input&quot;</span>),<br>)<br></code></pre></td></tr></table></figure><h2 id="derive-vs-builder-2-对比">Derive vs Builder (2) 对比</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/screencapture-wepie-feishu-cn-wiki-Bdb3wl4cViE6hqkUuykctkrqn8i-2024-03-01-20_52_38.png"alt="Derive vs Builder" /><figcaption aria-hidden="true">Derive vs Builder</figcaption></figure><h2 id="clap-rpassword-实现加密输入">clap + rpassword 实现加密输入</h2><p>对于密码、密钥等关键信息的输入，为了信息安全，我们一般会使用加密输出，<code>clap</code>本身不支持加密输入功能。若你有这方面的需求，可以使用<code>rpassword</code> crate 辅助完成。</p><p>示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><span class="hljs-keyword">use</span> rpassword::read_password;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    username: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-meta">#[arg(short, long, required = true)]</span><br>    password: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">password</span> = <span class="hljs-keyword">if</span> cli.password &#123;<br>        <span class="hljs-comment">// Prompt user to enter password</span><br>        <span class="hljs-title function_ invoke__">read_password</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to read password&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-string">&quot;&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()<br>    &#125;;<br><br>    <span class="hljs-comment">// Use username and password to do something</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;username: &#123;&#125;, password: &#123;&#125;&quot;</span>, cli.username, password);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="clap_complete-实现自动补全">clap_complete 实现自动补全</h2><p>要实现自动补全，需要在 <code>.zshrc</code> 或 <code>.bashrc</code> 等<code>SHELL</code> 文件中加入命令自动补全脚本。这时候可以使用<code>clap_complete</code> 来实现这个功能。</p><p>下面的示例目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── Cargo.lock<br>├── Cargo.toml<br>├── build.rs<br>└── src<br>    ├── cli.rs<br>    └── main.rs<br></code></pre></td></tr></table></figure><p>首先我们需要引入 <code>clap</code> 和 <code>clap_complete</code>crate，其中 <code>clap_complete</code> 只需在 build环境下即可，所以我们的 <code>Cargo.tmol</code> 如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;myapp&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-attr">build</span> = <span class="hljs-string">&quot;build.rs&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.1&quot;</span> &#125;<br><span class="hljs-attr">dirs</span> = <span class="hljs-string">&quot;5.0.1&quot;</span><br><br><span class="hljs-section">[build-dependencies]</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.1&quot;</span>&#125;<br><span class="hljs-attr">clap_complete</span> = <span class="hljs-string">&quot;4.5.1&quot;</span><br></code></pre></td></tr></table></figure><p>我们先在 <code>src/cli.rs</code> 中实现一个简单的命令行程序<strong>myapp</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Arg, ArgAction, Command&#125;;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_cli</span>() <span class="hljs-punctuation">-&gt;</span> Command &#123;<br>    Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;myapp&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;Tests completions&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">arg</span>(Arg::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;file&quot;</span>)<br>            .<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;some input file&quot;</span>))<br>        .<span class="hljs-title function_ invoke__">subcommand</span>(Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;test&quot;</span>)<br>            .<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;tests things&quot;</span>)<br>            .<span class="hljs-title function_ invoke__">arg</span>(Arg::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;case&quot;</span>)<br>                .<span class="hljs-title function_ invoke__">long</span>(<span class="hljs-string">&quot;case&quot;</span>)<br>                .<span class="hljs-title function_ invoke__">action</span>(ArgAction::Set)<br>                .<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;the case to test&quot;</span>)))<br>&#125;<br></code></pre></td></tr></table></figure><p>我们主要是演示这个自动补全功能，为了省事，<code>src/main.rs</code>中就不实现具体逻辑了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> cli;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_m</span> = cli::<span class="hljs-title function_ invoke__">build_cli</span>().<span class="hljs-title function_ invoke__">get_matches</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们在项目根目录下实现<code>build.rs</code>，它将为我们指定的命令生成自动补全脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> build.rs<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap_complete::&#123;generate_to, shells::Bash&#125;;<br><span class="hljs-keyword">use</span> std::env;<br><span class="hljs-keyword">use</span> std::io::Error;<br><br>include!(<span class="hljs-string">&quot;src/cli.rs&quot;</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">outdir</span> = <span class="hljs-keyword">match</span> env::<span class="hljs-title function_ invoke__">var_os</span>(<span class="hljs-string">&quot;OUT_DIR&quot;</span>) &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(()),<br>        <span class="hljs-title function_ invoke__">Some</span>(outdir) =&gt; outdir,<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cmd</span> = <span class="hljs-title function_ invoke__">build_cli</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = <span class="hljs-title function_ invoke__">generate_to</span>(<br>        Bash,<br>        &amp;<span class="hljs-keyword">mut</span> cmd, <span class="hljs-comment">// We need to specify what generator to use</span><br>        <span class="hljs-string">&quot;myapp&quot;</span>,  <span class="hljs-comment">// We need to specify the bin name manually</span><br>        outdir,   <span class="hljs-comment">// We need to specify where to write to</span><br>    )?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;cargo:warning=completion file is generated: &#123;path:?&#125;&quot;</span>);<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>你需要把其中的 <strong>myapp</strong> 替换为你的命令。</p><p>执行构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build<br></code></pre></td></tr></table></figure><p>可以看到输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">warning: myapp@0.1.0: completion file is generated: <span class="hljs-string">&quot;/Users/hedon/RustroverProjects/learn-clap-complete/target/debug/build/myapp-42e401d08c044ca3/out/myapp.bash&quot;</span><br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 1.90s<br></code></pre></td></tr></table></figure><p>这里会输出生成脚本所在的位置，我这里是<code>/Users/hedon/RustroverProjects/learn-clap-complete/target/debug/build/myapp-42e401d08c044ca3/out/myapp.bash</code>。</p><p>我的终端使用的是 zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span>      <br>/bin/zsh<br></code></pre></td></tr></table></figure><p>所以我需要将这个文件的内容加到 <code>~/.zshrc</code> 文件的末尾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /Users/hedon/RustroverProjects/learn-clap-complete/target/debug/build/myapp-42e401d08c044ca3/out/myapp.bash &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure><p>重新加载配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><p>这个时候你使用 <strong>myapp</strong> 命令的时候，按 <code>tap</code>键，就有自动补全了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ./target/debug/myapp <br>--<span class="hljs-built_in">help</span>    -h        \[file\]  <span class="hljs-built_in">help</span>      <span class="hljs-built_in">test</span> <br></code></pre></td></tr></table></figure><h1 id="httpie">HTTPie</h1><p>由于篇幅原因，实战 HTTPie 部分请看：<ahref="https://hedon.top/2024/03/06/rust-action-httpie/">Rust实战丨HTTPie</a></p><h1 id="与-go-语言-cobra-比较">与 Go 语言 cobra 比较</h1><p>Go 的 <code>cobra</code> 也是用于构建命令行应用程序的库，它在 Go语言生态中非常受欢迎。</p><p>为了直观展示这 2个库构建命令行应用程序的区别，我们来设计一个简单的命令行程序，用<code>clap</code> 和 <code>cobra</code>分别实现，以展示如何用这两个库实现相同的功能。</p><p>让我们创建一个 CLI 程序，它有一个 <code>greet</code> 子命令，接受一个<code>-n</code> 或 <code>--name</code> 参数，并打印出一条欢迎信息。</p><h2 id="rust-clap-实现">Rust clap 实现</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123; Parser, Subcommand&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(bin_name = <span class="hljs-string">&quot;greet_app&quot;</span>)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    sub: <span class="hljs-type">Option</span>&lt;Sub&gt;,<br>&#125;<br><br><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Sub</span> &#123;<br>    Greet &#123;<br>        <span class="hljs-meta">#[arg(short, long)]</span><br>        name: <span class="hljs-type">String</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(sub) = cli.sub &#123;<br>        <span class="hljs-keyword">match</span> sub &#123;<br>            Sub::Greet&#123;name&#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;greeting: &#123;:?&#125;&quot;</span>, name),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="go-cobra-实现">Go cobra 实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><br><span class="hljs-string">&quot;github.com/spf13/cobra&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> rootCmd = &amp;cobra.Command&#123;<br>Use:   <span class="hljs-string">&quot;greet_app&quot;</span>,<br>Short: <span class="hljs-string">&quot;A simple greeting application&quot;</span>,<br>Long:  <span class="hljs-string">`This is a simple greeting application with a greet command.`</span>,<br>&#125;<br><br><span class="hljs-keyword">var</span> greetCmd = &amp;cobra.Command&#123;<br>Use:   <span class="hljs-string">&quot;greet&quot;</span>,<br>Short: <span class="hljs-string">&quot;Greets a user&quot;</span>,<br>Long:  <span class="hljs-string">`Prints a greeting message for the specified user.`</span>,<br>Run: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cmd *cobra.Command, args []<span class="hljs-type">string</span>)</span></span> &#123;<br>name, _ := cmd.Flags().GetString(<span class="hljs-string">&quot;name&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, name)<br>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>rootCmd.AddCommand(greetCmd)<br>greetCmd.Flags().StringP(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;Sets the name to greet&quot;</span>)<br>greetCmd.MarkFlagRequired(<span class="hljs-string">&quot;name&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := rootCmd.Execute(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">This is a simple greeting application with a greet <span class="hljs-built_in">command</span>.<br><br>Usage:<br>  greet_app [<span class="hljs-built_in">command</span>]<br><br>Available Commands:<br>  completion  Generate the autocompletion script <span class="hljs-keyword">for</span> the specified shell<br>  greet       Greets a user<br>  <span class="hljs-built_in">help</span>        Help about any <span class="hljs-built_in">command</span><br><br>Flags:<br>  -h, --<span class="hljs-built_in">help</span>   <span class="hljs-built_in">help</span> <span class="hljs-keyword">for</span> greet_app<br><br>Use <span class="hljs-string">&quot;greet_app [command] --help&quot;</span> <span class="hljs-keyword">for</span> more information about a <span class="hljs-built_in">command</span>.<br></code></pre></td></tr></table></figure><h2 id="对比">对比</h2><h3 id="设计哲学和易用性">设计哲学和易用性</h3><p><strong>clap</strong>:</p><ul><li>使用 Rust 的宏来提供强大的编译时功能，如参数解析、验证等。</li><li>利用 Rust 的类型安全特性，减少运行时错误。</li><li>支持通过派生宏自动从结构体生成命令行解析代码，简化开发流程。</li></ul><p><strong>cobra</strong>:</p><ul><li>采用更传统的命令式编程模型，直观且易于上手。</li><li>通过组合命令对象来构建复杂的命令行应用。</li><li>提供了一套完整的生成工具来创建命令和配置，促进了开发速度。</li></ul><h3 id="功能和特性">功能和特性</h3><p><strong>clap</strong>:</p><ul><li>自动生成帮助信息、版本信息等。</li><li>支持多级子命令。</li><li>支持自定义验证器和复杂的参数关系（如互斥、依赖等）。</li></ul><p><strong>cobra</strong>:</p><ul><li>支持自动生成帮助文档。</li><li><strong>内置命令自动补全脚本生成功能</strong>。</li><li><strong>支持持久化命令行标志到配置文件</strong>。</li><li>通过插件支持增加额外的子命令。</li><li>能够轻松地与其他 Go 库集成，如 Viper 用于配置管理。</li></ul><h3 id="性能">性能</h3><p><strong>clap</strong>:</p><ul><li>由于 Rust 的编译时优化，<code>clap</code>在解析命令行参数时通常会有更好的性能。</li><li>更少的运行时开销，尤其是在处理大量复杂命令行参数时。</li></ul><p><strong>cobra</strong>:</p><ul><li>性能对于大多数命令行应用来说已经足够，但可能不如 <code>clap</code>优化。</li><li>Go 的运行时可能会引入额外的开销，尤其是在并发处理时。</li></ul>]]></content>
    
    
    <summary type="html">本文将深入探索 Rust 中一个非常流行的命令行解析工具 clap，本文会先详细介绍 clap Derive 和 Builder 两种构建命令行工具的方式，并实战 httpie 工具，最后还将 clap 与 Go 语言中在命令行解析同样流行的 cargo 进行比较。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 常用库" scheme="https://hedon.top/categories/Rust/Rust-%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="clap" scheme="https://hedon.top/tags/clap/"/>
    
  </entry>
  
  <entry>
    <title>Rust reqwest 简明教程</title>
    <link href="https://hedon.top/2024/03/02/rust-crate-reqwest/"/>
    <id>https://hedon.top/2024/03/02/rust-crate-reqwest/</id>
    <published>2024-03-02T10:46:56.000Z</published>
    <updated>2024-05-16T13:04:10.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p><code>reqwest</code> 是 Rust 中一个非常流行和强大的 HTTP客户端库，它提供了一种简单的方式来发送 HTTP请求并处理响应。<code>reqwest</code>支持阻塞和非阻塞（异步）请求，使其适合于各种不同的应用场景。在这篇博文中，我们将详细介绍如何使用<code>reqwest</code> 发送各种 HTTP 请求，并处理返回的响应。</p><h2 id="开始之前">开始之前</h2><p>在开始编写代码之前，你需要在你的 Rust 项目中添加 <code>reqwest</code>依赖。打开你的 <code>Cargo.toml</code> 文件，并添加以下内容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">reqwest</span> = &#123; version = <span class="hljs-string">&quot;0.12.4&quot;</span>, features = [<span class="hljs-string">&quot;json&quot;</span>] &#125;<br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1&quot;</span>, features = [<span class="hljs-string">&quot;full&quot;</span>] &#125;<br><span class="hljs-attr">serde</span> = &#123; version = <span class="hljs-string">&quot;1.0.197&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;<br><span class="hljs-attr">serde_json</span> = <span class="hljs-string">&quot;1.0.114&quot;</span><br></code></pre></td></tr></table></figure><p>这里我们还添加了其他几个依赖：</p><ul><li><code>tokio</code>: 在后面的示例中，我们将使用 <code>reqwest</code>的异步功能。</li><li><code>serde</code>: 用于数据解析，在示例中，我们会演示 json数据的解析。</li><li><code>serde_json</code>: 便于使用 <code>json!</code> 宏快速构建 json数据。</li></ul><h2 id="发送-get-请求">发送 GET 请求</h2><p>发送一个 GET 请求是最基本的 HTTP 操作。以下是如何使用<code>reqwest</code> 发送 GET 请求并设置请求头的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest::header;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">params</span> = [(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>), (<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;values&quot;</span>)];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = reqwest::Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = client<br>        .<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;http://httpbin.org/get&quot;</span>)<br>        <span class="hljs-comment">// set query params</span><br>        .form(&amp;params)<br>        <span class="hljs-comment">// set request headers</span><br>        .<span class="hljs-title function_ invoke__">header</span>(header::USER_AGENT, <span class="hljs-string">&quot;My Rust Program&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">header</span>(header::CONTENT_TYPE, <span class="hljs-string">&quot;application/json&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">send</span>()<br>        .<span class="hljs-keyword">await</span>?<br>        .<span class="hljs-title function_ invoke__">text</span>()<br>        .<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;body = &#123;:?&#125;&quot;</span>, body);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用 <code>reqwest::get</code> 函数发送一个 GET请求到 "https://httpbin.org/get"，并通过 <code>text</code>方法获取响应的文本内容。</p><h2 id="发送-post---text-请求">发送 POST - text 请求</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest::Client;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = client.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&quot;http://httpbin.org/post&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">body</span>(<span class="hljs-string">&quot;the exact body that is sent&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">send</span>()<br>        .<span class="hljs-keyword">await</span>?<br>        .<span class="hljs-title function_ invoke__">text</span>()<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;body: &#123;:?&#125;&quot;</span>, res);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="发送-post---form-请求">发送 POST - form 请求</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">params</span> = [(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>), (<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;values&quot;</span>)];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = reqwest::Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = client.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&quot;http://httpbin.org/post&quot;</span>)<br>        .form(&amp;params)<br>        .<span class="hljs-title function_ invoke__">send</span>()<br>        .<span class="hljs-keyword">await</span>?<br>        .<span class="hljs-title function_ invoke__">text</span>()<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;body: &#123;:?&#125;&quot;</span>, res);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="发送-post---json-请求">发送 POST - json 请求</h2><p>发送 POST 请求通常用于向服务器提交数据。以下是如何使用<code>reqwest</code> 发送包含 JSON 数据的 POST 请求的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest;<br><span class="hljs-keyword">use</span> serde_json::json;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = reqwest::Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = client.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&quot;https://httpbin.org/post&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">json</span>(&amp;json!(&#123;<span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;value&quot;</span>&#125;))<br>        .<span class="hljs-title function_ invoke__">send</span>()<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = res.<span class="hljs-title function_ invoke__">text</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Body:\n&#123;&#125;&quot;</span>, body);<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们使用 <code>Client::post</code> 方法创建一个 POST 请求，并通过<code>json</code> 方法设置 JSON 负载。然后，我们调用 <code>send</code>方法发送请求。</p><h2 id="处理-json-响应">处理 JSON 响应</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest;<br><span class="hljs-keyword">use</span> serde::Deserialize;<br><br><span class="hljs-meta">#[derive(Deserialize)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ip</span> &#123;<br>    origin: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ip</span>: Ip = reqwest::<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;https://httpbin.org/ip&quot;</span>)<br>        .<span class="hljs-keyword">await</span>?<br>        .<span class="hljs-title function_ invoke__">json</span>()<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;IP: &#123;&#125;&quot;</span>, ip.origin);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个 <code>Ip</code> 结构体来表示 JSON响应，然后使用 <code>json</code> 方法将响应反序列化为 <code>Ip</code>类型。</p><h2 id="总结">总结</h2><p><code>reqwest</code> 库为 Rust 提供了一个功能丰富而灵活的 HTTP客户端，适用于各种网络编程任务。无论是简单的数据获取还是复杂的 API交互，<code>reqwest</code> 都能帮助你以简洁的 Rust代码完成任务。希望这篇博文能帮助你开始使用 <code>reqwest</code>来开发网络相关的 Rust 应用！</p>]]></content>
    
    
    <summary type="html">本文介绍了 Rust 一个非常流程和强大的 HTTP 客户端库 reqwest 的基本使用方法。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 常用库" scheme="https://hedon.top/categories/Rust/Rust-%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Go 语言的 GPM 模型（Go1.21）</title>
    <link href="https://hedon.top/2024/01/20/go-gpm/"/>
    <id>https://hedon.top/2024/01/20/go-gpm/</id>
    <published>2024-01-20T05:10:41.000Z</published>
    <updated>2024-01-29T13:44:58.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>在现代软件开发中，有效地利用并发是提高应用性能和响应速度的关键。随着多核处理器的普及，编程语言和框架如何高效、简便地支持并发编程，成为了软件工程师们评估和选择工具时的一个重要考量。在这方面，Go语言凭借其创新的并发模型—GPM（Goroutine, P,M）—在众多编程语言中脱颖而出，为开发者提供了强大的工具，以简单、高效的方式实现并发。</p><p>自从 2009 年首次发布以来，Go语言就以其出色的性能、简洁的语法和对并发的原生支持赢得了广泛的关注。尤其是其并发模型，被设计为能够充分利用现代多核处理器的能力，同时隐藏底层的线程管理和同步复杂性，让开发者能够以更直观、更高级的抽象来构建并发程序。GPM模型，作为 Go 语言并发编程的核心，通过Goroutine、P（processor）、M（machine）三者的协同工作，实现了一种高效且易于管理的并发机制。</p><p>本文将基于 <strong>Go1.21</strong> 深入浅出地探讨 Go 语言的 GPM模型，主要分为几个部分：</p><ul><li>首先从其设计理念出发，详细解析 Goroutine、P 和 M三者的角色、工作原理及其相互之间的交互方式。</li><li>然后引入几个关键问题，我们会从结论上先总结 GPM的核心要点，内容包括协程调度循环、调度策略和调度时机。</li><li>接着我们会深入源码，去一步步洞察 Go 语言设计者是如何实现 GPM模型中的各个要点的，这个过程会比较繁琐，但其实也比较有趣，感兴趣的读者可以阅读这一块，若只是想对GPM 模型有个大概了解，那么停留在上一步也足矣了。</li><li>最后我们基于前面的分析，总结 G、P、M 三大组件在 Go程序运行过程中的状态流转图。</li></ul><p>通过对 GPM 模型的探讨，我们不仅能够理解 Go语言如何在众多现代编程语言中以其并发编程能力脱颖而出，还能够洞察其设计背后的智慧，以及这一模型如何随着Go 语言版本的迭代而不断进化和优化。无论你是对 Go语言充满好奇的新手，还是希望深化理解其并发模型的经验开发者，本文都将为你提供宝贵的视角和深刻的洞见。</p><h1 id="结论先行">结论先行</h1><h2 id="gpm-调度原理图">GPM 调度原理图</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126214830929.png"alt="Goroutine 调度原理图" /><figcaption aria-hidden="true">Goroutine 调度原理图</figcaption></figure><h2 id="goroutine-底层结构">Goroutine 底层结构</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h569pjiiosj21cu0u040p.jpg"alt="Goroutine 底层结构示例" /><figcaption aria-hidden="true">Goroutine 底层结构示例</figcaption></figure><h2 id="调度器-p-底层结构">调度器 P 底层结构</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57sl36b40j20o40u8js7.jpg"alt="P 底层结构" /><figcaption aria-hidden="true">P 底层结构</figcaption></figure><h2 id="gpm-调度循环">GPM 调度循环</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57qxoptk4j21hm0simyy.jpg"alt="GPM 调度循环图" /><figcaption aria-hidden="true">GPM 调度循环图</figcaption></figure><h2 id="gpm-协程调度优先级与顺序">GPM 协程调度优先级与顺序</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240127161341751.png"alt="Go 协程调度优先级与顺序" /><figcaption aria-hidden="true">Go 协程调度优先级与顺序</figcaption></figure><h2 id="寻找可执行-g-过程">寻找可执行 G 过程</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240128212451142.png"alt="findRunnable()" /><figcaption aria-hidden="true">findRunnable()</figcaption></figure><h2 id="协程切换时机">协程切换时机</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240129000028727.png"alt="Go 协程切换时机" /><figcaption aria-hidden="true">Go 协程切换时机</figcaption></figure><h1 id="gpm-模型">GPM 模型</h1><h2 id="概览">1. 概览</h2><p>这里有一张很流行的 Goroutine 调度原理图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126214830929.png"alt="Goroutine 调度原理图" /><figcaption aria-hidden="true">Goroutine 调度原理图</figcaption></figure><table><thead><tr class="header"><th>代号</th><th>名称</th><th>定义位置</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>Sched</td><td>调度器</td><td>proc.c</td><td>维护有存储 M 和 G 的队列以及调度器的一些状态信息等。</td></tr><tr class="even"><td>M</td><td>Machine 系统线程</td><td>runtime.h</td><td>它由操作系统管理的，Goroutine 就是跑在 M 之上的；M是一个很大的结构，里面维护小对象内存 cache（mcache）、当前执行的Goroutine、随机数发生器等等非常多的信息。</td></tr><tr class="odd"><td>P</td><td>Processor 处理器</td><td>runtime.h</td><td>它的主要用途就是用来执行 Goroutine 的，它维护了一个 Goroutine队列，即 runqueue。Processor 是让我们从 N:1 调度到 M:N调度的重要部分。所有的 P 都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS（可配置）个。</td></tr><tr class="even"><td>G</td><td>Goroutine 实现的核心结构</td><td>runtime.h</td><td>它包含了栈，指令指针，以及其他对调度 Goroutine很重要的信息，例如其阻塞的 channel。</td></tr><tr class="odd"><td>Global Queue</td><td>全局队列</td><td>proc.h</td><td>存放等待运行的 G。全局队列可能被任意的 P 加锁去获取里面的 G。</td></tr><tr class="even"><td>P Local Queue</td><td>P 的本地队列</td><td>proc.h</td><td>同全局队列类似，存放的也是等待运行的 G，但存放的数据有限，不会超过256 个。新建 G 时，G会优先加入本地队列。如果队列满了，则会把本地队列中一半的 G 以及新 G一起移动到全局队列。</td></tr></tbody></table><p>通过这个原理图我们知道 Go 语言的 GPM模型的作用非常简单，它就是一个“精打细算”的工具。以前单进程无法充分利用CPU资源，所以引入了多进程。又因为进程拥有的资源太多，其创建、切换和销毁都会占用很长时间，所以引入了更小粒度的线程。随着计算机科学的进步，现在看来，线程拥有的资源也是“比较多”的，所以线程的创建、切换和销毁代价也是“相对大”的。所以很多编程语言就引入了协程这个概念，其核心目的就是应用层自己抽象一个比线程更小粒度的调度单元，应用层结合操作系统的多线程能力，自己来管理“调度单元”的创建、切换和销毁，从而尽可能减少由线程切换带来的开销，以做到更轻量级的并发。</p><p>不同的编程语言可能有不同的实现，而关键就在于如何让调度更快、开销更小。这便是我们本文要探讨的主要内容。</p><div class="note note-info">            <p><strong>Go 语言的实现：</strong></p><p>线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P的本地队列为空时，M 会尝试从全局队列获得一批 G 放到 P的本地队列，或者从其他 P 的本地队列中“偷”一半 G 放到自己的本地队列。然后M 运行 G，G 执行之后，再从 P 获取下一个 G，如此不断重复下去。</p>          </div><p>在进入更加具体深入的讨论之前，我们需要重点思考以下几个问题：</p><ol type="1"><li>G 我们可以随便创建，可能有成千上万个，那 P 和 M 有多少个呢？</li><li>P 和 M 什么时候被创建呢？</li><li>操作系统只知道线程，所以实际上还是线程在执行任务，那么 G是如何调度到线程上并执行的呢？</li><li>如何防止协程饥饿？</li><li>如何减少频繁地创建和销毁线程？</li><li>多个线程从全局队列拿 G如何解决并发问题？又如何减少这种数据竞争呢？</li><li>在整个 Go 调度协程的过程中，G、P、M有哪些状态？它们又是如何轮转的呢？</li></ol><p>如果你对这几个问题有兴趣，请继续阅读下文。</p><h2 id="p-和-m-的个数问题">2. P 和 M 的个数问题</h2><ol type="1"><li>P 的数量由启动时环境变量 <code>$GOMAXPROCS</code> 或者程序中<code>runtime.GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有 <code>GOMAXPROCS</code> 个Goroutine 在同时运行。</li><li>M 的数量由 Go 语言本身的限制决定，Go 程序启动时会设置 M 的最大数量为<strong>10000</strong>个，但是内核很难支持这么多的线程数，所以这个限制可以忽略。可以使用<code>runtime.SetMaxThreads()</code> 设置 M 的最大数量。</li></ol><h2 id="p-和-m-何时被创建">3. P 和 M 何时被创建</h2><ol type="1"><li>P 的创建时机在确定了 P 的最大数量 n 后，runtime 会根据这个数量创建 n个 P。</li><li>M 创建的时机是在当没有足够的 M 来关联 P 并运行其中可运行的 G的时候，如所有的 M 此时都阻塞住了，而 P中还有很多就绪任务，就会去寻找空闲的 M，如果没有空闲的 M，就会去创建新的M。</li></ol><h2 id="调度循环">4. 调度循环</h2><p>在讨论 G 是如何被调度到 M 去执行的时候，我们需要先介绍 GPM模型中两个比较特殊的角色：<code>m0</code> 和 <code>g0</code>。</p><h3 id="m0">4.1 m0</h3><ul><li><strong>定义</strong>：m0 是 Go 程序启动时创建的第一个 M。它是由 Go运行时系统直接从操作系统线程创建的，不是从线程池中获取的。</li><li><strong>作用</strong>：m0 负责初始化和启动 Go运行时环境，包括创建调度器、分配第一个P（p0），并创建其他系统级别的资源。在程序的整个生命周期中，m0会继续存在，即使它可能不执行任何 Go 代码。</li><li><strong>特点</strong>：m0 不同于其他M，因为它不是从线程池中获取的。它可能没有绑定任何 P，除非程序中只有一个P（即 GOMAXPROCS 设置为 1）。</li></ul><h3 id="g0">4.2 g0</h3><ul><li><strong>定义</strong>：g0 是每个 M 的特殊Goroutine，它不执行任何实际的 Go 代码。每个 M 在创建时都会分配一个g0。</li><li><strong>作用</strong>：g0 主要用于执行调度器代码和进行系统调用。当 M需要执行这些非用户代码时，会切换到 g0 的栈上运行。</li><li><strong>特点</strong>：g0拥有自己的栈，这个栈用于存放调度器函数和系统调用的数据。这意味着当执行这些操作时，不会影响当前运行的用户Goroutine 的栈。</li></ul><h3 id="协程栈切换">4.3 协程栈切换</h3><p>g0 是 M 中负责调度其他 g 的协程，所以一个 M 中的协程调度其实就是在 g和 g0 之间不断切换：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240127155030695.png"alt="协程 g 与 协程 g0 的对应关系" /><figcaption aria-hidden="true">协程 g 与 协程 g0 的对应关系</figcaption></figure><p>大致过程如下：</p><ol type="1"><li>当 M 执行一个 G（用户 Goroutine）时，它使用 G的栈来运行用户代码。</li><li>当需要执行系统调用或调度器相关的代码时，M 会切换到 g0。g0拥有自己的栈，专门用于执行系统调用和调度器代码，这样可以避免污染用户Goroutine 的栈空间。在 g0 上，M 可以执行如内存分配、调度决策、处理Goroutine 的创建和销毁等操作。</li><li>完成系统调用或调度器任务后，M 会切换回之前的G，继续执行用户代码。这个过程会从 g0 的栈切换回 G 的栈。</li></ol><p>详细细节我们留到后面的源码分析揭晓。</p><h2 id="调度策略">5. 调度策略</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240127161341751.png"alt="Go 协程调度优先级与顺序" /><figcaption aria-hidden="true">Go 协程调度优先级与顺序</figcaption></figure><h3 id="获取本地运行队列">5.1 获取本地运行队列</h3><p>P 会优先尝试从自己的本地队列中寻找就绪的G，它<strong>一般</strong>会优先调度最近加入的。</p><p>因为这个时候可能由其他 P 来窃取 G，所以这里是需要同步机制的，Go采用原子操作来降低同步开销。</p><p>本地队列 G 的个数不超过 <strong>256</strong> 个，<strong>如果在创建 G的时候本地队列满了，会将本地队列中 1/2 的 G 连同新创建的 G一起放入全局队列中。</strong></p><h3 id="获取全局运行队列">5.2 获取全局运行队列</h3><p>P 会优先本地队列，然后才全局队列，这有个好处：</p><ul><li>如果只有全局队列，那么所有的 P 都需要去竞争全局队列中的G，这个时候需要上锁，且数据竞争会比较激烈，性能较差。</li><li>通过每个 P维护一个自己的本地队列可以减少并发冲突，如果实在需要去全局队列拿G，也可以一次性拿多个，大大减少了并发冲突的情况发生。</li></ul><p>但这又带来了一个问题，全局队列中协程的饥饿问题，因为 P会优先调度最近加入到自己本地队列中的 G，那可能会一直有新的 G被创建，导致全局队列中的 G 没有机会被调度到。Go 的解决思路是：</p><ul><li>P 每调度 <strong>61</strong> 次后，就会从全局队列中获取一个 G来运行。</li></ul><h3 id="获取准备就绪的网络协程">5.3 获取准备就绪的网络协程</h3><p>如果本地队列和全局队列都找不到就绪的 G 可以执行的话。调度会通过<code>runtime.netpoll</code> 获取可以运行的网络协程。</p><p>Go 语言的网络模型是对不同操作系统平台上 I/O 多路复用技术的封装。</p><p>当 Goroutine 在进行网络 I/O 时，它会被挂起，线程会去执行其他Goroutine。一旦 I/O 操作完成，该 Goroutine会被唤醒并重新排队等待执行。</p><h3 id="系统调用">5.4 系统调用</h3><p>当一个 Goroutine执行系统调用时，它可能会被阻塞，这时它的执行线程（M）可能会释放当前绑定的处理器（P），以便其他Goroutine 可以在该 P 上运行。</p><h3 id="协程窃取">5.5 协程窃取</h3><p>空闲的 M 如果绑定了 P，那么它的 P 会一直尝试从其他 P 的队列中窃取Goroutine，以平衡负载和避免空闲。这个时候为了让每个 P 都有可能被窃取，Go没有直接顺序遍历 P 列表，而是采用了一种相对随机的方式去遍历 P列表，直到找到可以运行的协程就返回。M 不断寻找可执行 G的这段期间，它被称为<strong>自旋线程</strong>。</p><p>所以为减少创建、切换和销毁线程的开销，Go 做了至少两点努力：</p><ol type="1"><li><p>偷取（Work Stealing）机制</p><p>当本线程无可运行的 G 时，它所绑定的 P 会尝试从其他线程绑定的 P 窃取G，而不是销毁线程。</p></li><li><p>移交（Hand Off）机制</p><p>当本线程因为 G 进行系统调用而阻塞时，线程会释放绑定的 P，把 P移交给其他空闲的线程执行。</p></li></ol><h2 id="调度时机">6. 调度时机</h2><p>Go 语言的调度器结合了抢占式调度和协作式调度，以下是 Go中这两种调度方式的具体实现和特性：</p><h3 id="协作式调度cooperative-scheduling">6.1 协作式调度（CooperativeScheduling）</h3><p><strong>阻塞操作</strong>：</p><ul><li>当 Goroutine执行阻塞操作（如通道操作、等待锁、系统调用等）时，它会主动放弃 CPU控制权，允许调度器切换到其他 Goroutine。</li></ul><p><strong>显式调度</strong>：</p><ul><li>Goroutine 显式请求 <code>runtime.Gosched()</code>调用，调度器进行调度。</li><li>这个时候回从当前协程切换到 g0 协程，取消 G 与 M 之间的绑定关系，把 G放入全局队列中。</li></ul><h3 id="抢占式调度preemptive-scheduling">6.2 抢占式调度（PreemptiveScheduling）</h3><p><strong>基于时间的抢占</strong>：</p><ul><li>从 Go 1.14 开始，调度器引入了基于时间的抢占机制。如果一个 Goroutine运行时间超过 10 毫秒，或者在系统调用中超过了 20微妙，调度器会在安全点（如函数调用、循环迭代、阻塞操作等）尝试暂停该Goroutine。</li><li>这种抢占不依赖于 Goroutine的显式放弃控制，而是由调度器主动触发。</li><li>安全点的选择旨在减少对 Goroutine执行的干扰，同时确保调度的公平性和响应性。</li></ul><p><strong>基于信号的抢占：</strong></p><ul><li>当程序在执行过程中既无法主动挂起，也不能进行系统调用，且无法进行函数调用时，就可以使用信号来调度。</li><li>信号其实就是线程信号，在操作系统中有很多基于信号的底层通信方式（SIGPIPE/ SIGURG / SIGHUP），而我们的线程可以注册对应信号的处理函数。</li><li>当线程接收到抢占信号时，会进入一个专门的信号处理器。这个处理器会检查是否处于安全点，如果是，则暂停当前Goroutine 并进行上下文切换。</li></ul><h1 id="源码分析">源码分析</h1><p>前面我们对 Go 语言的 GPM模型在基本概念、调度循环、调度策略和调度时机各个方面都进行了详细的阐述。如果读者只是想简单了解一下GPM模型的一些概念和设计思想，那么阅读到这里就基本足够了。如果对其源码实现有兴趣的话，那么请继续往下阅读~</p><p>接下来我们会从以下几个方面来对 Go 语言的 GPM 模型进行源码分析：</p><ol type="1"><li>G、P、M 在 Go 语言中的表示。</li><li>G 的创建过程。</li><li>g 和 g0 的切换过程。</li><li>GPM 的调度机制。</li></ol><h2 id="g-的底层结构">1. G 的底层结构</h2><p>G 在 Go 里面就是 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime2.go">runtime2.go</a>里面定义的 <code>g</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 栈参数。</span><br><span class="hljs-comment">// stack 描述实际的栈内存：[stack.lo, stack.hi)。</span><br><span class="hljs-comment">// stackguard0 是在 Go 栈增长序言中比较的栈指针。</span><br><span class="hljs-comment">// 通常是 stack.lo+StackGuard，但可以是 StackPreempt 来触发抢占。</span><br><span class="hljs-comment">// stackguard1 是在 C 栈增长序言中比较的栈指针。</span><br><span class="hljs-comment">// 在 g0 和 gsignal 栈上是 stack.lo+StackGuard。</span><br><span class="hljs-comment">// 在其他 goroutine 栈上是 ~0，以触发对 morestackc 的调用（并崩溃）。</span><br>stack       stack   <span class="hljs-comment">// 运行时/CGO 已知的偏移</span><br>stackguard0 <span class="hljs-type">uintptr</span> <span class="hljs-comment">// liblink 已知的偏移</span><br>stackguard1 <span class="hljs-type">uintptr</span> <span class="hljs-comment">// liblink 已知的偏移</span><br><br>_panic    *_panic <span class="hljs-comment">// 最内层的 panic - liblink 已知的偏移</span><br>_defer    *_defer <span class="hljs-comment">// 最内层的 defer</span><br>m         *m      <span class="hljs-comment">// 当前 m；arm liblink 已知的偏移</span><br>sched     gobuf   <span class="hljs-comment">// 当前协程的运行现场</span><br>syscallsp <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 如果 status==Gsyscall, syscallsp = sched.sp 在 gc 期间使用</span><br>syscallpc <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 如果 status==Gsyscall, syscallpc = sched.pc 在 gc 期间使用</span><br>stktopsp  <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 栈顶的预期 sp，用于回溯检查</span><br><span class="hljs-comment">// param 是一个通用的指针参数字段，用于在特定上下文中传递值，</span><br><span class="hljs-comment">// 其他存储参数的方式难以找到。目前有三种用途：</span><br><span class="hljs-comment">// 1. 当通道操作唤醒一个阻塞的 goroutine 时，它将 param 设置为</span><br><span class="hljs-comment">//    指向已完成阻塞操作的 sudog。</span><br><span class="hljs-comment">// 2. 由 gcAssistAlloc1 使用，以向其调用者信号，表明 goroutine 完成了 GC 周期。</span><br><span class="hljs-comment">//    以任何其他方式这样做是不安全的，因为此时 goroutine 的栈可能已经移动。</span><br><span class="hljs-comment">// 3. 由 debugCallWrap 使用，以将参数传递给新的 goroutine，因为在运行时分配闭包是被禁止的。</span><br>param        unsafe.Pointer<br>atomicstatus atomic.Uint32<br>stackLock    <span class="hljs-type">uint32</span> <span class="hljs-comment">// sigprof/scang 锁；<span class="hljs-doctag">TODO:</span> 合并到 atomicstatus</span><br>goid         <span class="hljs-type">uint64</span><br>schedlink    guintptr<br>waitsince    <span class="hljs-type">int64</span>      <span class="hljs-comment">// g 变为阻塞的大致时间</span><br>waitreason   waitReason <span class="hljs-comment">// 如果 status==Gwaiting</span><br><br>preempt       <span class="hljs-type">bool</span> <span class="hljs-comment">// 抢占信号，复制 stackguard0 = stackpreempt</span><br>preemptStop   <span class="hljs-type">bool</span> <span class="hljs-comment">// 在抢占时转换为 _Gpreempted；否则，只是取消调度</span><br>preemptShrink <span class="hljs-type">bool</span> <span class="hljs-comment">// 在同步安全点缩小栈</span><br><br><span class="hljs-comment">// asyncSafePoint 设置为 true 表示 g 在异步安全点停止。</span><br><span class="hljs-comment">// 这意味着栈上有没有精确指针信息的帧。</span><br>asyncSafePoint <span class="hljs-type">bool</span><br><br>paniconfault <span class="hljs-type">bool</span> <span class="hljs-comment">// 在意外的故障地址上触发 panic（而不是崩溃）</span><br>gcscandone   <span class="hljs-type">bool</span> <span class="hljs-comment">// g 已扫描栈；由 _Gscan 位在状态中保护</span><br>throwsplit   <span class="hljs-type">bool</span> <span class="hljs-comment">// 必须不分割栈</span><br><span class="hljs-comment">// activeStackChans 表示有未锁定的通道指向这个 goroutine 的栈。</span><br><span class="hljs-comment">// 如果为 true，栈复制需要获取通道锁来保护这些栈区域。</span><br>activeStackChans <span class="hljs-type">bool</span><br><span class="hljs-comment">// parkingOnChan 表示 goroutine 即将在 chansend 或 chanrecv 上停车。</span><br><span class="hljs-comment">// 用于标记栈缩小的不安全点。</span><br>parkingOnChan atomic.Bool<br><br>raceignore    <span class="hljs-type">int8</span>  <span class="hljs-comment">// 忽略竞态检测事件</span><br>tracking      <span class="hljs-type">bool</span>  <span class="hljs-comment">// 是否跟踪此 G 以获取调度延迟统计</span><br>trackingSeq   <span class="hljs-type">uint8</span> <span class="hljs-comment">// 用于决定是否跟踪此 G</span><br>trackingStamp <span class="hljs-type">int64</span> <span class="hljs-comment">// G 最后开始被跟踪的时间戳</span><br>runnableTime  <span class="hljs-type">int64</span> <span class="hljs-comment">// 可运行时间，运行时清除，仅在跟踪时使用</span><br>lockedm       muintptr<br>sig           <span class="hljs-type">uint32</span><br>writebuf      []<span class="hljs-type">byte</span><br>sigcode0      <span class="hljs-type">uintptr</span><br>sigcode1      <span class="hljs-type">uintptr</span><br>sigpc         <span class="hljs-type">uintptr</span><br>parentGoid    <span class="hljs-type">uint64</span>          <span class="hljs-comment">// 创建此 goroutine 的 goroutine 的 goid</span><br>gopc          <span class="hljs-type">uintptr</span>         <span class="hljs-comment">// 创建此 goroutine 的 go 语句的 pc</span><br>ancestors     *[]ancestorInfo <span class="hljs-comment">// 创建此 goroutine 的祖先 goroutine 的信息（仅在 debug.tracebackancestors 使用）</span><br>startpc       <span class="hljs-type">uintptr</span>         <span class="hljs-comment">// goroutine 函数的 pc</span><br>racectx       <span class="hljs-type">uintptr</span><br>waiting       *sudog         <span class="hljs-comment">// 此 g 正在等待的 sudog 结构（具有有效的 elem 指针）；按锁顺序</span><br>cgoCtxt       []<span class="hljs-type">uintptr</span>      <span class="hljs-comment">// cgo 回溯上下文</span><br>labels        unsafe.Pointer <span class="hljs-comment">// 分析器标签</span><br>timer         *timer         <span class="hljs-comment">// 缓存的计时器，用于 time.Sleep</span><br>selectDone    atomic.Uint32  <span class="hljs-comment">// 我们是否参与 select 并且有人赢得了竞赛？</span><br><br><span class="hljs-comment">// goroutineProfiled 指示当前 goroutine 的栈状态</span><br>  <span class="hljs-comment">// 是否已经被记录在进行中的 goroutine 性能分析中。</span><br>goroutineProfiled goroutineProfileStateHolder<br><br><span class="hljs-comment">// 每个 G 的追踪状态。</span><br>trace gTraceState<br><br><span class="hljs-comment">// 每个 G 的 GC 状态</span><br><br><span class="hljs-comment">// gcAssistBytes 是此 G 的 GC 协助信用，以分配的字节为单位。</span><br><span class="hljs-comment">// 如果为正，则 G 有信用分配 gcAssistBytes 字节而不协助。</span><br><span class="hljs-comment">// 如果为负，则 G 必须通过执行扫描工作来纠正这一点。</span><br><span class="hljs-comment">// 我们以字节为单位跟踪这一点，以便在 malloc 热路径中快速更新和检查债务。</span><br><span class="hljs-comment">// 协助比率决定了这如何对应于扫描工作债务。</span><br>gcAssistBytes <span class="hljs-type">int64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 <code>g</code> 结构字段非常多，这个结构体的设计反映了 Go语言对并发和协程管理的底层机制，包括栈管理、调度、垃圾回收、异常处理等多个方面。通过这种抽象，Go语言能够有效地管理成千上万的<code>goroutine</code>，使得并发编程变得更加简单和高效。</p><p>这里我们只关注 GPM 模型相关的内容，需要重点关心以下几个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br>stack     stack   <span class="hljs-comment">// 当前协程的协程栈</span><br>m         *m      <span class="hljs-comment">// 当前线程</span><br>sched     gobuf  <span class="hljs-comment">// 保存协程的运行现场</span><br>atomicstatus atomic.Uint32<span class="hljs-comment">// 协程状态</span><br>goid         <span class="hljs-type">uint64</span><span class="hljs-comment">// 协程ID</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="协程栈-stack">1.1 协程栈 stack</h3><p>其中 <code>stack</code>结构如下，它存储了协程栈的低地址和高地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> stack <span class="hljs-keyword">struct</span> &#123;<br>lo <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 栈的低地址</span><br>hi <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 栈的高地址</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程抽象-m">1.2 线程抽象 m</h3><p>而 <code>m</code> 就是 Go语言对操作系统线程的抽象，这不是实际的线程，这只是 Go语言对线程相关信息的抽象，以方便更好地调度协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> m <span class="hljs-keyword">struct</span> &#123;<br>g0      *g     <span class="hljs-comment">// g0 协程，Go 中的主协程</span><br>curg    *g       <span class="hljs-comment">// 现在正在运行的协程</span><br>id      <span class="hljs-type">int64</span> <span class="hljs-comment">// 线程ID</span><br>mOS<span class="hljs-comment">// 当前操作系统对线程的额外描述信息</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>m</code>结构体包含了许多字段，这些字段涉及到线程管理、调度、信号处理、系统调用、锁管理等多个方面。这个结构体是Go 并发模型的核心部分之一，它与 <code>g</code>（goroutine）和<code>p</code>（processor）结构体一起，构成了 Go的调度系统的基础。通过这种设计，Go能够有效地在多个操作系统线程之间调度成千上万的goroutine，实现高效的并发执行。</p><h3 id="协程上下文-gobuf">1.3 协程上下文 gobuf</h3><p><code>gobuf</code> 结构体在 Go 语言的运行时系统中用于保存<code>Goroutine</code>的执行上下文，特别是在调度和系统调用中。这个结构体保存了足够的信息以便在<code>Goroutine</code> 被暂停后能够恢复执行。</p><p>下面是对 <code>gobuf</code> 结构体中各个字段的解释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// sp, pc 和 g 的偏移量是已知的（在 libmach 中硬编码）。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// ctxt 在 GC 方面比较特殊：它可能是一个堆分配的 funcval，</span><br><span class="hljs-comment">// 因此 GC 需要跟踪它，但它需要在汇编中设置和清除，</span><br><span class="hljs-comment">// 在那里实现写屏障比较困难。然而，ctxt 实际上是一个保存的、活跃的寄存器，</span><br><span class="hljs-comment">// 我们只在真实寄存器和 gobuf 之间交换它。因此，我们在栈扫描期间将其视为根，</span><br><span class="hljs-comment">// 这意味着保存和恢复它的汇编不需要写屏障。它仍然被类型化为指针，</span><br><span class="hljs-comment">// 以便任何其他从 Go 进行的写操作都会获得写屏障。</span><br>sp   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 栈指针</span><br>pc   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 程序计数器</span><br>g    guintptr       <span class="hljs-comment">// 指向当前 goroutine 的指针</span><br>ctxt unsafe.Pointer <span class="hljs-comment">// 上下文，用于保存额外的状态或信息</span><br>ret  <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 用于保存函数返回值</span><br>lr   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 链接寄存器（在某些架构中用于函数调用）</span><br>bp   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 基指针（在启用帧指针的架构中使用）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们重点需要关注 2 个字段：</p><ul><li><code>sp</code>：栈指针，表示当前协程运行到栈中的哪个位置了。</li><li><code>pc</code>：程序计数器，表示当前协程运行到哪一行代码了。</li></ul><h3 id="协程状态-atomicstatus">1.4 协程状态 atomicstatus</h3><p>我记得在 Go1.16 版本中，这个字段的类型还是 <code>uint32</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">atomicstatus <span class="hljs-type">uint32</span><br></code></pre></td></tr></table></figure><p>现在 Go1.21 版本中，已经用了原子操作来减少并发冲突了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">atomicstatus atomic.Uint32<br></code></pre></td></tr></table></figure><p>可以看到 Go 的底层也是随着版本更新不断优化中的。</p><p><ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime2.go">runtime2.go</a>定义了 G 的各种状态，如：</p><ul><li><code>_Gidle (0)</code>: 表示 G 刚刚被分配，尚未初始化。</li><li><code>_Grunnable (1)</code>: 表示 G在运行队列上。它当前没有执行用户代码。栈不被该 <code>goroutine</code>拥有。</li><li>...</li></ul><p>后面我们会给出 G 状态的流转图。</p><h3 id="举个例子">1.5 举个例子</h3><p>假设我们现在有以下 Go 代码：main() 调用 do1()，do1() 调用do2()，do2() 调用 do3()。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do3</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;here is do3&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do2</span><span class="hljs-params">()</span></span> &#123;<br>do3()<span class="hljs-comment">//&lt;---------------</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do1</span><span class="hljs-params">()</span></span> &#123;<br>do2()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>do1()<br>&#125;<br></code></pre></td></tr></table></figure><p>那么当这段程序运行到第 6 行的时候，它的底层结构大概如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h569pjiiosj21cu0u040p.jpg"alt="Goroutine 底层结构示例" /><figcaption aria-hidden="true">Goroutine 底层结构示例</figcaption></figure><p>至于为什么这里有个 <code>goexit()</code>，其实就是为了可以跳回到<code>g0</code> 协程，后面我们会具体分析到。</p><h2 id="p-的底层结构">2. P 的底层结构</h2><p>P 的本质是 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime2.go">runtime2.go</a>里面定义的 <code>p</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;<br>    id          <span class="hljs-type">int32</span>          <span class="hljs-comment">// P 的唯一标识符</span><br>    status      <span class="hljs-type">uint32</span>         <span class="hljs-comment">// P 的状态，如 pidle/prunning/...</span><br>    link        puintptr       <span class="hljs-comment">// P 链接</span><br>    schedtick   <span class="hljs-type">uint32</span>         <span class="hljs-comment">// 每次调度器调用时递增</span><br>    syscalltick <span class="hljs-type">uint32</span>         <span class="hljs-comment">// 每次系统调用时递增</span><br>    sysmontick  sysmontick     <span class="hljs-comment">// sysmon 观察到的最后一个 tick</span><br>    m           muintptr       <span class="hljs-comment">// 关联的 M 的反向链接（如果空闲则为 nil）</span><br>    mcache      *mcache        <span class="hljs-comment">// M 缓存</span><br>    pcache      pageCache      <span class="hljs-comment">// 页面缓存</span><br>    raceprocctx <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 用于竞态检测的上下文</span><br><br>    <span class="hljs-comment">// 延迟结构体池</span><br>    deferpool    []*_defer<br>    deferpoolbuf [<span class="hljs-number">32</span>]*_defer<br><br>    <span class="hljs-comment">// Goroutine ID 缓存，减少对 runtime·sched.goidgen 的访问</span><br>    goidcache    <span class="hljs-type">uint64</span><br>    goidcacheend <span class="hljs-type">uint64</span><br><br>    <span class="hljs-comment">// 可运行 goroutine 队列，无锁访问</span><br>    runqhead <span class="hljs-type">uint32</span><br>    runqtail <span class="hljs-type">uint32</span><br>    runq     [<span class="hljs-number">256</span>]guintptr<br>    runnext  guintptr <span class="hljs-comment">// 下一个要运行的 G</span><br><br>    <span class="hljs-comment">// 空闲 G 的列表（状态 == Gdead）</span><br>    gFree <span class="hljs-keyword">struct</span> &#123;<br>        gList<br>        n <span class="hljs-type">int32</span><br>    &#125;<br><br>    <span class="hljs-comment">// sudog 缓存</span><br>    sudogcache []*sudog<br>    sudogbuf   [<span class="hljs-number">128</span>]*sudog<br><br>    <span class="hljs-comment">// 堆上 mspan 对象的缓存</span><br>    mspancache <span class="hljs-keyword">struct</span> &#123;<br>        <span class="hljs-built_in">len</span> <span class="hljs-type">int</span><br>        buf [<span class="hljs-number">128</span>]*mspan<br>    &#125;<br><br>    <span class="hljs-comment">// pinner 对象的缓存</span><br>    pinnerCache *pinner<br><br>  <span class="hljs-comment">// P 状态跟踪</span><br>    trace pTraceState<br><br>    <span class="hljs-comment">// 每个 P 的持久分配，避免互斥</span><br>    palloc persistentAlloc <br><br>    <span class="hljs-comment">// 定时器相关字段</span><br>    timer0When             atomic.Int64<br>    timerModifiedEarliest  atomic.Int64<br>    timersLock             mutex<br>    timers                 []*timer<br>    numTimers              atomic.Uint32<br>    deletedTimers          atomic.Uint32<br>    timerRaceCtx           <span class="hljs-type">uintptr</span><br><br>    <span class="hljs-comment">// GC 相关字段</span><br>    gcAssistTime         <span class="hljs-type">int64</span><br>    gcFractionalMarkTime <span class="hljs-type">int64</span><br>    gcw                  gcWork<br>    wbBuf                wbBuf<br><br>    <span class="hljs-comment">// 指示是否在下一个安全点运行特定的函数</span><br>    runSafePointFn <span class="hljs-type">uint32</span><br>  <br>    <span class="hljs-comment">// 指示当前 P 是否正在写入任何统计数据。</span><br>  <span class="hljs-comment">// 偶数时表示没有写入，奇数时表示正在写入。</span><br>    statsSeq       atomic.Uint32<br>  <br>    <span class="hljs-comment">// 指示当前的 P 应该尽快进入调度器，无论其上运行的是哪个 G。</span><br><span class="hljs-comment">// 这是实现抢占式调度的一部分，允许调度器在必要时中断长时间运行的 goroutine，</span><br>    <span class="hljs-comment">// 以便其他 goroutine 有机会运行。</span><br>    preempt        <span class="hljs-type">bool</span><br>  <br>    <span class="hljs-comment">// 记录页面分配、释放和清理跟踪信息的缓冲区。</span><br>    pageTraceBuf   pageTraceBuf<br>&#125;<br></code></pre></td></tr></table></figure><p><code>p</code> 结构体在 Go语言的运行时系统中代表了一个处理器（processor），它是调度器的核心组成部分。每个<code>p</code> 负责管理一组 <code>goroutine</code>的运行。这个结构体包含了许多字段，涉及到 <code>goroutine</code>的调度、内存分配、垃圾回收和其他系统级别的操作。</p><p>我们重点关注以下几个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;<br>m           muintptr   <span class="hljs-comment">// 当前负责的线程</span><br>  <br><span class="hljs-comment">// 本地可运行的协程的队列，可无锁访问</span><br>runqhead <span class="hljs-type">uint32</span> <span class="hljs-comment">// 队头</span><br>runqtail <span class="hljs-type">uint32</span> <span class="hljs-comment">// 队尾</span><br>runq     [<span class="hljs-number">256</span>]guintptr   <span class="hljs-comment">// 长度为 256</span><br>runnext guintptr <span class="hljs-comment">// 下一个可用的协程的指针</span><br>  <br>  <span class="hljs-comment">// 抢占标识，指示当前的 P 应该尽快进入调度器，无论其上运行的是哪个 G。</span><br>  preempt <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57sl36b40j20o40u8js7.jpg"alt="P 底层结构" /><figcaption aria-hidden="true">P 底层结构</figcaption></figure><h2 id="goroutine-的创建">3. Goroutine 的创建</h2><p>Go 并发能力的优秀之处，就在于它启动一个新的协程实在是太方便了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; ... &#125;()<br></code></pre></td></tr></table></figure><p>那么底层究竟做了什么呢？</p><h3 id="newproc">3.1 newproc()</h3><p>Goroutine 通过 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a>中的 <code>newproc()</code> 创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc</span><span class="hljs-params">(fn *funcval)</span></span> &#123;<br>    gp := getg()<br>    pc := getcallerpc()<br>    systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        newg := newproc1(fn, gp, pc)<br><br>        pp := getg().m.p.ptr()<br>        runqput(pp, newg, <span class="hljs-literal">true</span>)<br><br>        <span class="hljs-keyword">if</span> mainStarted &#123;<br>            wakep()<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>获取当前 goroutine 和调用者 PC</strong>: <code>getg()</code>获取当前正在执行的 <code>goroutine</code>，<code>getcallerpc()</code>获取调用者的程序计数器地址。</li><li><strong>在系统栈上执行 <code>newproc1</code></strong>:<code>systemstack</code> 确保 <code>newproc1</code>在系统栈上执行，而不是当前 <code>goroutine</code> 的栈。这是因为新的<code>goroutine</code> 可能需要更多的栈空间。</li><li><strong>创建新的 goroutine</strong>: <code>newproc1</code>被调用来实际创建新的 <code>goroutine</code>。</li><li><strong>将新的 goroutine 放入运行队列</strong>: <code>runqput</code>将新创建的 <code>goroutine</code> 放入运行队列。</li><li><strong>唤醒处理器</strong>:如果主函数已经开始执行，<code>wakep</code> 用于唤醒一个空闲的 P来运行新的 <code>goroutine</code>。</li></ol><h3 id="newproc1">3.2 newproc1()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">(fn *funcval, callergp *g, callerpc <span class="hljs-type">uintptr</span>)</span></span> *g &#123;<br>    <span class="hljs-comment">// ... (省略了错误检查和获取 M 的代码)</span><br><br>  <span class="hljs-comment">// 尝试从 P 的空闲列表获取一个 G，如果没有则创建一个新的</span><br>    newg := gfget(pp)<br>    <span class="hljs-keyword">if</span> newg == <span class="hljs-literal">nil</span> &#123;<br>        newg = malg(stackMin)<br>        casgstatus(newg, _Gidle, _Gdead)<br>        allgadd(newg)<br>    &#125;<br><br>    <span class="hljs-comment">// 设置新 G 的栈</span><br>    totalSize := <span class="hljs-type">uintptr</span>(<span class="hljs-number">4</span>*goarch.PtrSize + sys.MinFrameSize)<br>    totalSize = alignUp(totalSize, sys.StackAlign)<br>    sp := newg.stack.hi - totalSize<br>  spArg := sp<br>  <br>    <span class="hljs-comment">// 清空并设置新 G 的调度器相关字段</span><br>    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))<br>    newg.sched.sp = sp<br>    newg.stktopsp = sp<br>    newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum<br>    newg.sched.g = guintptr(unsafe.Pointer(newg))<br>  <br>    <span class="hljs-comment">// 设置新 G 的其他字段</span><br>    gostartcallfn(&amp;newg.sched, fn)<br>    newg.parentGoid = callergp.goid<br>    newg.gopc = callerpc<br>    newg.startpc = fn.fn<br>    <br>  <span class="hljs-comment">// ... (省略了跟踪和调试相关的代码)</span><br><br>    casgstatus(newg, _Gdead, _Grunnable)<br><br>    <span class="hljs-keyword">return</span> newg<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>创建或获取一个新的 goroutine</strong>: <code>gfget</code>尝试从 P 的空闲列表中获取一个<code>goroutine</code>，如果没有可用的，则通过 <code>malg</code>分配一个新的。</li><li><strong>初始化 goroutine 的栈和调度器</strong>: 设置新<code>goroutine</code>的栈、程序计数器、调用函数等。这里有个非常核心的点<code>newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum</code>，我们前面留了个疑问，协程栈顶的<code>goexit</code> 是哪里来的，就是这里来的。这里设置新<code>goroutine</code> 的程序计数器（<code>pc</code>）指向<code>goexit</code> 函数。<code>goexit</code> 是每个<code>goroutine</code> 在退出时必须调用的函数，用于执行清理工作并切换到g0 栈。</li><li><strong>设置父 goroutine ID 和创建点</strong>: 记录创建这个新<code>goroutine</code> 的父 <code>goroutine</code> 的 ID 和<code>go</code> 语句的位置。</li><li><strong>更改 goroutine 状态</strong>: 将新 <code>goroutine</code>的状态从 <code>_Gdead</code> 改为<code>_Grunnable</code>，使其准备好被调度。</li><li><strong>返回新的 goroutine</strong>: 函数返回新创建的<code>goroutine</code>。</li></ol><h3 id="runqput">3.3 runqput()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runqput tries to put g on the local runnable queue.</span><br><span class="hljs-comment">// If next is false, runqput adds g to the tail of the runnable queue.</span><br><span class="hljs-comment">// If next is true, runqput puts g in the pp.runnext slot.</span><br><span class="hljs-comment">// If the run queue is full, runnext puts g on the global queue.</span><br><span class="hljs-comment">// Executed only by the owner P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqput</span><span class="hljs-params">(pp *p, gp *g, next <span class="hljs-type">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrandn(<span class="hljs-number">2</span>) == <span class="hljs-number">0</span> &#123;<br>next = <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">if</span> next &#123;<br>retryNext:<br>oldnext := pp.runnext<br><span class="hljs-keyword">if</span> !pp.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;<br><span class="hljs-keyword">goto</span> retryNext<br>&#125;<br><span class="hljs-keyword">if</span> oldnext == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>gp = oldnext.ptr()<br>&#125;<br><br>retry:<br>h := atomic.LoadAcq(&amp;pp.runqhead) <br>t := pp.runqtail<br><span class="hljs-keyword">if</span> t-h &lt; <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)) &#123;<br>pp.runq[t%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].set(gp)<br>atomic.StoreRel(&amp;pp.runqtail, t+<span class="hljs-number">1</span>) <br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> runqputslow(pp, gp, h, t) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">goto</span> retry<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>随机调度器</strong>：如果启用了调度器的随机化（<code>randomizeScheduler</code>），并且<code>next</code> 为 <code>true</code>（newproc 调用的时候永远都是传的true），则有一半的概率将 <code>next</code> 设置为<code>false</code>。这有助于防止调度器的行为过于可预测。</li><li><strong>处理 <code>runnext</code> 槽</strong>：如果<code>next</code> 为 <code>true</code>，函数尝试将 <code>gp</code> 放入<code>pp.runnext</code> 槽。如果该槽已被占用，则将原有的<code>goroutine</code> 移动到常规运行队列，并重试将新的 <code>gp</code>放入 <code>runnext</code>。</li><li><strong>放入本地运行队列</strong>：如果 <code>next</code> 为<code>false</code> 或 <code>runnext</code> 槽已满，函数尝试将<code>gp</code> 放入本地运行队列的尾部。如果队列未满，<code>gp</code>将被成功添加。</li><li><strong>处理队列满的情况</strong>：如果本地运行队列已满，<code>runqputslow</code>被调用，尝试将 <code>gp</code> 连同自己队列中一半的 g放入全局运行队列。如果这也失败了，函数会重试将 <code>gp</code>放入本地队列。</li><li><strong>原子操作</strong>：函数使用原子操作来加载和存储队列头（<code>runqhead</code>）和尾（<code>runqtail</code>）指针，以确保多线程环境下的数据一致性和线程安全。</li></ol><h3 id="runqputslow">3.4 runqputslow()</h3><p><code>runqputslow</code> 函数处理本地运行队列满的情况，将<code>goroutine</code>批量转移到全局队列。这个函数通过原子操作和锁来确保操作的原子性和线程安全。随机化调度器的使用增加了调度的随机性和公平性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Put g and a batch of work from local runnable queue on global queue.</span><br><span class="hljs-comment">// Executed only by the owner P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqputslow</span><span class="hljs-params">(pp *p, gp *g, h, t <span class="hljs-type">uint32</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><br>  <span class="hljs-comment">// 从 pp 的本地队列中获取一半的 goroutine</span><br>  <span class="hljs-keyword">var</span> batch [<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]*g<br>n := t - h<br>n = n / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> n != <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span>) &#123;<br>throw(<span class="hljs-string">&quot;runqputslow: queue is not full&quot;</span>)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i] = pp.runq[(h+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br>&#125;<br><span class="hljs-keyword">if</span> !atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>batch[n] = gp<br><br>  <span class="hljs-comment">// 随机打乱 goroutine 的顺序，以增加调度的随机性</span><br><span class="hljs-keyword">if</span> randomizeScheduler &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">1</span>); i &lt;= n; i++ &#123;<br>j := fastrandn(i + <span class="hljs-number">1</span>)<br>batch[i], batch[j] = batch[j], batch[i]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 串成队列</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i].schedlink.set(batch[i+<span class="hljs-number">1</span>])<br>&#125;<br><span class="hljs-keyword">var</span> q gQueue<br>q.head.set(batch[<span class="hljs-number">0</span>])<br>q.tail.set(batch[n])<br><br><span class="hljs-comment">// 放入全局队列中</span><br>lock(&amp;sched.lock)<br>globrunqputbatch(&amp;q, <span class="hljs-type">int32</span>(n+<span class="hljs-number">1</span>))<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>创建批处理数组</strong>：函数首先创建一个 <code>batch</code>数组，用于存储从本地队列中取出的 <code>goroutine</code>。</li><li><strong>从本地队列中获取一批<code>goroutine</code></strong>：函数计算出要从本地队列中取出多少个<code>goroutine</code>（通常是队列长度的一半），并将它们添加到<code>batch</code> 数组中。</li><li><strong>原子操作更新队列头部</strong>：使用原子操作<code>atomic.CasRel</code>更新本地运行队列的头部索引，这是一个释放（release）操作，确保之前的读取操作完成。</li><li><strong>将当前 <code>goroutine</code>添加到批处理中</strong>：将传入的 <code>gp</code> 添加到<code>batch</code> 数组的末尾。</li><li><strong>随机化调度器</strong>：如果启用了随机调度器，函数会随机打乱<code>batch</code> 数组中的 <code>goroutine</code>顺序，以增加调度的随机性。</li><li><strong>链接 <code>goroutine</code></strong>：将 <code>batch</code>数组中的 <code>goroutine</code> 链接起来，形成一个队列。</li><li><strong>准备全局队列</strong>：创建一个 <code>gQueue</code>结构，并设置其头部和尾部指向 <code>batch</code> 数组中的第一个和最后一个<code>goroutine</code>。</li><li><strong>将批处理放入全局队列</strong>：加锁访问全局调度器的锁，然后将整个<code>batch</code> 队列放入全局运行队列。</li></ol><h2 id="调度过程-schedule">4. 调度过程 schedule()</h2><p>Go 的调度器核心执行逻辑都在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a>的 <code>schedule()</code>函数中。我们先不探讨过多的细节，我们先把整个大体脉络理清楚再说。</p><p>简化后的 <code>schedule()</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 获取当前正在执行的 M</span><br>mp := getg().m<br>  ...<br>  <span class="hljs-comment">// 查找一个可运行的 G，会阻塞住直到返回。</span><br>gp, inheritTime, tryWakeP := findRunnable() <br>  ...<br><span class="hljs-comment">// 执行 g</span><br>execute(gp, inheritTime)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>execute()</code> 执行 g，它简化后如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">execute</span><span class="hljs-params">(gp *g, inheritTime <span class="hljs-type">bool</span>)</span></span> &#123;<br>mp := getg().m<br>..<br>gogo(&amp;gp.sched)<br>&#125;<br></code></pre></td></tr></table></figure><p>它调用了 <code>gogo()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gogo</span><span class="hljs-params">(buf *gobuf)</span></span><br></code></pre></td></tr></table></figure><p>一般这种格式说明函数是用汇编实现的，我们在 Goland 上可以双击 shift然后搜索 <code>runtime·gogo</code>：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240128130637007.png"alt="runtime·gogo" /><figcaption aria-hidden="true">runtime·gogo</figcaption></figure><p>不同的平台有不同的实现，但是核心逻辑都是一样的，它直接操作处理器的寄存器和栈，以实现从一个 <code>goroutine</code>切换到另一个 <code>goroutine</code> 的功能。</p><p>我们后面的发内心会发现 <code>goexit()</code> 最终会调用<code>schedule()</code>。</p><p>这就串起来了，Go 程序启动后会创建 m0 和g0，所以第一个<code>schedule()</code> 是 g0 调用的，最后通过<code>gogo</code> 切换到用户协程 g 上面执行业务方法，完事后 g 通过<code>goexit</code> 回到 <code>schedule()</code>，以此循环反复下去。</p><p>现在我们可以来总结一下 GPM 调度循环的过程，大概如下图表示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57qxoptk4j21hm0simyy.jpg"alt="GPM 调度循环图" /><figcaption aria-hidden="true">GPM 调度循环图</figcaption></figure><p>下面我们再对这个过程中的关键函数进行细致分析：</p><ul><li><code>schedule()</code>：调度入口。</li><li><code>findRunnable()</code>：寻找可执行的 G。</li><li><code>execute()</code>：执行 G。</li><li><code>gogo()</code>：切换协程栈 g0 到 g。</li><li><code>goexit()</code>：退出 g 协程，切换回 g0 栈。</li></ul><h3 id="schedule">4.1 schedule()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 获取当前正在执行的 M</span><br>mp := getg().m<br><br>  <span class="hljs-comment">// 有锁的话抛出异常，避免该情况下调度出现死锁或其他问题</span><br><span class="hljs-keyword">if</span> mp.locks != <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;schedule: holding locks&quot;</span>)<br>&#125;<br><br>  <span class="hljs-comment">// M 被锁定了特定的 G，这个时候直接执行这个锁定的 G。</span><br><span class="hljs-keyword">if</span> mp.lockedg != <span class="hljs-number">0</span> &#123;<br>stoplockedm()<br>execute(mp.lockedg.ptr(), <span class="hljs-literal">false</span>) <span class="hljs-comment">// Never returns.</span><br>&#125;<br><br><span class="hljs-comment">// CGO 调用需要 g0 栈，所以这个时候不继续调度了，抛出异常。</span><br><span class="hljs-keyword">if</span> mp.incgo &#123;<br>throw(<span class="hljs-string">&quot;schedule: in cgo&quot;</span>)<br>&#125;<br><br>top:<br>pp := mp.p.ptr()<br>pp.preempt = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// 安全点检查：如果当前 M 在自旋的话，应该是没有可执行 G 的。</span><br><span class="hljs-keyword">if</span> mp.spinning &amp;&amp; (pp.runnext != <span class="hljs-number">0</span> || pp.runqhead != pp.runqtail) &#123;<br>throw(<span class="hljs-string">&quot;schedule: spinning with local work&quot;</span>)<br>&#125;<br><br>  <span class="hljs-comment">// 查找一个可运行的 G，会阻塞住直到返回。</span><br>gp, inheritTime, tryWakeP := findRunnable() <br><br>  <span class="hljs-comment">// 调试的时候系统会处于“冻结”状态，</span><br>  <span class="hljs-comment">// 这里故意通过两次 lock 引入死锁使当前 M 陷入无限等待，</span><br>  <span class="hljs-comment">// 以在调试时保持当前的调度器和运行时状态不变。</span><br><span class="hljs-keyword">if</span> debug.dontfreezetheworld &gt; <span class="hljs-number">0</span> &amp;&amp; freezing.Load() &#123;<br>lock(&amp;deadlock)<br>lock(&amp;deadlock)<br>&#125;<br><br>  <span class="hljs-comment">// 如果当前 M 之前是自旋的，但是现在要准备执行 G 了，那就不是自旋了。</span><br><span class="hljs-keyword">if</span> mp.spinning &#123;<br>resetspinning()<br>&#125;<br><br>  <span class="hljs-comment">// 当用户级调度被禁用时，采用双重检查后如果确实被禁用了，</span><br>  <span class="hljs-comment">// 那么就把当前 g 放在 sched.disable.runnable 列表中，</span><br>  <span class="hljs-comment">// 等待调度重启启用时再处理。</span><br>  <span class="hljs-comment">// 在 gc 的时候会出现这种情况：</span><br>  <span class="hljs-comment">// gcStart()    -&gt;  schedEnableUser(false)</span><br>  <span class="hljs-comment">// gcMarkDone() -&gt;  schedEnableUser(true)</span><br><span class="hljs-keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;<br>lock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> schedEnabled(gp) &#123;<br>unlock(&amp;sched.lock)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>sched.disable.runnable.pushBack(gp)<br>sched.disable.n++<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">goto</span> top<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 检查是否需要唤醒一个 P。</span><br>  <span class="hljs-comment">// 如果返回的 g 比较特殊，比如要负责 gc，那么这个值会是 true。</span><br><span class="hljs-keyword">if</span> tryWakeP &#123;<br>wakep()<br>&#125;<br>  <br>  <span class="hljs-comment">// 如果 g 已经绑定了 M，则直接启动该 M 去执行 g。</span><br><span class="hljs-keyword">if</span> gp.lockedm != <span class="hljs-number">0</span> &#123;<br>startlockedm(gp)<br><span class="hljs-keyword">goto</span> top<br>&#125;<br><br>  <span class="hljs-comment">// 执行 g</span><br>execute(gp, inheritTime)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>schedule()</code> 函数是 Go 调度器的核心，负责管理<code>goroutine</code> 的执行。它包括多个步骤，如检查当前 M的状态，处理特殊情况（如 <code>goroutine</code> 被锁定到特定的 M，或者 M正在执行 CGO 调用），以及选择和执行可运行的 <code>goroutine</code>。</p><h3 id="findrunnable">4.2 findRunnable()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Finds a runnable goroutine to execute.</span><br><span class="hljs-comment">// Tries to steal from other P&#x27;s, get g from local or global queue, poll network.</span><br><span class="hljs-comment">// tryWakeP indicates that the returned goroutine is not normal (GC worker, trace reader) so the caller should try to wake a P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRunnable</span><span class="hljs-params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="hljs-type">bool</span>) &#123;<br></code></pre></td></tr></table></figure><p>通过注释就可以知道这个函数的作用：寻找一个可执行的 goroutine：</p><ol type="1"><li>尝试从其他 P 窃取 g、从本地获取 g、从全局队列获取g、从网络轮询器获取 g；</li><li>如果是一个特殊的 g，如要负责 gc 或 trace，那么会将<code>tryWakeP</code> 置为<code>true</code>，表示调度器需要尝试唤醒或启动一个新的 P 来运行这个g，以确保了即使在系统负载较低时，这些特殊的g 也能得到及时处理。</li></ol><p>我们只关心它的核心部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRunnable</span><span class="hljs-params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="hljs-type">bool</span>) &#123;<br>  <span class="hljs-comment">// 获取当前 M</span><br>mp := getg().m<br>top:<br>  <br>  <span class="hljs-comment">// 获取 M 绑定的 P</span><br>pp := mp.p.ptr()<br><br><span class="hljs-comment">// 1. 每 61 次循环调度，就会去全局队列中获取一个 g 来执行</span><br><span class="hljs-keyword">if</span> pp.schedtick%<span class="hljs-number">61</span> == <span class="hljs-number">0</span> &amp;&amp; sched.runqsize &gt; <span class="hljs-number">0</span> &#123;<br>lock(&amp;sched.lock)<br>gp := globrunqget(pp, <span class="hljs-number">1</span>)<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">// 2. 从本地队列中获取 g</span><br><span class="hljs-keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, inheritTime, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 3. 从全局队列中获取 g</span><br><span class="hljs-keyword">if</span> sched.runqsize != <span class="hljs-number">0</span> &#123;<br>lock(&amp;sched.lock)<br>gp := globrunqget(pp, <span class="hljs-number">0</span>)<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 4. 从网络轮询器中获取 g</span><br><span class="hljs-keyword">if</span> netpollinited() &amp;&amp; netpollWaiters.Load() &gt; <span class="hljs-number">0</span> &amp;&amp; sched.lastpoll.Load() != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> list := netpoll(<span class="hljs-number">0</span>); !list.empty() &#123; <span class="hljs-comment">// non-blocking</span><br>gp := list.pop()<br>injectglist(&amp;list)<br>casgstatus(gp, _Gwaiting, _Grunnable)<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoUnpark(gp, <span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 5. 自旋，从其他 P 窃取 g</span><br>  <span class="hljs-comment">// mp.spinning 这个条件检查当前 M（操作系统线程）是否应该进入自旋状态。</span><br>  <span class="hljs-comment">// 自旋状态意味着 M 会积极地寻找工作，而不是休眠。</span><br>  <span class="hljs-comment">// 2*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load()</span><br>  <span class="hljs-comment">// 这个条件确保系统中自旋的 M 的数量不会超过一定比例。</span><br>  <span class="hljs-comment">// 这是为了防止在低并发情况下过多的 CPU 使用。</span><br><span class="hljs-keyword">if</span> mp.spinning || <span class="hljs-number">2</span>*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load() &#123;<br><span class="hljs-keyword">if</span> !mp.spinning &#123;<br>mp.becomeSpinning()<br>&#125;<br> <br>gp, inheritTime, tnow, w, newWork := stealWork(now)<br><span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, inheritTime, <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> newWork &#123;<br><span class="hljs-keyword">goto</span> top<br>&#125;<br><br>now = tnow<br><span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; (pollUntil == <span class="hljs-number">0</span> || w &lt; pollUntil) &#123;<br>pollUntil = w<br>&#125;<br>&#125;<br>  ...<br><span class="hljs-keyword">goto</span> top<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个过程涉及到几个重要的函数：</p><ul><li><code>globrunqget()</code>：从全局队列中寻找可运行的 G。</li><li><code>runqget()</code>：从本地队列中寻找可运行的 G。</li><li><code>netpoll()</code>：寻找可以运行的网络协程。</li><li><code>stealWork()</code>：从其他 P 窃取可运行的 G。</li></ul><h3 id="globrunqget">4.3 globrunqget()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">globrunqget</span><span class="hljs-params">(pp *p, max <span class="hljs-type">int32</span>)</span></span> *g &#123;<br>  <span class="hljs-comment">// 抢全局列表的锁</span><br>    assertLockHeld(&amp;sched.lock)<br><br>  <span class="hljs-comment">// 如果为空则直接返回</span><br>    <span class="hljs-keyword">if</span> sched.runqsize == <span class="hljs-number">0</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>  <span class="hljs-comment">// 确定 n 的大小，即要从全局队列中获取的 g 的个数。</span><br>  <span class="hljs-comment">// 这里会结合入参 max 对边界值进行判断，以获得一个合理的 n。</span><br>  <span class="hljs-comment">// 一次性最多拿 len(pp.runq)/2 个 g。</span><br>    n := sched.runqsize/gomaxprocs + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> n &gt; sched.runqsize &#123;<br>       n = sched.runqsize<br>    &#125;<br>    <span class="hljs-keyword">if</span> max &gt; <span class="hljs-number">0</span> &amp;&amp; n &gt; max &#123;<br>       n = max<br>    &#125;<br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(pp.runq))/<span class="hljs-number">2</span> &#123;<br>       n = <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(pp.runq)) / <span class="hljs-number">2</span><br>    &#125;<br><br>    sched.runqsize -= n<br><br>  <span class="hljs-comment">// 通过 pop() 从全局队列中弹出 g</span><br>    gp := sched.runq.pop()<br>    n--<br>    <span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- &#123;<br>       gp1 := sched.runq.pop()<br>       <span class="hljs-comment">// 将 g 放入 pp 的本地队列中</span><br>       <span class="hljs-comment">// runqput 在前面创建协程的地方已经介绍过了，这里不赘述。</span><br>       runqput(pp, gp1, <span class="hljs-literal">false</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> gp<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runqget">4.4 runqget()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqget</span><span class="hljs-params">(pp *p)</span></span> (gp *g, inheritTime <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-comment">// runnext 的 g 会优先执行</span><br>next := pp.runnext<br><span class="hljs-keyword">if</span> next != <span class="hljs-number">0</span> &amp;&amp; pp.runnext.cas(next, <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> next.ptr(), <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 原子操作获取队头指针</span><br>h := atomic.LoadAcq(&amp;pp.runqhead) <br>t := pp.runqtail<br><span class="hljs-keyword">if</span> t == h &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br>    <span class="hljs-comment">// 从队头获取 g，并通过原子操作更新队头（即抢这个 g）</span><br>gp := pp.runq[h%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br><span class="hljs-keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+<span class="hljs-number">1</span>) &#123; <br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runqget()</code> 函数用于从本地运行队列中获取一个可运行的<code>goroutine</code>。这个函数只能由拥有该队列的处理器（P）执行。下面是对这个函数的详细解释：</p><p><strong>1. 检查 <code>runnext</code></strong>：</p><ul><li><code>runnext</code> 是一个特殊的字段，用于存储下一个要运行的<code>goroutine</code>。如果 <code>runnext</code>非零，并且能成功通过原子操作（CAS）将其设置为零，则直接返回这个<code>goroutine</code>。</li><li>如果成功获取 <code>runnext</code> 指向的<code>goroutine</code>，<code>inheritTime</code> 被设置为<code>true</code>，表示这个 <code>goroutine</code>应该继承当前时间片的剩余时间。</li><li>如果没成功，意味着 runnext 的这个 g 已经被其他 P给抢了，因为我们可以发现本 P 只可能将其设置为 0，只有其他 P才会将其设置以为非 0。</li></ul><p><strong>2. 从本地队列中获取 <code>goroutine</code></strong>：</p><ul><li>使用原子操作加载<code>runqhead</code>（队列头指针），<code>runqtail</code>（队列尾指针）。</li><li>如果 <code>runqhead</code> 等于<code>runqtail</code>，表示队列为空，返回 <code>nil</code>。</li><li>否则，从队列中获取 <code>runqhead</code> 指向的<code>goroutine</code>，并尝试通过原子操作（CAS）更新<code>runqhead</code>。</li><li>如果更新成功，返回获取到的<code>goroutine</code>，<code>inheritTime</code> 被设置为<code>false</code>，表示这个 <code>goroutine</code>应该开始一个新的时间片。</li></ul><p>两个问题：</p><p><strong>1. 为什么获取 runqhead 需要上锁，获取 runqtail就不需要？</strong></p><p><strong>单一生产者</strong>：每个本地运行队列只有一个生产者，即与之关联的当前P。只有这个 P 可以向队列尾部添加新的<code>goroutine</code>。由于不存在多个生产者的并发写入问题，因此不需要锁来保护队尾。</p><p><strong>2. inheritTime 有什么用？</strong></p><p><code>inheritTime</code> 的主要作用是决定新调度的<code>goroutine</code>是否应该立即开始一个新的时间片，或者继续使用当前时间片的剩余部分。这在以下两种情况下尤为重要：</p><ul><li><strong>继承时间片</strong> (<code>inheritTime == true</code>)：当<code>runqget</code> 从 <code>runnext</code> 字段获取<code>goroutine</code> 时，这个 <code>goroutine</code>被认为是特别优先的，因此它继承了当前时间片的剩余时间。这通常发生在<code>goroutine</code>通过特定的同步机制（如通道操作）被明确唤醒时。</li><li><strong>开始新的时间片</strong>(<code>inheritTime == false</code>)：当 <code>runqget</code>从本地运行队列中正常获取 <code>goroutine</code> 时，这个<code>goroutine</code>将开始一个全新的时间片。这确保了调度的公平性，使得每个<code>goroutine</code> 都有机会在给定的时间片内运行。</li></ul><h3 id="netpoll">4.5 netpoll()</h3><p><code>netpoll()</code> 函数是 Go语言运行时网络轮询机制的一部分，用于检查网络连接是否准备好进行非阻塞 I/O操作。这个函数返回一组已经变为可运行状态的 <code>goroutine</code>，这些<code>goroutine</code> 之前可能因等待网络 I/O 而被挂起。</p><p>这里涉及到 Go 语言网络编程原理，在本文中不细究，就简单带过了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">netpoll</span><span class="hljs-params">(delay <span class="hljs-type">int64</span>)</span></span> gList &#123;<br>  <span class="hljs-comment">// 检查轮询器是否初始化。</span><br><span class="hljs-keyword">if</span> kq == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> gList&#123;&#125;<br>&#125;<br>  <span class="hljs-comment">// 设置轮询超时。</span><br><span class="hljs-keyword">var</span> tp *timespec<br><span class="hljs-keyword">var</span> ts timespec<br><span class="hljs-keyword">if</span> delay &lt; <span class="hljs-number">0</span> &#123;<br>tp = <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> delay == <span class="hljs-number">0</span> &#123;<br>tp = &amp;ts<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ts.setNsec(delay)<br><span class="hljs-keyword">if</span> ts.tv_sec &gt; <span class="hljs-number">1e6</span> &#123;<br>ts.tv_sec = <span class="hljs-number">1e6</span><br>&#125;<br>tp = &amp;ts<br>&#125;<br>  <span class="hljs-comment">// 使用 kevent 进行轮询操作，结果放在 events 中。</span><br><span class="hljs-keyword">var</span> events [<span class="hljs-number">64</span>]keventt<br>retry:<br>n := kevent(kq, <span class="hljs-literal">nil</span>, <span class="hljs-number">0</span>, &amp;events[<span class="hljs-number">0</span>], <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(events)), tp)<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> n != -_EINTR &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;runtime: kevent on fd&quot;</span>, kq, <span class="hljs-string">&quot;failed with&quot;</span>, -n)<br>throw(<span class="hljs-string">&quot;runtime: netpoll failed&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> delay &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> gList&#123;&#125;<br>&#125;<br><span class="hljs-keyword">goto</span> retry<br>&#125;<br>  <span class="hljs-comment">// 遍历 events 处理轮询事件。</span><br><span class="hljs-keyword">var</span> toRun gList<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">int</span>(n); i++ &#123;<br>ev := &amp;events[i]<br><br>    <span class="hljs-comment">// netpollBreakRd 用于唤醒轮询，即唤醒等待中的 goroutine。</span><br><span class="hljs-keyword">if</span> <span class="hljs-type">uintptr</span>(ev.ident) == netpollBreakRd &#123;<br><span class="hljs-keyword">if</span> ev.filter != _EVFILT_READ &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;runtime: netpoll: break fd ready for&quot;</span>, ev.filter)<br>throw(<span class="hljs-string">&quot;runtime: netpoll: break fd ready for something unexpected&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> delay != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> tmp [<span class="hljs-number">16</span>]<span class="hljs-type">byte</span><br>read(<span class="hljs-type">int32</span>(netpollBreakRd), noescape(unsafe.Pointer(&amp;tmp[<span class="hljs-number">0</span>])), <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(tmp)))<br>netpollWakeSig.Store(<span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>    <span class="hljs-comment">// 根据轮询事件的类型（读或写），唤醒相应等待网络 I/O 的 groutine。</span><br><span class="hljs-keyword">var</span> mode <span class="hljs-type">int32</span><br><span class="hljs-keyword">switch</span> ev.filter &#123;<br><span class="hljs-keyword">case</span> _EVFILT_READ:<br>mode += <span class="hljs-string">&#x27;r&#x27;</span><br><span class="hljs-keyword">if</span> ev.flags&amp;_EV_EOF != <span class="hljs-number">0</span> &#123;<br>mode += <span class="hljs-string">&#x27;w&#x27;</span><br>&#125;<br><span class="hljs-keyword">case</span> _EVFILT_WRITE:<br>mode += <span class="hljs-string">&#x27;w&#x27;</span><br>&#125;<br><span class="hljs-keyword">if</span> mode != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> pd *pollDesc<br><span class="hljs-keyword">var</span> tag <span class="hljs-type">uintptr</span><br><span class="hljs-keyword">if</span> goarch.PtrSize == <span class="hljs-number">4</span> &#123;<br>pd = (*pollDesc)(unsafe.Pointer(ev.udata))<br>tag = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tp := taggedPointer(<span class="hljs-type">uintptr</span>(unsafe.Pointer(ev.udata)))<br>pd = (*pollDesc)(tp.pointer())<br>tag = tp.tag()<br><span class="hljs-keyword">if</span> pd.fdseq.Load() != tag &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>pd.setEventErr(ev.flags == _EV_ERROR, tag)<br>      <span class="hljs-comment">// 标记 goroutine 可执行。</span><br>netpollready(&amp;toRun, pd, mode)<br>&#125;<br>&#125;<br>  <br>  <span class="hljs-comment">// 返回可运行的 goroutine 列表。</span><br><span class="hljs-keyword">return</span> toRun<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stealwork">4.6 stealWork()</h3><p><code>stealWork()</code> 函数用于尝试从其他处理器（P）窃取可运行的<code>goroutine</code> 或定时器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stealWork</span><span class="hljs-params">(now <span class="hljs-type">int64</span>)</span></span> (gp *g, inheritTime <span class="hljs-type">bool</span>, rnow, pollUntil <span class="hljs-type">int64</span>, newWork <span class="hljs-type">bool</span>) &#123;<br>  <br>  <span class="hljs-comment">// 获取当前 M 绑定的 P。</span><br>pp := getg().m.p.ptr()<br><br>ranTimer := <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment">// 尝试 4 次。</span><br><span class="hljs-keyword">const</span> stealTries = <span class="hljs-number">4</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; stealTries; i++ &#123;<br>    <span class="hljs-comment">// 前 3 次尝试窃取 g。</span><br>    <span class="hljs-comment">// 第 4 次尝试窃取 timer，并且尝试获取其他 P 的 runnext 中的 g。</span><br>stealTimersOrRunNextG := i == stealTries<span class="hljs-number">-1</span><br><br>    <span class="hljs-comment">// 随机选一个 P。</span><br><span class="hljs-keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;<br><span class="hljs-comment">// 如果系统正在 GC，则可以直接返回 true，因为可能要负责 gc 了，有事干了。</span><br>      <span class="hljs-keyword">if</span> sched.gcwaiting.Load() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>, now, pollUntil, <span class="hljs-literal">true</span><br>&#125;<br>      <br>      <span class="hljs-comment">// 获取选中的 P，如果是当前 P 则直接 continue，重试。</span><br>p2 := allp[enum.position()]<br><span class="hljs-keyword">if</span> pp == p2 &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>      <span class="hljs-comment">// 第 4 次尝试去窃取 p2 的 timer。</span><br><span class="hljs-keyword">if</span> stealTimersOrRunNextG &amp;&amp; timerpMask.read(enum.position()) &#123;<br>        <span class="hljs-comment">// 检查并可能执行 timer。</span><br>tnow, w, ran := checkTimers(p2, now)<br>now = tnow<br><span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; (pollUntil == <span class="hljs-number">0</span> || w &lt; pollUntil) &#123;<br>pollUntil = w<br>&#125;<br>        <span class="hljs-comment">// 如果执行了 timer，则检查本地队列是否有 g 可以运行，</span><br>        <span class="hljs-comment">// 因为 timer 会唤醒被挂起的 g。</span><br><span class="hljs-keyword">if</span> ran &#123;<br><span class="hljs-keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, inheritTime, now, pollUntil, ranTimer<br>&#125;<br>ranTimer = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br>      <span class="hljs-comment">// 前 3 次尝试或者第 4 次尝试没有窃取到 timer 的时候，</span><br>      <span class="hljs-comment">// 就从其他非空闲 P 的本地队列中尝试窃取 g。</span><br><span class="hljs-keyword">if</span> !idlepMask.read(enum.position()) &#123;<br>        <span class="hljs-comment">// 如果 stealTimersOrRunNextG 为 true，</span><br>        <span class="hljs-comment">// 那么会在窃取的时候，尝试窃取 p2 的 runnext。</span><br><span class="hljs-keyword">if</span> gp := runqsteal(pp, p2, stealTimersOrRunNextG); gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, now, pollUntil, ranTimer<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>, now, pollUntil, ranTimer<br>&#125;<br></code></pre></td></tr></table></figure><p>阅读源码的好处这就体现了，所有人都告诉我们 P 找不到可运行 G的时候就会去窃取其他 P 的G，但没人告诉我们，在这个过程<strong>还可能会去窃取其他 P 的 timer 和runnext</strong>。</p><p>所谓<code>timer</code>，即定时器，用于在指定的时间后执行某些操作。这些操作通常包括唤醒等待特定时间的<code>goroutine</code>，或执行与时间相关的任务。定时器在 Go的并发模型中扮演着重要的角色，特别是在涉及到时间延迟或周期性任务的场景中。在调度器层面，定时器的管理对于确保及时响应时间相关的事件和维持高效的调度至关重要。通过合理地处理定时器事件，Go能够在保持高并发性的同时，有效地管理时间延迟和周期性任务。</p><p>在 Go 语言的调度器中，跨 P 的定时器窃取是一种优化机制，它有 2个好处：</p><ul><li><strong>保持处理器活跃</strong>：当一个 P没有足够的本地工作时，它可以尝试从其他 P窃取定时器任务。这样做可以保持该 P活跃，避免它进入休眠状态，从而提高整体系统的效率。</li><li><strong>平衡系统负载</strong>：在多核系统中，不同的 P可能会有不同的负载。跨 P 的定时器窃取有助于在 P之间平衡负载，特别是在一些 P 非常忙碌而其他 P 相对空闲的情况下。</li></ul><p>好的，回过头来，为什么我们会说窃取的时候会从队头窃取呢？为什么是窃取p2 一半的 g 呢？这个过程就在 <code>runqsteal()</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqsteal</span><span class="hljs-params">(pp, p2 *p, stealRunNextG <span class="hljs-type">bool</span>)</span></span> *g &#123;<br>t := pp.runqtail<br>  <br>  <span class="hljs-comment">// 从 p2 中获取 n 个 g。</span><br>n := runqgrab(p2, &amp;pp.runq, t, stealRunNextG)<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>  <br>  <span class="hljs-comment">// 返回第 1 个 g，因为它可以直接执行了。</span><br>n--<br>gp := pp.runq[(t+n)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> gp<br>&#125;<br>  <span class="hljs-comment">// 如果还有剩下的 g，那么就加入到本地队列中。</span><br>  <span class="hljs-comment">// 这里可以看到是从队头加入的，所以需要使用原子操作获取队头。</span><br>h := atomic.LoadAcq(&amp;pp.runqhead)<br><span class="hljs-keyword">if</span> t-h+n &gt;= <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)) &#123;<br>throw(<span class="hljs-string">&quot;runqsteal: runq overflow&quot;</span>)<br>&#125;<br>atomic.StoreRel(&amp;pp.runqtail, t+n)<br><span class="hljs-keyword">return</span> gp<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runqgrab()</code> 是窃取 n 个 g 的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqgrab</span><span class="hljs-params">(pp *p, batch *[256]guintptr, batchHead <span class="hljs-type">uint32</span>, stealRunNextG <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">uint32</span> &#123;<br>  <span class="hljs-comment">// 使用无限循环来尝试窃取工作，直到成功或确定没有可窃取的工作。</span><br><span class="hljs-keyword">for</span> &#123;<br>h := atomic.LoadAcq(&amp;pp.runqhead) <br>t := atomic.LoadAcq(&amp;pp.runqtail) <br>n := t - h<br>    <br>    <span class="hljs-comment">// 这里可以看到，要窃取的个数，就是 pp 本地队列中 g 个数的一半</span><br>n = n - n/<span class="hljs-number">2</span><br>    <br>    <span class="hljs-comment">// 如果 n 为 0，且 stealRunNextG == true，</span><br>    <span class="hljs-comment">// 那么就尝试窃取 pp 的 runnext 中的 g。</span><br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> stealRunNextG &#123;<br><span class="hljs-keyword">if</span> next := pp.runnext; next != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> !pp.runnext.cas(next, <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>batch[batchHead%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(batch))] = next<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>    <br>    <span class="hljs-comment">// 如果 n 不为队列长度的一半，则说明队列发生了变化，</span><br>    <span class="hljs-comment">// 这个时候重新尝试窃取。</span><br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span>) &#123; <br><span class="hljs-keyword">continue</span><br>&#125;<br>    <span class="hljs-comment">// 将要窃取的 g 从 pp.runq 中转移到 batch 中。</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>g := pp.runq[(h+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))]<br>batch[(batchHead+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(batch))] = g<br>&#125;<br>    <span class="hljs-comment">// 使用原子操作尝试更新 pp 的队列头部，即将 g 从 pp.runq 中移除。</span><br><span class="hljs-keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123; <br><span class="hljs-keyword">return</span> n<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>findRunnable()</code>的全部过程我们总算是梳理完了，这个过程确实非常精彩，Go调度器在提高调度性能、确保调度的公平性、平衡系统负载、降低同步开销、减少资源再分配等方面都做了很多的努力，这才让Go 语言的并发又强大又易用。</p><p>下面是对 <code>findRunnable()</code> 一个简单的总结：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240128212451142.png"alt="findRunnable()" /><figcaption aria-hidden="true">findRunnable()</figcaption></figure><h3 id="execute">4.7 execute()</h3><p><code>findRunnable()</code> 之后就是<code>execute()</code>，它的核心过程如下（有删减）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">execute</span><span class="hljs-params">(gp *g, inheritTime <span class="hljs-type">bool</span>)</span></span> &#123;<br>mp := getg().m<br><span class="hljs-comment">// 将 g0 d 线程信息复制到即将要调用的协程 gp 中。</span><br>mp.curg = gp<br>gp.m = mp<br>  <span class="hljs-comment">// 修改 gp 的状态为 _Grunning，即运行中。</span><br>casgstatus(gp, _Grunnable, _Grunning)<br>gp.waitsince = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 标记为非抢占</span><br>gp.preempt = <span class="hljs-literal">false</span><br>  <span class="hljs-comment">// 用于栈保护，检测栈溢出</span><br>gp.stackguard0 = gp.stack.lo + stackGuard<br>  <span class="hljs-comment">// gogo 会完成 g0 到 g 的协程栈的切换，并从 gp.sched 开始执行。</span><br>  <span class="hljs-comment">// sched 字段我们前面介绍过，它是 gobuf 结构体，存储了 sp 和 pc。</span><br>gogo(&amp;gp.sched)<br>&#125;<br></code></pre></td></tr></table></figure><p>所以 <code>execute()</code> 的工作非常简单，其实就是将 g0的线程信息复制到 gp 上，并修改状态和一些元数据，核心部分其实在<code>gogo()</code> 中。</p><h3 id="gogo">4.8 gogo()</h3><p>前面我们说过，<code>gogo()</code> 会完成 g0 栈到 g栈的切换，且在不同平台下有不同的视线，这里我们以 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/asm_arm64.s">asm_arm64.s</a>为代表来看一下 <code>gogo()</code> 的汇编实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">TEXT runtime·gogo(SB), NOSPLIT|NOFRAME, $0-8<br>MOVDbuf+0(FP), R5<br>MOVDgobuf_g(R5), R6<br>MOVD0(R6), R4// make sure g != nil<br>Bgogo&lt;&gt;(SB)<br><br>TEXT gogo&lt;&gt;(SB), NOSPLIT|NOFRAME, $0<br>MOVDR6, g<br>BLruntime·save_g(SB)<br><br>MOVDgobuf_sp(R5), R0<br>MOVDR0, RSP<br>MOVDgobuf_bp(R5), R29<br>MOVDgobuf_lr(R5), LR<br>MOVDgobuf_ret(R5), R0<br>MOVDgobuf_ctxt(R5), R26<br>MOVD$0, gobuf_sp(R5)<br>MOVD$0, gobuf_bp(R5)<br>MOVD$0, gobuf_ret(R5)<br>MOVD$0, gobuf_lr(R5)<br>MOVD$0, gobuf_ctxt(R5)<br>CMPZR, ZR // set condition codes for == test, needed by stack split<br>MOVDgobuf_pc(R5), R6<br>B(R6)<br></code></pre></td></tr></table></figure><p>具体过程如下：</p><ol type="1"><li><strong><code>runtime·gogo</code>函数</strong>：这个函数用于设置新的 <code>goroutine</code>上下文。它接收一个指向 <code>gobuf</code>结构的指针（<code>buf+0(FP)</code>），该结构包含了<code>goroutine</code> 的上下文信息。</li><li><strong>加载 <code>gobuf</code> 并检查 <code>g</code></strong>：加载<code>gobuf</code> 结构，并检查 <code>g</code> 是否为<code>nil</code>。</li><li><strong>跳转到 <code>gogo&lt;&gt;</code></strong>：执行无条件跳转到<code>gogo&lt;&gt;</code> 函数。</li><li><strong><code>gogo&lt;&gt;</code>函数</strong>：这个函数实际上完成了上下文切换。<ul><li>设置当前 <code>goroutine</code>：将 <code>R6</code>寄存器中的值（新的 <code>goroutine</code>）设置为当前<code>goroutine</code>。</li><li>保存当前 <code>goroutine</code>：调用 <code>runtime·save_g</code>保存当前 <code>goroutine</code> 的状态。</li><li>恢复栈指针和其他寄存器：从 <code>gobuf</code>结构中恢复栈指针（<code>RSP</code>）、基指针（<code>R29</code>）、链接寄存器（<code>LR</code>）、返回值（<code>R0</code>）和上下文（<code>R26</code>）。</li><li>清空 <code>gobuf</code> 结构：将 <code>gobuf</code>结构中的字段清零。</li><li>准备跳转到新的程序计数器位置：从 <code>gobuf</code>中加载新的程序计数器地址（<code>gobuf_pc(R5)</code>）到<code>R6</code>。</li><li>跳转执行：通过 <code>B (R6)</code>跳转到新的程序计数器地址，继续执行新 <code>goroutine</code>的代码。</li></ul></li></ol><p>这段汇编代码是 Go 运行时中处理 <code>goroutine</code>上下文切换的关键部分。它直接操作处理器的寄存器和栈，以实现从一个<code>goroutine</code> 切换到另一个 <code>goroutine</code> 的功能。</p><p>在 <code>execute()</code> 中是这么调用 <code>gogo()</code> 的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">gogo(&amp;gp.sched)<br></code></pre></td></tr></table></figure><p>所以完成栈的切换后会从 <code>gp.sched</code>开始，执行代码，前面我们介绍过 <code>sched</code> 是一个<code>gobuf</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;<br>sp   <span class="hljs-type">uintptr</span><br>pc   <span class="hljs-type">uintptr</span><br>g    guintptr<br>ctxt unsafe.Pointer<br>ret  <span class="hljs-type">uintptr</span><br>lr   <span class="hljs-type">uintptr</span><br>bp   <span class="hljs-type">uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以会从 pc 处开始执行业务代码，前面在 <code>newproc()</code>的时候，我们提过一行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum<br></code></pre></td></tr></table></figure><p>这行代码的作用，是在协程创建的时候插入一个 <code>goexit</code>函数的地址，因为这个时候 <code>g</code>刚创建，所以其实就是往协程栈顶插入了 <code>goexit</code> 的地址。所以当<code>g</code> 执行完业务代码后，当栈中元素不断弹出后，最终就会弹出<code>goexit</code> 的地址，然后执行 <code>goexit()</code>函数，退出当前 <code>g</code>，切换回 <code>g0</code>。</p><h3 id="goexit">4.9 goexit()</h3><p><code>goexit</code> 定义在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/stubs.go">runtime/stubs.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// goexit is the return stub at the top of every goroutine call stack.</span><br><span class="hljs-comment">// Each goroutine stack is constructed as if goexit called the</span><br><span class="hljs-comment">// goroutine&#x27;s entry point function, so that when the entry point</span><br><span class="hljs-comment">// function returns, it will return to goexit, which will call goexit1</span><br><span class="hljs-comment">// to perform the actual exit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function must never be called directly. Call goexit1 instead.</span><br><span class="hljs-comment">// gentraceback assumes that goexit terminates the stack. A direct</span><br><span class="hljs-comment">// call on the stack will cause gentraceback to stop walking the stack</span><br><span class="hljs-comment">// prematurely and if there is leftover state it may panic.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit</span><span class="hljs-params">(neverCallThisFunction)</span></span><br></code></pre></td></tr></table></figure><p>通过注释我们可以得到 2 个信息：</p><ul><li><code>goexit</code> 的位于每个 goroutine 调用栈的顶部。每个goroutine 的栈被构造得好像 <code>goexit</code> 调用了 goroutine的入口函数。这意味着当入口函数返回时，它实际上返回到<code>goexit</code>。</li><li>不要直接调用 <code>goexit</code>，应该调用<code>goexit1</code>。</li></ul><p><code>goexit1</code> 位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Finishes execution of the current goroutine.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit1</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racegoend()<br>&#125;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoEnd()<br>&#125;<br>mcall(goexit0)<br>&#125;<br></code></pre></td></tr></table></figure><p>好吧，它调用了<code>goexit0</code>，原来这才是真正的退出入口，它也位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit0</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>  <span class="hljs-comment">// 获取当前的 M 和 P</span><br>mp := getg().m<br>pp := mp.p.ptr()<br><br>  <span class="hljs-comment">// 修改 gp 的状态为 _Gdead，标志它的终止</span><br>casgstatus(gp, _Grunning, _Gdead)<br>  <span class="hljs-comment">// 标记 gc 的栈内存是可以进行 gc 扫描的</span><br>gcController.addScannableStack(pp, -<span class="hljs-type">int64</span>(gp.stack.hi-gp.stack.lo))<br><span class="hljs-comment">// 如果 gp 是系统 goroutine，则将系统 goroutine 的计数减少</span><br>  <span class="hljs-keyword">if</span> isSystemGoroutine(gp, <span class="hljs-literal">false</span>) &#123;<br>sched.ngsys.Add(<span class="hljs-number">-1</span>)<br>&#125;<br>  <span class="hljs-comment">// 清理 gp 的状态</span><br>gp.m = <span class="hljs-literal">nil</span><br>locked := gp.lockedm != <span class="hljs-number">0</span><br>gp.lockedm = <span class="hljs-number">0</span><br>mp.lockedg = <span class="hljs-number">0</span><br>gp.preemptStop = <span class="hljs-literal">false</span><br>gp.paniconfault = <span class="hljs-literal">false</span><br>gp._defer = <span class="hljs-literal">nil</span> <br>gp._panic = <span class="hljs-literal">nil</span><br>gp.writebuf = <span class="hljs-literal">nil</span><br>gp.waitreason = waitReasonZero<br>gp.param = <span class="hljs-literal">nil</span><br>gp.labels = <span class="hljs-literal">nil</span><br>gp.timer = <span class="hljs-literal">nil</span><br><br>  <span class="hljs-comment">// 如果启用了垃圾回收（GC）并且 gp.gcAssistBytes 大于 0，</span><br>  <span class="hljs-comment">// 则将辅助信用归还给全局池。这有助于更好地控制垃圾回收进程。</span><br><span class="hljs-keyword">if</span> gcBlackenEnabled != <span class="hljs-number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="hljs-number">0</span> &#123;<br>assistWorkPerByte := gcController.assistWorkPerByte.Load()<br>scanCredit := <span class="hljs-type">int64</span>(assistWorkPerByte * <span class="hljs-type">float64</span>(gp.gcAssistBytes))<br>gcController.bgScanCredit.Add(scanCredit)<br>gp.gcAssistBytes = <span class="hljs-number">0</span><br>&#125;<br><br>  <span class="hljs-comment">// 将当前 g 从 P 的运行队列中移除</span><br>dropg()<br><br>  <span class="hljs-comment">// WebAssembly 平台特殊处理</span><br><span class="hljs-keyword">if</span> GOARCH == <span class="hljs-string">&quot;wasm&quot;</span> &#123; <br>gfput(pp, gp)<br>schedule() <br>&#125;<br><br>  <span class="hljs-comment">// 将 gp 放回处理器的可用队列中，这样可以复用 g</span><br>gfput(pp, gp)<br><br>  <span class="hljs-comment">// 如果 goroutine 被绑定到当前线程上，</span><br>  <span class="hljs-comment">// 那可能是在做系统调用，cgo 调用或其他特殊任务，</span><br>  <span class="hljs-comment">// 那么就需要切到 g0，让 g0 来完成后面的调度。</span><br>  <span class="hljs-keyword">if</span> locked &#123;<br><span class="hljs-comment">// 如果 goroutine 在终止前曾锁定当前线程，</span><br>    <span class="hljs-comment">// 则根据不同的操作系统执行不同的处理。</span><br>    <span class="hljs-comment">// 在大多数操作系统上，会跳转到 mstart 函数，释放 P 并退出线程。</span><br>    <span class="hljs-comment">// 但在 Plan 9 操作系统上，会清除 lockedExt。</span><br><span class="hljs-keyword">if</span> GOOS != <span class="hljs-string">&quot;plan9&quot;</span> &#123; <span class="hljs-comment">// See golang.org/issue/22227.</span><br>gogo(&amp;mp.g0.sched)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mp.lockedExt = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>  <br>  <span class="hljs-comment">// 继续调度</span><br>  <span class="hljs-comment">// 如果执行了 gogo，那就是 g0 在调度。</span><br>  <span class="hljs-comment">// 如果没有执行 gogo，那就是 gp 在调度。</span><br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里我们就完成了对 GPM 调度循环的全过程源码分析了，你可以回到 <ahref="##4.%20调度过程%20schedule()">4. 调度过程 schedule()</a>看一下我总结的那张图，这回你应该会有更加深入的理解了。</p><h2 id="协程切换">5. 协程切换</h2><p>如果要一个协程要一直到执行完毕才退出的话，那很可能会造成其他协程饥饿的问题。所以Go其实会在一些特殊的时机对协程进行切换，这个过程有抢占式调度，也有协作式的调度。</p><p>协程切换的时候，最核心的就是要保存当前协程的现场，以方便回到该协程的时候继续执行剩下的内容。大致过程如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57vi6wrdqj21ho0sqjtn.jpg"alt="Go 协程切换" /><figcaption aria-hidden="true">Go 协程切换</figcaption></figure><p>有哪些时机会触发切换呢，这里我直接给出结论：</p><p>基于协作的抢占式调度</p><ul><li>主动挂起：<code>runtime.gopark()</code></li><li>系统调用结束时：<code>exitsyscall()</code></li><li>函数跳转时：<code>morestack()</code></li></ul><p>基于信号的抢占式调度</p><ul><li>信号调度：<code>doSigPreempt()</code></li></ul><h3 id="主动挂起-runtime.gopack">5.1 主动挂起 runtime.gopack()</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57vq4flf5j21j20s4jto.jpg"alt="gopack 协程切换" /><figcaption aria-hidden="true">gopack 协程切换</figcaption></figure><p>这个函数位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gopark</span><span class="hljs-params">(unlockf <span class="hljs-keyword">func</span>(*g, unsafe.Pointer)</span></span> <span class="hljs-type">bool</span>, lock unsafe.Pointer, reason waitReason, traceReason traceBlockReason, traceskip <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> reason != waitReasonSleep &#123;<br>checkTimeouts() <br>&#125;<br>mp := acquirem()<br>gp := mp.curg<br>status := readgstatus(gp)<br><span class="hljs-keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;<br>throw(<span class="hljs-string">&quot;gopark: bad g status&quot;</span>)<br>&#125;<br>mp.waitlock = lock<br>mp.waitunlockf = unlockf<br>gp.waitreason = reason<br>mp.waitTraceBlockReason = traceReason<br>mp.waitTraceSkip = traceskip<br>releasem(mp)<br>mcall(park_m)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>gopark</code> 函数的主要目的是使 G进入休眠状态，等待被唤醒。</p><p>最后它调用了 <code>mcall()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// mcall switches from the g to the g0 stack and invokes fn(g)</span><br><span class="hljs-comment">// mcall 切换到 g0，并执行 fn。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mcall</span><span class="hljs-params">(fn <span class="hljs-keyword">func</span>(*g)</span></span>)<br></code></pre></td></tr></table></figure><p>所以这里切换回 <code>g0</code>，并执行了 <code>pack_m</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">park_m</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pack_m()</code> 其实就是调用了 <code>schedule()</code>去进行下一轮调度，这就完成了协程的切换。</p><p>当协程被阻塞的时候，就会去调用 <code>runtime.gopark()</code> 主动让出CPU，切回 <code>g0</code>，等待被唤醒，以此保证最大化利用 CPU资源。比如以下几种情况：</p><ul><li>休眠</li><li>channel 通道阻塞</li><li>网络 I/O 阻塞</li><li>因为执行垃圾回收而暂停</li></ul><h3 id="系统调用结束时-exitsyscall">5.2 系统调用结束时exitsyscall()</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h57vx0tfayj21g60r4tb4.jpg"alt="exitsyscall 协程切换" /><figcaption aria-hidden="true">exitsyscall 协程切换</figcaption></figure><p>Go 通过 <code>entersyscall()</code> 进行系统调用，完事后会执行<code>exitsyscall()</code>，它也位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exitsyscall</span><span class="hljs-params">()</span></span> &#123;<br>...<br>mcall(exitsyscall0)<br>&#125;<br></code></pre></td></tr></table></figure><p>其实它最终也是调用 <code>mcall()</code> 切换到 <code>g0</code>，我们不难猜出，它这里让 <code>g0</code> 去执行 <code>exitsyscall0</code>函数，做完系统调用的善后后，肯定还是会执行 <code>schedule()</code>函数进行协程调度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exitsyscall0</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数跳转时-morestack">5.3 函数跳转时 morestack()</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57w74gg19j21iq0smwgs.jpg"alt="morestack 协程切换" /><figcaption aria-hidden="true">morestack 协程切换</figcaption></figure><p>因为函数跳转意味着“压栈”，函数跳转时都会调用这个方法，它的本意在于检查当前协程栈空间是否有足够内存，如果不够就要扩大该栈空间。</p><p>为了让每个协程都有执行的机会，并且最大化利用 CPU 资源，Go语言在初始化时会启动一个特殊的线程来执行系统监控任务，系统监控在一个独立的M 上运行，不用绑定逻辑处理器 P。当系统监控到协程运行超过<code>10ms</code>，就将 <code>g.stackguard0</code> 置为<code>stackPreempt</code>（该值是一个抢占标志）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> forcePreemptNS = <span class="hljs-number">10</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> <span class="hljs-comment">// 10ms</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">retake</span><span class="hljs-params">(now <span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">uint32</span> &#123;<br><span class="hljs-comment">// 遍历所有的 P</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(allp); i++ &#123;<br>pp := allp[i]<br>pd := &amp;pp.sysmontick<br>s := pp.status<br>sysretake := <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> s == _Prunning || s == _Psyscall &#123;<br>t := <span class="hljs-type">int64</span>(pp.schedtick)<br><span class="hljs-keyword">if</span> <span class="hljs-type">int64</span>(pd.schedtick) != t &#123;<br>pd.schedtick = <span class="hljs-type">uint32</span>(t)<br>pd.schedwhen = now<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now &#123;<br>        <span class="hljs-comment">// 如果 G 运行时间过长，超过了 forcePreemptNS(10ms)，</span><br>        <span class="hljs-comment">// 则标记抢占</span><br>preemptone(pp)<br>sysretake = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> s == _Psyscall &#123;<br>      <span class="hljs-comment">// 如果是系统调用，且已经超过了一个系统监控的 tick(20us)，</span><br>      <span class="hljs-comment">// 则从系统调用中抢占 p。</span><br>      t := <span class="hljs-type">int64</span>(pp.syscalltick)<br><span class="hljs-keyword">if</span> !sysretake &amp;&amp; <span class="hljs-type">int64</span>(pd.syscalltick) != t &#123;<br>pd.syscalltick = <span class="hljs-type">uint32</span>(t)<br>pd.syscallwhen = now<br><span class="hljs-keyword">continue</span><br>&#125;<br>...<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 标记抢占</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preemptone</span><span class="hljs-params">(pp *p)</span></span> <span class="hljs-type">bool</span> &#123;<br>mp := pp.m.ptr()<br>gp := mp.curg<br>gp.preempt = <span class="hljs-literal">true</span><br>gp.stackguard0 = stackPreempt<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>巧的就是，Go 设计者，让程序在执行 <code>morestack()</code>函数时顺便判断一下 <code>g</code> 中的 <code>stackguard</code>是否已经被置为抢占 <code>stackPreempt</code>，如果的确被标记抢占，就回到<code>schedule()</code> 方法，并将当前协程放回队列中。</p><p><code>morestack</code> 是汇编实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">TEXT runtime·morestack(SB),NOSPLIT|NOFRAME,$0-0<br>...<br>BLruntime·newstack(SB)<br></code></pre></td></tr></table></figure><p>它最终会调用 <code>newstack()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newstack</span><span class="hljs-params">()</span></span> &#123;<br>  thisg := getg()<br>  gp := thisg.m.curg<br>  <span class="hljs-comment">// 1. 判断 gp.stackguard0 是否被标记为抢占</span><br>  stackguard0 := atomic.Loaduintptr(&amp;gp.stackguard0)<br>preempt := stackguard0 == stackPreempt<br>  <span class="hljs-comment">// 2. 如果被标记位抢占，调用 gopreempt_m()</span><br>  <span class="hljs-keyword">if</span> preempt &#123;<br><span class="hljs-comment">// 3. 最终会去调用  schedule() 去调新的协程执行</span><br>gopreempt_m(gp) <span class="hljs-comment">// never return</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gopreempt_m</span><span class="hljs-params">(gp *g)</span></span> &#123;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoPreempt()<br>&#125;<br>goschedImpl(gp)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goschedImpl</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号调度-dosigpreempt">5.4 信号调度 doSigPreempt()</h3><p>当程序在执行过程中既无法主动挂起，也不能进行系统调用，且无法进行函数调用时，就可以使用信号来调度。</p><p>信号其实就是线程信号，在操作系统中有很多基于信号的底层通信方式（SIGPIPE/ SIGURG / SIGHUP），而我们的线程可以注册对应信号的处理函数。</p><p>Go 中是注册了 <code>SIGURG</code> 信号的处理函数<code>doSigPreempt()</code>，在 GC工作时，向目标线程发送信号。线程收到信号后，会触发调度。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57wecvgwdj21hk0ssgny.jpg"alt="doSigPreempt 协程切换" /><figcaption aria-hidden="true">doSigPreempt 协程切换</figcaption></figure><p><code>doSigPreempt</code> 位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/signal_unix.go">runtime.signal_unix.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSigPreempt</span><span class="hljs-params">(gp *g, ctxt *sigctxt)</span></span> &#123;<br><span class="hljs-comment">// 检查此 g 是否要被抢占并且安全抢占</span><br><span class="hljs-keyword">if</span> wantAsyncPreempt(gp) &#123;<br><span class="hljs-keyword">if</span> ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok &#123;<br><span class="hljs-comment">// 2. 调整程序计数器 PC 并异步调用 asyncPreempt</span><br>ctxt.pushCall(abi.FuncPCABI0(asyncPreempt), newpc)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>asyncPreempt</code> 的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncPreempt</span><span class="hljs-params">()</span></span><br><br><span class="hljs-comment">// </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncPreempt2</span><span class="hljs-params">()</span></span> &#123;<br>gp := getg()<br>gp.asyncSafePoint = <span class="hljs-literal">true</span><br>  <span class="hljs-comment">// </span><br><span class="hljs-keyword">if</span> gp.preemptStop &#123;<br>mcall(preemptPark)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mcall(gopreempt_m)<br>&#125;<br>gp.asyncSafePoint = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>asyncPreempt</code> 是汇编实现，最终是调的<code>asyncPreempt2</code>，它会调用 <code>mcall</code> 切回<code>g0</code>，并执行 <code>preemptPark</code> 或<code>gopreempt_m</code>， <code>gopreempt_m</code> 就是前面<code>morestack</code> 最后调的！不出意外，<code>preemptPack</code>最后肯定还是调的 <code>schedule()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preemptPark</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runtime.gosched">5.5 runtime.Gosched()</h3><p>在我们实际编程中，你可以通过显式调用 <code>runtime.Gosched()</code>来主动让出 CPU，促进 Go 的下一轮调度，我们来看它的具体实现，肯定还是调的<code>schedule()</code>，没有意外！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Gosched</span><span class="hljs-params">()</span></span> &#123;<br>checkTimeouts()<br>mcall(gosched_m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gosched_m</span><span class="hljs-params">(gp *g)</span></span> &#123;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoSched()<br>&#125;<br>goschedImpl(gp)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goschedImpl</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>status := readgstatus(gp)<br><span class="hljs-keyword">if</span> status&amp;^_Gscan != _Grunning &#123;<br>dumpgstatus(gp)<br>throw(<span class="hljs-string">&quot;bad g status&quot;</span>)<br>&#125;<br>casgstatus(gp, _Grunning, _Grunnable)<br>dropg()<br>lock(&amp;sched.lock)<br>globrunqput(gp)<br>unlock(&amp;sched.lock)<br><br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结">5.6 总结</h3><p>Go 语言为了确保 P 不会因为 G运行时间过长或系统调用阻塞时间过长而导致性能下降。它会尝试进行协程切换，以确保任务可以适时地被分配和执行。这有助于保持Go程序的并发性能和响应性。而协程切换的方式有基于协作的抢占式调度（主动挂起<code>runtime.gopark()</code>，系统调用结束时<code>exitsyscall()</code>，函数跳转时<code>morestack()</code>），也有基于信号的抢占式调度<code>doSigPreempt()</code>，他们都无一例外的最终调用了<code>schedule()</code>。</p><p>所以总结下来其实还是这张图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57vi6wrdqj21ho0sqjtn.jpg"alt="Go 协程切换" /><figcaption aria-hidden="true">Go 协程切换</figcaption></figure><h1 id="gpm-状态流转">G、P、M 状态流转</h1><p>经过我们前面的分析，你可以自行整理 G、P、M状态的流转，这里我给出几张图供你参考：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126224853429.png"alt="Go 协程（G）状态转换图" /><figcaption aria-hidden="true">Go 协程（G）状态转换图</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126225021035.png"alt="Go 处理器（P）状态转换图" /><figcaption aria-hidden="true">Go 处理器（P）状态转换图</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126225849169.png"alt="Go M（操作系统线程）状态转换" /><figcaption aria-hidden="true">Go M（操作系统线程）状态转换</figcaption></figure><h1 id="总结-1">总结</h1><p>以上便是对 Go 语言 GPM 模型的全部分享啦！GPM 模型使得 Go语言能够并发执行成千上万个协程。</p><p>为了减少线程“相对昂贵”的切换代价，Go 引入了 GPM，将大量的 Goroutine分配到少量的系统线程上去执行，并利用多核并行，实现更强大的并发。</p><p>为了减小并发冲突，Go 在全局队列的基础上引入了本地队列。</p><p>为了避免协程饥饿，Go 又引入了多种协程调度的策略。</p><p>为了避免协程阻塞浪费 CPU，Go 引入了多种协程切换的方式。</p><p>Go 语言设计者进行了如此复杂的调度器实现，最终交付给 Gopher的，仅仅是一个 <code>go</code>关键字这么简单，真的是大道至简，这也是充分印证了那句话：“Go为并发而生”。</p><p>希望本文能对你有所帮助，enjoy~ happy coding~</p><h1 id="参考">参考</h1><ul><li><a href="https://book.douban.com/subject/36403287/">深入理解 Go语言</a></li><li><a href="https://book.douban.com/subject/35556889/">Go语言底层原理剖析</a></li><li><a href="https://coding.imooc.com/class/576.html">深入 Go底层原理</a></li><li>ChatGPT4</li></ul><h1 id="作图工具">作图工具</h1><ul><li><a href="https://excalidraw.com/">excalidraw</a></li><li><a href="https://whimsical.com/">whimsical</a></li></ul>]]></content>
    
    
    <summary type="html">本文基于 Go1.21.0 版本详细介绍了 Go 语言的 GPM 模型。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨绘制曼德博集</title>
    <link href="https://hedon.top/2024/01/17/rust-action-mandelbrot/"/>
    <id>https://hedon.top/2024/01/17/rust-action-mandelbrot/</id>
    <published>2024-01-17T14:39:05.000Z</published>
    <updated>2024-04-02T14:19:13.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="曼德博集">曼德博集</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/2560px-Mandelset_hires-20240118170914026.png"alt="曼德博集" /><figcaption aria-hidden="true">曼德博集</figcaption></figure><p>曼德博集其实是一个“没什么用”的发现。</p><p>曼德博集（MandelbrotSet）是一种在复平面上形成独特且复杂图案的点的集合。这个集合是以数学家本华·曼德博（BenoitMandelbrot）的名字命名的，他在研究复杂结构和混沌理论时发现了这个集合。曼德博集是分形几何的一个经典例子，显示了一个简单的数学公式如何能产生无限复杂和美丽的图案。</p><p>曼德博集的定义相对简单。对于每一个复数 <spanclass="math inline">\(c\)</span>，我们考虑以下迭代序列： <spanclass="math display">\[Z_{n+1} = z_n^2 + c \;\;\\ 其中 \;\; (z_0 = 0)\]</span> <strong>曼德博集合由那些使得上述序列不趋于无限大的复数 <spanclass="math inline">\(c\)</span>组成</strong>。在复平面上，这些点形成了一种独特的图案，通常以一种美丽且艺术的方式呈现。这个图案的边界非常复杂，包含了无限的细节和自相似的结构。这意味着无论你放大图案的哪一部分，你都会发现越来越精细的结构，这些结构在形式上与整体图案相似。</p><p>曼德博集合不仅在数学上有意义，也在艺术和科学中有广泛的应用，尤其是在研究混沌理论和复杂系统时。</p><p>具体可以看</p><ul><li><ahref="https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%BE%B7%E5%8D%9A%E9%9B%86%E5%90%88">维基百科-曼德博集</a></li><li><a href="https://www.bilibili.com/video/BV1kA411T7at">bilibili -2000亿倍放大曼德博集</a></li></ul><h1 id="目标功能">目标功能</h1><p>最终我们将实现一个命令行工具，它会根据我们输入的参数生成曼德博集图，使用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./mandelbrot &lt;FILE&gt; &lt;PIXELS&gt; &lt;UPPERLEFT&gt; &lt;LOWERRIGHT&gt;<br></code></pre></td></tr></table></figure><ul><li><code>FILE</code>: 曼德博集图生成的图片路经。</li><li><code>PIXELS</code>: 图片分辨率，如 <code>4x3</code>。</li><li><code>UPPERLEFT</code>: 指定在复平面中图片覆盖的左上角，如<code>4.0,3.0</code>。</li><li><code>LOWERRIGHT</code>: 制定在复平面中图片覆盖的右下角。</li></ul><p>所以我们最终会根据指定的图片范围，截取 <code>PIXELS</code>分辨率大小的曼德博集图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240118171322832.png"alt="截取曼德博集示意图" /><figcaption aria-hidden="true">截取曼德博集示意图</figcaption></figure><p>基于以上目标，我们拆分成几个问题：</p><ol type="1"><li>如何表示复数？</li><li>如何解析分辨率和坐标？</li><li>如何将图上像素映射到复数？</li><li>如何生成曼德博集图？即如何找到那些符合曼德博集的点，并将其进行着色标注？</li><li>如何写入图片文件？</li><li>如何渲染曼德博集？</li><li>如何解析命令行参数？</li><li>如何并发写入图片文件？</li></ol><h1 id="能学到什么">能学到什么</h1><ol type="1"><li>曼德博集是什么？</li><li>Rust 中的复数的原理与应用。</li><li>Rust 泛型初探。</li><li>Rust 中的 Option 和 Result 初探。</li><li>Rust 并发初探。</li><li>Rust 中如何解析命令行参数？</li><li>Rust 如何写入图像文件？</li><li>Rust 如何写测试用例？</li><li>Rust 实用 crate<code>num</code>、<code>image</code>、<code>crossbeam</code>。</li></ol><h1 id="版本">版本</h1><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;mandelbrot&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">image</span> = &#123;version = <span class="hljs-string">&quot;0.13.0&quot;</span>, features = [<span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;png&quot;</span>]&#125;<br><span class="hljs-attr">num</span> = <span class="hljs-string">&quot;0.4.1&quot;</span><br><span class="hljs-attr">crossbeam</span> = <span class="hljs-string">&quot;0.8&quot;</span><br><span class="hljs-attr">rayon</span> = <span class="hljs-string">&quot;1.10.0&quot;</span><br></code></pre></td></tr></table></figure><p>完整代码：https://github.com/hedon954/mandelbrot/blob/master/src/main.rs</p><h1 id="编码实现">编码实现</h1><h2 id="创建项目">0. 创建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new mandelbrot<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> mandelbrot<br></code></pre></td></tr></table></figure><h2 id="复数表示">1. 复数表示</h2><p>使用复数，我们需要引入一个 crete：<code>num</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add num<br></code></pre></td></tr></table></figure><p>其中定义了一个复数类型 <code>Complex</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/// 复数的实部</span><br>    <span class="hljs-keyword">pub</span> re: T,<br>    <span class="hljs-comment">/// 复数的虚部</span><br>    <span class="hljs-keyword">pub</span> im: T,<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>T</code> 是 Rust 中的泛型功能，表示任意类型<code>T</code>，确定好这个结构体的 <code>T</code> 的类型后，其中的属性<code>re</code> 和 <code>im</code> 的类型也就随之确定了。</p><h2 id="解析分辨率和坐标">2. 解析分辨率和坐标</h2><ul><li>分辨率格式为：4000x3000</li><li>坐标格式为：-1.0,2.0</li></ul><h3 id="解析数对">2.1 解析数对</h3><p>我们要做的就是，将分辨率拆成 (4000,3000)，将坐标拆为 (-1.0,2.0)。这里：</p><ul><li>带解析的元素 <code>s</code> 是一个字符串<code>&amp;str</code>。</li><li>分隔符 <code>separator</code> 是一个字符 <code>char</code>。</li><li>返回值是一个元组 <code>(T, T)</code>，其中 <code>T</code> 这里可以是u64/f32 等数字，它们都需要能从字符串转化而来，即<code>&lt;T:FromStr&gt;</code>。</li><li>因为解析可能出错，所以我们使用 <code>Option</code> 来承载。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 把字符串 `s`（形如 `&quot;400×600&quot;` 或 ``&quot;1.0,0.5&quot;）解析成一个坐标对</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// 具体来说，`s` 应该具有&lt;left&gt;&lt;sep&gt;&lt;right&gt;的格式，其中&lt;sep&gt;是由`separator`</span><br><span class="hljs-comment">/// 参数给出的字符，而&lt;left&gt;和&lt;right&gt;是可以被 `T:from_str` 解析的字符串。</span><br><span class="hljs-comment">/// `separator` 必须是 ASCII 字符</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// 如果 `s` 具有正确的格式，就返回 `Some(x,y)`，否则返回 `None`</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pair</span>&lt;T: FromStr&gt;(s: &amp;<span class="hljs-type">str</span>, separator: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;(T, T)&gt; &#123;<br>    <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">find</span>(separator) &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>        <span class="hljs-title function_ invoke__">Some</span>(index) =&gt; <span class="hljs-keyword">match</span> (T::<span class="hljs-title function_ invoke__">from_str</span>(&amp;s[..index]), T::<span class="hljs-title function_ invoke__">from_str</span>(&amp;s[index + <span class="hljs-number">1</span>..])) &#123;<br>            (<span class="hljs-title function_ invoke__">Ok</span>(l), <span class="hljs-title function_ invoke__">Ok</span>(r)) =&gt; <span class="hljs-title function_ invoke__">Some</span>((l, r)),<br>            _ =&gt; <span class="hljs-literal">None</span>,<br>        &#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以写几个测试用例来验证一下这个函数的正确性，这里我们用到<code>#[test]</code> 和 <code>assert_eq!</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_parse_pair</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;10,&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;,10&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;10,20&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)));<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;10,20xy&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">f64</span>&gt;(<span class="hljs-string">&quot;0.5x&quot;</span>, <span class="hljs-string">&#x27;x&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">f64</span>&gt;(<span class="hljs-string">&quot;0.5x1.5&quot;</span>, <span class="hljs-string">&#x27;x&#x27;</span>), <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-number">0.5</span>, <span class="hljs-number">1.5</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="转为复数">2.2 转为复数</h3><p>我们需要的参数 <code>upper_left</code> 和 <code>lower_right</code>都是复平面中的一个点，所以从字符串中将数对解析完毕后，我们将其赋值到复数的实部和虚部，转为复数实例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 把一对用逗号隔开的浮点数解析为复数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_complex</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Complex&lt;<span class="hljs-type">f64</span>&gt;&gt; &#123;<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">parse_pair</span>(s, <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>((re, im)) =&gt; <span class="hljs-title function_ invoke__">Some</span>(Complex &#123; re, im &#125;),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="将像素点映射成复数">3. 将像素点映射成复数</h2><p>第 2 步我们其实确定了两件事：</p><ol type="1"><li>确定截取曼德博集的哪一部分。</li><li>要在这个部分中画多少个点。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240118174407537.png"alt="目标区域中的像素点" /><figcaption aria-hidden="true">目标区域中的像素点</figcaption></figure><p>这一步我们需要把 <code>x</code>点转为复数，即确定它的横坐标和纵坐标。这部分可能需要发挥一下你的几何数学能力了（🤡🤡🤡）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 给定输出图像重像素的行和列，返回复平面中对应的坐标</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// `pixed` 是表示给图片中特定像素的 (column, row) 二元组。</span><br><span class="hljs-comment">/// `upper_left` 参数和 `lower_right` 参数是在复平面中表示指定图像覆盖范围的点。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">pixed_to_point</span>(<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    ·--------------------&gt; bounds.0  re</span><br><span class="hljs-comment">    丨</span><br><span class="hljs-comment">    丨</span><br><span class="hljs-comment">    丨</span><br><span class="hljs-comment">    bounds.1  im</span><br><span class="hljs-comment">     */</span><br>    bounds: (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>),<br>    pixed: (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>),<br>    upper_left: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>    lower_right: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> Complex&lt;<span class="hljs-type">f64</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> (width, height) = (<br>        lower_right.re - upper_left.re, <span class="hljs-comment">// 右-左</span><br>        upper_left.im - lower_right.im, <span class="hljs-comment">// 上-下</span><br>    );<br><br>    Complex &#123;<br>        re: upper_left.re + pixed.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> * width / bounds.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>,<br>        im: upper_left.im - pixed.<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> * height / bounds.<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_pixed_to_point</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        <span class="hljs-title function_ invoke__">pixed_to_point</span>(<br>            (<span class="hljs-number">100</span>, <span class="hljs-number">200</span>),<br>            (<span class="hljs-number">25</span>, <span class="hljs-number">175</span>),<br>            Complex &#123; re: -<span class="hljs-number">1.0</span>, im: <span class="hljs-number">1.0</span> &#125;,<br>            Complex &#123; re: <span class="hljs-number">1.0</span>, im: -<span class="hljs-number">1.0</span> &#125;<br>        ),<br>        Complex &#123;<br>            re: -<span class="hljs-number">0.5</span>,<br>            im: -<span class="hljs-number">0.75</span>,<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="寻找曼德博集点">4. 寻找曼德博集点</h2><p>什么是曼德博集点？看看上面的定义：<strong>曼德博集合由那些使得上述序列不趋于无限大的复数<span class="math inline">\(c\)</span> 组成</strong>。</p><p>现在我们可以来表示上述的公式 <span class="math inline">\(Z_{n+1} =z_n^2 + c\)</span> 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">complex_square_add_loop</span>(c: Complex&lt;<span class="hljs-type">f64</span>&gt;) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> = Complex &#123; re: <span class="hljs-number">0.0</span>, im: <span class="hljs-number">0.0</span> &#125;;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        z = z * z + c<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中我们将泛型结构体 <code>Complex</code> 的 <code>T</code> 确定为<code>f64</code>，并使用 <code>loop</code> 关键字进行无限循环。</p><p>所以我们的目标是什么？<strong>找到令 <code>z</code>不会“飞到”无穷远的 <code>c</code></strong>。</p><p>由于复数 <span class="math inline">\(c\)</span> 具有实部 re 和虚部im，因此可以把它们视为笛卡尔平面上某个点的 x 坐标和 y 坐标，如果 <spanclass="math inline">\(c\)</span>在曼德博集中，就在其中用黑色着色，否则就用浅色。因此，对于图像中的每个像素，必须在复平面上相应点位运行前面的循环，看看它是否逃逸到无穷远还是永远绕着原点运行，并相应将其着色。</p><p>无限循环肯定是不现实的，我们总要找到退出循环的机会，有 2 个思路：</p><ol type="1"><li>进行有限次数的迭代，这样可以获得该集合的一个不错的近似值，迭代的次数取决了精度的需要；</li><li>业界已证明，<strong>一旦 <code>z</code> 离开了以原点为中心的半径 2的圆，它最终一定会“飞到”无穷远</strong>。</li></ol><p>所以我们最终确定的函数如下，其中 <code>norm_sqr()</code> 会返回<code>z</code> 跟复平面原点的距离的平方：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 尝试测试 `c` 是否位于曼德博集中，使用最多 `limit` 次迭代来判定</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// 如果 `c` 不是集合成员之一，则返回 `Some(i)`，其中 `i` 是 `c` 离开以原点</span><br><span class="hljs-comment">/// 为中心的半径为 2 的圆时所需的迭代次数。如果 `c` 似乎是集群成员之一（确</span><br><span class="hljs-comment">/// 切而言是达到了迭代次数限制但仍然无法证明 `c` 不是成员），则返回 `None`</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">escape_time</span>(c: Complex&lt;<span class="hljs-type">f64</span>&gt;, limit: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">usize</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> = Complex &#123; re: <span class="hljs-number">0.0</span>, im: <span class="hljs-number">0.0</span> &#125;;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..limit &#123;<br>        <span class="hljs-keyword">if</span> z.<span class="hljs-title function_ invoke__">norm_sqr</span>() &gt; <span class="hljs-number">4.0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Some</span>(i);<br>        &#125;<br>        z = z * z + c<br>    &#125;<br>    <span class="hljs-literal">None</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写入图片文件">5. 写入图片文件</h2><p>我们可以使用 <code>image</code> 这个 crate来写入图片文件，它支持多种格式图片的读写，并内置了多种颜色色值。</p><p>这里我们准备生成 png图片，且需要对图片进行不同颜色的着色，所以我们引入 <code>default</code>和 <code>png</code> 这两个 feature。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add image --features default,png<br></code></pre></td></tr></table></figure><h3 id="创建文件-filecreate">5.1 创建文件 File::create()</h3><p>我们可以用标准库中的 <code>File::create(filename)</code>来创建一个文件，成功的话会返回一个文件句柄：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">output</span> = File::<span class="hljs-title function_ invoke__">create</span>(filename)?;<br></code></pre></td></tr></table></figure><h3 id="写入图片-pngencoder">5.2 写入图片 PNGEncoder</h3><p><code>image</code> 中提供了 <code>PNGEncoder</code> 用于写入 png图片，它有两个核心方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;W: Write&gt; PNGEncoder&lt;W&gt; &#123;<br>    <span class="hljs-comment">/// Create a new encoder that writes its output to ```w```</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(w: W) <span class="hljs-punctuation">-&gt;</span> PNGEncoder&lt;W&gt; &#123;<br>        PNGEncoder &#123;<br>            w: w<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/// Encodes the image ```image```</span><br>    <span class="hljs-comment">/// that has dimensions ```width``` and ```height```</span><br>    <span class="hljs-comment">/// and ```ColorType``` ```c```</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">encode</span>(<span class="hljs-keyword">self</span>, data: &amp;[<span class="hljs-type">u8</span>], width: <span class="hljs-type">u32</span>, height: <span class="hljs-type">u32</span>, color: ColorType) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>        <span class="hljs-keyword">let</span> (ct, bits) = color.<span class="hljs-title function_ invoke__">into</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">encoder</span> = png::Encoder::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">self</span>.w, width, height);<br>        encoder.<span class="hljs-title function_ invoke__">set</span>(ct).<span class="hljs-title function_ invoke__">set</span>(bits);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">writer</span> = <span class="hljs-built_in">try!</span>(encoder.<span class="hljs-title function_ invoke__">write_header</span>());<br>        writer.<span class="hljs-title function_ invoke__">write_image_data</span>(data).<span class="hljs-title function_ invoke__">map_err</span>(|e| e.<span class="hljs-title function_ invoke__">into</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>new(w)</code>: 传进目标 writer，即我们上面创建的<code>output</code>。</li><li><code>encode()</code>: 写入图片信息，这里有几个参数：<ul><li><code>width: u32</code>: 图片宽度。</li><li><code>height: u32</code>: 图片高度。</li><li><code>color: ColorType</code>: 颜色类型，可以是 RGB, Gray(8)等。</li><li><code>data: &amp;[u8]</code>: 像素色值列表，它的长度应该由上面 3个字段共同决定，如果选取的颜色是 RGB，意味着需要 3 个 u8才能表示一个像素点的颜色，所以长度为 width * height *3，如果选取的颜色是 Gray(8)，那么我们用 1 个 u8就可以表示一个像素点的灰度值，所以长度为 width * height *1。本文中我们会采用 Gray(8) 来汇总曼德博集的黑白图。</li></ul></li></ul><h2 id="渲染曼德博集">6. 渲染曼德博集</h2><p>这一步我们需要来确定上述 <code>PNGEncoder::encode()</code> 的 4个参数：</p><ul><li><p><code>width: u32</code>:图片宽度由命令行参数中指定即可。</p></li><li><p><code>height: u32</code>:图片高度由命令行参数中指定即可。</p></li><li><p><code>color: ColorType</code>: 本文我们只绘制黑白图，这里使用<code>ColorType::Gray(8)</code>，它表示图像是一个灰度（单色）图像，每个像素用8位（即1个字节）来表示。在这种格式中，每个像素的灰度值范围是0 到 255，其中 0 通常表示黑色，255表示白色，中间值表示不同的灰度。</p></li><li><p><code>data: &amp;[u8]</code>: 像素色值列表，我们需要确定 width *height 个像素的灰度值。</p><p>首先我们根据第 3 步将像素点映射成复数 <spanclass="math inline">\(c\)</span>，然后使用第 4 步中的<code>escape_time()</code> 函数来判断复数 <spanclass="math inline">\(c\)</span>是否位于曼德博集中，如果是，则着黑色，即赋值<code>0</code>，如果不是，则看它迭代了多少次才失败，次数越多，则越接近曼德博集，颜色越深，即越靠近0，所以赋值 <code>255-time</code>。</p></li></ul><p>最终我们实现的函数如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 将曼德博集对应的矩形渲染到像素缓冲区中</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// `bounds` 参数会给缓冲区 `pixels` 的宽度和高度，此缓冲区的每个字节都</span><br><span class="hljs-comment">/// 包含一个灰度像素。`upper_left` 和 `lower_right` 参数分别指定了</span><br><span class="hljs-comment">/// 复平面中对应于像素缓冲区左上角和右上角的点。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">render</span>(<br>    pixels: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>],<br>    bounds: (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>),<br>    upper_left: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>    lower_right: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>) &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(pixels.<span class="hljs-title function_ invoke__">len</span>(), bounds.<span class="hljs-number">0</span> * bounds.<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">raw</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..bounds.<span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">column</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..bounds.<span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">point</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (column, raw), upper_left, lower_right);<br>            pixels[raw * bounds.<span class="hljs-number">0</span> + column] = <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">escape_time</span>(point, <span class="hljs-number">255</span>) &#123;<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-number">0</span>,<br>                <span class="hljs-title function_ invoke__">Some</span>(count) =&gt; <span class="hljs-number">255</span> - count <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>,<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解析命令行参数">7. 解析命令行参数</h2><p>核心逻辑部分到这里其实就完成了，现在我们要做最后一步，就是解析命令行参数，让程序可以根据我们的要求绘制曼德博集图。</p><h3 id="解析-stdenvargs">7.1 解析 std::env::args()</h3><p>在 Rust中解析命令行参数的一个常用方法是使用<code>std::env::args</code>函数，这个函数返回一个迭代器，它包含了命令行上传递给程序的所有参数。对于更复杂的命令行参数解析，可以使用像<code>clap</code>或<code>structopt</code>这样的第三方库，这些库提供了更高级的功能和更好的错误处理。</p><p>下面是一个使用<code>std::env::args</code>的基本例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::env;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">args</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">arg</span> <span class="hljs-keyword">in</span> args.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基础版程序">7.2 基础版程序</h3><p>到这里，我们就可以实现完整的基础版程序了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 读取参数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">args</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>  <span class="hljs-comment">// 参数个数 = 1 + 4，其中第 1 个是应用程序名</span><br>    <span class="hljs-keyword">if</span> args.<span class="hljs-title function_ invoke__">len</span>() != <span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">eprintln!</span>(<span class="hljs-string">&quot;Usage: &#123;&#125; FILE PIXELS UPPERLEFT LOWERRIGHT&quot;</span>, args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">eprintln!</span>(<br>            <span class="hljs-string">&quot;Example: &#123;&#125; mandel.png 1000x700 -1.20,0.35 -1,0.20&quot;</span>,<br>            args[<span class="hljs-number">0</span>]<br>        );<br>        std::process::<span class="hljs-title function_ invoke__">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">// 解析参数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bounds</span> = <span class="hljs-title function_ invoke__">parse_pair</span>(&amp;args[<span class="hljs-number">2</span>], <span class="hljs-string">&#x27;x&#x27;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error parsing image dimensions&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">upper_left</span> = <span class="hljs-title function_ invoke__">parse_complex</span>(&amp;args[<span class="hljs-number">3</span>]).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error parsing upper left corner point&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lower_right</span> = <span class="hljs-title function_ invoke__">parse_complex</span>(&amp;args[<span class="hljs-number">4</span>]).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error parsing lower right corner point&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">pixels</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; bounds.<span class="hljs-number">0</span> * bounds.<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 渲染曼德博集</span><br>    <span class="hljs-title function_ invoke__">render</span>(&amp;<span class="hljs-keyword">mut</span> pixels, bounds, upper_left, lower_right);<br>  <span class="hljs-comment">// 输出图片</span><br>    <span class="hljs-title function_ invoke__">write_image</span>(&amp;args[<span class="hljs-number">1</span>], &amp;pixels, bounds).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error writing PNG file&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在项目根目录下编译一下程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build --release<br></code></pre></td></tr></table></figure><p>会在 target/release 下生成可执行文件，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20<br></code></pre></td></tr></table></figure><p>执行后你应该可以看到我们生成的曼德博集图如下：</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/mandel.png"alt="程序生成的曼德博集" /><figcaption aria-hidden="true">程序生成的曼德博集</figcaption></figure><p>大概是处于这个位置：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240118191624303.png"alt="程序截取的局部曼德博集处于整个曼德博集中的位置" /><figcaptionaria-hidden="true">程序截取的局部曼德博集处于整个曼德博集中的位置</figcaption></figure><h2 id="并发渲染">8. 并发渲染</h2><p>在 macOS 或 linux 系统下，我们可以使用 <code>time</code>来输出程序的执行时间：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">time ./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20<br>./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20  3.30s user 0.01s system 98% cpu 3.341 total<br></code></pre></td></tr></table></figure><p>笔者使用的电脑为 macbook Pro m2 max 芯片 32 G 内存 12核，可以看到在单核模式下，差不多需要 3~4s 的时间。</p><p>几乎所有的现代机器都有多个处理器核心，而当前这个程序只使用了一个。如果可以把此工作分派个机器提供的多个处理器核心，则应该可以更快地画完图像。</p><p>为此，我们可以将图像划分成多个部分，每个处理器负责其中的一个部分，并让每个处理器为分派给它的像素着色。为简单起见，可以将其分成一些水平条带，如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/CleanShot%202024-01-18%20at%2021.28.20.jpg"alt="将像素缓冲区划分为一些条带以进行并发渲染" /><figcaptionaria-hidden="true">将像素缓冲区划分为一些条带以进行并发渲染</figcaption></figure><p>crossbeam 是 Rust中的一个并发编程工具箱，它广泛用于提供各种并发和多线程编程的组件。</p><p><code>crossbeam::scope</code> 是 crossbeam提供的一个非常有用的功能，它允许你安全地创建临时的线程，并确保这些线程在离开作用域之前结束。</p><p>这里我们引入 crossbeam：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add crossbeam<br></code></pre></td></tr></table></figure><p>我们将 <code>fn main()</code> 中的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-title function_ invoke__">render</span>(&amp;<span class="hljs-keyword">mut</span> pixels, bounds, upper_left, lower_right);<br></code></pre></td></tr></table></figure><p>替换成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 8 个线程来并发执行</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">threads</span> = <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 计算每个线程负责渲染的高度，向上取整</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">rows_per_band</span> = bounds.<span class="hljs-number">1</span> / threads + <span class="hljs-number">1</span>;<br>&#123;<br>  <span class="hljs-comment">// chunks_mut() 会返回一个迭代器，该迭代器会生成此缓冲区的可变且不可迭代的切片</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bands</span>: <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>]&gt; = pixels.<span class="hljs-title function_ invoke__">chunks_mut</span>(rows_per_band * bounds.<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">collect</span>();<br>  <span class="hljs-comment">// crossbeam::scope 确保所有子线程在作用域结束之前完成，</span><br>  <span class="hljs-comment">// 这防止了悬垂指针和其他数据竞争问题。</span><br>    crossbeam::<span class="hljs-title function_ invoke__">scope</span>(|spawner| &#123;<br>      <span class="hljs-comment">// 遍历像素缓冲区的各个条带，</span><br>      <span class="hljs-comment">// 这里 into_iter() 迭代器会为循环体的每次迭代赋予独占一个条带的所有权，</span><br>      <span class="hljs-comment">// 确保一次只有一个线程可以写入它。</span><br>        <span class="hljs-keyword">for</span> (i, band) <span class="hljs-keyword">in</span> bands.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>          <span class="hljs-comment">// 确定每个条带的参数</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">top</span> = rows_per_band * i;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">height</span> = band.<span class="hljs-title function_ invoke__">len</span>() / bounds.<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">band_bounds</span> = (bounds.<span class="hljs-number">0</span>, height);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">band_upper_left</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (<span class="hljs-number">0</span>, top), upper_left, lower_right);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">band_lower_right</span> =<br>                <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (bounds.<span class="hljs-number">0</span>, top + height), upper_left, lower_right);<br>          <span class="hljs-comment">// 创建一个线程，渲染图像</span><br>          <span class="hljs-comment">// move 表示这个闭包会接手它所用遍历的所有权，</span><br>          <span class="hljs-comment">// 所以只有此闭关，即只有此线程可以使用可变切片 band。</span><br>            spawner.<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> |_| &#123;<br>                <span class="hljs-title function_ invoke__">render</span>(band, band_bounds, band_upper_left, band_lower_right);<br>            &#125;);<br>        &#125;<br>    &#125;)<br>    .<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>再次执行：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">time ./<span class="hljs-keyword">target</span>/<span class="hljs-keyword">release</span>/mandelbrot mandel.png <span class="hljs-number">4000</span><span class="hljs-keyword">x</span><span class="hljs-number">3000</span> <span class="hljs-number">-1.20</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.35</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.20</span><br>./<span class="hljs-keyword">target</span>/<span class="hljs-keyword">release</span>/mandelbrot mandel.png <span class="hljs-number">4000</span><span class="hljs-keyword">x</span><span class="hljs-number">3000</span> <span class="hljs-number">-1.20</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.35</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.20</span>  <span class="hljs-number">3.57</span>s user <span class="hljs-number">0.01</span>s system <span class="hljs-number">335</span>% cpu <span class="hljs-number">1.067</span> total<br></code></pre></td></tr></table></figure><p>可以看到虽然总共使用的 CPU 时间还是3~4s，但是整个程序的执行时间只缩短到 1s 左右了。</p><h2 id="rayon-工作窃取">9. rayon 工作窃取</h2><p>前面我们使用 8 个工作线程优化了曼德博集的绘制速度，大概是 4倍的速度提升。其实这还不够快。</p><p>问题的根源在于我们没有平均分配工作量。计算图像的一个像素相当于运行一个循环。事实上，图像的浅灰色部分（循环会快速退出的地方）比黑色部分（循环会运行整整255次迭代的地方）渲染速度要快得多。因此，虽然我们将整个区域划分成了大小相等的水平条带，但创建了不均等的工作负载，</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image00879.jpeg"alt="曼德博集程序中的工作分配不均等" /><figcaptionaria-hidden="true">曼德博集程序中的工作分配不均等</figcaption></figure><p>使用 rayon很容易解决这个问题。我们可以为输出中的每一行像素启动一个并行任务。这会创建数百个任务，而rayon可以在其线程中分配这些任务。有了工作窃取机制，任务的规模是无关紧要的。rayon会对这些工作进行平衡。</p><p>我们先引入 <code>rayon</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add rayon<br></code></pre></td></tr></table></figure><p>在 <code>main.rs</code> 中引入 <code>rayon</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rayon::prelude::*;<br></code></pre></td></tr></table></figure><p>然后 <code>main</code> 中并发绘制的部分替换为下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">bands</span>: <span class="hljs-type">Vec</span>&lt;(<span class="hljs-type">usize</span>, &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>])&gt; = pixels.<span class="hljs-title function_ invoke__">chunks_mut</span>(bounds.<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">enumerate</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><br>bands.<span class="hljs-title function_ invoke__">into_par_iter</span>().for_each(|(i, band)| &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">top</span> = i;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">band_bounds</span> = (bounds.<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">band_upper_left</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (<span class="hljs-number">0</span>, top), upper_left, lower_right);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">band_lower_right</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (bounds.<span class="hljs-number">0</span>, top + <span class="hljs-number">1</span>), upper_left, lower_right);<br>    <span class="hljs-title function_ invoke__">render</span>(band, band_bounds, band_upper_left, band_lower_right);<br>&#125;);<br></code></pre></td></tr></table></figure><p>首先，创建 bands，也就是要传给 rayon的任务集合。每个任务只是一个元组类型 (usize, &amp;mut[u8])：第一个是计算所需的行号，第二个是要填充的 pixels 切片。我们使用chunks_mut 方法将图像缓冲区分成一些行，enumerate则会给每一行添加行号，然后 collect会将所有数值切片对放入一个向量中。（这里需要一个向量，因为 rayon只能从数组和向量中创建并行迭代器。）</p><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build --release<br></code></pre></td></tr></table></figure><p>再次执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">time ./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20<br>./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20  3.96s user 0.01s system 973% cpu 0.408 total<br></code></pre></td></tr></table></figure><p>可以看到，这次速度提升更加明显，总共只用了 0.4s 左右的时间。</p><p>以上就是实用 Rust 绘制曼德博集实战的全部内容，enjoy，happycoding~</p>]]></content>
    
    
    <summary type="html">本文参考《Rust 程序设计（第二版）》中第二章的示例，与读者分享**曼德博集**的绘制过程。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
</feed>
