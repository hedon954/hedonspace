<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HedonWang</title>
  
  <subtitle>君子求诸己，律己则安。</subtitle>
  <link href="https://hedon.top/atom.xml" rel="self"/>
  
  <link href="https://hedon.top/"/>
  <updated>2025-04-05T14:58:50.094Z</updated>
  <id>https://hedon.top/</id>
  
  <author>
    <name>Hedon Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 知识图谱</title>
    <link href="https://hedon.top/2025/04/05/python-mindmap/"/>
    <id>https://hedon.top/2025/04/05/python-mindmap/</id>
    <published>2025-04-05T12:00:24.000Z</published>
    <updated>2025-04-05T14:58:50.094Z</updated>
    
    <content type="html"><![CDATA[<figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/2cfc18adf51b61ca8140561071d20c1d.png"alt="python-mindmap" /><figcaption aria-hidden="true">python-mindmap</figcaption></figure>]]></content>
    
    
    <summary type="html">本文梳理了 Python 的知识。</summary>
    
    
    
    <category term="python" scheme="https://hedon.top/categories/python/"/>
    
    <category term="mindmap" scheme="https://hedon.top/categories/python/mindmap/"/>
    
    
    <category term="python" scheme="https://hedon.top/tags/python/"/>
    
    <category term="mindmap" scheme="https://hedon.top/tags/mindmap/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《Unit Testing Principles, Practices, and Patterns》</title>
    <link href="https://hedon.top/2025/03/21/note-unit-testing/"/>
    <id>https://hedon.top/2025/03/21/note-unit-testing/</id>
    <published>2025-03-21T05:19:20.000Z</published>
    <updated>2025-04-05T14:31:32.877Z</updated>
    
    <content type="html"><![CDATA[<div class="tag-plugin quot"><h2 class="content" id="揪心疑惑" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">揪心疑惑</span><span class="empty"></span></h2></div><p>在撰写单元测试的过程中，你是否曾经被以下问题困扰过？</p><ol type="1"><li>为什么要写单元测试？单元测试的目标是什么？</li><li>单元测试的粒度是怎样的？什么叫单元？a class, a function, or abehavior, or an observable behavior?</li><li>单测覆盖率真的有用吗？有什么用？又有哪些限制？</li><li>怎样才能写好单元测试？怎样才能写出性价比最高的单元测试？</li><li>如何判断一个单元测试的好坏？有没有具体可供参阅的维度？</li><li>哪些代码需要写单元测试，哪些代码没必要写单元测试？</li><li>单元测试和集成测试的边界是什么？</li><li>（单元丨集成）测试到底是要测什么东西？</li><li>单元测试的侧重点是什么？集成测试的侧重点是什么？二者的比例该是怎样的？</li><li>如何使用 Mock？哪些东西是需要 Mock 的？哪些东西是不应该 Mock的？需要 Mock 的东西，应该在哪个层次进行 Mock？（你的 repository 层需要Mock 吗？）</li><li>为什么你的测试代码很脆弱，总是需要频繁修改，维护起来难度很大？</li><li>如何减少测试结果的假阳性和假阴性？</li></ol><div class="tag-plugin quot"><h2 class="content" id="四根柱子" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">四根柱子</span><span class="empty"></span></h2></div><p>对于第 5 个问题，作者提出了 4 个维度：</p><ul><li><strong>Protection againstregressions：防止回归</strong>，通过自动化验证代码修改后原有功能不受破坏。<ul><li><em>The amount of code that is executed during the test.</em></li><li><em>The complexity of that code.</em></li><li><em>The code’s domain significance.</em></li></ul></li><li><strong>Resistance torefactoring：抗重构性</strong>，重构业务代码时，测试代码无需过多变动便可通过用例，证明重构无误。<ul><li><em>Tests provide an early warning when you break existingfunctionality</em>.</li><li><em>You become confident that your code changes won’t lead toregressions</em>.</li></ul></li><li><strong>Fast feedback：快速反馈</strong>。</li><li><strong>Maintainability：可维护性</strong>。<ul><li><em>How hard it is to understand the test.</em></li><li><em>How hard it is to run the test.</em></li></ul></li></ul><p>对于这 4 个问题，你是否又有以下疑问：</p><ol type="1"><li>哪个维度是最重要的？</li><li>怎样才能写出满足各个维度的测试代码？</li><li>如果维度之间存在矛盾，如何 trade off？</li></ol>]]></content>
    
    
    <summary type="html">本文总结了读者在阅读《Unit Testing》书籍中的收获和思考。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>后端开发之路</title>
    <link href="https://hedon.top/2025/03/17/backend-road/"/>
    <id>https://hedon.top/2025/03/17/backend-road/</id>
    <published>2025-03-17T12:00:24.000Z</published>
    <updated>2025-04-05T14:31:32.871Z</updated>
    
    <content type="html"><![CDATA[<style>svg.markmap {        width: 100%;        height: 100vh;      }</style><div class="markmap" id="markmap-2779b510-9c56-46a4-a997-aec8fa005cfa">  <script type="text/template">- 后端开发之路  - 基础知识    - 计算机基础    - 网络基础    - 数据库基础    - 操作系统基础    - 编程语言基础  - 编程语言    - Java    - Python    - Node.js    - Go    - PHP    - Ruby    - C#    - C++    - C    - JavaScript    - TypeScript    - Kotlin    - Swift  - 框架    - Spring Boot    - Django    - Flask    - Express    - Koa    - Nest.js  - 数据库    - MySQL    - PostgreSQL    - MongoDB    - Redis    - SQLite    - Oracle  - 中间件    - Nginx    - Apache    - Tomcat    - Jetty    - Undertow  - 设计模式    - 单例模式    - 工厂模式    - 观察者模式    - 策略模式    - 装饰器模式    - 适配器模式    - 门面模式  - 架构模式    - 微服务架构    - 事件驱动架构    - 发布订阅架构    - 流式处理架构    - 服务网格架构  - 性能优化    - 代码优化    - 数据库优化    - 缓存优化    - 异步编程    - 并发编程    - 多线程编程    - 分布式编程    - 高可用性设计  </script></div>  ]]></content>
    
    
    <summary type="html">本文介绍了后端开发的成长道路</summary>
    
    
    
    <category term="roadmap" scheme="https://hedon.top/categories/roadmap/"/>
    
    
    <category term="roadmap" scheme="https://hedon.top/tags/roadmap/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 博客中优雅地集成 Markmap 思维导图</title>
    <link href="https://hedon.top/2025/03/17/mindmap-for-hexo/"/>
    <id>https://hedon.top/2025/03/17/mindmap-for-hexo/</id>
    <published>2025-03-17T10:21:18.000Z</published>
    <updated>2025-04-05T14:31:32.876Z</updated>
    
    <content type="html"><![CDATA[<p>在技术博客写作中，思维导图是一个非常有用的工具，它可以帮助我们更清晰地展示知识结构和概念关系。本文将介绍如何在Hexo 博客中集成 Markmap，让你能够直接在 Markdown文件中创建交互式思维导图。</p><h2 id="什么是-markmap">什么是 Markmap？</h2><p>Markmap 是一个将 Markdown格式的文本转换为思维导图的开源工具。它允许我们使用熟悉的 Markdown语法来创建漂亮的、交互式的思维导图。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://markmap.js.org/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://markmap.js.org/" autofill="title,icon"><div class="left"><span class="title">https://markmap.js.org/</span><span class="cap link footnote">https://markmap.js.org/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><h2 id="实现方案">实现方案</h2><h3 id="安装必要依赖">1. 安装必要依赖</h3><p>首先，我们需要安装 <code>uuid</code>包，这是用来给我们每一个思维导图生成一个唯一的 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uuid --save</span><br></pre></td></tr></table></figure><h3 id="创建自定义标签插件">2. 创建自定义标签插件</h3><p>在 <code>scripts/markmap_tag.js</code> 中创建自定义标签：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Markmap Tag Plugin for Hexo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">v4</span>: uuidv4 &#125; = <span class="built_in">require</span>(<span class="string">&quot;uuid&quot;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(</span><br><span class="line">  <span class="string">&quot;markmap&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">args, content</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">uuidv4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div class=&quot;markmap&quot; id=&quot;markmap-<span class="subst">$&#123;id&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;script type=&quot;text/template&quot;&gt;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;content&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123;</span></span><br><span class="line"><span class="string">  const template = document.querySelector(&#x27;#markmap-<span class="subst">$&#123;id&#125;</span> script[type=&quot;text/template&quot;]&#x27;);</span></span><br><span class="line"><span class="string">  if (template) &#123;</span></span><br><span class="line"><span class="string">    const content = template.textContent;</span></span><br><span class="line"><span class="string">    window.markmap.autoLoader.renderString(content, null, document.querySelector(&#x27;#markmap-<span class="subst">$&#123;id&#125;</span>&#x27;));</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">ends</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="添加样式">3. 添加样式</h3><p>创建 <code>source/css/markmap.css</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Markmap Styles */</span></span><br><span class="line"><span class="selector-class">.markmap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eaeaea</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.markmap</span> <span class="selector-tag">svg</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 响应式设计 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.markmap</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">480px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.markmap</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新主题配置">4. 更新主题配置</h3><p>在主题配置文件中添加必要的资源引用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/markmap.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/npm/markmap-autoloader@0.18&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用方法">使用方法</h2><div class="tag-plugin tabs" align="center"id="tab_1"><div class="nav-tabs"><div class="tab active"><a href="#tab_1-1">代码块</a></div><div class="tab"><a href="#tab_1-2">效果</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_1-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% markmap %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 技术栈</span><br><span class="line"><span class="bullet">  -</span> 前端</span><br><span class="line"><span class="bullet">    -</span> Vue.js</span><br><span class="line"><span class="bullet">    -</span> React</span><br><span class="line"><span class="bullet">    -</span> Angular</span><br><span class="line"><span class="bullet">  -</span> 后端</span><br><span class="line"><span class="bullet">    -</span> Node.js</span><br><span class="line"><span class="bullet">    -</span> Python</span><br><span class="line"><span class="bullet">    -</span> Go</span><br><span class="line"><span class="bullet">  -</span> 数据库</span><br><span class="line"><span class="bullet">    -</span> MySQL</span><br><span class="line"><span class="bullet">    -</span> MongoDB</span><br><span class="line"><span class="bullet">    -</span> Redis</span><br><span class="line"></span><br><span class="line">&#123;% endmarkmap %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab_1-2"><style>svg.markmap {        width: 100%;        height: 500px;      }</style><div id="markmap-45ef1592-03f1-4b9c-b508-dc8096fc345b" class="markmap"><script type="text/template">- 技术栈  - 前端    - Vue.js    - React    - Angular  - 后端    - Node.js    - Python    - Go  - 数据库    - MySQL    - MongoDB    - Redis  </script></div></div></div></div><h2 id="工作原理">工作原理</h2><h3 id="hexo-插件系统">1. Hexo 插件系统</h3><ul><li>Hexo 提供了强大的插件系统，允许我们通过 <code>hexo.extend</code> API来扩展功能</li><li>我们使用了 <code>hexo.extend.tag</code> 来注册自定义标签，这是 Hexo提供的标准扩展点之一</li></ul><h3 id="标签插件的工作原理">2. 标签插件的工作原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(</span><br><span class="line">  <span class="string">&quot;markmap&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">args, content</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">uuidv4</span>(); <span class="comment">// 生成唯一ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;markmap&quot; id=&quot;markmap-<span class="subst">$&#123;id&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;script type=&quot;text/template&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;content&#125;</span></span></span><br><span class="line"><span class="string">      &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">ends</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>当 Hexo 解析到 <code>markmap</code>标签时，会调用这个注册的函数</li><li><code>content</code> 参数包含了标签之间的所有内容（你的 markdown结构）</li><li><code>&#123;ends: true&#125;</code> 表示这是一个闭合标签（需要 endmarkmap结束）</li></ul><h3 id="markmap-库的渲染过程">3. Markmap 库的渲染过程</h3><ul><li>Markmap 库使用 <code>markmap-autoloader</code> 自动处理 markdown到思维导图的转换</li><li>转换过程：<ol type="1"><li>Markdown 文本被解析成层级结构</li><li>层级结构被转换为 SVG 路径</li><li>SVG 被渲染到页面上，并添加交互功能</li></ol></li></ul><h3 id="html-结构设计">4. HTML 结构设计</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;markmap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;markmap-$&#123;id&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/template&quot;</span>&gt;</span></span><br><span class="line">    $&#123;content&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>script type="text/template"</code> 来存储原始markdown</li><li>每个思维导图都有唯一 ID，避免页面上多个图表互相干扰</li></ul><h3 id="javascript-初始化">5. JavaScript 初始化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> template = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(</span><br><span class="line">    <span class="string">&#x27;#markmap-$&#123;id&#125; script[type=&quot;text/template&quot;]&#x27;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (template) &#123;</span><br><span class="line">    <span class="keyword">const</span> content = template.<span class="property">textContent</span>;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">markmap</span>.<span class="property">autoLoader</span>.<span class="title function_">renderString</span>(</span><br><span class="line">      content,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#markmap-$&#123;id&#125;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>等待页面加载完成</li><li>获取模板中的 markdown 内容</li><li>使用 markmap 库渲染思维导图</li></ul><h3 id="样式控制">6. 样式控制</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.markmap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eaeaea</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>提供响应式布局</li><li>确保思维导图在各种屏幕尺寸下都能正常显示</li></ul><h3 id="主题集成">7. 主题集成</h3><ul><li>在主题配置中注入必要的 CSS 和 JavaScript</li><li>确保资源在正确的时机加载</li></ul>]]></content>
    
    
    <summary type="html">本文详细介绍了如何在 Hexo 博客中优雅地集成 Markmap 思维导图，让你能够直接在 Markdown 文件中创建交互式思维导图。同时这也是一个 Hexo 插件的标准实现案例。</summary>
    
    
    
    <category term="小技术" scheme="https://hedon.top/categories/%E5%B0%8F%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="hexo" scheme="https://hedon.top/tags/hexo/"/>
    
    <category term="markmap" scheme="https://hedon.top/tags/markmap/"/>
    
  </entry>
  
  <entry>
    <title>为什么 OpenTelemetry 的 SDK 中不支持尾采样 Hook？</title>
    <link href="https://hedon.top/2025/03/13/opentelemetry-tail-sampler/"/>
    <id>https://hedon.top/2025/03/13/opentelemetry-tail-sampler/</id>
    <published>2025-03-13T07:10:27.000Z</published>
    <updated>2025-04-05T14:31:32.877Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式追踪系统中，采样策略直接影响着系统的性能和可观测性。OpenTelemetry作为当前最流行的可观测性框架，其采样机制设计有着深刻的考量。本文将深入探讨OpenTelemetry 的采样机制，特别是为什么它在 SDK 层面不支持尾采样。</p><h2 id="前置采样-vs-尾采样">前置采样 vs 尾采样</h2><p>在讨论 OpenTelemetry的采样机制前，我们需要理解两种主要的采样策略：</p><p><strong>前置采样（Head-based Sampling）</strong>：</p><ul><li>在链路开始时就决定是否采样</li><li>决策一旦做出，整个链路都遵循这个决策</li><li>不需要缓存完整的链路数据</li></ul><p><strong>尾采样（Tail-based Sampling）</strong>：</p><ul><li>在链路结束后决定是否保留</li><li>可以基于完整链路信息（如总耗时、是否有错误）做决策</li><li>需要临时缓存所有链路数据</li></ul><h2 id="opentelemetry-的采样实现">OpenTelemetry 的采样实现</h2><p>通过分析 <ahref="https://github.com/open-telemetry/opentelemetry-go/blob/v1.35.0/sdk/trace/tracer.go#L65">OpenTelemetryGo SDK的源码</a>，我们可以清晰地看到它采用的是前置采样策略。关键代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tr *tracer)</span></span> newSpan(ctx context.Context, name <span class="type">string</span>, config *trace.SpanConfig) trace.Span &#123;</span><br><span class="line">    <span class="comment">// ... 前面的代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行采样决策</span></span><br><span class="line">    samplingResult := tr.provider.sampler.ShouldSample(SamplingParameters&#123;</span><br><span class="line">        ParentContext: ctx,</span><br><span class="line">        TraceID:       tid,</span><br><span class="line">        Name:          name,</span><br><span class="line">        Kind:          config.SpanKind(),</span><br><span class="line">        Attributes:    config.Attributes(),</span><br><span class="line">        Links:         config.Links(),</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置采样标志</span></span><br><span class="line">    <span class="keyword">if</span> isSampled(samplingResult) &#123;</span><br><span class="line">        scc.TraceFlags = psc.TraceFlags() | trace.FlagsSampled</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scc.TraceFlags = psc.TraceFlags() &amp;^ trace.FlagsSampled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 后面的代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码揭示了几个关键点：</p><ol type="1"><li>采样决策在 span 创建时就已经做出</li><li>采样标志通过位操作设置在 TraceFlags 中</li><li>这个标志会随着 SpanContext 传播到整个分布式系统</li></ol><h2 id="采样标志的传播机制">采样标志的传播机制</h2><p>特别值得注意的是设置采样标志的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> isSampled(samplingResult) &#123;</span><br><span class="line">    scc.TraceFlags = psc.TraceFlags() | trace.FlagsSampled</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scc.TraceFlags = psc.TraceFlags() &amp;^ trace.FlagsSampled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用位操作来设置或清除采样标志：</p><ul><li><code>|</code> 操作用于设置采样标志，保留其他标志位不变</li><li><code>&amp;^</code>操作用于清除采样标志，同样保留其他标志位不变</li></ul><p>这确保了采样决策能够一致地传播到整个分布式链路中。</p><h2 id="为什么-opentelemetry-不支持尾采样">为什么 OpenTelemetry不支持尾采样？</h2><p>最重要的原因是：<font color="red">在 SDK中找不到尾巴！因为不知道链路什么时候结束！</font></p><p>在分布式系统中，一条链路可能跨越多个服务，所以你在某一个服务中，是不知道链路是否结束的，而OpenTelemetry 也不是一次性上报一整条链路，而是每个 <code>span</code>独立上报，最后再拼接到一起。</p><h3 id="opentelemetry-上报原理">OpenTelemetry 上报原理</h3><ol type="1"><li><p>独立上报</p><ul><li><p>每个 <code>span</code> 在结束时（调用<code>span.End()</code>）会被传递给 <code>SpanProcessor</code></p></li><li><p><code>SpanProcessor</code> 决定如何处理这个<code>span</code>（立即导出或批量导出）</p></li><li><p>导出是独立的，不会等待整个 <code>trace</code> 完成</p></li></ul></li><li><p>批处理机制</p><ul><li><p>默认使用 <code>BatchSpanProcessor</code>，它会收集一定数量的<code>spans</code> 或等待一定时间然后批量导出</p></li><li><p>但这个批处理与 <code>trace</code>完整性无关，只是为了效率</p></li></ul></li></ol><h3 id="collector-如何实现尾采样">Collector 如何实现尾采样</h3><p>Collector 通过以下方式解决这些问题：</p><ol type="1"><li><p>设置等待时间窗口</p><ul><li><p>为每个 trace 设置一个等待期（如 10 秒）</p></li><li><p>在此期间收集该 trace 的所有 spans</p></li><li><p><strong>超过等待期后，基于已收集的 spans 做决策</strong></p></li></ul></li><li><p>集中式收集</p><ul><li><p>所有服务的 spans 都发送到 Collector</p></li><li><p>Collector 有更全面的视图来关联 spans</p></li></ul></li><li><p>专门的资源分配：Collector作为独立组件，有专门的资源处理这种复杂逻辑，不会影响应用性能。</p></li></ol><h2 id="如何在-opentelemetry-生态中实现尾采样">如何在 OpenTelemetry生态中实现尾采样？</h2><p>虽然 SDK 不直接支持尾采样，但 OpenTelemetry生态提供了其他方式实现类似功能：</p><h3 id="使用-opentelemetry-collector">1. 使用 OpenTelemetryCollector</h3><p>Collector 提供了 Tail SamplingProcessor，可以在数据聚合层实现尾采样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">tail_sampling:</span></span><br><span class="line">    <span class="attr">decision_wait:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">num_traces:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">expected_new_traces_per_sec:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">policies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">error-policy</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">status_code</span></span><br><span class="line">        <span class="attr">status_code:</span> <span class="string">ERROR</span></span><br></pre></td></tr></table></figure><h3 id="结合前置采样和错误捕获">2. 结合前置采样和错误捕获</h3><p>可以实现一个智能的前置采样器，对特定场景（如包含错误属性）强制采样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SmartSampler <span class="keyword">struct</span> &#123;</span><br><span class="line">    baseSamplingRate <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartSampler)</span></span> ShouldSample(p trace.SamplingParameters) trace.SamplingResult &#123;</span><br><span class="line">    <span class="comment">// 错误请求必采样</span></span><br><span class="line">    <span class="keyword">for</span> _, attr := <span class="keyword">range</span> p.Attributes &#123;</span><br><span class="line">        <span class="keyword">if</span> attr.Key == <span class="string">&quot;error&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> trace.SamplingResult&#123;Decision: trace.RecordAndSample&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他请求使用基础采样率</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">float64</span>(p.TraceID[<span class="number">0</span>])/<span class="number">255.0</span> &lt; s.baseSamplingRate &#123;</span><br><span class="line">        <span class="keyword">return</span> trace.SamplingResult&#123;Decision: trace.RecordAndSample&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> trace.SamplingResult&#123;Decision: trace.Drop&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用专门的后端系统">3. 使用专门的后端系统</h3><p>一些专门的可观测性后端系统提供了尾采样功能：</p><ul><li><p>Jaeger 的 Adaptive Sampling</p></li><li><p>SkyWalking 的 Trace Sampling</p></li><li><p>Grafana Tempo 的 Trace Sampling</p></li></ul><h2 id="结论">结论</h2><p>OpenTelemetry SDK采用前置采样而非尾采样，是基于分布式系统一致性、性能优化和架构分层等多方面考虑的结果。虽然这意味着无法基于完整链路信息做采样决策，但OpenTelemetry 生态提供了多种方式来弥补这一限制。</p><p>在实际应用中，我们可以：</p><ol type="1"><li>在 SDK 层使用智能前置采样策略，确保关键链路被采样</li><li>在 Collector 层实现尾采样，进一步筛选有价值的链路</li><li>结合使用多种采样策略，平衡性能和可观测性</li></ol><p>通过这种分层设计，OpenTelemetry既保证了高效的数据收集，又为高级采样策略提供了可能性，满足了不同场景的需求。</p><div class="tag-plugin quot"><h2 class="content" id="实战案例" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">实战案例</span><span class="empty"></span></h2></div><p>笔者实现一个 Go 语言的开源项目 <code>goapm</code>，对多个 Go语言中常用的组件进行了 trace、log 和 metrics 的集成封装，用于快速在 Go语言项目中实现可观测性，同时还提供了 <code>goapm-example</code>实战案例，可供参考。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/goapm" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/goapm" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/goapm</span><span class="cap link footnote">https://github.com/hedon954/goapm</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/goapm-example" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/goapm-example" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/goapm-example</span><span class="cap link footnote">https://github.com/hedon954/goapm-example</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div>]]></content>
    
    
    <summary type="html">本文介绍了 OpenTelemetry 的采样机制，特别是为什么它在 SDK 层面不支持尾采样。</summary>
    
    
    
    <category term="服务监控" scheme="https://hedon.top/categories/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
    
    <category term="opentelemetry" scheme="https://hedon.top/tags/opentelemetry/"/>
    
    <category term="服务监控" scheme="https://hedon.top/tags/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《悟道领域驱动设计》</title>
    <link href="https://hedon.top/2025/03/11/note-ddd-awareness/"/>
    <id>https://hedon.top/2025/03/11/note-ddd-awareness/</id>
    <published>2025-03-11T06:45:32.000Z</published>
    <updated>2025-04-05T14:31:32.877Z</updated>
    
    <content type="html"><![CDATA[<div class="tag-plugin quot"><h2 class="content" id="思维转变" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">思维转变</span><span class="empty"></span></h2></div><p>领域驱动设计（Domain-Driven Design，以下简称DDD）的核心价值在于其对「业务领域」的深度聚焦。这里的「领域」并非单纯的技术范畴，而是指代软件系统所要映射的现实业务场景及其核心价值主张。DDD通过建立与业务高度契合的领域模型，使得技术实现与业务本质形成同频共振，从而有效解决复杂业务场景下的认知鸿沟问题。</p><p>在 VUCA（Volatile 易变性、Uncertain 不确定性、Complex复杂性、Ambiguous模糊性）特征愈发显著的现代商业环境中，任何架构设计都面临固有局限。这种局限性既源于业务需求本身的动态演进，也受制于人类认知的有限性——正如Eric Evans在开山之作中强调的“<strong>模型永远是对现实的近似抽象</strong>”。但正是这种局限性，凸显了DDD 方法论的战略意义：</p><div class="tag-plugin colorful note" color="blue"><div class="body"><p>它通过"战略设计"构建业务全景图，运用限界上下文划定领域边界，通过"战术设计"落地聚合根、实体/值对象等模式，形成应对复杂性的结构化解决方案。</p></div></div><p>需要特别指出的是，DDD的复杂性并非方法论本身的缺陷，而是其应对现实业务复杂度的必要代价。这种复杂性体现在三个维度：</p><ol type="1"><li><strong>认知复杂性</strong>：要求开发团队与领域专家共建"通用语言"，实现业务概念与代码模型的精准映射。</li><li><strong>架构复杂性</strong>：通过分层架构实现业务逻辑与技术实现的解耦，采用防腐层处理系统集成问题。</li><li><strong>演进复杂性</strong>：借助子域划分和上下文映射，为持续演进的业务提供可扩展的架构基础。</li></ol><p>对于实践者而言，DDD 的价值不在于提供完美无缺的终极方案，而是为 VUCA环境下的系统建设提供基础性指引。其核心思想——无论是通过限界上下文实现的领域自治，还是通过聚合根维护的业务一致性——都为控制软件熵增提供了可落地的模式库。即便不完全采用DDD完整体系，其领域建模思想、分层架构理念等核心要素，仍能显著提升复杂系统的可维护性和演进能力。这种开放包容的哲学，恰是DDD 历经二十年仍保持生命力的关键所在。</p><h3 id="贫血模型-vs.-充血模型">贫血模型 vs. 充血模型</h3><ul><li>贫血模型：指的是只有属性而没有行为的模型。</li><li>充血模型：指的是既有属性又有行为的模型。</li></ul><p>笔者过往的实践中，基本上都使用类似于<code>controller→service→repository[model]</code> 的三层架构：</p><ul><li><code>conrtoller</code> 负责暴露对外接口。</li><li><code>service</code> 负责执行所有的业务逻辑。</li><li><code>repository</code> 复杂数据的存储和缓存，包含数据对象<code>model</code> 的定义。</li></ul><p>在这个模式下，基本上所有的核心逻辑都充斥在 <code>service</code>层中，所以 <code>service</code>层一般都会非常大，它要扮演多面手，即要负责跟各个模块协作，还要负责处理具体的业务规则，最终完成一个业务行为。这个过程中，<code>model</code>即为贫血模型，因为逻辑都给 <code>service</code>处理了，这种架构也称为<strong>贫血三层架构</strong>。</p><p>在 DDD的理念下，很多的核心业务概念都会被建模为「领域对象」，这些「领域对象」本身就是一种业务规则的体现，所以把业务的处理逻辑，都归属到这些「领域对象」的行为当中了，即所谓的充血模型。</p><p>在这个理念下，一个优化后的<strong>充血四层架构</strong>如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250311152623058.png"alt="充血四层架构" /><figcaption aria-hidden="true">充血四层架构</figcaption></figure><p>贫血模型推荐场景：业务简单、迭代快速、团队技术栈偏传统（如 SpringBoot+MyBatis）时，避免过度设计。</p><p>充血模型推荐场景：业务复杂、需长期演进（如核心交易系统）、团队具备DDD 经验时，通过实体、值对象、领域服务等战术设计理念降低系统熵增。</p><p>混合使用的场景：部分核心领域用充血模型（如订单、支付），非核心模块用贫血模型（如日志、配置），平衡效率与质量。</p><p>实际上，充血模型因其状态完整，适合进行<strong>状态变更类</strong>的操作，以确保业务操作符合领域规则；贫血模型由于其轻量级，更适合作为不会涉及状态变更的操作的数据容器。这其实就是CQRS 的理念。</p><div class="tag-plugin quot"><h2 class="content" id="概念清单" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">概念清单</span><span class="empty"></span></h2></div><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/ddd.jpg" /></p><h3 id="战术设计">战术设计</h3><details class="tag-plugin colorful folding" ><summary><p>实体</p></summary><div class="body"><p><strong>定义</strong>：会随着业务变化发生变化的业务概念叫作实体对象。</p><p><strong>关键点</strong>：实体需要唯一表示</p></div></details><details class="tag-plugin colorful folding" ><summary><p>值对象</p></summary><div class="body"><p><strong>定义</strong>：一些对象在表达业务概念时是必须的，可业务并不围绕着它们进行，它们仅是对这些重要业务概念的描述，这一类对象叫作值对象。</p><p><strong>关键点</strong>：</p><ol type="1"><li>值对象的意义取决于属性，只要对象的属性一模一样，那么对象就是相同的。</li><li>尽量把值对象实现为不可变对象。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>领域服务</p></summary><div class="body"><p><strong>定义</strong>：领域服务自身是没有数据的，只是表达了某种业务计算逻辑，或者业务的某种策略。</p><p><strong>关键点</strong>：</p><ol type="1"><li>领域服务是无状态的。</li><li>只有在确实表达了一个相对独立的业务概念或者业务策略，并且不能简单地把它归结到某个既有的业务对象上时，才是一个真正的领域服务。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>领域事件</p></summary><div class="body"><p><strong>定义</strong>：领域事件代表从业务专家视角看到的某种重要的事情发生了。</p><p><strong>关键点</strong>：</p><ol type="1"><li>领域事件是一种特殊的值对象。</li><li>应该根据限界上下文中的通用语言来命名事件：AccountActivited。</li><li>应该将事件建模成值对象或贫血对象。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>聚合</p></summary><div class="body"><p><strong>定义</strong>：聚合从本质上讲是在基础的构造块上增加了一层边界，用边界把那些紧密相关的对象放到了一起。</p><p><strong>关键点</strong>：</p><ol type="1"><li>紧密相关的对象存在数据一致性问题；</li><li>缺乏边界时，维护数据一致性是困难的；</li><li>划分边界的关键在于既不要让整个系统成为一个整体，又让每个单独划分出的聚合具有明确的业务意义；</li><li>聚合需要关注三条法则：<ol type="1"><li>生命周期一致性：如果一个对象在聚合根消失之后仍然有意义，那么说明此时在系统中必然存在能够访问该对象的方法。这和聚合的定义矛盾，所以聚合内的其他元素必然在聚合根消失后失效。</li><li>问题域一致性：不属于同一个问题域的对象，不应该出现在同一个聚合中。</li><li>尽量小的聚合：聚合的本质作用是提升对象系统的粒度，确保一致性、降低复杂度。不过，粒度绝不是越大越好。如果聚合的粒度太大，那内部的逻辑复杂度也会大大增加还会影响到复用度。因此，要能够比较容易地断开聚合。</li></ol></li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>资源库</p></summary><div class="body"><p><strong>定义</strong>：对于查询、创建、修改、删除数据的操作，领域模型使用“资源库(Repository)”这个概念来承载它们。</p><p><strong>关键点</strong>：一个聚合对应一个资源库，应以聚合根命名资源库，除了聚合根之外的其他对象，都不应该提供资源库对象。</p></div></details><details class="tag-plugin colorful folding" ><summary><p>工厂</p></summary><div class="body"><p><strong>定义</strong>：工厂用于构建聚合。</p><p><strong>关键点</strong>：一个聚合往往包含多个对象，这些对象的数据之间又可能存在联系，如果允许分别创建这些对象，就会让聚合是业务完整性的单元这个定义面临失败。</p></div></details><h3 id="战略设计">战略设计</h3><details class="tag-plugin colorful folding" ><summary><p>统一语言</p></summary><div class="body"><p><strong>定义</strong>：与业务专家协作定义全团队通用的术语表，消除沟通歧义。</p><p><strong>关键点</strong>：</p><ol type="1"><li>同一个概念在不同的上下文中可能存在不同的含义；</li><li>同一个概念在同一上下文中的不同环节，也可能存在不同的含义，需要非常明确清晰的界定，降低沟通成本。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>子域</p></summary><div class="body"><p><strong>定义</strong>：子域是对业务领域的逻辑划分，用于分解复杂问题。通常分为<strong>核心子域</strong>（业务核心竞争力）、<strong>支撑子域</strong>（辅助核心业务）和<strong>通用子域</strong>（可复用的标准化能力）。</p><p><strong>关键点</strong>：因业务目标、团队定位和组织发展阶段等方面的不同，这三个子域的划分并非一成不变，而是会互相转换。</p></div></details><details class="tag-plugin colorful folding" ><summary><p>限界上下文</p></summary><div class="body"><p><strong>定义</strong>：限界上下文本质上是一个自治的小世界，它有完备的职责，还有清晰的边界。</p><p><strong>关键点</strong>：</p><ol type="1"><li>一个子域的一切资产，包括领域模型、数据库、包、可执行程序、接口声明等，都应该封装在限界上下文中，避免跨越边界。</li><li>如何平衡边界的价值和不利影响，是划分边界时要做的一种重要取舍。<strong>一个较为稳妥的策略是考虑认知的渐进特征，不要过早隔离。在已经确定的边界上进行划分，延缓划分那些尚具模糊性的边界，在这些边界逐渐变得清晰时再分离它们。</strong></li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>上下文映射</p></summary><div class="body"><p><strong>定义</strong>：限界上下文约定了基于领域模型的架构层次的设计分解，而分解必然意味着集成和协作。上下文映射就是对限界上下文之间的协作关系的模式总结。</p><p><strong>关键点</strong>：</p><ol type="1"><li>在边界上完成概念映射是一种基本模式。通过在应用层组装或者使用适配器完成概念映射，可以保持领域概念的清晰，避免领域模型遭到不必要的污染。</li><li>防腐层模式、标准开放服务模式、客户-供应商模式、追随者模式。</li></ol></div></details><h3 id="串讲">串讲</h3><p>在应对复杂业务系统时，DDD通过<strong>分治策略</strong>将业务领域拆分为多个<strong>子域</strong>（如电商系统的订单、支付子域），每个子域对应一个<strong>限界上下文</strong>——这是技术与业务对齐的关键边界，既承载领域模型的实现，也通过<strong>上下文映射</strong>（如防腐层、共享内核等模式）实现跨子域协作，避免模型污染。</p><p>限界上下文内的<strong>领域对象</strong>是业务逻辑的载体：具备唯一标识和生命周期的<strong>实体</strong>（如订单实体通过ID跟踪状态变化）、描述特征且不可变的<strong>值对象</strong>（如地址由省市构成，修改需整体替换），以及通过<strong>聚合根</strong>统一操作保证一致性的<strong>聚合</strong>（如订单聚合根管理订单项和配送信息）。当业务逻辑跨越多个聚合时，由无状态的<strong>领域服务</strong>协调（如支付计算需整合订单、账户聚合）。</p><p>对象的创建与持久化分别由<strong>工厂</strong>（封装复杂初始化逻辑）和<strong>资源库</strong>（隔离存储细节）负责，而<strong>领域事件</strong>（如订单支付成功事件）则驱动跨上下文的异步协作。</p><div class="tag-plugin quot"><h2 class="content" id="战术设计" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">战术设计</span><span class="empty"></span></h2></div><h3 id="factory">factory</h3><ul><li>factory 用于构建复杂的领域对象。</li></ul><h3 id="repository">repository</h3><ul><li>只有聚合根有 repository。</li><li>repository 就只提供 <code>load</code> 和 <code>save</code>功能，且要保证事务一致性。</li><li>尽可能提供行级的 repository，而不是表级的 repository，对于表级的repository，可以抽成一个领域服务。</li></ul><h3 id="设计模式">设计模式</h3><h4 id="责任链模式">责任链模式</h4><blockquote><p>将请求的发送者和接受者解耦，使多个对象都有机会处理请求。</p></blockquote><ul><li>责任链模式的使用要点在于要将维护责任链的代码和业务代码分开。</li><li>在 DDD中使用责任链模式时，应创建一个领域服务，在领域服务中完成责任链的创建和执行。</li><li>尽量不要在责任链的处理器中通过 <code>set</code>修改领域对象（聚合根）的状态，责任链应仅用于某些值的计算，最终将计算结果交给聚合根完成业务操作。</li></ul><p>笔者实现了一个快速构建责任链的工具：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go</span><span class="cap link footnote">https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><h4 id="策略模式">策略模式</h4><blockquote><p>允许在运行时根据需要选择不同的实现。</p></blockquote><ul><li>在 DDD中使用策略模式时，通常先定义一个领域服务接口，再在其实现类中完成策略的加载、选择和执行。</li><li>注意屏蔽策略模式的实现细节，避免上层关注领域服务内的设计模式细节。</li></ul><h4 id="桥接模式">桥接模式</h4><blockquote><p>旨在通过解耦抽象和实现，使两者能够独立扩展和变化。</p></blockquote><ul><li><strong>多维解耦机制</strong>：桥接模式通过组合/聚合关系替代继承关系，将原本紧密耦合的抽象层（功能定义）与实现层（具体操作）分离例如遥控器（抽象）与电视（实现）的协作，遥控器通过接口控制电视，无需关注具体品牌。</li><li><strong>正交扩展能力</strong>：支持两个独立变化维度（如消息类型与通知渠道、图形与渲染方式），避免类数量呈指数级增长（M×N组合问题）。电商物流系统中，新增微信通知渠道时，无需修改所有消息类即可实现扩展。</li></ul><h4 id="规约模式">规约模式</h4><blockquote><p>规约模式是一种用于定义业务领域中规则和约束的模式，通常由规约接口（Specification）和验证器（Validator）两个部分组成。</p></blockquote><ul><li>在 DDD中，规约模式并不是在聚合根进行业务操作之前做前置校验，而是在聚合根完成业务操作之后做后置校验，确保Repository 保存的聚合根符合业务规则。</li></ul><h4 id="适配器模式">适配器模式</h4><blockquote><p>将<strong>被适配者（Adaptee）的接口</strong>转换为<strong>目标接口（Target）</strong>，使原本因接口不兼容而无法协同工作的类能够协同。</p></blockquote><ul><li>在 DDD中，可以使用适配器模式来实现防腐层，以将外部上下文接口（如开放主机服务）返回的模型转换为本地上下文定义的领域模型，并将本地上下文的操作转换为对外部上下文的操作。可以有效隔离外部上下文的领域模型，避免互相污染。</li></ul><h3 id="领域事件">领域事件</h3><h4 id="幂等性">幂等性</h4><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image.png" /></p><h4 id="领域事件的定义">领域事件的定义</h4><blockquote><p>领域事件是领域模型的组成部分，它通常由聚合根产生，并被其他聚合或者限界上下文订阅和处理，触发相应的业务逻辑。</p></blockquote><p>注意点：</p><ul><li>应该根据限界上下文中的通用语言来命名事件：AccountActivited。</li><li>应该将事件建模成值对象或贫血对象。</li></ul><p>应用：</p><ol type="1"><li>解耦领域对象之间的关系；</li><li>触发其他领域对象的行为；</li><li>记录领域内已发生的状态变化；</li><li>实现跨聚合的最终一致性；</li><li>进行限界上下文集成。</li></ol><p>消息体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;event_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;event_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;entity_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;event_time&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extra_data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="领域事件的生成">领域事件的生成</h4><ol type="1"><li>应用层创建领域事件。</li><li>聚合根创建领域事件。</li></ol><p>要避免在聚合根内部调用基础实施发布领域事件，而是生成后返回给应用层，由应用层去发布。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entity <span class="keyword">struct</span> &#123;</span><br><span class="line">  Events []Event</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e *Entity)</span></span>ResgisterEvent(event Event) &#123;</span><br><span class="line">  e.Events = <span class="built_in">append</span>(e.Events. event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e *Entity)</span></span> GetEvents() []Event &#123;</span><br><span class="line">  res := e.Events()</span><br><span class="line">  e.Events = []Event&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="领域事件的发布">领域事件的发布</h4><ol type="1"><li>直接发布并轮询补偿：为事件存储一个发布状态标识，用于记录是否补发成功。并提供定时任务检索超时未发布成功的事件进行重新发布。</li><li>采用事务日志拖尾：引入变更数据捕获组件（Change Data Capture，简称CDC），捕获数据的变更日志，解析后获得领域事件并发布。</li></ol><h4 id="领域事件的订阅">领域事件的订阅</h4><p>将领域事件订阅者放置在用户接口层<code>user-interface-subscriber</code>，收到事件后调用应用服务执行业务逻辑。</p><h3 id="事件溯源">事件溯源</h3><p>事件溯源（Event Sourcing）是一种将所有的领域事件（DomainEvent）存储到事件存储（EventStore）中，并通过重放历史事件来还原领域对象状态的模式。</p><p>核心思想是将系统中所有的状态变更都视为事件，将这些事件以事件顺序记录下来，并存储到事件存储中。这样，可以通过重放这些事件，来还原任意时刻的系统状态。</p><p>三种方案：</p><ol type="1"><li>通过回放所有的历史事件重建聚合根。</li><li>通过快照提高重建聚合根的效率。</li><li><strong>通过拉链表生成所有事件对应的快照。</strong></li></ol><div class="tag-plugin colorful note" color="green"><div class="body"><p>拉链表是一种用于处理缓慢变化维度问题的数据结构，它可以有效地处理维度数据的历史变化。在拉链表中，每个记录都有一个开始时间和结束时间，用于描述该记录的存活时间，即该记录的有效期。</p></div></div><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250312183214921.png"alt="拉链法示意图" /><figcaption aria-hidden="true">拉链法示意图</figcaption></figure><h3 id="cqrs">CQRS</h3><p>CQRS 将系统的操作分为两类：</p><ul><li><strong>命令（Command）</strong>：负责数据的写操作（增、删、改），不返回数据。</li><li><strong>查询（Query）</strong>：负责数据的读操作，仅返回结果且不修改数据。</li></ul><p>两者的数据模型可独立设计，甚至使用不同的数据库或存储技术。</p><details class="tag-plugin colorful folding" color="blue"><summary><p>适用场景</p></summary><div class="body"><p><strong>应对高并发读写场景</strong></p><ul><li><p>案例 1：B 站点赞系统</p><p>在日均活跃用户近亿的 B 站，点赞功能通过 CQRS分离读写操作。写入端通过消息队列（如Kafka）异步处理请求，避免数据库锁竞争；查询端通过缓存优化读取性能，显著提升系统吞吐量和稳定性。</p></li><li><p>案例 2：实时答题 PK 游戏</p><p>高并发的答题得分计算场景中，CQRS 结合事件溯源（EventSourcing）记录每个操作事件，确保读写模型的最终一致性，同时支持复杂战况数据的实时展示。</p></li></ul><p><strong>解决复杂查询需求</strong></p><ul><li><p>案例 3：电商订单查询</p><p>随着订单查询需求多样化（如按时间筛选、跨实体聚合数据），CQRS通过独立读模型简化查询逻辑，避免领域模型被复杂查询逻辑污染。</p></li><li><p>案例 4：微服务数据聚合</p><p>在微服务架构中，CQRS允许通过事件同步跨服务数据到专用读库，避免跨服务联表查询的性能瓶颈（如行程管理服务与用户信息服务的聚合查询）。</p></li></ul><p><strong>提升数据模型灵活性</strong></p><ul><li><p>案例 5：文本增量更新</p><p>针对大型文本编辑场景，CQRS拆分读写模型，增量保存修改记录并通过事件合并，减少网络传输数据量，同时支持任意版本的历史数据恢复。</p></li></ul></div></details><details class="tag-plugin colorful folding" color="orange"><summary><p>不适用场景</p></summary><div class="body"><ul><li>简单 CRUD 系统（如小型管理后台）</li><li>强一致性要求的金融交易场景（如实时扣款）</li><li>团队缺乏事件驱动架构经验时</li></ul></div></details><h3 id="一致性">一致性</h3><h4 id="聚合内事务实现">聚合内事务实现</h4><ul><li>聚合内事务控制不要放在应用层，会使应用层承担过多的责任。应用层应专注于协调领域对象和基础设施以完成业务操作，不应过多涉及数据访问和事务控制的细节。</li><li>聚合内事务控制可以交给 <code>Repository</code>来实现，采用乐观锁解决并发问题，可以基于版本号和时间戳，一般重试 1-3次即可。</li></ul><h4 id="聚合间事务实现">聚合间事务实现</h4><ul><li><p>聚合间控制可以单独建立一个领域服务 Domain Service来完成。</p></li><li><p>对于实时性要求不高，仅需最终一致性，可以使用<strong>本地消息表</strong>或者<strong>最大努力通知</strong>的方案。</p></li><li><p>对于实时性一致性要求比较高，可以采用<strong>TCC（Try-Confirm-Cancel）</strong> 事务方案。</p></li><li><p>对于长事务场景，或者涉及外部系统、遗留系统，可以考虑<strong>Saga</strong> 事务方案。</p><blockquote><p>Saga将事务分为多个事务，这些分支事务按照一定的顺序执行。当某个分支事务执行成功后，会通过消息通知下一个分支执行；当某个分支事务执行失败时，会按照正常事务执行顺序的相反方向进行一系列的补偿操作，以确保全局事务的一致性。</p></blockquote></li></ul><div class="tag-plugin quot"><h2 class="content" id="战略设计" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">战略设计</span><span class="empty"></span></h2></div><h3 id="事件风暴">事件风暴</h3><h4 id="核心概念与元素">核心概念与元素</h4><table><colgroup><col style="width: 46%" /><col style="width: 6%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th>元素名称</th><th>颜色标识</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><font color="#FFA500"><strong>领域事件（DomainEvent）</strong></font></td><td>橙色</td><td>表示已发生的业务事实，以“动词过去式”命名（如“订单已提交”），是事件风暴的核心起点。</td></tr><tr class="even"><td><font color="#00008B"><strong>命令（Command）</strong></font></td><td>深蓝色</td><td>触发领域事件的操作或意图（如“提交订单”），通常由用户或系统触发。</td></tr><tr class="odd"><td><font color="#FFFF00"><strong>参与者（Actor）</strong></font></td><td>黄色</td><td>执行命令的角色，包括用户、部门或外部系统（如“客户”触发支付命令）。</td></tr><tr class="even"><td><font color="#FFC0CB"><strong>外部系统（ExternalSystem）</strong></font></td><td>粉色</td><td>与当前系统交互的第三方服务（如支付网关回调生成事件）。</td></tr><tr class="odd"><td><font color="#800080"><strong>策略（Policy）</strong></font></td><td>紫色</td><td>业务规则或约束条件（如“库存不足时取消订单”），决定事件触发的逻辑。</td></tr><tr class="even"><td><font color="#008000"><strong>读模型（ReadModel）</strong></font></td><td>绿色</td><td>为查询优化的数据视图（如“用户订单列表”），支持决策展示。</td></tr><tr class="odd"><td><font color="#FFD700"><strong>聚合（Aggregate）</strong></font></td><td>大黄色</td><td>业务对象集合（如“订单聚合”包含订单项和状态），维护一致性和完整性。</td></tr><tr class="even"><td><font color="#FF0000"><strong>问题（Question）</strong></font></td><td>红色</td><td>未达成共识的争议点（如事件定义分歧），需后续专项讨论。</td></tr></tbody></table><h4 id="实施流程与步骤">实施流程与步骤</h4><ol type="1"><li><p><strong>准备工作</strong></p><ul><li><strong>参与人员</strong>：业务专家、开发、产品、测试等跨职能角色，需领域专家主导。<br /></li><li><strong>物料</strong>：多色便签、白板、马克笔，线上工具辅助远程协作。</li></ul></li><li><p><strong>识别领域事件</strong>团队通过头脑风暴罗列所有可能事件（如电商场景的“订单已创建”“库存已扣减”），按时间轴排列，争议事件用红色便签标记并暂存。</p></li><li><p><strong>补充命令与角色</strong>为每个事件关联触发命令及执行者（如“客户”执行“支付订单”命令生成“支付完成”事件），区分内部操作与外部系统调用。</p></li><li><p><strong>定义策略与读模型</strong>添加业务规则（如“订单金额≥1000元需审核”）和数据展示需求（如“实时库存看板”）。</p></li><li><p><strong>构建聚合与划分子域</strong>将相关事件、命令归类为聚合（如“支付聚合”），划分限界上下文（如“订单服务”“库存服务”），明确微服务边界。</p></li></ol><h4 id="注意事项">注意事项</h4><ol type="1"><li><p><strong>事件粒度的把控</strong>：避免过度细化（如“用户已睁眼"）或过于宽泛（如“订单已修改”），需聚焦业务关键节点。</p></li><li><p><strong>争议处理与迭代</strong>：对未达成共识的事件标记为“问题”（红色便签），后续专题讨论；定期回顾模型，修正错误或补充遗漏。</p></li><li><p><strong>技术实现衔接</strong>：事件风暴的输出需转化为代码模型，例如通过事件溯源（EventSourcing）持久化事件流，或结合 CQRS 分离读写逻辑。</p></li></ol><h3 id="c4-架构模型">C4 架构模型</h3><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://c4model.com/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://c4model.com/" autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div><span class="cap link footnote">https://c4model.com/</span></div><div class="bottom"><span class="title">https://c4model.com/</span><span class="cap desc footnote"></span></div></a></div><table><colgroup><col style="width: 13%" /><col style="width: 30%" /><col style="width: 17%" /><col style="width: 38%" /></colgroup><thead><tr class="header"><th><strong>层级</strong></th><th><strong>核心目标</strong></th><th><strong>受众</strong></th><th><strong>关键元素</strong></th></tr></thead><tbody><tr class="odd"><td><strong>Context（上下文）</strong></td><td>描述系统与外部实体（用户、第三方系统）的交互关系</td><td>非技术人员（如业务方、客户）</td><td>系统边界、用户角色、外部依赖（如支付网关）</td></tr><tr class="even"><td><strong>Container（容器）</strong></td><td>展示系统内部的高阶技术组件（进程级单元）</td><td>技术管理者、架构师</td><td>Web 应用、数据库、消息队列等独立进程单元，关注技术选型与通信协议（如REST API、gRPC）</td></tr><tr class="odd"><td><strong>Component（组件）</strong></td><td>细化容器内部的业务模块与交互逻辑</td><td>开发团队</td><td>服务、模块、接口（如订单服务、库存服务），强调职责划分与依赖关系</td></tr><tr class="even"><td><strong>Code（代码）</strong></td><td>展示组件实现的代码结构</td><td>开发者</td><td>类、方法、数据库表（如 UML 类图、ER 图），通常由 IDE工具自动生成</td></tr></tbody></table><p>除了四层核心视图，C4 模型还提供：</p><ul><li><strong>部署图</strong>：展示容器在物理环境中的分布（如 Kubernetes集群部署）。</li><li><strong>动态图</strong>：描述业务流程（如用户下单到支付完成的时序交互）。</li><li><strong>系统景观图</strong>：多系统协同的全局视图（如企业级中台架构）。</li></ul><div class="tag-plugin tabs" align="center"id="tab_2"><div class="nav-tabs"><div class="tab active"><a href="#tab_2-1">Context</a></div><div class="tab"><a href="#tab_2-2">Container</a></div><div class="tab"><a href="#tab_2-3">Component</a></div><div class="tab"><a href="#tab_2-4">Code</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_2-1"><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/SystemContext-20250312173256060.png" /></p></div><div class="tab-pane" id="tab_2-2"><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Containers-20250312173305921.png" /></p></div><div class="tab-pane" id="tab_2-3"><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Components-20250312173320890.png" /></p></div><div class="tab-pane" id="tab_2-4"><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/MainframeBankingSystemFacade-20250312173313572.png" /></p></div></div></div><div class="tag-plugin quot"><h2 class="content" id="实践案例" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">实践案例</span><span class="empty"></span></h2></div><p>参考作者的 <ahref="https://github.com/feiniaojin/ddd-archetype">ddd-archetype</a>，笔者实现了一个 Go 版本的 <code>ddd-archetype-go</code>：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon-go-road/ddd-archetype-go" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon-go-road/ddd-archetype-go" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon-go-road/ddd-archetype-go</span><span class="cap link footnote">https://github.com/hedon-go-road/ddd-archetype-go</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><p>整体架构如下：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/ddd-ruoyi.drawio.png" /></p>]]></content>
    
    
    <summary type="html">阅读《悟道领域驱动设计》后的一些笔记和思考。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDD" scheme="https://hedon.top/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.24 新特性解读：使用 testing/synctest 优雅地测试并发代码</title>
    <link href="https://hedon.top/2025/03/06/go-lib-synctest/"/>
    <id>https://hedon.top/2025/03/06/go-lib-synctest/</id>
    <published>2025-03-06T07:00:18.000Z</published>
    <updated>2025-04-05T14:31:32.873Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go语言开发中，并发编程一直是其最引人注目的特性之一。然而，如何有效地测试并发代码却常常让开发者感到头疼。Go1.24 版本引入的实验性包 <code>testing/synctest</code>为这个问题带来了优雅的解决方案。今天，让我们深入了解这个新特性。</p><h1 id="并发测试的传统困境">并发测试的传统困境</h1><p>在介绍新方案之前，我们先看看传统的并发测试面临哪些问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTraditional</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 执行某些操作</span></span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待操作完成</span></span><br><span class="line">    time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">if</span> !done &#123;</span><br><span class="line">        t.Fatal(<span class="string">&quot;操作未完成&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式存在明显的问题：</p><ol type="1"><li><strong>时间依赖</strong>：需要通过 Sleep等待，导致测试运行缓慢</li><li><strong>不稳定性</strong>：在不同环境下可能产生不同结果</li><li><strong>精确性差</strong>：难以准确把握检查时机</li></ol><h1 id="synctest优雅的解决方案">synctest：优雅的解决方案</h1><p><code>testing/synctest</code> 包通过两个核心函数改变了这一切：</p><ul><li><code>Run()</code>: 创建隔离的测试环境（bubble）</li><li><code>Wait()</code>: 等待所有 goroutine 进入稳定状态</li></ul><p>让我们看看如何改写上面的测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWithSynctest</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 执行某些操作</span></span><br><span class="line">            time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">            done = <span class="literal">true</span></span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        synctest.Wait()  <span class="comment">// 等待所有 goroutine 进入稳定状态</span></span><br><span class="line">        <span class="keyword">if</span> !done &#123;</span><br><span class="line">            t.Fatal(<span class="string">&quot;操作未完成&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="深入理解-wait-机制">深入理解 Wait 机制</h1><h2 id="wait-的本质">Wait 的本质</h2><p>很多开发者初次接触 <code>Wait()</code>时可能会感到困惑：它到底在等待什么？什么时候会返回？</p><p>想象一个场景：你在拍摄一张全家福，需要等待所有人都找到自己的位置，站好不动，才能按下快门。<code>Wait()</code>就像这个摄影师，它在等待所有goroutine（就像照片中的人）都进入一个稳定的状态（站好不动）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 类比：三个人要拍全家福</span></span><br><span class="line">    <span class="keyword">go</span> person1()  <span class="comment">// 第一个人找位置</span></span><br><span class="line">    <span class="keyword">go</span> person2()  <span class="comment">// 第二个人找位置</span></span><br><span class="line">    <span class="keyword">go</span> person3()  <span class="comment">// 第三个人找位置</span></span><br><span class="line"></span><br><span class="line">    synctest.Wait()  <span class="comment">// 等待所有人都站好不动</span></span><br><span class="line">    <span class="comment">// 这时可以安全地&quot;按下快门&quot;（检查程序状态）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="为什么需要-wait">为什么需要 Wait？</h2><p>在并发程序中，我们经常需要在特定时刻检查程序状态。但是，如果某些goroutine 还在运行，这个状态可能随时发生变化。<code>Wait()</code>通过确保所有 goroutine 都进入稳定状态，为我们提供了一个"快照"时刻。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        result = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    synctest.Wait()  <span class="comment">// 等待 goroutine 进入稳定状态</span></span><br><span class="line">    <span class="comment">// 此时 result 的值是确定的，不会突然改变</span></span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="持久阻塞的概念">持久阻塞的概念</h2><p>哪些操作会导致持久阻塞？</p><ul><li>channel 操作（同一 bubble 内）</li><li>time.Sleep</li><li>sync.WaitGroup.Wait</li><li>sync.Cond.Wait</li></ul><p>哪些操作不算持久阻塞？</p><ul><li>互斥锁操作</li><li>外部 I/O</li><li>外部 channel 操作</li></ul><h1 id="虚拟时钟测试的神器">虚拟时钟：测试的神器</h1><p><code>synctest</code> 的另一个强大特性是虚拟时钟机制。在 bubble内部，所有时间相关的操作都使用虚拟时钟，这意味着：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 看似等待24小时</span></span><br><span class="line">    time.Sleep(<span class="number">24</span> * time.Hour)</span><br><span class="line">    <span class="comment">// 实际上立即执行完成！</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个特性让我们能够：</p><ol type="1"><li>快速测试长时间操作</li><li>精确控制时间流逝</li><li>避免测试的不确定性</li></ol><h1 id="实战案例深入理解-http-100-continue-测试">实战案例：深入理解 HTTP100 Continue 测试</h1><h2 id="背景知识">背景知识</h2><p>HTTP 的 100 Continue 机制是一个优化大文件上传的协议特性：</p><ol type="1"><li>客户端想上传大文件时，先发送带有 "Expect: 100-continue"头的请求</li><li>服务器可以决定是否接受这个上传：<ul><li>如果接受，返回 "100 Continue"</li><li>如果拒绝，可以直接返回错误状态码</li></ul></li><li>客户端根据服务器的响应决定是否发送文件内容</li></ol><h2 id="详细测试实现">详细测试实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHTTPContinue</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 第一步：建立测试环境</span></span><br><span class="line">        srvConn, cliConn := net.Pipe()</span><br><span class="line">        <span class="keyword">defer</span> srvConn.Close()</span><br><span class="line">        <span class="keyword">defer</span> cliConn.Close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二步：配置 HTTP 客户端</span></span><br><span class="line">        tr := &amp;http.Transport&#123;</span><br><span class="line">            DialContext: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, address <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cliConn, <span class="literal">nil</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ExpectContinueTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三步：准备测试数据</span></span><br><span class="line">        body := <span class="string">&quot;request body&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第四步：发送请求</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            req, _ := http.NewRequest(<span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;http://test.tld/&quot;</span>, </span><br><span class="line">                strings.NewReader(body))</span><br><span class="line">            req.Header.Set(<span class="string">&quot;Expect&quot;</span>, <span class="string">&quot;100-continue&quot;</span>)</span><br><span class="line">            resp, err := tr.RoundTrip(req)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                t.Errorf(<span class="string">&quot;请求失败: %v&quot;</span>, err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.Body.Close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第五步：验证请求头</span></span><br><span class="line">        req, err := http.ReadRequest(bufio.NewReader(srvConn))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;读取请求失败: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第六步：验证请求体未发送</span></span><br><span class="line">        <span class="keyword">var</span> gotBody strings.Builder</span><br><span class="line">        <span class="keyword">go</span> io.Copy(&amp;gotBody, req.Body)</span><br><span class="line">        synctest.Wait()</span><br><span class="line">        <span class="keyword">if</span> got := gotBody.String(); got != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;在发送 100 Continue 之前，意外收到请求体: %q&quot;</span>, got)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第七步：发送 100 Continue</span></span><br><span class="line">        srvConn.Write([]<span class="type">byte</span>(<span class="string">&quot;HTTP/1.1 100 Continue\r\n\r\n&quot;</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第八步：验证请求体</span></span><br><span class="line">        synctest.Wait()</span><br><span class="line">        <span class="keyword">if</span> got := gotBody.String(); got != body &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;收到的请求体 %q，期望 %q&quot;</span>, got, body)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第九步：完成请求</span></span><br><span class="line">        srvConn.Write([]<span class="type">byte</span>(<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试的关键点解析">测试的关键点解析</h2><ol type="1"><li><strong>使用 net.Pipe()</strong><ul><li>创建内存中的网络连接</li><li>避免依赖真实网络</li><li>保证测试的可重复性</li></ul></li><li><strong>请求发送过程</strong><ul><li>在独立的 goroutine 中发送请求</li><li>设置 "Expect: 100-continue" 头</li><li>准备要发送的请求体</li></ul></li><li><strong>验证关键行为</strong><ul><li>确认请求头正确发送</li><li>验证请求体在收到 100 Continue 之前未发送</li><li>验证请求体在收到 100 Continue 后正确发送</li></ul></li><li><strong>使用 Wait 的时机</strong><ul><li>在检查请求体之前调用 Wait</li><li>确保所有数据传输操作都已完成或阻塞</li><li>获得稳定的程序状态进行验证</li></ul></li></ol><h1 id="使用建议">使用建议</h1><ol type="1"><li><strong>明确边界</strong>：理解什么操作会导致持久阻塞，什么不会</li><li><strong>清理资源</strong>：确保所有 goroutine 在测试结束前退出</li><li><strong>模拟 I/O</strong>：使用内存管道替代真实网络连接</li><li><strong>合理使用 Wait</strong>：在需要检查状态的关键点调用</li></ol><h1 id="注意事项">注意事项</h1><ol type="1"><li>目前是实验性功能，需要设置 <code>GOEXPERIMENT=synctest</code></li><li>不支持测试真实的外部 I/O 操作</li><li>互斥锁操作不被视为持久阻塞</li></ol>]]></content>
    
    
    <summary type="html">本文介绍了 Go 1.24 版本引入的实验性包 testing/synctest，并详细讲解了如何使用它优雅地测试并发代码。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>直播系统推拉流原理</title>
    <link href="https://hedon.top/2025/03/04/live-stream-push-pull/"/>
    <id>https://hedon.top/2025/03/04/live-stream-push-pull/</id>
    <published>2025-03-04T03:34:09.000Z</published>
    <updated>2025-04-05T14:31:32.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直播系统推拉流原理概述">直播系统推拉流原理概述</h1><p>直播系统的核心功能是实现主播端视频采集后的实时传输，以及观众端的实时观看。整个过程主要包含：推流、服务器处理、拉流三个环节。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250304121833913.png"alt="直播系统架构" /><figcaption aria-hidden="true">直播系统架构</figcaption></figure><h2 id="核心概念解析">核心概念解析</h2><h3 id="推流push">1. 推流（Push）</h3><p>推流是指主播端将视频数据传输到服务器的过程。主要使用<code>RTMP</code> 协议（Real Time Messaging Protocol）。</p><p>比如可能有如下推流 URL 的生成逻辑： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generatePushUrl</span><span class="params">(String pushDomain, String pushKey, String appName, String streamName, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pushUrl</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 推流域名未开启鉴权功能的情况下</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(pushKey)) &#123;</span><br><span class="line">        pushUrl = <span class="string">&quot;rtmp://&quot;</span> + pushDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000L</span> + expireTime;</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringToMd5</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;-&quot;</span> + Long.toString(timeStamp) + <span class="string">&quot;-0-0-&quot;</span> + pushKey;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authKey</span> <span class="operator">=</span> md5(stringToMd5);</span><br><span class="line">        pushUrl = <span class="string">&quot;rtmp://&quot;</span> + pushDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;?auth_key=&quot;</span> + Long.toString(timeStamp) + <span class="string">&quot;-0-0-&quot;</span> + authKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pushUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>推流地址的组成部分： - rtmp:// - 协议 - pushDomain - 推流域名 -appName - 应用名称 - streamName - 流名称 - auth_key -鉴权参数（可选）</p><h3 id="拉流pull">2. 拉流（Pull）</h3><p>拉流是观众观看直播的过程。支持多种协议： - RTMP：延迟低（1-3秒） -HTTP-FLV：延迟适中（2-5秒） - HLS(m3u8)：延迟较高（5-30秒）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FLV 格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generalPullUrlFlv</span><span class="params">(String pullDomain, String pullKey, String appName, String streamName, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(pullKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://&quot;</span> + pullDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;.flv&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 鉴权逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HLS 格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generalPullUrlHls</span><span class="params">(String pullDomain, String pullKey, String appName, String streamName, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(pullKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://&quot;</span> + pullDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;.m3u8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 鉴权逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直播流程">直播流程</h2><ol type="1"><li><strong>主播开播</strong>：<ul><li>系统生成唯一的 streamId</li><li>生成带鉴权的推流地址</li><li>主播端推流软件（如 OBS）开始推流</li></ul></li><li><strong>服务器处理</strong>：<ul><li>流媒体服务器接收推流</li><li>进行转码、录制等处理</li><li>将流分发到 CDN 节点</li></ul></li><li><strong>观众观看</strong>：<ul><li>获取对应格式的拉流地址</li><li>通过播放器拉取直播流</li><li>实现实时观看</li></ul></li></ol><h2 id="实现建议">实现建议</h2><ol type="1"><li><strong>选择合适的流媒体服务器</strong>：<ul><li>商业云服务：阿里云直播、腾讯云直播</li><li>开源方案：SRS、Nginx-RTMP</li></ul></li><li><strong>根据业务场景选择协议</strong>：<ul><li>普通直播：HTTP-FLV</li><li>低延迟场景：RTMP</li><li>移动端兼容性要求高：HLS</li></ul></li><li><strong>关注关键指标</strong>：<ul><li>延迟控制</li><li>卡顿率</li><li>首屏时间</li><li>带宽成本</li></ul></li><li><strong>安全鉴权：</strong><ul><li>防盗链机制</li></ul></li></ol>]]></content>
    
    
    <summary type="html">本文介绍了直播系统推拉流的基本原理，包括推流和拉流的过程、协议选择、关键指标等。</summary>
    
    
    
    <category term="解决方案" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="直播系统" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="直播系统" scheme="https://hedon.top/tags/%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>网络数据包的完整旅程：从发送到接收的全过程</title>
    <link href="https://hedon.top/2025/03/01/net-data-journey/"/>
    <id>https://hedon.top/2025/03/01/net-data-journey/</id>
    <published>2025-03-01T04:58:37.000Z</published>
    <updated>2025-04-05T14:31:32.876Z</updated>
    
    <content type="html"><![CDATA[<p>不知道你是否曾经好奇你发出的一个网络请求，最终是怎么到达对端，并将你想要的信息返回给你的。本文将通过一个HTTP请求与响应，从一个比较宏观的角度来梳理下一个数据包在网络中的旅途，旨在帮助笔者和各位读者建立起对计算机网络模型一个比较全面的认知。</p><blockquote><p>本文参考极客时间《网络架构实战课（谢友鹏）》，再根据笔者的知识面、按照个人理解，补充更多丰富具体的内容。</p></blockquote><h1 id="实战">实战</h1><p>好，那我们直接开始，我们先使用 <code>curl</code> 来发起一个 HTTP请求，看看这过程中发生了什么：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /dev/null -v https://example.com</span><br></pre></td></tr></table></figure><p>在笔者的 mac 机器上，这行命令的输出如下：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301131247066.png" data-fancybox="true" alt="curl https//example.com 结果分析" style="width: 100%; height: auto;"></p><p>当我们发起请求时，首先会对 <code>example.com</code>进行域名解析，分别尝试解析到它的 <code>IPv6</code> 和<code>IPv4</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* IPv6: (none)</span><br><span class="line">* IPv4: 23.215.0.138, 96.7.128.198, 23.192.228.80, 23.192.228.84, 23.215.0.136, 96.7.128.175</span><br></pre></td></tr></table></figure><p>因为我们使用的是 <code>https</code> 协议，所以会尝试跟这些地址的<code>443</code> 端口建立 <code>TCP</code> 连接，（如果是<code>https</code> 则跟 <code>80</code> 端口），并进行<code>TLS 握手验证</code>，如果成功了，则会建立 <code>TCP</code>连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Trying <span class="number">23.215</span><span class="number">.0</span><span class="number">.138</span>:<span class="number">443.</span>..</span><br><span class="line">...[TLS handshake]</span><br><span class="line">* Connected to example.com (<span class="number">23.215</span><span class="number">.0</span><span class="number">.138</span>) port <span class="number">443</span></span><br></pre></td></tr></table></figure><p>建立连接后，就开始发送 <code>HTTP</code> 请求，这里使用的是 HTTP2协议。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* using HTTP/2</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0* [HTTP/2] [1] OPENED stream <span class="keyword">for</span> https://example.com/</span><br><span class="line">* [HTTP/2] [1] [:method: GET]</span><br><span class="line">* [HTTP/2] [1] [:scheme: https]</span><br><span class="line">* [HTTP/2] [1] [:authority: example.com]</span><br><span class="line">* [HTTP/2] [1] [:path: /]</span><br><span class="line">* [HTTP/2] [1] [user-agent: curl/8.10.1]</span><br><span class="line">* [HTTP/2] [1] [accept: */*]</span><br><span class="line">&#125; [5 bytes data]</span><br><span class="line">&gt; GET / HTTP/2</span><br><span class="line">&gt; Host: example.com</span><br><span class="line">&gt; User-Agent: curl/8.10.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">* Request completely sent off</span><br></pre></td></tr></table></figure><p>最后，服务器返回了 HTTP 200 OK 的响应。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123; [5 bytes data]</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):</span><br><span class="line">&#123; [265 bytes data]</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):</span><br><span class="line">&#123; [265 bytes data]</span><br><span class="line">&lt; HTTP/2 200</span><br><span class="line">&lt; content-type: text/html</span><br><span class="line">&lt; etag: <span class="string">&quot;84238dfc8092e5d9c0dac8ef93371a07:1736799080.121134&quot;</span></span><br><span class="line">&lt; last-modified: Mon, 13 Jan 2025 20:11:20 GMT</span><br><span class="line">&lt; cache-control: max-age=1374</span><br><span class="line">&lt; <span class="built_in">date</span>: Sat, 01 Mar 2025 05:01:03 GMT</span><br><span class="line">&lt; alt-svc: h3=<span class="string">&quot;:443&quot;</span>; ma=93600,h3-29=<span class="string">&quot;:443&quot;</span>; ma=93600,quic=<span class="string">&quot;:443&quot;</span>; ma=93600; v=<span class="string">&quot;43&quot;</span></span><br><span class="line">&lt; content-length: 1256</span><br><span class="line">&lt;</span><br><span class="line">&#125; [5 bytes data]</span><br><span class="line">100  1256  100  1256    0     0   1172      0  0:00:01  0:00:01 --:--:--  1172</span><br><span class="line">* Connection <span class="comment">#0 to host example.com left intact</span></span><br></pre></td></tr></table></figure><p>要进一步了解网络数据包的细节，我们可以通过抓包工具进行分析。你可以使用<code>tcpdump</code> 抓取与 example.com 的通信数据包。</p><p>运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> tcpdump host example.com -w example.com.pcap</span><br></pre></td></tr></table></figure><p>然后再另外一个命令行窗口再次发送请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /dev/null -v https://example.com</span><br></pre></td></tr></table></figure><p>回到 <code>tcpdump</code> 的窗口并结束监听，我们就会得到<code>example.com.pcap</code> 的抓包文件，可以通过<code>Wireshark</code> 软件打开该文件：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301133015523.png"alt="tcpdump 分析结果" /><figcaption aria-hidden="true">tcpdump 分析结果</figcaption></figure><h1 id="网络分层">网络分层</h1><p>通过上述实验，我们可以清晰看到网络是分层的，主流的分层模型有 OSI七层模型和 TCP/IP 四层模型，它们的对应关系及常见的协议如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/OSI-vs-TCP.png"alt="OSI-vs-TCP/IP" /><figcaption aria-hidden="true">OSI-vs-TCP/IP</figcaption></figure><p>我们在 Wireshark上方随便选择一个数据包，使用鼠标点击下方左侧的每一层，可以在右侧看到对应的层级数据。从链路层到应用层，每一层的数据都是对下一层的进一步封装。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301134103404.png"alt="数据包封装" /><figcaption aria-hidden="true">数据包封装</figcaption></figure><p>在发送方，用户程序需要传输的数据会经过逐层封装。首先添加应用层的 HTTPHeader，然后是传输层的 TCP Header，接着是网络层的 IPHeader，最后在链路层添加以太网帧的帧头和帧尾，包括源 MAC 地址、目的 MAC地址等链路层信息，最终形成网络中传输的完整数据包。</p><p>在接收方，数据包会按相反的顺序逐层解封装。接收设备从链路层开始解析数据，依次解读网络层、传输层和应用层的信息，最后将数据传递给接收方的应用程序。</p><p>如下图所示：</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/cn1.png"alt="数据包封装 &amp; 解析" /><figcaption aria-hidden="true">数据包封装 &amp; 解析</figcaption></figure><p>我们在 Wireshark中点开下面的每一层，可以看到如下信息，我在图标注了最重要的几个信息：<imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301135433547.png"alt="网络数据包关键信息" /></p><h1 id="网络之旅">网络之旅</h1><p>经过上述实验，我们可以做个小总结：</p><p>通过上述实验，我们可以清晰理解数据包的传输过程：</p><ul><li>HTTP请求是网络通信的应用层内容，它需要通过各层网络协议的封装才能实现端到端传输。</li><li>从发送方角度，数据传输遵循一个明确的逻辑顺序：首先将域名（example.com）解析为IP 地址，然后基于该 IP 地址和目标端口（443）建立 TCP 连接，接着找到目标IP 的 MAC 地址，最终由网卡将完整封装的数据包发送到网络中。</li><li>从接收方角度，服务器处理数据包的过程是一个自下而上的解封装过程：数据链路层接收到的帧包含源MAC 地址，网络层解析出 IPv4 地址和协议类型，传输层识别出 TCP协议和源端口号，最终在应用层获取并处理 HTTP请求数据。服务器根据这些信息构建响应，并按相反顺序封装返回给客户端。</li></ul><p>这种分层处理机制确保了网络通信的灵活性和可靠性，每层只需关注自己的职责，共同完成端到端的数据传输任务。</p><p>好，那么这里就有 2 个最关键的问题：</p><ol type="1"><li>如何通过域名获得 IP 地址？</li><li>如何通过 IP 地址获取 MAC 地址？</li></ol><h2 id="dns-解析">DNS 解析</h2><p>DNS（Domain NameSystem，域名系统）是互联网的一项核心服务，它允许我们使用易记的域名（如<code>example.com</code>）而不是数字 IP 地址（如<code>93.184.216.34</code>）来访问网站。</p><p>当你在浏览器中输入一个域名时，DNS 解析按以下步骤进行：</p><ol type="1"><li><p><strong>浏览器缓存检查</strong>：浏览器首先检查自己的缓存，看是否已经存储了该域名对应的IP 地址。</p></li><li><p><strong>操作系统缓存检查</strong>：如果浏览器缓存中没有，系统会检查操作系统的DNS 缓存（如 Windows 的 DNS Client 服务）。</p></li><li><p><strong>路由器缓存检查</strong>：若系统缓存中也没有，请求会被发送到你的路由器，它也维护着一个DNS 缓存。</p></li><li><p><strong>ISP DNS服务器查询</strong>：如果以上缓存都未命中，请求会被发送到你的ISP（互联网服务提供商）的 DNS 服务器。</p></li><li><p><strong>递归查询</strong>：ISP 的 DNS 服务器会执行递归查询：</p><ul><li>首先查询根域名服务器（Root DNS Server）</li><li>根服务器会引导到顶级域名服务器（TLD DNS Server，如 .com, .net, .org等）</li><li>顶级域名服务器会引导到权威域名服务器（Authoritative DNSServer）</li><li>权威服务器会返回该域名的 IP 地址</li></ul></li><li><p><strong>结果返回与缓存</strong>：一旦获取到 IP地址，它会被沿着查询路径返回，并在各个层级上缓存一段时间（由 TTL值决定）。</p></li></ol><p>你可以使用以下工具查询 DNS 信息：</p><ul><li><strong>nslookup</strong>：<code>nslookup example.com</code></li><li><strong>dig</strong>：<code>dig example.com</code></li><li><strong>host</strong>：<code>host example.com</code></li></ul><p>这些工具可以帮助你了解域名的解析过程和结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ host example.com</span><br><span class="line">example.com has address 23.215.0.138</span><br><span class="line">example.com has address 23.192.228.84</span><br><span class="line">example.com has address 23.215.0.136</span><br><span class="line">example.com has address 23.192.228.80</span><br><span class="line">example.com has address 96.7.128.175</span><br><span class="line">example.com has address 96.7.128.198</span><br><span class="line">example.com has IPv6 address 2600:1408:ec00:36::1736:7f31</span><br><span class="line">example.com has IPv6 address 2600:1406:3a00:21::173e:2e65</span><br><span class="line">example.com has IPv6 address 2600:1406:3a00:21::173e:2e66</span><br><span class="line">example.com has IPv6 address 2600:1406:bc00:53::b81e:94c8</span><br><span class="line">example.com has IPv6 address 2600:1406:bc00:53::b81e:94ce</span><br><span class="line">example.com has IPv6 address 2600:1408:ec00:36::1736:7f24</span><br><span class="line">example.com mail is handled by 0 .</span><br></pre></td></tr></table></figure><p>通过 DNS 解析将域名转换为 IP地址后，网络通信的下一步就是确定如何将数据包发送到目标 IP地址，这就需要用到 ARP 协议来获取目标设备的 MAC 地址。</p><h2 id="穿越客户端局域网">穿越客户端局域网</h2><p><strong>当我们发送一个网络请求时，数据包如何找到离开家庭/办公网络的"出口"？</strong></p><p>数据包首先需要解决的是"该往哪走"的问题：</p><ol type="1"><li><p><strong>问题：我需要直接联系目标设备还是找个"中介"？</strong></p><p>解决方案：子网判断</p><ul><li>设备会比较目标 IP 与自己的 IP 和子网掩码</li><li>就像判断收件人是不是住在同一个小区</li></ul></li><li><p><strong>问题：如何找到同一网络中的设备？</strong></p><p>解决方案：ARP 协议</p><ul><li>类似于小区广播："谁是 202 号房的？请告诉我你的门牌号！"</li><li>目标设备回应自己的 MAC 地址（设备的"身份证号"）</li></ul></li><li><p><strong>问题：目标在远方，如何离开本地网络？</strong></p><p>解决方案：默认网关</p><ul><li>就像不认识远方收件人的地址，先交给小区门卫（路由器）</li><li>数据包头上标注最终目的地 IP，但先送到网关的 MAC 地址</li></ul></li><li><p><strong>问题：数据如何在本地网络中转发？</strong></p><p>解决方案：交换机的 MAC 地址表</p><ul><li>交换机就像小区内的快递员，记住了每家每户的门牌号</li><li>它查表后将包裹精确送到对应的门口，不会打扰其他住户</li></ul></li></ol><p>简单来说，数据包在本地网络中的旅程就像是快递先确认收件人是否在同一小区，如果是，直接送达；如果不是，则交给小区出口的保安，由他负责进一步转发。</p><h2 id="穿越公网">穿越公网</h2><p><strong>数据包离开了本地网络，如何在茫茫互联网中找到遥远的目标服务器？</strong></p><p>数据包在互联网上的旅程就像一次跨国旅行：</p><ol type="1"><li><p><strong>问题：如何从私人区域进入公共世界？</strong></p><p>解决方案：NAT（网络地址转换）</p><ul><li><p>就像多人共用一个护照出国，本地设备共享一个公网 IP</p></li><li><p>路由器会记住谁发了什么请求，回程时能送回正确的设备</p></li></ul></li><li><p><strong>问题：互联网如此庞大复杂，谁来管理这些网络？</strong></p><p>解决方案：自治系统（Autonomous System, AS）</p><ul><li><p>AS 就像互联网世界的"国家"或"独立王国"</p></li><li><p>每个 AS 由单一技术管理机构控制（如ISP、大企业或教育机构）</p></li><li><p>你的数据包首先进入你的 ISP 所在的 AS，然后可能穿越多个AS</p></li><li><p>每个 AS 有唯一的 AS 号（ASN），如 AS7018(AT&amp;T) 或AS8075(Microsoft)</p></li></ul></li><li><p><strong>问题：这些"网络王国"如何相互通信和合作？</strong></p><p>解决方案：BGP 协议(边界网关协议)</p><ul><li><p>BGP 是 AS 之间的"外交语言"，用于宣告路由信息</p></li><li><p>它告诉其他 AS："通过我可以到达这些网络"</p></li><li><p>路由器根据 BGP 信息，决定数据包应该经过哪些 AS</p></li></ul></li><li><p><strong>问题：如何决定数据包在 AS 内部该走哪条路？</strong></p><p>解决方案：内部路由协议</p><ul><li><p>AS 内部使用 OSPF 或 IS-IS 等协议来找到最佳路径</p></li><li><p>路由器像城市中的交通指挥，根据"路况"决定下一个方向</p></li></ul></li><li><p><strong>问题：不同运营商之间如何连接？</strong></p><p>解决方案：互联网交换中心（IXP）</p><ul><li><p>就像不同航空公司在大型枢纽机场交换乘客</p></li><li><p>数据包在 IXP 从一个 AS “转机”到另一个 AS</p></li><li><p>这减少了路径长度，提高了传输效率</p></li></ul></li><li><p><strong>问题：我能知道我的数据经过了哪些地方吗？</strong></p><p>解决方案：路径追踪工具</p><ul><li><p>traceroute/tracert 就像给数据包装上 GPS</p></li><li><p>你可以看到数据包穿越的不同 AS 和路由器</p></li></ul></li></ol><p>互联网就像一个巨大的全球快递网络，你的数据包可能穿越多个国家、经过海底电缆，由不同的运营商接力传递，最终到达目的地的网络。</p><h2 id="穿越服务端局域网">穿越服务端局域网</h2><p><strong>数据包到达目标所在网络后，如何找到并到达最终的服务器？</strong></p><p>数据包抵达目的地网络，就像国际快递到达目标城市，还需要最后一段"本地配送"：</p><ol type="1"><li><p><strong>问题：如何确保只有合法请求能进入网络？</strong></p><p>解决方案：防火墙和安全策略</p><ul><li>就像机场海关，检查入境者是否符合入境条件</li><li>只有合法的数据包才能通过安全检查</li></ul></li><li><p><strong>问题：大型网站如何处理海量请求？</strong></p><p>解决方案：负载均衡</p><ul><li>像大型医院的分诊台，将病人分配到不同的医生处</li><li>根据服务器负载、用户位置等因素智能分发请求</li></ul></li><li><p><strong>问题：如何在数据中心复杂环境中找到目标服务器？</strong></p><p>解决方案：内部路由与最后一跳 ARP</p><ul><li>数据中心内部有自己的"地图"和"道路系统"</li><li>最后一个路由器会通过 ARP 找到服务器的具体位置</li></ul></li><li><p><strong>问题：现代云环境中，服务器可能是虚拟的，怎么处理？</strong></p><p>解决方案：虚拟网络</p><ul><li>物理服务器上可能运行多个虚拟机或容器</li><li>虚拟交换机将数据包准确送达虚拟环境中的目标应用</li></ul></li></ol><p>这就像国际快递最后的“最后一公里”配送 -从目的地城市的分拣中心，经过层层筛选，最终送到收件人手中。</p><h2 id="总结">总结</h2><p>网络请求就像一封国际信件的旅程：</p><ol type="1"><li><p>本地投递：从你家出发，判断收件人是否在同小区。如不在，交给小区出口的门卫（网关）。</p></li><li><p>国际运输：</p><ul><li>先经过你所在“国家”（你 ISP 的 AS）的海关（NAT）</li><li>然后可能穿越多个“国家”（不同的 AS）</li><li>各国海关（路由器）通过“国际条约”（BGP）决定包裹走向</li><li>有时通过“国际中转站”（IXP）快速转运到其他“国家”</li></ul></li><li><p>目的地配送：</p><ul><li><p>通过目的地“海关”（防火墙）入境检查</p></li><li><p>经过“分拣中心”（负载均衡器）分配处理人员</p></li><li><p>最终通过“本地快递员”（内部路由和交换）送达收件人手中</p></li></ul></li></ol><p>数据包就这样完成了客户端设备到服务器的全程旅行，然后服务器的响应再沿着类似的路径返回到客户端设备，完成整个请求-响应循环。</p><h1 id="参考">参考</h1><ul><li><p><ahref="https://time.geekbang.org/column/article/846257">极客时间《网络架构实战课》</a></p></li><li><p><ahref="https://www.geeksforgeeks.org/difference-between-osi-model-and-tcp-ip-model/">DifferenceBetween OSI Model and TCP/IP Model</a></p></li></ul>]]></content>
    
    
    <summary type="html">通过一个 HTTP 请求与响应，深入探索背后的网络通信机制，从 DNS 解析、TCP 连接到数据封装与传输，全面解析数据包如何穿越局域网与公网到达目标服务器。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>解决方案丨游戏后端中的 Push-ACK 机制设计与内存优化</title>
    <link href="https://hedon.top/2025/02/27/solution-push-ack/"/>
    <id>https://hedon.top/2025/02/27/solution-push-ack/</id>
    <published>2025-02-27T12:31:45.000Z</published>
    <updated>2025-04-05T14:31:32.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言">引言</h2><p>在现代在线游戏开发中，服务器与客户端之间实时、可靠的通信机制是游戏体验的基石。作为一名游戏后端开发者，我曾经遇到过这样的场景：更新了一个公会系统的新功能，服务器需要向成千上万个在线玩家推送公会状态变更。短短几小时后，服务器内存使用率飙升至90%，系统告警不断。问题出在哪里？Push消息的可靠性机制实现不当导致了内存泄漏。</p><p>本文将深入探讨游戏后端中 Push-ACK机制的设计与实现，特别关注如何避免内存暴涨问题，分享我在多个大型游戏项目中积累的经验与教训。</p><h2 id="背景为什么需要应用层的-ack-机制">背景：为什么需要应用层的 ACK机制？</h2><p>TCP协议确实提供了可靠的数据传输保证，包括数据包的序列号、校验和、超时重传等机制。那么，为什么我们还需要在应用层实现额外的ACK 机制呢？</p><h3 id="tcp-可靠性的边界">TCP 可靠性的边界</h3><p>TCP只能保证<strong>数据被送达到客户端的网络栈</strong>，但无法保证：</p><ol type="1"><li>数据被客户端应用程序正确处理</li><li>处理过程中没有出现异常</li><li>客户端的业务逻辑正确执行</li></ol><p>想象这样一个场景：服务器向玩家推送了一条"获得稀有装备"的消息，TCP确保了数据送达客户端，但如果客户端在处理这个消息时崩溃了呢？对于游戏这类状态敏感的应用，我们需要知道消息是否被<strong>成功处理</strong>，而不仅仅是<strong>成功传输</strong>。</p><h3 id="业务可靠性需求">业务可靠性需求</h3><p>实际游戏开发中，不同类型的消息有不同的可靠性需求：</p><table><thead><tr class="header"><th>消息类型</th><th>示例</th><th>可靠性需求</th></tr></thead><tbody><tr class="odd"><td>关键状态变更</td><td>道具获取、货币变化</td><td>极高（必须确认处理）</td></tr><tr class="even"><td>游戏进程通知</td><td>任务更新、成就解锁</td><td>高（需要确认）</td></tr><tr class="odd"><td>实时位置同步</td><td>玩家位置、NPC 移动</td><td>中（新数据可覆盖旧数据）</td></tr><tr class="even"><td>环境信息</td><td>天气变化、背景音乐</td><td>低（可接受偶尔丢失）</td></tr></tbody></table><h2 id="设计通用的-push-ack-机制">设计通用的 Push-ACK 机制</h2><p>一个完善的 Push-ACK机制需要考虑以下几个方面：消息唯一标识、优先级分级、超时重试、批量确认和失败处理。下面是基于Go 语言的设计实现：</p><h3 id="核心数据结构">核心数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Message 表示服务器推送的消息</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    MsgID        <span class="type">string</span>      <span class="string">`json:&quot;msg_id&quot;`</span>        <span class="comment">// 唯一消息标识</span></span><br><span class="line">    MsgType      <span class="type">string</span>      <span class="string">`json:&quot;msg_type&quot;`</span>      <span class="comment">// 消息类型</span></span><br><span class="line">    Timestamp    <span class="type">int64</span>       <span class="string">`json:&quot;timestamp&quot;`</span>     <span class="comment">// 发送时间戳</span></span><br><span class="line">    Priority     <span class="type">int</span>         <span class="string">`json:&quot;priority&quot;`</span>      <span class="comment">// 优先级：1-高，2-中，3-低</span></span><br><span class="line">    Payload      <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;payload&quot;`</span>       <span class="comment">// 消息内容</span></span><br><span class="line">    RequiresAck  <span class="type">bool</span>        <span class="string">`json:&quot;requires_ack&quot;`</span>  <span class="comment">// 是否需要确认</span></span><br><span class="line">    Expiration   <span class="type">int64</span>       <span class="string">`json:&quot;expiration&quot;`</span>    <span class="comment">// 过期时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AckMessage 表示客户端的确认消息</span></span><br><span class="line"><span class="keyword">type</span> AckMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">    AckID            <span class="type">string</span>  <span class="string">`json:&quot;ack_id&quot;`</span>           <span class="comment">// 对应原消息ID</span></span><br><span class="line">    Status           <span class="type">string</span>  <span class="string">`json:&quot;status&quot;`</span>           <span class="comment">// 状态：success/failed/partial</span></span><br><span class="line">    ClientTimestamp  <span class="type">int64</span>   <span class="string">`json:&quot;client_timestamp&quot;`</span> <span class="comment">// 客户端处理时间</span></span><br><span class="line">    ErrorCode        <span class="type">int</span>     <span class="string">`json:&quot;error_code&quot;`</span>       <span class="comment">// 错误码</span></span><br><span class="line">    ErrorMessage     <span class="type">string</span>  <span class="string">`json:&quot;error_message&quot;`</span>    <span class="comment">// 错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BatchAckMessage 表示批量确认消息</span></span><br><span class="line"><span class="keyword">type</span> BatchAckMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">    BatchAck        <span class="type">bool</span>     <span class="string">`json:&quot;batch_ack&quot;`</span>       <span class="comment">// 批量确认标志</span></span><br><span class="line">    AckIDs          []<span class="type">string</span> <span class="string">`json:&quot;ack_ids&quot;`</span>         <span class="comment">// 消息ID列表</span></span><br><span class="line">    Status          <span class="type">string</span>   <span class="string">`json:&quot;status&quot;`</span>          <span class="comment">// 状态</span></span><br><span class="line">    ClientTimestamp <span class="type">int64</span>    <span class="string">`json:&quot;client_timestamp&quot;`</span><span class="comment">// 确认时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PendingMessageInfo 表示等待确认的消息信息</span></span><br><span class="line"><span class="keyword">type</span> PendingMessageInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    ClientID    <span class="type">string</span>      <span class="comment">// 客户端ID</span></span><br><span class="line">    Message     *Message    <span class="comment">// 原始消息</span></span><br><span class="line">    SentTime    <span class="type">int64</span>       <span class="comment">// 发送时间</span></span><br><span class="line">    RetryCount  <span class="type">int</span>         <span class="comment">// 重试次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器端-push-管理器实现">服务器端 Push 管理器实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PushManager 负责管理推送消息和确认</span></span><br><span class="line"><span class="keyword">type</span> PushManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    pendingMessages    <span class="keyword">map</span>[<span class="type">string</span>]*PendingMessageInfo  <span class="comment">// 等待确认的消息</span></span><br><span class="line">    clientMessageCount <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>                  <span class="comment">// 每个客户端的消息数量</span></span><br><span class="line">    ackTimeout         <span class="type">int64</span>                           <span class="comment">// 确认超时时间(秒)</span></span><br><span class="line">    maxRetries         <span class="type">int</span>                             <span class="comment">// 最大重试次数</span></span><br><span class="line">    maxPendingPerClient <span class="type">int</span>                            <span class="comment">// 每客户端最大消息数</span></span><br><span class="line">    maxMessageAge      <span class="type">int64</span>                           <span class="comment">// 消息最大生存时间(秒)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存监控相关</span></span><br><span class="line">    memoryThresholdMB  <span class="type">int64</span>                           <span class="comment">// 内存阈值(MB)</span></span><br><span class="line">    criticalThresholdMB <span class="type">int64</span>                          <span class="comment">// 危险内存阈值(MB)</span></span><br><span class="line"></span><br><span class="line">    mutex              sync.RWMutex                    <span class="comment">// 保护并发访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网络接口（依赖外部实现）</span></span><br><span class="line">    networkLayer       NetworkInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPushManager 创建一个新的推送管理器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPushManager</span><span class="params">(networkLayer NetworkInterface)</span></span> *PushManager &#123;</span><br><span class="line">    pm := &amp;PushManager&#123;</span><br><span class="line">        pendingMessages:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*PendingMessageInfo),</span><br><span class="line">        clientMessageCount:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>),</span><br><span class="line">        ackTimeout:          <span class="number">10</span>,</span><br><span class="line">        maxRetries:          <span class="number">3</span>,</span><br><span class="line">        maxPendingPerClient: <span class="number">1000</span>,</span><br><span class="line">        maxMessageAge:       <span class="number">300</span>,</span><br><span class="line">        memoryThresholdMB:   <span class="number">1000</span>,  <span class="comment">// 1GB</span></span><br><span class="line">        criticalThresholdMB: <span class="number">1500</span>,  <span class="comment">// 1.5GB</span></span><br><span class="line">        networkLayer:        networkLayer,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动后台任务</span></span><br><span class="line">    <span class="keyword">go</span> pm.checkTimeoutsLoop()</span><br><span class="line">    <span class="keyword">go</span> pm.cleanupLoop()</span><br><span class="line">    <span class="keyword">go</span> pm.memoryMonitorLoop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushMessage 向客户端推送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> PushMessage(clientID <span class="type">string</span>, message *Message) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不需要确认，直接发送</span></span><br><span class="line">    <span class="keyword">if</span> !message.RequiresAck &#123;</span><br><span class="line">        <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查客户端消息数是否超限</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &gt;= pm.maxPendingPerClient &#123;</span><br><span class="line">        pm.handleQueueOverflow(clientID, message)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储待确认消息</span></span><br><span class="line">    pm.pendingMessages[message.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">        ClientID:    clientID,</span><br><span class="line">        Message:     message,</span><br><span class="line">        SentTime:    time.Now().Unix(),</span><br><span class="line">        RetryCount:  <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新客户端消息计数</span></span><br><span class="line">    pm.clientMessageCount[clientID]++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProcessAck 处理客户端的确认消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> ProcessAck(clientID <span class="type">string</span>, ack *AckMessage) <span class="type">bool</span> &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    info, exists := pm.pendingMessages[ack.AckID]</span><br><span class="line">    <span class="keyword">if</span> !exists || info.ClientID != clientID &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认成功，删除消息</span></span><br><span class="line">    <span class="built_in">delete</span>(pm.pendingMessages, ack.AckID)</span><br><span class="line">    pm.clientMessageCount[clientID]--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客户端没有待确认消息了，清理计数器</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProcessBatchAck 处理批量确认</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> ProcessBatchAck(clientID <span class="type">string</span>, batchAck *BatchAckMessage) <span class="type">int</span> &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    confirmedCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, ackID := <span class="keyword">range</span> batchAck.AckIDs &#123;</span><br><span class="line">        info, exists := pm.pendingMessages[ackID]</span><br><span class="line">        <span class="keyword">if</span> exists &amp;&amp; info.ClientID == clientID &#123;</span><br><span class="line">            <span class="built_in">delete</span>(pm.pendingMessages, ackID)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line">            confirmedCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客户端没有待确认消息了，清理计数器</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> confirmedCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台任务：超时检查与重试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> checkTimeoutsLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        pm.checkTimeouts()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时检查与重试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> checkTimeouts() &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    now := time.Now().Unix()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.pendingMessages &#123;</span><br><span class="line">        <span class="comment">// 检查是否超时</span></span><br><span class="line">        <span class="keyword">if</span> now - info.SentTime &gt; pm.ackTimeout &#123;</span><br><span class="line">            <span class="keyword">if</span> info.RetryCount &lt; pm.maxRetries &#123;</span><br><span class="line">                <span class="comment">// 增加重试次数</span></span><br><span class="line">                info.RetryCount++</span><br><span class="line">                info.SentTime = now</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新发送</span></span><br><span class="line">                pm.networkLayer.SendToClient(info.ClientID, info.Message)</span><br><span class="line">                log.Printf(<span class="string">&quot;Retrying message %s to client %s, attempt %d&quot;</span>,</span><br><span class="line">                          msgID, info.ClientID, info.RetryCount)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 超出最大重试次数，放弃并记录</span></span><br><span class="line">                log.Printf(<span class="string">&quot;Message %s to client %s failed after %d attempts&quot;</span>,</span><br><span class="line">                          msgID, info.ClientID, pm.maxRetries)</span><br><span class="line"></span><br><span class="line">                <span class="built_in">delete</span>(pm.pendingMessages, msgID)</span><br><span class="line">                pm.clientMessageCount[info.ClientID]--</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通知业务层处理失败</span></span><br><span class="line">                <span class="keyword">go</span> pm.notifyMessageFailed(info.ClientID, info.Message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决内存暴涨问题">解决内存暴涨问题</h2><p>在大型游戏中，服务器可能同时维护数十万甚至上百万个连接，如果每个连接都有数百条待确认消息，服务器内存很快就会爆满。以下是我在实践中总结的几种高效内存管理策略：</p><h3 id="周期性过期消息清理">1. 周期性过期消息清理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清理过期消息的后台循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> cleanupLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Minute)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        pm.cleanExpiredMessages()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理过期消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> cleanExpiredMessages() &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    now := time.Now().Unix()</span><br><span class="line">    expiredCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.pendingMessages &#123;</span><br><span class="line">        <span class="comment">// 检查消息是否过期</span></span><br><span class="line">        <span class="keyword">if</span> now - info.SentTime &gt; pm.maxMessageAge &#123;</span><br><span class="line">            <span class="built_in">delete</span>(pm.pendingMessages, msgID)</span><br><span class="line">            pm.clientMessageCount[info.ClientID]--</span><br><span class="line">            expiredCount++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">            log.Printf(<span class="string">&quot;Cleaned expired message %s to client %s (age: %d seconds)&quot;</span>,</span><br><span class="line">                      msgID, info.ClientID, now - info.SentTime)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> expiredCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Cleanup: Removed %d expired messages&quot;</span>, expiredCount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息压缩与合并">2. 消息压缩与合并</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompressMessage 压缩消息以减少内存占用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompressMessage</span><span class="params">(message *Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="comment">// 将消息转为JSON</span></span><br><span class="line">    jsonData, err := json.Marshal(message)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error marshaling message: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用gzip压缩</span></span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    writer := gzip.NewWriter(&amp;buf)</span><br><span class="line"></span><br><span class="line">    _, err = writer.Write(jsonData)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error compressing message: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := writer.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error closing gzip writer: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DecompressMessage 解压缩消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecompressMessage</span><span class="params">(compressed []<span class="type">byte</span>)</span></span> (*Message, <span class="type">error</span>) &#123;</span><br><span class="line">    reader, err := gzip.NewReader(bytes.NewReader(compressed))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;create gzip reader: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> reader.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(&amp;buf, reader); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;decompress data: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> message Message</span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(buf.Bytes(), &amp;message); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unmarshal json: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;message, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分级存储策略">3. 分级存储策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PushManager 增加分级存储功能</span></span><br><span class="line"><span class="keyword">type</span> PushManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ... 之前的字段 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存中存储高优先级消息</span></span><br><span class="line">    memoryPending     <span class="keyword">map</span>[<span class="type">string</span>]*PendingMessageInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis客户端，用于存储低优先级消息</span></span><br><span class="line">    redisClient      *redis.Client</span><br><span class="line">    redisKeyPrefix   <span class="type">string</span></span><br><span class="line">    redisExpiry      time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushMessage 分级存储版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> PushMessage(clientID <span class="type">string</span>, message *Message) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不需要确认，直接发送</span></span><br><span class="line">    <span class="keyword">if</span> !message.RequiresAck &#123;</span><br><span class="line">        <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查客户端消息数量限制</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &gt;= pm.maxPendingPerClient &#123;</span><br><span class="line">        pm.handleQueueOverflow(clientID, message)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm.clientMessageCount[clientID]++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据优先级选择存储位置</span></span><br><span class="line">    <span class="keyword">if</span> message.Priority &lt;= <span class="number">2</span> &#123; <span class="comment">// 高优先级和中优先级</span></span><br><span class="line">        <span class="comment">// 存入内存</span></span><br><span class="line">        pm.memoryPending[message.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">            ClientID:    clientID,</span><br><span class="line">            Message:     message,</span><br><span class="line">            SentTime:    time.Now().Unix(),</span><br><span class="line">            RetryCount:  <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 低优先级</span></span><br><span class="line">        <span class="comment">// 存入Redis</span></span><br><span class="line">        messageInfo := &amp;PendingMessageInfo&#123;</span><br><span class="line">            ClientID:    clientID,</span><br><span class="line">            Message:     message,</span><br><span class="line">            SentTime:    time.Now().Unix(),</span><br><span class="line">            RetryCount:  <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jsonData, err := json.Marshal(messageInfo)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error marshaling message: %v&quot;</span>, err)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        redisKey := pm.redisKeyPrefix + message.MsgID</span><br><span class="line">        err = pm.redisClient.Set(context.Background(), redisKey, jsonData, pm.redisExpiry).Err()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error storing message in Redis: %v&quot;</span>, err)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProcessAck 分级存储版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> ProcessAck(clientID <span class="type">string</span>, ack *AckMessage) <span class="type">bool</span> &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查内存中的消息</span></span><br><span class="line">    info, existsInMemory := pm.memoryPending[ack.AckID]</span><br><span class="line">    <span class="keyword">if</span> existsInMemory &amp;&amp; info.ClientID == clientID &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pm.memoryPending, ack.AckID)</span><br><span class="line">        pm.clientMessageCount[clientID]--</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再检查Redis中的消息</span></span><br><span class="line">    redisKey := pm.redisKeyPrefix + ack.AckID</span><br><span class="line">    exists, err := pm.redisClient.Exists(context.Background(), redisKey).Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error checking message in Redis: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> exists == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 获取消息以验证客户端ID</span></span><br><span class="line">        jsonData, err := pm.redisClient.Get(context.Background(), redisKey).Bytes()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error getting message from Redis: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> messageInfo PendingMessageInfo</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(jsonData, &amp;messageInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error unmarshaling message from Redis: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> messageInfo.ClientID == clientID &#123;</span><br><span class="line">            <span class="comment">// 从Redis删除并更新计数</span></span><br><span class="line">            pm.redisClient.Del(context.Background(), redisKey)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存自适应调整">4. 内存自适应调整</h3><p>内存自适应调整是我在实际项目中解决突发流量问题的关键策略。它能够根据当前系统负载动态调整消息处理参数，确保系统稳定性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存监控循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> memoryMonitorLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">10</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        memoryMB := pm.getMemoryUsageMB()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> memoryMB &gt; pm.criticalThresholdMB &#123;</span><br><span class="line">            <span class="comment">// 紧急情况，进行应急清理</span></span><br><span class="line">            pm.emergencyCleanup(memoryMB)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> memoryMB &gt; pm.memoryThresholdMB &#123;</span><br><span class="line">            <span class="comment">// 超过警戒线，调整参数</span></span><br><span class="line">            pm.adjustParameters(memoryMB)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前进程内存使用量（MB）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> getMemoryUsageMB() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> memStats runtime.MemStats</span><br><span class="line">    runtime.ReadMemStats(&amp;memStats)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(memStats.Alloc / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据内存使用情况调整参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> adjustParameters(currentMemoryMB <span class="type">int64</span>) &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算内存超出比例</span></span><br><span class="line">    excessRatio := <span class="type">float64</span>(currentMemoryMB - pm.memoryThresholdMB) / <span class="type">float64</span>(pm.memoryThresholdMB)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整每客户端最大消息数</span></span><br><span class="line">    newMaxPerClient := <span class="type">int</span>(<span class="type">float64</span>(pm.maxPendingPerClient) * (<span class="number">1</span> - excessRatio*<span class="number">0.5</span>))</span><br><span class="line">    <span class="keyword">if</span> newMaxPerClient &lt; <span class="number">100</span> &#123;</span><br><span class="line">        newMaxPerClient = <span class="number">100</span> <span class="comment">// 确保至少保留100条</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整消息最大生存时间</span></span><br><span class="line">    newMaxAge := <span class="type">int64</span>(<span class="type">float64</span>(pm.maxMessageAge) * (<span class="number">1</span> - excessRatio*<span class="number">0.5</span>))</span><br><span class="line">    <span class="keyword">if</span> newMaxAge &lt; <span class="number">60</span> &#123;</span><br><span class="line">        newMaxAge = <span class="number">60</span> <span class="comment">// 至少60秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新参数</span></span><br><span class="line">    pm.maxPendingPerClient = newMaxPerClient</span><br><span class="line">    pm.maxMessageAge = newMaxAge</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;Memory usage: %d MB, adjusted parameters: maxPending=%d, maxAge=%ds&quot;</span>,</span><br><span class="line">               currentMemoryMB, pm.maxPendingPerClient, pm.maxMessageAge)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一次清理</span></span><br><span class="line">    pm.cleanExpiredMessages()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧急清理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> emergencyCleanup(currentMemoryMB <span class="type">int64</span>) &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;CRITICAL: Memory usage at %d MB, performing emergency cleanup&quot;</span>, currentMemoryMB)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大幅降低参数</span></span><br><span class="line">    pm.maxPendingPerClient = <span class="number">100</span></span><br><span class="line">    pm.maxMessageAge = <span class="number">60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理低优先级消息</span></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.memoryPending &#123;</span><br><span class="line">        <span class="keyword">if</span> info.Message.Priority &gt; <span class="number">1</span> &#123; <span class="comment">// 只保留最高优先级</span></span><br><span class="line">            <span class="built_in">delete</span>(pm.memoryPending, msgID)</span><br><span class="line">            pm.clientMessageCount[info.ClientID]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;Emergency cleanup completed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列溢出处理策略">5. 队列溢出处理策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理队列溢出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> handleQueueOverflow(clientID <span class="type">string</span>, newMessage *Message) &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Queue overflow for client %s&quot;</span>, clientID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略1: 根据消息优先级决定是否替换现有消息</span></span><br><span class="line">    <span class="keyword">if</span> newMessage.Priority == <span class="number">1</span> &#123; <span class="comment">// 高优先级消息</span></span><br><span class="line">        <span class="comment">// 查找并替换该客户端的一条低优先级消息</span></span><br><span class="line">        <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.memoryPending &#123;</span><br><span class="line">            <span class="keyword">if</span> info.ClientID == clientID &amp;&amp; info.Message.Priority &gt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// 记录</span></span><br><span class="line">                log.Printf(<span class="string">&quot;Replacing low priority message %s with high priority message&quot;</span>, msgID)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 删除旧消息</span></span><br><span class="line">                <span class="built_in">delete</span>(pm.memoryPending, msgID)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加新消息</span></span><br><span class="line">                pm.memoryPending[newMessage.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">                    ClientID:    clientID,</span><br><span class="line">                    Message:     newMessage,</span><br><span class="line">                    SentTime:    time.Now().Unix(),</span><br><span class="line">                    RetryCount:  <span class="number">0</span>,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送新消息</span></span><br><span class="line">                pm.networkLayer.SendToClient(clientID, newMessage)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略2: 丢弃旧消息以腾出空间</span></span><br><span class="line">    <span class="comment">// 查找该客户端最旧的消息</span></span><br><span class="line">    <span class="keyword">var</span> oldestMsgID <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> oldestTime <span class="type">int64</span> = math.MaxInt64</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.memoryPending &#123;</span><br><span class="line">        <span class="keyword">if</span> info.ClientID == clientID &amp;&amp; info.SentTime &lt; oldestTime &#123;</span><br><span class="line">            oldestMsgID = msgID</span><br><span class="line">            oldestTime = info.SentTime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldestMsgID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Dropping oldest message %s for client %s&quot;</span>, oldestMsgID, clientID)</span><br><span class="line">        <span class="built_in">delete</span>(pm.memoryPending, oldestMsgID)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加新消息</span></span><br><span class="line">        pm.memoryPending[newMessage.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">            ClientID:    clientID,</span><br><span class="line">            Message:     newMessage,</span><br><span class="line">            SentTime:    time.Now().Unix(),</span><br><span class="line">            RetryCount:  <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送新消息</span></span><br><span class="line">        pm.networkLayer.SendToClient(clientID, newMessage)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 极端情况，无法找到可替换的消息</span></span><br><span class="line">        log.Printf(<span class="string">&quot;Cannot find message to replace for client %s&quot;</span>, clientID)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端实现">客户端实现</h2><p>客户端实现同样关键，特别是批量确认机制能显著减少网络流量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PushReceiver 客户端推送接收处理器</span></span><br><span class="line"><span class="keyword">type</span> PushReceiver <span class="keyword">struct</span> &#123;</span><br><span class="line">    connection        Connection          <span class="comment">// 网络连接接口</span></span><br><span class="line">    processedMsgIDs   <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>    <span class="comment">// 已处理消息ID及处理时间</span></span><br><span class="line">    pendingAcks       []<span class="type">string</span>            <span class="comment">// 待确认的消息ID</span></span><br><span class="line">    ackBatchSize      <span class="type">int</span>                 <span class="comment">// 批量确认大小</span></span><br><span class="line">    ackInterval       time.Duration       <span class="comment">// 批量确认间隔</span></span><br><span class="line">    messageHandlers   <span class="keyword">map</span>[<span class="type">string</span>]MessageHandler <span class="comment">// 消息处理函数</span></span><br><span class="line"></span><br><span class="line">    mutex             sync.Mutex          <span class="comment">// 保护并发访问</span></span><br><span class="line">    stopChan          <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;       <span class="comment">// 停止信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageHandler 消息处理函数类型</span></span><br><span class="line"><span class="keyword">type</span> MessageHandler <span class="function"><span class="keyword">func</span><span class="params">(payload <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPushReceiver 创建推送接收器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPushReceiver</span><span class="params">(conn Connection)</span></span> *PushReceiver &#123;</span><br><span class="line">    receiver := &amp;PushReceiver&#123;</span><br><span class="line">        connection:       conn,</span><br><span class="line">        processedMsgIDs:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>),</span><br><span class="line">        pendingAcks:      <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>),</span><br><span class="line">        ackBatchSize:     <span class="number">50</span>,</span><br><span class="line">        ackInterval:      time.Second,</span><br><span class="line">        messageHandlers:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]MessageHandler),</span><br><span class="line">        stopChan:         <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动批量确认任务</span></span><br><span class="line">    <span class="keyword">go</span> receiver.ackLoop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动过期消息ID清理任务</span></span><br><span class="line">    <span class="keyword">go</span> receiver.cleanupLoop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterHandler 注册消息处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> RegisterHandler(msgType <span class="type">string</span>, handler MessageHandler) &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    r.messageHandlers[msgType] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleMessage 处理收到的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> HandleMessage(message *Message) &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    msgID := message.MsgID</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已处理过该消息</span></span><br><span class="line">    <span class="keyword">if</span> _, exists := r.processedMsgIDs[msgID]; exists &#123;</span><br><span class="line">        <span class="comment">// 已处理过，再次发送确认</span></span><br><span class="line">        <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">            r.pendingAcks = <span class="built_in">append</span>(r.pendingAcks, msgID)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果积累的确认数量超过批量大小，立即发送</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(r.pendingAcks) &gt;= r.ackBatchSize &#123;</span><br><span class="line">                <span class="keyword">go</span> r.sendBatchAcks()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找处理函数</span></span><br><span class="line">    handler, exists := r.messageHandlers[message.MsgType]</span><br><span class="line">    <span class="keyword">if</span> !exists &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;No handler for message type: %s&quot;</span>, message.MsgType)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未知消息类型也需要确认</span></span><br><span class="line">        <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">            r.sendErrorAck(msgID, <span class="string">&quot;Unknown message type&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    err := handler(message.Payload)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error processing message %s: %v&quot;</span>, msgID, err)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">            r.sendErrorAck(msgID, err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录已处理的消息</span></span><br><span class="line">    r.processedMsgIDs[msgID] = time.Now().Unix()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要确认，加入待确认队列</span></span><br><span class="line">    <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">        r.pendingAcks = <span class="built_in">append</span>(r.pendingAcks, msgID)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果积累的确认数量超过批量大小，立即发送</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(r.pendingAcks) &gt;= r.ackBatchSize &#123;</span><br><span class="line">            <span class="keyword">go</span> r.sendBatchAcks()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送批量确认</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> sendBatchAcks() &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有待确认消息，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(r.pendingAcks) == <span class="number">0</span> &#123;</span><br><span class="line">        r.mutex.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制当前的待确认ID列表</span></span><br><span class="line">    ackIDs := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(r.pendingAcks))</span><br><span class="line">    <span class="built_in">copy</span>(ackIDs, r.pendingAcks)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空待确认列表</span></span><br><span class="line">    r.pendingAcks = r.pendingAcks[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建批量确认消息</span></span><br><span class="line">    batchAck := &amp;BatchAckMessage&#123;</span><br><span class="line">        BatchAck:        <span class="literal">true</span>,</span><br><span class="line">        AckIDs:          ackIDs,</span><br><span class="line">        Status:          <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        ClientTimestamp: time.Now().Unix(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送确认</span></span><br><span class="line">    r.connection.Send(batchAck)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送错误确认</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> sendErrorAck(msgID <span class="type">string</span>, errorMessage <span class="type">string</span>) &#123;</span><br><span class="line">    ack := &amp;AckMessage&#123;</span><br><span class="line">        AckID:           msgID,</span><br><span class="line">        Status:          <span class="string">&quot;failed&quot;</span>,</span><br><span class="line">        ClientTimestamp: time.Now().Unix(),</span><br><span class="line">        ErrorCode:       <span class="number">1001</span>,</span><br><span class="line">        ErrorMessage:    errorMessage,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.connection.Send(ack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量确认定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> ackLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(r.ackInterval)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            r.sendBatchAcks()</span><br><span class="line">        <span class="keyword">case</span> &lt;-r.stopChan:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理过期的已处理消息ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> cleanupLoop() &#123;</span><br><span class="line">    <span class="comment">// 每小时清理一次</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Hour)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            r.cleanupProcessedIDs()</span><br><span class="line">        <span class="keyword">case</span> &lt;-r.stopChan:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理过期的已处理消息ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> cleanupProcessedIDs() &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    now := time.Now().Unix()</span><br><span class="line">    expireTime := <span class="type">int64</span>(<span class="number">86400</span>) <span class="comment">// 24小时过期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, processTime := <span class="keyword">range</span> r.processedMsgIDs &#123;</span><br><span class="line">        <span class="keyword">if</span> now - processTime &gt; expireTime &#123;</span><br><span class="line">            <span class="built_in">delete</span>(r.processedMsgIDs, msgID)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭推送接收器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> Close() &#123;</span><br><span class="line">    <span class="comment">// 发送所有待确认消息</span></span><br><span class="line">    r.sendBatchAcks()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止所有后台任务</span></span><br><span class="line">    <span class="built_in">close</span>(r.stopChan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战经验与最佳实践">实战经验与最佳实践</h2><p>在多个千万用户级别的游戏项目实践中，我总结了以下几点 Push-ACK机制的最佳实践：</p><h3 id="消息分级是关键">1. 消息分级是关键</h3><p>不是所有消息都需要相同级别的可靠性保证。在一个 MMORPG项目中，我们将消息分为四级：</p><ul><li><strong>关键级</strong>：直接影响游戏平衡和经济的消息，如道具获取、货币变化</li><li><strong>重要级</strong>：影响游戏进程的消息，如任务更新、排行榜变动</li><li><strong>普通级</strong>：一般游戏状态信息，如其他玩家动作、环境变化</li><li><strong>低优先级</strong>：可以容忍丢失的背景信息，如聊天、天气效果</li></ul><p>高级别消息使用完整的 ACK 机制，低级别消息可以简化甚至取消 ACK需求，这样大大减轻了服务器内存压力。</p><h3 id="利用统计指标进行调优">2. 利用统计指标进行调优</h3><p>监控以下关键指标：</p><ul><li>ACK 响应时间分布</li><li>消息重试率</li><li>每客户端平均待确认消息数</li><li>内存使用增长曲线</li></ul><p>在一个足球经理类游戏中，通过这些指标我们发现，将 ACK 超时时间从 10秒调整到 5 秒，并将最大重试次数从 3 次增加到 5次，可以将消息最终确认率从 99.2%提高到 99.8%，同时减少了25%的内存使用。</p><h3 id="针对不同网络环境优化">3. 针对不同网络环境优化</h3><p>移动网络环境差异很大，针对不同网络条件动态调整策略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据网络条件调整参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> adjustForNetworkCondition(clientID <span class="type">string</span>, rtt time.Duration) &#123;</span><br><span class="line">    <span class="comment">// 网络条件良好</span></span><br><span class="line">    <span class="keyword">if</span> rtt &lt; <span class="number">100</span>*time.Millisecond &#123;</span><br><span class="line">        pm.clientTimeouts[clientID] = <span class="number">3</span> <span class="comment">// 3秒超时</span></span><br><span class="line">        pm.clientRetries[clientID] = <span class="number">2</span>  <span class="comment">// 2次重试</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> rtt &lt; <span class="number">300</span>*time.Millisecond &#123;</span><br><span class="line">        pm.clientTimeouts[clientID] = <span class="number">5</span> <span class="comment">// 5秒超时</span></span><br><span class="line">        pm.clientRetries[clientID] = <span class="number">3</span>  <span class="comment">// 3次重试</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pm.clientTimeouts[clientID] = <span class="number">10</span> <span class="comment">// 10秒超时</span></span><br><span class="line">        pm.clientRetries[clientID] = <span class="number">5</span>   <span class="comment">// 5次重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定期压力测试">4. 定期压力测试</h3><p>在一个大型开放世界游戏中，我们每月进行一次"混沌测试"，模拟极端情况：</p><ol type="1"><li>突发 50%客户端同时掉线然后重连</li><li>模拟网络延迟突然从 50ms 增加到 500ms</li><li>模拟 10%的确认消息丢失</li></ol><p>这种测试让我们发现了很多边缘情况，并建立了更健壮的防御机制。</p><h2 id="结论">结论</h2><p>一个设计良好的 Push-ACK机制是现代游戏服务器架构的核心组件。它确保了游戏状态的一致性，提升了玩家体验，同时也为运营团队提供了可靠的数据基础。最重要的是，它必须是高性能且资源友好的。</p><p>通过采用本文介绍的多级存储、自适应参数调整、消息优先级和过期策略等技术，我们可以构建一个既可靠又高效的推送确认系统，即使在面对数十万并发</p>]]></content>
    
    
    <summary type="html">本文介绍了游戏后端中的 Push-ACK 机制的设计与实现，特别关注如何避免内存暴涨问题，分享了在多个大型游戏项目中积累的经验与教训。</summary>
    
    
    
    <category term="解决方案" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="游戏后端" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%B8%B8%E6%88%8F%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="解决方案" scheme="https://hedon.top/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="游戏后端" scheme="https://hedon.top/tags/%E6%B8%B8%E6%88%8F%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Push-Ack" scheme="https://hedon.top/tags/Push-Ack/"/>
    
  </entry>
  
  <entry>
    <title>服务监控丨Prometheus 四大数据类型详解</title>
    <link href="https://hedon.top/2025/02/26/prometheus-data-type/"/>
    <id>https://hedon.top/2025/02/26/prometheus-data-type/</id>
    <published>2025-02-26T07:52:10.000Z</published>
    <updated>2025-04-05T14:31:32.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在微服务和云原生架构的世界中，一套强大的监控系统是保障服务稳定性的基石。Prometheus作为 CNCF的明星项目，凭借其简单高效的特性，已成为事实上的云原生监控标准。本文将深入剖析Prometheus 的四大数据类型及其 PromQL查询语言，帮助开发团队构建强大的可观测性系统。</p><h2 id="结论先行prometheus-四大数据类型速览">结论先行：Prometheus四大数据类型速览</h2><table style="width:100%;"><colgroup><col style="width: 12%" /><col style="width: 22%" /><col style="width: 19%" /><col style="width: 19%" /><col style="width: 26%" /></colgroup><thead><tr class="header"><th>特性</th><th>Counter</th><th>Gauge</th><th>Histogram</th><th>Summary</th></tr></thead><tbody><tr class="odd"><td><strong>定义</strong></td><td>只增不减的累积计数器</td><td>可增可减的瞬时值</td><td>观测值分布的分桶统计</td><td>客户端计算的分位数统计</td></tr><tr class="even"><td><strong>重置行为</strong></td><td>服务重启时归零</td><td>保持当前值</td><td>桶计数归零</td><td>计数归零</td></tr><tr class="odd"><td><strong>典型应用</strong></td><td>请求计数、错误数、流量统计</td><td>温度、内存使用、连接数</td><td>请求延迟、响应大小</td><td>请求延迟、队列等待时间</td></tr><tr class="even"><td><strong>数据点</strong></td><td>单一值</td><td>单一值</td><td>_bucket、_sum、count</td><td>{quantile="x"}、_sum、_count</td></tr><tr class="odd"><td><strong>查询重点</strong></td><td>rate()、increase()</td><td>直接使用、预测函数</td><td>histogram_quantile()</td><td>直接读取分位数</td></tr><tr class="even"><td><strong>分布式聚合</strong></td><td>可以（sum、rate）</td><td>可以（avg、max、min）</td><td>可以（百分位也可聚合）</td><td>有限（分位数不可聚合）</td></tr><tr class="odd"><td><strong>资源消耗</strong></td><td>低</td><td>低</td><td>中（依赖桶数量）</td><td>中（客户端计算）</td></tr></tbody></table><h2 id="一prometheus-核心数据类型详解">一、Prometheus核心数据类型详解</h2><h3 id="counter计数器持续增长的累积值">1.Counter（计数器）：持续增长的累积值</h3><p>Counter是最简单但也最常用的指标类型，代表一个只增不减的累积数值。每当事件发生，计数器增加；当监控目标重启时，计数器归零。</p><p><strong>适用场景</strong>：</p><ul><li>API 请求总数</li><li>错误发生次数</li><li>处理任务的数量</li><li>网络流量字节数</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的计数器</span></span><br><span class="line">requestCounter := prometheus.NewCounterVec(</span><br><span class="line">    prometheus.CounterOpts&#123;</span><br><span class="line">        Name: <span class="string">&quot;http_requests_total&quot;</span>,</span><br><span class="line">        Help: <span class="string">&quot;Total number of HTTP requests&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;method&quot;</span>, <span class="string">&quot;path&quot;</span>, <span class="string">&quot;status&quot;</span>&#125;, <span class="comment">// 定义标签维度</span></span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(requestCounter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用标签记录请求</span></span><br><span class="line">requestCounter.WithLabelValues(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>, <span class="string">&quot;200&quot;</span>).Inc()</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 每秒请求率（5分钟窗口）</span><br><span class="line">rate(http_requests_total&#123;status=&quot;200&quot;&#125;[5m])</span><br><span class="line"></span><br><span class="line"># 错误率计算</span><br><span class="line">sum(rate(http_requests_total&#123;status=~&quot;5..&quot;&#125;[5m])) / sum(rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># 1小时内的请求增量</span><br><span class="line">increase(http_requests_total[1h])</span><br></pre></td></tr></table></figure><p><strong>最佳实践</strong>：</p><ul><li>永远不要直接使用 Counter 的原始值，总是使用 <code>rate()</code> 或<code>increase()</code></li><li>使用有意义的标签进行多维度分析，但避免高基数标签</li><li>Counter 重置（如服务重启）会被 <code>rate()</code> 函数自动处理</li></ul><h3 id="gauge仪表盘可变的瞬时值">2. Gauge（仪表盘）：可变的瞬时值</h3><p>Gauge 表示一个可增可减的瞬时测量值，反映系统的当前状态。</p><p><strong>适用场景</strong>：</p><ul><li>内存使用量</li><li>CPU 使用率</li><li>当前活跃连接数</li><li>队列深度</li><li>温度等物理量</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的仪表盘</span></span><br><span class="line">memoryGauge := prometheus.NewGaugeVec(</span><br><span class="line">    prometheus.GaugeOpts&#123;</span><br><span class="line">        Name: <span class="string">&quot;app_memory_usage_bytes&quot;</span>,</span><br><span class="line">        Help: <span class="string">&quot;Current memory usage in bytes&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;component&quot;</span>, <span class="string">&quot;instance&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(memoryGauge)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前值</span></span><br><span class="line">memoryGauge.WithLabelValues(<span class="string">&quot;api-server&quot;</span>, <span class="string">&quot;instance-1&quot;</span>).Set(<span class="type">float64</span>(getCurrentMemoryUsage()))</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 直接使用当前值</span><br><span class="line">app_memory_usage_bytes&#123;component=&quot;api-server&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 统计聚合</span><br><span class="line">avg_over_time(app_memory_usage_bytes[1h])</span><br><span class="line">max_over_time(app_memory_usage_bytes[24h])</span><br><span class="line"></span><br><span class="line"># 趋势预测（线性回归）</span><br><span class="line">predict_linear(app_memory_usage_bytes[6h], 4 * 3600)</span><br><span class="line"></span><br><span class="line"># 计算变化率</span><br><span class="line">(app_memory_usage_bytes - app_memory_usage_bytes offset 1h) / app_memory_usage_bytes offset 1h</span><br></pre></td></tr></table></figure><p><strong>最佳实践</strong>：</p><ul><li>Gauge 可以直接使用其瞬时值，不需要像 Counter 那样使用 rate</li><li>对于容易波动的指标，考虑使用 <code>avg_over_time</code>平滑数据</li><li>利用 <code>predict_linear</code> 进行容量规划和趋势预测</li></ul><h3 id="histogram直方图观测值分布的分桶统计">3.Histogram（直方图）：观测值分布的分桶统计</h3><p>Histogram允许对观测值（如请求延迟）进行分布式统计，将数据分散到预定义的桶中，是分析性能分布的理想工具。</p><p><strong>自动生成的指标</strong>：</p><ul><li><code>&lt;metric&gt;_bucket&#123;le="&lt;upper bound&gt;"&#125;</code>:小于等于特定阈值的观测值计数</li><li><code>&lt;metric&gt;_sum</code>: 所有观测值的总和</li><li><code>&lt;metric&gt;_count</code>: 观测值总数</li></ul><p><strong>适用场景</strong>：</p><ul><li>请求延迟分布</li><li>响应大小分布</li><li>批处理任务执行时间</li><li>任何需要百分位数分析的场景</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的直方图</span></span><br><span class="line">durationHistogram := prometheus.NewHistogramVec(</span><br><span class="line">    prometheus.HistogramOpts&#123;</span><br><span class="line">        Name:    <span class="string">&quot;http_request_duration_seconds&quot;</span>,</span><br><span class="line">        Help:    <span class="string">&quot;HTTP request duration in seconds&quot;</span>,</span><br><span class="line">        Buckets: prometheus.ExponentialBuckets(<span class="number">0.001</span>, <span class="number">2</span>, <span class="number">10</span>), <span class="comment">// 从1ms开始指数增长</span></span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;method&quot;</span>, <span class="string">&quot;path&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(durationHistogram)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录请求延迟</span></span><br><span class="line">durationHistogram.WithLabelValues(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>).Observe(responseTime)</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 计算平均响应时间</span><br><span class="line">rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])</span><br><span class="line"></span><br><span class="line"># 计算P90延迟</span><br><span class="line">histogram_quantile(0.9, rate(http_request_duration_seconds_bucket[5m]))</span><br><span class="line"></span><br><span class="line"># 按API路径分析P95延迟</span><br><span class="line">histogram_quantile(0.95, sum by(path, le) (rate(http_request_duration_seconds_bucket[5m])))</span><br><span class="line"></span><br><span class="line"># 计算SLO：延迟小于100ms的请求比例</span><br><span class="line">sum(rate(http_request_duration_seconds_bucket&#123;le=&quot;0.1&quot;&#125;[5m])) / sum(rate(http_request_duration_seconds_count[5m]))</span><br></pre></td></tr></table></figure><p><strong>最佳实践</strong>：</p><ul><li>仔细设计桶边界，覆盖关键分位数区域</li><li>对于延迟指标，通常使用指数桶比线性桶更合理</li><li>利用 <code>histogram_quantile</code> 计算任意分位数</li><li>桶的数量会影响存储和性能，权衡精度和开销</li></ul><h3 id="summary摘要客户端计算的分位数统计">4.Summary（摘要）：客户端计算的分位数统计</h3><p>Summary 与 Histogram类似，但在客户端直接计算并存储分位数，无需服务器端计算。</p><p><strong>自动生成的指标</strong>：</p><ul><li><code>&lt;metric&gt;&#123;quantile="&lt;φ&gt;"&#125;</code>: φ 分位数的值</li><li><code>&lt;metric&gt;_sum</code>: 所有观测值的总和</li><li><code>&lt;metric&gt;_count</code>: 观测值总数</li></ul><p><strong>适用场景</strong>：</p><ul><li>需要高精度分位数的场景</li><li>客户端计算分位数更高效的情况</li><li>对服务器端聚合要求不高的场景</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的摘要</span></span><br><span class="line">durationSummary := prometheus.NewSummaryVec(</span><br><span class="line">    prometheus.SummaryOpts&#123;</span><br><span class="line">        Name:       <span class="string">&quot;http_request_duration_seconds_summary&quot;</span>,</span><br><span class="line">        Help:       <span class="string">&quot;HTTP request duration in seconds&quot;</span>,</span><br><span class="line">        Objectives: <span class="keyword">map</span>[<span class="type">float64</span>]<span class="type">float64</span>&#123;<span class="number">0.5</span>: <span class="number">0.05</span>, <span class="number">0.9</span>: <span class="number">0.01</span>, <span class="number">0.99</span>: <span class="number">0.001</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;method&quot;</span>, <span class="string">&quot;path&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(durationSummary)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录请求延迟</span></span><br><span class="line">durationSummary.WithLabelValues(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/api/login&quot;</span>).Observe(responseTime)</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 直接读取P99延迟</span><br><span class="line">http_request_duration_seconds_summary&#123;quantile=&quot;0.99&quot;, method=&quot;GET&quot;, path=&quot;/api/users&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 计算平均响应时间</span><br><span class="line">rate(http_request_duration_seconds_summary_sum[5m]) / rate(http_request_duration_seconds_summary_count[5m])</span><br><span class="line"></span><br><span class="line"># 每个服务的中位数延迟</span><br><span class="line">max by(service) (http_request_duration_seconds_summary&#123;quantile=&quot;0.5&quot;&#125;)</span><br></pre></td></tr></table></figure><p><strong>最佳实践与限制</strong>：</p><ul><li>Summary 预计算的分位数不能跨实例聚合（这是关键限制）</li><li>适用于分位数精度要求高且实例相对独立的场景</li><li>客户端计算分位数会增加应用资源消耗</li><li>分位数设置后不可更改，需提前规划好监控需求</li></ul><h2 id="二promql-查询语言精通">二、PromQL 查询语言精通</h2><p>PromQL 是 Prometheus的强大武器，掌握它能让我们精确提取所需的监控数据。</p><h3 id="基础查询与标签选择">1. 基础查询与标签选择</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 基本查询与精确匹配</span><br><span class="line">http_requests_total&#123;status=&quot;200&quot;, method=&quot;GET&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 正则表达式匹配</span><br><span class="line">http_requests_total&#123;path=~&quot;/api/v1/.+&quot;, method!=&quot;OPTIONS&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 范围查询（返回时间序列）</span><br><span class="line">http_requests_total&#123;status=&quot;500&quot;&#125;[5m]</span><br></pre></td></tr></table></figure><h3 id="操作符与函数">2. 操作符与函数</h3><p><strong>算术运算符</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 计算内存使用率百分比</span><br><span class="line">100 * (node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes</span><br></pre></td></tr></table></figure><p><strong>聚合函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 按服务和路径分组求和</span><br><span class="line">sum by(service, path) (rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># 丢弃instance标签求最大值</span><br><span class="line">max without(instance) (node_cpu_seconds_total)</span><br></pre></td></tr></table></figure><p><strong>瞬时向量函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 标签替换</span><br><span class="line">label_replace(up, &quot;host&quot;, &quot;$1&quot;, &quot;instance&quot;, &quot;(.*):.*&quot;)</span><br><span class="line"></span><br><span class="line"># 按标签分组取topk</span><br><span class="line">topk by(path) (5, http_request_duration_seconds_sum / http_request_duration_seconds_count)</span><br></pre></td></tr></table></figure><h3 id="复杂查询模式">3. 复杂查询模式</h3><p><strong>SLI/SLO 监控</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 服务可用性SLI</span><br><span class="line">sum(rate(http_requests_total&#123;status=~&quot;2..|3..&quot;&#125;[5m])) / sum(rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># 延迟SLO</span><br><span class="line">histogram_quantile(0.99, sum by(le) (rate(http_request_duration_seconds_bucket[5m]))) &lt; 0.3</span><br></pre></td></tr></table></figure><p><strong>异常检测</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 相对于历史同期的异常增长</span><br><span class="line">rate(http_requests_total[5m])</span><br><span class="line">  &gt; 2 * avg_over_time(rate(http_requests_total[5m])[1d:5m] offset 1d)</span><br></pre></td></tr></table></figure><p><strong>预测分析</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 磁盘空间预测</span><br><span class="line">predict_linear(node_filesystem_free_bytes&#123;mountpoint=&quot;/&quot;&#125;[6h], 7 * 24 * 3600) &lt; 10 * 1024 * 1024 * 1024</span><br></pre></td></tr></table></figure><h2 id="三实战应用场景">三、实战应用场景</h2><h3 id="服务健康度监控">1. 服务健康度监控</h3><p><strong>RED 方法实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Rate - 请求率</span><br><span class="line">sum by(service) (rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># Error - 错误率</span><br><span class="line">sum by(service) (rate(http_requests_total&#123;status=~&quot;5..&quot;&#125;[5m])) / sum by(service) (rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># Duration - P95延迟</span><br><span class="line">histogram_quantile(0.95, sum by(service, le) (rate(http_request_duration_seconds_bucket[5m])))</span><br></pre></td></tr></table></figure><p><strong>服务依赖健康度</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 数据库查询错误率</span><br><span class="line">sum(rate(database_query_errors_total[5m])) / sum(rate(database_queries_total[5m]))</span><br><span class="line"></span><br><span class="line"># 第三方API调用延迟</span><br><span class="line">histogram_quantile(0.99, sum by(api_name, le) (rate(api_request_duration_seconds_bucket[5m])))</span><br></pre></td></tr></table></figure><h3 id="性能瓶颈分析">2. 性能瓶颈分析</h3><p><strong>热点 API 发现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 延迟最高的10个接口</span><br><span class="line">topk(10,</span><br><span class="line">  histogram_quantile(0.95, sum by(method, path, le) (rate(http_request_duration_seconds_bucket[5m])))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 请求量最大的接口</span><br><span class="line">topk(10, sum by(method, path) (rate(http_requests_total[5m])))</span><br></pre></td></tr></table></figure><p><strong>数据库性能分析</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 平均查询时间趋势</span><br><span class="line">rate(db_query_duration_seconds_sum[5m]) / rate(db_query_duration_seconds_count[5m])</span><br><span class="line"></span><br><span class="line"># 慢查询比例</span><br><span class="line">sum(rate(db_query_duration_seconds_bucket&#123;le=&quot;+Inf&quot;&#125;[5m])) - sum(rate(db_query_duration_seconds_bucket&#123;le=&quot;0.1&quot;&#125;[5m])) / sum(rate(db_query_duration_seconds_bucket&#123;le=&quot;+Inf&quot;&#125;[5m]))</span><br></pre></td></tr></table></figure><h3 id="容量规划与告警">3. 容量规划与告警</h3><p><strong>资源预测</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># CPU使用率预测</span><br><span class="line">predict_linear(avg by(instance) (rate(node_cpu_seconds_total&#123;mode!=&quot;idle&quot;&#125;[6h])) [3d:], 7 * 24 * 3600) &gt; 0.85</span><br><span class="line"></span><br><span class="line"># 内存压力告警</span><br><span class="line">(node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes &gt; 0.9</span><br></pre></td></tr></table></figure><p><strong>流量容量规划</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 带宽使用预测</span><br><span class="line">predict_linear(rate(node_network_transmit_bytes_total[12h])[7d:], 30 * 24 * 3600)</span><br></pre></td></tr></table></figure><h2 id="四最佳实践与性能优化">四、最佳实践与性能优化</h2><h3 id="指标命名与标签设计">1. 指标命名与标签设计</h3><p><strong>命名规范</strong>：</p><ul><li>使用 snake_case</li><li>包含单位后缀（_bytes, _seconds, _total）</li><li>保持风格一致性</li></ul><p><strong>标签最佳实践</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合理设计标签维度</span></span><br><span class="line">apiLatency := prometheus.NewHistogramVec(</span><br><span class="line">    prometheus.HistogramOpts&#123;</span><br><span class="line">        Name:    <span class="string">&quot;api_request_duration_seconds&quot;</span>,</span><br><span class="line">        Help:    <span class="string">&quot;API request duration in seconds&quot;</span>,</span><br><span class="line">        Buckets: prometheus.ExponentialBuckets(<span class="number">0.001</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;service&quot;</span>, <span class="string">&quot;endpoint&quot;</span>, <span class="string">&quot;status_code&quot;</span>&#125;, <span class="comment">// 合理的低基数标签</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变标签使用ConstLabels</span></span><br><span class="line">prometheus.NewGaugeVec(</span><br><span class="line">    prometheus.GaugeOpts&#123;</span><br><span class="line">        Name:        <span class="string">&quot;service_info&quot;</span>,</span><br><span class="line">        Help:        <span class="string">&quot;Service information&quot;</span>,</span><br><span class="line">        ConstLabels: prometheus.Labels&#123;<span class="string">&quot;version&quot;</span>: <span class="string">&quot;v2.1.3&quot;</span>, <span class="string">&quot;environment&quot;</span>: <span class="string">&quot;production&quot;</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;instance&quot;</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="客户端性能优化">2. 客户端性能优化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存常用标签组合以提高性能</span></span><br><span class="line">getCounter := requestCounter.WithLabelValues(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>, <span class="string">&quot;200&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    getCounter.Inc() <span class="comment">// 重用标签组合，避免重复创建</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量更新方式</span></span><br><span class="line"><span class="keyword">var</span> rpcDurations = prometheus.NewSummaryVec(</span><br><span class="line">    prometheus.SummaryOpts&#123;</span><br><span class="line">        Name:       <span class="string">&quot;rpc_durations_seconds&quot;</span>,</span><br><span class="line">        Help:       <span class="string">&quot;RPC latency distributions.&quot;</span>,</span><br><span class="line">        Objectives: <span class="keyword">map</span>[<span class="type">float64</span>]<span class="type">float64</span>&#123;<span class="number">0.5</span>: <span class="number">0.05</span>, <span class="number">0.9</span>: <span class="number">0.01</span>, <span class="number">0.99</span>: <span class="number">0.001</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;service&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ObserveBatch</span><span class="params">(durations <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> service, duration := <span class="keyword">range</span> durations &#123;</span><br><span class="line">        rpcDurations.WithLabelValues(service).Observe(duration)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询优化">3. 查询优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 优化前：高基数查询</span><br><span class="line">sum(rate(http_requests_total&#123;path=~&quot;/api/.*&quot;&#125;[5m])) by (path, method, status)</span><br><span class="line"></span><br><span class="line"># 优化后：降低基数，按需聚合</span><br><span class="line">sum(rate(http_requests_total&#123;path=~&quot;/api/.*&quot;&#125;[5m])) by (method, status)</span><br><span class="line"></span><br><span class="line"># 优化聚合顺序（先聚合再求和）</span><br><span class="line">sum(</span><br><span class="line">  avg by(instance) (rate(node_cpu_seconds_total&#123;mode!=&quot;idle&quot;&#125;[5m]))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="五常见陷阱与解决方案">五、常见陷阱与解决方案</h2><h3 id="高基数问题">1. 高基数问题</h3><p><strong>问题</strong>：标签组合过多导致时间序列爆炸<strong>解决方案</strong>：</p><ul><li>限制标签基数，避免使用 UserID、SessionID 等作为标签</li><li>使用<code>label_replace</code>和正则表达式转换高基数标签</li><li>考虑使用 Exemplars 而非标签存储高基数数据</li></ul><h3 id="数据类型选择误区">2. 数据类型选择误区</h3><p><strong>Counter vs Gauge</strong>：请求数应使用 Counter 而非 Gauge<strong>Histogram vs Summary</strong>：需要聚合分析请使用Histogram，精确分位数可选 Summary</p><h3 id="查询性能问题">3. 查询性能问题</h3><p><strong>问题</strong>：复杂查询导致 Prometheus 高负载<strong>解决方案</strong>：</p><ul><li>使用记录规则预计算常用查询</li><li>合理设置 scrape 间隔，避免过度采集</li><li>对高请求量接口使用客户端聚合</li></ul><h2 id="总结与展望">总结与展望</h2><p>Prometheus 的四种数据类型各有所长：Counter 适合累积事件计数，Gauge适合瞬时状态测量，Histogram 适合分布统计和百分位分析，Summary适合客户端精确分位数计算。与之配合的 PromQL提供了强大的数据查询和分析能力，共同构成了完整的监控解决方案。</p><p>随着云原生技术的发展，Prometheus 生态也在不断壮大，与Grafana、Alertmanager、Thanos等工具集成，能够构建更完善的监控告警平台。在微服务架构中，结合RED（Rate、Error、Duration）和USE（Utilization、Saturation、Errors）方法论，可以构建全面的可观测性系统。</p><p>无论你是刚开始使用 Prometheus的新手，还是寻求优化监控系统的资深工程师，希望本文对你理解和应用Prometheus有所帮助。记住，好的监控不仅能及时发现问题，更能预测和防范问题，最终服务于业务可靠性和用户体验的提升。</p><hr /><p><em>参考资源:</em></p><ul><li>Prometheus 官方文档: https://prometheus.io/docs/</li><li>Google SRE 书籍:https://sre.google/sre-book/monitoring-distributed-systems/</li><li>Prometheus 实战: https://prometheusbook.com/</li></ul>]]></content>
    
    
    <summary type="html">本文介绍了 Prometheus 的四大数据类型及其 PromQL 查询语言，帮助开发团队构建强大的可观测性系统。</summary>
    
    
    
    <category term="服务监控" scheme="https://hedon.top/categories/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
    
    <category term="服务监控" scheme="https://hedon.top/tags/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
    <category term="prometheus" scheme="https://hedon.top/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>在 Go 项目中实现 JWT 用户认证与续期机制</title>
    <link href="https://hedon.top/2025/02/15/go-action-jwt/"/>
    <id>https://hedon.top/2025/02/15/go-action-jwt/</id>
    <published>2025-02-15T15:28:10.000Z</published>
    <updated>2025-04-05T14:31:32.872Z</updated>
    
    <content type="html"><![CDATA[<p>JWT (JSON Web Token)是一种广泛使用的用户认证方案，因其无状态、跨域支持和灵活性而受到欢迎。本文将结合实际代码，详细讲解如何在Go 项目中实现 JWT 认证机制，并探讨两种常见的 Token 续期策略：自动续期和Refresh Token。</p><h2 id="jwt-基础概念">1. JWT 基础概念</h2><p>JWT 由三部分组成：Header、Payload 和 Signature。使用 JWT进行登录认证的基本工作流程是：</p><ol type="1"><li>用户登录成功后，服务器生成 JWT。</li><li>服务器将 token 返回给客户端。</li><li>客户端后续请求携带 token。</li><li>服务器验证 token 的有效性。</li></ol><p>我们可以在 https://jwt.io/ 网站对 JWT进行分析，查看其具体的组成成分。</p><h2 id="基本准备">2. 基本准备</h2><p>在本篇，我们将使用 Go 语言，通过一个完整的案例实现在 HTTP接口中，使用 JWT 进行用户登录和认证流程。本文假设读者已掌握基本的 Go语言语法和网络编程经验，并对 <ahref="https://github.com/gin-gonic/gin">Gin</a> 框架有基本的了解。</p><p>为了快速响应失败，本文案例中使用了封装好的异常处理机制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrUser = errors.New(<span class="string">&quot;&quot;</span>)</span><br><span class="line">ErrSys  = errors.New(<span class="string">&quot;&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户侧错误，会直接将错误内容返回给用户，不打印日志。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserErr</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w%v&quot;</span>, ErrUser, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserErrf</span><span class="params">(format <span class="type">string</span>, a ...any)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w%v&quot;</span>, ErrUser, fmt.Sprintf(format, a...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义系统内部错误，会固定返回 internal server error 给用户，但是会将原始错误信息输出到日志中，便于内部排查。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SystemErr</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w%v&quot;</span>, ErrSys, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SystemErrf</span><span class="params">(format <span class="type">string</span>, a ...any)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w%v&quot;</span>, ErrSys, fmt.Sprintf(format, a...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GinErr</span><span class="params">(c *gin.Context, req any, err <span class="type">error</span>, msgs ...<span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrUser) &#123;</span><br><span class="line">c.JSON(http.StatusOK, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg := <span class="string">&quot;internal server error&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(msgs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">msg = msgs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">slog.Error(msg,</span><br><span class="line">slog.Any(<span class="string">&quot;req&quot;</span>, req),</span><br><span class="line">slog.String(<span class="string">&quot;err&quot;</span>, err.Error()),</span><br><span class="line">)</span><br><span class="line">c.JSON(http.StatusOK, <span class="string">&quot;internal server error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现用户认证">3. 实现用户认证</h2><p>在进行实际代码编写之前，你需要先初始化好项目并引入 <code>jwt</code>依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang-jwt/jwt/v5</span><br></pre></td></tr></table></figure><p>在代码中使用的时候，可以：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/golang-jwt/jwt/v5&quot;</span></span><br></pre></td></tr></table></figure><p>那接下来我们就正式开始我们的功能实现。</p><h3 id="定义-claims-结构">3.1 定义 Claims 结构</h3><p>首先，我们需要定义 JWT 的载荷（Payload）结构，即决定将什么信息存储在token 当中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">    jwt.RegisteredClaims</span><br><span class="line">    UserID    <span class="type">uint64</span> <span class="string">`json:&quot;user_id&quot;`</span>    <span class="comment">// 用户ID</span></span><br><span class="line">    UserAgent <span class="type">string</span> <span class="string">`json:&quot;user_agent&quot;`</span>  <span class="comment">// 用户设备信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们：</p><ul><li><p>组合了 <code>jwt.RegisteredClaims</code>，它包含了标准的 JWT字段（如过期时间），帮助我们实现了 <code>jwt.Clamis</code> 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Claims <span class="keyword">interface</span> &#123;</span><br><span class="line">GetExpirationTime() (*NumericDate, <span class="type">error</span>)</span><br><span class="line">GetIssuedAt() (*NumericDate, <span class="type">error</span>)</span><br><span class="line">GetNotBefore() (*NumericDate, <span class="type">error</span>)</span><br><span class="line">GetIssuer() (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">GetSubject() (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">GetAudience() (ClaimStrings, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jwt.RegisteredClaims</code> 的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RegisteredClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">Issuer <span class="type">string</span> <span class="string">`json:&quot;iss,omitempty&quot;`</span></span><br><span class="line">Subject <span class="type">string</span> <span class="string">`json:&quot;sub,omitempty&quot;`</span></span><br><span class="line">Audience ClaimStrings <span class="string">`json:&quot;aud,omitempty&quot;`</span></span><br><span class="line">ExpiresAt *NumericDate <span class="string">`json:&quot;exp,omitempty&quot;`</span></span><br><span class="line">NotBefore *NumericDate <span class="string">`json:&quot;nbf,omitempty&quot;`</span></span><br><span class="line">IssuedAt *NumericDate <span class="string">`json:&quot;iat,omitempty&quot;`</span></span><br><span class="line">ID <span class="type">string</span> <span class="string">`json:&quot;jti,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetExpirationTime() (*NumericDate, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.ExpiresAt, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetNotBefore() (*NumericDate, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.NotBefore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetIssuedAt() (*NumericDate, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.IssuedAt, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetAudience() (ClaimStrings, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.Audience, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetIssuer() (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.Issuer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetSubject() (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.Subject, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加了自定义字段 <code>UserID</code> 和 <code>UserAgent</code>用于安全控制。你可以根据自己的业务需求，添加任意非敏感信息到这个结构中。</p></li></ul><h3 id="登录接口实现">3.2 登录接口实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   AccessTokenDuration = time.Minute * <span class="number">15</span></span><br><span class="line">   RefreshTokenDuration = time.Hour * <span class="number">24</span> * <span class="number">7</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> LoginJWT(ctx *gin.Context) &#123;</span><br><span class="line">    <span class="comment">// 1. 校验用户信息，在本案例中，使用邮箱加密码进行登录</span></span><br><span class="line">    user, err := u.svc.Login(ctx.Request.Context(), req.Email, req.Password)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, req, utils.UserErr(err), <span class="string">&quot;login failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建 JWT Claims</span></span><br><span class="line">    accessClaims := UserClaims&#123;</span><br><span class="line">        UserID:    user.ID,</span><br><span class="line">        UserAgent: ctx.Request.UserAgent(),</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(AccessTokenDuration)), <span class="comment">// 15分钟过期</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 生成 Access Token</span></span><br><span class="line">    accessToken := jwt.NewWithClaims(jwt.SigningMethodHS512, accessClaims)</span><br><span class="line">    accessTokenStr, err := accessToken.SignedString(AccessTokenKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, req, utils.SystemErr(err), <span class="string">&quot;generate access token failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 生成 Refresh Token，用于 Token 续期</span></span><br><span class="line">    refreshClaims := RefreshClaims&#123;</span><br><span class="line">        UserID:    user.ID,</span><br><span class="line">        UserAgent: ctx.Request.UserAgent(),</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(RefreshTokenDuration)), <span class="comment">// 7天过期</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS512, refreshClaims)</span><br><span class="line">    refreshTokenStr, err := refreshToken.SignedString(RefreshTokenKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, req, utils.SystemErr(err), <span class="string">&quot;generate refresh token failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 返回两个 token</span></span><br><span class="line">    ctx.Header(<span class="string">&quot;x-jwt-token&quot;</span>, accessTokenStr)</span><br><span class="line">    ctx.Header(<span class="string">&quot;x-refresh-token&quot;</span>, refreshTokenStr)</span><br><span class="line">    ctx.JSON(http.StatusOK, <span class="string">&quot;login success&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jwt-中间件实现">3.3 JWT 中间件实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LoginJWTMiddlewareBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">whiteList []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLoginJWTMiddlewareBuilder</span><span class="params">()</span></span> *LoginJWTMiddlewareBuilder &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;LoginJWTMiddlewareBuilder&#123;</span><br><span class="line">whiteList: []<span class="type">string</span>&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *LoginJWTMiddlewareBuilder)</span></span> IgnorePaths(paths ...<span class="type">string</span>) *LoginJWTMiddlewareBuilder &#123;</span><br><span class="line">b.whiteList = <span class="built_in">append</span>(b.whiteList, paths...)</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *LoginJWTMiddlewareBuilder)</span></span> Build() gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 1. 提取 token</span></span><br><span class="line">        authCode := ctx.GetHeader(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">        tokenStr := strings.TrimPrefix(authCode, <span class="string">&quot;Bearer &quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 解析和验证 token</span></span><br><span class="line">        uc := web.UserClaims&#123;&#125;</span><br><span class="line">        token, err := jwt.ParseWithClaims(tokenStr, &amp;uc, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> web.AccessTokenKey, <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 验证 token 有效性</span></span><br><span class="line">        <span class="keyword">if</span> token == <span class="literal">nil</span> || !token.Valid &#123;</span><br><span class="line">            ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 验证 UserAgent</span></span><br><span class="line">        <span class="keyword">if</span> uc.UserAgent != ctx.Request.UserAgent() &#123;</span><br><span class="line">            ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 设置用户信息到上下文</span></span><br><span class="line">        ctx.Set(<span class="string">&quot;user_id&quot;</span>, uc.UserID)</span><br><span class="line">      ctx.Set(<span class="string">&quot;claims&quot;</span>, uc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册中间件">3.4 注册中间件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initWebServer</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">server := gin.Default()</span><br><span class="line"></span><br><span class="line">server.Use(</span><br><span class="line">middleware.CORS(),</span><br><span class="line">middleware.NewLoginJWTMiddlewareBuilder().</span><br><span class="line">IgnorePaths(<span class="string">&quot;/users/signup&quot;</span>).</span><br><span class="line">IgnorePaths(<span class="string">&quot;/users/login&quot;</span>).</span><br><span class="line">Build(),</span><br><span class="line">)</span><br><span class="line">web.RegisterRoutes(server)</span><br><span class="line"><span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRoutes</span><span class="params">(server *gin.Engine)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">userHandler.RegisterRoutes(server)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> RegisterRoutes(server *gin.Engine) &#123;</span><br><span class="line">  ur := server.Group(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">  ur.POST(<span class="string">&quot;/login&quot;</span>, u.LoginJWT)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在其他接口中使用-token-的相关信息">4. 在其他接口中使用 Token的相关信息</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> Profile(ctx *gin.Context) &#123;</span><br><span class="line">  <span class="comment">// 可以获取 user_id</span></span><br><span class="line">userID := ctx.GetUint64(<span class="string">&quot;user_id&quot;</span>)</span><br><span class="line">  <span class="comment">// 也可以直接获取整个 claims。</span></span><br><span class="line">  <span class="comment">// 这里我们可以选择不进行断言，因为理论上我们的可以保证这里通过断言。</span></span><br><span class="line">  <span class="comment">// 如果这里发生 panic 了，则说明我们的内部逻辑没有形成闭环，存在问题。</span></span><br><span class="line">  <span class="comment">// panic 可以第一时间暴露问题，然后被解决掉。</span></span><br><span class="line">  <span class="comment">// 不过这个时候建议你使用 gin 的 recover 中间件进行全局保护，避免整个服务因为 panic 而宕机。</span></span><br><span class="line">  uc, _ := ctx.Get(<span class="string">&quot;claims&quot;</span>)</span><br><span class="line">userClaims := uc.(*UserClaims)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="refresh-token-机制">5. Refresh Token 机制</h2><h3 id="添加刷新-token-接口">5.1 添加刷新 Token 接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> RefreshToken(ctx *gin.Context) &#123;</span><br><span class="line">    <span class="comment">// 从请求头获取 Refresh Token</span></span><br><span class="line">    refreshTokenStr := ctx.GetHeader(<span class="string">&quot;x-refresh-token&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> refreshTokenStr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析和验证 Refresh Token</span></span><br><span class="line">    <span class="keyword">var</span> refreshClaims RefreshClaims</span><br><span class="line">    refreshToken, err := jwt.ParseWithClaims(refreshTokenStr, &amp;refreshClaims, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> RefreshTokenKey, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !refreshToken.Valid &#123;</span><br><span class="line">        ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证 User Agent</span></span><br><span class="line">    <span class="keyword">if</span> refreshClaims.UserAgent != ctx.Request.UserAgent() &#123;</span><br><span class="line">        ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成新的 Access Token</span></span><br><span class="line">    accessClaims := UserClaims&#123;</span><br><span class="line">        UserID:    refreshClaims.UserID,</span><br><span class="line">        UserAgent: ctx.Request.UserAgent(),</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(AccessTokenDuration)),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    newAccessToken := jwt.NewWithClaims(jwt.SigningMethodHS512, accessClaims)</span><br><span class="line">    newAccessTokenStr, err := newAccessToken.SignedString(AccessTokenKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, <span class="literal">nil</span>, utils.SystemErr(err), <span class="string">&quot;generate new access token failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 Refresh Token 进行续期</span></span><br><span class="line">  refreshClaims := RefreshClaims&#123;</span><br><span class="line">        UserID:    user.ID,</span><br><span class="line">        UserAgent: ctx.Request.UserAgent(),</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(RefreshTokenDuration)), <span class="comment">// 7天过期</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    newRefreshToken := jwt.NewWithClaims(jwt.SigningMethodHS512, refreshClaims)</span><br><span class="line">    newRefreshTokenStr, err := newRefreshToken.SignedString(RefreshTokenKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, req, utils.SystemErr(err), <span class="string">&quot;generate new refresh token failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新的 Access Token 和续期后的 Refresh Token</span></span><br><span class="line">    ctx.Header(<span class="string">&quot;x-jwt-token&quot;</span>, newAccessTokenStr)</span><br><span class="line">   ctx.Header(<span class="string">&quot;x-refresh-token&quot;</span>, newRefreshTokenStr)</span><br><span class="line">    ctx.JSON(http.StatusOK, <span class="string">&quot;token refreshed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册路由">5.2 注册路由</h3><p>在 <code>RegisterRoutes</code> 方法中添加新路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> RegisterRoutes(server *gin.Engine) &#123;</span><br><span class="line">  ur := server.Group(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">  ur.POST(<span class="string">&quot;/login&quot;</span>, u.LoginJWT)</span><br><span class="line">  ur.GET(<span class="string">&quot;/profile&quot;</span>, u.Profile)</span><br><span class="line">  ur.POST(<span class="string">&quot;/refresh&quot;</span>, u.RefreshToken)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端使用流程">6. 客户端使用流程</h2><ol type="1"><li>登录后获取 Access Token 和 Refresh Token</li><li>使用 Access Token 访问受保护资源</li><li>当 Access Token 过期时调用 /refresh 接口获取新的 Access Token</li><li>使用新的 Access Token 继续访问</li></ol><p>刷新 token 的客户端示例代码（笔者并不擅长写前端代码 hhh，所以这是让ChatGPT 帮忙写的 😄）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">async function refreshAccessToken() &#123;</span><br><span class="line">    <span class="keyword">const</span> response = await fetch(<span class="string">&#x27;/users/refresh&#x27;</span>, &#123;</span><br><span class="line">        method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">&#x27;x-refresh-token&#x27;</span>: localStorage.getItem(<span class="string">&#x27;refreshToken&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">        <span class="keyword">const</span> newAccessToken = response.headers.get(<span class="string">&#x27;x-jwt-token&#x27;</span>);</span><br><span class="line">        localStorage.setItem(<span class="string">&#x27;accessToken&#x27;</span>, newAccessToken);</span><br><span class="line">        <span class="keyword">const</span> newRefreshToken = response.headers.get(<span class="string">&#x27;x-refresh-token&#x27;</span>);</span><br><span class="line">        localStorage.setItem(<span class="string">&#x27;refreshToken&#x27;</span>, newRefreshToken);</span><br><span class="line">        <span class="keyword">return</span> newAccessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果刷新失败，重定向到登录页</span></span><br><span class="line">    window.location.href = <span class="string">&#x27;/login&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="token-续期策略对比">7. Token 续期策略对比</h2><p>在前面案例中，细心的读者可以观察到我们对 <code>AccessToken</code> 和<code>RefreshToken</code> 分别采用了 2 种不同的续期策略。</p><h3 id="自动续期">自动续期</h3><p><strong>优点：</strong></p><ul><li>简单易用：在每次请求时自动检查并续期 Token，用户体验流畅。</li><li>无额外存储需求：不需要存储 RefreshToken，减少了存储和管理的复杂性</li></ul><p><strong>缺点：</strong></p><ul><li>安全性较低：如果 Token被盗用，攻击者可以通过自动续期保持长时间的访问。</li><li>Token 过期时间不固定：Token 的有效期会不断延长，难以控制。</li></ul><h3 id="refresh-token">Refresh Token</h3><p><strong>优点：</strong></p><ul><li>更高的安全性：即使 Access Token被盗用，攻击者也无法续期，除非同时获取 Refresh Token。</li><li>可控的 Token 生命周期：Access Token 有固定的短期有效期，RefreshToken 有较长的有效期。</li><li>支持 Token 撤销：可以实现 Refresh Token的黑名单机制，支持手动撤销。</li></ul><p><strong>缺点：</strong></p><ul><li>实现复杂度较高：需要额外的接口和逻辑来处理 Refresh Token。</li><li>存储需求：需要安全存储 Refresh Token，可能需要数据库支持。</li></ul><h2 id="总结">8. 总结</h2><p>JWT 实现用户认证的优势在于无状态、跨域支持和灵活性。通过合理使用 JWT和选择合适的 Token续期策略，我们可以构建安全、可靠的用户认证系统。希望本文能帮助您在 Go项目中更好地实现 JWT 认证。</p>]]></content>
    
    
    <summary type="html">本文将结合实际代码，详细讲解如何在 Go 项目中实现 JWT 认证机制，并探讨两种常见的 Token 续期策略：自动续期和 Refresh Token。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="Go 实战" scheme="https://hedon.top/categories/Go/Go-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="JWT" scheme="https://hedon.top/tags/JWT/"/>
    
    <category term="Go 实战" scheme="https://hedon.top/tags/Go-%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>深入 Go 语言核心：map 和 slice 的传参有什么不同</title>
    <link href="https://hedon.top/2025/02/14/go-slice-vs-map/"/>
    <id>https://hedon.top/2025/02/14/go-slice-vs-map/</id>
    <published>2025-02-14T07:34:05.000Z</published>
    <updated>2025-04-05T14:31:32.874Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 开发中，经常会遇到需要在函数中修改 map 或 slice的场景。虽然它们都支持动态扩容，但在函数传参时的行为却大不相同。今天，让我们通过实例深入理解这个问题。</p><h2 id="一个困惑的开始">一个困惑的开始</h2><p>看这样一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Map 示例</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;old&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    modifyMap(m)</span><br><span class="line">    fmt.Println(m) <span class="comment">// 输出: map[new:1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slice 示例</span></span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    modifySlice(s)</span><br><span class="line">    fmt.Println(s) <span class="comment">// 输出: [100 2 3]，而不是 [100 2 3 200]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyMap</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;new&quot;</span>] = <span class="number">1</span>        <span class="comment">// 会影响原始 map</span></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">&quot;old&quot;</span>)    <span class="comment">// 也会影响原始 map</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">100</span>          <span class="comment">// 会影响原始 slice</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">200</span>)  <span class="comment">// 不会影响原始 slice</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有趣的是：</p><ol type="1"><li>map 的所有操作都会影响原始数据</li><li>slice 的简单索引修改会影响原始数据，但 append 可能不会</li></ol><p>为什么会这样？让我们从内部结构开始分析。</p><h2 id="内部结构解析">内部结构解析</h2><h3 id="map-的内部结构">Map 的内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count      <span class="type">int</span>            <span class="comment">// 元素个数</span></span><br><span class="line">    flags      <span class="type">uint8</span>          <span class="comment">// 状态标志</span></span><br><span class="line">    B          <span class="type">uint8</span>          <span class="comment">// 桶的对数 B</span></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 指向桶数组的指针</span></span><br><span class="line">    <span class="comment">// ... 其他字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们声明一个 map 变量时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 实际上 m 是 *hmap，即指向 hmap 结构的指针</span></span><br></pre></td></tr></table></figure><h3 id="slice-的内部结构">Slice 的内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer  <span class="comment">// 指向底层数组的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span>            <span class="comment">// 当前长度</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span>            <span class="comment">// 当前容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们声明一个 slice 变量时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// s 是一个完整的 slice 结构体，而不是指针</span></span><br></pre></td></tr></table></figure><h2 id="深入理解传参行为">深入理解传参行为</h2><h3 id="场景一简单修改不涉及扩容">场景一：简单修改（不涉及扩容）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyBoth</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span>   <span class="comment">// 通过指针修改原始 map</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">100</span>     <span class="comment">// 通过指向相同底层数组的指针修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map:</span><br><span class="line">main()中的 m  -----&gt; hmap&#123;...&#125;  &lt;----- modifyBoth()中的 m</span><br><span class="line">(同一个底层结构)</span><br><span class="line"></span><br><span class="line">Slice:</span><br><span class="line">main()中的 s      = slice&#123;array: 指向数组1, len: 3, cap: 3&#125;</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                        [1 2 3]</span><br><span class="line">                           ^</span><br><span class="line">modifyBoth()中的 s = slice&#123;array: 指向数组1, len: 3, cap: 3&#125;</span><br></pre></td></tr></table></figure><h3 id="场景二涉及扩容的操作">场景二：涉及扩容的操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expandBoth</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// map 扩容</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        m[fmt.Sprintf(<span class="string">&quot;key%d&quot;</span>, i)] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slice 扩容</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Map 扩容过程：</span><br><span class="line">Before:</span><br><span class="line">main()中的 m  -----&gt; hmap&#123;buckets: 指向存储A&#125;</span><br><span class="line">                           ^</span><br><span class="line">expandBoth()中的 m ---------|</span><br><span class="line"></span><br><span class="line">After:</span><br><span class="line">main()中的 m  -----&gt; hmap&#123;buckets: 指向更大的存储B&#125;  // 同一个 hmap，只是更新了内部指针</span><br><span class="line">                           ^</span><br><span class="line">expandBoth()中的 m ---------|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Slice 扩容过程：</span><br><span class="line">Before:</span><br><span class="line">main()中的 s      = slice&#123;array: 指向数组A, len: 3, cap: 3&#125;</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                        [1 2 3]</span><br><span class="line">                           ^</span><br><span class="line">expandBoth()中的 s = slice&#123;array: 指向数组A, len: 3, cap: 3&#125;</span><br><span class="line"></span><br><span class="line">After append:</span><br><span class="line">main()中的 s      = slice&#123;array: 指向数组A, len: 3, cap: 3&#125;     // 保持不变</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                        [1 2 3]</span><br><span class="line"></span><br><span class="line">expandBoth()中的 s = slice&#123;array: 指向数组B, len: 4, cap: 6&#125;    // 新的结构体，指向新数组</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                     [1 2 3 200]</span><br></pre></td></tr></table></figure><h2 id="关键区别解析">关键区别解析</h2><ol type="1"><li><p><strong>传递方式不同</strong>：</p><ul><li>map 传递的是指针，函数内外使用的是同一个 hmap 结构</li><li>slice 传递的是结构体副本，函数内的修改发生在副本上</li></ul></li><li><p><strong>扩容行为不同</strong>：</p><ul><li>map 扩容时，原有的 hmap 结构保持不变，只更新内部的 buckets 指针</li><li>slice 扩容时，会创建新的底层数组，并返回一个指向新数组的新 slice结构体</li></ul></li><li><p><strong>修改效果不同</strong>：</p><ul><li>map 的所有操作（包括扩容）都会反映到原始数据</li><li>slice 的行为分两种情况：<ul><li>不涉及扩容的修改会影响原始数据（因为指向同一个底层数组）</li><li>涉及扩容的操作（如append）会创建新的底层数组，修改不会影响原始数据</li></ul></li></ul></li></ol><h2 id="最佳实践">最佳实践</h2><p>基于以上原理，在编码时应注意：</p><ol type="1"><li>对于 map：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyMap</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span>    <span class="comment">// 直接修改即可，不需要返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>对于 slice：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 如果需要 append 或其他可能导致扩容的操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line">s = modifySlice(s)</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>理解 map 和 slice 的这些差异，关键在于：</p><ol type="1"><li>map 是指针类型，始终指向同一个 hmap 结构</li><li>slice 是结构体，包含了指向底层数组的指针</li><li>扩容时 map 只更新内部指针，而 slice 需要创建新的底层数组</li></ol><p>这种设计各有优势：</p><ul><li>map 的行为更加统一和直观</li><li>slice 的设计提供了更多的灵活性和控制权</li></ul><p>在实际编程中，正确理解和处理这些差异，是写出健壮 Go 代码的关键。</p>]]></content>
    
    
    <summary type="html">本文通过一个令人困惑的例子开始，探讨 Go 语言中 map 和 slice 动态扩容机制与传参时需要注意的问题。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨解密 QUIC/HTTP3：未来互联网的基石</title>
    <link href="https://hedon.top/2025/01/15/book-quic-http3/"/>
    <id>https://hedon.top/2025/01/15/book-quic-http3/</id>
    <published>2025-01-15T11:17:20.000Z</published>
    <updated>2025-04-05T14:31:32.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="quic-产生背景">1. QUIC 产生背景</h1><h2 id="常见网络协议">常见网络协议</h2><ul><li><code>UDP</code></li><li><code>TCP</code></li><li><code>SCTP</code>（Stream Control TransmissionProtocol）：用于电话网络。</li><li><code>KCP</code>：基于 UDP在应用层实现可靠性传输，牺牲带宽换取效率。</li><li><code>RTP</code>（Real-time Transport Protocol）：与 RTCP配合传输实时数据，如交互式音频和视频数据。<ul><li>RTCP：传输控制信息</li><li>RTP：传输实时数据</li></ul></li></ul><h2 id="tsl-版本演化">TSL 版本演化</h2><ul><li><p><code>SSLv2</code>：安全性低</p></li><li><p><code>SSLv3</code>：分为握手阶段和数据传输阶段。</p><ul><li>握手阶段完成对端点的认证和确定保护数据传输的密钥。</li><li>一旦确定了密钥，后面的数据传输和SSL协议过程都受到加密和完整性保护。</li></ul></li><li><p><code>TSL1.0</code>：基于 SSLv3，存在 CBC（Cipher BlockChaining，密文分组链接）加密和解密模式漏洞，使得主动攻击者可以观察到当前记录的IV（IntiallizationVector，初始化向量），猜测一个数据库，进行数据注入。</p></li><li><p><code>TSL1.1</code>：修复了 TSL1.0 的一些关键安全问题：</p><ul><li>BC 加密使用每条记录一个的显式IV；</li><li>为了防止 CBC 填充攻击，使用 bad_record_mac 错误码代替decryption_failed 回复填充错误；</li><li>支持传输参数的IANA（Internet Assigned NumbersAuthority，互联网数字分配机构）注册，增加了传输参数的灵活性；</li><li>改进了连接关闭过早情况下的连接恢复问题。</li></ul><p>有些加密算法还是存在安全漏洞，使用的 MD5 也不安全。</p></li><li><p><code>TSL1.2</code>：主要关注了架构灵活性和安全问题。</p><ul><li>架构：<ul><li>客户端可以指定自己支持的签名和 hash 算法列表；</li><li>支持非协议固定的算法；</li></ul></li><li>安全：<ul><li>增加了对 AEAD（Authenticated Encryption with Associated Data关联数据认证加密）的支持，可以在加密中认证没有加密部分的关键数据，甚至是不在报文中的关键数据，可以保护更大的范围。</li><li>规定必须实现密码套件 TLS_RSA_WITH_AES_128_CBC_SHA。</li><li>增加了 HMAC-SHA256 密码套件。</li><li>删除了包含已废弃算法的 IDEA 和 DES 密码套件。</li><li>对 EncryptedPreMasterSecret 版本号进行了更严格的检查。</li></ul></li></ul></li><li><p><code>TSL1.3</code>：除了增加安全性，重点改进了连接速度，首次连接发送数据最低可以1-RTT，恢复连接发送数据最低可以 0-RTT。</p><ul><li>安全：<ul><li>删除了所有被证明有问题的对称加密算法，只保留了 AEAD的加密套件。密码套件的概念也已经改变，将认证和密钥交换机制与加密算法和散列（用于密钥导出函数和握手消息认证码）分离。</li><li>删除 RSA 和静态 DH 密码套件，因为静态 RSA加密预主密钥的方式和使用静态 DH私钥都不能保证前向安全性，很容易泄露密钥。只保留能保证前向安全的密钥交换算法，如使用临时私钥的ECDHE（Elliptic Curve Diffie-Hellman Ephemeral，椭圆曲线 DH临时密钥交换算法）和 DHE（Diffie-Hellman Ephemeral, DH临时密钥交换算法）。</li><li>ServerHello 之后的消息都加密传输。</li><li>删除了压缩功能。之前版本的压缩功能由于存在被攻击的风险实际上很少使用，而且现代的压缩基本都在应用层实现，比如HTTP就自己实现的压缩。</li></ul></li></ul></li></ul><h2 id="http-版本演化">HTTP 版本演化</h2><ul><li><p><code>HTTP0.9</code>：仅支持简单的请求响应，只能访问<strong>简单的文本</strong>文档。</p></li><li><p><code>HTTP1.0</code>：HTTP1中引入了<strong>请求头和响应头</strong>，请求时可以指定 HTTP版本号、用户代理、接收类型等，响应可以指明响应状态、内容长度、内容类型等。</p></li><li><p><code>HTTP1.1</code>：增加了<strong>重用 TCP连接</strong>（keep-alive）的方法，默认保持连接，除非显式通知关闭连接[插图]。这样可以在一个TCP 连接上完成多个请求-响应，消除了 TCP 建立的延迟，也避免了新建立的 TCP连接的慢启动过程。</p><ul><li>HTTP1.1 在 HTTP 请求首部中增加了 Host 字段，用来支持共享 IP地址的虚拟主机服务器。</li><li>同时支持了更多的方法，如 PUT、PATCH、DELETE、OPTIONS。</li><li>引入分块传输支持动态内容。</li><li>引入了更多的缓存控制策略。</li><li>支持请求部分内容。</li></ul></li><li><p><code>HTTP2</code>：修改了 HTTP1.1的封装格式，增加了一个二进制分帧层。基于二进制分层，HTTP2 实现了 HTTP的<strong>多路复用</strong>。HTTP2为每个请求分配了一个流标识，服务器响应时带上相同的流标识，客户端就可以方便地将响应与请求关联起来，而不用依赖顺序，从而可以降低延迟和提高吞吐量。</p><ul><li>HTTP2 还增加了首部压缩 HPACK（Header Compression for HTTP2，HTTP2首部压缩算法）。</li><li>支持请求优先级。</li><li>支持服务器主动推送。</li><li>增加了 ALPN（Application-Layer ProtocolNegotiation，应用层协议协商）。</li><li>支持认证、加密和完整性保护，即 <code>HTTPS</code>。</li></ul><p>但多个请求或响应在同一个 TCP 上发送时，仍然受制于 TCP的队首阻塞问题。</p></li><li><p><code>HTTP3</code>：基于 <code>QUIC</code> 协议，底层使用 UDP实现，摆脱了 TCP 的队首阻塞问题。同时改进了 TCP中存在的一些其他问题，比如拥塞控制、协议僵化、启动慢、重连慢、安全弱等。</p><ul><li>实现了没有队首阻塞的并发。如果 QUIC丢了一个报文，仅仅影响对应流的交付，不会阻塞其他流。</li><li>与 TLS1.3 紧密合作，尽可能的加密。还增加了 QUIC报文的首部加密，除保证了报文安全性，提高了攻击门槛，还避免了协议僵化。</li><li>选择 UDP 作为底层实现。一方面避免了 TCP的首部阻塞，另一方面互联网中绝大部分的主机和中间件都是 TCP 和 UDP的天下，所以天然支持。</li><li>用户态实现。不依赖于内核，容易单独升级。</li><li>低延迟的建立。实现了首次最低 1-RTT发送应用数据，恢复连接时发送应用数据最低只需 0-RTT。</li><li>无缝的连接迁移。QUIC 的连接基于连接标识，改变 IP 或者 UDP端口号并不影响连接的识别，因此可以实现无缝的连接迁移。但是负载均衡就麻烦了。</li><li>改进的流量控制。</li><li>协议行为作为负载。</li></ul></li></ul><h1 id="quic-报文">2. QUIC 报文</h1><ul><li>长首部报文：用于建立 QUIC 连接和建立连接前发送应用数据。</li><li>短首部报文：用于在 QUIC 连接建立后发送应用数据和 QUIC协议内容。</li><li>无状态重置报文：当服务器丢失了连接状态但仍然收到该连接的数据包时，可以发送无状态重置报文通知客户端立即终止连接。</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250122195252117.png"alt="QUIC 报文类型" /><figcaption aria-hidden="true">QUIC 报文类型</figcaption></figure><p>初始报文：客户端使用初始报文来发起连接，服务器使用初始报文和握手报文回应客户端的请求。</p><p>0-RTT 报文：用于承载 QUIC连接之前想要发送的数据，一般用于恢复连接后立即发送数据。</p><p>握手报文：用来携带服务器和客户端的 TLS 加密握手信息和确认，载荷一般是CRYPTO 帧和 ACK 帧。</p><p>重试报文：是服务器用来验证客户端地址的报文，可以防止源地址欺骗。</p><blockquote><p>服务器使用重试报文通知客户端按照要求重新发送初始报文，在重试报文中携带重试令牌给客户端，并使用服务器选择的连接标识作为重试报文的源连接标识；客户端需要使用服务器指定的连接标识作为目的连接标识，携带服务器指定的重试令牌，构建新的初始报文，重新发送给服务器。</p></blockquote><p>版本协商报文：当服务器收到包含自己不支持的版本号的初始报文时，就会发送版本协商报文。客户端收到版本协商报文后需要在其中选择一个自己支持的版本号，重新以新版本号发送初始报文。</p><p>短首部报文：一般也叫作 1-RTT 报文，连接在协商出 1-RTT密钥后就可以发送短首部报文，用于携带应用数据。</p>]]></content>
    
    
    <summary type="html">整理阅读《解密 QUIC/HTTP3：未来互联网的基石》笔记。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="QUIC" scheme="https://hedon.top/tags/QUIC/"/>
    
    <category term="HTTP3" scheme="https://hedon.top/tags/HTTP3/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>匠心码道丨01 编写优质代码的十大黄金法则</title>
    <link href="https://hedon.top/2024/12/12/clean-code-10-rules/"/>
    <id>https://hedon.top/2024/12/12/clean-code-10-rules/</id>
    <published>2024-12-12T02:22:49.000Z</published>
    <updated>2025-04-05T14:31:32.871Z</updated>
    
    <content type="html"><![CDATA[<p>代码质量的优劣直接影响着项目的可维护性和团队的开发效率。一个经验丰富的开发者不仅要能实现功能，更要善于编写清晰易懂、结构合理的代码。本文将介绍10 条帮助你编写清晰、易维护且可扩展代码的重要规则。</p><h1 id="规则">规则</h1><h2 id="使用有意义的变量和函数名称">1. 使用有意义的变量和函数名称</h2><p>变量、函数和类的命名应该具有描述性和意义。你的代码应该能够清晰地表达其意图，而无需额外的注释来解释。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> api.<span class="title function_">get</span>();</span><br><span class="line"><span class="keyword">const</span> arr = users.<span class="title function_">filter</span>(<span class="function"><span class="params">u</span> =&gt;</span> u.<span class="property">a</span> === <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxRetries = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> currentDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> userResponse = <span class="keyword">await</span> api.<span class="title function_">getUserProfile</span>();</span><br><span class="line"><span class="keyword">const</span> activeUsers = users.<span class="title function_">filter</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">isActive</span> === <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p>有意义的命名能讲述代码的故事。读者应该能够仅通过名称就理解变量或函数的用途。</p><p>💡实践建议：</p><ul><li>使用动词前缀命名函数：<code>getUserProfile()</code>、<code>validateInput()</code>、<code>calculateTotal()</code></li><li>使用名词命名变量：<code>userCount</code>、<code>activeUsers</code>、<code>orderStatus</code></li><li>布尔值使用 is/has/should等前缀：<code>isValid</code>、<code>hasPermission</code>、<code>shouldUpdate</code></li></ul><h2 id="保持函数简短且专注">2. 保持函数简短且专注</h2><p>函数应该保持简短，并且只做一件事。函数承担的责任越多，测试、调试和理解起来就越困难。</p><p><strong>反面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_order</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="comment"># 多个责任：验证、定价、折扣、配送等</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">validate_order</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_total</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_discount</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>每个函数应该只有一个责任。如果你需要用"和"来描述函数的功能，那么这个函数可能做得太多了。</p><p>💡 最佳实践：</p><ul><li>函数建议保持在 20-30 行以内</li><li>如果超过 50 行，应该考虑拆分</li><li>一个函数最好不要超过 3 个参数</li></ul><h2 id="避免深层嵌套">3. 避免深层嵌套</h2><p>深层嵌套的循环和条件语句会使代码难以理解。通过使用提前返回、函数拆分或将大问题分解为小问题来使代码扁平化。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (user.<span class="title function_">isActive</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (order != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="title function_">processOrder</span>(order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span> || !user.<span class="title function_">isActive</span>()) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (order == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="title function_">processOrder</span>(order);</span><br></pre></td></tr></table></figure></p><p>提前返回可以减少读者的认知负担，使代码更简单、更容易理解。</p><h2 id="明智地使用注释">4. 明智地使用注释</h2><p>注释不应该解释代码做了什么；代码本身应该是自解释的。只在必要时使用注释来解释复杂逻辑背后的"原因"，而不是"是什么"。</p><p><strong>反面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置用户状态为激活</span></span><br><span class="line"><span class="variable">$user</span>-&gt;isActive = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录成功后将用户标记为激活状态</span></span><br><span class="line"><span class="variable">$user</span>-&gt;isActive = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>注释应该增加价值，解释特定实现背后的原因或解释复杂的业务逻辑。</p><h2 id="保持一致的格式">5. 保持一致的格式</h2><p>一致的代码格式使代码更容易阅读和导航。在项目中使用统一的缩进、间距和对齐方式。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a+b;&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>许多团队使用 Prettier 或 ESLint等工具来自动格式化并强制执行代码风格规则。</p><h2 id="不要重复自己dry-原则">6. 不要重复自己（DRY 原则）</h2><p>代码重复会导致不一致、bug 和不必要的复杂性。应用 DRY原则可以保持代码库精简，更易于维护。</p><p><strong>反面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$userType</span> == <span class="string">&quot;admin&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 复杂逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$userType</span> == <span class="string">&quot;superadmin&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 相同的复杂逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">userIsAdmin</span>(<span class="variable">$userType</span>)) &#123;</span><br><span class="line">    <span class="comment">// 复杂逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过将共同逻辑抽象到函数、类或工具中来避免代码重复。</p><h2 id="单一责任原则srp">7. 单一责任原则（SRP）</h2><p>每个类和函数应该只有一个改变的理由。遵循单一责任原则使代码模块化，更容易重构。</p><p><strong>反面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>承担太多责任的类更难维护。SRP 使代码更模块化，更容易测试。</p><h2 id="避免魔法数字和字符串">8. 避免魔法数字和字符串</h2><p>魔法数字（或字符串）是没有上下文或解释的硬编码值。使用常量或枚举代替，这样可以增加代码的清晰度。</p><p><strong>反面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">discount = <span class="number">0.05</span></span><br><span class="line"><span class="keyword">if</span> user.role == <span class="string">&quot;admin&quot;</span>:</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DISCOUNT_RATE = <span class="number">0.05</span></span><br><span class="line">ADMIN_ROLE = <span class="string">&quot;admin&quot;</span></span><br><span class="line">discount = DISCOUNT_RATE</span><br><span class="line"><span class="keyword">if</span> user.role == ADMIN_ROLE:</span><br></pre></td></tr></table></figure></p><p>常量为数字或字符串提供了含义，使代码更容易理解。</p><h2 id="编写测试">9. 编写测试</h2><p>单元测试和集成测试确保你的代码按预期工作，并且在进行更改时不会出错。编写测试使代码更可靠，长期更易于维护。</p><p><strong>反面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法没有测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// 逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProcessOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    <span class="comment">// 断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试应该成为你工作流程的一部分，确保代码无 BUG 且稳定。</p><h2 id="保持简单kiss-原则">10. 保持简单（KISS 原则）</h2><p>KISS（Keep It Simple,Stupid）原则提醒我们简单是关键。复杂的解决方案会导致混淆，更难维护。在面对决策时，选择最简单、最直接的方案来满足需求。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过度复杂的购物车商品总价计算</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateTotal</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> discount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复杂的折扣计算逻辑</span></span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;electronics&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.<span class="property">price</span> &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                discount += item.<span class="property">price</span> * <span class="number">0.1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">price</span> &gt; <span class="number">500</span>) &#123;</span><br><span class="line">                discount += item.<span class="property">price</span> * <span class="number">0.05</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;books&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.<span class="property">quantity</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                discount += item.<span class="property">price</span> * item.<span class="property">quantity</span> * <span class="number">0.15</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        total += item.<span class="property">price</span> * item.<span class="property">quantity</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total - discount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将复杂逻辑拆分成小函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateDiscount</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;electronics&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item.<span class="property">price</span> &gt; <span class="number">1000</span> ? <span class="number">0.1</span> : (item.<span class="property">price</span> &gt; <span class="number">500</span> ? <span class="number">0.05</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;books&#x27;</span> &amp;&amp; item.<span class="property">quantity</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateTotal</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> discount = <span class="title function_">calculateDiscount</span>(item);</span><br><span class="line">        <span class="keyword">const</span> itemTotal = item.<span class="property">price</span> * item.<span class="property">quantity</span>;</span><br><span class="line">        <span class="keyword">return</span> total + itemTotal * (<span class="number">1</span> - discount);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>💡 最佳实践：</p><ul><li>将复杂逻辑拆分成小的、容易理解的函数</li><li>避免在一个函数中处理过多的条件判断</li><li>使用清晰的命名来表达意图</li><li>保持函数的单一职责</li></ul><h1 id="总结">总结</h1><p>干净的代码对于可维护性、可读性和协作至关重要。遵循这 10条规则——使用有意义的命名、保持函数简短、避免魔法数字、编写测试等，将会带来更健壮、更易理解和更易扩展的代码库。编写代码不仅仅是要让它能工作，更要让其他人（包括未来的你）能够轻松理解和扩展。</p><h1 id="代码审查清单">代码审查清单</h1><p>在提交代码前，可以使用以下清单进行自查：</p><ul class="task-list"><li><label><inputtype="checkbox" />变量和函数名称是否具有描述性</label></li><li><label><input type="checkbox" />函数是否只做一件事</label></li><li><label><input type="checkbox" />是否存在重复代码</label></li><li><label><input type="checkbox" />是否有未使用的魔法数字</label></li><li><label><input type="checkbox" />是否编写了相应的测试</label></li><li><label><input type="checkbox" />代码格式是否统一</label></li><li><label><input type="checkbox" />注释是否有价值</label></li><li><label><input type="checkbox" />嵌套是否过深</label></li></ul><h1 id="参考">参考</h1><ul><li><ahref="https://www.thecodingdev.com/2024/09/top-10-clean-code-rules-every-developer.html?ref=dailydev">top-10-clean-code-rules-every-developer-should-follow</a></li></ul>]]></content>
    
    
    <summary type="html">详解编写整洁代码的十大原则，帮你写出更好的代码。</summary>
    
    
    
    <category term="匠心码道" scheme="https://hedon.top/categories/%E5%8C%A0%E5%BF%83%E7%A0%81%E9%81%93/"/>
    
    
    <category term="编程规范" scheme="https://hedon.top/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
    <category term="代码质量" scheme="https://hedon.top/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
    <category term="最佳实践" scheme="https://hedon.top/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>KCP 源码分析与原理总结</title>
    <link href="https://hedon.top/2024/12/01/kcp/"/>
    <id>https://hedon.top/2024/12/01/kcp/</id>
    <published>2024-12-01T02:08:02.000Z</published>
    <updated>2025-04-05T14:31:32.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>本文很大部分参考了 <ahref="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP协议的原理和实现</a>，非常感谢该文作者的讲解。本文再此基础上，加入了一些笔者的思考和分析图示，以期更好地理解KCP 的底层原理。</p><h1 id="结论先行">结论先行</h1><p>KCP 是一个快速可靠协议，能以比 TCP 浪费 10%-20%的带宽的代价，换取平均延迟降低30%-40%，且最大延迟降低三倍的传输效果。</p><p>TCP 是为流量设计的（每秒内可以传输多少 KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以 10%-20%带宽浪费的代价换取了比 TCP 快 30%-40% 的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而 KCP是水流湍急的小激流。</p><h2 id="kcp-增加的带宽在哪里增加的速度又在哪里">KCP增加的带宽在哪里？增加的速度又在哪里？</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612111337839.png"alt="为什么 KCP 能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%？" /><figcaption aria-hidden="true">为什么 KCP 能以比 TCP 浪费 10%-20%的带宽的代价，换取平均延迟降低 30%-40%？</figcaption></figure><h2 id="kcp-核心特性">KCP 核心特性</h2><p><strong>快速重传</strong>： KCP 支持快速重传机制，不像 TCP那样依赖超时重传。KCP可以根据接收方返回的确认信息快速判断哪些数据包已经丢失，并迅速进行重传。</p><p><strong>选择性确认（Selective Acknowledgment, SACK）</strong>： KCP支持SACK，这允许接收端告知发送端哪些包已经收到，从而仅重传未被确认接收的数据包，减少不必要的重传。</p><p><strong>无连接操作</strong>： 基于 UDP 的实现使得 KCP在传输数据前不需要像 TCP那样进行三次握手建立连接，这减少了初始的延迟，并使其能在连接性较差的网络环境下更加灵活和快速。</p><p><strong>拥塞控制</strong>： KCP 实现了类似 TCP的拥塞控制算法，但更为简化，能够快速适应网络条件的变化，如带宽波动和丢包。</p><p><strong>流量控制</strong>： KCP允许调整发送和接收的窗口大小，使得发送方可以根据接收方的处理能力和网络条件调整数据发送速率，优化网络利用率和减少拥塞。</p><p><strong>可配置的传输策略</strong>： KCP允许用户根据应用需求调整内部参数，如传输间隔、窗口大小等，以达到最优的传输效率和延迟。</p><p><strong>前向错误校正（Forward Error Correction, FEC）</strong>： KCP还可以结合使用 FEC技术，通过发送额外的冗余数据来恢复丢失的包，进一步提高在高丢包环境下的数据传输可靠性。</p><h2 id="为什么-tcp-做不到-kcp-这样">为什么 TCP 做不到 KCP 这样？</h2><p>TCP作为一种成熟且广泛使用的传输协议，在设计上注重可靠性和通用性，因此在拥塞控制和流量控制方面相对保守，以确保在各种网络条件下都能稳定运行。然而，这些设计上的保守性也导致了TCP 在某些情况下的灵活性和自适应性不如 KCP。</p><table><colgroup><col style="width: 16%" /><col style="width: 4%" /><col style="width: 79%" /></colgroup><thead><tr class="header"><th>特性类别</th><th>协议</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>拥塞控制机制</td><td>TCP</td><td>固定算法（慢启动、拥塞避免等），保守的调整策略（指数和线性增长）</td></tr><tr class="even"><td></td><td>KCP</td><td>灵活算法，动态调整策略，快速调整窗口大小</td></tr><tr class="odd"><td>重传机制的延迟</td><td>TCP</td><td>固定重传间隔（RTO），多次确认触发重传，需要主动开启选择性重传（SACK）</td></tr><tr class="even"><td></td><td>KCP</td><td>快速重传，选择性重传，减少重传延迟</td></tr><tr class="odd"><td>流量控制</td><td>TCP</td><td>固定流量控制（依赖接收窗口和发送窗口），通用性设计</td></tr><tr class="even"><td></td><td>KCP</td><td>自适应流量控制，应用层反馈调整发送窗口和重传策略</td></tr><tr class="odd"><td>应用场景</td><td>TCP</td><td>广泛应用于各种网络环境，标准化要求高</td></tr><tr class="even"><td></td><td>KCP</td><td>优化特定场景（如高丢包率和高延迟网络），灵活实现</td></tr></tbody></table><h3 id="拥塞控制机制的固定性">1. 拥塞控制机制的固定性</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定算法</strong>：TCP 的拥塞控制算法，如慢启动（SlowStart）、拥塞避免（Congestion Avoidance）、快速重传（FastRetransmit）和快速恢复（FastRecovery），在设计时考虑了广泛的兼容性和可靠性。这些算法虽然有效，但其调整机制相对固定，响应速度较慢。</li><li><strong>保守的调整策略</strong>：TCP的拥塞控制算法采用了保守的调整策略，例如指数增长和线性增长，这在高丢包率或高延迟网络中，可能会导致拥塞窗口（cwnd）增长速度较慢，影响传输效率。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>灵活算法</strong>：KCP的拥塞控制机制更为灵活，可以根据实时网络状况进行快速调整。例如，KCP的快速重传和选择性重传机制，使其能更快速地响应网络丢包情况。</li><li><strong>动态调整策略</strong>：KCP的拥塞窗口调整更为灵活，可以根据网络状况快速增加或减少窗口大小，提高传输效率。</li></ul><h3 id="重传机制的延迟">2. 重传机制的延迟</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定重传间隔</strong>：TCP使用固定的重传超时（RTO），并随着每次重传逐渐增加（指数回退），这种保守的重传机制在高延迟和高丢包率网络中可能导致重传延迟较长。</li><li><strong>多次确认触发重传</strong>：TCP 的快速重传需要等待三个重复的ACK 才能触发，这在丢包率较高的情况下，可能会导致较长的延迟。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>快速重传</strong>：KCP在检测到丢包后立即进行重传，而不需要等待多个重复的ACK，这显著减少了重传延迟。</li><li><strong>选择性重传</strong>：KCP只重传丢失的数据包，而不是所有未确认的数据包，减少了不必要的重传开销。（TCP其实也支持选择性重传 SACK）</li></ul><h3 id="流量控制的灵活性">3. 流量控制的灵活性</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定流量控制</strong>：TCP的流量控制主要依赖于接收窗口（rwnd）和发送窗口（swnd），在处理突发流量或变化较大的网络条件时，调整速度较慢。</li><li><strong>通用性设计</strong>：TCP作为一种通用协议，其设计必须兼顾各种网络环境，因此在流量控制上相对保守，以确保在任何环境下都能稳定运行。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>自适应流量控制</strong>：KCP的流量控制机制可以根据实际应用需求进行更细粒度的调整。例如，KCP可以根据延迟抖动、丢包率等动态参数调整发送速率，确保在不同网络条件下都能保持高效传输。</li><li><strong>应用层反馈</strong>：KCP可以根据应用层的实时反馈，动态调整发送窗口和重传策略，进一步优化传输效率。</li></ul><h3 id="应用场景的差异">4. 应用场景的差异</h3><p><strong>TCP</strong>：</p><ul><li><strong>广泛应用</strong>：TCP设计用于广泛的网络环境，包括稳定的有线网络和不稳定的无线网络，因此其机制必须足够通用和保守，保证在各种情况下的可靠性。</li><li><strong>标准化要求</strong>：作为互联网的基础协议，TCP的各项机制经过严格标准化，任何修改都需要广泛测试和验证，以确保不会影响现有网络的稳定性。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>特定优化</strong>：KCP设计初衷是优化特定场景下的传输性能，特别是高丢包率和高延迟网络，因此在设计上更加灵活，能够根据实时网络状况进行调整。</li><li><strong>灵活实现</strong>：KCP可以根据具体应用需求进行优化，例如在实时通信和在线游戏等场景中，灵活的流量控制和快速重传机制显著提升了传输效率。</li></ul><h3 id="结论">结论</h3><p>虽然 TCP在拥塞控制和流量控制方面具备基本的动态调整能力，但其保守的设计和标准化要求使得其在高丢包率和高延迟网络中的适应性和灵活性不如KCP。KCP通过灵活的拥塞控制、快速重传和自适应流量控制机制，能够更有效地应对不同网络条件下的传输需求，提供更高效的传输性能。</p><h2 id="kcp-一定比-tcp-快吗">KCP 一定比 TCP 快吗？</h2><p><font color="red">不一定</font>。KCP 并不一定在所有情况下都比 TCP快。虽然 KCP在某些特定网络环境（如高丢包率和高延迟的网络）中表现更优异，但在某些情况下，TCP可能更合适。</p><h3 id="网络环境">1. 网络环境</h3><p><strong>高丢包率和高延迟网络</strong>：</p><ul><li><strong>KCP</strong>：KCP通过快速重传和选择性重传机制，以及动态调整的窗口和重传间隔，能够更好地应对高丢包率和高延迟网络，减少传输延迟，提高传输效率。</li><li><strong>TCP</strong>：TCP的重传机制和保守的拥塞控制在这种环境中可能导致较高的延迟和较低的带宽利用率。</li></ul><p><strong>低丢包率和低延迟网络</strong>：</p><ul><li><strong>KCP</strong>：在稳定的低丢包率和低延迟网络中，KCP的频繁重传和控制报文可能会导致额外的带宽开销，未必有明显的性能优势。</li><li><strong>TCP</strong>：TCP在这种环境中表现稳定，且由于其带宽开销较小，可能比 KCP 更高效。</li></ul><h3 id="带宽利用率">2. 带宽利用率</h3><p><strong>带宽充足的网络</strong>：</p><ul><li><strong>KCP</strong>：KCP由于其频繁的重传和控制报文，可能会占用更多的带宽，但如果带宽充足，这种开销对整体性能影响较小，且其低延迟优势可能更明显。</li><li><strong>TCP</strong>：TCP的带宽利用率较高，适合带宽充足的环境。</li></ul><p><strong>带宽受限的网络</strong>：</p><ul><li><strong>KCP</strong>：KCP的额外带宽开销在带宽受限的网络中可能会显著影响整体传输效率。</li><li><strong>TCP</strong>：TCP的较低带宽开销使其在带宽受限的环境中更有优势。</li></ul><h3 id="应用场景">3. 应用场景</h3><p><strong>实时应用</strong>（如在线游戏、视频会议）：</p><ul><li><strong>KCP</strong>：KCP的低延迟和快速响应能力使其非常适合实时应用，在这些场景中，传输的及时性比带宽利用率更重要。</li><li><strong>TCP</strong>：TCP 在这些场景中的表现可能不如KCP，特别是在高丢包率和高延迟的网络中。</li></ul><p><strong>非实时应用</strong>（如文件传输、网页浏览）：</p><ul><li><strong>KCP</strong>：KCP 在这些场景中可能不如 TCP高效，特别是在网络稳定且带宽有限的情况下。</li><li><strong>TCP</strong>：TCP的可靠性和高带宽利用率使其非常适合非实时应用。</li></ul><h3 id="实现和配置">4. 实现和配置</h3><p><strong>实现复杂性</strong>：</p><ul><li><strong>KCP</strong>：实现和配置 KCP 可能比 TCP更复杂，需要根据具体应用和网络环境进行优化和调整。</li><li><strong>TCP</strong>：TCP是一个成熟的协议，系统和库的支持较好，配置和使用相对简单。</li></ul><h3 id="总结">总结</h3><p>KCP 在某些特定环境和应用场景中确实比 TCP更快，尤其是高丢包率和高延迟的网络环境，以及对低延迟要求较高的实时应用。但在网络稳定、带宽有限或非实时应用场景中，TCP可能表现更好。因此，选择使用 KCP 还是 TCP应根据具体的网络条件和应用需求进行权衡。</p><h1 id="前置准备">前置准备</h1><p>笔者不想那么快就贴出大段大段的代码进行分析，这可能会使读者不知所云。为了更好地阐述KCP的底层原理，笔者的设想是先对原理部分进行概要总结，然后再带着这些结论去分析源码，进一步填充里面的边角细节。</p><p>但是呢，为了更好地理解 KCP的原理，又不得不对涉及源码的一些重要设计，为了避免在原理分析阶段，对源码进行过多的涉及，笔者决定添加这单独的一章内容，对KCP 的“接口设计”、“报文段”、“KCP控制块”以及“队列和缓冲区”先进行简要概述，以辅助读者更好地理解后续的内容。</p><h2 id="接口设计">接口设计</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612171839051.png"alt="KCP 工作简约图" /><figcaption aria-hidden="true">KCP 工作简约图</figcaption></figure><p>在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h">kcp.h</a>文件中，定义了 KCP 最核心的几个接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 KCP 控制对象</span></span><br><span class="line">ikcpcb* <span class="title function_">ikcp_create</span><span class="params">(IUINT32 conv, <span class="type">void</span> *user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放一个 KCP 控制对象。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_release</span><span class="params">(ikcpcb *kcp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 KCP 的输出回调函数，这个回调函数在 KCP 需要发送数据时被调用。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_setoutput</span><span class="params">(ikcpcb *kcp, <span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">ikcpcb *kcp, <span class="type">void</span> *user))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 KCP 的接收队列中接收数据，用于上层从 KCP 中读取数据。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_recv</span><span class="params">(ikcpcb *kcp, <span class="type">char</span> *buffer, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 KCP 的发送队列中添加数据，用于上层向 KCP 发送数据，KCP 会管理这些数据并负责其可靠传输。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_send</span><span class="params">(ikcpcb *kcp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 KCP 的内部状态，通常需要定期调用。</span></span><br><span class="line"><span class="comment">// 这个函数负责处理 KCP 的超时、重传等操作，需要在一定的时间间隔内反复调用（通常每 10-100 毫秒）。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_update</span><span class="params">(ikcpcb *kcp, IUINT32 current)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否要调用 ikcp_update</span></span><br><span class="line">IUINT32 <span class="title function_">ikcp_check</span><span class="params">(<span class="type">const</span> ikcpcb *kcp, IUINT32 current)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收到的低层数据包（例如 UDP 包）。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_input</span><span class="params">(ikcpcb *kcp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">long</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将缓冲区可以发送的包发送出去，会在 ikcp_update 中被调用。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_flush</span><span class="params">(ikcpcb *kcp)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>ikcp_create</code>:</p><ul><li><code>conv</code>:会话标识符，用于标识两个端点之间的连接。这个标识符在两个通信端点之间必须一致。</li><li><code>user</code>: 用户数据指针，可以传递任意用户数据，这个数据在KCP 的 <code>output</code> 回调中会被传递回去。</li><li><strong>返回值</strong>: 一个指向新创建的 KCP控制块（<code>ikcpcb</code>）的指针。</li></ul></li><li><p><code>ikcp_release</code>: 释放一个 KCP 控制对象。</p></li><li><p><code>ikcp_setoutput</code>: 设置 KCP 的输出回调函数。</p><ul><li><p><code>output</code>: 输出回调函数指针。这个回调函数在 KCP需要发送数据时被调用。</p><ul><li><code>buf</code>: 要发送的数据缓冲区。</li><li><code>len</code>: 数据长度。</li><li><code>kcp</code>: 当前的 KCP 对象。</li><li><code>user</code>: 用户数据。</li></ul><p>通过这个回调，KCP 可以将要发送的数据传递给下层的网络层，比如 UDP套接字。</p></li></ul></li><li><p><code>ikcp_recv</code>: 从 KCP 的接收队列中接收数据。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>buffer</code>: 用户提供的缓冲区，用于存储接收到的数据。</li><li><code>len</code>: 缓冲区的长度。</li><li><strong>返回值</strong>:成功接收的数据大小；如果没有数据可接收，返回负值（例如，EAGAIN）。</li></ul><p>这个函数用于上层从 KCP 中读取数据。</p></li><li><p><code>ikcp_send</code>: 向 KCP 的发送队列中添加数据。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>buffer</code>: 要发送的数据缓冲区。</li><li><code>len</code>: 数据的长度。</li><li><strong>返回值</strong>:成功发送的数据大小；如果发送失败，返回负值。</li></ul><p>这个函数用于上层向 KCP 发送数据，KCP会管理这些数据并负责其可靠传输。</p></li><li><p><code>ikcp_update</code>: 更新 KCP的内部状态，通常需要定期调用。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>current</code>: 当前的时间戳（以毫秒为单位）。</li></ul><p>这个函数负责处理 KCP的超时、重传等操作，需要在一定的时间间隔内反复调用（通常每 10-100毫秒）。</p></li><li><p><code>ikcp_input</code>: 处理接收到的低层数据包（例如 UDP包）。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>data</code>: 收到的数据缓冲区。</li><li><code>size</code>: 数据的长度。</li><li><strong>返回值</strong>:成功处理的数据大小；如果处理失败，返回负值。</li></ul></li><li><p><code>ikcp_flush</code>: 刷新待发送的数据。</p></li></ul><p>其中最重要的是这 4 个：</p><ul><li><code>ikcp_send</code>: 将数据放在发送队列中等待发送。</li><li><code>ikcp_recv</code>: 从接收队列中读取数据。</li><li><code>ikcp_input</code>:读取下层协议输入数据，解析报文段，如果是数据，就将数据放入接收缓冲区，如果是ACK，就在发送缓冲区中标记对应的报文段已送达。</li><li><code>ikcp_flush</code>:调用输出回调将发送缓冲区的数据发送出去。</li></ul><p>这里就先简要介绍到这里，后面在源码分析篇章再对这些接口进行详细分析。</p><h2 id="报文段">报文段</h2><p>KCP 的报文段大小为 24 字节，结构如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612172557464.png" alt="KCP 报文段" style="zoom: 33%;" /></p><p>每个字段的含义如下：</p><ul><li><code>conv</code>: 连接标识</li><li><code>cmd</code>：报文类型</li><li><code>frg</code>：分片数量，表示随后还有多少个报文属于同一个包</li><li><code>wnd</code>：发送方剩余接收窗口的大小</li><li><code>ts</code>：时间戳</li><li><code>sn</code>：报文编号</li><li><code>una</code>：发送方的接收缓冲区中最小还未收到的报文段的编号，也就是说，比它小的报文段都已全部接收</li><li><code>len</code>：数据段长度</li><li><code>data</code>：数据段，只有数据报文会有这个字段</li></ul><p>其中 <code>cmd</code> 共有 4 种报文类型：</p><ul><li>数据报文：IKCP_CMD_PUSH</li><li>确认报文：IKCP_CMD_ACK</li><li>窗口探测报文：IKCP_CMD_WASK 询问对端剩余接收窗口的大小</li><li>窗口通知报文：IKCP_CMD_WINS 通知对端剩余接收窗口的大小</li></ul><p>在 KCP 中，报文段结构定义在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h">kcp.h</a>文件中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPSEG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">node</span>;</span></span><br><span class="line">IUINT32 conv;</span><br><span class="line">IUINT32 cmd;</span><br><span class="line">IUINT32 frg;</span><br><span class="line">IUINT32 wnd;</span><br><span class="line">IUINT32 ts;</span><br><span class="line">IUINT32 sn;</span><br><span class="line">IUINT32 una;</span><br><span class="line">IUINT32 len;</span><br><span class="line">IUINT32 resendts;</span><br><span class="line">IUINT32 rto;</span><br><span class="line">IUINT32 fastack;</span><br><span class="line">IUINT32 xmit;</span><br><span class="line"><span class="type">char</span> data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>IKCPSEG</code> 结构还多出了几个字段，这是为了支持 KCP协议的可靠性和效率：</p><ul><li><code>resendts</code>:记录报文的下次重传时间，用于实现重传机制。如果报文在一定时间内没有被确认收到，就会在这个时间戳之后被重新发送。</li><li><code>rto</code>: 表示当前报文的重传超时时间（RTT的估计值）。用于计算每个报文的重传时间，如果超过 <code>rto</code>时间没有收到 ACK，会触发重传。</li><li><code>fastack</code>:快速重传计数，记录该报文被跳过的次数。如果一个报文的 ACK连续接收到多个对同一报文的确认，而不是新的报文，会增加这个计数，用于实现快速重传机制。</li><li><code>xmit</code>:记录报文已经被发送的次数。用于统计一个报文的重传次数，帮助判断传输的可靠性。如果操作<code>dead_link</code> 次，则会判断为连接失效，KCP 会断开连接。</li><li><code>node</code>: 链表节点，用于将多个 <code>IKCPSEG</code>结构体链接在一起。KCP 的队列和缓冲区都是循环双链表结构。</li></ul><p>这些字段共同作用，帮助 KCP 实现以下功能：</p><ul><li><strong>可靠性</strong>：通过 <code>sn</code>、<code>una</code> 和<code>ack</code> 确保数据包按顺序接收和重传。</li><li><strong>流量控制</strong>：通过 <code>wnd</code>控制数据流量，避免接收方过载。</li><li><strong>高效传输</strong>：通过 <code>resendts</code> 和<code>rto</code> 进行超时和重传控制，<code>fastack</code>提供快速重传机制。</li><li><strong>灵活管理</strong>：使用链表节点 <code>node</code>组织数据，便于内部管理。</li></ul><h2 id="kcp-控制块-ikcpcb">KCP 控制块 ikcpcb</h2><p>上面我们提到的 <code>ikcp_create</code> 和 <code>ikcp_release</code>就是对 KCP 控制块 <code>ikcpcb</code> 的创建和释放，每个 KCP连接都对应一个 KCP 控制块。它定义在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h#L343">kcp.h</a>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPCB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">IUINT32 conv, mtu, mss, state;</span><br><span class="line">IUINT32 snd_una, snd_nxt, rcv_nxt;</span><br><span class="line">IUINT32 ts_recent, ts_lastack, ssthresh;</span><br><span class="line">IINT32 rx_rttval, rx_srtt, rx_rto, rx_minrto;</span><br><span class="line">IUINT32 snd_wnd, rcv_wnd, rmt_wnd, cwnd, probe;</span><br><span class="line">IUINT32 current, interval, ts_flush, xmit;</span><br><span class="line">IUINT32 nrcv_buf, nsnd_buf;</span><br><span class="line">IUINT32 nrcv_que, nsnd_que;</span><br><span class="line">IUINT32 nodelay, updated;</span><br><span class="line">IUINT32 ts_probe, probe_wait;</span><br><span class="line">IUINT32 dead_link, incr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_buf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_buf</span>;</span></span><br><span class="line">IUINT32 *acklist;</span><br><span class="line">IUINT32 ackcount;</span><br><span class="line">IUINT32 ackblock;</span><br><span class="line"><span class="type">void</span> *user;</span><br><span class="line"><span class="type">char</span> *buffer;</span><br><span class="line"><span class="type">int</span> fastresend;</span><br><span class="line"><span class="type">int</span> fastlimit;</span><br><span class="line"><span class="type">int</span> nocwnd, stream;</span><br><span class="line"><span class="type">int</span> logmask;</span><br><span class="line"><span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line"><span class="type">void</span> (*writelog)(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">log</span>, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字段的含义如下，读者可在后续分析过程回过来查阅：</p><table><colgroup><col style="width: 13%" /><col style="width: 86%" /></colgroup><thead><tr class="header"><th>字段名</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>conv</code></td><td>连接标识符，用于识别一个特定的会话。</td></tr><tr class="even"><td><code>mtu</code></td><td>最大传输单元（Maximum TransmissionUnit），表示网络层传输数据包的最大字节数。</td></tr><tr class="odd"><td><code>mss</code></td><td>最大报文段长度（Maximum SegmentSize），表示应用层传输数据的最大字节数。</td></tr><tr class="even"><td><code>state</code></td><td>连接状态，标识当前的传输状态。</td></tr><tr class="odd"><td><code>snd_una</code></td><td>未确认的发送序号，表示最早未确认的包的序号。</td></tr><tr class="even"><td><code>snd_nxt</code></td><td>下一个发送序号，表示即将发送的包的序号。</td></tr><tr class="odd"><td><code>rcv_nxt</code></td><td>下一个接收序号，表示期望接收的下一个包的序号。</td></tr><tr class="even"><td><code>ts_recent</code></td><td>最近的时间戳，用于延迟测量。</td></tr><tr class="odd"><td><code>ts_lastack</code></td><td>最近的确认时间戳，用于 RTT 计算。</td></tr><tr class="even"><td><code>ssthresh</code></td><td>拥塞避免的慢启动阈值。</td></tr><tr class="odd"><td><code>rx_rttval</code></td><td>RTT 的偏差，用于计算 RTT 的波动。</td></tr><tr class="even"><td><code>rx_srtt</code></td><td>平滑的 RTT 值，用于计算平均 RTT。</td></tr><tr class="odd"><td><code>rx_rto</code></td><td>重新传输超时时间，根据 RTT 动态调整。</td></tr><tr class="even"><td><code>rx_minrto</code></td><td>最小的重新传输超时时间。</td></tr><tr class="odd"><td><code>snd_wnd</code></td><td>发送窗口大小，控制发送流量的窗口。</td></tr><tr class="even"><td><code>rcv_wnd</code></td><td>接收窗口大小，控制接收流量的窗口。</td></tr><tr class="odd"><td><code>rmt_wnd</code></td><td>远端窗口大小，表示对方接收窗口的大小。</td></tr><tr class="even"><td><code>cwnd</code></td><td>拥塞窗口大小，控制发送流量的窗口，用于拥塞控制。</td></tr><tr class="odd"><td><code>probe</code></td><td>探测标志，表示是否需要进行窗口探测。</td></tr><tr class="even"><td><code>current</code></td><td>当前的时间戳。</td></tr><tr class="odd"><td><code>interval</code></td><td>刷新间隔时间，表示定期刷新 KCP 状态的间隔。</td></tr><tr class="even"><td><code>ts_flush</code></td><td>下次刷新时间戳，用于确定何时执行下一次状态刷新。</td></tr><tr class="odd"><td><code>xmit</code></td><td>发送次数，表示数据包重传的次数。</td></tr><tr class="even"><td><code>nrcv_buf</code></td><td>接收缓冲区的数据包数量。</td></tr><tr class="odd"><td><code>nsnd_buf</code></td><td>发送缓冲区的数据包数量。</td></tr><tr class="even"><td><code>nrcv_que</code></td><td>接收队列中的数据包数量。</td></tr><tr class="odd"><td><code>nsnd_que</code></td><td>发送队列中的数据包数量。</td></tr><tr class="even"><td><code>nodelay</code></td><td>延迟模式标志，表示是否启用无延迟模式。</td></tr><tr class="odd"><td><code>updated</code></td><td>更新标志，表示是否需要更新 KCP 状态。</td></tr><tr class="even"><td><code>ts_probe</code></td><td>下次探测时间戳，用于窗口探测。</td></tr><tr class="odd"><td><code>probe_wait</code></td><td>探测等待时间，表示等待多长时间后进行下一次窗口探测。</td></tr><tr class="even"><td><code>dead_link</code></td><td>死链标志，表示连接是否已经失效。</td></tr><tr class="odd"><td><code>incr</code></td><td>增量，用于控制流量的增加速率。</td></tr><tr class="even"><td><code>snd_queue</code></td><td>发送队列，用于存储待发送的数据包。</td></tr><tr class="odd"><td><code>rcv_queue</code></td><td>接收队列，用于存储待处理的数据包。</td></tr><tr class="even"><td><code>snd_buf</code></td><td>发送缓冲区，用于存储已经发送但未确认的数据包。</td></tr><tr class="odd"><td><code>rcv_buf</code></td><td>接收缓冲区，用于存储已经接收到但未处理的数据包。</td></tr><tr class="even"><td><code>acklist</code></td><td>确认列表，用于存储待发送的确认序号。</td></tr><tr class="odd"><td><code>ackcount</code></td><td>确认计数，表示确认列表中的条目数量。</td></tr><tr class="even"><td><code>ackblock</code></td><td>确认块大小，表示确认列表的内存分配大小。</td></tr><tr class="odd"><td><code>user</code></td><td>用户数据指针，用于存储用户自定义的数据。</td></tr><tr class="even"><td><code>buffer</code></td><td>缓冲区，用于临时存储发送的数据。</td></tr><tr class="odd"><td><code>fastresend</code></td><td>快速重传标志，表示启用快速重传功能。</td></tr><tr class="even"><td><code>fastlimit</code></td><td>快速重传限制，表示在一个 RTT 内允许的最大重传次数。</td></tr><tr class="odd"><td><code>nocwnd</code></td><td>无拥塞窗口控制标志，表示是否禁用拥塞窗口控制。</td></tr><tr class="even"><td><code>stream</code></td><td>流模式标志，表示是否启用流模式。</td></tr><tr class="odd"><td><code>logmask</code></td><td>日志掩码，用于控制日志输出的级别。</td></tr><tr class="even"><td><code>output</code></td><td>发送数据回调函数，用于发送数据。</td></tr><tr class="odd"><td><code>writelog</code></td><td>日志回调函数，用于输出日志。</td></tr></tbody></table><h2 id="队列和缓冲区">队列和缓冲区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPCB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_buf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_buf</span>;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>KCP中队列和缓冲区都是循环双链表，链表由宏实现，笔者并不擅长，所以本文就不探讨该链表的实现了，有数据结构基础的笔者应该很好理解这一块。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612175626865.png"alt="队列和缓冲区的实现：循环双链表" /><figcaptionaria-hidden="true">队列和缓冲区的实现：循环双链表</figcaption></figure><p>队列和缓冲区是 KCP最核心的部分，它们的作用流程大概如下图所示，读者可以自行阅读尝试理解，后续我们会进行详细的分析。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612175950432.png"alt="KCP 队列和缓冲区作用流程" /><figcaption aria-hidden="true">KCP 队列和缓冲区作用流程</figcaption></figure><h1 id="原理分析">原理分析</h1><p>这一节我们详细讨论 KCP 的整个 ARQ流程。首先我们会对整体流程进行简要概述，然后详细讨论滑动窗口中的发送和接收过程，接着讨论超时重传和快速重传，在这之后我们会将KCP 和 TCP 的重传策略进行简单对比，最后介绍一下拥塞控制策略。</p><h2 id="整体流程">1. 整体流程</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612192523848.png"alt="KCP 全流程" /><figcaption aria-hidden="true">KCP 全流程</figcaption></figure><p>KCP 的全流程如上图所示：</p><ol type="1"><li>发送方调用 <code>ikcp_send</code>将发送数据，这个时候会创建报文段实例，并放入 <code>snd_queue</code>发送队列中。</li><li>KCP 会定时调用 <code>ikcp_update</code> 判断是否要调用<code>ikcp_flush</code>。</li><li>调用 <code>ikcp_flush</code> 时会将合适的报文段放入<code>snd_buf</code> 缓冲区中，具体包括：<ol type="1"><li>发送 ACK 列表中所有 ACK；</li><li>根据是否需要发送窗口探测和通知报文，需要则发；</li><li>根据发送窗口大小，将适量的报文段从 <code>snd_queue</code> 移入<code>snd_buf</code> 中；</li><li>发送 <code>snd_buf</code>中的报文，包括<strong>新加入的</strong>、<strong>RTO 内未收到ACK</strong> 的和 <strong>ACK 失序若干次</strong>的；</li><li>根据丢包情况计算 <code>ssthresh</code> 和 <code>cwnd</code>。</li></ol></li><li>发送的时候会调用由 <code>ikcp_setoutput</code>设置的回调函数，将数据发送到对端。</li><li>接收方收到数据后，会调用 <code>ikcp_input</code>，将数据放入<code>rcv_buf</code> 缓冲区，具体包括：<ol type="1"><li>根据所有报文的 una 将相应的报文标记为已送达；</li><li>如果是 ACK，就将相应的报文标记为已送达；</li><li>如果是数据报文，就将它放入 <code>rcv_buf</code>，然后将<code>rcv_buf</code> 中顺序正确的报文移入 <code>rcv_queue</code>接收队列中，接着将相关信息插入 ACK 列表，在稍后的<code>ikcp_flush</code> 中会发送相应的 ACK；</li><li>如果是窗口探测报文，就标记“需要发送窗口通知”，在稍后的<code>ikcp_flush</code> 中会发送窗口通知报文；</li><li>包括窗口通知报文在内的所有报文都有 wnd 字段，据此更新 rmt_wnd；</li><li>根据 ACK 失序情况决定是否进行快速重传；</li><li>计算 cwnd。</li></ol></li><li>调用 <code>ikcp_recv</code> 从 <code>rcv_queue</code>中接收数据。</li></ol><h2 id="滑动窗口">2. 滑动窗口</h2><p>发送缓冲区 <code>snd_buf</code> 和接收缓冲区 <code>rcv_buf</code>中活动的报文都是在滑动窗口之中的。这对于我们理解 KCP的发送和接收流程非常重要，所有我们先从滑动窗口开始介绍。</p><p>滑动窗口实际是一个抽象的概念,不能简单地认为它是缓冲区的一部分，准确的说，滑动窗口是由队列加缓冲区共同组成的。</p><h3 id="发送">2.1 发送</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612193023604.png"alt="发送窗口" /><figcaption aria-hidden="true">发送窗口</figcaption></figure><p><code>snd_una</code> 和 <code>snd_nxt</code>会努力往<strong>右</strong>移动：</p><ol type="1"><li><code>ikcp_flush</code> 时，会从 <code>snd_queue</code>中取出报文插入到 <code>snd_nxt</code> 的位置上；</li><li>如果<code>snd_nxt - snd_una &gt;= cwnd</code>，则不允许新的报文插入；</li><li>当 <code>snd_una</code> 的 ACK 报文到达时，<code>snd_una</code>就会右移到第一个没有收到 ACK 报文的位置；</li></ol><p>发送窗口中未确认到达的报文何时重传？</p><ul><li>报文在一个 RTO 时间内仍未确认到达，就会重传。报文 RTO 初始值是rx_rto ，会持续增长，速率支持配置。</li></ul><h3 id="接收">2.2 接收</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612193238859.png"alt="接收窗口" /><figcaption aria-hidden="true">接收窗口</figcaption></figure><ol type="1"><li>每收到一个数据报文, 都会根据它的编号将它插入到 <code>rcv_buf</code>对应的位置中；</li><li>接着检查 <code>rcv_nxt</code> 能否向右移动,只有当报文的顺序正确且连续才能移动；</li><li>在上图的例子中由于 4 号报文的缺失, <code>rcv_nxt</code> 只能处于 4号位置等待，5, 6 号报文也不能移动到 <code>rcv_queue</code> 中；</li><li>等到 4 号报文到达后，才能将 4, 5, 6 号报文一并移动到<code>rcv_queue</code> 中，同时 <code>rcv_nxt</code> 会右移到 7号位置。</li></ol><h3 id="案例分析">2.3 案例分析</h3><p>我们举个简单的例子演示整个 ARQ的流程。下图中实线箭头表示数据报文，虚线箭头表示 ACK。</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/kcp_5.svg"alt="KCP ARQ 流程" /><figcaption aria-hidden="true">KCP ARQ 流程</figcaption></figure><p>① t1 时刻发送方发送 1 号报文, 1 号报文放入发送缓冲区中, snd_una 指向1, snd_nxt 指向 2.</p><p>② t2 至 t3 时刻发送方依次发送 2 至 3 号报文, snd_nxt 依次后移.</p><p>③ 1 号报文丢包.</p><p>④ t4, t5 时刻接收方收到 3 号和 2 号报文, 放入 rcv_buf 中; 随后回复 3号和 2 号 ACK. 此时由于 1 号报文缺失, rcv_nxt 始终指向 1.</p><p>⑤ 3 号 ACK 丢包.</p><p>⑥ t7 时刻发送方收到 2 号 ACK, 将 2 号报文标记为已送达. 此时由于 3 号ACK 丢包, 3 号报文未标记为已送达. 由于 1 号报文未确认送达, snd_una亦指向 1.</p><p>⑦ t8 时刻 1 号报文超时, 重传.</p><p>⑧ t9 时刻接收方收到 1 号报文, 放入 rcv_buf 中; 这时 1, 2, 3号报文顺序正确, rcv_nxt 右移到 4 号位置. 接收方回复 1 号 ACK, 同时带上una = 4.</p><p>⑨ t10 时刻发送方收到 1 号 ACK, 将 1 号报文标记为已送达. 同时 una 表明1, 2, 3 号报文均已送达, 因此也将 3 号报文标记为已送达. snd_una 移动到4.</p><h2 id="超时重传">3. 超时重传</h2><p>超时重传是当发送的数据包在预定时间内未被确认时，重新发送该数据包的机制。在KCP 中，这个时间由重新传输超时（RTO）决定。KCP 计算 RTO 初始值的方法是TCP 的标准方法, 规定在 <ahref="https://www.rfc-editor.org/rfc/rfc6298.html">RFC 6298</a> 中。</p><p>这里还是贴出源码讲比较直观：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ikcp_update_ack</span><span class="params">(ikcpcb *kcp, IINT32 rtt)</span></span><br><span class="line">&#123;</span><br><span class="line">IINT32 rto = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;rx_srtt == <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;rx_srtt = rtt;</span><br><span class="line">kcp-&gt;rx_rttval = rtt / <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">long</span> delta = rtt - kcp-&gt;rx_srtt;</span><br><span class="line"><span class="keyword">if</span> (delta &lt; <span class="number">0</span>) delta = -delta;</span><br><span class="line">kcp-&gt;rx_rttval = (<span class="number">3</span> * kcp-&gt;rx_rttval + delta) / <span class="number">4</span>;</span><br><span class="line">kcp-&gt;rx_srtt = (<span class="number">7</span> * kcp-&gt;rx_srtt + rtt) / <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;rx_srtt &lt; <span class="number">1</span>) kcp-&gt;rx_srtt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">rto = kcp-&gt;rx_srtt + _imax_(kcp-&gt;interval, <span class="number">4</span> * kcp-&gt;rx_rttval);</span><br><span class="line">kcp-&gt;rx_rto = _ibound_(kcp-&gt;rx_minrto, rto, IKCP_RTO_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个计算过程笔者就不做详细介绍了，代码里面的公式读者可以尝试自行画图进行理解，这里就不花大篇幅画公式了，下面我尝试以更通俗易懂的话语解释RTO，只需要理解它在做什么，为什么这么做，就可以了，个人觉得对公式的细节可以暂且忽略。</p><h3 id="rto-计算目的">3.1 RTO 计算目的</h3><p>KCP 的 RTO计算是为了确定在多长时间内未收到确认（ACK）时，应该重新发送数据包。这段时间被称为重传超时时间（RTO）。计算RTO的目的是在网络条件变化的情况下，既能快速响应数据丢失，也能避免不必要的重传，从而保持高效的传输。</p><h3 id="rto-计算涉及的变量解释">3.2 RTO 计算涉及的变量解释</h3><p><strong>RTT 和 SRTT 的概念:</strong></p><ul><li>RTT（Round-Trip Time）:是从发送一个数据包到收到其确认（ACK）所花的时间。</li><li>SRTT（Smoothed RTT）: 是 RTT 的加权平均值，它代表了 RTT的一个更稳定的估计值。SRTT 的目的是减少 RTT 的短期波动对 RTO的影响。</li></ul><p><strong>RTT 变化值（RTTvariance）</strong>：网络传输时间并不总是固定的，有时会因为网络拥塞或其他原因出现波动。我们通过计算RTT 变化值（RTT variance）来估计这种波动的大小。</p><p><strong>为什么需要 SRTT 和 RTT 变化值：</strong></p><ul><li>SRTT 给我们一个平均的 RTT 估计值。</li><li>RTT 变化值告诉我们网络的波动性。如果波动很大，我们希望 RTO更大，以免因为短暂的网络延迟就触发不必要的重传。</li></ul><h3 id="rto-计算步骤">3.3 RTO 计算步骤</h3><p><strong>1. 初始化</strong>：初次计算时，我们没有历史 RTT值，所以直接用第一次测量的 RTT 来初始化 SRTT，并将 RTT 变化值设为 RTT的一半。</p><p><strong>2. 更新 SRTT 和 RTT 变化值</strong>:</p><ul><li>每次我们测量新的 RTT，就用它来更新 SRTT 和 RTT 变化值。</li><li>更新 SRTT：我们不直接替换旧的SRTT，而是用一个平滑的方式（即加权平均），使得 SRTT 逐渐靠近新RTT，但又不会剧烈变化。</li><li>更新 RTT 变化值：计算新的 RTT 与 SRTT 的差值，用这个差值来更新 RTT变化值，使其反映当前网络波动的大小。</li></ul><p><strong>3. 计算 RTO</strong>:</p><ul><li>用 SRTT 加上四倍的 RTT 变化值来计算 RTO，这样可以确保 RTO足够长，能涵盖大部分的网络波动。</li><li>我们还要确保 RTO 不小于一个最小值（<code>rx_minrto</code>），以防止RTO过小导致频繁重传；也不能大于一个最大值（<code>IKCP_RTO_MAX</code>），以防止RTO 过大影响响应速度。</li></ul><h3 id="rto-计算效果">4. RTO 计算效果</h3><ul><li><strong>稳定的传输</strong>: SRTT 提供了一个稳定的平均 RTT估计，使得 RTO 能适应网络的长期变化。</li><li><strong>适应网络波动</strong>: RTT 变化值使得 RTO能够应对网络的短期波动，减少因短暂延迟而导致的重传。</li><li><strong>快速响应</strong>: RTO设置合理后，能够在数据丢失时快速重传，保持传输的高效和及时性。</li></ul><p>通过这样的计算方式，KCP能够在不同的网络条件下，自动调整重传策略，从而在保证数据可靠性的同时，保持较高的传输效率。</p><h2 id="快速重传">4. 快速重传</h2><p>在网络传输中，数据包可能会由于网络拥塞、丢包等原因而丢失。超时重传依赖于重传超时时间（RTO）来判断是否需要重传，这可能会导致响应延迟。而快速重传通过检测重复的确认包（ACK）来快速判断数据包的丢失，并立即触发重传，显著缩短了数据丢失的恢复时间。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612200038895.png"alt="KCP 快速重传" /><figcaption aria-hidden="true">KCP 快速重传</figcaption></figure><h3 id="何时快速重传">4.1 何时快速重传？</h3><ul><li>每个报文的 <code>fastack</code> 记录了它检测到 ACK 失序的次数，每当KCP 收到一个编号为 sn 的 ACK 时，就会检查 snd_buf 中编号小于 sn且未确认送达的报文，并将其 <code>fastack</code> 加 1。</li><li>可以通过配置 <code>fastresend</code>指定失序多少次就执行快速重传。</li><li>每次调用 ikcp_flush 都会重传 snd_buf 中<code>fastask &gt;= fastresend</code> 的报文。</li></ul><h3 id="无限快速重传吗">4.2 无限快速重传吗？</h3><ul><li>每个报文的 <code>xmit</code> 记录它被传输的次数，可以配置<code>fastlimit</code> 规定传输次数小于 <code>fastlimit</code>的报文才能执行快速重传。</li></ul><h2 id="比较-tcp-的超时重传和快速重传">5. 比较 TCP的超时重传和快速重传</h2><p>TCP 也实现了类似的机制，但在复杂性和应用场景上有所不同。</p><h3 id="tcp-的超时重传">5.1 TCP 的超时重传</h3><p><strong>1. RTT 估算</strong>:</p><ul><li><p>TCP 通过接收确认包来估算 RTT，并使用 RTT 的变化范围来计算RTO。</p></li><li><p>TCP 使用 Jacobson/Karels 算法进行 RTT 估算和 RTO 计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SRTT and RTTVAR calculation</span></span><br><span class="line">RTTVAR = (<span class="number">1</span> - β) * RTTVAR + β * |RTTsample - SRTT|</span><br><span class="line">SRTT = (<span class="number">1</span> - α) * SRTT + α * RTTsample</span><br><span class="line">RTO = SRTT + <span class="number">4</span> * RTTVAR</span><br></pre></td></tr></table></figure><p>其中，SRTT 是平滑的 RTT，RTTVAR 是 RTT 的变化范围，α 和 β是权重因子。</p></li></ul><p><strong>2. 重传策略</strong>:</p><ul><li>如果在 RTO 时间内未收到 ACK，TCP 会重传未确认的数据包。</li><li>每次重传，RTO 值会按照指数增长（指数退避算法）。</li></ul><p><strong>3. 拥塞控制</strong>:</p><ul><li>TCP使用复杂的拥塞控制机制，如慢启动、拥塞避免等，来调整发送窗口和传输速率。</li></ul><h3 id="tcp-的快速重传">5.2 TCP 的快速重传</h3><ul><li>当接收到三个重复的 ACK 时，TCP 会立即重传丢失的数据包，而不等待 RTO超时。</li><li>快速重传后，TCP进入快速恢复状态，调整拥塞窗口，避免拥塞窗口过度收缩。</li></ul><h3 id="比较分析">5.3 比较分析</h3><table><colgroup><col style="width: 16%" /><col style="width: 41%" /><col style="width: 42%" /></colgroup><thead><tr class="header"><th>特性</th><th>KCP</th><th>TCP</th></tr></thead><tbody><tr class="odd"><td><strong>RTT 估算</strong></td><td>基于加权移动平均，较为简单</td><td>使用 Jacobson/Karels 算法，复杂但精确</td></tr><tr class="even"><td><strong>RTO 计算</strong></td><td>简化的计算公式</td><td>基于 RTT 的复杂计算</td></tr><tr class="odd"><td><strong>重传机制</strong></td><td>超时重传和快速重传</td><td>超时重传和快速重传</td></tr><tr class="even"><td><strong>拥塞控制</strong></td><td>简单的拥塞控制，适合低延迟应用</td><td>复杂的拥塞控制，适合广泛的传输场景</td></tr><tr class="odd"><td><strong>适用场景</strong></td><td>实时应用，如游戏、视频会议</td><td>通用应用，如文件传输、HTTP</td></tr><tr class="even"><td><strong>实现复杂度</strong></td><td>较为简单，易于理解和实现</td><td>复杂，需处理更多的网络状态和控制</td></tr><tr class="odd"><td><strong>可靠性</strong></td><td>依赖于用户自定义的重传和控制策略</td><td>内置可靠性和流控制机制</td></tr><tr class="even"><td><strong>响应速度</strong></td><td>高效快速，适用于低延迟和高吞吐量场景</td><td>可靠但响应速度较慢，适合稳定传输场景</td></tr></tbody></table><p>KCP 和 TCP 都提供了可靠的传输机制，但它们适用于不同的应用场景。KCP设计简单，适合对延迟敏感的实时应用，而 TCP拥有完善的拥塞控制和可靠性机制，适合广泛的网络应用。</p><h2 id="拥塞控制">6. 拥塞控制</h2><p>拥塞控制是网络传输协议中的一个重要机制，用于防止发送过多的数据包导致网络拥塞。在KCP中，拥塞控制相对简单，主要通过发送窗口（<code>snd_wnd</code>）和拥塞窗口（<code>cwnd</code>）来管理数据发送速率。</p><h3 id="三种策略">6.1 三种策略</h3><p>KCP 有 3 种拥塞控制的策略：</p><ul><li>慢启动（slow start）</li><li>拥塞避免（congestion avoidance）</li><li>快速恢复（fast recovery）</li></ul><p><strong>慢启动</strong>：先将 cwnd 设置为 1，随后平均每经过一个 RTT时间，<code>cwnd = cwnd * 2</code>，直到阈值 <code>ssthresh</code>。</p><p><strong>拥塞避免</strong>：cwnd 到 <code>ssthresh</code> 后，cwnd呈<strong>线性</strong>增长。</p><p>当慢启动或者拥塞避免造成 <strong>丢包</strong>后，就采取相应的退让策略：</p><ol type="1"><li><code>fastack &gt;= fastresend</code> -&gt; 发生快速重传：将<code>ssthresh = cwnd / 2</code>，<code>cwnd = ssthresh + fastresend</code>进入<strong>快恢复</strong>。</li><li><code>current &gt;= resentts</code> -&gt;超时重传：<code>ssthresh = ssthresh / 2</code>，<code>cwnd = 1</code>，进入<strong>慢启动</strong>。</li></ol><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/kcp_7.svg"alt="拥塞控制中 cwnd 和 ssthresh 的变化情况" /><figcaption aria-hidden="true">拥塞控制中 cwnd 和 ssthresh的变化情况</figcaption></figure><h3 id="核心概念">6.2 核心概念</h3><p>KCP 的拥塞控制基于以下几个核心概念：</p><ul><li><strong>发送窗口(<code>snd_wnd</code>)</strong>：表示发送端在未收到接收端确认之前，允许发送的数据包的数量。它类似于TCP 中的发送窗口，控制了数据流的速率。</li><li><strong>接收窗口(<code>rcv_wnd</code>)</strong>：表示接收端能够处理的最大数据包数量。发送端通过接收端的窗口大小来调整自己的发送速率。</li><li><strong>远端窗口(<code>rmt_wnd</code>)</strong>：表示接收端的窗口大小，发送端会根据这个值调整自己的发送窗口，以避免发送的数据超出接收端的处理能力。</li><li><strong>拥塞窗口(<code>cwnd</code>)</strong>：用于控制传输中的数据包数量。它基于网络的拥塞情况动态调整，以避免网络拥塞。</li><li><strong>慢启动阈值(<code>ssthresh</code>)</strong>：用于确定拥塞控制的模式。当<code>cwnd</code> 小于 <code>ssthresh</code> 时，KCP处于慢启动模式，否则进入拥塞避免模式。</li></ul><h3 id="窗口探测window-probing">6.3 窗口探测（Window Probing）</h3><p>在某些情况下，接收端的窗口可能会被关闭（即 <code>rmt_wnd</code> 为0），这意味着接收端无法接收任何新的数据。为了应对这种情况，KCP实现了窗口探测机制：</p><ul><li>当 <code>rmt_wnd</code> 为 0 时，KCP不会立即停止发送数据，而是会定期发送一个探测包，以检测接收端窗口是否已经打开。</li><li>这个探测包会触发接收端返回一个ACK，其中包含最新的接收窗口大小信息。</li></ul><h3 id="调节和配置">6.4 调节和配置</h3><p>KCP的拥塞控制机制提供了一些配置参数，用户可以通过调整这些参数来优化传输性能：</p><ul><li><strong><code>snd_wnd</code></strong>:发送窗口大小，用户可以根据应用的需求调整该值，以控制数据发送的最大量。</li><li><strong><code>rcv_wnd</code></strong>:接收窗口大小，表示接收端能够处理的最大数据包数量。</li><li><strong><code>ssthresh</code></strong>:慢启动阈值，初始值通常设置为较大的一个常量，用户可以根据网络情况调整。</li><li><strong><code>cwnd</code></strong>: 拥塞窗口大小，初始值通常设置为1，随传输情况动态调整。</li></ul><h2 id="比较-tcp-的拥塞控制">7. 比较 TCP 的拥塞控制</h2><h3 id="四个阶段">7.1 四个阶段</h3><p>TCP 拥塞控制有四个关键阶段</p><p><strong>慢启动（Slow Start）</strong>：</p><ul><li><strong>目的</strong>：快速探测网络的可用带宽。</li><li><strong>机制</strong>：当一个连接刚建立或者从丢包恢复时，<code>cwnd</code>（拥塞窗口）从一个较小的值（通常是1 个 MSS，即最大报文段大小）开始，并以指数增长的方式增加。</li><li><strong>过程</strong>：每次收到一个 ACK，<code>cwnd</code> 增加一个MSS，使得 <code>cwnd</code> 每 RTT 增加一倍，直到 <code>cwnd</code>达到慢启动阈值（<code>ssthresh</code>）。</li></ul><p><strong>拥塞避免（Congestion Avoidance）</strong>:</p><ul><li><strong>目的</strong>：逐步探测网络的最大容量，并避免拥塞。</li><li><strong>机制</strong>：当 <code>cwnd</code> 达到或超过<code>ssthresh</code> 时，TCP 进入拥塞避免阶段，此时 <code>cwnd</code>以线性增长的方式增加。</li><li><strong>过程</strong>：每个 RTT，<code>cwnd</code> 增加<code>1/cwnd</code> 个MSS，这种增长方式较为保守，旨在防止过度发送导致的拥塞。</li></ul><p><strong>快速重传（Fast Retransmit）</strong>:</p><ul><li><strong>目的</strong>：快速响应丢包，提高传输效率。</li><li><strong>机制</strong>：当发送端收到三个重复的 ACK时，立即重传被确认丢失的数据包，而不等待 RTO 超时。</li><li><strong>过程</strong>：快速重传的目的是迅速恢复丢失的数据包，从而减少因丢包导致的等待时间。</li></ul><p><strong>快速恢复（Fast Recovery）</strong>:</p><ul><li><strong>目的</strong>：在拥塞后快速恢复到适当的传输速率。</li><li><strong>机制</strong>：在快速重传后，TCP不会直接进入慢启动，而是保持 <code>cwnd</code>的一部分，以较快的速度恢复到拥塞避免状态。</li><li><strong>过程</strong>：将 <code>ssthresh</code> 设置为当前<code>cwnd</code> 的一半，<code>cwnd</code> 被临时减小，然后在接收新 ACK时快速增加 <code>cwnd</code>，直到恢复到 <code>ssthresh</code>为止。</li></ul><h3 id="比较分析-1">7.2 比较分析</h3><table><colgroup><col style="width: 14%" /><col style="width: 42%" /><col style="width: 42%" /></colgroup><thead><tr class="header"><th>特性</th><th>TCP</th><th>KCP</th></tr></thead><tbody><tr class="odd"><td><strong>实现复杂度</strong></td><td>复杂，包含多个阶段和算法</td><td>简单，主要通过窗口大小控制</td></tr><tr class="even"><td><strong>拥塞检测</strong></td><td>通过 RTT 估算和 ACK 检测丢包</td><td>主要通过 ACK 和窗口大小检测丢包</td></tr><tr class="odd"><td><strong>响应速度</strong></td><td>响应相对较慢，适合稳定传输</td><td>响应较快，适合实时性高的传输</td></tr><tr class="even"><td><strong>适应性</strong></td><td>能适应广泛的网络条件</td><td>适应性较好，但更适合低延迟网络</td></tr><tr class="odd"><td><strong>配置灵活性</strong></td><td>较为固定，依赖于系统配置和优化</td><td>提供更多的配置选项，用户可根据需求调整</td></tr><tr class="even"><td><strong>应用场景</strong></td><td>适用于各种需要可靠传输的应用</td><td>适用于实时性要求高的应用，如游戏和视频会议</td></tr><tr class="odd"><td><strong>窗口调整</strong></td><td>慢启动、拥塞避免、快速重传、快速恢复等机制</td><td>主要通过发送窗口和拥塞窗口调整</td></tr><tr class="even"><td><strong>丢包响应</strong></td><td>丢包时通过减小 <code>cwnd</code> 和 <code>ssthresh</code>来调整</td><td>丢包时迅速调整 <code>cwnd</code> 和重传</td></tr><tr class="odd"><td><strong>拥塞控制策略</strong></td><td>慢启动、拥塞避免、快速重传、快速恢复等多种策略</td><td>主要通过调整 <code>cwnd</code> 和 <code>ssthresh</code>进行简单控制</td></tr><tr class="even"><td><strong>优点</strong></td><td>稳定可靠、机制全面、应用广泛</td><td>实现简单、响应快、灵活性高、适合实时应用</td></tr><tr class="odd"><td><strong>缺点</strong></td><td>复杂、响应慢、初始阶段保守</td><td>无法应对更加复杂的网络状况、应用场景有限</td></tr></tbody></table><p>TCP 和 KCP 都有各自的拥塞控制机制，适用于不同的应用场景。TCP提供了复杂而全面的拥塞控制，适合于各种网络条件下的可靠传输，而 KCP提供了简单高效的控制机制，适合于低延迟和高响应速度的实时应用。选择使用哪种协议取决于具体的应用需求和网络环境。</p><h1 id="源码分析">源码分析</h1><h2 id="核心数据结构">1. 核心数据结构</h2><h3 id="ikcpseg-报文段结构">1.1 IKCPSEG 报文段结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPSEG</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">node</span>;</span>  <span class="comment">// 链表节点</span></span><br><span class="line">    IUINT32 conv;     <span class="comment">// 会话ID</span></span><br><span class="line">    IUINT32 cmd;      <span class="comment">// 命令类型</span></span><br><span class="line">    IUINT32 frg;      <span class="comment">// 分片序号</span></span><br><span class="line">    IUINT32 wnd;      <span class="comment">// 窗口大小</span></span><br><span class="line">    IUINT32 ts;       <span class="comment">// 时间戳</span></span><br><span class="line">    IUINT32 sn;       <span class="comment">// 序列号</span></span><br><span class="line">    IUINT32 una;      <span class="comment">// 待接收的下一个包序号</span></span><br><span class="line">    IUINT32 len;      <span class="comment">// 数据长度</span></span><br><span class="line">    IUINT32 resendts; <span class="comment">// 重传时间戳</span></span><br><span class="line">    IUINT32 rto;      <span class="comment">// 超时重传时间</span></span><br><span class="line">    IUINT32 fastack;  <span class="comment">// 快速重传计数器</span></span><br><span class="line">    IUINT32 xmit;     <span class="comment">// 传输次数</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">1</span>];     <span class="comment">// 数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ikcpcb-控制块">1.2 IKCPCB 控制块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPCB</span> &#123;</span></span><br><span class="line">    <span class="comment">// === 基础配置 ===</span></span><br><span class="line">    IUINT32 conv;          <span class="comment">// 会话ID，用于标识一个会话</span></span><br><span class="line">    IUINT32 mtu;          <span class="comment">// 最大传输单元，默认1400字节</span></span><br><span class="line">    IUINT32 mss;          <span class="comment">// 最大报文段大小，默认mtu-24字节</span></span><br><span class="line">    IUINT32 state;        <span class="comment">// 连接状态，0=正常，-1=断开</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 发送和接收序号 ===</span></span><br><span class="line">    IUINT32 snd_una;      <span class="comment">// 第一个未确认的包序号</span></span><br><span class="line">    IUINT32 snd_nxt;      <span class="comment">// 下一个待发送的包序号</span></span><br><span class="line">    IUINT32 rcv_nxt;      <span class="comment">// 待接收的下一个包序号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 时间戳相关 ===</span></span><br><span class="line">    IUINT32 ts_recent;    <span class="comment">// 最近一次收到包的时间戳</span></span><br><span class="line">    IUINT32 ts_lastack;   <span class="comment">// 最近一次收到ACK的时间戳</span></span><br><span class="line">    IUINT32 ssthresh;     <span class="comment">// 慢启动阈值，默认为IKCP_THRESH_INIT(2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === RTT相关 ===</span></span><br><span class="line">    IINT32 rx_rttval;     <span class="comment">// RTT的变化量</span></span><br><span class="line">    IINT32 rx_srtt;       <span class="comment">// 平滑后的RTT</span></span><br><span class="line">    IINT32 rx_rto;        <span class="comment">// 超时重传时间，初始为IKCP_RTO_DEF(200ms)</span></span><br><span class="line">    IINT32 rx_minrto;     <span class="comment">// 最小重传超时时间，默认为IKCP_RTO_MIN(100ms)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 窗口相关 ===</span></span><br><span class="line">    IUINT32 snd_wnd;      <span class="comment">// 发送窗口大小，默认32</span></span><br><span class="line">    IUINT32 rcv_wnd;      <span class="comment">// 接收窗口大小，默认128</span></span><br><span class="line">    IUINT32 rmt_wnd;      <span class="comment">// 远端窗口大小，默认128</span></span><br><span class="line">    IUINT32 cwnd;         <span class="comment">// 拥塞窗口大小，初始为0</span></span><br><span class="line">    IUINT32 probe;        <span class="comment">// 探测标志，用于窗口探测</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 时间相关 ===</span></span><br><span class="line">    IUINT32 current;      <span class="comment">// 当前时间</span></span><br><span class="line">    IUINT32 interval;     <span class="comment">// 内部更新时间间隔，默认100ms</span></span><br><span class="line">    IUINT32 ts_flush;     <span class="comment">// 下次刷新时间</span></span><br><span class="line">    IUINT32 xmit;         <span class="comment">// 总重传次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 队列计数器 ===</span></span><br><span class="line">    IUINT32 nrcv_buf;     <span class="comment">// 接收缓存中的包数量</span></span><br><span class="line">    IUINT32 nsnd_buf;     <span class="comment">// 发送缓存中的包数量</span></span><br><span class="line">    IUINT32 nrcv_que;     <span class="comment">// 接收队列中的包数量</span></span><br><span class="line">    IUINT32 nsnd_que;     <span class="comment">// 发送队列中的包数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 配置标志 ===</span></span><br><span class="line">    IUINT32 nodelay;      <span class="comment">// 是否启用nodelay模式，0=不启用</span></span><br><span class="line">    IUINT32 updated;      <span class="comment">// 是否调用过update</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 探测相关 ===</span></span><br><span class="line">    IUINT32 ts_probe;     <span class="comment">// 下次探测时间</span></span><br><span class="line">    IUINT32 probe_wait;   <span class="comment">// 探测等待时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 链路控制 ===</span></span><br><span class="line">    IUINT32 dead_link;    <span class="comment">// 最大重传次数，默认为IKCP_DEADLINK(20)</span></span><br><span class="line">    IUINT32 incr;         <span class="comment">// 可发送的最大数据量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 数据队列 ===</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_queue</span>;</span>  <span class="comment">// 发送队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_queue</span>;</span>  <span class="comment">// 接收队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_buf</span>;</span>    <span class="comment">// 发送缓存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_buf</span>;</span>    <span class="comment">// 接收缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === ACK相关 ===</span></span><br><span class="line">    IUINT32 *acklist;     <span class="comment">// ACK列表</span></span><br><span class="line">    IUINT32 ackcount;     <span class="comment">// ACK数量</span></span><br><span class="line">    IUINT32 ackblock;     <span class="comment">// ACK列表大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 用户相关 ===</span></span><br><span class="line">    <span class="type">void</span> *user;           <span class="comment">// 用户数据指针</span></span><br><span class="line">    <span class="type">char</span> *buffer;         <span class="comment">// 临时缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 快速重传相关 ===</span></span><br><span class="line">    <span class="type">int</span> fastresend;       <span class="comment">// 触发快速重传的重复ACK个数</span></span><br><span class="line">    <span class="type">int</span> fastlimit;        <span class="comment">// 快速重传次数限制，默认IKCP_FASTACK_LIMIT(5)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 其他配置 ===</span></span><br><span class="line">    <span class="type">int</span> nocwnd;          <span class="comment">// 是否关闭拥塞控制，0=不关闭</span></span><br><span class="line">    <span class="type">int</span> stream;          <span class="comment">// 是否为流模式，0=消息模式(默认)，1=流模式</span></span><br><span class="line">    <span class="type">int</span> logmask;        <span class="comment">// 日志掩码，控制日志输出级别</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 回调函数 ===</span></span><br><span class="line">    <span class="comment">// 数据输出回调，用于发送数据</span></span><br><span class="line">    <span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line">    <span class="comment">// 日志输出回调</span></span><br><span class="line">    <span class="type">void</span> (*writelog)(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">log</span>, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体可以大致分为几个主要部分：</p><ul><li>基础配置：包含基本的会话标识和传输单元大小设置</li><li>序号追踪：用于追踪发送和接收的包序号</li><li>时间管理：包含各种时间戳和定时器</li><li>窗口控制：实现流量控制和拥塞控制</li><li>队列管理：管理数据的发送和接收</li><li>ACK 处理：处理确认包</li><li>配置选项：各种功能开关和参数设置</li><li>回调函数：用于数据输出和日志记录</li></ul><h2 id="核心函数">2. 核心函数</h2><p>在进入具体的核心函数分析之前，需要先点明 2 点，<code>kcp</code>的实现者期望其尽可能地简单和减少依赖，所以数据的输出甚至是当前时间都是由使用者来设置的，即<code>kcp</code> 本身是不依赖于机器时钟的。具体体现在下面 2 个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// set output callback, which will be invoked by kcp</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_setoutput</span><span class="params">(ikcpcb *kcp, <span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">ikcpcb *kcp, <span class="type">void</span> *user))</span></span><br><span class="line">&#123;</span><br><span class="line">kcp-&gt;output = output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// update state (call it repeatedly, every 10ms-100ms), or you can ask</span></span><br><span class="line"><span class="comment">// ikcp_check when to call it again (without ikcp_input/_send calling).</span></span><br><span class="line"><span class="comment">// &#x27;current&#x27; - current timestamp in millisec.</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_update</span><span class="params">(ikcpcb *kcp, IUINT32 current)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ikcp_send-发送数据">2.1 ikcp_send 发送数据</h3><p><code>ikcp_send</code>是应用层接口，负责将用户数据分片并加入到发送队列（<code>snd_queue</code>）。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241129154115523.png"alt="ikcp_send" /><figcaption aria-hidden="true">ikcp_send</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// user/upper level send, returns below zero for error</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_send</span><span class="params">(ikcpcb *kcp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">IKCPSEG *seg;</span><br><span class="line"><span class="type">int</span> count, i;</span><br><span class="line"><span class="type">int</span> sent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mtu: 最大传输单元</span></span><br><span class="line"><span class="comment">// mss: 最大报文段大小</span></span><br><span class="line"><span class="comment">// mss = mtu - 包头长度(24)</span></span><br><span class="line">assert(kcp-&gt;mss &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// append to previous segment in streaming mode (if possible)</span></span><br><span class="line"><span class="comment">// 如果是流模式，则将数据追加到前一个分段中（如果可能）</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;stream != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 如果当前发送队列不为空，且前一个分段未满，则将数据追加到前一个分段中</span></span><br><span class="line"><span class="keyword">if</span> (!iqueue_is_empty(&amp;kcp-&gt;snd_queue)) &#123;</span><br><span class="line">IKCPSEG *old = iqueue_entry(kcp-&gt;snd_queue.prev, IKCPSEG, node);</span><br><span class="line"><span class="keyword">if</span> (old-&gt;len &lt; kcp-&gt;mss) &#123;</span><br><span class="line"><span class="type">int</span> capacity = kcp-&gt;mss - old-&gt;len;</span><br><span class="line"><span class="type">int</span> extend = (len &lt; capacity)? len : capacity;</span><br><span class="line">seg = ikcp_segment_new(kcp, old-&gt;len + extend);</span><br><span class="line">assert(seg);</span><br><span class="line"><span class="keyword">if</span> (seg == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将新的 seg-&gt;node 放入 snd_queue 中等待发送</span></span><br><span class="line">iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;snd_queue);</span><br><span class="line"><span class="comment">// 把上一个报文的数据拷贝过来</span></span><br><span class="line"><span class="built_in">memcpy</span>(seg-&gt;data, old-&gt;data, old-&gt;len);</span><br><span class="line"><span class="keyword">if</span> (buffer) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(seg-&gt;data + old-&gt;len, buffer, extend);</span><br><span class="line">buffer += extend;</span><br><span class="line">&#125;</span><br><span class="line">seg-&gt;len = old-&gt;len + extend;</span><br><span class="line">seg-&gt;frg = <span class="number">0</span>;</span><br><span class="line">len -= extend;</span><br><span class="line">iqueue_del_init(&amp;old-&gt;node);</span><br><span class="line"><span class="comment">// 释放之前老数据的 kcp node</span></span><br><span class="line">ikcp_segment_delete(kcp, old);</span><br><span class="line">sent = extend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> sent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 非流模式，不追加到上一个报文后面</span></span><br><span class="line"><span class="comment">// 2. 流模式，但是上一个报文已满，则创建新的报文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算需要的报文数量，kcp 会对数据进行分段传输</span></span><br><span class="line"><span class="keyword">if</span> (len &lt;= (<span class="type">int</span>)kcp-&gt;mss) count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> count = (len + kcp-&gt;mss - <span class="number">1</span>) / kcp-&gt;mss;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收窗口位置不够，则暂停发送</span></span><br><span class="line"><span class="keyword">if</span> (count &gt;= (<span class="type">int</span>)IKCP_WND_RCV) &#123;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;stream != <span class="number">0</span> &amp;&amp; sent &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> sent;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送所有的报文段</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"><span class="type">int</span> size = len &gt; (<span class="type">int</span>)kcp-&gt;mss ? (<span class="type">int</span>)kcp-&gt;mss : len;</span><br><span class="line">seg = ikcp_segment_new(kcp, size);</span><br><span class="line">assert(seg);</span><br><span class="line"><span class="keyword">if</span> (seg == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (buffer &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(seg-&gt;data, buffer, size);</span><br><span class="line">&#125;</span><br><span class="line">seg-&gt;len = size;</span><br><span class="line">seg-&gt;frg = (kcp-&gt;stream == <span class="number">0</span>)? (count - i - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">iqueue_init(&amp;seg-&gt;node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将报文段放入 snd_queue 中</span></span><br><span class="line">iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;snd_queue);</span><br><span class="line">kcp-&gt;nsnd_que++;</span><br><span class="line"><span class="keyword">if</span> (buffer) &#123;</span><br><span class="line">buffer += size;</span><br><span class="line">&#125;</span><br><span class="line">len -= size;</span><br><span class="line">sent += size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ikcp_input-接收数据">2.2 ikcp_input 接收数据</h3><p><code>ikcp_input</code> 负责处理从网络接收到的原始 KCP数据包，它会处理协议层面的数据，包括ACK、窗口控制等协议信息，并将接收到的数据放入 KCP的内部接收缓冲区（<code>rcv_buf</code> 和 <code>rcv_queue</code>）。</p><h3 id="ikcp_recv-获取数据">2.3 ikcp_recv 获取数据</h3><p><code>ikcp_recv</code>是应用层函数，供上层应用调用以获取完整的消息数据，它从 KCP的接收队列(rcv_queue)中读取已经排序好的数据，处理分片重组，确保返回完整的消息。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241129163431276.png"alt="ikcp_recv" /><figcaption aria-hidden="true">ikcp_recv</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// user/upper level recv: returns size, returns below zero for EAGAIN</span></span><br><span class="line"><span class="comment">// 从 rcv_queue 中获取数据</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_recv</span><span class="params">(ikcpcb *kcp, <span class="type">char</span> *buffer, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="type">int</span> ispeek = (len &lt; <span class="number">0</span>)? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> peeksize;</span><br><span class="line"><span class="type">int</span> recover = <span class="number">0</span>;</span><br><span class="line">IKCPSEG *seg;</span><br><span class="line">assert(kcp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 rcv_queue 为空，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (iqueue_is_empty(&amp;kcp-&gt;rcv_queue))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 len &lt; 0，则说明是 peek 操作，准备只查看数据</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span>) len = -len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 rcv_queue 中数据的大小</span></span><br><span class="line">peeksize = ikcp_peeksize(kcp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法获得大小，返回 -2</span></span><br><span class="line"><span class="keyword">if</span> (peeksize &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据过大，返回 -3</span></span><br><span class="line"><span class="keyword">if</span> (peeksize &gt; len)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nrcv_que: rcv_queue 的长度</span></span><br><span class="line"><span class="comment">// rcv_wnd: 接收窗口的大小</span></span><br><span class="line"><span class="comment">// 如果 nrcv_que &gt;= rcv_wnd，则需要进行快恢复</span></span><br><span class="line"><span class="comment">// 因为 nrcv_que &gt;= rcv_wnd，说明接收窗口已经满了，</span></span><br><span class="line"><span class="comment">// 这个时候需要发送 IKCP_CMD_WINS 告诉发送方窗口大小，</span></span><br><span class="line"><span class="comment">// 这个时候发送方需要进行快恢复，减小数据传输，以尽快释放接收窗口</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;nrcv_que &gt;= kcp-&gt;rcv_wnd)</span><br><span class="line">recover = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge fragment</span></span><br><span class="line"><span class="comment">// 将多个片段合并成一个完整的片段</span></span><br><span class="line"><span class="comment">// 合并后，将合并后的片段从 rcv_queue 中删除</span></span><br><span class="line"><span class="keyword">for</span> (len = <span class="number">0</span>, p = kcp-&gt;rcv_queue.next; p != &amp;kcp-&gt;rcv_queue; ) &#123;</span><br><span class="line"><span class="type">int</span> fragment;</span><br><span class="line">seg = iqueue_entry(p, IKCPSEG, node);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buffer) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(buffer, seg-&gt;data, seg-&gt;len);</span><br><span class="line">buffer += seg-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">len += seg-&gt;len;</span><br><span class="line">fragment = seg-&gt;frg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ikcp_canlog(kcp, IKCP_LOG_RECV)) &#123;</span><br><span class="line">ikcp_log(kcp, IKCP_LOG_RECV, <span class="string">&quot;recv sn=%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)seg-&gt;sn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ispeek == <span class="number">0</span>) &#123;</span><br><span class="line">iqueue_del(&amp;seg-&gt;node);</span><br><span class="line">ikcp_segment_delete(kcp, seg);</span><br><span class="line">kcp-&gt;nrcv_que--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fragment == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(len == peeksize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// move available data from rcv_buf -&gt; rcv_queue</span></span><br><span class="line"><span class="comment">// 尝试将 rcv_buf 中编号连续的数据，移动到 rcv_queue 中</span></span><br><span class="line"><span class="comment">// 移动后，将移动的数据从 rcv_buf 中删除</span></span><br><span class="line"><span class="keyword">while</span> (! iqueue_is_empty(&amp;kcp-&gt;rcv_buf)) &#123;</span><br><span class="line">seg = iqueue_entry(kcp-&gt;rcv_buf.next, IKCPSEG, node);</span><br><span class="line"><span class="keyword">if</span> (seg-&gt;sn == kcp-&gt;rcv_nxt &amp;&amp; kcp-&gt;nrcv_que &lt; kcp-&gt;rcv_wnd) &#123;</span><br><span class="line">iqueue_del(&amp;seg-&gt;node);</span><br><span class="line">kcp-&gt;nrcv_buf--;</span><br><span class="line">iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;rcv_queue);</span><br><span class="line">kcp-&gt;nrcv_que++;</span><br><span class="line">kcp-&gt;rcv_nxt++;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快恢复</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;nrcv_que &lt; kcp-&gt;rcv_wnd &amp;&amp; recover) &#123;</span><br><span class="line"><span class="comment">// 在ikcp_flush 中返回 IKCP_CMD_WINS</span></span><br><span class="line"><span class="comment">// 通知本段窗口大小给对端</span></span><br><span class="line">kcp-&gt;probe |= IKCP_ASK_TELL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ikcp_update-定时时钟">2.4 ikcp_update 定时时钟</h3><p>前面我们看了 <code>ikcp_send</code> 、<code>ikcp_input</code> 和<code>ikcp_recv</code>三个核心流程的函数，其中的一些细节，你可以回到本文前面的「原理分析」再对照源码仔细阅读。</p><p>在前面的原理分析中，我们提到，为了提高传输和处理数据的效率，<code>kcp</code>设计了队列和缓冲区，同时为了实现可靠性，<code>kcp</code> 也提供了<code>ACK</code>和重试、拥塞控制等机制，这些事情都是周期定时去处理的。这里是由<code>ikcp_update</code> 函数去处理的。</p><p><code>ikcp_update</code> 是 KCP 的定时器函数，负责以固定间隔调用<code>ikcp_flush</code> 处理数据发送和协议更新，是 KCP的"心跳"机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// update state (call it repeatedly, every 10ms-100ms), or you can ask</span></span><br><span class="line"><span class="comment">// ikcp_check when to call it again (without ikcp_input/_send calling).</span></span><br><span class="line"><span class="comment">// &#x27;current&#x27; - current timestamp in millisec.</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_update</span><span class="params">(ikcpcb *kcp, IUINT32 current)</span></span><br><span class="line">&#123;</span><br><span class="line">IINT32 slap;</span><br><span class="line"></span><br><span class="line">kcp-&gt;current = current;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;updated == <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;updated = <span class="number">1</span>;</span><br><span class="line">kcp-&gt;ts_flush = kcp-&gt;current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算间隔</span></span><br><span class="line">slap = _itimediff(kcp-&gt;current, kcp-&gt;ts_flush);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slap &gt;= <span class="number">10000</span> || slap &lt; <span class="number">-10000</span>) &#123;</span><br><span class="line">kcp-&gt;ts_flush = kcp-&gt;current;</span><br><span class="line">slap = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 达到调用间隔，则执行 ikcp_flush 进行接收数据或发送数据</span></span><br><span class="line"><span class="keyword">if</span> (slap &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;ts_flush += kcp-&gt;interval;</span><br><span class="line"><span class="keyword">if</span> (_itimediff(kcp-&gt;current, kcp-&gt;ts_flush) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;ts_flush = kcp-&gt;current + kcp-&gt;interval;</span><br><span class="line">&#125;</span><br><span class="line">ikcp_flush(kcp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很简单，根据注释所说，通常情况下会每 <code>10ms~100ms</code>执行一次，然后核心是去调用 <code>ikcp_flush</code>函数，所有的逻辑都在里面。</p><h3 id="ikcp_flush-定时处理">2.5 ikcp_flush 定时处理</h3><p>如上所述，<code>ikcp_flush</code> 是 KCP的核心发送函数，负责将发送队列 <code>snd_queue</code>中的数据移入发送缓存 <code>snd_buf</code> 并通过 <code>output</code>回调发送出去，同时处理 ACK发送、快速重传、超时重传和窗口探测等协议细节。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241129170905325.png"alt="ikcp_flush" /><figcaption aria-hidden="true">ikcp_flush</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ikcp_flush</span><span class="params">(ikcpcb *kcp)</span></span><br><span class="line">&#123;</span><br><span class="line">IUINT32 current = kcp-&gt;current;<span class="comment">// 当前时间</span></span><br><span class="line"><span class="type">char</span> *buffer = kcp-&gt;buffer;<span class="comment">// 临时缓冲区</span></span><br><span class="line"><span class="type">char</span> *ptr = buffer;</span><br><span class="line"><span class="type">int</span> count, size, i;</span><br><span class="line">IUINT32 resent, cwnd;</span><br><span class="line">IUINT32 rtomin;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="type">int</span> change = <span class="number">0</span>;<span class="comment">// 是否执行过快速重传</span></span><br><span class="line"><span class="type">int</span> lost = <span class="number">0</span>;<span class="comment">// 是否执行过超时重传</span></span><br><span class="line">IKCPSEG seg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否已调用 ikcp_update</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;updated == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个段用于构建各种控制包</span></span><br><span class="line">seg.conv = kcp-&gt;conv;  <span class="comment">// 连接标识</span></span><br><span class="line">seg.cmd = IKCP_CMD_ACK;<span class="comment">// 报文类型：IKCP_CMD_ACK 表示确认报文</span></span><br><span class="line">seg.frg = <span class="number">0</span>;<span class="comment">// 分片数量，表示随后还有多少个报文属于同一个包</span></span><br><span class="line">seg.wnd = ikcp_wnd_unused(kcp);<span class="comment">// 发送方剩余接收窗口的大小</span></span><br><span class="line">seg.una = kcp-&gt;rcv_nxt;<span class="comment">// 发送方的接收缓冲区中最小还未收到的报文段的编号，也就是说，编号比它小的报文段都已全部接收</span></span><br><span class="line">seg.len = <span class="number">0</span>;<span class="comment">// 数据段长度</span></span><br><span class="line">seg.sn = <span class="number">0</span>;<span class="comment">// 报文编号</span></span><br><span class="line">seg.ts = <span class="number">0</span>;<span class="comment">// 时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// flush acknowledges</span></span><br><span class="line"><span class="comment">// ① 发送 ACK 队列中的所有 ACK</span></span><br><span class="line">count = kcp-&gt;ackcount;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line"><span class="comment">// buffer 中累计的数据将要超过 mtu 的时候</span></span><br><span class="line"><span class="comment">// 就调用 ikcp_output 将数据发送出去</span></span><br><span class="line"><span class="keyword">if</span> (size + (<span class="type">int</span>)IKCP_OVERHEAD &gt; (<span class="type">int</span>)kcp-&gt;mtu) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">ptr = buffer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 ACK 列表中取出 sn(报文编号)和 ts(时间戳)</span></span><br><span class="line">ikcp_ack_get(kcp, i, &amp;seg.sn, &amp;seg.ts);</span><br><span class="line"><span class="comment">// 将 ACK 报文写入 buffer</span></span><br><span class="line">ptr = ikcp_encode_seg(ptr, &amp;seg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ② ACK 队列已清空</span></span><br><span class="line">kcp-&gt;ackcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// probe window size (if remote window size equals zero)</span></span><br><span class="line"><span class="comment">// 对端剩余接收窗口大小为 0，则意味着可能需要发送窗口探测报文：IKCP_CMD_WASK</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;rmt_wnd == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 根据 ts_probe 和 probe_wait 确定当前时刻是否需要发送探测报文</span></span><br><span class="line"><span class="comment">// probe_wait: 等待发送探测报文的时间，IKCP_PROBE_INIT=7s, IKCP_PROBE_LIMIT=</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe_wait == <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;probe_wait = IKCP_PROBE_INIT; <span class="comment">// 7s 后去发探测报文</span></span><br><span class="line">kcp-&gt;ts_probe = kcp-&gt;current + kcp-&gt;probe_wait;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (_itimediff(kcp-&gt;current, kcp-&gt;ts_probe) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe_wait &lt; IKCP_PROBE_INIT)</span><br><span class="line">kcp-&gt;probe_wait = IKCP_PROBE_INIT;</span><br><span class="line">kcp-&gt;probe_wait += kcp-&gt;probe_wait / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe_wait &gt; IKCP_PROBE_LIMIT)</span><br><span class="line">kcp-&gt;probe_wait = IKCP_PROBE_LIMIT;</span><br><span class="line">kcp-&gt;ts_probe = kcp-&gt;current + kcp-&gt;probe_wait;</span><br><span class="line">kcp-&gt;probe |= IKCP_ASK_SEND; <span class="comment">// 设置是否需要去发送 IKCP_ASK_SEND</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kcp-&gt;ts_probe = <span class="number">0</span>;</span><br><span class="line">kcp-&gt;probe_wait = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flush window probing commands</span></span><br><span class="line"><span class="comment">// ③ 如果需要，则发送窗口探测报文：IKCP_CMD_WASK</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe &amp; IKCP_ASK_SEND) &#123;</span><br><span class="line">seg.cmd = IKCP_CMD_WASK;</span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line"><span class="keyword">if</span> (size + (<span class="type">int</span>)IKCP_OVERHEAD &gt; (<span class="type">int</span>)kcp-&gt;mtu) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">ptr = buffer;</span><br><span class="line">&#125;</span><br><span class="line">ptr = ikcp_encode_seg(ptr, &amp;seg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flush window probing commands</span></span><br><span class="line"><span class="comment">// ④ 如果需要，则发送窗口通知报文：IKCP_CMD_WINS</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe &amp; IKCP_ASK_TELL) &#123;</span><br><span class="line">seg.cmd = IKCP_CMD_WINS;</span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line"><span class="keyword">if</span> (size + (<span class="type">int</span>)IKCP_OVERHEAD &gt; (<span class="type">int</span>)kcp-&gt;mtu) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">ptr = buffer;</span><br><span class="line">&#125;</span><br><span class="line">ptr = ikcp_encode_seg(ptr, &amp;seg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kcp-&gt;probe = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate window size</span></span><br><span class="line"><span class="comment">// ⑤ 计算当前窗口大小</span></span><br><span class="line">cwnd = _imin_(kcp-&gt;snd_wnd, kcp-&gt;rmt_wnd);</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;nocwnd == <span class="number">0</span>) cwnd = _imin_(kcp-&gt;cwnd, cwnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// move data from snd_queue to snd_buf</span></span><br><span class="line"><span class="comment">// 5.1 如果符合发送的条件，则创建新的 newseg 并放入 snd_buf 的尾部</span></span><br><span class="line"><span class="keyword">while</span> (_itimediff(kcp-&gt;snd_nxt, kcp-&gt;snd_una + cwnd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">IKCPSEG *newseg;</span><br><span class="line"><span class="keyword">if</span> (iqueue_is_empty(&amp;kcp-&gt;snd_queue)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">newseg = iqueue_entry(kcp-&gt;snd_queue.next, IKCPSEG, node);</span><br><span class="line"></span><br><span class="line">iqueue_del(&amp;newseg-&gt;node);</span><br><span class="line">iqueue_add_tail(&amp;newseg-&gt;node, &amp;kcp-&gt;snd_buf);</span><br><span class="line">kcp-&gt;nsnd_que--;</span><br><span class="line">kcp-&gt;nsnd_buf++;</span><br><span class="line"></span><br><span class="line">newseg-&gt;conv = kcp-&gt;conv;</span><br><span class="line">newseg-&gt;cmd = IKCP_CMD_PUSH;</span><br><span class="line">newseg-&gt;wnd = seg.wnd;</span><br><span class="line">newseg-&gt;ts = current;</span><br><span class="line">newseg-&gt;sn = kcp-&gt;snd_nxt++;</span><br><span class="line">newseg-&gt;una = kcp-&gt;rcv_nxt;</span><br><span class="line">newseg-&gt;resendts = current;</span><br><span class="line">newseg-&gt;rto = kcp-&gt;rx_rto;</span><br><span class="line">newseg-&gt;fastack = <span class="number">0</span>;</span><br><span class="line">newseg-&gt;xmit = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate resent</span></span><br><span class="line"><span class="comment">// 失序多少次就快速重传。如果 fastresend 大于 0，则取其值；否则，设为最大值 0xffffffff。</span></span><br><span class="line">resent = (kcp-&gt;fastresend &gt; <span class="number">0</span>)? (IUINT32)kcp-&gt;fastresend : <span class="number">0xffffffff</span>;</span><br><span class="line"><span class="comment">// 最小超时重传时间。如果 nodelay 为 0，则为 rx_rto 的八分之一，否则为 0。</span></span><br><span class="line">rtomin = (kcp-&gt;nodelay == <span class="number">0</span>)? (kcp-&gt;rx_rto &gt;&gt; <span class="number">3</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flush data segments</span></span><br><span class="line"><span class="keyword">for</span> (p = kcp-&gt;snd_buf.next; p != &amp;kcp-&gt;snd_buf; p = p-&gt;next) &#123;</span><br><span class="line"><span class="comment">// 从 snd_buf 取出一个报文</span></span><br><span class="line">IKCPSEG *segment = iqueue_entry(p, IKCPSEG, node);</span><br><span class="line"><span class="type">int</span> needsend = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 条件1：第一次发送的报文，直接发送</span></span><br><span class="line"><span class="keyword">if</span> (segment-&gt;xmit == <span class="number">0</span>) &#123;   <span class="comment">//  该报文的 xmit 传输次数</span></span><br><span class="line">needsend = <span class="number">1</span>;</span><br><span class="line">segment-&gt;xmit++;</span><br><span class="line">segment-&gt;rto = kcp-&gt;rx_rto;</span><br><span class="line">segment-&gt;resendts = current + segment-&gt;rto + rtomin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_itimediff(current, segment-&gt;resendts) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 条件2：且重传时间到了，则重传</span></span><br><span class="line">needsend = <span class="number">1</span>;</span><br><span class="line">segment-&gt;xmit++;</span><br><span class="line">kcp-&gt;xmit++;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;nodelay == <span class="number">0</span>) &#123;</span><br><span class="line">segment-&gt;rto += _imax_(segment-&gt;rto, (IUINT32)kcp-&gt;rx_rto);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">IINT32 step = (kcp-&gt;nodelay &lt; <span class="number">2</span>)?</span><br><span class="line">((IINT32)(segment-&gt;rto)) : kcp-&gt;rx_rto;</span><br><span class="line">segment-&gt;rto += step / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">segment-&gt;resendts = current + segment-&gt;rto;</span><br><span class="line">lost = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (segment-&gt;fastack &gt;= resent) &#123;</span><br><span class="line"><span class="comment">// 条件3：达到快速重传次数，则重传</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)segment-&gt;xmit &lt;= kcp-&gt;fastlimit ||</span><br><span class="line">kcp-&gt;fastlimit &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">needsend = <span class="number">1</span>;</span><br><span class="line">segment-&gt;xmit++;</span><br><span class="line">segment-&gt;fastack = <span class="number">0</span>;</span><br><span class="line">segment-&gt;resendts = current + segment-&gt;rto;</span><br><span class="line">change++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needsend) &#123;</span><br><span class="line"><span class="type">int</span> need;</span><br><span class="line">segment-&gt;ts = current;</span><br><span class="line">segment-&gt;wnd = seg.wnd;</span><br><span class="line">segment-&gt;una = kcp-&gt;rcv_nxt;</span><br><span class="line"></span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line">need = IKCP_OVERHEAD + segment-&gt;len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size + need &gt; (<span class="type">int</span>)kcp-&gt;mtu) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">ptr = buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ptr = ikcp_encode_seg(ptr, segment);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (segment-&gt;len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(ptr, segment-&gt;data, segment-&gt;len);</span><br><span class="line">ptr += segment-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果某个数据包的重传次数超过阈值，则标记连接断开。</span></span><br><span class="line"><span class="keyword">if</span> (segment-&gt;xmit &gt;= kcp-&gt;dead_link) &#123;</span><br><span class="line">kcp-&gt;state = (IUINT32)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flash remain segments</span></span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update ssthresh</span></span><br><span class="line"><span class="comment">// 1. 如果发生了快速重传，让 ssthresh 减半，进入快恢复</span></span><br><span class="line"><span class="keyword">if</span> (change) &#123;</span><br><span class="line">IUINT32 inflight = kcp-&gt;snd_nxt - kcp-&gt;snd_una;</span><br><span class="line">kcp-&gt;ssthresh = inflight / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;ssthresh &lt; IKCP_THRESH_MIN)</span><br><span class="line">kcp-&gt;ssthresh = IKCP_THRESH_MIN;</span><br><span class="line">kcp-&gt;cwnd = kcp-&gt;ssthresh + resent;</span><br><span class="line">kcp-&gt;incr = kcp-&gt;cwnd * kcp-&gt;mss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果发生了超时重传，则让 ssthresh 减半，然后 cwnd = 1，进入慢启动</span></span><br><span class="line"><span class="keyword">if</span> (lost) &#123;</span><br><span class="line">kcp-&gt;ssthresh = cwnd / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;ssthresh &lt; IKCP_THRESH_MIN)</span><br><span class="line">kcp-&gt;ssthresh = IKCP_THRESH_MIN;</span><br><span class="line">kcp-&gt;cwnd = <span class="number">1</span>;</span><br><span class="line">kcp-&gt;incr = kcp-&gt;mss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兜底，cwnd 至少为 1</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;cwnd &lt; <span class="number">1</span>) &#123;</span><br><span class="line">kcp-&gt;cwnd = <span class="number">1</span>;</span><br><span class="line">kcp-&gt;incr = kcp-&gt;mss;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://github.com/skywind3000/kcp">KCP repo</a></li><li><a href="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP协议的原理和实现</a></li></ul>]]></content>
    
    
    <summary type="html">本文详细介绍了游戏开发中常用的网络协议 KCP 的底层原理和源码实现。通过大量图示和原理总结,帮助读者深入理解 KCP 协议的工作机制，包括其快速重传、选择性确认、流量控制等核心特性。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="KCP" scheme="https://hedon.top/tags/KCP/"/>
    
    <category term="TCP" scheme="https://hedon.top/tags/TCP/"/>
    
    <category term="网络" scheme="https://hedon.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Rust 入门丨01 类型系统概述</title>
    <link href="https://hedon.top/2024/11/28/rust-01-type-system/"/>
    <id>https://hedon.top/2024/11/28/rust-01-type-system/</id>
    <published>2024-11-28T09:52:47.000Z</published>
    <updated>2025-04-05T14:31:32.878Z</updated>
    
    <content type="html"><![CDATA[<p>在 Rust 编程世界中，绝大部分的特性和能力都离不开 Rust强大的类型系统，所以在这个系列的第 1 篇我们先来对 Rust的类型系统做一个全局概述，希望可以帮助你建立起对 Rust的基本印象。在后续的实践过程中，我推荐你可以经常回来思考下为什么 Rust要构建这样的类型系统，在每一个分支点是如何做出决策的，这些决策又体现在代码的哪些地方。相信这样可以帮助你更好地入门Rust。</p><p>废话不多说，进入正文。</p><h1 id="什么是类型系统">什么是类型系统？</h1><p>在进入 Rust类型系统讨论之前，我们先尝试占在更高的角度，即整个编程语言界的角度去思考，<font color="red">什么是类型系统？</font></p><blockquote><p>编程语言的类型系统是指一套规则，用于定义和管理程序中数据的类型。类型系统的主要目的是帮助捕获程序中的错误，提高代码的可靠性和可读性。</p></blockquote><p>类型系统可以根据多种特性进行分类，主要包括以下几个方面：</p><ol type="1"><li><strong>静态类型和动态类型</strong>：<ul><li><strong>静态类型</strong>：在编译时检查变量类型。例如，Java、C++ 和Haskell都是静态类型语言。在这些语言中，变量的类型必须在编译时确定，这样可以在编译阶段捕获许多类型错误。</li><li><strong>动态类型</strong>：在运行时检查变量类型。例如，Python、Ruby和 JavaScript是动态类型语言。在这些语言中，变量的类型是在程序运行时确定的，这提供了更大的灵活性，但也可能导致运行时错误。</li></ul></li><li><strong>强类型和弱类型</strong>：<ul><li><strong>强类型</strong>：严格限制不同类型之间的操作。例如，Python 和Java是强类型语言。强类型系统通常不允许隐式类型转换，这意味着在进行不同类型之间的操作时，必须显式地进行类型转换。</li><li><strong>弱类型</strong>：允许更多隐式类型转换。例如，JavaScript 和Perl是弱类型语言。在这些语言中，编译器或解释器会在需要时自动进行类型转换，这可能导致难以预料的行为。</li></ul></li><li><strong>显式类型和隐式类型</strong>：<ul><li><strong>显式类型</strong>：程序员必须明确声明每个变量的类型。例如，Java和 C++ 要求在声明变量时指定其类型。</li><li><strong>隐式类型</strong>：编译器或解释器会根据上下文自动推断变量的类型。例如，Python和 JavaScript 使用隐式类型，程序员不需要显式声明变量类型。</li></ul></li><li><strong>子类型和多态</strong>：<ul><li><strong>子类型</strong>：一种类型系统允许一种类型作为另一种类型的子集。例如，在面向对象编程中，子类是父类的子类型。</li><li><strong>多态</strong>：允许一个接口被多种不同类型实现。多态性有多种形式，包括参数多态（如泛型）和子类型多态（如继承）。</li></ul></li><li><strong>类型推断</strong>：<ul><li>类型推断是指编译器自动确定表达式的类型，而无需明确的类型注释。例如，Haskell和 Scala 使用类型推断来减少程序员的负担，同时保持静态类型的安全性。</li></ul></li><li><strong>代数数据类型和类型构造</strong>：<ul><li>代数数据类型（ADT）是通过组合其他类型来构造新类型的机制，常见于函数式编程语言，如Haskell 和 OCaml。ADT 包括产品类型（如元组）和和类型（如枚举）。</li></ul></li><li><strong>结构类型和名义类型</strong>：<ul><li><strong>结构类型</strong>：基于对象的结构来确定类型的兼容性。例如，TypeScript和 Go 使用结构类型系统。</li><li><strong>名义类型</strong>：基于名称来确定类型的兼容性。例如，Java 和C++ 使用名义类型系统。</li></ul></li></ol><p>这里我梳理了一张图，供你参考：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241128183852984.png"alt="编程语言类型系统" /><figcaption aria-hidden="true">编程语言类型系统</figcaption></figure><blockquote><p>注：本图参考了陈天老师在 Rust训练营课程上提供的教案并进行了增改。</p></blockquote><h1 id="rust-类型系统">Rust 类型系统</h1><p>Rust为了在提供高性能的同时保证内存安全和线程安全，花了大量力气构建了一个强大的类型系统。</p><p>基于之前提到的七个方面，我们来梳理下 Rust 的类型系统：</p><ol type="1"><li><p><strong>静态类型</strong>：Rust是静态类型语言，这意味着变量的类型在编译时就被确定。这种设计使得 Rust在编译阶段就可以捕获许多类型错误，从而提高代码的安全性和性能。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">10</span>; <span class="comment">// 明确指定类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>强类型</strong>：Rust是强类型语言，它严格限制不同类型之间的操作。Rust不允许隐式类型转换（例如，不能自动将整数转换为浮点数），需要显式地使用as 进行类型转换。这种严格性有助于避免许多常见的编程错误。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f64</span> = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误：不能将 i32 隐式转换为 f64</span></span><br><span class="line">    <span class="comment">// let sum = x + y;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确：需要显式转换</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = x <span class="keyword">as</span> <span class="type">f64</span> + y;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Sum = &#123;&#125;&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>显式类型和类型推断</strong>：虽然 Rust是显式类型语言，要求在某些情况下声明变量类型，但它也具有强大的类型推断能力。编译器可以根据上下文推断出大多数变量的类型，减少了程序员的负担。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5u8</span>);  <span class="comment">// 结合这里，Rust 编译器可以推断出 v 的类型是 Vec&lt;u8&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>子类型和多态</strong>：Rust 支持泛型和trait，这是一种多态性的实现方式。trait类似于接口，允许定义类型可以实现的一组方法。泛型允许定义函数、结构体和枚举时使用占位类型，从而实现代码的重用和灵活性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里 std::fmt::Display 就是一个 trait，目前，你可以先简单理解为 trait 就是接口</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_value</span>&lt;T: std::fmt::Display&gt;(value: T) &#123;  </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_value</span>(<span class="number">42</span>);  <span class="comment">// 42 默认为 i32，标准库为其是实现了 Display trait</span></span><br><span class="line">    <span class="title function_ invoke__">print_value</span>(<span class="string">&quot;Hello, world!&quot;</span>); <span class="comment">// &amp;str 也实现了 Display trait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>类型推断</strong>：Rust的类型推断系统非常强大，能够根据代码上下文自动推断变量和表达式的类型。这使得代码更简洁，同时保持了类型安全性。</p></li><li><p><strong>代数数据类型和类型构造</strong>：Rust支持代数数据类型，通过枚举（enum）和结构体（struct）来实现。枚举允许定义一个类型，该类型可以是几种不同的变体之一，每个变体可以携带不同的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>结构类型和名义类型</strong>：Rust使用名义类型系统。每个类型都有一个显式的名称，类型的兼容性基于名称而不是结构。这意味着即使两个结构体有相同的字段，它们也被视为不同的类型，除非通过特征或显式转换来实现兼容性。</p></li></ol><p>除此之外，Rust的类型系统还提供了其他非常强大且有用的特效，如所有权和借用、生命周期以及模式匹配。</p><ul><li><p><strong>所有权和借用（Ownership and Borrowing）</strong>：</p><ul><li>Rust的类型系统与其所有权模型紧密结合。所有权模型通过所有权、借用和生命周期的概念来管理内存，从而在无垃圾回收器的情况下确保内存安全。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s); <span class="comment">// 借用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>生命周期（Lifetimes）</strong>：</p><ul><li>Rust使用生命周期标注来跟踪引用的有效范围，确保引用在使用时始终有效。这是Rust 类型系统中一个独特的特性，帮助防止悬空引用和数据竞争。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#x27;&#123;&#125;&#x27;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>模式匹配</strong>：</p><ul><li>Rust提供强大的模式匹配功能，尤其是在处理枚举和复杂数据结构时，使得代码更具表达力和安全性。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_message</span>(msg: Message) &#123;</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Quit the application&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125; =&gt; &#123;  <span class="comment">// 模式匹配能根据数据类型直接拆解出来，使用起来非常方便</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Move to coordinates: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">Write</span>(text) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Text message: &#123;&#125;&quot;</span>, text);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change color to RGB(&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;</span>, r, g, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Rust的类型系统通过上述特性实现了高效、安全和灵活的编程模型，适合系统编程和高性能应用。它在编译期捕获许多潜在错误，使得运行时更为安全可靠。</p><p>当然，如果你之前没有学习过Rust，那这些概念和代码对你来说大概率是云里雾里，不要着急，我们先建立起一个大概的印象就行了。这里我针对Rust 类型系统梳理了一张图，你可以在以后的学习中时常回来看看：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241128185615522.png"alt="Rust 类型系统" /><figcaption aria-hidden="true">Rust 类型系统</figcaption></figure><blockquote><p>注：本图参考了陈天老师在 Rust训练营课程上提供的教案并进行了增改。</p></blockquote><p>本篇就到这里，下篇我们将介绍 Rust 的数据类型，enjoy coding~</p>]]></content>
    
    
    <summary type="html">本文从编程语言的角度介绍了类型系统的基本概念，并详细阐述了 Rust 类型系统的特点，包括静态类型、强类型、所有权系统等核心特性。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 入门" scheme="https://hedon.top/categories/Rust/Rust-%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 入门丨02 数据类型</title>
    <link href="https://hedon.top/2024/11/28/rust-02-data-type/"/>
    <id>https://hedon.top/2024/11/28/rust-02-data-type/</id>
    <published>2024-11-28T09:41:08.000Z</published>
    <updated>2025-04-05T14:31:32.878Z</updated>
    
    <content type="html"><![CDATA[<p>上文中，我们简单探讨了 <ahref="https://hedon.top/2024/11/28/rust-01-type-system/">Rust的类型系统</a>，这一篇我们继续来了解 Rust 的数据类型。我画了一张 Rust基础知识图谱，希望可以帮助你更好地定位当前所在的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mindmap</span><br><span class="line">  root((Rust 数据类型))</span><br><span class="line">    数值类型</span><br><span class="line">      整数</span><br><span class="line">        有符号</span><br><span class="line">          i8/i16/i32/i64/i128/isize</span><br><span class="line">        无符号</span><br><span class="line">          u8/u16/u32/u64/u128/usize</span><br><span class="line">      浮点数</span><br><span class="line">        f32</span><br><span class="line">        f64</span><br><span class="line">      布尔型</span><br><span class="line">        bool</span><br><span class="line">      字符型</span><br><span class="line">        char</span><br><span class="line">    复合类型</span><br><span class="line">      元组 Tuple</span><br><span class="line">      数组 Array</span><br><span class="line">      切片 Slice</span><br><span class="line">      字符串</span><br><span class="line">        String</span><br><span class="line">        str</span><br><span class="line">      结构体 Struct</span><br><span class="line">      枚举 Enum</span><br><span class="line">    特殊类型</span><br><span class="line">      单元类型 unit</span><br><span class="line">      Never类型 !</span><br><span class="line">      指针类型</span><br><span class="line">        引用 &amp;T</span><br><span class="line">        原始指针 *const/*mut</span><br><span class="line">        智能指针</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文介绍了 Rust 中的数据类型。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 训练营总结丨第三次入门 Rust</title>
    <link href="https://hedon.top/2024/11/26/rust-bootcamp/"/>
    <id>https://hedon.top/2024/11/26/rust-bootcamp/</id>
    <published>2024-11-26T11:10:08.000Z</published>
    <updated>2025-04-05T14:31:32.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起">缘起</h1><p>2023年我给自己定了很多个目标，最终的结果是每个都做了一些事情，但是没有一个是做得比较彻底的，印证了《孙子兵法》的那句：“无所不备，则无所不寡”。</p><p>在 2023.10.23 出于好奇，我订阅了《Rust语言从入门到实战》的专栏，跟着课程的更新节奏学习完了整个专栏。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Rust%E8%AF%AD%E8%A8%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E7%BB%93%E8%AF%BE%E8%AF%81%E4%B9%A6.png" alt="Rust语言从入门到实战结课证书" style="zoom:33%;" /></p><p>虽然我第一次入门 Rust 失败了，但也被 Rust的种种特性所吸引。我是个特别喜欢“痛苦前置”的人，而 Rust编译器"睚眦必报"的编译器检查正给予了我被虐的爽感，编译通过后程序的稳定运行也符合我追求成为一位“靠谱”工程师的愿景。</p><p>加之我的主力语言是Go，一门应用编程语言，所以我一直希望学习一门系统编程语言，以期将来有能力窥探一些底层的细节原理。C/C++太古老了，特性太多了，大神太多了，我怎么学都不可能赶得上别人，嘿嘿，学个新的，大家都没学过，这不就舒服了么。</p><p>后来极客时间决定开设《Rust 训练营》，讲师是<ahref="https://www.zhihu.com/people/tchen">陈天</a>老师，我去搜了关于陈天老师的一些资料，看了一些他写的文章和技术分享视频，甚至油管上还有他之前面试的视频。OK，这个人得到了我的认可，我想跟这样的人交个朋友，哪怕只是加个微信，至少我多了个口子，得以窥探精英阶层人士的生活一角。</p><p>结合 2023 年的教训，2024年年初我就给自己制定了一年的目标，只有一个，就是<strong>踏踏实实、完完整整学习完整个Rust 训练营，其他所有事情和目标，都要为其让步</strong>。</p><blockquote><p>其实是 2 个目标 hhh，另外一个目标是：完成人生的第一场半程马拉松。</p></blockquote><h1 id="筑基">筑基</h1><p>为了更好服务于《Rust 训练营》，在 1-4 月份，我花了差不多 3个多月的时间啃下了<ahref="https://book.douban.com/subject/36547630/">《Rust程序设计（第二版）》</a>，对整个 Rust的语言特性建立了更加完善的体系基础，也多奠定了一些基础，当然，这是我第二次入门Rust 失败。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241127172804063.png" alt="Rust 程序设计（第二版）阅读计划" style="zoom: 25%;" /></p><h1 id="修炼">修炼</h1><p>4 月 18 号开营，本来是预计 7月份结营的，不过陈天老师分享的欲望刹不住车，硬是“拖堂”到了 11 月 22号。事实上，这是有点难受的，一个事情拖太久，思维上很容易疲惫，懒惰也愈难克服。不过从消费者的角度，这是赚翻了，毕竟，学着学着，花呗的12 期无息分期也差不多要还完了。</p><p>所以，其实一个 1095 的程序员，在 4.20 到 11.22 是可以花 279 小时 54分钟学完 202 讲课程的。</p><blockquote><p>即使你将来不使用Rust，相信你学完这门课程后也能成为一位更好的软件工程师。 —— 陈天</p></blockquote><p>是的，在学习中，更多时候感受到的不仅仅是在学习Rust，而是在重学软件工程，我开始切身接触优秀的软件开发具备了哪些不可或缺的流程。为了效仿这些优秀的思想和实践，在实际工作中，今年我做了一些尝试：</p><ol type="1"><li>引入更丰富的 CI/CD流程，尽可能发挥机器的能力，让机器不厌其烦地做那些的重复劳动，而这些不起眼的重复劳动，却能以最小代码为我们排查出最多难以发现的“失误”BUG。</li><li>开始学习写单测，开始学习如何将代码写得能单测、易单测，学习着如何将那些不能单测的💩代码改造成可单测的代码，也将单测运行加入了CI/CD的流程中。在单测多次帮我揪出那些我意识不到的不小心改错的逻辑的时候，我才切身感受到单测的作用，也真正理解了“写单测并不会影响开发效率，如果影响了，那也是提高了开发效率”。幸运的是，截至目前（11.27），我已经连续2 次，在上千行代码的需求开发中，提测阶段和线上发布阶段，都是 0Bug，运气不错。</li><li>引入监控系统，在指标上，存储层、应用层、业务层和网关层进行分层监控，在开发时，从业务无关组件（<ahref="https://github.com/hedon954/goapm">goapm</a>），到业务相关通用组件，最后再到应用程序特定组件的分阶段分层次开发，开始学习着“先解决业务背后的领域问题，顺带解决业务问题”。</li><li>开始思考一些架构层面的东西，开始思考一些代码组织、接口契约、领域模块划分的问题，以期写出质量更好的代码。</li></ol><p>为了支撑上面这些事情，今年我又顺带读了一些书，我是个很少读书的人，因为我总觉得：“读书好慢”。而且我读书也确实很慢，主要是，很困😅。然而，当我回望来时路，一切却都在我的意料之外。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241127180300408.png"alt="hedon 2024 的书单" /><figcaption aria-hidden="true">hedon 2024 的书单</figcaption></figure><p>这个时候我才知道：</p><ul><li>慢就是快</li><li>少就是多</li></ul><h1 id="历劫">历劫</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241127161520649.png"alt="rust-road" /><figcaption aria-hidden="true">rust-road</figcaption></figure><p>这些书其实都不在我的计划之内，因为 2024 我只有一个目标：<strong>完成Rust训练营的学习</strong>。它们只不过是我完成既定计划之余的加餐罢了。</p><p>而幸好我只有一个目标，所以才能有更多时间和精力去应对跟随训练营学习中的一些困难：</p><ul><li>晚上 9 点下班，真累啊，休息下吧，真不想学了。</li><li>工作了一周，真累啊，周末要不就休息吧，真不想学了。</li><li>编译器报错好多啊，算了，要不直接 copy 现成的代码吧。</li><li>这知识点在讲啥啊，算了，先不懂装懂吧，后面还那么多课，先赶进度再说。</li><li>前端和客户端的知识，好像跟我没啥关系，算了，不听了，过过过。</li><li>单测我就不写了，浪费时间。</li><li>学完咯，感觉没啥好总结的，算了，下一个吧。</li><li>....</li></ul><p>运气不错，上述的 n 多种情况，至少在 50-70% 的时候，我能做到：</p><ul><li>学一下再说，累了再停。</li><li>下午出去玩，早上先学了再说。</li><li>算了，狠点，盲写，自己尝试解决一下，咦，也就那么回事。写完后再对比下，哦，其实这块没听懂。</li><li>弄懂再说，多听几遍课，重新看几遍书，再搜一些相关博客，哦，这个知识点是这个意思，读书百遍其义自见原来是这味？</li><li>算了，试试现在 LLM 是否如吹的那么牛，嗯，好像用 LLM来实现前端和客户端的基础功能还真可以，也没那么无聊嘛。</li><li>算了，先试着写下单测吧。哦，我的代码这么难测啊，哦，这行代码怎么就犯蠢了呢，哦，花不了多少时间嘛。</li><li>要不还是总结下吧，哦，原来这个地方是这个意思，哦，原来还讲到了这个点。</li></ul><p>所以这个时候我又知道了：</p><ul><li>慢就是快</li><li>少就是多</li></ul><h1 id="小成">小成</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">➜  hedon-rust-road ll</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  21 wangjiahan  staff   672B Nov 27 18:26 aicomm</span><br><span class="line">drwxr-xr-x  23 wangjiahan  staff   736B Sep 11 13:55 chat</span><br><span class="line">drwxr-xr-x  17 wangjiahan  staff   544B Sep 11 18:31 chatapp</span><br><span class="line">drwxr-xr-x  26 wangjiahan  staff   832B Nov 27 18:26 crm</span><br><span class="line">drwxr-xr-x  22 wangjiahan  staff   704B Nov 27 18:26 dino</span><br><span class="line">drwxr-xr-x  16 wangjiahan  staff   512B Nov 27 18:29 error-info</span><br><span class="line">drwxr-xr-x  18 wangjiahan  staff   576B Sep  4 19:00 hackernews</span><br><span class="line">drwxr-xr-x  22 wangjiahan  staff   704B Sep 12 15:54 hedon-bot</span><br><span class="line">drwxr-xr-x   9 wangjiahan  staff   288B Nov 27 18:29 httpie</span><br><span class="line">drwxr-xr-x  13 wangjiahan  staff   416B Aug 22 10:40 inverted-index-concurrency</span><br><span class="line">drwxr-xr-x   7 wangjiahan  staff   224B Nov 27 18:28 json-macro</span><br><span class="line">drwxr-xr-x  26 wangjiahan  staff   832B Sep  3 19:30 learn-ffi</span><br><span class="line">drwxr-xr-x   8 wangjiahan  staff   256B Nov 27 18:29 learn-proc-macro</span><br><span class="line">drwxr-xr-x   7 wangjiahan  staff   224B Nov 27 18:30 mandelbrot</span><br><span class="line">drwxr-xr-x  10 wangjiahan  staff   320B Aug 22 10:40 matrix-multi</span><br><span class="line">drwxr-xr-x   7 wangjiahan  staff   224B Nov 27 18:29 pest-parser-collection</span><br><span class="line">drwxr-xr-x  19 wangjiahan  staff   608B Nov 27 18:27 r-redis</span><br><span class="line">drwxr-xr-x  21 wangjiahan  staff   672B Aug 22 10:40 rcli</span><br><span class="line">drwxr-xr-x  17 wangjiahan  staff   544B Aug 22 10:40 simple-chat</span><br><span class="line">drwxr-xr-x  17 wangjiahan  staff   544B Aug 22 10:40 simple-shortener</span><br><span class="line">drwxr-xr-x  21 wangjiahan  staff   672B Aug 22 10:40 taotie</span><br><span class="line">drwxr-xr-x@ 18 wangjiahan  staff   576B Nov 27 15:38 thumbor</span><br><span class="line">drwxr-xr-x  19 wangjiahan  staff   608B Aug 29 10:56 winnow-parser-collection</span><br><span class="line">➜  hedon-rust-road tokei -t rust</span><br><span class="line">===============================================================================</span><br><span class="line"> Language            Files        Lines         Code     Comments       Blanks</span><br><span class="line">===============================================================================</span><br><span class="line"> Rust                  336        25451        21615          644         3192</span><br><span class="line"> |- Markdown            53          546            0          476           70</span><br><span class="line"> (Total)                          25997        21615         1120         3262</span><br><span class="line">===============================================================================</span><br><span class="line"> Total                 336        25451        21615          644         3192</span><br><span class="line">===============================================================================</span><br></pre></td></tr></table></figure><p>看老师画了那么多牛逼的图，要不“邯郸学步”模仿一下吧。故而又忍着“下一个吧”的念头，梳理了下这几个月到底做了些什么。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/8abb5b2a2f3020ca36f75087ae76a53c.PNG"alt="rcli" /><figcaption aria-hidden="true">rcli</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/4ac783c6adaa38a45853861753112e35.PNG"alt="r-redis" /><figcaption aria-hidden="true">r-redis</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/4bdd0cba75aa773c6f4e941cf5c5fe29.PNG"alt="macro-json" /><figcaption aria-hidden="true">macro-json</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/969e023d9003b3c28ea1c95a7c1d9388.PNG"alt="macro-error-info" /><figcaption aria-hidden="true">macro-error-info</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/f25b8a0f1c95ac306ecda6c4ff3954a3.PNG"alt="rust-ecosystem" /><figcaption aria-hidden="true">rust-ecosystem</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/d04da8bf3577f1d09b7fce647451a700.PNG"alt="crm" /><figcaption aria-hidden="true">crm</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/c85939619088cda8c9a763ba514d235e.PNG"alt="taotie" /><figcaption aria-hidden="true">taotie</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/2d3892c57b0742707c6ff3a1267f532a.PNG"alt="dino" /><figcaption aria-hidden="true">dino</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/874082e0f9f9410f342d875f8559bd15.PNG"alt="aicomm" /><figcaption aria-hidden="true">aicomm</figcaption></figure><h1 id="归元">归元</h1><ul><li>知是行之始，行是知之成。</li><li>遇事不决，可问春风。春风不语，既随本心。</li></ul><p>2025 见！</p>]]></content>
    
    
    <summary type="html">本文记录了我在 Rust 训练营的学习历程，也映射了我 2024 年全年的成长轨迹。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="总结" scheme="https://hedon.top/categories/Rust/%E6%80%BB%E7%BB%93/"/>
    
    <category term="2024" scheme="https://hedon.top/categories/Rust/%E6%80%BB%E7%BB%93/2024/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</title>
    <link href="https://hedon.top/2024/11/11/rust-memory-order/"/>
    <id>https://hedon.top/2024/11/11/rust-memory-order/</id>
    <published>2024-11-11T05:06:49.000Z</published>
    <updated>2025-04-05T14:31:32.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="atomic">Atomic</h1><p>在 Rust 的 <code>std::sync::atomic</code>模块中包含了无锁并发编程的原子化类型，与通常的算术运算符和逻辑运算符不同，原子化类型会暴露执行原子化操作的方法，单独的加载、存储、交换和算术运算都会作为一个单元安全地进行，哪怕其他线程也在执行操作同一内存的原子化操作也没问题。</p><p>Rust 提供了以下几种原子化类型：</p><ul><li><code>AtomicIsize</code> 和 <code>AtomicUsize</code> 是与单线程<code>isize</code> 类型和 <code>usize</code>类型对应的共享整数类型。</li><li><code>AtomicI8</code>、<code>AtomicI16</code>、<code>AtomicI32</code>、<code>AtomicI64</code>及其无符号变体（如<code>AtomicU8</code>）是共享整数类型，对应于单线程中的类型<code>i8</code>、<code>i16</code> 等。</li><li><code>AtomicBool</code> 是一个共享的 <code>bool</code> 值。</li><li><code>AtomicPtr</code> 是不安全指针类型 <code>*mut T</code>的共享值。</li></ul><p>这些类型都会以下几类核心功能：</p><ul><li><code>Load</code> 、<code>Store</code>: 存取值</li><li><code>Fetch-and-Modify</code>: 获取并修改</li><li><code>Compare-and-Exchange</code>: 比较并交换</li></ul><p>下面我们对上述提到的几种核心功能进行举例。</p><h2 id="load-store">Load &amp; Store</h2><ul><li><strong>load</strong>:从原子化类型中获取起对应的基本数据类型的值。</li><li><strong>store</strong>:将一个基本数据类型的值存储到其对应的原子化类型中。</li></ul><p>在下面的例子中，我们使用 <code>AtomicUsize::new(0)</code>初始化了一个原子类型，它对应的基本数据类型是 <code>usize</code>。</p><p>我们起了一个子线程，在 for 循环中不断地使用 <code>store</code>函数修改 <code>num_done</code> 的值，然后在主线程中使用<code>load</code> 获取起对应的值，当发现值为 <code>100</code>时，就退出循环，进程结束。</p><p>得益于原子化类型的并发安全特性，所以这里两个线程对<code>num_done</code> 进行并发读写都是安全的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_done</span> = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">main_thread</span> = thread::<span class="title function_ invoke__">current</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line">                num_done.<span class="title function_ invoke__">store</span>(i + <span class="number">1</span>, std::sync::atomic::Ordering::Relaxed);  <span class="comment">// store 存储</span></span><br><span class="line">                main_thread.<span class="title function_ invoke__">unpark</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">n</span> = num_done.<span class="title function_ invoke__">load</span>(std::sync::atomic::Ordering::Relaxed); <span class="comment">// load 获取</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">100</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Working... &#123;n&#125;/100 done&quot;</span>);</span><br><span class="line">            thread::<span class="title function_ invoke__">park_timeout</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里我们暂且忽略 <code>std::sync::atomic::Ordering::Relaxed</code>这个参数的含义，在后续的「内存顺序」章节会进行详细阐述。</p></blockquote><h2 id="fetch-and-modify">Fetch-and-Modify</h2><p><strong>Fetch-and-Modify</strong>操作用于在获取当前值的同时对其进行修改。这类操作包括<code>fetch_add</code>、<code>fetch_sub</code>、<code>fetch_and</code>、<code>fetch_or</code>、<code>fetch_xor</code>等。</p><p>我们将上面的例子修改一下，不再是直接 <code>store</code>一个值，而是不断进行加 1 操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_done</span> = &amp;AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;</span><br><span class="line">                num_done.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, std::sync::atomic::Ordering::Relaxed); <span class="comment">// 使用 fetch_add 进行加 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">n</span> = num_done.<span class="title function_ invoke__">load</span>(std::sync::atomic::Ordering::Relaxed);</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">100</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Working... &#123;n&#125;/100 done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="compare-and-exchange">Compare-and-Exchange</h2><p><strong>Compare-and-Exchange</strong>是一种条件更新操作，只有在当前值等于预期值时才会更新。</p><p>下面的例子中我们实现了一个函数<code>allocate_new_id</code>，它支持在并发环境下分配新的<code>id</code>，这里我们使用了 <code>compare_exchange(id, id+1)</code>进行条件更新，只有当 <code>id</code>没有发生变化的时候，才运行对其进行加1，这就保证了在并发下，只有一个线程可以成功执行该语句，从而保证<code>id</code> 的递增性和唯一性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">allocate_new_id</span>() <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> NEXT_ID: AtomicU32 = AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">id</span> = NEXT_ID.<span class="title function_ invoke__">load</span>(std::sync::atomic::Ordering::Relaxed);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(id &lt; <span class="number">1000</span>, <span class="string">&quot;Too many IDs!&quot;</span>);</span><br><span class="line">        <span class="keyword">match</span> NEXT_ID.<span class="title function_ invoke__">compare_exchange</span>(  <span class="comment">// 只有 id 没有发生变化，才允许进行加 1</span></span><br><span class="line">            id,</span><br><span class="line">            id + <span class="number">1</span>,</span><br><span class="line">            std::sync::atomic::Ordering::Relaxed,</span><br><span class="line">            std::sync::atomic::Ordering::Relaxed,</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="keyword">return</span> id,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(v) =&gt; id = v,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details class="tag-plugin colorful folding" color="blue" open><summary><p>在 Rust中，原子化类型还提供了另外一个函数：<code>compare_exchange_weak</code>，它与<code>compare_exchange</code>的主要区别在于它们在<strong>失败时</strong>的行为：</p></summary><div class="body"><p><strong>compare_exchange</strong>:</p><ul><li>只会在实际值不等于期望值时失败。</li><li>提供更强的保证，但可能性能较低。</li><li>适用于不在循环中的单次比较交换操作。</li></ul><p><strong>compare_exchange_weak</strong>:</p><ul><li>即使实际值等于期望值时也可能失败（称为“虚假失败”或“spuriousfailure”）。</li><li>性能可能更好，因为允许在某些架构上生成更高效的代码。</li><li>最适合在循环中使用，因为需要处理可能的虚假失败。</li></ul><p>在实际应用中:</p><ul><li>如果操作在循环中,使用 <code>compare_exchange_weak</code>通常更好。</li><li>如果是单次操作,使用 <code>compare_exchange</code> 更合适。</li><li>在某些平台上，这两个操作可能没有性能差异,但<code>compare_exchange_weak</code> 的行为仍然可能不同。</li></ul><p>这种区别的存在是因为在某些 CPU架构上,允许虚假失败可以生成更高效的机器码。比如在 ARM架构上，<code>compare_exchange_weak</code> 可以直接映射到单个LL/SC（Load-Link/Store-Conditional）指令。</p></div></details><h2 id="硬件原理">硬件原理</h2><p>在一些处理器架构中，当一个 CPU执行需要原子性的操作时，它可以通过锁定内存总线来确保在操作完成之前，其他CPU 无法访问相关的内存地址。</p><p>基本工作流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CPU 发出 LOCK 信号</span><br><span class="line">   └── 激活处理器的 LOCK# 引脚</span><br><span class="line">      └── 获得总线的独占访问权</span><br><span class="line">          └── 执行原子操作</span><br><span class="line">              └── 释放 LOCK 信号</span><br><span class="line">                  └── 其他处理器可以访问内存</span><br></pre></td></tr></table></figure><p>主流的有 2 种锁定机制：</p><ul><li><p><strong>总线锁定（BusLocking）</strong>：总线锁定是一种机制，它通过锁定内存总线来确保在执行原子操作时，其他处理器无法访问内存。这种方法虽然简单，但会导致总线的其他操作被阻塞，从而影响系统性能。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line"><span class="bullet">-</span> 绝对的原子性保证</span><br><span class="line"><span class="bullet">-</span> 适用于所有内存位置</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"><span class="bullet">-</span> 性能开销大</span><br><span class="line"><span class="bullet">-</span> 会阻塞其他 CPU 对内存的访问</span><br></pre></td></tr></table></figure></li><li><p><strong>缓存锁定（CacheLocking）</strong>：现代处理器通常使用缓存锁定来实现原子操作。缓存锁定通过锁定处理器的缓存行来实现，而不是锁定整个总线。这种方法可以减少对总线的影响，提高系统的并发性能。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line"><span class="bullet">-</span> 性能更好</span><br><span class="line"><span class="bullet">-</span> 不会完全阻塞内存访问</span><br><span class="line"></span><br><span class="line">条件：</span><br><span class="line"><span class="bullet">-</span> 数据必须在缓存行中</span><br><span class="line"><span class="bullet">-</span> 缓存行必须是独占状态</span><br></pre></td></tr></table></figure></li></ul><p>缓存锁定通常依赖于缓存一致性协议（如 <strong>MESI</strong>协议）来确保在多个处理器之间的数据一致性。通过这些协议，处理器可以在本地缓存中执行原子操作，并在必要时与其他处理器同步。</p><p><strong>MESI</strong> 协议即：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">M (Modified)：已修改</span><br><span class="line">E (Exclusive)：独占</span><br><span class="line">S (Shared)：共享</span><br><span class="line">I (Invalid)：无效</span><br><span class="line"></span><br><span class="line">操作流程：</span><br><span class="line"><span class="bullet">1.</span> 检查数据是否在缓存中</span><br><span class="line"><span class="bullet">2.</span> 如果在，将状态改为 Exclusive</span><br><span class="line"><span class="bullet">3.</span> 执行原子操作</span><br><span class="line"><span class="bullet">4.</span> 通知其他 CPU 使其缓存失效</span><br></pre></td></tr></table></figure><p>不同的架构有不同的锁定方式：</p><ul><li>x86/x64：使用 LOCK 前缀</li><li>ARM：使用 exclusive load/store 指令</li><li>PowerPC：使用 load-linked/store-conditional</li></ul><p>以下是 x86 汇编的一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; 原子加法操作</span><br><span class="line">lock add dword ptr [memory], 1</span><br><span class="line"></span><br><span class="line">; 比较并交换</span><br><span class="line">lock cmpxchg dword ptr [memory], eax</span><br></pre></td></tr></table></figure><p>为了充分利用<strong>缓存锁定</strong>的优势，我们在编写代码时，可以有以下的性能考虑：</p><ul><li><p><strong>缓存行对齐，避免伪共享</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicI32, Ordering&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Rust 中，可以使用 #[repr(align(N))] 属性来确保结构体或变量的对齐方式，以避免伪共享。</span></span><br><span class="line"><span class="comment">// 伪共享是指多个线程访问不同的变量，但这些变量共享同一个缓存行，从而导致不必要的缓存一致性流量。</span></span><br><span class="line"><span class="meta">#[repr(align(64))]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AlignedCounter</span> &#123;</span><br><span class="line">    counter: AtomicI32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = AlignedCounter &#123;</span><br><span class="line">        counter: AtomicI32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 counter.counter.fetch_add(...) 进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>避免频繁的总线锁定</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicI32, Ordering&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = AtomicI32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不好的做法：频繁的原子操作</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">1000</span> &#123;</span><br><span class="line">        counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::SeqCst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更好的做法：本地累加后一次性更新</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">local_sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">1000</span> &#123;</span><br><span class="line">        local_sum += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    counter.<span class="title function_ invoke__">fetch_add</span>(local_sum, Ordering::SeqCst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="rust-实战查看汇编">Rust 实战查看汇编</h3><blockquote><p>笔者使用的是 ARM64 架构的 macbook。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicI64, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ATOMIC: AtomicI64 = AtomicI64::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t1</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        ATOMIC.<span class="title function_ invoke__">store</span>(<span class="number">10086</span>, Ordering::Release);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t2</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = ATOMIC.<span class="title function_ invoke__">load</span>(Ordering::Acquire);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;val&#125;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    t2.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>rustc</code> 编译并输出汇编代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc -O --emit asm src/main.rs</span><br></pre></td></tr></table></figure><p>代码中我特地设置了 <code>10086</code>这个特殊的值，这是为了可以在输出的 <code>main.s</code> 文件中快速找到<code>store</code> 对应的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__ZN3std3sys9backtrace28__rust_begin_short_backtrace17h750d7a3a9c81fc67E:</span><br><span class="line">.cfi_startproc</span><br><span class="line">Lloh8:</span><br><span class="line">adrpx8, __ZN4main6ATOMIC17hd0b0dbf92e477148E.0@PAGE</span><br><span class="line">Lloh9:</span><br><span class="line">addx8, x8, __ZN4main6ATOMIC17hd0b0dbf92e477148E.0@PAGEOFF</span><br><span class="line">movw9, #10086 ; 将值 10086 移入寄存器</span><br><span class="line">stlrx9, [x8] ; Store-Release 指令，原子地存储值</span><br><span class="line">; InlineAsm Start</span><br><span class="line">; InlineAsm End</span><br><span class="line">ret</span><br><span class="line">.loh AdrpAddLloh8, Lloh9</span><br><span class="line">.cfi_endproc</span><br></pre></td></tr></table></figure><p>在这个代码中，<code>stlr</code> 就是 <code>Store Release</code>的意思，另外一个关键字是 <code>ladpr</code>，表示<code>Load Acquire</code> 的意思，通过这个关键字，你可以找到<code>load</code> 对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lloh11:</span><br><span class="line">addx8, x8, __ZN4main6ATOMIC17hd0b0dbf92e477148E.0@PAGEOFF</span><br><span class="line">ldaprx8, [x8] ; ; Load-Acquire 指令，原子地加载值</span><br><span class="line">strx8, [sp, #8]</span><br></pre></td></tr></table></figure><h3 id="go-实战查看汇编">Go 实战查看汇编</h3><blockquote><p>笔者使用的是 ARM64 架构的 macbook。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := atomic.Int64&#123;&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">data.Store(<span class="number">10086</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := data.Load()</span><br><span class="line"><span class="built_in">println</span>(a)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下命令，可以输出优化后的汇编代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags=-S -ldflags=-w main.go 2&gt; assembly.txt</span><br></pre></td></tr></table></figure><p>查看输出的文件，我们同样搜索 <code>10086</code>，可以快速找到<code>store</code> 的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0008 00008 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:109)MOVD$10086, R1</span><br><span class="line">0x000c 00012 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:109)STLRR1, (R0)</span><br></pre></td></tr></table></figure><p>可以看到，这里同样也是使用了 <code>STLR</code> 指令。接着我们看第 14行代码的位置对应的汇编：可以发现这里使用的 <code>LDAR</code>指令，也就是 <code>Load Acuqire</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x001c 00028 (/Users/wangjiahan/goStudy/go-atomic/main.go:14)HINT$0</span><br><span class="line">0x0020 00032 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:106)LDAR(R0), R0</span><br><span class="line">0x0024 00036 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:106)MOVDR0, main..autotmp_6-8(SP)</span><br></pre></td></tr></table></figure><h1 id="内存顺序">内存顺序</h1><p>在了解了 Rust Atomic的基本用法和基本原理之后，我们回过头来谈一谈原子操作参数中的<code>std::sync::atomic::Ordering::Relaxed</code>，这个就是本篇的主题：<strong>内存顺序</strong>。内存顺序要解决的核心问题是<u>如何合理地限制单一线程中的代码执行顺序，使得在不使用锁的情况下，既能最大化利用CPU 的计算能力，又能保证多线程环境下不会出现逻辑错误。</u></p><h2 id="指令乱序">指令乱序</h2><p>CPU和编译器都会在保证程序运行结果不发生改变的前提下，尽一切可能让我们的程序运行得尽可能快。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(a: &amp;<span class="keyword">mut</span> <span class="type">i32</span>, b: &amp;<span class="keyword">mut</span> <span class="type">i32</span>) &#123;</span><br><span class="line">  *a += <span class="number">1</span>;</span><br><span class="line">  *b += <span class="number">1</span>;</span><br><span class="line">  *a += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上述代码，编译器完全可以优化成下面的代码，从而提高程序的运行效率：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>(a: &amp;<span class="keyword">mut</span> <span class="type">i32</span>, b: &amp;<span class="keyword">mut</span> <span class="type">i32</span>) &#123;</span><br><span class="line">  *a += <span class="number">2</span>;</span><br><span class="line">  *b += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个过程中，就可能会出现<strong>指令重排</strong>，甚至是<strong>代码重写</strong>，不过这带来了指令乱序的问题，即<u>程序的实际执行顺序跟我们的代码顺序是不一致的</u>。</p><p>不过，编译器保证的是<strong>在单线程环境下，执行的结果最终一致</strong>，所以，指令乱序在单线程环境下完全是允许的。对于编译器来说，它只知道：在当前线程中，数据的读写以及数据之间的依赖关系。但是，<strong>编译器并不知道哪些数据是在线程间共享，而且是有可能会被修改的</strong>。而这些是需要开发人员去保证的。</p><h2 id="内存模型">内存模型</h2><p>为了解决指令乱序带来的并发问题，Rust 采用了内存模型（MemoryModel）这一概念。这个概念主要借鉴自 C++11中引入的内存模型，它定义了在多线程环境下内存访问的行为规范。</p><p>内存模型的核心目标是在以下三方面之间取得平衡：</p><ol type="1"><li><strong>正确性保证</strong>：确保多线程程序的行为是可预测和一致的。</li><li><strong>性能优化</strong>：允许编译器和 CPU在不违反正确性的前提下进行优化。</li><li><strong>跨平台兼容</strong>：提供一个统一的抽象层，使代码可以在不同的硬件架构上正确运行。</li></ol><p>具体来说，内存模型：</p><ul><li>为开发者提供了清晰的规则，说明在多线程环境下，什么样的内存访问行为是合法的，什么样的行为会导致未定义行为。</li><li>为编译器开发者提供了明确的标准，指导他们在不同平台上实现必要的内存同步原语。</li><li>通过定义不同的内存顺序级别（如 Relaxed、Release/Acquire、SeqCst等），让开发者可以根据需要选择合适的同步强度。</li></ul><p>这种抽象让开发者可以专注于并发逻辑本身，而不必过分关注底层硬件的具体实现细节。</p><h2 id="sequenced-before">Sequenced-Before</h2><p>在讨论内存顺序之前，我们需要先对 2 个重要关系术语进行简单阐述，分别是<code>Sequenced-Before</code> 和 <code>Happens-Before</code>。</p><p><strong>Sequenced-Before</strong>描述的是<strong>单个线程内</strong>的操作顺序。它基于程序的源代码顺序，表示在同一线程中，一个操作在程序中出现在另一个操作之前。</p><p>具体来说，如果操作 A sequenced-before 操作 B，那么：</p><ol type="1"><li><p><strong>数据依赖关系</strong>：如果 B 依赖于 A 的结果，那么 A一定会在 B 之前执行。例如： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;      <span class="comment">// 操作 A</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x + <span class="number">1</span>;  <span class="comment">// 操作 B - 依赖于 A 的结果</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>原子操作的顺序</strong>：对同一个原子变量的操作会保持程序顺序。例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X.<span class="title function_ invoke__">fetch_add</span>(<span class="number">5</span>, Relaxed);    <span class="comment">// 一定先执行</span></span><br><span class="line">X.<span class="title function_ invoke__">fetch_add</span>(<span class="number">10</span>, Relaxed);   <span class="comment">// 一定后执行</span></span><br></pre></td></tr></table></figure></p></li><li><p><strong>独立操作的可重排性</strong>：如果两个操作之间没有数据依赖关系，且操作的是不同的变量，那么它们可能会被重排序。例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X.<span class="title function_ invoke__">store</span>(<span class="number">1</span>, Relaxed);  <span class="comment">// 这两个操作可能会被重排序</span></span><br><span class="line">Y.<span class="title function_ invoke__">store</span>(<span class="number">2</span>, Relaxed);  <span class="comment">// 因为它们操作的是不同的变量</span></span><br></pre></td></tr></table></figure></p></li></ol><h2 id="happens-before">Happens-Before</h2><p><strong>Happens-Before</strong>则描述了<strong>跨线程</strong>的操作顺序。它定义了不同线程中的操作之间的可见性和顺序关系。如果操作A Happens-Before 操作 B，那么 A 的内存写入对 B 是可见的。</p><p>典型的 Happens-Before 有：</p><ol type="1"><li>同一线程内，如果先调用 <code>f()</code>，再调佣 <code>g()</code>，则<code>f()</code> happens-before <code>g()</code>，其实这就是<code>sequenced-before</code>。</li><li><code>spawing</code> happens-before <code>joining</code>。</li><li><code>lock</code> happens-before <code>unlock</code>。</li></ol><p>举个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> X: AtomicI32 = AtomicI32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    X.<span class="title function_ invoke__">store</span>(<span class="number">1</span>, Relaxed);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = thread::<span class="title function_ invoke__">spawn</span>(f);</span><br><span class="line">    X.<span class="title function_ invoke__">store</span>(<span class="number">2</span>, Relaxed);</span><br><span class="line">    t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    X.<span class="title function_ invoke__">store</span>(<span class="number">3</span>, Relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = X.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">    <span class="built_in">assert!</span>(x == <span class="number">1</span> || x == <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子的执行顺序如下图所示，因为 <code>spawn</code>happens-before<code>join</code>，所以我们可以确定的执行顺序是：<strong>“store 1 toX”→“store 2 to X”→“store 3 to X”</strong>。而 <strong>load fromX</strong> 介于 spawn 和 join之间，且没有进行任何其他的内存顺序限制，所以它和 <strong>store 2 toX</strong> 之间的顺序是不确定的，但是可以肯定的是，它一定在<strong>store 3 to X</strong> 之前，所以<code>assert!(x == 1 || x == 2);</code> 是永远成立的。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241111160041436.png" alt="spawn-happens-before-join" style="zoom:33%;" /></p><p>到这里，相信不少读者已经能够理解为什么需要内存顺序这个东西了，核心问题就是在于<strong>store 2 to X</strong> 和 <strong>load from X</strong>的执行顺序是否会影响我们的业务逻辑，如果不会，那么我们可以指定最松散的内存顺序要求，如果会，那么我们就要利用指定合适的内存顺序来使得其按照我们的预期顺序进行执行，从而保证业务逻的正确。</p><h2 id="rust-内存顺序">Rust 内存顺序</h2><p>Rust 支持五种内存顺序（Ordering），从最松散到最严格依次为：</p><table><colgroup><col style="width: 24%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 27%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th>内存顺序</th><th>说明</th><th>保证</th><th>适用场景</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>Relaxed</td><td>最宽松的内存顺序</td><td>- 仅保证操作的原子性<br>- 不提供任何同步保证<br>- 不建立happens-before 关系</td><td>- 简单计数器<br>- 性能要求极高且确定不需要同步<br>-已通过其他方式确保同步</td><td><code>counter.fetch_add(1, Ordering::Relaxed)</code></td></tr><tr class="even"><td>Release</td><td>用于存储操作</td><td>- 之前的内存访问不会被重排到此操作之后<br>- 与 Acquire配对使用可建立 happens-before 关系</td><td>- 生产者-消费者模式<br>- 发布共享数据<br>- 初始化完成标志</td><td><code>data.store(42, Ordering::Release)</code></td></tr><tr class="odd"><td>Acquire</td><td>用于加载操作</td><td>- 之后的内存访问不会被重排到此操作之前<br>- 与 Release配对使用可建立 happens-before 关系</td><td>- 生产者-消费者模式<br>- 获取共享数据<br>- 检查初始化标志</td><td><code>data.load(Ordering::Acquire)</code></td></tr><tr class="even"><td>AcqRel</td><td>同时包含 Acquire 和 Release 语义</td><td>- 结合了 Acquire 和 Release 的所有保证<br>- 用于读改写操作</td><td>- 需要双向同步的原子操作<br>- 锁的实现<br>- 复杂的同步原语</td><td><code>value.fetch_add(1, Ordering::AcqRel)</code></td></tr><tr class="odd"><td>SeqCst</td><td>最严格的内存顺序</td><td>- 包含 AcqRel 的所有保证<br>- 所有线程看到的所有 SeqCst操作顺序一致<br>- 提供全局的顺序一致性</td><td>- 需要严格的全局顺序<br>- 不确定使用哪种顺序时<br>-对性能要求不高的场景</td><td><code>flag.store(true, Ordering::SeqCst)</code></td></tr></tbody></table><p>在 C++ 中，其实还有另外一种内存顺序 <code>Consume</code>，它是<code>Acquire</code> 的一个更弱的版本：</p><ul><li><p><strong>Acquire</strong>:保证后续的所有读写操作不会重排到这个操作前面</p></li><li><p><strong>Consume</strong>:只保证后续与这个操作结果相关的读写操作不会重排到这个操作前面</p></li></ul><p>理论上，Consume 在某些架构上可以提供比 Acquire更好的性能，因为它只需要对数据依赖的操作进行同步。</p><p>然而，由于以下原因，Rust 选择不支持 Consume 顺序：</p><ol type="1"><li><strong>实现复杂性</strong>：很多编译器实现者发现正确实现 Consume语义非常困难。</li><li><strong>性能收益不确定</strong>：在实践中，大多数编译器都将 Consume视为 Acquire 来处理。</li><li><strong>标准困惑</strong>：C++ 标准委员会也承认当前的 Consume语义定义存在问题，正在考虑重新设计。</li></ol><details class="tag-plugin colorful folding" color="blue" open><summary><p>选择建议：</p></summary><div class="body"><ol type="1"><li><strong>不确定选择哪种顺序时</strong>：<ul><li>使用 SeqCst（最安全但性能最低）</li><li>或咨询有经验的开发者</li></ul></li><li><strong>性能优化时</strong>：<ul><li>先使用 SeqCst 开发</li><li>在性能测试后，根据需要降低到 Release/Acquire</li><li>只有在确实需要时才使用 Relaxed</li></ul></li><li><strong>常见组合</strong>：<ul><li>Release 写 + Acquire 读：最常见的生产者-消费者模式</li><li>AcqRel：用于原子的读改写操作</li><li>Relaxed：用于简单的计数器场景</li></ul></li></ol></div></details><p>下面我们来对每种内存顺序进行举例阐述。</p><h3 id="relaxed">Relaxed</h3><p><code>Relaxed</code>是最宽松的内存顺序，它只保证了原子操作在并发下的安全性，但不保证执行顺序。</p><p>考虑如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> X: AtomicI32 = AtomicI32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">a</span>() &#123;</span><br><span class="line">    X.<span class="title function_ invoke__">fetch_add</span>(<span class="number">5</span>, Relaxed);</span><br><span class="line">    X.<span class="title function_ invoke__">fetch_add</span>(<span class="number">10</span>, Relaxed); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">b</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = X.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = X.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = X.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = X.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;a&#125; &#123;b&#125; &#123;c&#125; &#123;d&#125;&quot;</span>);  <span class="comment">// 这个输出不一定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(a);</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(b);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, X.<span class="title function_ invoke__">load</span>(Relaxed)); <span class="comment">// 最终结果一定是 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于我们上面提到的 <code>sequenced-before</code> 规则，我们可以确定<code>a</code> 和 <code>b</code> 两个线程内的<code>happens-before</code> 规则，但是二者之间的<code>happens-before</code> 是无法确定的，但是我们可以确定最后的结果是<code>15</code>。下图展示了上述代码的执行顺序示意图：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241111164259913.png" alt="relaxed-ordering" style="zoom:50%;" /></p><p>虽然两个线程之间的 <code>happens-before</code>是无法确定的，但是我们可以确定 <code>X</code>的变化顺序：0→5→15。所以线程 <code>b</code> 输出<code>0 0 0 0</code>、<code>0 0 5 15</code> 和 <code>0 15 15 15</code>都是可能的，而永远不可能输出 <code>0 5 0 15</code> 或<code>0 0 10 15</code> 类似的结果。</p><p>但是如果是这样子的话，就不一定了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> X: AtomicI32 = AtomicI32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">a1</span>() &#123;</span><br><span class="line">    X.<span class="title function_ invoke__">fetch_add</span>(<span class="number">5</span>, Relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">a2</span>() &#123;</span><br><span class="line">    X.<span class="title function_ invoke__">fetch_add</span>(<span class="number">10</span>, Relaxed); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">b</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = X.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = X.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = X.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = X.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;a&#125; &#123;b&#125; &#123;c&#125; &#123;d&#125;&quot;</span>);  <span class="comment">// 这个输出不一定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(a1);</span><br><span class="line">      s.<span class="title function_ invoke__">apawn</span>(a2);</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(b);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, X.<span class="title function_ invoke__">load</span>(Relaxed)); <span class="comment">// 最终结果一定是 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子，<code>X</code> 的变化顺序可以是 0→5→15，也可以是0→10→15，这取决于哪个 <code>fetch_add</code> 先被执行。</p><p>再举个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> DATA: AtomicI32 = AtomicI32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">static</span> READY: AtomicBool = AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        <span class="comment">// 线程 A - 写入者</span></span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            DATA.<span class="title function_ invoke__">store</span>(<span class="number">123</span>, Ordering::Relaxed);     <span class="comment">// ① 准备数据</span></span><br><span class="line">            READY.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Relaxed);   <span class="comment">// ② 发出数据就绪信号</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程 B - 读取者</span></span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="keyword">while</span> !READY.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) &#123;  <span class="comment">// ③ 等待数据就绪信号</span></span><br><span class="line">                thread::<span class="title function_ invoke__">yield_now</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert_eq!</span>(DATA.<span class="title function_ invoke__">load</span>(Ordering::Relaxed), <span class="number">123</span>); <span class="comment">// ④ 获取数据，这里断言一定成功吗？</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子中，线程 A 执行了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DATA.<span class="title function_ invoke__">store</span>(<span class="number">123</span>, Ordering::Relaxed);     <span class="comment">// 准备数据</span></span><br><span class="line">READY.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Relaxed);   <span class="comment">// 发出数据就绪信号</span></span><br></pre></td></tr></table></figure><p>这是 2 个没有依赖关系的原子操作，且使用的是 <code>Relaxed</code>内存顺序，所以对于线程 B 来说，这 2个操作的顺序是不确定的。所以是很可能在<code>READY.load(Ordering::Relaxed)</code> 返回 <code>true</code>的时候，<code>DATA.load(Ordering::Relaxed)</code> 依旧还是<code>0</code>。</p><p>那如何确保这个断言一定成功呢？那就需要“升级”一下了~ 这个时候就轮到<code>Release</code> 和 <code>Acquire</code> 的出场了。</p><h3 id="release-acquire">Release &amp; Acquire</h3><p><code>Release</code> 和 <code>Acquire</code>一般成对出现，它们共同建立了线程间的同步关系：</p><ul><li><code>Release</code>:作用于写操作（store），确保该操作之前的所有内存访问不会被重排到这个Release 操作之后。</li><li><code>Acquire</code>:作用于读操作（load），确保该操作之后的所有内存访问不会被重排到这个Acquire 操作之前。</li></ul><p>当一个线程通过 <code>Acquire</code> 读取到另一个线程通过<code>Release</code> 写入的值时，会建立一个 happens-before关系：<strong><font color="orange">线程 A 中 Release写入之前的所有内存写操作，对于线程 B 中 Acquire读取之后的所有内存读操作都是可见的</font></strong>。</p><p>修改一下上面的例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> DATA: AtomicI32 = AtomicI32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">static</span> READY: AtomicBool = AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            DATA.<span class="title function_ invoke__">store</span>(<span class="number">123</span>, Ordering::Relaxed);   </span><br><span class="line">            READY.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release);   <span class="comment">// 这里改为 release</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="keyword">while</span> !READY.<span class="title function_ invoke__">load</span>(Ordering::Acquire) &#123;  <span class="comment">// 这里改为 acquire</span></span><br><span class="line">                thread::<span class="title function_ invoke__">yield_now</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert_eq!</span>(DATA.<span class="title function_ invoke__">load</span>(Ordering::Relaxed), <span class="number">123</span>); <span class="comment">// 必定成功</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241111165714772.png" alt="release-acquire-ordering" style="zoom:50%;" /></p><p>如上图所示，在这个例子中：</p><ol type="1"><li>Release-Acquire 同步确保了 <code>READY</code> 的写入和读取之间建立了happens-before 关系</li><li>由于 <code>DATA</code> 的写入在 <code>READY</code> 的 Release写入之前，而 <code>DATA</code> 的读取在 <code>READY</code> 的 Acquire读取之后</li><li>因此可以保证线程 B 一定能看到线程 A 写入的值 123</li></ol><p>更进一步，我们通过观察，可以发现 <code>DATA</code> 都没必要使用<code>Atomic</code> 类型，因为由 <code>READY</code> 建议的<code>happens-before</code> 规则已经能保证对 <code>DATA</code>的读写不可能并发执行了。不过因为 Rust的类型系统并不允许跨线程进行非原子类型的读写操作，所以这里我们需要使用<code>unsafe</code>才能使编译通过，但通过我们之前的分析，我们可以确保下面这段代码是安全的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> DATA: <span class="type">u64</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> READY: AtomicBool = AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="comment">// Safety: 此时没有其他线程访问 DATA，</span></span><br><span class="line">        <span class="comment">// 因为我们还没有设置 READY 标志</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; DATA = <span class="number">123</span> &#125;;</span><br><span class="line">        READY.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Release); <span class="comment">// 在这个存储操作之前的所有内存操作 ..</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">while</span> !READY.<span class="title function_ invoke__">load</span>(Acquire) &#123; <span class="comment">// .. 在这个加载操作返回 true 后都是可见的</span></span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Safety: 没有线程会修改 DATA，因为 READY 已经被设置</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">unsafe</span> &#123; DATA &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details class="tag-plugin colorful folding" color="blue" open><summary><p>释放序列（Release Sequence）</p></summary><div class="body"><p>我们再来看一段代码示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;sync::atomic::AtomicU8, thread&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> DATA: <span class="type">Vec</span>&lt;<span class="type">i64</span>&gt; = <span class="built_in">vec!</span>[];</span><br><span class="line"><span class="keyword">static</span> FLAG: AtomicU8 = AtomicU8::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">thread_1</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        DATA.<span class="title function_ invoke__">push</span>(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FLAG.<span class="title function_ invoke__">store</span>(<span class="number">1</span>, std::sync::atomic::Ordering::Release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">thread_2</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">expected</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// memory_order_relaxed is okay because this is an RMW,</span></span><br><span class="line">    <span class="comment">// and RMWs (with any ordering) following a release form a release sequence</span></span><br><span class="line">    <span class="keyword">while</span> FLAG</span><br><span class="line">        .<span class="title function_ invoke__">compare_exchange</span>(</span><br><span class="line">            expected,</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            std::sync::atomic::Ordering::Relaxed,</span><br><span class="line">            std::sync::atomic::Ordering::Relaxed,</span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">is_err</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        expected = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">thread_3</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> FLAG.<span class="title function_ invoke__">load</span>(std::sync::atomic::Ordering::Acquire) &lt; <span class="number">2</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// if we read the value 2 from the atomic flag, we see 42 in the vector</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(DATA[<span class="number">0</span>], <span class="number">42</span>); <span class="comment">// will never fire</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(thread_1);</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(thread_2);</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(thread_3);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是参考 <ahref="https://en.cppreference.com/w/cpp/atomic/memory_order">cppreference</a>而翻译成 Rust 代码的，在上述代码中，即使 <code>thread_2</code>中我们使用的是 <code>Relaxed</code>， 这段代码中的<code>assert_eq!(DATA[0], 42)</code>也是一定成功的。为什么呢？这涉及到一个重要的概念——<strong>释放序列（ReleaseSequence）</strong>：</p><ul><li>当一个 <code>release</code>操作后面跟着一系列的原子<code>"读-修改-写"(RMW)</code>操作时，这些操作会形成一个释放序列。</li><li>在这个序列中，后续的 RMW 操作<strong>不需要</strong>使用 release 或acquire 语义也能保证同步。</li></ul><p>在这段代码中：当 <code>thread_2</code> 的 <code>RMW</code>操作成功的时候，说明 <code>FLAG</code> 是 <code>1</code>，即<code>thread_1</code> 已经执行了 <code>release</code>操作，这个时候：</p><ol type="1"><li><code>thread_1</code> 的 <code>release</code> 操作建立了同步点</li><li><code>thread_2</code> 的 <code>RMW</code>操作自动成为释放序列的一部分</li><li>当 <code>thread_3</code> 通过 <code>acquire</code> 看到值 2时，它能看到整个释放序列的所有修改。</li><li>因此能保证看到 <code>DATA</code> 中的 42。</li></ol><p>所以在这种场景下使用 <code>relaxed</code> 既安全又高效，因为：</p><ul><li>它是释放序列的一部分</li><li>不需要额外的同步开销</li><li>仍然能保证正确的内存顺序</li></ul><p>为什么这样设计呢？</p><ul><li><strong>原子性保证</strong>：RMW操作本身就是原子的，不会产生数据竞争</li><li><strong>连续性</strong>：每个 RMW操作都直接或间接地基于前一个操作的结果</li><li><strong>因果关系</strong>：形成了一个清晰的修改链条</li><li><strong>性能考虑</strong>：中间的 RMW 操作不需要额外的同步开销</li></ul></div></details><h3 id="sequentially-consistent">Sequentially Consistent</h3><p><code>SeqCst</code> 是最严格的内存顺序，它包括获取<code>release</code> 和 <code>acquire</code>的所有保证，还保证了全局一致的操作顺序。简单理解就是，你代码的顺序是怎么样，实际的执行顺序就是什么样。</p><p>我们来看一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::Ordering::SeqCst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> A: AtomicBool = AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">static</span> B: AtomicBool = AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> S: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        A.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, SeqCst);</span><br><span class="line">        <span class="keyword">if</span> !B.<span class="title function_ invoke__">load</span>(SeqCst) &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123; S.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        B.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, SeqCst);</span><br><span class="line">        <span class="keyword">if</span> !A.<span class="title function_ invoke__">load</span>(SeqCst) &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123; S.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    a.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    b.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，两个线程都是希望将自己的原子变量设置为<code>true</code>，从而阻止另外一个线程对 <code>S</code> 进行<code>push</code> 操作，其实就类似于锁。因为这里使用了<code>SeqCst</code>，所以代码的执行顺序是跟代码编写顺序是一致的，那么就可能出现以下3 种执行情况：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241112113535084.png"alt="seqcst-memory-order" /><figcaption aria-hidden="true">seqcst-memory-order</figcaption></figure><p>即：同一时刻，<strong>最多</strong>只可能有一个线程会对<code>S</code> 进行操作。</p><h1 id="内存屏障">内存屏障</h1><p>除了内存顺序（MemoryOrder），还有另外一种方式可以控制程序的执行顺序，就是内存屏障（MemoryBarrier）。内存屏障是一种底层的同步原语，它能强制处理器按照特定的顺序执行内存操作。内存屏障通过阻止或限制指令重排序，来确保内存操作的可见性和顺序性。</p><h2 id="基本概念">基本概念</h2><p>内存屏障主要分为以下几种类型：</p><ol type="1"><li><strong>Load Barrier（读屏障）</strong><ul><li>确保在屏障之前的所有读操作都执行完成</li><li>防止后续读操作被重排到屏障之前</li><li>对应 Acquire 语义</li></ul></li><li><strong>Store Barrier（写屏障）</strong><ul><li>确保在屏障之前的所有写操作都执行完成</li><li>防止后续写操作被重排到屏障之前</li><li>对应 Release 语义</li></ul></li><li><strong>Full Barrier（全屏障）</strong><ul><li>同时包含读屏障和写屏障的功能</li><li>防止任何内存操作的重排序</li><li>对应 SeqCst 语义</li></ul></li></ol><p>即下面这 2 种实现方式是等价的：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241112123652784.png" alt="fench" style="zoom:50%;" /></p><p>所以到这里，我们可以更好地理解<strong>为什么 <code>release</code>是阻止其前面的内存访问越过它，而 <code>acquire</code>是阻止其后面的内存访问越过它了</strong>。因为有个 <code>fence</code>在前面或后面拦着！</p><p>但是一般来说，下面的写法相比上面的写法会有一丢丢的性能损失，因为这会增加一些额外的处理指令。那<code>fence</code> 的用武之地是什么呢？</p><ol type="1"><li>可以同时对多个原子操作进行 <code>fench</code>；</li><li>可以根据条件判断，选择是否进行 <code>fench</code>。</li></ol><p>举个例子：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241112125023036.png" alt="fence-multi-atomics" style="zoom:50%;" /></p><p>这个例子的关键点是：</p><ol type="1"><li>如果线程 2 中的任何一个 load 操作观察到了线程 1 中对应的 store操作的值：<ul><li>比如 A.load() 读到了值 1，或</li><li>B.load() 读到了值 2，或</li><li>C.load() 读到了值 3</li></ul></li><li>那么：线程 1 中的 release fence 就会 happens-before 线程 2 中的acquire fence。这意味着线程 1 中 release fence 之前的所有内存操作对线程2 中 acquire fence 之后的操作都是可见的。</li></ol><p>这展示了内存屏障的一个重要优势：<strong>一个屏障可以同时为多个原子操作建立同步关系，而不需要在每个原子操作上都使用Release/Acquire 内存序。这在某些场景下可能会更高效。</strong></p><p>用更通俗的话说：这就像在线程 1 设置了一个"检查点"（releasefence），在线程 2 也设置了一个"检查点"（acquire fence），只要线程 2看到了线程 1 在其检查点之后做的任何一个改动，那么线程 1检查点之前的所有操作对线程 2 的检查点之后都是可见的。</p><h2 id="硬件实现">硬件实现</h2><p>不同的处理器架构实现内存屏障的方式不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; x86/x64</span><br><span class="line">MFENCE  ; 全屏障</span><br><span class="line">LFENCE  ; 读屏障</span><br><span class="line">SFENCE  ; 写屏障</span><br><span class="line"></span><br><span class="line">; ARM</span><br><span class="line">DMB     ; 数据内存屏障</span><br><span class="line">DSB     ; 数据同步屏障</span><br><span class="line">ISB     ; 指令同步屏障</span><br></pre></td></tr></table></figure><h2 id="与内存顺序的关系">与内存顺序的关系</h2><p>Rust 的内存顺序实际上是通过内存屏障来实现的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release 写入会插入 Store Barrier</span></span><br><span class="line">atomic.<span class="title function_ invoke__">store</span>(<span class="number">42</span>, Ordering::Release);  <span class="comment">// 编译器会在此处插入 Store Barrier</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Acquire 读取会插入 Load Barrier</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = atomic.<span class="title function_ invoke__">load</span>(Ordering::Acquire);  <span class="comment">// 编译器会在此处插入 Load Barrier</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SeqCst 操作会插入 Full Barrier</span></span><br><span class="line">atomic.<span class="title function_ invoke__">store</span>(<span class="number">42</span>, Ordering::SeqCst);  <span class="comment">// 编译器会在此处插入 Full Barrier</span></span><br></pre></td></tr></table></figure><details class="tag-plugin colorful folding" color="red" open><summary></summary><div class="body"><p>注意：直接使用内存屏障是非常底层的操作，通常我们应该使用 Rust提供的高级抽象（如原子类型和它们的内存顺序）来实现同步。内存屏障的知识主要用于理解这些高级抽象的工作原理。</p></div></details><h1 id="go-atomic">Go Atomic</h1><p>熟悉 Go 语言的读者应该会意识到在使用 Go语言的原子类型的时候，好像都没见过 Memory Order 这个东西，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := atomic.Int64&#123;&#125;</span><br><span class="line">data.Add(<span class="number">1</span>)</span><br><span class="line">data.And(<span class="number">2</span>)</span><br><span class="line">data.Or(<span class="number">3</span>)</span><br><span class="line">data.Swap(<span class="number">4</span>)</span><br><span class="line">data.Store(<span class="number">5</span>)</span><br><span class="line">data.Load()</span><br><span class="line">data.CompareAndSwap(<span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <ahref="https://github.com/golang/go/blob/release-branch.go1.23/src/sync/atomic/doc.go">atomic/doc.go</a>源码中我们可以看到这段话：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The load and store operations, implemented by the LoadT and StoreT</span></span><br><span class="line"><span class="comment">// functions, are the atomic equivalents of &quot;return *addr&quot; and</span></span><br><span class="line"><span class="comment">// &quot;*addr = val&quot;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In the terminology of [the Go memory model], if the effect of</span></span><br><span class="line"><span class="comment">// an atomic operation A is observed by atomic operation B,</span></span><br><span class="line"><span class="comment">// then A “synchronizes before” B.</span></span><br><span class="line"><span class="comment">// Additionally, all the atomic operations executed in a program</span></span><br><span class="line"><span class="comment">// behave as though executed in some sequentially consistent order.</span></span><br><span class="line"><span class="comment">// This definition provides the same semantics as</span></span><br><span class="line"><span class="comment">// C++&#x27;s sequentially consistent atomics and Java&#x27;s volatile variables.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// [the Go memory model]: https://go.dev/ref/mem</span></span><br></pre></td></tr></table></figure><p>Go语言设计者认为让程序员选择内存序会增加复杂性和出错的可能，所以为了程序的简单性和可预测性，直接就<strong>使用了最安全的<code>Seq-Cst</code> 内存顺序</strong>了。</p><p><a href="https://go.dev/ref/mem">the Go memory model</a>中还提了一句：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If you must read the rest of this document to understand the behavior of your program, you are being too clever.</span><br><span class="line">Don&#x27;t be clever.</span><br></pre></td></tr></table></figure><p>这也呼应了 Go 的设计理念：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Share memory by communicating; don&#x27;t communicate by sharing memory.</span><br></pre></td></tr></table></figure><p>所以总结一下：</p><ol type="1"><li>Go 的原子操作采用了最强的顺序一致性内存序；</li><li>这是一个有意识的设计选择，为了简单性和可预测性；</li><li>如果你需要更细粒度的内存序控制，那么 Go 可能不是最佳选择；</li><li>Go 更推荐使用 channels 和其他同步原语来进行并发控制。</li></ol><h1 id="参考">参考</h1><ul><li><a href="https://marabos.nl/atomics/memory-ordering.html">RustAtomics And Lock</a></li><li><ahref="https://mp.weixin.qq.com/s/t5_Up2YZEZt1NLbvgYz9FQ">聊一聊内存模型与内存序</a></li><li><ahref="https://en.cppreference.com/w/cpp/atomic/memory_order">cppreference</a></li><li><a href="https://go.dev/ref/mem">the Go memory model</a></li></ul>]]></content>
    
    
    <summary type="html">本文深入探讨了 Rust 中的原子操作和内存顺序模型。从硬件层面的原子操作实现原理出发,详细介绍了 Rust 提供的各种原子类型及其操作,并重点阐述了内存顺序(Memory Ordering)的概念、分类及其在并发编程中的应用。通过大量示例代码和图解,帮助读者全面理解 Rust 的内存模型和并发安全机制。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 底层原理" scheme="https://hedon.top/categories/Rust/Rust-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="内存顺序" scheme="https://hedon.top/tags/%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F/"/>
    
    <category term="内存屏障" scheme="https://hedon.top/tags/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    
    <category term="并发控制" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
    <category term="Atomic" scheme="https://hedon.top/tags/Atomic/"/>
    
    <category term="Happens-Before" scheme="https://hedon.top/tags/Happens-Before/"/>
    
  </entry>
  
</feed>
