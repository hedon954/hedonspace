<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HedonWang</title>
  
  <subtitle>君子求诸己，律己则安。</subtitle>
  <link href="https://hedon.top/atom.xml" rel="self"/>
  
  <link href="https://hedon.top/"/>
  <updated>2025-07-08T05:28:51.395Z</updated>
  <id>https://hedon.top/</id>
  
  <author>
    <name>Hedon Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust 入门丨02 闭包</title>
    <link href="https://hedon.top/2025/07/08/rust-02-closure/"/>
    <id>https://hedon.top/2025/07/08/rust-02-closure/</id>
    <published>2025-07-08T05:22:00.000Z</published>
    <updated>2025-07-08T05:28:51.395Z</updated>
    
    <content type="html"><![CDATA[<p>笔者之前一直不理解 Rust 中关于闭包的 Fn/FnMut/FnOnce 这 3 个 trait 的包含关系。通过一段时间的学习和分析，终于找到了我思维上的一个错误点 ，特此梳理此文，方便日后查询。</p><p>我之前的理解是这样的：</p><blockquote><p>Fn 只需要引用，所以要求是最容易满足的。FnMut 需要的是可变引用，所以能满足 FnMut，一定能满足 Fn。FnOnce 需要的是所有权，那都有所有权了 ，&amp;mut 和 &amp; 肯定就不在话下了。所以满足 FnOnce 的，一定是 Fn 和 FnMut。满足 FnMut 的，不一定是 FnOnce，但是一定是 Fn。</p></blockquote><p>我的错误点在于：在<strong>闭包实现者</strong>的角度想&quot;我拥有什么权限&quot;。</p><p>正确的思路应该是：<u>站在<strong>函数调用者</strong>的角度想&quot;我得到了什么承诺&quot;</u>。这才是 Trait 设计的本质，即是能力的声明，更是限制的承诺。</p><hr><h3 id="核心关键：承诺越强，限制越多，类型越“小”">核心关键：承诺越强，限制越多，类型越“小”</h3><p><code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code> 这三个 Trait，本质上是闭包对<strong>调用者</strong>做出的三种不同强度的<strong>承诺</strong>。</p><ol><li><strong><code>Fn</code> 的承诺 (最强的承诺)</strong><ul><li><strong>承诺内容</strong>：调用我，只需要对我进行不可变借用 (<code>&amp;self</code>)。你甚至可以同时在多个线程里调用我。我保证不会改变任何东西，也不会消耗掉自己。</li><li><strong>对闭包的限制</strong>：为了兑现这个最强的承诺，闭包自身受到的限制也最大。它<strong>只能</strong>不可变地借用环境中的变量。</li><li><strong>调用者的自由</strong>：调用者获得了最大的自由，可以随心所欲地、不限次数地调用这个闭包。</li></ul></li><li><strong><code>FnMut</code> 的承诺 (中等的承诺)</strong><ul><li><strong>承诺内容</strong>：调用我，需要对我进行可变借用 (<code>&amp;mut self</code>)。这意味着你不能同时调用我，但可以一个接一个地调用。我可能会改变我内部的状态。</li><li><strong>对闭包的限制</strong>：限制有所放宽。闭包可以<strong>可变地</strong>借用环境变量。</li><li><strong>调用者的自由</strong>：调用者的自由受到了一些限制，不能并发调用了。</li></ul></li><li><strong><code>FnOnce</code> 的承诺 (最弱的承诺)</strong><ul><li><strong>承诺内容</strong>：你<strong>只能</strong>调用我一次 (<code>self</code>)。调用之后，我就会被消耗掉，不复存在。</li><li><strong>对闭包的限制</strong>：对闭包自身的限制最小。它可以随心所欲，甚至可以拿走环境变量的<strong>所有权</strong>。</li><li><strong>调用者的自由</strong>：调用者只拥有一次调用的机会，自由度最低。</li></ul></li></ol><h3 id="将之前的逻辑反过来思考">将之前的逻辑反过来思考</h3><p>用&quot;承诺&quot;的视角：</p><ul><li><strong>错误想法</strong>：<code>FnOnce</code> 有所有权，最厉害，所以它包含了 <code>FnMut</code> 和 <code>Fn</code>。</li><li><strong>正确的逻辑</strong>：一个闭包如果能做出 <code>Fn</code> 的承诺（最强承诺），那么它自然也能满足 <code>FnMut</code>（中等承诺）和 <code>FnOnce</code>（最弱承诺）的要求。</li></ul><p>这就像一个人的信用评级：</p><ul><li>一个能被评为 <strong>AAA 级信用 (<code>Fn</code>)</strong> 的人，向他借钱（调用他）风险极低，可以随时借。他自然也满足 <strong>AA 级 (<code>FnMut</code>)</strong> 和 <strong>A 级 (<code>FnOnce</code>)</strong> 的标准。</li><li>一个被评为 <strong>AA 级信用 (<code>FnMut</code>)</strong> 的人，满足不了 AAA 级的苛刻标准，但他肯定满足 A 级的基本标准。</li><li>一个只有 <strong>A 级信用 (<code>FnOnce</code>)</strong> 的人，意味着和他交易有风险，只能“一次性买卖”，他肯定满足不了 AA 级和 AAA 级的要求。</li></ul><p>所以，这个关系是：</p><ul><li>凡是 <code>Fn</code>，必然是 <code>FnMut</code> 和 <code>FnOnce</code>。</li><li>凡是 <code>FnMut</code>，必然是 <code>FnOnce</code>，但不一定是 <code>Fn</code>。</li><li><code>FnOnce</code> 最为宽泛，它不承诺自己是 <code>FnMut</code> 或 <code>Fn</code>。</li></ul><h3 id="代码验证">代码验证</h3><p>我们用一个具体的例子来印证这个理论。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个函数，它要求一个“AAA信用”的闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_repeatedly</span>&lt;F: <span class="title function_ invoke__">Fn</span>()&gt;(closure: F) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;--- Calling an Fn closure ---&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，它要求一个“AA信用”的闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_mutably</span>&lt;F: <span class="title function_ invoke__">FnMut</span>()&gt;(<span class="keyword">mut</span> closure: F) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;--- Calling an FnMut closure ---&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，它只要求“A信用”的闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_once</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt;(closure: F) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;--- Calling an FnOnce closure ---&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">owned_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 这是一个 Fn 闭包，因为它只对 my_string 进行了不可变借用。</span></span><br><span class="line">    <span class="comment">// 它做出了最强的承诺。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure_fn</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Fn says: &#123;&#125;&quot;</span>, my_string);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 这是一个 FnMut 闭包，因为它对 my_string 进行了可变借用。</span></span><br><span class="line">    <span class="comment">// 它只能做出中等承诺。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">closure_fn_mut</span> = || &#123;</span><br><span class="line">        my_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;FnMut says: &#123;&#125;&quot;</span>, my_string);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 这是一个 FnOnce 闭包，因为它夺走了 owned_string 的所有权。</span></span><br><span class="line">    <span class="comment">// 它只能做出最弱的承诺。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure_fn_once</span> = || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">consumed</span> = owned_string;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;FnOnce says: &#123;&#125;&quot;</span>, consumed);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 开始验证 ---</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `closure_fn` (AAA级) 可以满足所有要求</span></span><br><span class="line">    <span class="title function_ invoke__">call_repeatedly</span>(closure_fn);</span><br><span class="line">    <span class="title function_ invoke__">call_mutably</span>(closure_fn);</span><br><span class="line">    <span class="title function_ invoke__">call_once</span>(closure_fn);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `closure_fn_mut` (AA级) 满足不了 AAA 级的要求</span></span><br><span class="line">    <span class="comment">// call_repeatedly(closure_fn_mut); // 编译错误！因为它改变了环境，不满足 Fn 的要求</span></span><br><span class="line">    <span class="title function_ invoke__">call_mutably</span>(&amp;<span class="keyword">mut</span> closure_fn_mut);</span><br><span class="line">    <span class="title function_ invoke__">call_once</span>(&amp;<span class="keyword">mut</span> closure_fn_mut);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `closure_fn_once` (A级) 只能满足最基本的要求</span></span><br><span class="line">    <span class="comment">// call_repeatedly(closure_fn_once); // 编译错误！</span></span><br><span class="line">    <span class="comment">// call_mutably(closure_fn_once);    // 编译错误！因为它被调用后就没了，不能调用第二次</span></span><br><span class="line">    <span class="title function_ invoke__">call_once</span>(closure_fn_once);</span><br><span class="line">    <span class="comment">// call_once(closure_fn_once); // 再次调用也会编译错误，因为它已经被消耗了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>在 Rust 的 Trait 系统中，一个类型如果满足更强的承诺（<code>Fn</code>），它就能被用在要求较弱承诺（<code>FnMut</code>, <code>FnOnce</code>）的任何地方。这就是为什么 <code>Fn</code> 是最小、最核心的那个集合。</p>]]></content>
    
    
    <summary type="html">本文通过&quot;承诺&quot;的视角深入解析 Rust 闭包中 Fn、FnMut、FnOnce 三个 trait 的包含关系，帮助读者理解闭包设计的本质。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 入门" scheme="https://hedon.top/categories/rust/rust-%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨07丨架构特性范围</title>
    <link href="https://hedon.top/2025/07/08/fosa-ch7/"/>
    <id>https://hedon.top/2025/07/08/fosa-ch7/</id>
    <published>2025-07-08T03:00:00.000Z</published>
    <updated>2025-07-08T03:28:02.155Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第七章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>What is an architectural quantum, and why is it important to architecture?</p><p>为什么是架构量子？它为什么对架构很重要？</p></li><li><p>Assume a system consisting of a single user interface with four independently deployed services, each containing its own separate database. Would this system have a single quantum or four quanta? Why?</p><p>假设一个系统包含一个单一的用户界面，以及四个独立部署的服务，每个服务都包含自己的独立数据库。这个系统会有一个量子还是四个量子？为什么？</p></li><li><p>Assume a system with an administration portion managing static reference data (such as the product catalog, and warehouse information) and a customer-facing portion managing the placement of orders. How many quanta should this system be and why? If you envision multiple quanta, could the admin quantum and customer-facing quantum share a database? If so, in which quantum would the database need to reside?</p><p>假设一个系统包含两个部分：</p><ol><li><strong>管理后台</strong>：负责管理静态参考数据（例如产品目录、仓库信息）。</li><li><strong>用户端</strong>：负责处理客户订单的下达。</li></ol><p>这个系统应该被划分为多少个 <strong>量子</strong>？为什么？如果您设想这是多个量子，那二者可以共享同一个数据库吗？如果可以，该数据库需要驻留在哪个量子中？</p></li></ol><hr><h2 id="什么是架构量子？">什么是架构量子？</h2><p><strong>架构量子 (Architectural Quantum)</strong> 这个概念源于 Neal Ford、Mark Richards 等人在《软件架构：艰难的部分》(Software Architecture: The Hard Parts) 一书中提出的。它的核心定义是：</p><blockquote><p>一个<strong>架构量子</strong>是指一个系统中，具有<strong>高功能内聚性 (High Functional Cohesion)</strong> 和<strong>同步部署依赖性 (Synchronous Deployable Dependency)</strong> 的、可独立部署的组件的最小集合。</p></blockquote><p>为了更好地理解这个定义，我们需要拆解其中的关键术语：</p><ul><li><strong>可独立部署的组件 (Independently Deployable Component)</strong>：这是现代架构（尤其是微服务架构）的基本单元。它可以是一个服务、一个应用或者任何可以独立于系统其他部分进行部署的模块。</li><li><strong>高功能内聚性 (High Functional Cohesion)</strong>：这个概念借鉴了软件工程中的“内聚性”，指的是一个组件内部的各个部分为了一个共同、明确的目标而紧密协作。例如，一个“订单处理服务”应该只包含与创建、更新、查询订单相关的逻辑，而不应该包含用户认证或产品推荐的逻辑。一个架构量子内的所有组件，共同构成了一个完整且内聚的业务功能。</li><li><strong>同步部署依赖性 (Synchronous Deployable Dependency)</strong>：这是定义中最关键也最“硬核”的部分。它指的是组件之间的行为调用必须是同步的，以保证系统正常工作。如果服务 A 调用服务 B，并且必须等待 B 的响应才能继续执行，那么 A 和 B 之间就存在同步依赖。这种依赖关系会将不同的独立部署组件“捆绑”在一起，形成一个不可分割的整体，也就是一个量子。如果为了让某个功能正常工作，你必须同时部署或更新服务 A 和服务 B，那它们就属于同一个量子。</li></ul><h2 id="为什么架构量子很重要？">为什么架构量子很重要？</h2><p>理解了定义后，我们来看看它在实践中的重要性。架构量子的概念为我们提供了一个强大的分析工具，帮助我们衡量和决策架构中的关键架构特性，例如：</p><ol><li><strong>可部署性 (Deployability)</strong>：一个架构量子是<strong>最小的独立部署单元</strong>。整个量子可以作为一个单元进行部署、回滚和发布，而不会破坏系统的其他部分。这极大地简化了 CI/CD 流程。如果你错误地将一个量子拆分成多个，可能会导致部署时的级联失败。</li><li><strong>可测试性 (Testability)</strong>：由于量子内部的组件功能高度内聚且存在同步依赖，因此它也成为了一个理想的<strong>测试边界</strong>。你可以对整个量子进行端到端的功能测试和集成测试，而无需启动整个庞大的系统。</li><li><strong>可伸缩性 (Scalability)</strong>：不同的量子承载不同的业务功能，其负载模式也可能完全不同。例如，浏览产品目录的量子和处理支付的量子对资源的需求天差地别。将它们划分为不同的量子，使得我们可以<strong>独立地扩展</strong>每一个量子，从而更高效地利用资源。</li><li><strong>容错性 (Fault Tolerance)</strong>：一个设计良好的量子边界可以形成一道“防火墙”。一个量子的失败（例如，由于代码缺陷或流量激增）不应该导致其他量子的同步崩溃。这种隔离性是构建高可用系统的基础。</li><li><strong>组织结构对齐 (Alignment with Team Structure)</strong>：根据康威定律 (Conway’s Law)，系统架构往往会反映出开发它的团队的沟通结构。一个清晰的量子可以由一个独立的、自治的团队负责，从而减少跨团队沟通的开销，提升开发效率。</li></ol><p>简而言之，架构量子帮助我们识别出系统中<strong>真正的、不可再分的架构单元</strong>。它提供了一个明确的边界，指导我们如何合理地拆分系统，从而在可部署性、可伸缩性、容错性和团队效率之间取得平衡。</p><h2 id="场景分析一：单一-UI-四个独立服务">场景分析一：单一 UI + 四个独立服务</h2><blockquote><p>假设一个系统包含一个单一的用户界面，以及四个独立部署的服务，每个服务都包含自己的独立数据库。这个系统会有一个量子还是四个量子？为什么？</p></blockquote><p>答案是：<strong>这个系统最有可能包含四个量子 (Four Quanta)</strong>。</p><p><strong>分析如下：</strong></p><p>这里的关键信息是“四个<strong>独立部署</strong>的服务，每个服务都包含<strong>自己的独立数据库</strong>”。</p><ol><li><strong>独立部署与自有数据库</strong>：这个设定强烈暗示了服务之间的高度解耦。在现代架构中，服务独占自己的数据库是实现真正自治和独立部署的黄金法则。如果服务间共享数据库，它们的部署就会产生耦合（例如，一个服务修改了表结构，可能会影响到所有依赖该表的其他服务），也就无法做到真正的独立部署。</li><li><strong>同步依赖的缺失</strong>：虽然这四个服务最终都服务于同一个用户界面 (UI)，但题目并未描述它们之间存在<strong>同步调用</strong>的强依赖关系。UI 很可能是通过异步的方式或者直接独立地与这四个服务进行通信。例如，UI 的一个页面可能需要同时展示来自服务 A 的用户信息和服务 B 的产品列表，但 UI 可以分别向 A 和 B 发起两个独立的 API 请求，这两个服务之间并不需要直接对话。</li><li><strong>功能内聚性</strong>：每个服务和它自己的数据库共同构成了一个高度内聚的功能单元。例如，服务 A 和它的数据库负责“用户管理”，服务 B 和它的数据库负责“订单管理”，等等。它们各自完成了闭环的业务能力。</li></ol><p><strong>结论</strong>：由于这四个服务（连同其数据库）可以独立部署，并且它们之间大概率不存在必须同步成功的强依赖，因此它们构成了四个独立的架构量子。单一的用户界面在这里扮演的是一个“集成层”或“客户端”的角色，它本身通常不被视为一个量子，而是作为这些量子的消费者。将系统划分为四个量子，使得每个服务都可以被独立地开发、测试、部署和扩展，从而获得了极大的架构灵活性。</p><h2 id="场景分析二：管理后台-用户端">场景分析二：管理后台 + 用户端</h2><blockquote><p>假设一个系统包含两个部分：</p><ul><li>管理后台：负责管理静态参考数据（例如产品目录、仓库信息）。</li><li>用户端：负责处理客户订单的下达。</li></ul><p>这个系统应该被划分为多少个量子？为什么？如果您设想这是多个量子，那二者可以共享同一个数据库吗？如果可以，该数据库需要驻留在哪个量子中？</p></blockquote><h3 id="这个系统应该被划分为多少个量子？为什么？">这个系统应该被划分为多少个量子？为什么？</h3><p>答案是：<strong>这个系统应该被划分为两个量子 (Two Quanta)</strong>。</p><p><strong>分析如下：</strong></p><ol><li><strong>不同的架构特性需求</strong>：<ul><li><strong>用户端 (Customer-facing Portion)</strong>：这是系统的核心交易部分。它需要<strong>高可用性 (High Availability)</strong>、<strong>高可伸缩性 (High Scalability)</strong>（因为用户流量波动大，尤其在促销期间）、以及<strong>低延迟 (Low Latency)</strong>。</li><li><strong>管理后台 (Administration Portion)</strong>：这部分主要由内部员工使用。它对可伸缩性的要求远低于用户端，但可能对<strong>数据一致性 (Consistency)</strong> 和安全性有更高的要求。其使用模式也更可预测。</li></ul></li><li><strong>功能内聚性与关注点分离</strong>：管理后台的功能（管理产品目录、仓库信息）和用户端的功能（浏览商品、下单、支付）在业务上是完全不同的。将它们分开，符合单一职责原则，也使得各自的逻辑更清晰。</li><li><strong>部署和生命周期的独立性</strong>：用户端的功能可能需要频繁迭代和快速发布（例如，上线一个新的促销活动），而管理后台的功能则相对稳定，更新频率较低。将它们划分为两个量子，可以实现独立的部署和发布节奏，用户端的紧急修复或更新不会被后台的发布流程所拖累。</li></ol><p><strong>结论</strong>：基于截然不同的架构特性需求、功能内聚性以及部署独立性的考量，将这个系统划分为一个“管理后台量子”和一个“用户端量子”是最佳实践。</p><h3 id="二者可以共享同一个数据库吗？">二者可以共享同一个数据库吗？</h3><p>答案是：<strong>技术上可以，但强烈不推荐 (Technically possible, but highly discouraged)</strong>。共享数据库会引入我们之前提到的问题，即<strong>耦合 (Coupling)</strong>。</p><ul><li><strong>性能耦合</strong>：管理后台的一个慢查询或数据批量导入操作，可能会锁住表，从而严重影响用户端的性能，甚至导致用户无法下单。</li><li><strong>部署耦合</strong>：如果用户端需要修改某个表的结构来支持新功能，这个修改可能会破坏管理后台的正常工作，反之亦然。这使得两个本应独立的量子在部署上产生了依赖。</li><li><strong>安全耦合</strong>：用户端和管理后台的数据库访问权限需求是不同的。共享数据库会增加权限管理的复杂性，可能导致安全漏洞。</li></ul><h3 id="如果一定要共享，数据库需要驻留在哪个量子中？">如果一定要共享，数据库需要驻留在哪个量子中？</h3><p>这是一个权衡和妥协的问题。如果因为历史原因、成本限制或其他因素<strong>不得不</strong>共享数据库，那么决策的关键在于<strong>数据的所有权 (Data Ownership)</strong> 和<strong>服务的关键性 (Service Criticality)</strong>。</p><p>在这个场景中，“产品目录”和“仓库信息”这些数据，虽然由管理后台进行维护，但它们的最终消费者和价值实现者是<strong>用户端</strong>。用户下单的逻辑严重依赖于这些数据的可用性和准确性。</p><p>因此，如果必须共享，该数据库在逻辑上应该<strong>驻留在用户端量子中</strong>。</p><p><strong>原因如下：</strong></p><ol><li><strong>业务关键性</strong>：用户端是直接产生商业价值的部分，其可用性是第一位的。将数据库置于此量子内，意味着所有架构决策（如扩展、备份、容灾）都将优先保障用户端的需求。</li><li><strong>数据所有权</strong>：虽然管理后台是数据的“生产者”，但用户端是数据的核心“消费者”。在领域驱动设计 (Domain-Driven Design) 的思想中，数据应该属于它所支持的核心业务领域 (Core Domain)，在这里显然是用户交易领域。</li><li><strong>架构上的清晰性</strong>：这样做可以建立一个清晰的依赖关系：管理后台量子依赖于用户端量子中的数据。这虽然不是最理想的解耦状态，但至少依赖关系是单向且明确的。</li></ol><p>在这种共享模式下，更好的实践是通过<strong>定义稳定的 API</strong> 来缓解耦合。管理后台不应直接操作数据库，而是应该通过用户端量子提供的 API 来修改产品目录等数据。这样做可以隐藏数据库的物理实现，为未来的数据库拆分创造可能性。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第七章的课后思考题。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
  </entry>
  
  <entry>
    <title>课程笔记丨《手把手带你写一个 Web 框架》</title>
    <link href="https://hedon.top/2025/07/07/note-write-a-web-framework/"/>
    <id>https://hedon.top/2025/07/07/note-write-a-web-framework/</id>
    <published>2025-07-07T15:02:00.000Z</published>
    <updated>2025-07-08T02:38:47.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="框架-零件">框架&quot;零件&quot;</h2><h3 id="context">context</h3><ol><li>框架级 Context：可以组合优秀框架（如 gin.Context）的基础上，扩展自己常用的功能函数。</li><li>业务级 Context：针对具体的业务，组合框架 Context，封装更多的业务工具函数，进一步提升效率。</li><li>如果有必要进步提升性能的话，可以使用 sync.Pool 对 Context 进行管理，避免 Context 频繁创建销毁带来的性能损耗。</li><li>灵活使用链路调用，有助于提升代码的清晰度和可扩展性。</li></ol><h3 id="路由匹配">路由匹配</h3><p>Gin 使用 <a href="https://en.wikipedia.org/wiki/Radix_tree">radix tree</a>，尽可能压缩路由的公共前缀，同时使用 indices 加速路由的检索。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Patricia_trie_var.svg/350px-Patricia_trie_var.svg.png" alt="radix tree"></p><h3 id="中间件">中间件</h3><p>使用洋葱型中间件，可以很方便地进行 AOP 编程，有很大的扩展性。</p><p>如 Gin 框架中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlersChain defines a HandlerFunc slice.</span></span><br><span class="line"><span class="keyword">type</span> HandlersChain []HandlerFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc defines the handler used by gin middleware as return value.</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br></pre></td></tr></table></figure><p>同时为 <code>IRouter</code> 接口也定义 <code>Group</code> 函数，这样可以进一步提升聚合类的逻辑复用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRouter defines all router handle interface includes single and group router.</span></span><br><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span> &#123;</span><br><span class="line">IRoutes</span><br><span class="line">Group(<span class="type">string</span>, ...HandlerFunc) *RouterGroup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行过程中，使用 <code>c.Next()</code> 和 <code>c.Abort()</code> 来进行处理器调用或提前退出等逻辑控制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> abortIndex <span class="type">int8</span> = math.MaxInt8 &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Next() &#123;</span><br><span class="line">c.index++   <span class="comment">// 初始化 c.index = -1</span></span><br><span class="line"><span class="keyword">for</span> c.index &lt; <span class="type">int8</span>(<span class="built_in">len</span>(c.handlers)) &#123;</span><br><span class="line"><span class="keyword">if</span> c.handlers[c.index] != <span class="literal">nil</span> &#123;</span><br><span class="line">c.handlers[c.index](c)</span><br><span class="line">&#125;</span><br><span class="line">c.index++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Abort() &#123;</span><br><span class="line">c.index = abortIndex  <span class="comment">// 设置为最大值，后面的 next 就会直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展现有框架">扩展现有框架</h3><p>相比于自己从零开始写一个 Web 框架，完全可以站在前人的肩膀上，将流行的、好用的、开源协议允许的框架代码拷贝到自己的仓库中，进行改造升级，从而快速搭建一个功能完善、经过验证、贴合团队需要的强悍 Web 框架。</p><h2 id="一切皆服务">一切皆服务</h2><p>按照面向接口编程的理念，将每个模块看成是一个服务，服务的具体实现我们其实并不关心，我们关心的是服务提供的能力，即接口协议。那么框架主体真正要做的事情是什么呢？其实是：<strong>定义好每个模块服务的接口协议，规范服务与服务之间的调用，并且管理每个服务的具体实现</strong>。</p><p>所有的服务都去框架主体中注册自身的模块接口协议，其他的服务调用功能模块的时候，并不是直接去这个服务获取实例，而是从框架主体中获取有这个接口协议的服务实例。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250707232209688.png" alt="一切皆服务"></p><h3 id="容器-container">容器 container</h3><p>服务提供接口定义可参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewInstance is a function that creates a new instance of a service</span></span><br><span class="line"><span class="keyword">type</span> NewInstance <span class="function"><span class="keyword">func</span><span class="params">(...any)</span></span> (any, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceProvider is an interface that defines a service provider</span></span><br><span class="line"><span class="keyword">type</span> ServiceProvider <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Register a service provider into the container,</span></span><br><span class="line"><span class="comment">// whether to initialize the service or not determined by the IsDefer method</span></span><br><span class="line">Register(Container) NewInstance</span><br><span class="line"><span class="comment">// Boot the service provider, this method will be called after the container is initialized.</span></span><br><span class="line"><span class="comment">// Is id recommend to do some initialization work in this method.</span></span><br><span class="line"><span class="comment">// If returns error, the service initialization will be failed.</span></span><br><span class="line">Boot(Container) <span class="type">error</span></span><br><span class="line"><span class="comment">// IsDefer determines whether the service provider should be deferred.</span></span><br><span class="line"><span class="comment">// If true, the service provider will be deferred until the first time the service is used.</span></span><br><span class="line">IsDefer() <span class="type">bool</span></span><br><span class="line"><span class="comment">// Params are the parameters which would be passed to the NewInstance function.</span></span><br><span class="line">Params(Container) []any</span><br><span class="line"><span class="comment">// Name is a method that returns the unique name of the service provider.</span></span><br><span class="line">Name() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器接口定义可参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Container is a service provider container, provides methods to register and resolve service providers.</span></span><br><span class="line"><span class="keyword">type</span> Container <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Bind binds a service provider into the container,</span></span><br><span class="line"><span class="comment">// if the service provider is already bound, it would panic.</span></span><br><span class="line">Bind(provider ServiceProvider) <span class="type">error</span></span><br><span class="line"><span class="comment">// IsBind checks if a service provider is bound into the container</span></span><br><span class="line">IsBind(key <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line"><span class="comment">// Make resolves a service provider from the container</span></span><br><span class="line">Make(key <span class="type">string</span>) (any, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// MustMake resolves a service provider from the container, if not found, it will panic</span></span><br><span class="line">MustMake(key <span class="type">string</span>) any</span><br><span class="line"><span class="comment">// MakeNew creates a new instance of a service provider,</span></span><br><span class="line"><span class="comment">// it is useful when you need to create a new instance of a service provider</span></span><br><span class="line"><span class="comment">// and pass some different parameters to the service provider&#x27;s constructor.</span></span><br><span class="line">MakeNew(key <span class="type">string</span>, params ...any) (any, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现可参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helps to check if the Container interface is implemented</span></span><br><span class="line"><span class="keyword">var</span> _ Container = (*HdwebContainer)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HdwebContainer is the default implementation of the Container interface</span></span><br><span class="line"><span class="keyword">type</span> HdwebContainer <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// providers is a map of service providers, key is the name of the service provider</span></span><br><span class="line">providers <span class="keyword">map</span>[<span class="type">string</span>]ServiceProvider</span><br><span class="line"><span class="comment">// instances is a map of service instances, key is the name of the service</span></span><br><span class="line">instances <span class="keyword">map</span>[<span class="type">string</span>]any</span><br><span class="line"><span class="comment">// lock is used to protect the container from concurrent access</span></span><br><span class="line">lock sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewHdwebContainer creates a new HdwebContainer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHdwebContainer</span><span class="params">()</span></span> *HdwebContainer &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;HdwebContainer&#123;</span><br><span class="line">providers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]ServiceProvider),</span><br><span class="line">instances: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]any),</span><br><span class="line">lock:      sync.RWMutex&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind binds a service provider into the container,</span></span><br><span class="line"><span class="comment">// if the service provider is already bound, &#x27;</span></span><br><span class="line"><span class="comment">// it will replace the existing one and return an error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> Bind(provider ServiceProvider) <span class="type">error</span> &#123;</span><br><span class="line">h.lock.Lock()</span><br><span class="line">key := provider.Name()</span><br><span class="line"><span class="keyword">if</span> _, ok := h.providers[key]; ok &#123;</span><br><span class="line">h.lock.Unlock()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;service provider already bound: &quot;</span> + key)</span><br><span class="line">&#125;</span><br><span class="line">h.providers[key] = provider</span><br><span class="line">h.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> provider.IsDefer() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := provider.Boot(h); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">params := provider.Params(h)</span><br><span class="line">method := provider.Register(h)</span><br><span class="line"></span><br><span class="line">instance, err := method(params...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> h.lock.Unlock()</span><br><span class="line"><span class="keyword">if</span> _, ok := h.instances[key]; ok &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;service provider already resolved: &quot;</span> + key)</span><br><span class="line">&#125;</span><br><span class="line">h.instances[key] = instance</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsBind checks if a service provider is bound into the container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> IsBind(key <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h.findServiceProvider(key) != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make resolves a service provider from the container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> Make(key <span class="type">string</span>) (any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> h.<span class="built_in">make</span>(key, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeNew creates a new instance of a service provider,</span></span><br><span class="line"><span class="comment">// it is useful when you need to create a new instance of a service provider</span></span><br><span class="line"><span class="comment">// and pass some different parameters to the service provider&#x27;s constructor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> MakeNew(key <span class="type">string</span>, params ...any) (any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> h.<span class="built_in">make</span>(key, params, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MustMake resolves a service provider from the container, if not found, it will panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> MustMake(key <span class="type">string</span>) any &#123;</span><br><span class="line">ins, err := h.<span class="built_in">make</span>(key, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ins</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> <span class="built_in">make</span>(key <span class="type">string</span>, params []any, forceNew <span class="type">bool</span>) (any, <span class="type">error</span>) &#123;</span><br><span class="line">sp := h.findServiceProvider(key)</span><br><span class="line"><span class="keyword">if</span> sp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;service provider not found: &quot;</span> + key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> forceNew &#123;</span><br><span class="line"><span class="keyword">return</span> h.newInstance(sp, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ins := h.getInstance(key); ins != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ins, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> h.lock.Unlock()</span><br><span class="line"><span class="keyword">if</span> ins, ok := h.instances[key]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> ins, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">ins, err := h.newInstance(sp, params)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">h.instances[key] = ins</span><br><span class="line"><span class="keyword">return</span> ins, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> getInstance(key <span class="type">string</span>) any &#123;</span><br><span class="line">h.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> h.lock.RUnlock()</span><br><span class="line"><span class="keyword">return</span> h.instances[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> newInstance(sp ServiceProvider, params []any) (any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> err := sp.Boot(h); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> params == <span class="literal">nil</span> &#123;</span><br><span class="line">params = sp.Params(h)</span><br><span class="line">&#125;</span><br><span class="line">method := sp.Register(h)</span><br><span class="line"><span class="keyword">return</span> method(params...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> findServiceProvider(key <span class="type">string</span>) ServiceProvider &#123;</span><br><span class="line">h.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> h.lock.RUnlock()</span><br><span class="line"><span class="keyword">return</span> h.providers[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务-service-provider">服务 service provider</h3><ul><li>contract：服务功能接口定义</li><li>provider：为服务实现 ServiceProvider 接口</li><li>service：实现服务 contract 功能接口</li></ul><h4 id="框架级服务">框架级服务</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">contract</span>  <span class="comment"># 服务接口定义</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">app.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">kernel.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">env.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">config.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider</span>  <span class="comment"># 服务实现</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">app</span> <span class="comment"># app 服务</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider.go</span> <span class="comment"># 实现 Service Provider</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.go</span>  <span class="comment"># 实现服务接口</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">kernel</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.go</span></span><br></pre></td></tr></table></figure><h4 id="业务级服务">业务级服务</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> &#123;<span class="string">root</span>&#125;  <span class="comment"># 根目录</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">app</span> <span class="comment"># app 目录</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider</span> <span class="comment"># 通用业务服务</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">user</span>  <span class="comment"># user 服务</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">contract.go</span> <span class="comment"># user 服务接口定义</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.go</span>  <span class="comment"># user 服务接口实现</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider.go</span> <span class="comment"># 为 user 服务实现 Service Provider</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">mail</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">contract.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider.go</span></span><br></pre></td></tr></table></figure><h2 id="自动化-DRY">自动化 DRY</h2><p>在业务开发过程中，对于那些重复性的类模板劳动，可以使用 CLI 命令行工具，或其他自动化工具，来简化这些劳动输出。</p><p>这里有 2 个思路，一个是使用 Makefile，一个是使用 CLI（Go 里面可以使用 <code>cobra</code> 框架）。选择的时候可以考虑以下几个点：</p><ol><li>命令变动的频率（二者在这一点区别不大，不过如果变动频率比较低，那 CLI 的劣势就相对可以忽略了）</li><li>命令使用的复杂性（参数越多，则需要越详尽的帮助说明）</li><li>业务逻辑相关性（越相关，则逻辑越复杂，使用代码越好管控）</li></ol><p>常见的思路有：</p><ul><li>生成项目脚手架（init）</li><li>项目启动管理（build、start、stop、restart、update）</li><li>服务模版生成（provider list/new）—— 可以结合  <code>survey</code> 做命令行渐进式输入，<code>template</code> 生成模板代码</li><li>命令行系列生成（command list/new）</li><li>定时任务（cron list/run）</li><li>swagger 生成（swagger gen）</li></ul>]]></content>
    
    
    <summary type="html">极客时间《手把手带你写一个 Web 框架》课程笔记。</summary>
    
    
    
    <category term="课程笔记" scheme="https://hedon.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://hedon.top/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨06丨评估和管理架构特性</title>
    <link href="https://hedon.top/2025/07/07/fosa-ch6/"/>
    <id>https://hedon.top/2025/07/07/fosa-ch6/</id>
    <published>2025-07-07T03:00:00.000Z</published>
    <updated>2025-07-07T11:03:19.483Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第六章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>Why is cyclomatic complexity such an important metric to analyze for architecture?</p><p>为什么圈复杂度是架构分析的重要指标？</p></li><li><p>What is an architecture fitness function? How can they be used to analyze an architecture?</p><p>什么是架构适应度函数？它们如何用于分析架构？</p></li><li><p>Provide an example of an architecture fitness function to measure the scalability of an architecture.</p><p>提供一个衡量架构可伸缩性的架构适应度函数示例。</p></li><li><p>What is the most important criteria for an architecture characteristic to allow architects and developers to create fitness functions?</p><p>允许架构师和开发人员创建适应度函数的最重要标准是什么？</p></li></ol><hr><h1>评估架构特性</h1><p>评估架构特性一般可以从 3 个方面入手：</p><ul><li>运维性指标 (operational measures)：主要关注系统在运维层面的能力，涵盖性能、可扩展性、弹性、可用性、可靠性等能力。</li><li>结构性指标 (structural measures)：关注代码结构，如模块化、组件间受控的耦合、可读代码以及其他内部质量评估。常用工具有：<ul><li><strong>圈复杂度 (Cyclomatic Complexity，CC)</strong>：一个代码层面的度量标准，由 Thomas McCabe, Sr. 于 1976 年开发，通过分析代码的决策点（如 if 语句）来量化代码的复杂性。高圈复杂度可能表明代码难以理解和测试。公式为 <code>CC = E - N + 2</code>（针对单个函数），或 <code>CC = E - N + 2P</code>（针对扇出调用）。行业普遍认为 CC 值低于 10 是可接受的，但更倾向于低于 5。</li><li><strong>距主序列距离 (Distance from the Main Sequence，D)</strong>：一个基于抽象性（A）和不稳定性（I）的综合指标，公式为 <code>D = |A + I - 1|</code>。它反映了抽象性和不稳定性之间的理想关系。远离理想线的类可能落入&quot;无用区&quot;（过于抽象难以使用）或&quot;痛苦区&quot;（过于具体且难以维护）</li></ul></li><li>流程性指标 (process measures)：关注软件开发过程中的特性，如敏捷性、可测试性和可部署性。常用工具有：<ul><li><strong>代码覆盖率（code coverage）</strong></li></ul></li></ul><h1>管理架构特性</h1><p>管理架构特性主要通过 4 个方面：</p><ul><li><strong>架构适应性函数 (Architecture Fitness Functions)</strong>：这是评估系统输出质量的客观函数，用于衡量架构特性。它们将重要的架构原则编码到软件基础中，并自动验证这些原则是否得到遵守。例如：<ul><li>检测组件之间的循环依赖 (Cyclic Dependencies)</li><li>验证分层架构中的层间依赖关系</li><li>衡量距主序列的距离</li><li>混沌工程</li></ul></li><li><strong>架构决策记录 (Architecture Decision Records, ADRs)</strong>：ADR 是一种有效的文档化架构决策的方式，通常是一到两页的短文本文件。每个 ADR 应包含标题、状态（例如“已接受”、“已取代”）、上下文、决策（使用肯定性语言）和结果（包括决策的正面和负面影响，以及权衡分析）。ADR 使得架构师能够清晰记录决策的技术和业务理由，避免重复讨论和误解。ADR 中的“合规性 (Compliance)”部分可以强制架构师思考如何衡量和管理决策的合规性，无论是手动还是通过适应性函数自动化。</li><li><strong>风险风暴 (Risk Storming)</strong>：这是一种协作活动，用于识别、达成共识并减轻架构风险。它包括识别（个体非协作活动）、共识（协作活动，讨论并统一风险评估）和缓解（协作活动，寻找减少或消除风险的方法）三个主要阶段。风险风暴通常使用风险矩阵 (Risk Matrix)，通过“影响”和“可能性”两个维度来量化风险。风险评估报告还可以显示特定风险类别或领域随时间的改进或恶化，使用加号 (+) 和减号 (-) 表示方向。</li><li><strong>持续沟通与协作</strong>：有效的沟通对于知识共享和项目成功至关重要。架构师应与产品负责人、项目经理、业务干系人以及开发人员进行谈判和协商，以获得架构决策的批准。倡导通用语言 (Ubiquitous Language)，确保所有项目相关方使用相同的业务领域术语，从而减少信息丢失和误解。</li></ul><h1>回答问题</h1><p>基于上述对本章的概括回顾，回到本章的 4 个课后题，笔者梳理了一下自己的理解，供读者们参考。</p><p>圈复杂度：</p><ol><li>圈复杂度是一种评估代码复杂性的工具。</li><li>如果一个函数（方法）中，条件分支和语句越多，则说明越复杂，一方面可能是业务逻辑本身就足够复杂，另外一方面，也很可能是代码的模块拆分没有做好，逻辑没有梳理清晰，写成了一坨。</li><li>这背后体现了模块化、可测试性、可部署性、可扩展性、可迭代性等多种代码结构层面的架构特性。</li></ol><p>架构适应度函数：</p><ol><li>架构适应度函数是一种用于持续评估当前架构是否满足需求的机制，可以理解为&quot;架构的单元测试&quot;。</li><li>不同的组织、不同的团队、不同的职责对同一个架构特性的理解、定义和需求都是不尽相同的。通过协商、建立其符合具体需求的架构适应度函数，在达成共识的基础上，可以持续对某些架构特性进行达标检测，避免偏离。比如代码测试覆盖率可以用来检测架构的可测试性、部署耗时可以用来横向架构的可部署性、可迭代性等。</li><li>要编写 fitness function，最重要也是唯一最重要的标准是<strong>架构特性必须能够被客观地衡量和定义</strong>。通过鼓励客观定义，团队可以拆解复合特性，从而发现可以被客观衡量的功能。一旦特性被具体定义，就可以更容易地建立相应的适应度函数来验证其完整性。</li></ol><p>衡量系统的可伸缩性：</p><ol><li>可伸缩性，指的是系统在用户或请求数量增加时，仍然能够维持性能和运行的能力。</li><li>假如说我们现在有一个订单服务，如果我们希望它具备良好的可伸缩性，当我们将服务实例从 2 个增加到 4 个时，系统在相同响应时间基准下，应用能处理接近翻倍的请求吞吐量。</li></ol>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第六章的课后思考题，深入探讨如何衡量和管理架构特性，分析圈复杂度等结构性指标的重要性、架构适应度函数的定义与应用，以及运维性、结构性、流程性指标的评估方法，帮助理解如何建立有效的架构治理机制来持续监控和优化系统架构。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨05丨识别架构特征</title>
    <link href="https://hedon.top/2025/07/04/fosa-ch5/"/>
    <id>https://hedon.top/2025/07/04/fosa-ch5/</id>
    <published>2025-07-04T02:24:26.000Z</published>
    <updated>2025-07-07T11:03:23.413Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第五章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>Give a reason why it is a good practice to limit the number of characteristics (“-ilities”) an architecture should support.</p><p>举一个例子来说明为什么限制系统中支持的架构特性的数量的有必要的。</p></li><li><p>True or false: most architecture characteristics come from business requirements and user stories.</p><p>大多数的架构特性都来自于业务需求和用户故事，这对吗？</p></li><li><p>If a business stakeholder states that time-to-market (i.e., getting new features and bug fixes pushed out to users as fast as possible) is the most important business concern, which architecture characteristics would the architecture need to support?</p><p>如果一个业务利益相关者将上市时间（比如以最快的速度实现新功能和修复 BUG）视为最重要的需求点，这个时候需要支持什么样的架构特性？</p></li><li><p>What is the difference between scalability and elasticity?</p><p>可伸缩性（scalability） 和弹性（elasticity）的区别是什么？</p></li><li><p>You find out that your company is about to undergo several major acquisitions to significantly increase its customer base. Which architectural characteristics should you be worried about?</p><p>如果你发现了你的公司进行了几次重大收购以大幅增加其客户群，这个时候你应该考虑什么架构特性？</p></li></ol><hr><h1>架构特性不是越多越好</h1><ul><li><strong>增加系统设计的复杂性</strong>：每增加一个架构特性，都会使整个系统设计变得更加复杂。支持过多的架构特性会导致在架构师和开发人员开始解决核心业务问题之前，系统就变得越来越复杂。</li><li><strong>分散对核心问题的关注</strong>：架构特性定义了系统的成功标准，通常与系统的功能性正交，关注的是“如何”实现需求以及“为什么”做出某些选择。然而，如果过度追求特性数量，可能会导致偏离原始的业务问题，即开发软件的最初动机。</li><li><strong>每个特性都涉及权衡</strong>：软件架构中的每一个方面都存在权衡，有优点也有缺点。例如，在拍卖系统中，选择使用主题（topic）进行通信可能带来架构可扩展性的优势和服务的解耦，但会引入数据访问和数据安全方面的潜在问题，并且不支持异构契约。而使用队列（queue）则允许每个消费者拥有自己的契约，但不具备可扩展性，并且会增加服务间的耦合。架构师需要分析这些权衡，并根据业务驱动因素和环境选择最重要的特性。</li><li><strong>过度规范的危害</strong>：架构师过度规范架构特性是常见的陷阱，其破坏性不亚于规范不足，因为它会使系统设计过于复杂。历史案例“瓦萨号”战舰的失败就是一个例证，它是因为过度追求建造最宏伟的战舰（即过度规范架构特性）而最终导致沉没。</li><li><strong>陷入“意外复杂性”陷阱</strong>：架构师有时会为解决方案、图表和文档添加不必要的复杂性。正如一位作者所言，“开发者被复杂性吸引，就像飞蛾扑火一样——结果往往相同”。这种“意外复杂性”是由于人为地使问题复杂化，而不是问题本身固有的复杂性。通过识别子领域类型并根据其业务逻辑的复杂性选择合适的实现模式（例如，事务脚本和活动记录适用于简单业务逻辑，而领域模型和事件溯源领域模型适用于复杂的核心子领域），可以避免引入不必要的复杂性。</li><li><strong>设计应由业务驱动</strong>：领域驱动设计（DDD）的核心思想在于让业务领域驱动软件设计决策。这意味着设计决策应该基于业务领域的需求和战略，而非盲目地堆砌所有可能的架构特性。</li></ul><p>因此，与领域利益相关者合作时，架构师应努力使最终的架构特性列表尽可能短，因为每个特性都会增加总体系统设计的复杂性。</p><h1>如何识别架构特性</h1><ol><li>从领域焦点中识别架构特性</li><li>从业务需求中识别架构特性</li></ol><p>这里面的一大难点就是：<strong>业务方与开发方使用的不是同一种&quot;语言&quot;</strong>。双方对同一件事情的关注点是不一样的，所以表述出来的述求，也是不同的。</p><p>所以在识别架构特性的时候，架构师的职责就是需要将业务领域的关注点和架构特性进行对应。比如：</p><table><thead><tr><th>Domain Concern</th><th>Architecture characteristics</th></tr></thead><tbody><tr><td>Mergers and acquisitions 合并与收购</td><td>互操作性 interoperability<br>可扩展性 scalability<br>适配性 adaptability<br>可扩展性 extensibility</td></tr><tr><td>Time to market 上市时间</td><td>灵活性 agility<br>可测试性 testability<br>可部署性 deployability</td></tr><tr><td>User satisfaction 用户满意度</td><td>性能 performance<br>可用性 availability<br>容错性 fault tolerance<br>可测试性 testability<br>可部署性 deployability<br>灵活性 agility<br>安全性 security</td></tr><tr><td>Competitive advantage 竞争优势</td><td>灵活性 agility<br/>可测试性 testability<br/>可部署性 deployability<br/>可扩展性 scalability<br/>可用性 availability<br/>容错性 fault tolerance</td></tr><tr><td>Time and budget 时间和预算</td><td>简单性 simplicity<br>可行性 feasibility</td></tr></tbody></table><p>另外， 随着业务的发展，关注点也是在不断发生变化的，这个时候，架构所侧重的架构特性也是随之改变的。</p><h1>可扩展性 vs 弹性</h1><ul><li><strong>可伸缩性（Scalability）</strong>：<u>指的是系统在用户或请求数量增加时，仍然能够维持性能和运行的能力</u>。它衡量的是系统在负载线性增加时，性能是否能够保持相应的线性增长。例如，如果一个系统在用户增加一倍时，其性能也能线性提升，那么它就是可伸缩的。这通常通过增加资源（如服务器实例）来实现，以应对持续增长的用户数量。</li><li><strong>弹性（Elasticity）</strong>：<u>指的是系统处理请求突发性增长的能力</u>。它关注的是系统如何有效地应对不可预测和可变的用户流量高峰。例如，音乐会售票系统在门票开售时会经历用户流量的突然飙升，这需要高弹性的支持。一个具有弹性的系统能够在流量高峰时动态地启动新的处理单元（Processing Units），并在负载降低时关闭它们</li></ul><p>简而言之，可伸缩性是关于处理增加的负载并保持性能，而弹性是关于处理突发性、不可预测的负载波动。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第五章的课后思考题，深入探讨如何识别架构特征，分析限制架构特性数量的重要性、架构特性的来源、业务驱动与架构特性的关系，以及可伸缩性与弹性等关键特性的区别，帮助理解如何从业务需求中提取和选择合适的架构特性。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨04丨架构特性定义</title>
    <link href="https://hedon.top/2025/07/03/fosa-ch4/"/>
    <id>https://hedon.top/2025/07/03/fosa-ch4/</id>
    <published>2025-07-03T02:35:26.000Z</published>
    <updated>2025-07-07T11:03:26.419Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第四章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>What three criteria must an attribute meet to be considered an architecture characteristic?</p><p>一个属性要被认定为架构特性，必须满足哪三个条件？</p></li><li><p>What is the difference between an implicit characteristic and an explicit one? Provide an example of each.</p><p>隐性特性和显性特性的区别是什么？请分别举一个例子。</p></li><li><p>Provide an example of an operational characteristic.</p><p>提供一个操作特性的例子。</p></li><li><p>Provide an example of a structural characteristic.</p><p>提供一个结构特性的例子。</p></li><li><p>Provide an example of a cross-cutting characteristic.</p><p>提供一个交叉特性的例子。</p></li><li><p>Which architecture characteristic is more important to strive for—availability or performance?</p><p>在架构特性中，更应努力追求的是可用性还是性能？</p></li></ol><hr><h2 id="架构特性定义">架构特性定义</h2><p>一个属性要成为架构特性（Architecture Characteristics），需至少满足 3 个条件：</p><ol><li><strong>指定非领域设计考量</strong>：架构特性关注的是应用程序&quot;如何&quot;实现需求以及做出某些选择&quot;为何&quot;的原因，而不是应用程序&quot;应该做什么&quot;的业务需求。例如，性能水平通常不会出现在需求文档中，但却是重要的架构特性。</li><li><strong>影响设计的某个结构方面</strong>：如果一个架构特性需要特殊结构考虑才能成功，那么它就会上升到架构特性的层面。例如，一般的安全性对于几乎所有项目都是必需的，但当需要设计特定的模块、组件或服务来隔离关键安全问题时，安全才成为一个架构特性。</li><li><strong>对应用程序的成功至关重要</strong>：应用程序可以支持大量的架构特性，但并非所有都应该被支持。支持每个架构特性都会增加设计的复杂性，因此，架构师的关键任务是选择最少的、对应用程序成功至关重要或重要的架构特性，而不是尽可能多的。</li></ol><h2 id="显性-隐性">显性 &amp; 隐性</h2><ul><li><p><strong>显性架构特性 (Explicit Architecture Characteristics)</strong> 是在需求规范中明确列出的，作为必要设计的一部分。它们通常直接出现在需求文档或其他具体说明中。</p><blockquote><p>在书中的 Silicon Sandwiches 的案例中，用户数量（“当前数千，未来可能数百万”）就隐含地要求了可伸缩性 (Scalability)，即在不严重降低性能的情况下处理大量并发用户的能力。虽然需求没有明确提出可伸缩性，但从用户数量的描述中可以推断出来</p></blockquote></li><li><p><strong>隐性架构特性 (Implicit Architecture Characteristics)</strong> 很少出现在需求文档中，但它们对于项目的成功是必需的。架构师必须利用他们对问题领域的知识，在分析阶段发现这些特征。</p><blockquote><p>可用性 (Availability) 是一种隐性特征，它确保用户可以访问系统。与可用性密切相关的是可靠性 (Reliability)，它确保网站在交互过程中保持正常运行，不会出现连接中断等问题。这些特征通常不会在设计文档中明确指定，但对于几乎所有应用程序都至关重要。</p></blockquote></li></ul><h2 id="操作特性">操作特性</h2><p>操作性架构特性涵盖了系统的<strong>运行能力</strong>，例如性能、可伸缩性、弹性、可用性和可靠性等。这些特性通常与运营和 DevOps 关注点高度重叠。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>Availability</td><td>系统需要保持可用的时间长度；例如，如果需要 24/7 可用，则需要采取措施确保系统始终可用。它指的是软件可操作和可访问的程度。</td></tr><tr><td>Continuity</td><td>灾难恢复能力。</td></tr><tr><td>Performance</td><td>衡量应用程序请求和响应周期所需的时间。它包括压力测试、高峰分析、功能使用频率分析、所需容量和响应时间。它也可以是更具体的度量，例如首屏渲染时间，即网页首次可见的时间。</td></tr><tr><td>Recoverability</td><td>业务连续性要求（例如，发生灾难时，系统需要多快才能重新上线？）这将影响备份策略和对复制硬件的要求。它也指软件从故障中恢复的能力，通过恢复任何受影响的数据并重新建立系统的所需状态。</td></tr><tr><td>Reliability/Safety</td><td>评估系统是否需要具备故障安全能力，或者其任务关键性是否影响生命。如果系统发生故障，是否会给公司带来巨额损失。它指系统在指定条件下和指定时间内运行的程度。</td></tr><tr><td>Robustness</td><td>在互联网连接中断、断电或硬件故障时，处理错误和边界条件的能力。</td></tr><tr><td>Scalability</td><td>系统随着用户或请求数量的增加而执行和运行的能力。这意味着处理大量并发用户而不会出现严重的性能下降。</td></tr></tbody></table><h2 id="结构特性">结构特性</h2><p>结构性架构特性关注<strong>代码结构</strong>。在许多情况下，架构师对代码质量问题负有独立或共同的责任，例如良好的模块化、组件间的受控耦合、可读性强的代码以及其他内部质量评估。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>Configurability</td><td>最终用户通过可用界面轻松更改软件配置方面的能力。</td></tr><tr><td>Extensibility</td><td>系统的可扩展性。</td></tr><tr><td>Installability</td><td>系统在所有必要平台上安装的便捷性。它指软件在指定环境中安装和/或卸载的程度。</td></tr><tr><td>Leverageability/Reuse</td><td>跨多个产品利用通用组件的能力。它指开发人员在多个系统或构建其他资产中重复使用资产的程度。</td></tr><tr><td>Maintainability</td><td>开发人员修改、纠正或使其适应环境和/或需求变化的有效性和效率程度。</td></tr><tr><td>Portability</td><td>系统是否需要在多个平台上运行。它指开发人员将系统、产品或组件从一个硬件、软件或其他操作或使用环境转移到另一个环境的程度。</td></tr><tr><td>Supportability</td><td>应用程序所需的技术支持级别。系统中调试错误所需的日志记录及其他设施的级别。</td></tr><tr><td>Upgradeability</td><td>从该应用程序/解决方案的旧版本轻松/快速升级到新版本的能力。</td></tr></tbody></table><h2 id="交叉特性">交叉特性</h2><p>交叉架构特性指的是那些难以归类或超出传统类别，但却形成重要设计约束和考虑的特性。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>Accessibility</td><td>确保所有用户（包括色盲或听力障碍等残障用户）能够访问系统。它指使软件可供具有最广泛特征和能力的人使用。</td></tr><tr><td>Archivability</td><td>数据是否需要在一段时间后归档或删除。</td></tr><tr><td>Authentication</td><td>确保用户是其所声称的身份的安全要求。</td></tr><tr><td>Authorization</td><td>确保用户只能访问应用程序内特定功能（按用例、子系统、网页、业务规则、字段级别等）的安全要求。</td></tr><tr><td>Legal</td><td>系统在哪些法律约束下运行（数据保护、萨班斯-奥克斯利法案、GDPR 等）？公司需要哪些保留权利？关于应用程序构建或部署方式的任何规定。</td></tr><tr><td>Privacy</td><td>隐藏内部公司员工交易信息的能力（加密交易，甚至数据库管理员和网络架构师都无法查看）。</td></tr><tr><td>Security</td><td>数据是否需要在数据库中加密？内部系统之间网络通信是否需要加密？远程用户访问需要何种类型的认证？它指软件保护信息和数据的程度，以便人员或其他产品或系统具有与其授权类型和级别相称的数据访问程度。</td></tr><tr><td>Supportability</td><td>应用程序所需的技术支持级别。系统中调试错误所需的日志记录及其他设施的级别。</td></tr><tr><td>Usability/Achievability</td><td>用户使用应用程序/解决方案实现目标所需的培训水平。它指用户可以有效、高效、满意地使用系统达到预期目的。</td></tr></tbody></table><h2 id="可用性-vs-性能">可用性 vs 性能</h2><p>在架构特性中，没有绝对的&quot;更重要&quot;之分，只有权衡取舍 (trade-offs)。这是软件架构的第一定律。架构师很少能够设计一个系统来最大化每一个架构特性。</p><p>可用性和性能之间的选择取决于具体的业务驱动因素、环境和一系列其他因素。例如：</p><ul><li><strong>业务需求</strong>：<ul><li>如果一个系统对用户来说必须始终可用，即使偶尔慢一点也可以接受，那么可用性可能是更高的优先级。例如，一个紧急服务系统或金融交易系统，即使延迟增加，也必须确保服务不中断。</li><li>如果业务目标是提供极快的响应时间，即使偶尔停机也能接受，那么性能可能更重要。例如，高频交易系统，毫秒级的延迟都可能导致巨大损失。</li></ul></li><li><strong>相互影响与权衡</strong>：提升某一个架构特性往往会对其他特性产生负面影响。例如，为了提高安全性，可能需要进行更多的加密和间接操作，这几乎肯定会负面影响性能。</li><li><strong>上下文决定</strong>：不同的系统部分可能需要不同的优先级。例如，在一个在线拍卖系统中，拍卖师界面的可用性和可靠性可能比单个竞拍者界面的可用性更关键。</li></ul><p>因此，架构师的工作是分析这些权衡，并根据特定情况选择&quot;最不差的架构&quot;（least worst architecture）。这要求架构师深入理解业务领域，并与所有相关利益方（包括开发人员、业务分析师、产品负责人等）进行协作，而不是孤立地做出决策。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第四章的课后思考题，深入探讨架构特性（Architecture Characteristics）的定义与分类，分析架构特性的三个判定标准、隐性与显性特性的区别，以及操作型、结构型、交叉型特性的具体表现形式，帮助理解如何识别和选择适合系统需求的架构特性。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
  </entry>
  
  <entry>
    <title>RAG 全栈技术</title>
    <link href="https://hedon.top/2025/07/03/ai-rag-tech-complete/"/>
    <id>https://hedon.top/2025/07/03/ai-rag-tech-complete/</id>
    <published>2025-07-03T00:00:00.000Z</published>
    <updated>2025-07-08T02:38:47.739Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 文档加载</h1><ul><li><a href="https://python.langchain.com/docs/integrations/document_loaders/">langchain-document_loaders</a></li></ul><h2 id="langchian-Document">langchian Document</h2><ul><li><code>page_content</code>: 文档内容</li><li><code>metadata</code>: 文档元信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line">document = Document(</span><br><span class="line">    page_content=<span class="string">&quot;Hello, world!&quot;</span>,</span><br><span class="line">    metadata=&#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;https://example.com&quot;</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="html">html</h2><ul><li><p>在线网页：<em>from</em> langchain<em>community.document_loaders _import</em> WebBaseLoader</p></li><li><p>本地文件：<em>from</em> langchain<em>community.document_loaders _import</em> BSHTMLLoader</p></li><li><p>解析代码：<em>from</em> bs4 <em>import</em> BeautifulSoup</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 HTML 文件内容</span></span><br><span class="line">html_txt = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./file_load/test.html&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        html_txt += line</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 HTML</span></span><br><span class="line">soup = BeautifulSoup(html_txt, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码块 td class=&quot;code&quot;</span></span><br><span class="line">code_content = soup.find_all(<span class="string">&#x27;td&#x27;</span>, class_=<span class="string">&quot;code&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> code_content:</span><br><span class="line">    <span class="built_in">print</span>(ele.text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;+&quot;</span>*<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>这里对代码块解析时的 <code>class</code> 需要根据具体网页的元素定义进行更换，不过大体思路都一样（也不局限于代码块）。</p></li></ul><h2 id="PDF">PDF</h2><ul><li><p>加载文件：<em>from</em> langchain<em>community.document_loaders _import</em> PyMuPDFLoader</p></li><li><p>解析表格：<em>import</em> fitz</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fitz</span><br><span class="line"></span><br><span class="line">doc = fitz.<span class="built_in">open</span>(<span class="string">&quot;./file_load/fixtures/zhidu_travel.pdf&quot;</span>)</span><br><span class="line"></span><br><span class="line">table_data = []</span><br><span class="line">text_data = []</span><br><span class="line"></span><br><span class="line">doc_tables = []</span><br><span class="line"><span class="keyword">for</span> idx, page <span class="keyword">in</span> <span class="built_in">enumerate</span>(doc):</span><br><span class="line">    text = page.get_text()</span><br><span class="line">    text_data.append(text)</span><br><span class="line">    tabs = page.find_tables()</span><br><span class="line">    <span class="keyword">for</span> i, tab <span class="keyword">in</span> <span class="built_in">enumerate</span>(tabs):</span><br><span class="line">        ds = tab.to_pandas()</span><br><span class="line">        table_data.append(ds.to_markdown())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tab <span class="keyword">in</span> table_data:</span><br><span class="line">    <span class="built_in">print</span>(tab)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">100</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Unstructured">Unstructured</h2><p><a href="https://github.com/Unstructured-IO/unstructured">Unstructured</a> 是由 <a href="http://Unstructured.IO">Unstructured.IO</a> 开发的开源 Python 库，专为处理非结构化数据（如 PDF、Word、HTML、XML 等）设计。在 LangChain 中，它作为文档加载的核心工具，实现以下功能：</p><ol><li>格式支持广泛：解析 PDF、DOCX、PPTX、HTML、XML、CSV 等格式，甚至支持扫描件中的 OCR 文本提取。</li><li>元素分区（Partitioning）：将文档拆分为结构化元素（标题、段落、表格、列表），保留原始布局和元数据。</li><li>数据清洗：自动清理文档中的无关符号、页眉页脚，生成纯净文本。</li></ol><p>使用 langchain_unstructured 需要安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uv add unstructured</span><br><span class="line">uv add langchain_unstructured</span><br><span class="line">uv add unstructured_inference</span><br><span class="line">uv add unstructured_pytesseract</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统依赖（macOS）</span></span><br><span class="line">brew install poppler</span><br><span class="line">brew install tesseract</span><br><span class="line">brew install libmagic</span><br><span class="line">brew install ghostscript</span><br><span class="line">brew install pandoc</span><br></pre></td></tr></table></figure><h3 id="PDF-2">PDF</h3><p>需要额外安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uv remove camelot-py # 如果有 camelot 需要先移出，在一些版本上存在冲突</span><br><span class="line"></span><br><span class="line">uv add &quot;unstructured[pdf]&quot;</span><br></pre></td></tr></table></figure><p>使用时导入包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_unstructured <span class="keyword">import</span> UnstructuredLoader</span><br></pre></td></tr></table></figure><h3 id="PPT">PPT</h3><p>需要安装额外依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv add python-pptx</span><br></pre></td></tr></table></figure><p>使用时导入包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> UnstructuredPowerPointLoader</span><br></pre></td></tr></table></figure><p>解析 PPT 中的表格及其他特殊类型，可以使用原始的 <code>python-pptx</code> 库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pptx <span class="keyword">import</span> Presentation</span><br><span class="line"><span class="keyword">from</span> pptx.enum.shapes <span class="keyword">import</span> MSO_SHAPE_TYPE</span><br><span class="line"></span><br><span class="line">ppt = Presentation(<span class="string">&quot;./file_load/fixtures/test_ppt.pptx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> slide_number, slide <span class="keyword">in</span> <span class="built_in">enumerate</span>(ppt.slides, start=<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Slide <span class="subst">&#123;slide_number&#125;</span>:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> shape <span class="keyword">in</span> slide.shapes:</span><br><span class="line">        <span class="keyword">if</span> shape.has_text_frame:  <span class="comment"># 文本信息</span></span><br><span class="line">            <span class="built_in">print</span>(shape.text)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> shape.has_table:  <span class="comment"># 表格信息</span></span><br><span class="line">            table = shape.table</span><br><span class="line">            <span class="keyword">for</span> row_idx, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(table.rows):</span><br><span class="line">                <span class="keyword">for</span> col_idx, cell <span class="keyword">in</span> <span class="built_in">enumerate</span>(row.cells):</span><br><span class="line">                    cell_text = cell.text</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Row <span class="subst">&#123;row_idx + <span class="number">1</span>&#125;</span>, Column <span class="subst">&#123;col_idx + <span class="number">1</span>&#125;</span>: <span class="subst">&#123;cell_text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> shape.shape_type == MSO_SHAPE_TYPE.PICTURE: <span class="comment"># 图片信息</span></span><br><span class="line">            imgae = shape.image</span><br><span class="line">            image_filename = <span class="string">&quot;./file_load/fixtures/pic_from_ppt.jpg&quot;</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(image_filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(imgae.blob)</span><br></pre></td></tr></table></figure><h3 id="Word">Word</h3><p>需要安装额外依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uv add docx2txt</span><br><span class="line">uv add python-docx</span><br></pre></td></tr></table></figure><p>使用时导入包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> Docx2txtLoader</span><br></pre></td></tr></table></figure><p>解析 Word 中的表格及其他特殊类型，可以使用原始的 <code>python-docx</code> 库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_docx</span>(<span class="params">file_path</span>):</span><br><span class="line">    doc = Document(file_path)</span><br><span class="line">    <span class="keyword">for</span> para <span class="keyword">in</span> doc.paragraphs:</span><br><span class="line">        <span class="built_in">print</span>(para.text)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> table <span class="keyword">in</span> doc.tables:</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> table.rows:</span><br><span class="line">            <span class="keyword">for</span> cell <span class="keyword">in</span> row.cells:</span><br><span class="line">                <span class="built_in">print</span>(cell.text, end=<span class="string">&#x27; | &#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./file_load/fixtures/test_word.docx&quot;</span></span><br><span class="line">read_docx(file_path=file_path)</span><br></pre></td></tr></table></figure><h3 id="Excel">Excel</h3><p>需要安装额外依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv add openpyxl</span><br></pre></td></tr></table></figure><h2 id="ragflow-deepdoc">ragflow.deepdoc</h2><p>RAGFlow 是一个开源的、基于&quot;深度文档理解&quot;的 RAG 引擎。</p><p><strong>RAGFlow 的主要特点：</strong></p><ol><li><strong>开箱即用：</strong> 提供 Web UI 界面，用户可以通过简单的几次点击，无需编写代码，就能完成知识库的建立和问答测试。通过 <code>Docker</code> 可以一键部署，非常方便。</li><li><strong>工作流自动化 (Automated Workflow)：</strong> RAGFlow 将复杂的 RAG 流程（文档解析、切块、向量化、存储、检索、生成）模板化。用户可以选择不同的模板来适应不同的数据和任务需求，整个过程高度自动化。</li><li><strong>可视化与可解释性：</strong> 在处理文档时，RAGFlow 会生成一个可视化的解析结果图，让用户能清晰地看到文档是如何被理解和切分的，大大增强了系统的透明度和可调试性。</li><li><strong>企业级特性：</strong> 它支持多种文档格式，能够生成可溯源的答案（即答案会附上来源出处），并且兼容多种 LLM 和向量数据库，易于集成到现有企业环境中。</li></ol><p>如果说 RAGFlow 是一个高效的问答“工厂”，那么 DeepDoc 就是这个工厂里最核心、最先进的“原材料加工车间”。所有外部文档在进入知识库之前，都必须经过 DeepDoc 的精细处理。</p><p>DeepDoc 的全称是 <strong>Deep Document Understanding</strong>（深度文档理解），它是 RAGFlow 实现高质量检索的基石。它并非简单地提取文本，而是试图像人一样“看”和“理解”文档的版面布局和内在逻辑。</p><p><strong>DeepDoc 的工作原理与核心能力：</strong></p><ol><li><strong>视觉版面分析 (Vision-based Layout Analysis)：</strong><ul><li><strong>理论：</strong> DeepDoc 首先会利用计算机视觉（CV）模型，像人眼一样扫描整个文档页面。它不是逐行读取字符，而是先识别出页面上的宏观结构，例如：这是标题、那是段落、这是一个表格、这是一张图片、这是一个页眉/页脚。</li><li><strong>实践：</strong> 对于一个两栏布局的 <code>PDF</code> 报告，传统的文本提取工具可能会把左边一行的结尾和右边一行的开头错误地拼在一起。而 DeepDoc 的视觉分析能准确识别出两个独立的栏目，并按照正确的阅读顺序（先读完左栏，再读右栏）来处理文本。</li></ul></li><li><strong>智能分块 (Intelligent Chunking)：</strong><ul><li><strong>理论：</strong> 这是 DeepDoc 最具价值的一点。在理解了文档布局之后，它会进行“语义分块”而非“物理分块”。传统的 RAG 会把文档切成固定长度（如 500 个字符）的块，这常常会将一个完整的表格或一段逻辑连贯的话拦腰截断。</li><li><strong>实践：</strong> DeepDoc 会将一个完整的表格识别出来并视为一个独立的“块”（Chunk）。一个标题和它紧随其后的段落也会被智能地划分在一起。这样做的好处是，当用户提问与表格相关的问题时，系统检索到的就是这个包含完整上下文的表格块，而不是表格的某几行碎片。这极大地保证了提供给 LLM 的上下文信息的完整性和逻辑性。</li></ul></li><li><strong>高质量光学字符识别 (OCR)：</strong><ul><li><strong>理论：</strong> 对于扫描的 <code>PDF</code> 文件或者文档中嵌入的图片，DeepDoc 内置了高质量的 OCR 引擎。</li><li><strong>实践：</strong> 即便文档是扫描的复印件，它也能尽可能准确地提取出其中的文字内容，并将其融入到上述的版面分析中，确保信息不丢失。</li></ul></li><li><strong>表格解析与转译：</strong><ul><li><strong>理论：</strong> 识别出表格只是第一步，更关键的是让 LLM 能“读懂”表格。</li><li><strong>实践：</strong> DeepDoc 能够提取出表格的结构化数据，并将其转换为 LLM 更容易理解的格式，例如 Markdown 格式。一个复杂的表格图片，在经过 DeepDoc 处理后，可能会变成一个 Markdown 文本表格，这样 LLM 就能轻松地理解其行列关系，并回答诸如“请总结一下表格中第三季度销售额最高的产品是哪个？”这类的问题。</li></ul></li></ol><p>笔者在实践过程中，通过精简 ragflow.deepdoc 中的 pdfparser，抽出了一个组件 <a href="https://github.com/hedon-ai-road/deepdoc_pdfparser">deepdoc_pdfparser</a>.</p><h1>2. 分块策略</h1><ul><li>可视化工具：<a href="https://chunkviz.up.railway.app/">ChunkViz</a></li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/https%253A%252F%252Fsubstack-post-media.s3.amazonaws.com%252Fpublic%252Fimages%252F92c70184-ba0f-4877-9a55-e4add0e311ad_870x1116.gif" alt="RAG 五大分块策略"></p><blockquote><p>参考：<a href="https://blog.dailydoseofds.com/p/5-chunking-strategies-for-rag-f8b?ref=dailydev">5-chunking-strategies-for-rag</a></p></blockquote><h1>3. 向量嵌入</h1><h2 id="3-1-嵌入模型评测">3.1 嵌入模型评测</h2><p>Hugging Face 的 <a href="https://huggingface.co/spaces/mteb/leaderboard">MTEB</a> (Massive Text Embedding Benchmark) 是一个大规模的文本嵌入模型评测基准。它的核心作用是<strong>为各种文本嵌入模型提供一个统一、全面、客观的性能衡量标准</strong>。</p><p>涵盖了文本嵌入在现实世界中最常见的 8 种应用场景，共计 58 个数据集和 112 种语言。这 8 大任务分别是：</p><ul><li><strong>Bitext Mining (双语文本挖掘):</strong> 在不同语言的句子中找出翻译对。</li><li><strong>Classification (分类):</strong> 将文本划分到预定义的类别中。</li><li><strong>Clustering (聚类):</strong> 将相似的文本分组在一起。</li><li><strong>Pair Classification (句子对分类):</strong> 判断两个句子是否具有某种关系 (如释义、矛盾等)。</li><li><strong>Reranking (重排序):</strong> 对一个已经排好序的列表 (如搜索结果) 进行重新排序，以提升质量。</li><li><strong>Retrieval (检索):</strong> 从一个大规模的文档语料库中找出与查询最相关的文档。这是目前文本嵌入最核心和最热门的应用之一。</li><li><strong>Semantic Textual Similarity (STS, 语义文本相似度):</strong> 判断两个句子的语义相似程度，通常给出一个从 0 到 5 的分数。</li><li><strong>Summarization (摘要):</strong> 评估生成的摘要与原文的语义相似度。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image.png" alt="MTEB"></p><h2 id="3-2-稀疏嵌入（Sparse-Embedding）">3.2 稀疏嵌入（Sparse Embedding）</h2><table><thead><tr><th style="text-align:left"><strong>特征</strong></th><th style="text-align:left"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>维度</strong></td><td style="text-align:left">通常等于完整词表或特征集合的大小，可达 10⁵ – 10⁶；大多数维度为 0，只有少数位置有权重</td></tr><tr><td style="text-align:left"><strong>构造方式</strong></td><td style="text-align:left">基于词频或词频-逆文档频率（TF-IDF）、BM25 等统计方法，不依赖深度学习</td></tr><tr><td style="text-align:left"><strong>权重含义</strong></td><td style="text-align:left">每个非零维可直观解释为某个词或特征的重要度，具有高度可解释性</td></tr><tr><td style="text-align:left"><strong>检索/存储</strong></td><td style="text-align:left">用倒排索引即可实现 O(1) 级精确匹配；在线增量更新代价低</td></tr><tr><td style="text-align:left"><strong>优势</strong></td><td style="text-align:left">对长文档、术语精确匹配友好 易于调参（停用词、词根化） 资源消耗小、无推理延迟</td></tr><tr><td style="text-align:left"><strong>劣势</strong></td><td style="text-align:left">维度极高，逐向量暴力计算代价大 只捕获词面共现，无法理解语义或同义词 对拼写/语序变化鲁棒性差</td></tr></tbody></table><h3 id="TF-IDF-Term-Frequency-Inverse-Document-Frequency，词频-逆文档频率">TF-IDF(Term Frequency - Inverse Document Frequency，词频-逆文档频率)</h3><blockquote><p><em>一种经典的加权方案，用来衡量 词语 t 对 文档 d 在 语料库 D 中的重要程度。</em></p></blockquote><ul><li>一句话：词在整个语料库中出现得越少，但在本篇文档中出现得越多，那它就越重要。</li></ul><p>公式：$TF-IDF(t,d,D) = TF(t,d) × IDF(t,D)$</p><p>TF（局部权重）：</p><ul><li>计数：<code>tf = #t 出现次数</code></li><li>频率：<code>tf = #t / |d|</code></li><li>对数平滑：<code>tf = 1 + log(#t)</code></li></ul><p>ID（全局权重）：$$IDF(t) = log\frac{N-df(t)+0.5}{df(t)+0.5} $$</p><ul><li><em>N</em> = 语料中文档总数</li><li><em>df(t)</em> = 含词 <em>t</em> 的文档数</li><li>加 1 或 0.5 可以避免分母为 0，并抑制长尾噪声。</li></ul><h3 id="BM25-Best-Matching-25">BM25(Best Matching 25)</h3><p>可视为 TF-IDF 的扩展版，进一步引入：</p><ul><li><em>k₁</em> 控制 TF 饱和：TF 越大，增益递减。</li><li><em>b</em> 长度归一化：文档越长，单词 TF 权重被抑制。</li></ul><p>公式：$$w(t,d)=IDF(t)⋅\frac{TF(k_{1} +1)}{TF+k_{1}·（1-b+b·\frac{文档长度}{平均文档长度} ）} $$</p><table><thead><tr><th style="text-align:left"><strong>角色</strong></th><th style="text-align:left"><strong>控制对象</strong></th><th style="text-align:left"><strong>常见区间</strong></th><th style="text-align:left"><strong>极值行为</strong></th><th style="text-align:left"><strong>直觉比喻</strong></th></tr></thead><tbody><tr><td style="text-align:left">k₁ (saturation factor)</td><td style="text-align:left">TF 饱和曲线斜率——同一个词在同一文档中重复出现到第 n 次时，还能再加多少分</td><td style="text-align:left">1.0 – 2.0</td><td style="text-align:left">k₁ → 0：完全不计重复词；k₁ → ∞：线性计数，退化为 TF-IDF</td><td style="text-align:left">沾一滴酱油 vs. 倒一瓶酱油：味道总有极限，不会永远 1 → 2 → 3 倍变浓</td></tr><tr><td style="text-align:left">b (length normalizer)</td><td style="text-align:left">文档长度惩罚强度——长文能否用“大块头”刷分</td><td style="text-align:left">0.3 – 0.9</td><td style="text-align:left">b = 0：不考虑长度（BM15）b = 1：长度全量归一化（BM11）</td><td style="text-align:left">打篮球按身高加分：b=0 不管身高；b=1 按身高严格扣分；中间值折中</td></tr></tbody></table><h2 id="3-3-密集嵌入（Dense-Embedding）">3.3 密集嵌入（Dense Embedding）</h2><table><thead><tr><th style="text-align:left"><strong>特征</strong></th><th style="text-align:left"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>维度</strong></td><td style="text-align:left">兼顾效率与表达力，常见 128 – 1536；每一维几乎都非零。</td></tr><tr><td style="text-align:left"><strong>构造方式</strong></td><td style="text-align:left">由深度模型（BERT、Sentence-BERT、OpenAI text-embedding-3-small 等）端对端学习，捕获上下文语义</td></tr><tr><td style="text-align:left"><strong>权重含义</strong></td><td style="text-align:left">单维难以直观解释，但整体向量在低维空间中编码了丰富的语义相似度</td></tr><tr><td style="text-align:left"><strong>检索/存储</strong></td><td style="text-align:left">需专门的 ANN（HNSW、Faiss IVF-PQ 等）索引；向量更新需重新编码</td></tr><tr><td style="text-align:left"><strong>优势</strong></td><td style="text-align:left">具备语义泛化能力，能跨同义词、拼写、语序可跨语言、跨模态（图文）在 RAG/问答场景提升召回率</td></tr><tr><td style="text-align:left"><strong>劣势</strong></td><td style="text-align:left">训练与推理成本高（GPU/CPU 向量化计算）结果可解释性弱 在线增量写入需再编码、重建索引</td></tr></tbody></table><h2 id="3-4-ColBERT">3.4 ColBERT</h2><p>ColBERT 是一种让 BERT 用“词级小向量”做快速、精准文本检索的方法 —— 既不像传统 TF-IDF 那样粗糙，也不像跨编码器那样慢。</p><p>ColBERT = “把 BERT 的句向量拆成 token 向量，再用 Late Interaction 重新拼起来做检索”的工程化改造版 BERT。</p><p><strong>Late Interaction</strong> 就是把查询（Q）和文档（D）<strong>先独立编码</strong>，等到最后打分时再让它们在 <strong>token 级别</strong> 做一次“小范围、轻量级”的互动——既不像 Cross-Encoder 那样“一上来就深度交互”，也不像 Bi-Encoder 那样“全程零交互”。</p><blockquote><p>换言之，BERT 提供<strong>语言理解底座</strong>，ColBERT 在此之上加了<strong>面向检索的输出格式与打分逻辑</strong>，二者既同宗又分工明确。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">           预训练阶段（同一个 BERT 权重）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">┌───────────────┐</span><br><span class="line">│ Google BERT │ ← 海量文本上做 MLM/NSP</span><br><span class="line">└───────────────┘</span><br><span class="line">│ （加载相同参数）</span><br><span class="line">╭───────────┴───────────╮</span><br><span class="line">│ │</span><br><span class="line">│ ↓ 普通微调 │ ↓ ColBERT 微调</span><br><span class="line">│ （分类、NER…） │ （稠密检索）</span><br><span class="line">│ │</span><br><span class="line">│ 取 [CLS] 整句向量 │ 保留 每个 token 向量</span><br><span class="line">│ + 任务特定头 │ + Late-Interaction 打分</span><br><span class="line">│ │</span><br><span class="line">╰───────────┬───────────╯</span><br><span class="line">│</span><br><span class="line">下游推理/检索</span><br></pre></td></tr></table></figure><h2 id="3-5-BGE-M3">3.5 BGE-M3</h2><p>BGE-M3 是由智源研究院（BAAI）开发的新一代旗舰文本嵌入模型，它开创性地在单一模型内集成了<strong>多语言</strong>（支持超过 100 种语言）、<strong>长文本</strong> （支持 8192 词符）和<strong>多功能检索</strong>（同时支持稠密、稀疏和多向量检索）的强大能力。</p><table><thead><tr><th style="text-align:left"><strong>M</strong></th><th style="text-align:left"><strong>含义</strong></th><th style="text-align:left"><strong>具体能力</strong></th><th style="text-align:left"><strong>参考</strong></th></tr></thead><tbody><tr><td style="text-align:left">Multi-Functionality</td><td style="text-align:left">多功能</td><td style="text-align:left">同时产出 稠密向量（dense）、多向量/ColBERT（colbert） 和 稀疏向量（sparse），一套模型即可覆盖混合检索需求。</td><td style="text-align:left"><a href="https://huggingface.co/BAAI/bge-m3">huggingface.bge-m3</a></td></tr><tr><td style="text-align:left">Multi-Linguality</td><td style="text-align:left">多语种</td><td style="text-align:left">覆盖 100+ 语言，是目前公开数据集中多语检索任务的 SOTA。</td><td style="text-align:left"><a href="https://arxiv.org/abs/2402.03216?utm_source=chatgpt.com">arXiv.bge-m3</a></td></tr><tr><td style="text-align:left">Multi-Granularity</td><td style="text-align:left">多粒度</td><td style="text-align:left">最长输入 8 192 token，既能编码短句也能处理长文档。</td><td style="text-align:left"><a href="https://huggingface.co/BAAI/bge-m3">huggingface.bge-m3</a></td></tr></tbody></table><h1>4. 查询增强技术</h1><h2 id="4-1-查询构建">4.1 查询构建</h2><h3 id="4-1-1-Text-to-SQL">4.1.1 Text-to-SQL</h3><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1*wDKR6-ToiX5UgsUYN41JiQ.png" alt="Text-to-SQL"></p><ol><li>构建 DDL 知识库：schema 提取与切片；</li><li>构建 Q-SQL 知识库：示例对注入；</li><li>构建 DB 描述知识库：业务描述补充；</li><li>提供 RAG 检索上下文；</li><li>调用 LLM 进行 SQL 生成；</li><li>执行 SQL 并反馈结果；</li><li>迭代直到正确解决问题。</li></ol><p>常用框架：</p><ul><li>vanna</li><li>Chat2DB</li><li>DB-GPT</li></ul><h3 id="4-1-2-Text-to-Cypher">4.1.2 Text-to-Cypher</h3><p>跟 Text-to-SQL 一样，只不过是生成图数据库（neo4j）查询语句。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1*lhHfQGKOkZGNm40QIqTNIQ.png" alt="Text-to-Cypher"></p><ol><li>构建图元模型（Graph Metamodel）知识库；</li><li>构建 Q-Cypher 知识库（示例对注入）；</li><li>构建图描述（Graph Description）知识库；</li><li>提供 RAG 检索上下文；</li><li>调用 LLM 进行 SQL 生成；</li><li>执行 SQL 并反馈结果；</li><li>迭代直到正确解决问题。</li></ol><h3 id="4-1-3-从查询中提取元数据构建过滤器">4.1.3 从查询中提取元数据构建过滤器</h3><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/output.png" alt="从查询中提取元数据构建过滤器"></p><ol><li>将自然语言转为向量查询语句；</li><li>利用 LLM 推断出元数据过滤条件；</li><li>在查询检索时，根据过滤条件进行文档过滤；</li><li>返回过滤后的相似文档；</li></ol><p>实战案例：</p><ul><li><a href="https://ragflow.io/blog/implementing-text2sql-with-ragflow">https://ragflow.io/blog/implementing-text2sql-with-ragflow</a></li><li><a href="https://medium.com/neo4j/generating-cypher-queries-with-chatgpt-4-on-any-graph-schema-a57d7082a7e7">https://medium.com/neo4j/generating-cypher-queries-with-chatgpt-4-on-any-graph-schema-a57d7082a7e7</a></li></ul><h2 id="4-2-查询翻译">4.2 查询翻译</h2><p>通过对用户查询进行改造和扩展，使其更加清晰、具体，从而提高检索精度。</p><p>常用工具：</p><table><thead><tr><th style="text-align:left"><strong>方案</strong></th><th style="text-align:left"><strong>链接</strong></th><th style="text-align:left"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:left">ragbear</td><td style="text-align:left"><a href="https://github.com/lexiforest/ragbear">GitHub - lexiforest/ragbear</a></td><td style="text-align:left">rewrite= 参数多种改写模式</td></tr><tr><td style="text-align:left">LangChain</td><td style="text-align:left"><a href="https://blog.langchain.dev/query-transformations/">Query Transformations</a></td><td style="text-align:left">内置链式改写</td></tr><tr><td style="text-align:left">LlamaIndex</td><td style="text-align:left"><a href="https://docs.llamaindex.ai/en/stable/examples/query_transformations/query_transform_cookbook/">Query Transform Cookbook ¶</a></td><td style="text-align:left">多策略组合</td></tr><tr><td style="text-align:left">Haystack</td><td style="text-align:left"><a href="https://haystack.deepset.ai/cookbook/metadata_enrichment">Advanced RAG: Automated Structured Metadata Enrichment | Haystack</a></td><td style="text-align:left">pipeline node</td></tr></tbody></table><h3 id="4-2-1-Query2Doc">4.2.1 Query2Doc</h3><p><a href="https://arxiv.org/pdf/2303.07678">Query2Doc</a> 是指将 query 直接交给 LLM 去生成一份相关文档，然后将 query 和生成的文档一起去进行检索。虽然 LLM 生成的文档可能不对，但是提供了更丰富的信息、丰富了问题的语义，有助于提高检索时的精度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">query2doc</span>(<span class="params">query</span>):</span><br><span class="line">    prompt = <span class="string">f&quot;你是一名公司员工制度的问答助手，熟悉公司规章制度，请简短回答以下问题：<span class="subst">&#123;query&#125;</span>&quot;</span></span><br><span class="line">    doc_info = llm(prompt)</span><br><span class="line">    context_query = <span class="string">f&quot;<span class="subst">&#123;query&#125;</span>, <span class="subst">&#123;doc_info&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> context_query</span><br></pre></td></tr></table></figure><h3 id="4-2-2-HyDE">4.2.2 HyDE</h3><p><a href="https://docs.haystack.deepset.ai/docs/hypothetical-document-embeddings-hyde">HyDE</a>（Hypothetical Document Embeddings，假设文档向量）让 LLM 根据 query 去生成一系列假设性文档，然后将这些文档跟 query 一起做向量化，取向量均值去进行检索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hyde</span>(<span class="params">query, include_query=<span class="literal">True</span></span>):</span><br><span class="line">    prompt_template = <span class="string">&quot;&quot;&quot;你是一名公司员工制度的问答助手，熟悉公司规章制度，请简短回答以下问题：</span></span><br><span class="line"><span class="string">    Question: &#123;question&#125;</span></span><br><span class="line"><span class="string">    Answer:&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    prompt = PromptTemplate(input_variables=[<span class="string">&quot;question&quot;</span>], template=prompt_template)</span><br><span class="line">    embeddings = HypotheticalDocumentEmbedder(llm_chain= prompt | llm,</span><br><span class="line">                                 base_embeddings=embedding_model.get_embedding_fun())</span><br><span class="line">    hyde_embedding = embeddings.embed_query(query)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> include_query:</span><br><span class="line">        query_embeddings = embedding_model.get_embedding_fun().embed_query(query)</span><br><span class="line">        result = (np.array(query_embeddings) + np.array(hyde_embedding)) / <span class="number">2</span></span><br><span class="line">        result = <span class="built_in">list</span>(result)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = hyde_embedding</span><br><span class="line">    result = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, result))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="4-2-3-子问题查询">4.2.3 子问题查询</h3><p>当问题比较复杂时，可以利用 LLM 将问题拆解成子问题，每个子问题都生成检索上下文，可以根据合并后总的上下文回答，也可以每个上下文独立回答后汇总。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sun_question</span>(<span class="params">query</span>):</span><br><span class="line">    prompt_template = <span class="string">&quot;&quot;&quot;你是一名公司员工制度的问答助手，熟悉公司规章制度。</span></span><br><span class="line"><span class="string">    你的任务是对复杂问题继续拆解，以便理解员工的意图。</span></span><br><span class="line"><span class="string">    请根据以下问题创建一个子问题列表：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    复杂问题：&#123;question&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    请执行以下步骤：</span></span><br><span class="line"><span class="string">    1. 识别主要问题：找出问题中的核心概念或主题。</span></span><br><span class="line"><span class="string">    2. 分解成子问题：将主要问题分解成可以独立理解和解决的多个子问题。</span></span><br><span class="line"><span class="string">    3. 只返回子问题列表，不包含其他解释信息，格式为：</span></span><br><span class="line"><span class="string">        1. 子问题1</span></span><br><span class="line"><span class="string">        2. 子问题2</span></span><br><span class="line"><span class="string">        3. 子问题3</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    prompt = PromptTemplate(input_variables=[<span class="string">&quot;question&quot;</span>], template=prompt_template)</span><br><span class="line"></span><br><span class="line">    llm_chain = prompt | llm</span><br><span class="line">    sub_queries = llm_chain.invoke(query).split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> sub_queries</span><br></pre></td></tr></table></figure><h3 id="4-2-4-查询改写">4.2.4 查询改写</h3><p>当问题表达不清、措辞差、缺少关键信息时，使用 LLM 根据用户问题<strong>多角度</strong>重写问题，增加额外的信息，提高检索质量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">question_rewrite</span>(<span class="params">query</span>):</span><br><span class="line">    prompt_template = <span class="string">&quot;&quot;&quot;你是一名公司员工制度的问答助手，熟悉公司规章制度。</span></span><br><span class="line"><span class="string">    你的任务是需要为给定的问题，从不同层次生成这个问题的转述版本，使其更易于检索，转述的版本增加一些公司规章制度的关键词。</span></span><br><span class="line"><span class="string">    问题：&#123;question&#125;</span></span><br><span class="line"><span class="string">    请直接给出转述后的问题列表，不包含其他解释信息，格式为：</span></span><br><span class="line"><span class="string">        1. 转述问题1</span></span><br><span class="line"><span class="string">        2. 转述问题2</span></span><br><span class="line"><span class="string">        3. 转述问题3</span></span><br><span class="line"><span class="string">        ...&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    prompt = PromptTemplate(input_variables=[<span class="string">&quot;question&quot;</span>], template=prompt_template)</span><br><span class="line"></span><br><span class="line">    llmchain = prompt | llm</span><br><span class="line">    rewrote_question = llmchain.invoke(query)</span><br><span class="line">    <span class="keyword">return</span> rewrote_question</span><br></pre></td></tr></table></figure><h3 id="4-2-5-查询抽象">4.2.5 查询抽象</h3><p>查询抽象（Take a Step Back）是指当问题包含太多的细节，可能导致检索时忽略了关键的信息，降低检索质量。可以将用户的具体问题转化为一个更高层次的抽象问题，一个更广泛的问题，关注于高级概念或原则，从而提高检索质量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts.chat <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts.few_shot <span class="keyword">import</span> FewShotChatMessagePromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将复杂问题抽象化，使其更聚焦在本质问题上</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">take_step_back</span>(<span class="params">query</span>):</span><br><span class="line">    examples = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;input&quot;</span>: <span class="string">&quot;我祖父去世了，我要回去几天&quot;</span>,</span><br><span class="line">            <span class="string">&quot;output&quot;</span>: <span class="string">&quot;公司丧葬假有什么规定？&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;input&quot;</span>: <span class="string">&quot;我去北京出差，北京的消费高，有什么额外的补助？&quot;</span>,</span><br><span class="line">            <span class="string">&quot;output&quot;</span>: <span class="string">&quot;员工出差的交通费、住宿费、伙食补助费的规定是什么？&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    example_prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">&quot;human&quot;</span>, <span class="string">&quot;&#123;input&#125;&quot;</span>),</span><br><span class="line">            (<span class="string">&quot;ai&quot;</span>, <span class="string">&quot;&#123;output&#125;&quot;</span>),</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    few_shot_prompt = FewShotChatMessagePromptTemplate(</span><br><span class="line">        example_prompt=example_prompt,</span><br><span class="line">        examples=examples,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">        [</span><br><span class="line">            (</span><br><span class="line">                <span class="string">&quot;system&quot;</span>,</span><br><span class="line">                <span class="string">&quot;&quot;&quot;你是一名公司员工制度的问答助手，熟悉公司规章制度。</span></span><br><span class="line"><span class="string">                你的任务是将输入的问题通过归纳、提炼，转换为关于公司规章制度制定相关的一般性问题，使得问题更容易捕捉问题的意图。</span></span><br><span class="line"><span class="string">                请参考下面的例子，按照同样的风格直接返回一个转述后的问题：&quot;&quot;&quot;</span></span><br><span class="line">            ),</span><br><span class="line">            <span class="comment"># few shot exmaples,</span></span><br><span class="line">            few_shot_prompt,</span><br><span class="line">            <span class="comment"># new question</span></span><br><span class="line">            (<span class="string">&quot;user&quot;</span>, <span class="string">&quot;&#123;question&#125;&quot;</span>)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    question_gen = prompt | llm | StrOutputParser()</span><br><span class="line">    res = question_gen.invoke(&#123;<span class="string">&quot;question&quot;</span>: query&#125;).removeprefix(<span class="string">&quot;AI: &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="4-3-查询路由">4.3 查询路由</h2><p>查询路由（Query Routing）是指根据用户问题的具体意图，自动判断应该将该问题导向最合适的数据源（例如向量知识库、SQL 数据库、图数据库或特定 API）以获取最精准信息的决策过程。</p><table><thead><tr><th style="text-align:left">思路</th><th style="text-align:left">图示</th></tr></thead><tbody><tr><td style="text-align:left">逻辑路由</td><td style="text-align:left"><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1831ccf2-5d1b-4a7c-b094-6251d4aa61f5.png" alt="逻辑路由"></td></tr><tr><td style="text-align:left">语义路由</td><td style="text-align:left"><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/3b10f6dc-c598-498a-90c2-c9085c7d1b27.png" alt="语义路由"></td></tr></tbody></table><h1>5. 索引优化技术</h1><p>基本思路：</p><ul><li>父子文档索引</li><li>分层索引</li><li>多表示索引</li></ul><h2 id="5-1-从小块到大上下文">5.1 从小块到大上下文</h2><blockquote><p>向量检索的时候，检索到的是一个小文档，但是通过小文档的 metadata，返回给 LLM 的是查询出来的大文档。</p></blockquote><p>节点-句子滑动窗口检索 SentenceWindowNodeParser</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/output%20(1).png" alt="SentenceWindowNodeParser"></p><p>父子文本块检索：ParentDocumentRetriever</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(1).png" alt="ParentDocumentRetriever"></p><p>前后串连、自动扩展上下文：PrevNextNodePostprocessor、AutoPrevNextPostprocessor</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(2).png" alt="PrevNextNodePostprocessor"></p><h2 id="5-2-构建有层次的索引">5.2 构建有层次的索引</h2><ul><li>构建两个向量数据库（Summary 和 Details），通过 Metadata 进行连接；</li><li>通过 <code>llamaindex</code> 的 <code>indexnode</code> 和 <code>PandasQueryEngine</code>；</li><li>通过查询先检索相关表名，然后做 <code>Text2SQL</code>。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(3).png" alt="Summary &amp; Detail"></p><h2 id="5-3-构建多表示索引">5.3 构建多表示索引</h2><p>构建混合索引：EnsembleRetriever</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(4).png" alt="EnsembleRetriever"></p><p>构建多表示索引：MultiVectorRetriever</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(5).png" alt="MultiVectorRetriever"></p><h1>6. 检索后优化技术</h1><h2 id="6-1-重排-rerank">6.1 重排 rerank</h2><p>传统的搜索或推荐系统通常分为两步：</p><ol><li><strong>召回（Recall）</strong>: 从海量的候选集中，快速、粗略地筛选出几百或几千个可能相关的项目。此阶段追求<strong>速度</strong>和<strong>查全率</strong>，常用技术包括基于关键词的搜索（如 BM25）或向量相似度搜索（ANN）。</li><li><strong>排序/重排（Ranking/Reranking）</strong>: 对召回的结果进行更精细、更复杂的计算，以确定最终呈现给用户的顺序。此阶段追求<strong>精准度</strong>和<strong>查准率</strong>。我们今天讨论的技术就属于这个范畴。</li></ol><p>可以把这个过程比作“海选”和“决赛”。召回是海选，快速淘汰掉明显不相关的选手；重排是决赛，评委（重排模型）对入围选手进行全方位的严格评审，最终给出排名。</p><h3 id="6-1-1-RRF-重排">6.1.1 RRF 重排</h3><blockquote><p>民主投票式的融合</p></blockquote><p>RRF 是一种简单、高效、无需训练的“结果融合”策略。想象一下，你有多个独立的搜索系统（比如一个关键词搜索，一个向量搜索），它们各自对同一批文档给出了自己的排名。RRF 的作用就是将这些不同的排名列表“民主地”融合成一个最终的、可能更优的排名列表。</p><p>RRF 的核心思想是：<strong>一个文档在多个列表中的排名越靠前，它在最终列表中的排名就应该越靠前。</strong></p><p>与简单地将不同系统的得分相加不同，RRF 采用“倒数排名”（Reciprocal Rank）来计算每个文档的最终分数。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(6).png" alt="RRF Rerank"></p><p>优势：</p><ul><li><strong>无需训练</strong>: 即插即用，非常方便。</li><li><strong>性能稳健</strong>: 在不同召回源质量参差不齐时，表现通常比简单的分数相加（如 <code>sum fusion</code>）更稳定。</li><li><strong>计算开销极低</strong>: 几乎不增加额外的计算负担。</li></ul><p>缺点：</p><ul><li><strong>效果上限不高</strong>: 它只利用了“排名”这一个信息，忽略了不同系统给出的原始“分数”中蕴含的置信度信息。</li><li><strong>依赖召回质量</strong>: 如果所有召回源的质量都很差，RRF 也无力回天。</li></ul><p>适应场景：</p><ul><li>混合搜索（Hybrid Search）：融合关键词搜索（BM25）和向量搜索的结果。</li><li>多模态搜索：融合文本、图片等不同模态的搜索结果。</li></ul><h3 id="6-1-2-Cross-Encoder-重排">6.1.2 Cross-Encoder 重排</h3><blockquote><p>query 和文档的&quot;深度阅读理解&quot;</p></blockquote><p>如果说召回阶段的向量搜索是&quot;看标题识文章&quot;，那么 Cross-Encoder 重排就是&quot;把 query 和每篇文档放在一起，逐字逐句地做一篇完整的阅读理解&quot;。</p><p>它通过深度学习模型（通常是 Transformer 架构，如 BERT）来判断一个 query 和一个文档之间的相关性到底有多强。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1*hkV7rQlN6OuEin7qPxyafA.jpeg" alt="Cross-Encoder Rerank"></p><p>基本流程：</p><ol><li><strong>输入构建</strong>: 将查询（Query）和待排序的文档（Document）用一个特殊的分隔符（如 <code>[SEP]</code>）拼接在一起，形成一个单一的输入序列。例如：<code>[CLS] 我的问题是什么？[SEP] 这是候选文档的内容... [SEP]</code></li><li><strong>模型计算</strong>: 将这个拼接后的序列输入到一个预训练好的 Transformer 模型（如 BERT）中。模型内部的自注意力机制（Self-Attention）会让 Query 中的每个词和 Document 中的每个词都进行充分的交互和信息比对。</li><li><strong>分数输出</strong>: 模型在处理完整个序列后，通常会利用起始位置 <code>[CLS]</code> Token 对应的输出向量，接一个简单的线性层，最终输出一个单一的分数（logit），这个分数就代表了 Query 和 Document 之间的相关性得分。</li><li><strong>排序</strong>: 根据所有文档得到的相关性得分，从高到低进行排序，得到最终结果。</li></ol><p>优点：</p><ul><li><strong>效果极佳</strong>: 由于对 query 和文档进行了深度的、非对称的交互分析，其精度通常是所有重排方法中最高的。</li></ul><p>缺点：</p><ul><li><strong>计算成本极高</strong>: 对于每个 <code>(query, document)</code> 对，都需要进行一次完整的、重量级的模型前向传播。如果召回了 500 个文档，就需要进行 500 次 BERT 模型的计算，这在实时性要求高的场景下是巨大的挑战。</li><li><strong>无法提前索引</strong>: 文档的表示不是独立的，必须在查询时与 query 结合才能计算，因此无法像向量搜索那样提前为所有文档建立索引。</li></ul><p>适用场景：</p><ul><li>对精度要求极高，且可以容忍较高延迟的场景，如某些法律或医疗文献的精确查找。</li><li>作为“黄金标准”来生成高质量的标注数据，用于训练更轻量的召回模型（如 Bi-Encoder）。</li></ul><h3 id="6-1-3-ColBERT-重排">6.1.3 ColBERT 重排</h3><blockquote><p>Contextualized Late Interaction over BERT。</p><p>介于“看标题”和“深度阅读”之间的“划重点式”阅读</p></blockquote><p>ColBERT 试图在 Cross-Encoder 的高精度和 Bi-Encoder (召回阶段常用) 的高效率之间找到一个平衡点。它的核心思想是：<strong>不需要逐字逐句地进行完整对比，而是先把 query 和文档各自的&quot;重点&quot;（关键词向量）划出来，然后再计算这些重点之间的匹配程度。</strong></p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/colbert.png" alt="ColBERT Rerank"></p><p>基本流程：</p><ol><li><strong>独立编码</strong>: 首先，使用一个 BERT 类的模型（但稍作修改）分别独立地处理 Query 和 Document。它不再是输出一个单一的 <code>[CLS]</code> 向量，而是为 Query 和 Document 中的<strong>每一个 Token</strong> 都生成一个上下文相关的向量。</li><li><strong>Query 端向量</strong>: 对于 Query，我们保留所有 Token 的输出向量。</li><li><strong>Document 端向量</strong>: 对于 Document，我们也保留所有 Token 的输出向量。这些向量可以<strong>提前计算并存储</strong>，这是它比 Cross-Encoder 高效的关键。</li><li><strong>延迟交互计算</strong>: 在查询时，进行“延迟交互”。具体来说，对于 Query 中的<strong>每一个</strong> Token 向量，我们都去 Document 的所有 Token 向量中寻找一个最相似的（通过最大内积<code>MaxSim</code>操作）。</li><li><strong>分数聚合</strong>: 最后，将 Query 中每个 Token 找到的最大相似度分数<strong>相加</strong>，得到最终的相关性总分。</li></ol><blockquote><p>这个过程好比：</p><ul><li><strong>Query</strong>: “best deep learning framework”</li><li><strong>Document</strong>: “PyTorch is a popular framework for deep learning…”</li></ul><p>ColBERT 会分别计算：</p><ul><li>“best” 和文档中所有词向量的最大相似度。</li><li>“deep” 和文档中所有词向量的最大相似度。</li><li>“learning” 和文档中所有词向量的最大相似度。</li><li>“framework” 和文档中所有词向量的最大相似度。</li><li>然后把这四个最大相似度值加起来作为总分。</li></ul></blockquote><p>优点：</p><ul><li><strong>性能优越</strong>: 精度远超传统的 Bi-Encoder，并且在很多任务上能逼近 Cross-Encoder。</li><li><strong>效率较高</strong>: 由于文档向量可以预计算和索引，查询时的计算开销远低于 Cross-Encoder，只涉及向量的相似度计算。</li></ul><p>缺点：</p><ul><li><strong>存储开销大</strong>: 需要为文档中的每个 Token 都存储一个高维向量，存储成本远高于只存一个文档向量的 Bi-Encoder。</li><li><strong>实现相对复杂</strong>: 其索引和查询逻辑比标准向量搜索更复杂。</li></ul><p>适用场景：</p><ul><li>需要高精度但又对延迟有一定要求的现代搜索引擎，如微软的 Bing 就在使用类似的技术。</li><li>作为 RAG 系统中的高质量重排器。</li></ul><h3 id="6-1-4-Cohere-和-Jina-重排">6.1.4 Cohere 和 Jina 重排</h3><blockquote><p>商业化的&quot;重排即服务&quot;（Reranking-as-a-Service）</p></blockquote><p>Cohere 和 Jina AI 都是提供 AI 模型和服务的公司。它们都将高质量的重排模型封装成了简单易用的 API 服务。本质上，它们提供的重排器很可能就是基于类似 Cross-Encoder 架构的、在海量高质量数据上训练和优化的专有模型。</p><p>优点：</p><ul><li><strong>使用简单</strong>: 只需几行代码调用 API 即可，无需关心模型训练、部署和维护。</li><li><strong>效果保证</strong>: 通常能获得非常好的开箱即用效果，因为这些模型经过了大量数据的锤炼。</li></ul><p>缺点：</p><ul><li><strong>成本</strong>: 按调用量或 token 数量计费，对于大流量应用可能是一笔不小的开销。</li><li><strong>数据隐私</strong>: 需要将你的 query 和文档数据发送给第三方服务商，对于数据敏感的应用需要仔细评估其隐私政策。</li><li><strong>灵活性受限</strong>: 无法像自建模型那样进行深度定制或调优。</li></ul><p>适用场景：</p><ul><li>快速原型验证（MVP）。</li><li>中小型企业或开发者，希望以最小的工程代价获得最好的排序质量。</li><li>大型企业中非核心但又需要高质量排序的业务场景。</li></ul><h3 id="6-1-5-RankGPT-和-RankLLM">6.1.5 RankGPT 和 RankLLM</h3><p>这是最新的重排范式，直接利用 LLM 强大的语言理解和推理能力来进行排序。它的思路是：<strong>不再让模型输出一个简单的相关性分数，而是让 LLM 直接对召回的文档列表进行&quot;思考&quot;和&quot;比较&quot;，然后输出一个排序好的列表。</strong></p><p>基本思路：</p><ol><li><strong>构建 Prompt</strong>: 将 query 和召回的文档列表（通常是文档的标题和摘要）格式化成一个复杂的 Prompt。这个 Prompt 会明确指示 LLM 作为一个排序专家，对给定的文档列表根据与 query 的相关性进行排序，并按指定的格式输出结果。</li><li><strong>LLM 推理</strong>: 将这个 Prompt 发送给 LLM。LLM 会利用其强大的上下文理解能力，分析 query 的深层意图，并比较不同文档之间的细微差别（例如，一个内容更全面，另一个更新颖）。</li><li><strong>解析输出</strong>: LLM 会返回一个文本结果，比如一个重新排序好的文档 ID 列表。程序需要解析这个文本输出来获取最终的排序。</li></ol><p>优点：</p><ul><li><strong>理解复杂意图</strong>: LLM 能够理解非常复杂和模糊的 query，并能进行一定程度的推理，这是传统模型难以做到的。</li><li><strong>零样本/少样本能力强</strong>: 无需针对特定任务进行微调，就能在很多场景下取得惊人的效果。</li><li><strong>可解释性</strong>: 有时可以引导 LLM 给出排序的理由，增加了透明度。</li></ul><p>缺点：</p><ul><li><strong>成本和延迟极高</strong>: 调用大型 LLM API 的成本和时间开销是目前所有方法中最高的，通常只能用于非实时或小批量任务。</li><li><strong>上下文长度限制</strong>: LLM 的上下文窗口大小有限，一次能处理的文档数量和文档长度都受限。</li><li><strong>稳定性问题</strong>: 输出格式可能不稳定，需要设计鲁棒的解析逻辑。结果也可能有一定的随机性。</li></ul><p>适用场景：</p><ul><li>对召回结果的“最后一公里”进行精加工，例如对前 10 名结果进行最终排序。</li><li>作为生成高质量排序标注数据的强大工具。</li><li>对成本不敏感、但对排序质量有极致要求的特定应用。</li></ul><h3 id="6-1-6-时效加权重排">6.1.6 时效加权重排</h3><p>这是一种业务逻辑驱动的重排策略，而非特定的模型或算法。其核心思想是：<strong>对于某些类型的查询，最新的信息比旧的信息更有价值。</strong></p><p>基本思路：</p><ol><li><strong>时间衰减函数 (Time Decay Function)</strong>: 设计一个函数，使得文档的分数随着其发布时间的流逝而衰减。最常用的函数是指数衰减或高斯衰减。</li><li><strong>分桶加权</strong>: 将文档按发布时间分到不同的桶里，如&quot;24 小时内&quot;、“一周内”、“一月内”、“更早”。为每个桶设置一个固定的权重或加分项。例如，&quot;24 小时内&quot;的文档分数乘以 1.5，&quot;一周内&quot;的乘以 1.2 等。</li></ol><p>优点：</p><ul><li><strong>实现简单</strong>: 逻辑清晰，容易实现和调整。</li><li><strong>效果显著</strong>: 对于新闻、社交媒体、产品更新等时效性强的查询，能极大提升用户体验。</li></ul><p>缺点：</p><ul><li><strong>&quot;一刀切&quot;风险</strong>: 如果不加区分地对所有查询都增强时效性，可能会伤害那些寻求&quot;“永恒&quot;知识的查询（如&quot;什么是牛顿第一定律”）。</li><li><strong>参数难调</strong>: 衰减函数的形状、权重 w 等参数需要根据经验和 A/B 测试来仔细调整。</li></ul><p>适用场景：</p><ul><li><strong>新闻搜索</strong>: 用户总是想看最新的报道。</li><li><strong>电商新品</strong>: 用户搜索&quot;手机&quot;时，可能更想看到最新款。</li><li><strong>社交媒体 Feed</strong>: 最新的帖子通常排在最前面。</li><li><strong>需要与查询意图识别结合</strong>: 一个优秀的系统应该能识别出哪些 query 是具有时效性意图的，然后动态地应用时效性加权。</li></ul><h2 id="6-2-压缩-compression">6.2 压缩 compression</h2><p>传统的 RAG 流程是“检索-增强-生成”。系统首先根据用户问题从知识库中检索出若干相关文档片段（Chunks），然后将这些片段作为上下文（Context）连同用户问题一起提交给大语言模型（LLM），由 LLM 生成最终答案。</p><p>这里面潜藏着几个挑战：</p><ol><li><strong>上下文窗口限制 (Context Window Limit)</strong>：每个 LLM 都有其上下文长度上限（如 GPT-4 是 128k tokens）。如果检索出的文档过多，会超出窗口限制，导致无法处理。</li><li><strong>成本与延迟 (Cost &amp; Latency)</strong>：LLM 的 API 调用费用通常与输入的 Token 数量成正比。上下文越长，费用越高，同时模型的推理时间也越长，导致用户等待时间增加。</li><li><strong>“大海捞针”问题 (Lost in the Middle)</strong>：研究表明，当 LLM 的上下文中包含大量信息时，它对位于上下文中间部分信息的注意力会下降。如果关键信息被大量无关或次要信息包围，LLM 可能无法有效利用它，从而影响生成答案的准确性。</li><li><strong>噪声干扰 (Noise Interference)</strong>：检索出的文档片段虽然“相关”，但并非每个字、每句话都对回答当前问题至关重要。这些无关信息就是“噪声”，会干扰 LLM 的判断。</li></ol><p>因此，<strong>RAG 压缩技术的核心目标</strong>，就是在将检索到的信息送入 LLM 之前，对其进行“精炼”——去除无关信息、保留核心内容，从而在<strong>降低成本、提升效率</strong>的同时，<strong>提高最终答案的质量</strong>。</p><h3 id="6-2-1-上下文压缩检索器">6.2.1 上下文压缩检索器</h3><p>上下文压缩检索器是指 LangChain 提供的 <code>Contextual Compression Retriever</code>。</p><p>它不是一个独立的检索器，而是一个&quot;包装器&quot;（Wrapper）。它首先使用一个常规的检索器（如 <code>VectorStoreRetriever</code>）获取一批文档，然后通过一个嵌入的&quot;文档压缩器&quot;（Document Compressor）对这些文档进行筛选或重写，最后只返回那些真正重要的信息。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*SL1A95gsICIB5IDA.png" alt="Contextual Compression Retriever"></p><p>LangChain 提供了两种主流的压缩器：</p><ul><li><strong><code>LLMChainExtractor</code></strong>：这个压缩器内部会运行一个 LLM（通常是一个小模型）。它会遍历每个检索到的文档，并向 LLM 提出一个问题，例如：“请从以下文档中抽取出与’[用户原始问题]'相关的句子。” LLM 会根据指令抽取出关键句子，丢弃无关部分，从而实现压缩。这是一种<strong>基于 LLM 的抽取式压缩</strong></li><li><strong><code>EmbeddingsFilter</code></strong>：这个压缩器不依赖 LLM。它会计算用户问题和每个检索文档（或文档内更小的句子片段）的嵌入向量（Embedding）之间的相似度。只有当相似度超过预设的阈值（e.g., <code>similarity_threshold=0.8</code>）时，该文档或句子才会被保留。这是一种<strong>基于嵌入相似度的过滤式压缩</strong>。</li></ul><p>优势：</p><ul><li><strong>提升信噪比</strong>：直接过滤掉与问题无关的整个文档或文档中的无关部分。</li><li><strong>灵活性高</strong>：可以根据需求选择计算成本低但效果略粗糙的<code>EmbeddingsFilter</code>，或选择成本高但更智能的<code>LLMChainExtractor</code>。</li><li><strong>模块化</strong>：与 LangChain 生态无缝集成，易于实现。</li></ul><h3 id="6-2-2-句子嵌入优化器">6.2.2 句子嵌入优化器</h3><p>句子嵌入优化器是指 LlamaIndex 提供的 <code>Sentence Embedding Optimizer</code>。</p><p>与 LangChain 的 <code>EmbeddingsFilter</code> 思想非常相似，但它在 LlamaIndex 的生态系统内，并专注于句子级别的精细化过滤。</p><p>在检索到相关的文档块（Node）之后，不是将整个文档块都丢给 LLM，而是深入到文档块内部，逐一分析每个句子，只保留与用户问题最相关的句子。</p><p>基本原理：</p><ol><li><strong>初始节点检索</strong>：查询引擎首先从索引中检索出 Top-K 个最相关的节点（Nodes，相当于 LangChain 的 Documents）。</li><li><strong>句子级分析</strong>：<code>SentenceEmbeddingOptimizer</code>（或类似功能的<code>SimilarityPostprocessor</code>）接收这些节点。它会：<ul><li>将每个节点分解成单独的句子。</li><li>为每个句子计算一个嵌入向量。</li><li>计算每个句子的嵌入向量与用户原始问题嵌入向量之间的相似度得分。</li></ul></li><li><strong>阈值过滤</strong>：它会根据一个预设的相似度阈值（<code>similarity_cutoff</code>）来决定保留哪些句子。只有得分高于阈值的句子才会被保留下来，组合成新的、更精简的节点内容。</li><li><strong>合成响应</strong>：最后，只有这些经过精炼的、包含高相关度句子的节点才会被送入响应合成器（Response Synthesizer），由 LLM 生成最终答案。</li></ol><p>优势：</p><ul><li><strong>粒度极细</strong>：相比于过滤整个文档，句子级过滤能最大程度地保留一个文档块中的相关信息，同时剔除无关句子，精度更高。</li><li><strong>减少上下文割裂</strong>：有时一个文档块整体相关度可能不高，但其中有一两句关键信息。这种方法可以精准地把这两句&quot;捞&quot;出来，避免整个文档块被丢弃。</li></ul><h3 id="6-2-3-LLMLingua">6.2.3 LLMLingua</h3><p>在将包含检索文档的冗长提示词（Prompt）发送给昂贵的大模型（如 GPT-4）之前，先用一个更小、更便宜的语言模型（如 GPT-2 或一个微调过的 Llama）来对这个提示词进行&quot;有损压缩&quot;。这个压缩过程会识别并删除那些对 LLM 理解问题和生成答案不太重要的词语或句子。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/LLMLinguafigure1.png" alt="LLMLingua: Innovating LLM efficiency with prompt compression - Microsoft  Research"></p><p>基本原理：</p><ol><li><strong>构建完整提示词</strong>：将用户问题和所有检索到的文档拼接成一个完整的、非常长的提示词。</li><li><strong>小模型介入</strong>：LLMLingua 使用一个小模型来分析这个长提示词。它会评估如果从提示词中删除某个词或某段话，对大模型理解原始提示词的“困惑度”会产生多大影响。</li><li><strong>智能删除</strong>：它会优先删除那些对困惑度影响最小的词语和句子，因为这些内容被认为是信息量较低或冗余的。这个过程被设计得非常精巧，旨在保留关键的实体、术语和逻辑关系。</li><li><strong>生成压缩提示词</strong>：经过这个过程，原始的长提示词被压缩成一个更短的版本，其中包含了原始上下文的&quot;精华&quot;。</li><li><strong>提交大模型</strong>：最后，这个压缩后的、短小精悍的提示词被发送给目标大模型进行处理。</li></ol><h3 id="6-2-4-RECOMP-压缩">6.2.4 RECOMP 压缩</h3><p>RECOMP (REtrieval-and-COMPression) 是一种面向<strong>复杂问题</strong>的、多步骤的 RAG 策略，它将压缩思想融入到了一个更宏大的框架中。</p><p>当面对一个需要综合多个信息源才能回答的复杂问题时，传统的 RAG 一次性检索出的文档可能包含大量不相关细节。RECOMP 通过&quot;分而治之&quot;和&quot;先抽取再合成&quot;的方式来创建高度浓缩和相关的上下文。</p><p>基本原理：</p><ol><li><strong>问题分解（可选）</strong>：对于一个非常复杂的问题，可能首先会将其分解为几个更简单的子问题。</li><li><strong>检索与抽取 (Retrieve and Extract)</strong>：针对（每个子）问题，执行以下操作：<ol><li><strong>检索</strong>：从知识库中检索相关文档。</li><li><strong>抽取</strong>：<strong>这是关键步骤</strong>。它不是直接使用这些文档，而是向 LLM 发出指令，要求 LLM 阅读每个文档，并从中<strong>抽取</strong>出与当前（子）问题直接相关的<strong>简明摘要或关键事实点</strong>。例如：“请阅读以下关于 A 公司的财报，并抽取出其 2023 年第四季度的收入和利润数字。”</li></ol></li><li><strong>压缩与合成 (Compress and Synthesize)</strong>：<ol><li>将从所有文档中抽取出的摘要或事实点收集起来。</li><li>再次调用 LLM，将这些零散但高度相关的信息点<strong>合成</strong>成一段连贯、流畅、无冗余的文本。这段文本就是最终为原始复杂问题量身定制的“完美上下文”。</li></ol></li><li><strong>最终生成</strong>：将这个合成好的、高度浓缩的上下文连同原始问题一起提交给 LLM，生成最终答案。</li></ol><p>优势：</p><ul><li><strong>极高的信息密度</strong>：最终生成的上下文几乎不含任何与问题无关的噪声，每一句话都是为了回答问题而存在的。</li><li><strong>处理复杂问题的能力强</strong>：非常适合需要整合来自不同文档、不同主题信息的“多跳（multi-hop）”问题。</li><li><strong>可解释性</strong>：由于中间步骤生成了摘要和事实点，这个过程比黑盒方法更易于调试和理解。</li></ul><h3 id="6-2-5-Prompt-Caching-记忆上下文">6.2.5 Prompt Caching 记忆上下文</h3><p>它是一种<strong>性能优化</strong>技术，而非内容压缩技术，但常在处理长上下文时被提及。</p><p>在 Transformer 模型（所有现代 LLM 的基础）中，当模型处理一个序列时，它会为每个 Token 计算一个键（Key）和值（Value）向量，这个计算过程非常耗时。Prompt Caching（或称 KV Cache）技术的核心就是：<strong>将已经处理过的 Prompt 部分的 KV 向量缓存起来，下次请求时如果 Prompt 前缀相同，则直接复用缓存，无需重新计算。</strong></p><p>基本原理：</p><ol><li><strong>首次请求</strong>：用户发送一个长 Prompt（例如，一篇需要总结的文章）。模型在处理这个长 Prompt 时，会计算其中每个 Token 的 KV 向量，并将它们存储在 GPU 的内存中（即 KV Cache）。</li><li><strong>后续交互</strong>：现在，用户基于这篇文章提问（例如，“文章的作者是谁？”）。这个新的请求实际上是 <code>[原始长Prompt] + [新问题]</code>。</li><li><strong>缓存命中</strong>：当模型收到这个新请求时，它会发现请求的前半部分（<code>[原始长Prompt]</code>）与上一次完全相同。它会立即从 KV Cache 中加载这部分的 KV 向量，而<strong>只需为新的部分（<code>[新问题]</code>）计算 KV 向量</strong>。</li><li><strong>加速生成</strong>：这样一来，模型省去了重复计算长 Prompt 部分的巨大开销，从而极大地加快了对新问题的响应速度。</li></ol><p>优势：</p><ul><li><strong>大幅提升多轮对话或连续查询的性能</strong>：对于聊天机器人、文档问答等需要保持长上下文的场景，效果极其显著。</li><li><strong>降低总计算成本</strong>：虽然不减少送入的 Token 数，但通过复用计算结果，降低了处理相同前缀的实际计算成本和时间。</li></ul><h2 id="6-3-校正-correction">6.3 校正 correction</h2><p>C-RAG 的核心思想是在检索模块和生成模块之间，引入一个<strong>轻量级的“检索评估器” (Retrieval Evaluator)</strong>，并根据评估结果采取不同的<strong>校正措施</strong>。这项技术主要在学术论文 <em><a href="https://arxiv.org/abs/2401.15884">arXiv:2401.15884</a></em> 中被系统性地提出和阐述。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(7).png" alt="C-RAG"></p><p>C-RAG 的精髓在于其动态的、差异化的处理策略。</p><ul><li><strong>当评估为“不正确”时</strong>：C-RAG 会果断地<strong>抛弃</strong>所有从内部知识库检索到的文档。因为它判断这些文档只会误导 LLM。取而代之，它会<strong>重写 (Rewrite)</strong> 用户的查询，使其更适合通用搜索引擎，然后<strong>触发网络搜索 (Web Search)</strong>，从更广阔的、实时更新的互联网中获取信息。这极大地扩展了 RAG 系统的知识边界，尤其适用于回答关于近期事件或内部知识库未覆盖领域的问题。</li><li><strong>当评估为“正确”时</strong>：即便文档是相关的，也可能包含大量与问题无关的“噪音”段落。为了让 LLM 更专注于核心信息，C-RAG 采用了一种“分解-再重组” (Decompose-then-Recompose)*的知识精炼算法。<ul><li><strong>分解 (Decompose)</strong>：将相关的文档分解成更小的、独立的知识片段 (Knowledge Strips)。</li><li><strong>重组 (Recompose)</strong>：再次使用评估器对每个知识片段进行打分，过滤掉无关的片段，只保留最核心、最相关的知识点，然后将这些精华片段“重组”起来，作为最终的上下文。</li></ul></li><li><strong>当评估为“模糊”时</strong>：C-RAG 会采取一种混合策略。它会<strong>同时</strong>对内部检索到的模糊文档进行上述的“分解-再重组”精炼，并启动网络搜索获取外部信息。最后，将两方面的信息<strong>合并</strong>，为 LLM 提供一个更全面、更鲁棒的上下文。</li></ul><p>实战案例：<a href="https://langchain-ai.github.io/langgraph/tutorials/rag/langgraph_crag/">LangGraph-CRAG</a></p><h1>7. 响应生成</h1><ul><li><a href="https://python.langchain.com/docs/concepts/output_parsers/">Output parsers | 🦜️🔗 LangChain</a></li><li><a href="https://docs.llamaindex.ai/en/stable/module_guides/querying/structured_outputs/output_parser/">LlamaIndex 丨 Output Parsing Modules</a></li><li><a href="https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses">OpenAI 丨 Structured Outputs</a></li></ul><h1>8. 系统性优化</h1><p>系统性优化指的是从系统层面上，通过优化整个 RAG 流程来达到一个更好的检索效果。</p><h2 id="8-1-自我修正与反思型-RAG">8.1 自我修正与反思型 RAG</h2><ul><li>业界标杆：<a href="https://github.com/AkariAsai/self-rag">self-rag</a></li><li>笔者实践：<a href="https://github.com/hedon-ai-road/regulation_rag/blob/main/self_rag.py">self-rag.py</a></li></ul><p>此架构模拟了人类“先思考、再审视、后修正”的决策过程。系统首先生成一个初步答案，然后启动一个内部的&quot;批评家&quot;来评估这个答案的质量。如果发现问题（如信息不完整、逻辑不通顺），系统会生成修正指令，并基于新指令进行迭代优化，直到产出高质量的最终答案。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/d9b68194-3676-4c00-88c2-12f4e1020e64.png" alt="Self-RAG 思想简化"></p><h2 id="8-2-迭代式检索-RAG">8.2 迭代式检索 RAG</h2><ul><li><a href="https://arxiv.org/pdf/2403.06840">RA-ISF</a></li></ul><p>此架构专门应对信息不足的问题。当一次检索无法获取回答复杂问题所需的全部信息时，系统会进入一个迭代循环。它会分析已获取的内容，智能地生成新的、更深入的查询，然后再次进行检索。这个过程不断重复，直到收集到足够全面的上下文，最后再进行综合生成。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(8).png" alt="Iterative Retrieval RAG 原理简化"></p><h2 id="8-3-自适应-智能体-RAG">8.3 自适应/智能体 RAG</h2><ul><li><a href="https://github.com/asinghcsu/AgenticRAG-Survey">AgenticRAG-Survey</a></li></ul><p>此架构将 RAG 提升到了一个智能体 （Agent）的高度。系统核心是一个作为大脑的 LLM，它能自主分析用户问题，并决策采取何种行动：是进行知识库检索、上网搜索、调用计算器，还是直接回答。它能制定多步计划并调用不同工具，展现出更高的灵活性和解决复杂问题的能力。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(9).png" alt="Agentic RAG 原理简化"></p><h1>9. 评估</h1><ul><li>实践案例：<a href="https://github.com/hedon-ai-road/regulation_rag/blob/main/eval.ipynb">eval.ipynb</a></li></ul><h2 id="9-1-三大标准">9.1 三大标准</h2><ul><li><strong>Context Relevance</strong>：系统检索到的上下文是否紧密围绕用户的问题展开，是否包含了解答问题所需的关键信息。</li><li><strong>Faithfulness</strong>：生成的答案与给定的上下文之间的事实一致性。</li><li><strong>Answer Relevance</strong>：关注答案是否直接回答了问题，还关注答案是否完整、是否包含冗余信息。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250704094042400.png" alt="RAG 评估三大标准"></p><h2 id="9-2-三大步骤">9.2 三大步骤</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250704094056404.png" alt="RAG 评估三大步骤"></p><h2 id="9-3-Ragas">9.3 Ragas</h2><p><a href="https://docs.ragas.io/en/stable/">Ragas</a> 评估指标：</p><ul><li><strong>Faithfulness</strong>: 生成的答案与给定的上下文之间的事实一致性。</li><li><strong>Answer relevancy</strong>: 关注答案是否直接回答了问题，还关注答案是否完整、是否包含冗余信息。</li><li><strong>Context Precision</strong>: 衡量检索上下文的信噪比。</li><li><strong>Context Recall</strong>: 判断是否能检索到回答问题所需的全部相关信息。</li></ul><p>优点：</p><p>优点：</p><ol><li>轻量易用。</li><li>指标专业性：专为 RAG 设计四大核心指标：上下文相关性（Context Relevance）、上下文召回率（Context Recall）、答案忠实度（Faithfulness）、答案相关性（Answer Relevance）。</li><li>无参考标签评估：不依赖参考答案即可完成评估，降低标注成本。</li></ol><p>缺点：</p><ol><li>结果可解释性弱：仅输出分数，不提供得分原因。</li><li>本地化支持不足：主要优化英文场景，对中文等语言支持有限。</li><li>功能扩展性弱：不支持自定义指标，灵活性较。</li></ol><p>代码示例：</p><p><strong>1. 构建数据集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line">questions = [</span><br><span class="line">    <span class="string">&quot;伙食补助费标准是什么?&quot;</span>,</span><br><span class="line">    <span class="string">&quot;出差可以买意外保险吗？需要自己购买吗&quot;</span>,</span><br><span class="line">]</span><br><span class="line">ground_truths = [</span><br><span class="line">    <span class="string">&quot;伙食补助费标准: 西藏、青海、新疆 120元/人、天 其他省份 100元/人、天&quot;</span>,</span><br><span class="line">    <span class="string">&quot;出差可以购买交通意外保险，由单位统一购买，不再重复购买&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">answers = []</span><br><span class="line">contexts = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> query <span class="keyword">in</span> questions:</span><br><span class="line">    response, context_list = run_rag_pipeline_without_stream(query=query, k=<span class="number">3</span>)</span><br><span class="line">    answers.append(response)</span><br><span class="line">    contexts.append(context_list)</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;question&quot;</span>: questions,</span><br><span class="line">    <span class="string">&quot;answer&quot;</span>: answers,</span><br><span class="line">    <span class="string">&quot;contexts&quot;</span>: contexts,</span><br><span class="line">    <span class="string">&quot;ground_truth&quot;</span>: ground_truths</span><br><span class="line">&#125;</span><br><span class="line">dataset = Dataset.from_dict(data)</span><br></pre></td></tr></table></figure><p><strong>2. 定义评估指标</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ragas.metrics <span class="keyword">import</span>(</span><br><span class="line">    faithfulness,</span><br><span class="line">    answer_relevancy,</span><br><span class="line">    context_recall,</span><br><span class="line">    context_precision,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>3. 执行评估</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ragas <span class="keyword">import</span> evaluate</span><br><span class="line"><span class="keyword">from</span> ragas <span class="keyword">import</span> RunConfig</span><br><span class="line"></span><br><span class="line">eval_llm = RagLLM()</span><br><span class="line">embedding_model = RagEmbedding()</span><br><span class="line">eval_embedding_fn = embedding_model.get_embedding_fun()</span><br><span class="line"></span><br><span class="line">result = evaluate(</span><br><span class="line">    dataset=dataset,</span><br><span class="line">    llm=eval_llm,</span><br><span class="line">    embeddings=eval_embedding_fn,</span><br><span class="line">    metrics=[</span><br><span class="line">        context_precision,</span><br><span class="line">        context_recall,</span><br><span class="line">        faithfulness,</span><br><span class="line">        answer_relevancy,</span><br><span class="line">    ],</span><br><span class="line">    raise_exceptions=<span class="literal">True</span>,</span><br><span class="line">    run_config=config</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">df = result.to_pandas()</span><br></pre></td></tr></table></figure><p><strong>4. 评估结果</strong></p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(10).png" alt="Ragas 评估结果示例"></p><h2 id="9-4-TruLens">9.4 TruLens</h2><p>提供一个交互式的仪表板（Dashboard），用于可视化评估结果、比较不同版本的实验并追踪性能变化。它不仅支持 LangChain 和 LlamaIndex 等主流框架，还支持对完全自定义的 RAG 应用进行封装和评估。</p><p>典型流程：</p><ol><li>定义反馈函数（如 <code>Groundedness</code>，<code>AnswerRelevance</code>，<code>ContextRelevance</code>）；</li><li>然后用 <code>TruApp</code> 包装 RAG 应用；</li><li>再一个 <code>with</code> 上下文管理器中运行查询；</li><li><code>run_dashboard</code> 启动仪表盘查看结果。</li></ol><p>优点：</p><ol><li>全链路追踪：记录 RAG 全流程（检索、上下文、生成），支持根本原因分析，精准定位故障点（如检索错误或生成偏差）。</li><li>可视化与集成：内置 Web 仪表盘，实时展示评估结果；深度集成 LangChain 和 LlamaIndex。</li><li>反馈函数组合：支持自定义反馈函数（如毒性检测、语言匹配），灵活适配业务需求。</li></ol><p>缺点：</p><ol><li>指标覆盖面窄：核心仅三大指标（上下文相关性、答案忠实度、答案相关性），缺乏上下文召回率等关键维度。</li><li>依赖人工标注：答案正确性等指标需参考答案（Ground Truth），增加标注成本。</li><li>调试门槛高：全链路追踪需额外配置，对新手不够友好。</li></ol><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> trulens_eval <span class="keyword">import</span> TruApp, Feedback, OpenAI, Select</span><br><span class="line"><span class="keyword">from</span> trulens_eval.app <span class="keyword">import</span> App</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化反馈函数提供者</span></span><br><span class="line">provider = OpenAI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 RAG 三元组反馈函数</span></span><br><span class="line">f_groundedness = Feedback(provider.groundedness_measure_with_cot_reasons).on(Select.RecordCalls.retrieve.rets.collect()).on_output()</span><br><span class="line">f_answer_relevance = Feedback(provider.relevance_with_cot_reasons).on_input().on_output()</span><br><span class="line">f_context_relevance = Feedback(provider.context_relevance_with_cot_reasons).on_input().on(Select.RecordCalls.retrieve.rets[:]).aggregate(np.mean)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包装 RAG 应用</span></span><br><span class="line">tru_rag_app = TruApp(rag_query_engine, app_id=<span class="string">&quot;RAG_v1&quot;</span>, feedbacks=[f_groundedness, f_answer_relevance, f_context_relevance])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行并记录评估</span></span><br><span class="line"><span class="keyword">with</span> tru_rag_app <span class="keyword">as</span> recording:</span><br><span class="line">    rag_query_engine.query(<span class="string">&quot;What did the author do growing up?&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动仪表板</span></span><br><span class="line">tru.run_dashboard()</span><br></pre></td></tr></table></figure><h2 id="9-5-DeepEval">9.5 DeepEval</h2><p>将自身定位为 LLM 应用的&quot;单元测试&quot;框架，理念非常现代化。提供超过 14 种评估指标，不仅覆盖 RAG，还包括微调等场景。其一大亮点是指标具有<strong>自我解释</strong>能力，即在给出分数的同时，会提供具体的理由来解释为何得分不高，极大地便利了调试过程。此外，它与流行的测试框架 Pytest 深度集成，可以无缝地融入 CI/CD 流程。</p><p>优点：</p><ol><li>工程化与自动化：原生支持 pytest，可集成 CI/CD 流水线，实现自动化测试与报告生成。</li><li>指标丰富且可定制：内置 30+ 指标（如忠实度、毒性、偏见检测），支持 DAG 自定义指标（决策树结构）满足复杂逻辑。独创上下文召回率计算（基于关键陈述覆盖比例）。</li><li>结果可解释性强：提供分数原因及改进建议，支持与 RAGAS 结果联动分析</li></ol><p>缺点：</p><ol><li>部分指标非 RAG 专属：如摘要质量、知识保留等指标更通用，需筛选适用场景。</li><li>依赖评估模型：默认使用 OpenAI 模型，替换自定义模型需额外开发。</li><li>配置复杂：DAG 指标需设计节点逻辑（任务节点、裁决节点等），学习曲线陡峭。</li></ol><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> deepeval</span><br><span class="line"><span class="keyword">import</span> deepeval.evaluate</span><br><span class="line"><span class="keyword">from</span> deepeval.metrics <span class="keyword">import</span> (</span><br><span class="line">    FaithfulnessMetric,</span><br><span class="line">    AnswerRelevancyMetric,</span><br><span class="line">    ContextualPrecisionMetric,</span><br><span class="line">    ContextualRecallMetric</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> deepeval.test_case <span class="keyword">import</span> LLMTestCase</span><br><span class="line"></span><br><span class="line">test_cases = []</span><br><span class="line"><span class="keyword">for</span> i, question <span class="keyword">in</span> <span class="built_in">enumerate</span>(questions):</span><br><span class="line">    test_cases.append(LLMTestCase(</span><br><span class="line">        <span class="built_in">input</span>=question,</span><br><span class="line">        actual_output=answers[i],</span><br><span class="line">        retrieval_context=contexts[i],</span><br><span class="line">        expected_output=ground_truths[i],</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">evaluation_metrics = [</span><br><span class="line">    FaithfulnessMetric(threshold=<span class="number">0.7</span>),</span><br><span class="line">    AnswerRelevancyMetric(threshold=<span class="number">0.8</span>),</span><br><span class="line">    ContextualPrecisionMetric(threshold=<span class="number">0.7</span>),</span><br><span class="line">    ContextualRecallMetric(threshold=<span class="number">0.9</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">results = deepeval.evaluate(</span><br><span class="line">    test_cases=test_cases,</span><br><span class="line">    metrics=evaluation_metrics</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, result <span class="keyword">in</span> <span class="built_in">enumerate</span>(results.test_results):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;--- TestCase <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Query: <span class="subst">&#123;result.<span class="built_in">input</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result.success:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;✅ Overall Result: Passed\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;❌ Overall Result: Failed\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印每个指标的详细得分和原因</span></span><br><span class="line">    <span class="keyword">for</span> metric_result <span class="keyword">in</span> result.metrics_data:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  📊 Metric: <span class="subst">&#123;metric_result.__class__.__name__&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;     - Score: <span class="subst">&#123;metric_result.score:<span class="number">.2</span>f&#125;</span> (Threshold: <span class="subst">&#123;metric_result.threshold&#125;</span>)&quot;</span>)</span><br><span class="line">        reason = <span class="built_in">getattr</span>(metric_result, <span class="string">&#x27;reason&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;     - Reason: <span class="subst">&#123;reason&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">25</span> + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>结合单元测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> deepeval <span class="keyword">import</span> assert_test</span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;test_case&quot;</span>, test_cases</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regualation_rag_eval</span>(<span class="params">test_case: LLMTestCase</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Testing Input: <span class="subst">&#123;test_case.<span class="built_in">input</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    assert_test(</span><br><span class="line">        test_case=test_case,</span><br><span class="line">        metrics=[</span><br><span class="line">            FaithfulnessMetric(threshold=<span class="number">0.7</span>),</span><br><span class="line">            AnswerRelevancyMetric(threshold=<span class="number">0.8</span>),</span><br><span class="line">            ContextualPrecisionMetric(threshold=<span class="number">0.7</span>),</span><br><span class="line">            ContextualRecallMetric(threshold=<span class="number">0.9</span>)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--- TestCase 1 ---</span><br><span class="line">Query: 伙食补助费标准是什么?</span><br><span class="line">✅ Overall Result: Passed</span><br><span class="line"></span><br><span class="line">  📊 Metric: MetricData</span><br><span class="line">     - Score: 1.00 (Threshold: 0.7)</span><br><span class="line">     - Reason: The score is 1.00 because there are no contradictions, indicating a perfect alignment between the actual output and the retrieval context. Great job maintaining accuracy and consistency!</span><br><span class="line">  📊 Metric: MetricData</span><br><span class="line">     - Score: 1.00 (Threshold: 0.8)</span><br><span class="line">     - Reason: The score is 1.00 because the response perfectly addresses the question about the standard for meal allowances without any irrelevant information. Great job!</span><br><span class="line">  📊 Metric: MetricData</span><br><span class="line">     - Score: 1.00 (Threshold: 0.7)</span><br><span class="line">     - Reason: The score is 1.00 because the relevant nodes in the retrieval contexts are perfectly ranked above the irrelevant node. The first node provides a clear table with the &#x27;伙食补助费标准&#x27; for different regions, directly answering the input question. The second node further explains the concept and provides the same standards, reinforcing the relevance. The third node, which discusses hotel recommendations and accommodation fees, is unrelated and correctly ranked last.</span><br><span class="line">  📊 Metric: MetricData</span><br><span class="line">     - Score: 1.00 (Threshold: 0.9)</span><br><span class="line">     - Reason: The score is 1.00 because the expected output perfectly aligns with the information in the nodes in the retrieval context, showcasing a flawless match. Great job!</span><br></pre></td></tr></table></figure><h1>10. Graph RAG</h1><h2 id="10-1-图数据库">10.1 图数据库</h2><h3 id="10-1-1-neo4j">10.1.1 neo4j</h3><p><a href="https://github.com/neo4j/neo4j">neo4j</a> 使用的是语言是 <a href="https://neo4j.com/docs/getting-started/cypher/">cypher</a>。Cypher 的核心是 <code>MATCH</code>（模式匹配） + <code>RETURN</code>（结果返回），辅以 <code>CREATE</code>/<code>MERGE</code>（数据操作）、<code>WHERE</code>（过滤）、<code>WITH</code>（管道传递）。</p><p><strong>1. 节点与关系语法</strong></p><ul><li><strong>节点</strong>：用圆括号 <code>()</code> 表示，可包含变量、标签和属性。<ul><li><code>()</code>：匿名节点</li><li><code>(p:Person)</code>：变量 <code>p</code> + 标签 <code>Person</code></li><li><code>(p:Person &#123;name: 'Alice', age: 30&#125;)</code>：带属性的节点。</li></ul></li><li><strong>关系</strong>：用方括号 <code>[]</code> 表示，放在两个短横线中间（<code>--</code>），方向用箭头（<code>→</code> 或 <code>←</code>）指定。<ul><li><code>-[:KNOWS]-</code>：无变量、类型为 <code>KNOWS</code> 的无向关系</li><li><code>-[r:ACTED_IN &#123;roles: ['Neo']&#125;]-→</code>：变量 <code>r</code> + 类型 <code>ACTED_IN</code> + 属性</li></ul></li></ul><p><strong>2. 模式匹配（MATCH）</strong></p><p>核心是通过路径模式描述图结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[r:ACTED_IN]-&gt;(m:Movie &#123;title: &#x27;The Matrix&#x27;&#125;)</span><br><span class="line">RETURN p, r.roles</span><br></pre></td></tr></table></figure><ul><li>可选匹配：<code>OPTIONAL MATCH</code> 处理可能不存在的关系。</li></ul><p><strong>3. 数据操作语句</strong></p><ul><li><p>创建：</p><ul><li><code>CREATE (p:Person &#123;name: 'Alice'&#125;)</code>：创建节点。</li><li><code>CREATE (a)-[:FRIEND]-&gt;(b)</code>：创建关系（需先匹配 <code>a</code>, <code>b</code>）</li></ul></li><li><p>更新：<code>SET</code> 修改属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person) SET p.age = 31</span><br></pre></td></tr></table></figure></li><li><p>合并：<code>MERGE</code> 存在则匹配，不存在则创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MERGE (p:Person &#123;name: &#x27;Alice&#x27;&#125;)</span><br><span class="line">ON CREATE SET p.created_at = timestamp()</span><br></pre></td></tr></table></figure></li><li><p>删除：</p><ul><li><code>DELETE n</code>：删除节点（需先断开关系）</li><li><code>DETACH DELETE n</code>：删除节点及关联关系</li></ul></li></ul><p><strong>4. 查询控制条件</strong></p><ul><li><p>过滤：<code>WHERE</code> 条件筛选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person) WHERE p.age &gt; 30 OR p.name STARTS WITH &#x27;A&#x27;</span><br></pre></td></tr></table></figure></li><li><p>返回：<code>RETURN</code> 指定输出</p></li><li><p>连接查询：<code>WITH</code> 传递中间结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p)-[:FRIEND]-&gt;(f)</span><br><span class="line">WITH p, count(f) AS friendCount</span><br><span class="line">WHERE friendCount &gt; 10</span><br><span class="line">RETURN p.name</span><br></pre></td></tr></table></figure></li><li><p>聚合与排序：</p><ul><li><code>COUNT()</code>, <code>COLLECT()</code>：聚合函数</li><li><code>ORDER BY p.age DESC LIMIT 10</code>：排序和分页</li></ul></li></ul><p><strong>5. 索引与约束</strong></p><ul><li><p>索引：加速节点查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX FOR (p:Person) ON (p.name)</span><br></pre></td></tr></table></figure></li><li><p>约束：确保数据唯一性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE CONSTRAINT ON (m:Movie) ASSERT m.title IS UNIQUE</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-1-2-nebula-graph">10.1.2 nebula graph</h3><p><a href="https://github.com/vesoft-inc/nebula">nebula graph</a> 使用的语言是 <a href="https://docs.nebula-graph.io/3.8.0/3.ngql-guide/1.nGQL-overview/1.overview/">nGQL</a>。</p><h2 id="10-2-典型流程">10.2 典型流程</h2><ol><li>将问题提交给 LLM，让其提取（总结）关键词；</li><li>通过关键词来地毯式查询节点，尝试命中图数据库中定义的节点；</li><li>如果有命中的，则通过节点来查询关联的关系和节点信息；</li><li>将查询到的信息组织上上下文提交给 LLM，解答最初的问题。</li></ol><h2 id="10-3-实战案例">10.3 实战案例</h2><ul><li><a href="https://github.com/hedon-py-road/learn-neo4j/blob/main/neo4j.ipynb">learn-neo4j</a></li><li><a href="https://github.com/hedon-ai-road/ftt_rag/blob/main/graph-rag.ipynb">ftt_graph_rag</a></li></ul><h1>11. ReAct RAG</h1><p>ReAct = Reasoning + Acting = 推理 + 行动</p><ul><li>核心理念：让大型语言模型像人一样，在解决复杂问题时，能够先思考分析（推理），然后根据思考结果采取行动（行动），再观察行动结果，接着进行新一轮的思考，如此循环，直到问题解决。</li><li>核心流程：<ul><li>思考（Thought）</li><li>行动（Action）</li><li>观察（Observation）</li><li>思考（Thought）</li><li>…</li><li>最终答案（Final Answer）</li></ul></li></ul><h2 id="11-1-Prompt">11.1 Prompt</h2><p><strong>1. 明确的规则制定（Rule Formulation）</strong></p><ol><li>循环结构：强制模型遵循 “Thought -&gt; Action -&gt; Observation” 的循环。</li><li>输出格式：严格规定每一个环节的输出格式，便于程序解析。</li><li>终止条件：明确告诉模型何时任务算完成，以及如何提交最终答</li></ol><p><strong>2. 精确的工具授权（Tool Granting）</strong></p><ol><li>功能单一：每个工具最好只做一件事，这让模型更容易选择。</li><li>描述清晰：工具的描述 (description) 是模型决定使用哪个工具的唯一依据。描述要用自然语言写得清晰、准确，说明白“这个工具能干什么”。</li><li>参数明确：工具的输入参数 (parameters) 必须定义清楚，包括名称、类型和用途。</li><li>有了 MCP 后，这一步可以用 MCP 来替代。</li></ol><p><strong>3. 高质量的示例引导（Example Guidance）</strong></p><ol><li>展示思维链：清晰地展示从问题到第一个思考，再到行动的逻辑。</li><li>覆盖典型场景：展示如何使用不同的工具，甚至是如何组合使用工具。</li><li>处理异常情况：最好能包含一个处理错误的示例 (比如搜索不到结果时该怎么办)，这能极大地提升模型的鲁棒性。</li></ol><p>Prompt 示例骨架：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">You are an expert assistant capable of solving complex problems by breaking them down into a sequence of thought and action. You must strictly follow the format of &quot;Thought, Action, Observation&quot; to solve the problem.</span><br><span class="line"></span><br><span class="line">You have access to the following tools:</span><br><span class="line"></span><br><span class="line">[tool<span class="emphasis">_definitions]</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Use the following format:</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Question: The user&#x27;s question you need to answer.</span></span><br><span class="line"><span class="emphasis">Thought: Your internal reasoning and plan for the next action.</span></span><br><span class="line"><span class="emphasis">Action: The tool you will use. It must be one of [list_</span>of<span class="emphasis">_tool_</span>names].</span><br><span class="line">Observation: The result returned by the action.</span><br><span class="line">... (this Thought/Action/Observation cycle can repeat N times)</span><br><span class="line">Thought: I now have the final answer.</span><br><span class="line">Action: finish(the final answer)</span><br></pre></td></tr></table></figure><p>Few Shot 示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Question: 苹果公司的现任 CEO 是谁？他的前任是谁？</span><br><span class="line"></span><br><span class="line">Thought: 我需要分两步解决这个问题。第一，找出苹果的现任 CEO。第二，找出他的前任。我先执行第一步。</span><br><span class="line">Action: search(&quot;苹果公司现任 CEO&quot;)</span><br><span class="line">Observation: 苹果公司现任 CEO 是蒂姆·库克 (Tim Cook)。</span><br><span class="line"></span><br><span class="line">Thought: 我已经知道了现任 CEO 是蒂姆·库克。现在我需要找出他的前任是谁。</span><br><span class="line">Action: search(&quot;蒂姆·库克的前任是谁&quot;)</span><br><span class="line">Observation: 蒂姆·库克的前任是苹果公司的创始人史蒂夫·乔布斯 (Steve Jobs)。</span><br><span class="line"></span><br><span class="line">Thought: 我已经获得了所有需要的信息：现任 CEO 是蒂姆·库克，前任是史蒂夫·乔布斯。我可以给出最终答案了。</span><br><span class="line">Action: finish(&quot;苹果公司的现任 CEO 是蒂姆·库克，他的前任是史蒂夫·乔布斯。&quot;)</span><br></pre></td></tr></table></figure><h2 id="11-2-实战案例">11.2 实战案例</h2><ul><li><a href="https://github.com/hedon-ai-road/react_rag">react-rag</a></li></ul><h1>12. RAG 相关思考</h1><ul><li><a href="https://www.woshipm.com/ai/6235363.html">企业大模型落地的现实解法：为什么 RAG 是绕不开的技术路径？</a></li><li><a href="https://blog.csdn.net/2401_84495872/article/details/148831083">不需要 RAG！手把手教你构建问答 Agent</a></li></ul>]]></content>
    
    
    <summary type="html">RAG 全栈技术</summary>
    
    
    
    <category term="ai" scheme="https://hedon.top/categories/ai/"/>
    
    <category term="rag" scheme="https://hedon.top/categories/ai/rag/"/>
    
    
    <category term="ai" scheme="https://hedon.top/tags/ai/"/>
    
    <category term="rag" scheme="https://hedon.top/tags/rag/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨03丨模块化</title>
    <link href="https://hedon.top/2025/07/02/fosa-ch3/"/>
    <id>https://hedon.top/2025/07/02/fosa-ch3/</id>
    <published>2025-07-02T03:00:26.000Z</published>
    <updated>2025-07-07T11:03:28.491Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第三章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>What is meant by the term <em>connascence</em>?</p><p>&quot;连接性&quot;这个术语是什么意思？</p></li><li><p>What is the difference between static and dynamic connascence?</p><p>静态连接性和动态连接性有什么区别？</p></li><li><p>What does <em>connascence of type</em> mean? Is it static or dynamic connascence?</p><p>类型连接性是什么意思？它是静态的还是动态的？</p></li><li><p>What is the strongest form of connascence?</p><p>连接性最强的形式是什么？</p></li><li><p>What is the weakest form of connascence?</p><p>连接性最弱的形式是什么？</p></li><li><p>Which is preferred within a code base—static or dynamic connascence?</p><p>在一个代码库中，静态连接性和动态连接性哪个更受青睐？</p></li></ol><hr><p>本篇的主题是 Modularity（模块化），谈到模块化，我们最常提到的一句话就是：“高内聚（cohesion）、低耦合（coupling）”。</p><ul><li>内聚是指模块内部各元素之间关联的紧密程度。高内聚意味着模块中的所有元素都紧密相关，并且共同为一个单一的、明确定义的目的服务。高内聚使模块的功能职责更加集中和明确，易于理解和修改。</li><li>耦合是指不同模块之间相互依赖的程度。低耦合意味着模块之间的依赖关系很弱，一个模块的改变对其他模块的影响尽可能小。低耦合降低了系统修改、测试和部署的风险。当系统的一个部分发生变化时，由于依赖关系较少，需要修改的其他部分也较少。</li></ul><p>课后题中提到的 connascence（连接性）跟耦合的概念很像。</p><blockquote><p>当一个组件的修改需要修改另外一个组件才能保持系统整体的正确性时，这两个组件就处于连接性状态。它衡量了软件组件之间相互依赖的程度。</p><p>连接性是对耦合度量的一种细化。虽然传统的耦合度量（如内向耦合和外向耦合）关注的是连接的方向，但连接性更进一步，关心组件之间如何耦合在一起。</p></blockquote><p>连接性可以分为 2 大类：</p><ul><li>静态连接性：指的是源代码级别的耦合，它可以通过简单的源代码分析来确定。<ul><li>命名连接性：多个组件必须就某个实体的名称达成一致。这是最弱的连接性形式，也是代码库中最理想的耦合方式，因为现代重构工具可以轻松实现系统范围内的名称更改。</li><li>类型连接性：多个组件必须就某个实体的类型达成一致。这在许多静态类型语言中很常见，例如变量和参数被限制为特定类型。</li><li>意义连接性 / 约定连接性：多个组件必须就某个值的含义或约定达成一致。</li><li>位置连接性：多个组件必须就某个实体在列表、记录或参数中的位置达成一致。</li><li>算法连接性：多个组件必须就某个特定算法达成一致。</li><li>执行连接性：多个组件必须就某个执行顺序或流程达成一致。</li></ul></li><li>动态连接性：指的是运行时的调用，这种很难确定，因为缺乏有效的运行时分析工具。<ul><li>执行连接性：不同语句的执行顺序很重要。例如一段代码中某些属性必须按特定顺序设置才能正确运行。</li><li>时序连接性：多个组件的执行时序很重要。通常发生在竞态条件中，即两个线程同时执行并影响联合操作的结果</li><li>值连接性：多个值之间相互关联，必须一起改变。</li><li>身份连接性：多个组件必须引用同一个实体。例如，两个独立的组件必须共享和更新一个公共数据结构。</li></ul></li></ul><p>连接性的强弱如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250702130438266.png" alt="FOSA Figure 3-5. The strength on connascence provides a good refactoring guide"></p><p>越往左上角，表示连接性越弱，也是我们编写代码时更希望看到的。</p><p>Page-Jones 提出了 3 个使用连接性来改善系统模块化的指导原则：</p><ol><li>通过将系统分解为封装的元素来最小化整体连接性；</li><li>最小化任何剩余的跨越封装边界的连接性；</li><li>最大化封装边界内的连接性。</li></ol><p>Jim Weirich 进一步给出了 2 条建议：</p><ol><li><strong>程度规则（Rule of Degree）</strong>：将强形式的连接性转换为弱形式的连接性。例如，可以通过重构将意义连接性（CoM）转换为命名连接性（CoN），即创建命名常量而不是使用&quot;魔法值&quot;。</li><li><strong>局部性规则（Rule of Locality）</strong>：随着软件元素之间距离的增加，使用弱形式的连接性。这意味着，如果组件彼此远离，则它们之间的耦合应尽可能松散，避免强连接性形式。</li></ol>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第三章的课后思考题，深入探讨模块化设计的核心概念——连接性（connascence），分析静态与动态连接性的区别、不同连接性形式的强弱程度，以及如何在代码库中合理选择连接性类型，帮助理解高内聚低耦合的实现原理和最佳实践。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨02丨架构思维</title>
    <link href="https://hedon.top/2025/07/01/fosa-ch2/"/>
    <id>https://hedon.top/2025/07/01/fosa-ch2/</id>
    <published>2025-07-01T03:00:26.000Z</published>
    <updated>2025-07-07T11:03:30.126Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第二章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>Describe the traditional approach of architecture versus development and explain why that approach no longer works.</p><p>描述传统意义上的架构与开发的方法，并解释为什么这种方法不再适用。</p></li><li><p>List the three levels of knowledge in the knowledge triangle and provide an example of each.</p><p>列出知识三角中的三个层次，并为每个层次提供一个示例。</p></li><li><p>Why is it more important for an architect to focus on technical breadth rather than technical depth?</p><p>为什么对于一位架构师而言，注重技术的广度而非深度会显得更为重要呢？</p></li><li><p>What are some of the ways of maintaining your technical depth and remaining hands-on as an architect?</p><p>作为架构师，有哪些方法可以保持技术深度并保持动手能力呢？</p></li></ol><hr><h1>1. 架构与开发方法</h1><p>在传统方法中，架构师与开发人员的职责是分离的，如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250701102459269.png" alt="FOSA Figure 2-1. Traditional view of architecture versus design"></p><p>架构师的职责：</p><ul><li>分析业务逻辑，以提取和定义架构特征</li><li>选择适合问题领域的架构模式和风格</li><li>创建系统的构建块 —— 组件</li></ul><p>开发者的职责：</p><ul><li>根据架构师交付的产出，创建类图</li><li>构建用户界面</li><li>开发和测试源代码</li></ul><p>这种传统方法的问题在于它是一种单向的&quot;移交&quot;模式。架构师在设计完成后将产物移交给开发团队，但架构师与开发人员之间存在物理和虚拟的障碍。这种方法不再适用的原因主要有以下几点：</p><ol><li><strong>信息丢失和脱节</strong>：架构师的决策有时无法有效传达给开发团队，而开发团队在实现过程中对架构产生的改变也鲜有反馈给架构师。</li><li><strong>缺乏协作与同步</strong>：唯一不变的就是变，业务是不断发展的，系统架构也是不断演进和迭代的。这种单向模式导致双方缺乏紧密、双向的合作，无法及时响应业务和技术变化，导致架构变得脆弱且难以维护。</li></ol><p>更适合现代软件开发的方法应如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250701102918334.png" alt="FOSA Figure 2.2. Making architecture work through collaboration"></p><p>在这种双向交互的方式中，架构师不再仅仅是交付设计产出，而是在整个软件生命周期中，不断对开发团队进行领导和指导，开发团队在实现过程也，也不断将遇到的问题和改变返回给架构师时，双方紧密合作、互通有无、共同前进。</p><h1>2. 知识三角</h1><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250701103512872.png" alt="FOSA Figure 2-3. The pyramid representing all knowledge"></p><p><strong>第一层 (底层)：你知道你知道的 (Stuff you know you know)</strong> 这是你知识体系的基石，是你明确掌握、能够熟练运用的技能和知识。它们是你的&quot;舒适区&quot;和核心竞争力。比如掌握编程语言（Go/Rust）的基本语法和常见框架。</p><p><strong>第二层 (中层)：你知道你不知道的 (Stuff you know you don’t know)</strong> 这是你已经意识到但尚未掌握的领域。你可能听说过某个技术、某个概念，知道它的存在和价值，但还没有系统学习或实践过。这是你明确的学习目标和成长方向。比如编程语言（Go/Rust）的编译原理和编译期优化技术。</p><p><strong>第三层 (顶层)：你不知道你不知道的 (Stuff you don’t know you don’t know)</strong> 这是你的认知盲区。你甚至不知道这些知识、技术或方法论的存在。它们往往是突破瓶颈、实现认知跃迁的关键，也是最大的风险和机遇所在。一个人的成长，很大程度上就是不断将第三层的 &quot;未知未知&quot;转化为第二层的&quot;已知未知&quot;的过程。比如 AI 领域中的各种新兴技术。</p><h1>3. 广度还是深度</h1><p>对于架构师而言，广度比深度要更重要，原因如下：</p><ol><li>架构师的职责不是&quot;做&quot;，而是&quot;选择怎么做&quot;。只有当架构师拥有广泛的知识宽度时，能在不同的业务场景中，通过权衡对比，选择出最适合当前业务的架构模式。</li><li>每个人的时间和精力是有限的，我们不可能同时精通所有的技术，所以架构师必须在广度和深度之间有所侧重。为了避免&quot;过时专业知识&quot;，架构师需要保持学习最新前沿技术，试图在多个领域保持深度会导致精力耗尽，只能牺牲部分深度以换取更大的广度。</li><li>软件架构中一切都是&quot;权衡&quot;。只知道一种解决方案的架构师是做不出权衡的，只有当知道多种解决方案，并清楚其中的优劣，才能在充满各种限制的现实场景中做出&quot;最不坏&quot;的架构设计。</li></ol><p>在笔者看来，为了后期可以更快、更扎实的扩展我们的广度，前期的&quot;深度探索&quot;尤为重要。拥有一个深度的知识领域，就像在浩瀚的知识海洋中打下了一个坚实的&quot;锚&quot;。当你学习新知识时，可以把它关联到你的“锚点”上，而不是让它漂浮在空中。正所谓：<strong>一通百通</strong>。</p><p>如果你深度研究过 Go 的 GMP 调度模型、goroutine 的实现、channel 的底层结构，你不仅仅是学会了 Go 的并发。你真正理解了<strong>用户态线程、M:N 调度、CSP (Communicating Sequential Processes) 模型</strong> 等核心概念。当你再去学习 Rust 的 <code>async/await</code> 和 <code>tokio</code> 时，你会发现虽然语法和所有权规则完全不同，但其背后的<strong>异步运行时、任务调度、Future/Executor 模型</strong> 等思想，都与你已有的知识体系遥相呼应。你的学习过程不再是死记硬背，而是<strong>比较、关联和迁移</strong>，效率极高。</p><p>所以，一个更完整、更理想的技术人员成长路径应该是：</p><ol><li><strong>职业前期 (深耕期)：</strong> <strong>深度优先，广度为辅。</strong> 选择一个你感兴趣且有前景的主航道（如 Go/Rust 后端开发），投入 80% 的精力向下猛扎，直到成为该领域的专家。用 20% 的精力保持对周边领域的关注。这个阶段的目标是 <strong>“立足”</strong>。</li><li><strong>职业中期 (拓展期)：</strong> <strong>深度与广度并重。</strong> 在你的根据地已经非常扎实之后，开始有意识地、系统性地拓展你的知识广度，将深耕期遇到的问题和知识点串联起来，形成体系。从 “I 型人才” 向 “T 型人才” 转变。这个阶段的目标是 <strong>“连接”</strong>。</li><li><strong>职业后期 (整合期)：</strong> <strong>广度优先，深度为基。</strong> 当你需要承担架构师、技术负责人等角色时，你的主要价值来自于广阔的视野和权衡决策能力。你过往的深度积累，则为你的决策提供了坚实的支撑和深刻的洞察力。这个阶段的目标是 <strong>“引领”</strong>。</li></ol><h1>4. 维持动手能力</h1><p>很多架构师与开发团队的协议日益疏远，很大程度源于架构师脱离一线开发环境太久了，以下是一些简单且有效保持技术深度和动手能力的方法：</p><ol><li><strong>避免&quot;瓶颈陷阱（bottleneck trap）&quot;并委派核心代码</strong>：架构师不应独自承担关键路径或框架代码的开发，因为这会使其成为团队的瓶颈。应将这些核心代码委派给开发团队。架构师可以专注于编码一到三个迭代后的业务功能（例如，一个服务或一个屏幕），从而既能获得实践经验，又能让开发团队拥有核心代码的所有权，并更好地理解他们在开发过程中可能遇到的问题。</li><li><strong>持续做概念验证（POCs）</strong>：POC 不仅要求架构师编写代码，还能通过实践验证架构决策。在这个过程中，架构师需要严格要求自己产出高质量的代码，因为开发团队后续的工作，很大程度会在 POC 的基础上进行扩展。</li><li><strong>处理技术债务</strong>：通常这些任务优先级较低，即使未能在一个迭代内完成，也不会对项目造成严重影响。这能让架构师获得实践编码经验，同时解放开发团队去处理关键功能用户故事。</li><li><strong>参与修复非紧急漏洞</strong>：处理 BUG 能够帮助架构师识别代码库乃至架构中的问题和弱点。</li><li><strong>构建效率提升工具</strong>：开发一些提升效率的小工具，一方面可以帮助开发团队更高效率地开展工作，另一方面也可以有效维持架构师的动手能力。</li><li><strong>编写适应性函数（Fitness Functions）</strong>：辅助编写单元测试、集成测试等自动化测试，一来能帮助架构师维持动手能力，二来能帮助架构师更深入理解项目细节，三来可以提高项目架构的健壮性。</li><li><strong>参与代码评审（Code Review）</strong>：代码评审能让架构师保持对代码库的参与度，同时确保架构合规性，并发现团队中的指导和辅导机会。</li></ol>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第二章的课后思考题，深入探讨传统架构方法的局限性、知识三角的三个层次、架构师技术广度与深度的平衡，以及架构师保持技术敏锐度的实践方法，帮助理解现代架构师应具备的思维模式。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
  </entry>
  
  <entry>
    <title>Go 底层原理丨深度剖析 Gin 框架核心机制：从 HTTP 请求生命周期到高性能设计哲学</title>
    <link href="https://hedon.top/2025/06/30/go-gin/"/>
    <id>https://hedon.top/2025/06/30/go-gin/</id>
    <published>2025-06-30T08:43:04.000Z</published>
    <updated>2025-07-01T02:19:16.360Z</updated>
    
    <content type="html"><![CDATA[<p>本篇笔者将尝试基于 <a href="https://github.com/gin-gonic/gin/tree/v1.10.1">Gin v1.10.1</a> 来进行一趟 Gin 源码之旅，为了使我们的学习更有方向，在开始之前，我们来思考一个问题：</p><blockquote><p>一个 HTTP 请求从抵达 Gin 到返回响应，其完整的旅程是怎样的？</p></blockquote><ol><li><strong>启动服务：</strong> <code>r.Run()</code> 究竟做了什么？（提示：它内部调用了 Go 标准库的 <code>http.ListenAndServe</code>）</li><li><strong>请求入口：</strong> 当一个请求到来，Go 的 <code>http.Server</code> 是如何将请求交给 Gin 的核心 <code>Engine</code> 处理的？（提示：<code>Engine</code> 本身就是一个 <code>http.Handler</code>）</li><li><strong>上下文创建：</strong> <code>gin.Context</code> 是在何时被创建的？它封装了什么？</li><li><strong>路由匹配：</strong> Gin 如何根据请求的 URL 快速找到对应的处理函数？</li><li><strong>中间件执行：</strong> <code>r.Use()</code> 添加的中间件是如何形成一个“调用链”的？<code>c.Next()</code> 的作用机制是什么？</li><li><strong>业务处理：</strong> 你的业务逻辑处理函数（Handler）是如何被调用的？</li><li><strong>响应返回：</strong> <code>c.JSON()</code> 或 <code>c.String()</code> 这样的函数，最终是如何将数据写入到 <code>http.ResponseWriter</code> 的？</li><li><strong>资源回收：</strong> <code>gin.Context</code> 对象在请求结束后是如何被回收的？（提示：<code>sync.Pool</code>）</li><li><strong>优雅关闭：</strong> 服务在关闭过程中，如何保证当前请求被正确完整处理？</li></ol><h2 id="从本篇中你可以学到什么">从本篇中你可以学到什么</h2><p>阅读本文，你将不仅仅是学会如何使用 Gin 框架，更是能深入到底层，理解其高效运作背后的原理。这趟旅程将为你揭示一个完整的 HTTP 请求在 Gin 中的生命周期，让你在未来的开发与面试中都更具深度和信心。</p><p>具体来说，你将收获以下核心知识点：</p><ul><li><strong>Go Web 服务核心原理</strong><ul><li>理解 Gin 的 <code>r.Run()</code> 如何封装并启动标准库的 <code>http.Server</code>。</li><li>掌握 Go <code>net/http</code> 服务如何通过 <code>net.Listener</code> 的 <code>Accept()</code> 循环来接收 TCP 连接，并为每个连接开启独立 Goroutine 进行处理的并发模型。</li></ul></li><li><strong>Gin 的高性能设计哲学</strong><ul><li>剖析 Gin 如何通过 <code>sync.Pool</code> 对象池技术来复用 <code>gin.Context</code>，从而大幅减少内存分配和 GC 压力，这是 Gin 高性能的关键之一。</li><li>学习 Go <code>http.Server</code> 中优雅关闭（<code>Shutdown</code>）的完整实现，包括：<ul><li>如何通过 <code>Context</code> 控制超时。</li><li>如何区分并分别处理<strong>监听器（Listener）</strong> 和<strong>连接（Connection）</strong>。</li><li>高效轮询等待中的<strong>指数退避（Exponential Backoff）</strong> 与<strong>抖动（Jitter）</strong> 策略。</li></ul></li></ul></li><li><strong>精巧的 Radix Tree 路由实现</strong><ul><li>深入理解 Gin 高性能路由的<strong>基数树（Radix Tree）实现原理</strong>，包括 <code>methodTrees</code> 的整体结构。</li><li>彻底搞懂路由 <code>node</code> 节点的每个字段的精确含义，特别是 <code>indices</code>（快速索引）和 <code>wildChild</code>（通配符标志）这两个性能优化的法宝。</li><li>掌握路由的<strong>查找（<code>getValue</code>）过程</strong>：包括前缀匹配、静态路由匹配、以及如何通过 <code>skippedNodes</code> 实现<strong>回溯（Backtracking）</strong> 机制来保证静态路由的优先级。</li><li>掌握路由的<strong>注册（<code>addRoute</code>）过程</strong>：包括最核心的<strong>节点分裂（Split Edge）</strong> 逻辑，以及如何通过 <code>panic</code> 来避免<strong>通配符冲突</strong>，从而在构建时就保证路由树的逻辑正确性。</li></ul></li><li><strong>中间件的洋葱模型</strong><ul><li>揭秘 Gin 中间件的核心 <code>c.Next()</code> 的工作机制，理解 <code>HandlersChain</code> 和 <code>index</code> 索引是如何协同工作，实现了优雅的“洋葱模型”调用链。</li></ul></li><li><strong>框架的扩展性与接口设计</strong><ul><li>了解 Gin 如何通过 <code>RouterGroup</code> 组合的方式，巧妙地为 <code>Engine</code> 和 <code>RouterGroup</code> 自身都实现 <code>IRouter</code> 接口，从而支持灵活的路由分组与嵌套。</li><li>学习 <code>c.JSON()</code> 背后的 <code>render.Render</code> 接口设计，理解其如何将不同格式（JSON、XML、HTML 等）的响应渲染逻辑解耦。</li></ul></li></ul><h2 id="启动服务-r-Run">启动服务 r.Run()</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr ...<span class="type">string</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">address := resolveAddress(addr)</span><br><span class="line">err = http.ListenAndServe(address, engine.Handler())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="地址解析">地址解析</h3><p>其中 resolveAddress 就是解析监听地址，默认为 <code>:8080</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolveAddress</span><span class="params">(addr []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(addr) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">// 如果没传地址</span></span><br><span class="line">    <span class="comment">// 先尝试从环境变量 PORT 中获取监听端口</span></span><br><span class="line"><span class="keyword">if</span> port := os.Getenv(<span class="string">&quot;PORT&quot;</span>); port != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;:&quot;</span> + port</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 默认 8080 端口</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;:8080&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// 传了地址，则使用传递的地址参数</span></span><br><span class="line"><span class="keyword">return</span> addr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 只允许传递一个地址，否则 panic</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;too many parameters&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动监听">启动监听</h3><p><code>r.Run()</code> 底层使用的其实还是标准库 <code>http</code> 的 <code>ListenAndServe()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> ListenAndServe() <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 如果服务正在关闭中，直接返回报错</span></span><br><span class="line">  <span class="keyword">if</span> s.shuttingDown() &#123;</span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 省略非核心代码</span></span><br><span class="line">ln, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line"><span class="keyword">return</span> s.Serve(ln)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心看 <code>s.Serve(ln)</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serve 方法会针对监听器 l 接收到来的连接建立新的服务协程。</span></span><br><span class="line"><span class="comment">// 每个服务协程会读取请求，并随后调用 s.Handler 来作出回应。</span></span><br><span class="line"><span class="comment">// 只有当监听器返回的连接是 [*tls.Conn] 类型，并且这些连接在 TLS 配置的 NextProtos 中设置了“h2”选项时，才会启用 HTTP/2 支持。</span></span><br><span class="line"><span class="comment">// 服务调用函数 always 会返回一个非空的错误，并关闭 l。</span></span><br><span class="line"><span class="comment">// 在 Server.Shutdown 或 Server.Close 之后，返回的错误为 ErrServerClosed。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 context</span></span><br><span class="line">baseCtx := context.Background()</span><br><span class="line"><span class="keyword">if</span> s.BaseContext != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 如果有自定义的 context 构造器，则使用自定义的来初始化</span></span><br><span class="line">baseCtx = s.BaseContext(origListener)</span><br><span class="line"><span class="keyword">if</span> baseCtx == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;BaseContext returned a nil context&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx := context.WithValue(baseCtx, ServerContextKey, s)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 监听客户端连接</span></span><br><span class="line">rw, err := l.Accept()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">connCtx := ctx</span><br><span class="line">    <span class="comment">// 初始化一个连接对象</span></span><br><span class="line">c := s.newConn(rw)</span><br><span class="line">c.setState(c.rwc, StateNew, runHooks) <span class="comment">// before Serve can return</span></span><br><span class="line"><span class="comment">// 服务这个连接对象</span></span><br><span class="line">    <span class="keyword">go</span> c.serve(connCtx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>服务基础 context 的初始化和相关状态处理，作为后面在每个连接上的请求响应的 gin.Context 的基础。</li><li>for 循环监听客户端连接。</li><li>为每个客户端建立 conn 连接对象。</li><li><code>c.serve(connCtx)</code> 服务每一个连接。</li></ol><h2 id="请求入口-c-serve-connCtx">请求入口 c.serve(connCtx)</h2><h3 id="连接握手">连接握手</h3><p>重点来看 <code>c.serve(connCtx)</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> serve(ctx context.Context) &#123;</span><br><span class="line"><span class="keyword">if</span> tlsConn, ok := c.rwc.(*tls.Conn); ok &#123;</span><br><span class="line"><span class="comment">// tls 握手</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超时控制</span></span><br><span class="line">ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">c.cancelCtx = cancelCtx</span><br><span class="line"><span class="keyword">defer</span> cancelCtx()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跟踪当前 listener，里面其实是一个 waitGroup，用于优雅重启确保监听器完全关闭</span></span><br><span class="line">  <span class="keyword">if</span> !s.trackListener(&amp;l, <span class="literal">true</span>) &#123;  <span class="comment">// 可以理解为 wg.Add(1)</span></span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">defer</span> s.trackListener(&amp;l, <span class="literal">false</span>)  <span class="comment">// 可以理解为 wg.Done()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 读取请求数据，返回的 w 是一个 response，用于响应数据</span></span><br><span class="line">w, err := c.readRequest(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 异常处理</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; 核心具体的 HTTP 处理函数</span></span><br><span class="line">serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束请求，响应数据</span></span><br><span class="line">w.finishRequest()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非长连接则直接返回，否则继续复用当前连接</span></span><br><span class="line"><span class="keyword">if</span> !w.conn.server.doKeepAlives() &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果配置了 TLS，则进行 TLS 加密握手；</li><li>创建超时控制 context，对于超时连接强制关闭；</li><li>for 循环 <code>c.readRequest(ctx)</code> 读取请求数据；</li><li>执行 <code>ServeHTTP(w, req)</code> 执行具体的 HTTP 处理业务；</li><li>结束请求，<code>w.finishRequest()</code> 响应数据；</li><li>非长连接则直接返回，释放连接，否则复用当前连接处理后续请求。</li></ol><h3 id="读取请求">读取请求</h3><p>其中 <code>c.readRequest()</code> 核心逻辑是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> readRequest(ctx context.Context) (w *response, err <span class="type">error</span>) &#123;</span><br><span class="line">req, err := readRequest(c.bufr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 一些请求检验和请求头的检查设置</span></span><br><span class="line"></span><br><span class="line">w = &amp;response&#123;</span><br><span class="line">conn:          c,</span><br><span class="line">cancelCtx:     cancelCtx,</span><br><span class="line">req:           req, <span class="comment">// 请求元数据</span></span><br><span class="line">reqBody:       req.Body,  <span class="comment">// 请求体</span></span><br><span class="line">handlerHeader: <span class="built_in">make</span>(Header),</span><br><span class="line">contentLength: <span class="number">-1</span>,</span><br><span class="line">closeNotifyCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>),</span><br><span class="line">wants10KeepAlive: req.wantsHttp10KeepAlive(),</span><br><span class="line">wantsClose:       req.wantsClose(),</span><br><span class="line">&#125;</span><br><span class="line">w.cw.res = w</span><br><span class="line">w.w = newBufioWriterSize(&amp;w.cw, bufferBeforeChunkingSize)</span><br><span class="line"><span class="keyword">return</span> w, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写回响应">写回响应</h3><p>其中 <code>c.finishRequest()</code> 核心逻辑是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *response)</span></span> finishRequest() &#123;</span><br><span class="line">  <span class="comment">// 标记处理完毕</span></span><br><span class="line">w.handlerDone.Store(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写 HTTP Status OK</span></span><br><span class="line"><span class="keyword">if</span> !w.wroteHeader &#123;</span><br><span class="line">w.WriteHeader(StatusOK)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将响应数据全部写入缓冲区，并回收缓冲区，后续复用</span></span><br><span class="line">w.w.Flush()</span><br><span class="line">putBufioWriter(w.w)</span><br><span class="line">w.cw.<span class="built_in">close</span>()</span><br><span class="line">w.conn.bufw.Flush()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空请求体相关数据，用于后续请求复用</span></span><br><span class="line">w.conn.r.abortPendingRead()</span><br><span class="line">w.reqBody.Close()</span><br><span class="line"><span class="keyword">if</span> w.req.MultipartForm != <span class="literal">nil</span> &#123;</span><br><span class="line">w.req.MultipartForm.RemoveAll()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上下文创建-回收-sync-Pool">上下文创建 &amp; 回收 sync.Pool</h2><p>现在我们进入 <code>ServeHTTP(w, req)</code> 执行具体的 HTTP 处理业务，这里会先为每一个请求创建上下文，然后再进行请求处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span></span> ServeHTTP(rw ResponseWriter, req *Request) &#123;</span><br><span class="line">handler := sh.srv.Handler</span><br><span class="line">handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line"><span class="comment">// 从 sync.Pool 对象池中获取一个 gin.Context</span></span><br><span class="line">  c := engine.pool.Get().(*Context)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置 gin.Context，使其与当前 request 绑定</span></span><br><span class="line">c.writermem.reset(w)</span><br><span class="line">c.Request = req</span><br><span class="line">c.reset()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理请求</span></span><br><span class="line">engine.handleHTTPRequest(c)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 gin.Context 返回 sync.Pool</span></span><br><span class="line">engine.pool.Put(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里使用了 <code>sync.Pool</code> 对象池来管理 <code>gin.Context</code> 对象，通过复用对象来避免重复创建和销毁带来的额外开销。</p><h2 id="路由匹配-sh-ServeHTTP">路由匹配 sh.ServeHTTP</h2><p>核心处理逻辑是 <code>engine.handleHTTPRequest(c)</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> handleHTTPRequest(c *Context) &#123;</span><br><span class="line">httpMethod := c.Request.Method</span><br><span class="line">rPath := c.Request.URL.Path</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消除请求路径中的重复斜杠，比如 /hello//user 会处理为 /hello/user</span></span><br><span class="line">  <span class="comment">// 这里在不同的版本默认策略是不一样的，在 1.5.0 版本是默认开启的，在 1.10.0 版本是关闭的！</span></span><br><span class="line"><span class="keyword">if</span> engine.RemoveExtraSlash &#123;</span><br><span class="line">rPath = cleanPath(rPath)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找请求路由对应的处理器，并执行。</span></span><br><span class="line">t := engine.trees</span><br><span class="line"><span class="keyword">for</span> i, tl := <span class="number">0</span>, <span class="built_in">len</span>(t); i &lt; tl; i++ &#123;</span><br><span class="line"><span class="comment">// 将下文详细分析</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果设置了 HandleMethodNotAllowed，则会在找不到对应路由的情况下，</span></span><br><span class="line">  <span class="comment">// 尝试在 Allow Header 中返回相同路由，但是不同 HTTP Method 的处理器。</span></span><br><span class="line"><span class="keyword">if</span> engine.HandleMethodNotAllowed &#123;</span><br><span class="line">allowed := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(t)<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> _, tree := <span class="keyword">range</span> engine.trees &#123;</span><br><span class="line"><span class="keyword">if</span> tree.method == httpMethod &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> value := tree.root.getValue(rPath, <span class="literal">nil</span>, c.skippedNodes, unescape); value.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">allowed = <span class="built_in">append</span>(allowed, tree.method)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(allowed) &gt; <span class="number">0</span> &#123;</span><br><span class="line">c.handlers = engine.allNoMethod</span><br><span class="line">c.writermem.Header().Set(<span class="string">&quot;Allow&quot;</span>, strings.Join(allowed, <span class="string">&quot;, &quot;</span>))</span><br><span class="line">serveError(c, http.StatusMethodNotAllowed, default405Body)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找不到对应的路由，返回 404</span></span><br><span class="line">c.handlers = engine.allNoRoute</span><br><span class="line">serveError(c, http.StatusNotFound, default404Body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由树结构-methodTrees">路由树结构 methodTrees</h3><p>这里我们重点来看一下 Gin 的路由树是怎样的，先看一下数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gin Engine</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">trees            methodTrees</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法路由树</span></span><br><span class="line"><span class="keyword">type</span> methodTree <span class="keyword">struct</span> &#123;</span><br><span class="line">method <span class="type">string</span></span><br><span class="line">root   *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由树节点</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">path      <span class="type">string</span></span><br><span class="line">indices   <span class="type">string</span></span><br><span class="line">wildChild <span class="type">bool</span></span><br><span class="line">nType     nodeType</span><br><span class="line">priority  <span class="type">uint32</span></span><br><span class="line">children  []*node <span class="comment">// child nodes, at most 1 :param style node at the end of the array</span></span><br><span class="line">handlers  HandlersChain</span><br><span class="line">fullPath  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法路由树列表</span></span><br><span class="line"><span class="keyword">type</span> methodTrees []methodTree</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> handleHTTPRequest(c *Context) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  t := engine.trees</span><br><span class="line">  <span class="keyword">for</span> i, tl := <span class="number">0</span>, <span class="built_in">len</span>(t); i &lt; tl; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> t[i].method != httpMethod &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    root := t[i].root</span><br><span class="line">    value := root.getValue(rPath, c.params, c.skippedNodes, unescape)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250630195928403.png" alt="Gin 路由树结构示意图"></p><h3 id="路由树节点-node">路由树节点 node</h3><p>这里我们重点解释下 <code>node</code> 结果中的字段含义，这对后续的路由查找分析非常重要：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">path      <span class="type">string</span>    <span class="comment">// 当前节点所代表的 URL 路径片段</span></span><br><span class="line">indices   <span class="type">string</span>    <span class="comment">// 子节点的索引，用于快速查找</span></span><br><span class="line">wildChild <span class="type">bool</span>      <span class="comment">// 标志位，表示是否存在通配符子节点（:param 或 *catchall）</span></span><br><span class="line">nType     nodeType  <span class="comment">// 节点的类型（静态、参数、通配符等）</span></span><br><span class="line">priority  <span class="type">uint32</span>    <span class="comment">// 节点的优先级，用于路由注册时的排序</span></span><br><span class="line">children  []*node   <span class="comment">// 子节点列表</span></span><br><span class="line">handlers  HandlersChain <span class="comment">// 匹配该节点路径时，需要执行的处理函数链（包含中间件和主 handler）</span></span><br><span class="line">fullPath  <span class="type">string</span>    <span class="comment">// 完整的路由注册路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-path-string">1. path string</h4><ul><li><strong>含义</strong>：这个字段存储了当前节点所代表的 <strong>URL 路径片段</strong> 或 <strong>公共前缀</strong>。它不是完整的 URL 路径，而是树中一个分支的字符串。基数树会尽可能地将多个路由的公共前缀合并到一个 <code>path</code> 中以节省空间。</li><li>举例：假设你注册了两个路由：/user/profile 和 /user/settings。那么可能会有一个父节点的 path 是 /user/，然后它有两个子节点，一个 path 是 profile，另一个是 settings。</li></ul><h4 id="2-indices-string">2. indices string</h4><ul><li><p><strong>含义</strong>：这是一个非常巧妙的性能优化字段。它是一个字符串，其中每个字符都是对应 <code>children</code> 切片中子节点的 <code>path</code> 的 <strong>第一个字符</strong>。它的作用是作为 <code>children</code> 的一个快速查找索引。当需要寻找下一个节点时，程序只需用请求路径的下一个字符来和 <code>indices</code> 进行匹配，就能立刻知道应该访问 <code>children</code> 中的哪个元素，而无需遍历整个 <code>children</code> 切片。</p></li><li><p>举例：一个父节点 n 的 path 是 /。它有三个子节点，path 分别是 articles、blog 和 contact。</p><ul><li><p><code>n.children[0].path</code> = “articles”</p></li><li><p><code>n.children[1].path</code> = “blog”</p></li><li><p><code>n.children[2].path</code> = “contact”</p><p>那么，n.indices 的值就会是 “abc”。</p><p>当一个请求 /blog/test 到来时，程序匹配完父节点的 / 后，看到下一个字符是 b，它直接在 indices (“abc”) 中找到 b 是第二个字符，于是就直接去访问 children[1]，非常高效。</p></li></ul></li></ul><h4 id="3-wildChild-bool">3. wildChild bool</h4><ul><li><strong>含义</strong>：一个布尔标志位。如果为 <code>true</code>，表示这个节点的子节点中 <strong>存在一个通配符节点</strong>（即 <code>:param</code> 或 <code>*catchall</code> 类型的节点）。</li><li><strong>作用</strong>：这同样是一个性能优化。在路由查找时，如果静态子节点（通过 <code>indices</code>）没有匹配上，程序只需检查 <code>wildChild</code> 这一个布尔值，就能快速知道是否需要进一步尝试匹配通配符子节点，避免了额外的条件判断。根据约定，通配符子节点永远是 <code>children</code> 数组的最后一个元素。</li></ul><h4 id="4-nType-nodeType">4. nType nodeType</h4><ul><li><strong>含义</strong>：表示当前节点的类型。<code>nodeType</code> 是一个整数类型，通常有以下几种值：<ul><li><code>static</code> (静态)：节点的 <code>path</code> 是一个固定的字符串，例如 <code>/about</code>。</li><li><code>root</code> (根)：整棵树的根节点。</li><li><code>param</code> (参数)：表示一个命名参数，例如 <code>:id</code>。路径 <code>/users/:id</code> 中的 <code>:id</code> 部分就是一个 <code>param</code> 类型的节点。</li><li><code>catchAll</code> (通配符)：表示一个“全匹配”参数，例如 <code>*filepath</code>。路径 <code>/static/*filepath</code> 中的 <code>*filepath</code> 就是一个 <code>catchAll</code> 类型的节点。</li></ul></li><li><strong>作用</strong>：在路由查找时，<code>getValue</code> 函数通过 <code>switch n.nType</code> 来决定如何处理当前节点和剩余的请求路径。例如，遇到 <code>param</code> 类型就要提取参数值，遇到 <code>catchAll</code> 就要捕获所有剩余路径。</li></ul><h4 id="5-priority-uint32">5. priority uint32</h4><ul><li><strong>含义</strong>：节点的优先级。这个值在 <strong>构建路由树</strong> 的时候使用，而不是在请求时查找时使用。</li><li><strong>作用</strong>：它的值是根据注册到这个节点的路由数量以及其子孙节点的路由数量计算出来的。当插入新路由可能导致树结构冲突时，<code>priority</code> 可以帮助算法决定如何拆分和重组节点，以保持树的正确性和高效性。简单来说，它代表了一个节点的&quot;权重&quot;或&quot;繁忙程度&quot;。</li></ul><h4 id="6-children-node">6. children []*node</h4><ul><li><strong>含义</strong>：一个 <code>*node</code> 指针的切片，存储了所有直接的子节点。这是构成树状结构的核心字段。</li><li><strong>规则</strong>：这个切片有一个重要规则：如果存在通配符子节点（<code>:param</code> 或 <code>*catchall</code>），它 <strong>必须并且只能是切片中的最后一个元素</strong>。静态子节点（<code>static</code>）则排在前面，它们的顺序与 <code>indices</code> 字符串中字符的顺序一一对应。</li></ul><h4 id="7-handlers-HandlersChain">7. handlers HandlersChain</h4><ul><li><strong>含义</strong>：<code>HandlersChain</code> 本质上是一个 <code>[]HandlerFunc</code>，也就是一个处理函数的切片。</li><li><strong>作用</strong>：这是路由查找的最终目标。当一个请求的 URL 完整匹配到某个节点时，这个节点的 <code>handlers</code> 字段就包含了需要被执行的所有函数，这其中可能包括多个中间件（Middleware）和最终处理业务逻辑的那个主函数（Handler）。如果一个节点的 <code>handlers</code> 为 <code>nil</code>，说明它只是一个中间路径节点，不能直接处理请求。</li></ul><h4 id="8-fullPath">8. fullPath</h4><ul><li><p><strong>含义</strong>：存储了用户在代码中定义的 <strong>完整的、原始的路由注册字符串</strong>。</p></li><li><p><strong>作用</strong>：</p><ol><li><strong>调试与日志</strong>：在中间件或日志系统中，你可以通过 <code>c.FullPath()</code> （它读取的就是这个值）获知当前请求匹配到的是哪条原始路由规则，这对于监控和问题排查非常有用。</li><li><strong>模板渲染或 URL 生成</strong>：在某些场景下，你可能需要根据路由名称或模式来生成 URL，<code>fullPath</code> 提供了这个原始模式。</li></ol></li><li><p>举例：</p><p>你注册了 router.GET(“/users/:id/profile”, …).</p><p>这会被拆分成多个 node。假设最终匹配到 profile 那个 node：</p><ul><li>它的 <code>path</code> 可能是 <code>&quot;profile&quot;</code>。</li><li>但它的 <code>fullPath</code> 会是 <code>&quot;/users/:id/profile&quot;</code>。</li></ul></li></ul><h4 id="总结">总结</h4><p>这 8 个字段协同工作，共同构建了一个既节省内存又查找飞快的路由树。</p><ul><li><code>path</code>, <code>children</code>, <code>nType</code> 定义了树的 <strong>基本结构和逻辑</strong>。</li><li><code>indices</code> 和 <code>wildChild</code> 是为了 <strong>极致性能</strong> 而设计的巧妙索引。</li><li><code>handlers</code> 和 <code>fullPath</code> 存储了路由的 <strong>最终目标和元数据</strong>。</li><li><code>priority</code> 则在幕后默默地保证了这棵树在动态构建过程中的 <strong>稳定性和合理性</strong>。</li></ul><h3 id="路由定位-root-GetValue">路由定位 root.GetValue</h3><p>接下来我们来看 <code>root.GetValue()</code> 具体是如何定位路由处理器的，这个方法非常长，我们逐一分解。</p><p>好的，我们来一起深入解析一下 Gin 框架中这个核心的路由查找函数 <code>(n *node) getValue</code>。</p><p>这是一个非常精妙的函数，它的背后是高性能路由技术的典型实现。为了真正理解它，我们需要遵循“由表及里、由浅入深”的原则，从它的目标、使用的数据结构，再到具体的代码执行逻辑，一步步进行剖析。</p><h4 id="第-1-步：前缀匹配">第 1 步：前缀匹配</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prefix := n.path</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="built_in">len</span>(prefix) &#123;</span><br><span class="line">    <span class="keyword">if</span> path[:<span class="built_in">len</span>(prefix)] == prefix &#123;</span><br><span class="line">        path = path[<span class="built_in">len</span>(prefix):]</span><br><span class="line">        <span class="comment">// ... 继续寻找子节点</span></span><br></pre></td></tr></table></figure><p>这是基数树最基本的操作。代码首先检查当前请求路径 <code>path</code> 是否以当前节点 <code>n</code> 的路径 <code>n.path</code> 为前缀。</p><ul><li><strong>如果匹配</strong>：说明路径的前半部分对了，然后从 <code>path</code> 中“砍掉”已经匹配上的前缀，准备在子节点中继续匹配剩余的 <code>path</code>。</li><li><strong>如果不匹配</strong>：说明走错路了，需要回溯或直接返回未找到。</li></ul><h4 id="第-2-步：在子节点中选择-道路-静态路由">第 2 步：在子节点中选择&quot;道路&quot; (静态路由)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">idxc := path[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> []<span class="type">byte</span>(n.indices) &#123;</span><br><span class="line">    <span class="keyword">if</span> c == idxc &#123;</span><br><span class="line">        n = n.children[i]</span><br><span class="line">        <span class="keyword">continue</span> walk</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在砍掉前缀后，<code>path</code> 是剩余的待匹配路径。<code>idxc := path[0]</code> 取出剩余路径的第一个字符。然后，代码遍历 <code>n.indices</code> 这个“索引目录”。</p><ul><li><code>n.indices</code> 存储了所有子节点的路径的第一个字符。</li><li>如果 <code>idxc</code> 在 <code>n.indices</code> 中找到了匹配项 <code>c</code>，就意味着存在一个正确的子节点可以继续走下去。</li><li><code>n = n.children[i]</code> 将当前节点 <code>n</code> 更新为找到的子节点。</li><li><code>continue walk</code> 跳回到 <code>walk</code> 循环的开始，在新节点上重复 <strong>第 1 步</strong> 的前缀匹配。</li></ul><p>这个设计非常高效，因为它避免了对 <code>children</code> 切片的完整遍历，而是通过一个字符的比较就快速定位了下一个节点。</p><h4 id="第-3-步：处理-岔路口-通配符-Wildcard">第 3 步：处理&quot;岔路口&quot; - 通配符 (Wildcard)</h4><p>如果静态路由没找到（<code>for</code> 循环结束），程序会检查是否存在通配符子节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !n.wildChild &#123;</span><br><span class="line">    <span class="comment">// ... 没有通配符子节点，处理找不到的情况</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle wildcard child, which is always at the end of the array</span></span><br><span class="line">n = n.children[<span class="built_in">len</span>(n.children)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> n.nType &#123;</span><br><span class="line"><span class="keyword">case</span> param:</span><br><span class="line"><span class="keyword">case</span> catchAll:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>n.wildChild</code> 是一个布尔值，表示当前节点是否有一个通配符子节点（<code>:param</code> 或 <code>*catchall</code>）。按照约定，通配符子节点永远是 <code>children</code> 数组的最后一个元素。如果存在，就直接跳到这个通配符节点继续匹配。</p><p>接着，<code>switch n.nType</code> 根据通配符节点的类型进行处理：</p><ul><li><strong><code>case param</code> (例如 <code>/users/:id</code>)</strong>:<ul><li>它会从剩余的 <code>path</code> 中&quot;截取&quot;出参数值。截取的规则是到下一个 <code>/</code> 或者路径末尾。</li><li>例如，如果 <code>path</code> 是 <code>123/profile</code>，它会截取出 <code>123</code> 作为参数值。</li><li>然后将参数的键（如 <code>id</code>）和值（如 <code>123</code>）存入 <code>params</code>。</li><li>如果 <code>/</code> 后面还有路径（如 <code>profile</code>），则继续在当前参数节点的子节点中进行 <code>walk</code>。</li></ul></li><li><strong><code>case catchAll</code> (例如 <code>/static/*filepath</code>)</strong>:<ul><li>这就更简单了，它会把 <strong>所有</strong> 剩余的 <code>path</code> 都作为参数值。</li><li>例如，如果 <code>path</code> 是 <code>css/main.css</code>，整个字符串都会被捕获。</li><li><code>catchAll</code> 节点一定是路径的终点，找到后直接返回结果。</li></ul></li></ul><h4 id="第-4-步：到达终点与-没路了-的处理">第 4 步：到达终点与&quot;没路了&quot;的处理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> path == prefix &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里说明已经找到了&quot;终点&quot;，进行最后的一系列检查。</p><p>第一种情况：到达真终点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We should have reached the node containing the handle.</span></span><br><span class="line"><span class="comment">// Check if this node has a handle registered.</span></span><br><span class="line"><span class="keyword">if</span> value.handlers = n.handlers; value.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">    value.fullPath = n.fullPath</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最完美的情况！我们找到了一个与请求路径完全匹配的节点，并且这个节点上确实注册了至少一个处理函数，这里我们设置好 fullPath 属性然后就可以直接返回了。</p><p>第二种情况：到达假终点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the current path does not equal &#x27;/&#x27; and the node does not have a registered handle and the most recently matched node has a child node</span></span><br><span class="line"><span class="comment">// the current node needs to roll back to last valid skippedNode</span></span><br><span class="line"><span class="keyword">if</span> n.handlers == <span class="literal">nil</span> &amp;&amp; path != <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">  <span class="comment">// skippedNodes 记录了所有我们路过的、存在&quot;岔路口&quot;（即有其他路径可选）的节点。</span></span><br><span class="line">    <span class="keyword">for</span> length := <span class="built_in">len</span>(*skippedNodes); length &gt; <span class="number">0</span>; length-- &#123;  <span class="comment">// 从后往前遍历</span></span><br><span class="line">        skippedNode := (*skippedNodes)[length<span class="number">-1</span>] <span class="comment">// 取出最近的一个岔路口</span></span><br><span class="line">        *skippedNodes = (*skippedNodes)[:length<span class="number">-1</span>] <span class="comment">// 将其从&quot;待办列表&quot;中移除。</span></span><br><span class="line">        <span class="keyword">if</span> strings.HasSuffix(skippedNode.path, path) &#123;  <span class="comment">// 判断这个岔路口的完整路径是否以我们当前这个&quot;死胡同&quot;路径结尾。</span></span><br><span class="line">          path = skippedNode.path  <span class="comment">// 如果检查通过，就意味着我们找到了一个可以&quot;复活&quot;的存档点</span></span><br><span class="line">          n = skippedNode.node  <span class="comment">// 滚到当时路过那个岔路口的状态</span></span><br><span class="line">          <span class="keyword">if</span> value.params != <span class="literal">nil</span> &#123;</span><br><span class="line">            *value.params = (*value.params)[:skippedNode.paramsCount]</span><br><span class="line">          &#125;</span><br><span class="line">          globalParamsCount = skippedNode.paramsCount</span><br><span class="line">          <span class="keyword">continue</span> walk <span class="comment">// 读档后，选择另一条路重新开始走</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 检查不通过，说明没有&quot;后悔药&quot;可以吃了，查找失败。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们到达了节点 <code>n</code>，但这个节点的 <code>handlers</code> 是 <strong><code>nil</code></strong>！并且，为了避免对根路径 <code>/</code> 的误判，加了 <code>path != &quot;/&quot;</code> 的条件。</p><p>这意味着我们走到了一个&quot;死胡同&quot;或者说一个&quot;假终点&quot;。路径虽然匹配了，但这只是一个中间节点（例如 <code>/users</code>），它本身不能处理请求，真正的终点在它的子节点上（例如 <code>/users/list</code> 或 <code>/users/:id</code>）。但我们的请求路径已经用完了，无法再往下走了。</p><blockquote><p><strong>为什么会发生这种情况？</strong> 这通常发生在有路由冲突或歧义时，路由器“贪婪地”选择了一条看似正确但实际上是死胡同的路。</p><p>试想一下情况：</p><ol><li>注册路由 A: <code>/users/new</code> (静态)</li><li>注册路由 B: <code>/users/:id</code> (动态)</li><li>用户请求: <code>GET /users/new</code></li></ol><p>路由器在匹配完 <code>/users/</code> 后，剩下 <code>new</code>。此时它面临一个选择：是匹配静态的 <code>new</code> 节点，还是匹配动态的 <code>:id</code> 节点？虽然 Gin 会优先匹配静态节点，但我们可以设想一个场景：如果 <code>/users/new</code> 这个路由<strong>没有注册 handler</strong>（开发者忘了写），而 <code>/users/:id</code> 注册了。</p><p>当请求 <code>/users/new</code> 时，它会先走到 <code>new</code> 节点。发现 <code>handlers</code> 是 <code>nil</code>，于是就进入了这个回溯逻辑。</p></blockquote><h4 id="第-5-步：智能建议-TSR-Trailing-Slash-Redirect"><strong>第 5 步：智能建议 - TSR (Trailing Slash Redirect)</strong></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We can recommend to redirect to the same URL without a</span></span><br><span class="line"><span class="comment">// trailing slash if a leaf exists for that path.</span></span><br><span class="line">value.tsr = path == <span class="string">&quot;/&quot;</span> &amp;&amp; n.handlers != <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p><code>tsr</code> 是 Gin 的一个非常人性化的功能。</p><ul><li><strong>场景 1</strong>: 你注册了 <code>/users</code>，但用户请求了 <code>/users/</code>。</li><li><strong>场景 2</strong>: 你注册了 <code>/users/</code>，但用户请求了 <code>/users</code>。</li></ul><p>在这两种情况下，Gin 不会直接返回 <code>404 Not Found</code>。<code>getValue</code> 函数在发现“几乎”匹配（就差一个尾部斜杠）时，会将 <code>value.tsr</code> 设置为 <code>true</code>。上层逻辑接收到这个 <code>true</code> 信号后，就会向客户端返回一个 <code>301</code> 或 <code>307</code> 重定向建议，告诉浏览器应该访问另一个带或不带斜杠的 URL。这提升了用户体验。</p><h4 id="第-6-步：回溯-Backtracking"><strong>第 6 步：回溯 (Backtracking)</strong></h4><p>这是函数中最复杂，但也最能体现其强大的部分。这里的逻辑跟第 4 步中到达&quot;假终点&quot;大致是相同的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the current node needs to roll back to last valid skippedNode</span></span><br><span class="line"><span class="keyword">for</span> length := <span class="built_in">len</span>(*skippedNodes); length &gt; <span class="number">0</span>; length-- &#123;</span><br><span class="line">    skippedNode := (*skippedNodes)[length<span class="number">-1</span>]</span><br><span class="line">    *skippedNodes = (*skippedNodes)[:length<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> strings.HasSuffix(skippedNode.path, path) &#123;</span><br><span class="line">        <span class="comment">// ... 回滚状态，重新 walk</span></span><br><span class="line">        <span class="keyword">continue</span> walk</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是考虑以下路由：</p><ol><li><code>/users/:id</code></li><li><code>/users/new</code></li></ol><p>我们假设另外一种情况，当一个请求 <code>GET /users/new</code> 到来时：</p><ol><li>它首先匹配到 <code>/users/</code> 前缀。</li><li>剩下的路径是 <code>new</code>。此时，它既可能匹配静态的 <code>new</code>，也可能匹配参数 <code>:id</code>。</li><li>大多数路由器的实现会优先匹配静态路径。但<strong>如果 <code>getValue</code> 先进入了 <code>:id</code> 的分支</strong>，它会把 <code>new</code> 当作 <code>:id</code> 的值。如果 <code>:id</code> 节点下没有更多子路径，查找就会失败。</li><li>这时，就需要回溯。<code>skippedNodes</code> 记录了&quot;上一个有其他选择的路口&quot;（例如，那个同时存在静态子节点和通配符子节点的 <code>/users/</code> 节点）。</li><li>代码会回退到那个路口，并尝试另一条路（即匹配 <code>new</code> 静态路径），最终找到正确的 <code>handlers</code>。</li></ol><p>这个机制确保了 <strong>静态路由的优先级总是高于通配符路由</strong>，即使它们的路径结构很相似。</p><h4 id="总结-2">总结</h4><p><code>Gin</code> 的 <code>(n *node) getValue</code> 函数是一个基于基数树 (Radix Tree) 的、高度优化的路由查找实现。它的执行过程可以概括为：</p><ol><li><strong>循路前进</strong>：沿着基数树，通过前缀匹配 (<code>n.path</code>) 和索引查找 (<code>n.indices</code>)，快速匹配 URL 的静态部分。</li><li><strong>灵活应变</strong>：当遇到通配符节点 (<code>:param</code> 或 <code>*catchall</code>) 时，能正确解析路径参数。</li><li><strong>终点判断</strong>：当路径完全匹配时，检查当前节点是否有 <code>handlers</code>，有则成功返回。</li><li><strong>智能容错</strong>：当精确匹配失败，但存在仅差一个尾部斜杠的路由时，会给出重定向建议 (TSR)。</li><li><strong>迷途知返</strong>：通过 <code>skippedNodes</code> 机制实现回溯，确保在有多种可能匹配路径（静态 vs 通配符）时，能够做出正确的选择，保证路由匹配的准确性。</li></ol><p>通过这些精巧的设计，Gin 在保证强大功能的同时，实现了极高的路由性能。</p><p>我画了个流程图，供你参考：</p><pre class="mermaid">graph TD    subgraph MainProcess [主流程]        direction TB        A["getValue(path, ...)"]:::startend        %% Stage 1: Traversal Loop        subgraph TraversalPhase ["第一阶段：遍历深入 (WALK 循环)"]            direction TB            W["<b>循环开始</b><br>在当前节点 n"]:::process            C1{"路径前缀匹配 且 路径有剩余?"}:::decision            P1["削减已匹配路径"]:::process            C2{"匹配静态子节点?"}:::decision            P2["记录回溯点(skippedNodes)<br>n = <b>进入静态子节点</b>"]:::process            C3{"有通配符子节点?"}:::decision            P3["n = <b>进入通配符子节点</b>"]:::process            C4{"节点类型是 :param?"}:::decision            P4["处理 :param, 截取并保存参数"]:::process            C5{"参数后还有剩余路径?"}:::decision        end        %% Stage 2: Final Adjudication        Junction["<br>无法继续深入<br><b>转到最终裁决</b><br>"]:::decision        subgraph FinalAdjudication [第二阶段：最终裁决]            direction TB            C_FINAL_BACKTRACK{"需要回溯?<br>(当前节点无 handler)"}:::decision            P_FINAL_BACKTRACK["<b>执行回溯</b><br>遍历 skippedNodes 查找备用路径<br>若找到, 则恢复现场"]:::process            C_FINAL_HANDLER{"找到 handler?<br>(n.handlers != nil)"}:::decision            SUCCESS["<b>成功</b><br>返回 value (含 handlers)"]:::startend            P_FINAL_TSR["<b>TSR 检查</b><br>检查是否存在 +/- 斜杠的“近亲”路由"]:::process            FINAL_RETURN["返回 value<br>(可能含 TSR, 或为空)"]:::startend        end        B4_CatchAll["<b>处理 *catchAll</b><br>截取所有剩余路径<br>保存参数, 赋值 handlers<br><b>直接成功返回</b>"]:::startend        %% --- Connections (Corrected Syntax) ---        A --> W        W --> C1        %% Traversal Logic        C1 -- "是(Yes)" --> P1        P1 --> C2        C2 -- "是(Yes)" --> P2        P2 -- "进入下一轮" --> W        C2 -- "否(No)" --> C3        C3 -- "是(Yes)" --> P3        P3 --> C4        C4 -- "是(Yes)" --> P4        P4 --> C5        C5 -- "是(Yes)" --> W        C4 -- "否(No), 是 *catchAll" --> B4_CatchAll        %% Exits from Traversal to Adjudication        C1 -- "否(No)" --> Junction        C3 -- "否(No): 无路可走" --> Junction        C5 -- "否(No): 路径耗尽" --> Junction        %% Adjudication Logic        Junction --> C_FINAL_BACKTRACK        C_FINAL_BACKTRACK -- "是(Yes)" --> P_FINAL_BACKTRACK        P_FINAL_BACKTRACK -- "回到循环" --> W        C_FINAL_BACKTRACK -- "否(No): 无需回溯" --> C_FINAL_HANDLER        C_FINAL_HANDLER -- "是(Yes)" --> SUCCESS        C_FINAL_HANDLER -- "否(No)" --> P_FINAL_TSR        P_FINAL_TSR --> FINAL_RETURN    end    %% Styling    classDef startend fill:#9f9,stroke:#333,stroke-width:2px,color:#000    classDef panic fill:#f99,stroke:#333,stroke-width:2px,color:#000    classDef decision fill:#ffc,stroke:#333,stroke-width:2px,color:#000    classDef process fill:#9cf,stroke:#333,stroke-width:2px,color:#000</pre><h2 id="中间件执行-c-Next">中间件执行 c.Next</h2><h3 id="执行机制">执行机制</h3><p>经过路由匹配，我们找到了处理当前请求的节点，返回的 <code>value</code> 结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> nodeValue <span class="keyword">struct</span> &#123;</span><br><span class="line">handlers HandlersChain</span><br><span class="line">params   *Params</span><br><span class="line">tsr      <span class="type">bool</span></span><br><span class="line">fullPath <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中处理函数就是 <code>handlers</code>，它是类型的 <code>HandlersChain</code>，其实就是 <code>[]HandleFunc</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlersChain defines a HandlerFunc slice.</span></span><br><span class="line"><span class="keyword">type</span> HandlersChain []HandlerFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc defines the handler used by gin middleware as return value.</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br></pre></td></tr></table></figure><p>在 <code>engine.handleHTTPRequest()</code> 中，找到了处理节点后，执行了下面 4 行代码，其中核心就是 <code>c.Next()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.handlers = value.handlers</span><br><span class="line">c.fullPath = value.fullPath</span><br><span class="line">c.Next()</span><br><span class="line">c.writermem.WriteHeaderNow()</span><br></pre></td></tr></table></figure><p>我们来看一下 <code>c.Next()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">handlers HandlersChain <span class="comment">// 请求链路</span></span><br><span class="line">index    <span class="type">int8</span>          <span class="comment">// 当前处理的 HandleFunc 在 handlers 中的索引</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Next() &#123;</span><br><span class="line">c.index++</span><br><span class="line"><span class="keyword">for</span> c.index &lt; <span class="type">int8</span>(<span class="built_in">len</span>(c.handlers)) &#123;</span><br><span class="line">c.handlers[c.index](c)</span><br><span class="line">c.index++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> reset() &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">c.handlers = <span class="literal">nil</span></span><br><span class="line">  c.index = <span class="number">-1</span>  <span class="comment">// 这里初始值是 -1，因为第一次执行 Next() 的时候，会 c.index++</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的逻辑其实简单，就是通过递增 <code>index</code> 依次执行 <code>HandlersChain</code>。</p><p>我们顺带看一下 <code>c.Abort()</code>，真是聪明！将 index 设置为 abortIndex，这样后面的 handler 就执行不到了！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Abort() &#123;</span><br><span class="line">c.index = abortIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口实现">接口实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRouter defines all router handle interface includes single and group router.</span></span><br><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span> &#123;</span><br><span class="line">IRoutes</span><br><span class="line">Group(<span class="type">string</span>, ...HandlerFunc) *RouterGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IRoutes defines all router handle interface.</span></span><br><span class="line"><span class="keyword">type</span> IRoutes <span class="keyword">interface</span> &#123;</span><br><span class="line">Use(...HandlerFunc) IRoutes</span><br><span class="line">Handle(<span class="type">string</span>, <span class="type">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">Any(<span class="type">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">GET(<span class="type">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">POST(<span class="type">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">DELETE(<span class="type">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">PATCH(<span class="type">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">PUT(<span class="type">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">OPTIONS(<span class="type">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">HEAD(<span class="type">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">Match([]<span class="type">string</span>, <span class="type">string</span>, ...HandlerFunc) IRoutes</span><br><span class="line">StaticFile(<span class="type">string</span>, <span class="type">string</span>) IRoutes</span><br><span class="line">StaticFileFS(<span class="type">string</span>, <span class="type">string</span>, http.FileSystem) IRoutes</span><br><span class="line">Static(<span class="type">string</span>, <span class="type">string</span>) IRoutes</span><br><span class="line">StaticFS(<span class="type">string</span>, http.FileSystem) IRoutes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册路由的核心接口是 <code>IRouter</code>，并且为 <code>Engine</code> 和 <code>RouterGroup</code> 实现了 <code>IRouter</code> 接口：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250630222405298.png" alt="Gin IRouter 接口及其实现"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">RouterGroup</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RouterGroup is used internally to configure router, a RouterGroup is associated with</span></span><br><span class="line"><span class="comment">// a prefix and an array of handlers (middleware).</span></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">Handlers HandlersChain</span><br><span class="line">basePath <span class="type">string</span></span><br><span class="line">engine   *Engine</span><br><span class="line">root     <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码后我们发现，其实真正实现 <code>IRouter</code> 接口的，只有 <code>RouterGroup</code>！然后在 <code>Engine</code> 中组合 <code>RouterGroup</code>，这样我们既可以直接在 <code>Engine</code> 上（根路径）注册路由，需要注意的是，<code>IRouter</code> 中有一个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Group(<span class="type">string</span>, ...HandlerFunc) *RouterGroup</span><br></pre></td></tr></table></figure><p>这样就巧妙地实现了<strong>分组路由</strong>和<strong>递归分组路由</strong>的功能！</p><p>我们先来看看 <code>Group()</code> 的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Group(relativePath <span class="type">string</span>, handlers ...HandlerFunc) *RouterGroup &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;RouterGroup&#123;</span><br><span class="line">Handlers: group.combineHandlers(handlers),  <span class="comment">// 组合当前 group 和 handlers（深拷贝），并返回新的 handlers 列表</span></span><br><span class="line">basePath: group.calculateAbsolutePath(relativePath), <span class="comment">// 合并路径</span></span><br><span class="line">engine:   group.engine,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个接口最多支持 127-1 个处理器</span></span><br><span class="line"><span class="keyword">const</span> abortIndex <span class="type">int8</span> = math.MaxInt8 &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> combineHandlers(handlers HandlersChain) HandlersChain &#123;</span><br><span class="line">finalSize := <span class="built_in">len</span>(group.Handlers) + <span class="built_in">len</span>(handlers)</span><br><span class="line">assert1(finalSize &lt; <span class="type">int</span>(abortIndex), <span class="string">&quot;too many handlers&quot;</span>)</span><br><span class="line">mergedHandlers := <span class="built_in">make</span>(HandlersChain, finalSize)</span><br><span class="line"><span class="built_in">copy</span>(mergedHandlers, group.Handlers)  <span class="comment">// 深拷贝当前 group 拥有的 handler</span></span><br><span class="line"><span class="built_in">copy</span>(mergedHandlers[<span class="built_in">len</span>(group.Handlers):], handlers) <span class="comment">// 深拷贝新注册的 handler</span></span><br><span class="line"><span class="keyword">return</span> mergedHandlers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> calculateAbsolutePath(relativePath <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> joinPaths(group.basePath, relativePath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看注册路由的具体实现，以 <code>GET()</code> 为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> GET(relativePath <span class="type">string</span>, handlers ...HandlerFunc) IRoutes &#123;</span><br><span class="line"><span class="keyword">return</span> group.handle(http.MethodGet, relativePath, handlers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> handle(httpMethod, relativePath <span class="type">string</span>, handlers HandlersChain) IRoutes &#123;</span><br><span class="line">absolutePath := group.calculateAbsolutePath(relativePath) <span class="comment">// 合并路径</span></span><br><span class="line">handlers = group.combineHandlers(handlers)  <span class="comment">// 组合当前 group 和 handlers（深拷贝），并返回新的 handlers 列表</span></span><br><span class="line">group.engine.addRoute(httpMethod, absolutePath, handlers) <span class="comment">// 添加路由</span></span><br><span class="line"><span class="keyword">return</span> group.returnObj()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册逻辑在 <code>engine.addRoute()</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method, path <span class="type">string</span>, handlers HandlersChain) &#123;</span><br><span class="line"><span class="comment">// 获取 method 对应的路由树，不存在则创建</span></span><br><span class="line">  root := engine.trees.get(method)</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">root = <span class="built_in">new</span>(node)</span><br><span class="line">root.fullPath = <span class="string">&quot;/&quot;</span></span><br><span class="line">engine.trees = <span class="built_in">append</span>(engine.trees, methodTree&#123;method: method, root: root&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加路由</span></span><br><span class="line">root.addRoute(path, handlers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由注册">路由注册</h3><p>核心逻辑在 <code>root.addRoute()</code> 中，这个函数的目标是在路由树中为给定的 <code>path</code> 和 <code>handlers</code> 找到一个安身之处，必要时会重塑树的结构。</p><p>整个函数的核心是一个 <code>walk</code> 循环，它模拟了从树的根节点开始，一步步向下走，直到找到或创造出新路由位置的过程。接下来我们细细拆解这个过程。</p><h4 id="初始化与空树处理">初始化与空树处理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fullPath := path</span><br><span class="line">n.priority++</span><br><span class="line"></span><br><span class="line"><span class="comment">// Empty tree</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(n.path) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(n.children) == <span class="number">0</span> &#123;</span><br><span class="line">    n.insertChild(path, fullPath, handlers)</span><br><span class="line">    n.nType = root</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>n.priority++</code></strong>: 每当有一个路由需要经过或终止于当前节点 <code>n</code>，这个节点的优先级（权重）就会增加。这反映了该节点在路由树中的&quot;繁忙&quot;程度。</li><li><strong>空树判断</strong>: 这是最简单的基础情况。如果当前节点 <code>n</code> 的 <code>path</code> 和 <code>children</code> 都为空，说明这是一棵空树（或者说我们正处于一个未初始化的根节点）。</li><li><strong>操作</strong>: 直接调用 <code>n.insertChild(path, fullPath, handlers)</code>，将整条 <code>path</code> 作为第一个孩子插入，并把自己的类型设置为 <code>root</code>。整个添加过程结束。</li></ul><hr><p>如果不是空树，程序就进入 <code>walk</code> 循环，开始真正的&quot;建树之旅&quot;。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i := longestCommonPrefix(path, n.path)</span><br></pre></td></tr></table></figure><p>这是循环体内的第一步，也是最关键的一步。它计算了 <strong>要插入的新路径 <code>path</code></strong> 和 <strong>当前节点路径 <code>n.path</code></strong> 之间的最长公共前缀 (Longest Common Prefix) 的长度 <code>i</code>。这个 <code>i</code> 的值，决定了接下来所有的操作。</p><blockquote><p>要不，刷个 leetcode 放松一下？🤡🤡🤡 <a href="https://leetcode.com/problems/longest-common-prefix/description/">longestCommonPrefix</a></p></blockquote><h4 id="场景一：节点分裂-Split-Edge">场景一：节点分裂 (Split Edge)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Split edge</span></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(n.path) &#123;</span><br><span class="line">    <span class="comment">// 分裂当前 n，继承之前的 indices, children, handlers 和 wildChild</span></span><br><span class="line">    child := node&#123;</span><br><span class="line">      path:      n.path[i:],</span><br><span class="line">      wildChild: n.wildChild,</span><br><span class="line">      nType:     static,</span><br><span class="line">      indices:   n.indices,</span><br><span class="line">      children:  n.children,</span><br><span class="line">      handlers:  n.handlers,</span><br><span class="line">      priority:  n.priority - <span class="number">1</span>,</span><br><span class="line">      fullPath:  n.fullPath,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    n.children = []*node&#123;&amp;child&#125; <span class="comment">// 把分裂出来的节点作为当前节点的 child</span></span><br><span class="line">    n.indices = bytesconv.BytesToString([]<span class="type">byte</span>&#123;n.path[i]&#125;) <span class="comment">// 重置 indices，目前只有一个元素，就是分裂出来的节点的第一个字符</span></span><br><span class="line">    n.path = path[:i]  <span class="comment">// 缩短前缀</span></span><br><span class="line">    n.handlers = <span class="literal">nil</span>   <span class="comment">// 清空 handlers，因为当前节点已经是中间节点了</span></span><br><span class="line">    n.wildChild = <span class="literal">false</span>  <span class="comment">// 清空通配符标识</span></span><br><span class="line">    n.fullPath = fullPath[:parentFullPathIndex+i] <span class="comment">// 重置 fullPath</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>触发条件</strong>: <code>i &lt; len(n.path)</code>。这意味着公共前缀的长度 <code>i</code> 小于当前节点 <code>n</code> 的路径长度。换句话说，新路径和当前节点路径在中间某个位置出现了&quot;分叉&quot;。</li><li><strong>经典例子</strong>: 当前节点 <code>n.path</code> 是 <code>&quot;/hello&quot;</code>，要插入的新路径 <code>path</code> 是 <code>&quot;/help&quot;</code>。<ul><li>LCP 是 <code>&quot;/hel&quot;</code>，长度 <code>i</code> 为 4。</li><li><code>i &lt; len(&quot;/hello&quot;)</code> (4 &lt; 6) 条件成立。</li></ul></li><li>**操作 (这是最精妙的部分): **<ol><li><strong>创建新子节点 <code>child</code></strong>:<ul><li>这个 <code>child</code> 节点继承了当前节点 <code>n</code> &quot;后半段&quot;的路径，即 <code>n.path[i:]</code> (例子中是 <code>&quot;lo&quot;</code>)。</li><li>它也完全继承了 <code>n</code> 之前的所有子节点 (<code>n.children</code>)、<code>handlers</code>、<code>wildChild</code> 状态等。它的 <code>priority</code> 会减 1，因为父节点 <code>n</code> 的 <code>priority</code> 已经加过了。</li></ul></li><li><strong>改造当前节点 <code>n</code></strong>:<ul><li>当前节点 <code>n</code> 被&quot;改造&quot;成一个新的、更短的 <strong>父节点/分支节点</strong>。</li><li><code>n.path</code> 被截断为公共前缀 <code>path[:i]</code> (例子中是 <code>&quot;/hel&quot;</code>)。</li><li><code>n.handlers</code> 被设为 <code>nil</code>，因为它现在只是一个中间节点。</li><li><code>n.children</code> 被重置，现在<strong>只包含</strong>刚刚创建的那个 <code>child</code> 节点。</li><li><code>n.indices</code> 也被更新，只包含指向新 <code>child</code> 节点的索引字符 (例子中是 <code>'l'</code>)。</li></ul></li></ol></li><li><strong>结果</strong>: 执行完分裂后，树的结构从 <code>(node path=&quot;/hello&quot;)</code> 变成了 <code>(node path=&quot;/hel&quot;) -&gt; (child path=&quot;lo&quot;)</code>。此时，我们还没有处理新路径 <code>&quot;/help&quot;</code> 剩下的部分 (<code>&quot;p&quot;</code>)。代码会自然地流转到下面的 <code>if i &lt; len(path)</code> 逻辑，将 <code>&quot;p&quot;</code> 作为 <code>/hel</code> 节点的第二个孩子插入。</li></ul><hr><h4 id="场景二：继续向下走或创建新分支">场景二：继续向下走或创建新分支</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make new node a child of this node</span></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(path) &#123;</span><br><span class="line">    path = path[i:]</span><br><span class="line">    c := path[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 /?a=1&amp;b=2 这种情况</span></span><br><span class="line">    <span class="keyword">if</span> n.nType == param &amp;&amp; c == <span class="string">&#x27;/&#x27;</span> &amp;&amp; <span class="built_in">len</span>(n.children) == <span class="number">1</span> &#123;</span><br><span class="line">      parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">      n = n.children[<span class="number">0</span>]</span><br><span class="line">      n.priority++</span><br><span class="line">      <span class="keyword">continue</span> walk</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看能不能找到匹配的静态子节点</span></span><br><span class="line">    <span class="keyword">for</span> i, max := <span class="number">0</span>, <span class="built_in">len</span>(n.indices); i &lt; max; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> c == n.indices[i] &#123;</span><br><span class="line">        parentFullPathIndex += <span class="built_in">len</span>(n.path)</span><br><span class="line">        i = n.incrementChildPrio(i)</span><br><span class="line">        n = n.children[i]</span><br><span class="line">        <span class="keyword">continue</span> walk</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找不到匹配的静态子节点，且当前节点非通配符节点，则插入一个新的子节点</span></span><br><span class="line">    <span class="keyword">if</span> c != <span class="string">&#x27;:&#x27;</span> &amp;&amp; c != <span class="string">&#x27;*&#x27;</span> &amp;&amp; n.nType != catchAll &#123;</span><br><span class="line">      <span class="comment">// []byte for proper unicode char conversion, see #65</span></span><br><span class="line">      n.indices += bytesconv.BytesToString([]<span class="type">byte</span>&#123;c&#125;)</span><br><span class="line">      child := &amp;node&#123;</span><br><span class="line">        fullPath: fullPath,</span><br><span class="line">      &#125;</span><br><span class="line">      n.addChild(child)</span><br><span class="line">      n.incrementChildPrio(<span class="built_in">len</span>(n.indices) - <span class="number">1</span>)</span><br><span class="line">      n = child</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> n.wildChild &#123;</span><br><span class="line">      <span class="comment">// 如果新的 path 是通配符路径，当前节点 n 也是通配符节点，那需要检查是否有冲突</span></span><br><span class="line">      <span class="comment">// 按照约定，通配符子节点永远是 children 切片的最后一个元素，取出最后一个元素，成为当前的 n</span></span><br><span class="line">      n = n.children[<span class="built_in">len</span>(n.children)<span class="number">-1</span>]</span><br><span class="line">      n.priority++</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断通配符是否不冲突，需要满足 3 个条件</span></span><br><span class="line">      <span class="comment">// 1. len(path) &gt;= len(n.path) &amp;&amp; n.path == path[:len(n.path)]</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt;= <span class="built_in">len</span>(n.path) &amp;&amp; n.path == path[:<span class="built_in">len</span>(n.path)] &amp;&amp;</span><br><span class="line">        <span class="comment">// Adding a child to a catchAll is not possible</span></span><br><span class="line">        n.nType != catchAll &amp;&amp;</span><br><span class="line">        <span class="comment">// Check for longer wildcard, e.g. :name and :names</span></span><br><span class="line">        (<span class="built_in">len</span>(n.path) &gt;= <span class="built_in">len</span>(path) || path[<span class="built_in">len</span>(n.path)] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span> walk</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Wildcard conflict</span></span><br><span class="line">      pathSeg := path</span><br><span class="line">      <span class="keyword">if</span> n.nType != catchAll &#123;</span><br><span class="line">        pathSeg = strings.SplitN(pathSeg, <span class="string">&quot;/&quot;</span>, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      prefix := fullPath[:strings.Index(fullPath, pathSeg)] + n.path</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;&#x27;&quot;</span> + pathSeg +</span><br><span class="line">        <span class="string">&quot;&#x27; in new path &#x27;&quot;</span> + fullPath +</span><br><span class="line">        <span class="string">&quot;&#x27; conflicts with existing wildcard &#x27;&quot;</span> + n.path +</span><br><span class="line">        <span class="string">&quot;&#x27; in existing prefix &#x27;&quot;</span> + prefix +</span><br><span class="line">        <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 fullPath，handlers 赋予处理后的最终的当前节点</span></span><br><span class="line">    n.insertChild(path, fullPath, handlers)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>触发条件</strong>: <code>i &lt; len(path)</code>。这意味着在匹配完公共前缀后（或者说，完整匹配了当前节点的 <code>path</code> 后），要插入的新路径 <code>path</code> <strong>还有剩余部分</strong>。</li><li><strong>例子</strong>: 当前节点 <code>n.path</code> 是 <code>&quot;/users&quot;</code>，要插入的新路径是 <code>&quot;/users/new&quot;</code>。<ul><li>LCP 是 <code>&quot;/users&quot;</code>，长度 <code>i</code> 为 6。<code>i == len(n.path)</code>。</li><li><code>i &lt; len(&quot;/users/new&quot;)</code> (6 &lt; 10) 条件成立。</li></ul></li></ul><p>具体过程如下：</p><ol><li><p><code>path = path[i:]</code>: 更新 <code>path</code> 为剩余未处理的部分 (例子中是 <code>&quot;/new&quot;</code>)。</p></li><li><p><code>c := path[0]</code>: 取出剩余路径的第一个字符 (例子中是 <code>/</code>)。</p></li><li><p><strong>检查现有子节点</strong>: <code>for i, max := 0, len(n.indices); ...</code></p><p>这是最常见的&quot;向下走&quot;逻辑。程序用字符 <code>c</code> 去匹配 <code>n.indices</code>，如果找到了匹配的静态子节点，就增加那个子节点的 <code>priority</code>，然后 <code>n = n.children[i]</code>，将 <code>n</code> 更新为那个子节点，<code>continue walk</code>，从新的 <code>n</code> 开始下一轮循环。</p></li><li><p><strong>插入新子节点</strong>:</p><ul><li><p>如果 <code>for</code> 循环没找到匹配的子节点，并且 <code>c</code> 不是通配符 (<code>:</code> 或 <code>*</code>)，程序就会创建一个新的静态子节点，更新 <code>n.indices</code>，并将 <code>n</code> 指向这个新创建的子节点。</p></li><li><p>如果 <code>c</code> 是通配符，会进入 <code>else if n.wildChild</code> 逻辑。这个逻辑主要是用来<strong>处理通配符冲突</strong>的。例如，你不能在 <code>/:id</code> 之后再添加 <code>/:user</code>。如果存在冲突，程序会 <code>panic</code> 并给出非常清晰的错误信息。如果没有冲突（例如，在 <code>/:id</code> 节点下添加子节点 <code>/profile</code>），则会继续向下 <code>walk</code>。这里检查了 3 个条件：</p><ul><li><p>条件 ① <code>len(path) &gt;= len(n.path) &amp;&amp; n.path == path[:len(n.path)]</code>：检查<strong>新路径 <code>path</code> 是否以已存在的通配符路径 <code>n.path</code> 开头</strong>。</p><ul><li><strong>可能兼容</strong>：已存在 <code>:id</code>，新来 <code>:id/profile</code>。<code>&quot;:id/profile&quot;</code> 以 <code>&quot;:id&quot;</code> 开头，通过。</li><li><strong>绝对冲突</strong>：已存在 <code>:id</code>，新来 <code>:user</code>。<code>&quot;:user&quot;</code> 并不以 <code>&quot;:id&quot;</code> 开头，检查失败，将直接跳到 <code>panic</code>。这正是我们之前讨论的，<code>/:id</code> 和 <code>/:user</code> 无法共存的逻辑实现。</li></ul></li><li><p>条件 ② <code>n.nType != catchAll</code>：检查<strong>已存在的通配符节点类型不是 <code>catchAll</code> (<code>*</code> 类型)</strong>。</p><p><code>catchAll</code> 类型的通配符（例如 <code>/static/*filepath</code>）是终极的，它会匹配所有后续路径。因此，在它后面再添加任何子节点（例如 <code>/static/*filepath/more</code>）都是没有意义的，也是不被允许的。如果已存在的是 <code>catchAll</code>，此条件不满足，将 <code>panic</code>。</p></li><li><p>条件 ③ <code>(len(n.path) &gt;= len(path) || path[len(n.path)] == '/')</code>：这是一个非常精妙的检查，用于确保通配符的&quot;边界清晰&quot;，防止部分重叠的歧义命名。它分为两种允许的情况：</p><ul><li><strong><code>len(n.path) &gt;= len(path)</code></strong>: 新路径和旧通配符路径完全一样（或更短，但由于条件 A，只能是完全一样）。例如，已存在 <code>:id</code>，新来的也是 <code>:id</code>（后面可能要加子节点）。</li><li><strong><code>path[len(n.path)] == '/'</code></strong>: 新路径比旧通配符路径更长，并且紧跟着的第一个字符必须是 <code>/</code>。例如，已存在 <code>:id</code>，新来的是 <code>:id/profile</code>，<code>profile</code> 前面必须有 <code>/</code> 分隔。</li></ul></li></ul><p>如果所有这三个条件都奇迹般地满足了，说明新路径是现有通配符的一个完全合法的&quot;子路径&quot;或&quot;扩展&quot;。程序就会执行 <code>continue walk</code>，继续愉快地向下走，处理路径剩下的部分。</p></li></ul></li><li><p><code>n.insertChild(path, fullPath, handlers)</code>: 这是创建新节点的最终调用，并将 <code>path</code>、<code>fullPath</code> 和 <code>handlers</code>赋予这个新的叶子节点。然后 <code>return</code>，添加过程结束。</p></li></ol><hr><h4 id="场景三：终点命中，添加-Handlers">场景三：终点命中，添加 Handlers</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Otherwise add handle to current node</span></span><br><span class="line"><span class="keyword">if</span> n.handlers != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;handlers are already registered for path &#x27;&quot;</span> + fullPath + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">n.handlers = handlers</span><br><span class="line">n.fullPath = fullPath</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li><strong>触发条件</strong>: 循环走到了一个节点 <code>n</code>，并且 <code>i == len(n.path)</code> 且 <code>i == len(path)</code>。这意味着要插入的路径和当前节点的路径<strong>完全一样</strong>。</li><li><strong>含义</strong>: 找到了一个已经存在的、路径完全匹配的节点。</li><li><strong>操作</strong>:<ol><li>检查 <code>n.handlers</code> 是否已经存在。如果存在，说明重复注册路由，这是不允许的，程序会 <code>panic</code>。</li><li>如果不存在，就将 <code>handlers</code> 和 <code>fullPath</code> 赋予当前节点 <code>n</code>。</li><li><code>return</code>，添加过程结束。</li></ol></li></ul><h4 id="总结-3">总结</h4><p><code>addRoute</code> 函数通过一个 <code>walk</code> 循环，非常精妙地处理了向基数树中插入新路由的所有可能情况：</p><ol><li><strong>从计算 LCP 开始</strong>，判断新路由与当前节点的关系。</li><li>如果新路由与现有节点路径<strong>部分重叠</strong>，则<strong>分裂</strong>现有节点，创造出一个新的分支节点。</li><li>如果新路由是现有节点路径的<strong>超集</strong>，则<strong>深入</strong>到子节点中，或<strong>创建</strong>新的子节点。</li><li>如果新路由与现有节点 路径<strong>完全重合</strong>，则为其<strong>附加</strong>处理函数，或因重复注册而报错。</li></ol><p>我画了个流程图，供你参考：</p><pre class="mermaid">graph TD    subgraph MainProcess [主流程]        direction TB        %% Node Definitions        A["addRoute(path, handlers)"]:::startend        A1["n.priority++"]:::process        C0{"树为空?"}:::decision        %% Empty Tree Path        B0["insertChild(path, ...)<br>n.nType = root<br>return"]:::startend        %% Main Walk Loop        W["WALK 循环开始"]:::process        W1["i := longestCommonPrefix(path, n.path)"]:::process        C1_SplitEdge{"i < len(n.path)?<br>(需要分裂节点?)"}:::decision        %% Split Edge Logic        B1["<b>节点分裂 (Split Edge)</b><br>1. 创建 child 继承 n 的后半段路径和属性<br>2. 改造 n 为父节点, path 截为公共前缀<br>3. n 的 children 重置为 [child]<br>4. n.handlers = nil"]:::process        %% Continue After Split or No Split        C2_MorePath{"i < len(path)?<br>(新路径还有剩余?)"}:::decision        %% Path A: No More Path (Exact Match)        C3_HasHandlers{"n.handlers != nil?"}:::decision        P1["panic('路由重复注册')"]:::panic        B2["n.handlers = handlers<br>n.fullPath = fullPath<br>return"]:::startend        %% Path B: More Path Left        W2["path = path[i:]<br>c := path[0]"]:::process        C4{"静态子节点匹配成功?<br>(for c in n.indices)"}:::decision        B3["n = 匹配的子节点<br>n.priority++<br><b>continue walk</b>"]:::process        %% Wildcard Logic        C5{"c 是通配符 : 或 * ?"}:::decision        C5_1{"n 已有通配符子节点?<br>(n.wildChild)"}:::decision        C6{"兼容性检查通过?"}:::decision        B4["n = 已存在的通配符子节点<br>n.priority++"]:::process        B5["<b>continue walk</b>"]:::process        P2["panic('通配符冲突')"]:::panic        %% Insert New Child        B6["<b>创建新子节点</b><br>1. 创建 child node<br>2. 更新 n.indices<br>3. n.addChild(child)<br>4. n = child"]:::process        B7["n.insertChild(path, ...)<br>return"]:::startend        %% Connections        A --> A1 --> C0        C0 -- "是(Yes)" --> B0        C0 -- "否(No)" --> W        W --> W1 --> C1_SplitEdge        C1_SplitEdge -- "是(Yes)" --> B1 --> C2_MorePath        C1_SplitEdge -- "否(No)" --> C2_MorePath        C2_MorePath -- "否(No) - 路径完全匹配" --> C3_HasHandlers        C3_HasHandlers -- "是(Yes)" --> P1        C3_HasHandlers -- "否(No)" --> B2        C2_MorePath -- "是(Yes) - 路径有剩余" --> W2        W2 --> C4        C4 -- "是(Yes)" --> B3 --> W        C4 -- "否(No)" --> C5        C5 -- "是(Yes)" --> C5_1        C5_1 -- "否(No)" --> B6        C5_1 -- "是(Yes)" --> B4 --> C6        C6 -- "是(Yes)" --> B5 --> W        C6 -- "否(No)" --> P2        C5 -- "否(No) - 静态" --> B6        B6 --> B7    end    %% Styling    classDef startend fill:#9f9,stroke:#333,stroke-width:2px,color:#000    classDef panic fill:#f99,stroke:#333,stroke-width:2px,color:#000    classDef decision fill:#ffc,stroke:#333,stroke-width:2px,color:#000    classDef process fill:#9cf,stroke:#333,stroke-width:2px,color:#000</pre><h2 id="响应返回-ctx-Json">响应返回 ctx.Json</h2><p>我们的业务逻辑，会在上一步的中间件执行就顺带被执行了。现在我们来看一下请求结果是如何被返还回去的，这里以 <code>ctx.Json()</code> 为例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON serializes the given struct as JSON into the response body.</span></span><br><span class="line"><span class="comment">// It also sets the Content-Type as &quot;application/json&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> JSON(code <span class="type">int</span>, obj any) &#123;</span><br><span class="line">c.Render(code, render.JSON&#123;Data: obj&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Render writes the response headers and calls render.Render to render data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Render(code <span class="type">int</span>, r render.Render) &#123;</span><br><span class="line">  <span class="comment">// 设置 HTTP 响应状态码</span></span><br><span class="line">c.Status(code)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否有必要写 response body，没必要则直接返回</span></span><br><span class="line"><span class="keyword">if</span> !bodyAllowedForStatus(code) &#123;</span><br><span class="line">r.WriteContentType(c.Writer)</span><br><span class="line">c.Writer.WriteHeaderNow()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写 response body</span></span><br><span class="line"><span class="keyword">if</span> err := r.Render(c.Writer); err != <span class="literal">nil</span> &#123;</span><br><span class="line">_ = c.Error(err)</span><br><span class="line">c.Abort()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心是 <code>r.Render</code>，它是一个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Render interface is to be implemented by JSON, XML, HTML, YAML and so on.</span></span><br><span class="line"><span class="keyword">type</span> Render <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Render writes data with custom ContentType.</span></span><br><span class="line">Render(http.ResponseWriter) <span class="type">error</span></span><br><span class="line"><span class="comment">// WriteContentType writes custom ContentType.</span></span><br><span class="line">WriteContentType(w http.ResponseWriter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250630235422540.png" alt="Render 接口实现类"></p><p>这里我们看一下 JSON 的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Render (JSON) writes data with custom ContentType.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r JSON)</span></span> Render(w http.ResponseWriter) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> WriteJSON(w, r.Data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteJSON marshals the given interface object and writes it with custom ContentType.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteJSON</span><span class="params">(w http.ResponseWriter, obj any)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">writeContentType(w, jsonContentType)</span><br><span class="line">jsonBytes, err := json.Marshal(obj)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = w.Write(jsonBytes)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// github.com/gin-gonic/gin/response_writer.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *responseWriter)</span></span> Write(data []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">w.WriteHeaderNow()</span><br><span class="line">n, err = w.ResponseWriter.Write(data)</span><br><span class="line">w.size += n</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实逻辑就 2 步：</p><ol><li>写 content-type: application/json。</li><li>调用标准库的 <code>http.responseWriter</code> 将响应结果写回缓冲区。</li></ol><p>在调用链处理完毕后，最后就回到了我们在<strong>请求入口 c.serve(connCtx)</strong> 中分析到的 <code>finishRequest</code>，然后通过建立好的 TCP 连接传递给客户端。</p><h2 id="优雅关闭-httpServer-Shutdown">优雅关闭 httpServer.Shutdown</h2><p>Gin 框架本身不提供优雅关闭的功能，需要使用标准库的 <code>http.Server</code> 来实现优雅关闭（最好结合 tableflip 实现无缝切换）。</p><p>基础实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个通道来接收系统信号</span></span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 监听 SIGINT (Ctrl+C) 和 SIGTERM 信号</span></span><br><span class="line">signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// ... 注册路由</span></span><br><span class="line">httpServer := &amp;http.Server&#123;</span><br><span class="line">  Addr:    <span class="string">&quot;:9010&quot;</span>,</span><br><span class="line">  Handler: r,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := httpServer.ListenAndServe(); err != <span class="literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;服务器启动失败: &quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞等待信号</span></span><br><span class="line">&lt;-quit</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Shutdown 进行优雅关闭</span></span><br><span class="line"><span class="keyword">if</span> err := httpServer.Shutdown(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;服务器已关闭&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们看一下 <code>Shutdown()</code> 的具体逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Shutdown(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 将服务置为关闭中的状态，拒绝新的连接</span></span><br><span class="line">s.inShutdown.Store(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行钩子函数</span></span><br><span class="line">s.mu.Lock()</span><br><span class="line">lnerr := s.closeListenersLocked()</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> s.onShutdown &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">&#125;</span><br><span class="line">s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待现有连接执行完毕 &amp; 关闭</span></span><br><span class="line">s.listenerGroup.Wait()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指数退避与抖动</span></span><br><span class="line">pollIntervalBase := time.Millisecond</span><br><span class="line">nextPollInterval := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Duration &#123;</span><br><span class="line">interval := pollIntervalBase + time.Duration(rand.Intn(<span class="type">int</span>(pollIntervalBase/<span class="number">10</span>)))</span><br><span class="line">pollIntervalBase *= <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> pollIntervalBase &gt; shutdownPollIntervalMax &#123;</span><br><span class="line">pollIntervalBase = shutdownPollIntervalMax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> interval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer := time.NewTimer(nextPollInterval())</span><br><span class="line"><span class="keyword">defer</span> timer.Stop()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.closeIdleConns() &#123; <span class="comment">// 直接关闭空闲的连接，如果全部已经关闭了，就返回 true</span></span><br><span class="line"><span class="keyword">return</span> lnerr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 超时强制关闭</span></span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line"><span class="keyword">case</span> &lt;-timer.C:  <span class="comment">// 重新设置下次轮询的时间</span></span><br><span class="line">timer.Reset(nextPollInterval())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑如下：</p><ol><li><p>将服务置为关闭中的状态，这样在 <code>Accept</code> 的时候，就会拒绝新的连接了。</p></li><li><p>执行用户自定义的钩子函数，Gin 框架扩展性的体现。</p></li><li><p><code>s.listenerGroup.Wait()</code> 等待监听器彻底关闭，这里对应了前面 <code>Serve</code> 中的这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> !s.trackListener(&amp;l, <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> s.trackListener(&amp;l, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> trackListener(ln *net.Listener, add <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">s.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> s.listeners == <span class="literal">nil</span> &#123;</span><br><span class="line">s.listeners = <span class="built_in">make</span>(<span class="keyword">map</span>[*net.Listener]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> add &#123;</span><br><span class="line"><span class="keyword">if</span> s.shuttingDown() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">s.listeners[ln] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">s.listenerGroup.Add(<span class="number">1</span>)  <span class="comment">// &lt;-------- 开启监听</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(s.listeners, ln)</span><br><span class="line">s.listenerGroup.Done()  <span class="comment">// &lt;-------- 结束监听</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不断轮询关闭空闲的连接，直到整个服务处于静止状态。这里使用的指数退避和抖动：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shutdownPollIntervalMax = <span class="number">500</span> * time.Millisecond <span class="comment">// 最长轮询等待时间为 500ms</span></span><br><span class="line"></span><br><span class="line">pollIntervalBase := time.Millisecond <span class="comment">// 从 1ms 开始</span></span><br><span class="line">nextPollInterval := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Duration &#123;</span><br><span class="line">  interval := pollIntervalBase + time.Duration(rand.Intn(<span class="type">int</span>(pollIntervalBase/<span class="number">10</span>))) <span class="comment">// 加 10% 随机抖动时间</span></span><br><span class="line">  pollIntervalBase *= <span class="number">2</span> <span class="comment">// 翻倍</span></span><br><span class="line">  <span class="keyword">if</span> pollIntervalBase &gt; shutdownPollIntervalMax &#123; <span class="comment">// 限制最长轮询等待时间</span></span><br><span class="line">    pollIntervalBase = shutdownPollIntervalMax</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> interval</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指数退避</strong>：轮询的间隔时间 <code>pollIntervalBase</code> 从 1 毫秒开始，每次轮询后都<strong>翻倍</strong>，直到一个最大值 （<code>shutdownPollIntervalMax</code>）。这非常高效：开始时频繁检查，以便服务能快速关闭；如果耗时较长，就降低检查频率，避免空转浪费 CPU。</p><p><strong>抖动</strong>：在基础间隔上增加一个 10% 的随机时间。这在分布式系统中是一个好习惯，可以避免多个服务在同一时刻执行相同操作，造成&quot;惊群效应&quot;。</p></li><li><p>返回，完成服务的安全关闭。</p></li></ol><h2 id="流程总结">流程总结</h2><p>最后我们做一个汇总。一个 HTTP 请求在 Gin 框架中的完整旅程可以总结为以下几个核心阶段：</p><p><strong>1. 启动与监听：</strong></p><ul><li>Gin 服务的启动入口是 <code>r.Run()</code>，它首先会解析监听地址，默认使用 <code>:8080</code> 端口，也可以通过 <code>PORT</code> 环境变量或直接传参来指定。</li><li>其底层核心是调用了 Go 标准库的 <code>http.ListenAndServe</code>，进一步通过 <code>net.Listen</code> 监听 TCP 端口，并最终在 <code>Serve</code> 方法中进入一个 <code>for</code> 循环，通过 <code>l.Accept()</code> 来接收新的客户端连接。</li><li>每当接收到一个新连接，就会创建一个 <code>conn</code> 对象，并为其开启一个独立的 goroutine（<code>go c.serve(connCtx)</code>）来处理后续的请求。</li></ul><p><strong>2. 请求处理入口：</strong></p><ul><li>在 <code>c.serve</code> 的 <code>for</code> 循环中，服务器通过 <code>c.readRequest(ctx)</code> 读取和解析原始的 HTTP 请求数据。</li><li>最关键的一步是调用 <code>serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</code>，这将请求的 <code>ResponseWriter</code> 和 <code>Request</code> 对象传递给了 Gin 引擎的核心处理逻辑。</li><li>请求处理完毕后，会调用 <code>w.finishRequest()</code> 来写入响应数据、刷新缓冲区并清理资源，为下一次请求复用做准备。</li></ul><p><strong>3. 上下文创建与回收：</strong></p><ul><li>Gin 引擎的 <code>ServeHTTP</code> 方法是处理所有请求的入口。为了提高性能，Gin 使用 <code>sync.Pool</code> 对象池来复用 <code>gin.Context</code> 对象。</li><li>每次处理新请求时，会从池中 <code>Get()</code> 一个 <code>Context</code>，重置其内部状态并与当前请求的 <code>ResponseWriter</code> 和 <code>Request</code> 绑定。</li><li>请求处理完毕后，<code>Context</code> 对象会被 <code>Put()</code> 回对象池，从而避免了频繁创建和销毁对象带来的垃圾回收压力。</li></ul><p><strong>4. 路由匹配：</strong></p><ul><li>Gin 的核心路由机制是基于一个 <code>methodTrees</code> 结构，它为每种 HTTP 方法（GET、POST 等）维护一棵独立的基数树（Radix Tree）。</li><li>这棵树由 <code>node</code> 节点构成，<code>node</code> 结构的 <code>path</code>、<code>indices</code>、<code>wildChild</code>、<code>children</code> 等字段协同工作，构建了一个既节省内存又查找飞快的路由树。<code>indices</code> 字段通过存储子节点首字母作为快速索引，是其高性能的关键之一。</li><li>路由查找由 <code>root.getValue()</code> 方法执行，它通过一系列步骤（前缀匹配、静态路由查找、通配符匹配）来定位处理器。</li><li><code>getValue</code> 的设计非常精巧，它利用 <code>skippedNodes</code> 实现了<strong>回溯（Backtracking）</strong> 机制，以确保在面对静态路由（<code>/users/new</code>）和动态路由（<code>/users/:id</code>）的选择时，能够优先匹配静态路由，保证了路由的准确性。同时，它还支持 <strong>TSR（Trailing Slash Redirect）</strong> 建议，提升了用户体验。</li></ul><p><strong>5. 中间件与业务逻辑执行：</strong></p><ul><li>路由匹配成功后，找到的 <code>HandlersChain</code>（一个 <code>[]HandlerFunc</code> 切片）会被赋值给 <code>gin.Context</code>。</li><li><code>c.Next()</code> 方法通过一个 <code>for</code> 循环和递增的 <code>index</code> 索引，依次调用 <code>HandlersChain</code> 中的所有处理函数（包括全局中间件、分组中间件和最终的业务 Handler）。</li><li><code>c.Abort()</code> 方法通过将 <code>index</code> 设置为一个极大值来巧妙地中断调用链的执行。</li></ul><p><strong>6. 响应返回：</strong></p><ul><li>当业务逻辑中调用 <code>c.JSON()</code> 等方法时，实际上是调用了 <code>c.Render()</code>。</li><li><code>Render</code> 方法会设置 HTTP 状态码，并通过 <code>render.Render</code> 接口来执行具体的渲染逻辑。例如，<code>render.JSON</code> 会使用标准库的 <code>json.Marshal</code> 将对象序列化，然后通过 <code>http.ResponseWriter</code> 将数据写入响应体。</li></ul><p><strong>7. 优雅关闭：</strong></p><ul><li>Gin 自身不提供优雅关闭，但可以与标准库的 <code>http.Server</code> 结合实现。</li><li><code>httpServer.Shutdown()</code> 的核心逻辑是：<ol><li>首先，通过原子操作 <code>s.inShutdown.Store(true)</code> 设置关闭状态，并调用 <code>s.closeListenersLocked()</code>关闭监听器，从源头阻止新连接的建立。</li><li>并发执行通过 <code>onShutdown</code> 注册的钩子函数。</li><li>进入一个轮询循环，不断调用 <code>s.closeIdleConns()</code> 来关闭已处理完请求的空闲连接。</li><li>这个轮询采用了<strong>指数退避 (Exponential Backoff)</strong> 和<strong>抖动 (Jitter)</strong> 策略，在保证能快速关闭的同时，避免了在等待期间空转浪费 CPU。</li><li>整个关闭过程受传入的 <code>context.Context</code> 控制，可以实现超时强制关闭，避免无限期等待。</li></ol></li></ul>]]></content>
    
    
    <summary type="html">基于 Gin v1.10.1 源码，深入解析 HTTP 请求在 Gin 中的完整生命周期，包括高性能 Radix Tree 路由实现、sync.Pool 对象池优化、中间件洋葱模型、以及优雅关闭等核心机制</summary>
    
    
    
    <category term="go" scheme="https://hedon.top/categories/go/"/>
    
    
    <category term="go" scheme="https://hedon.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨01丨软件架构概述</title>
    <link href="https://hedon.top/2025/06/26/fosa-ch1/"/>
    <id>https://hedon.top/2025/06/26/fosa-ch1/</id>
    <published>2025-06-26T03:00:26.000Z</published>
    <updated>2025-07-07T11:03:31.108Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第一章</u>内容。</p><p>本章的课后题是：</p><ol><li>What are the four dimensions that define software architecture?<br>软件架构定义的四个维度是什么？</li><li>What is the difference between an architecture decision and a design principle?<br>架构决策和设计原则有什么区别？</li><li>List the eight core expectations of a software architect.<br>软件架构师的核心期望有哪些？</li><li>What is the First Law of Software Architecture?<br>软件架构的第一定律是什么？</li></ol><hr><h1>1. 软件架构定义的四个维度</h1><ul><li><strong>structure of the system</strong>: refres to the type of architecture style (or styles) the system is implemented in (such as microservices, layered, or microkernel).</li><li><strong>architecture characteristics</strong>: define the success criteria of a system, which is generally orthogonal to the functionality of the system.</li><li><strong>architecture decisions</strong>: define the rules for how a system should be constructed.</li><li><strong>design principles</strong>: differ from architecture decisions in that a design principle is a guideline rather than a hard-and-fast rule.</li></ul><p>FOSA 中强调，软件架构不单单是&quot;架构&quot;本身，因为它无法揭示系统为何如此构建（why is more important than how），所以书中用了 4 个维度来定义软件架构的方方面面。</p><h2 id="1-1-系统结构">1.1 系统结构</h2><p>系统结构可能就是我们最常谈到的&quot;架构&quot;，指的的整个软件的架构风格（Architecture Style），例如微服务（Microservices）、分层架构（Layered）或微内核（Microkernel）。</p><p>书中后续篇章详细介绍了以下 8 种架构风格：</p><ol><li>分层架构（Layered Architecture）</li><li>流水线架构（Pipeline Architecture）</li><li>微内核架构（Microkernel Architecture）</li><li>基于服务的架构（Service-Based Architecture）</li><li>事件驱动架构（Event-Driven Architecture）</li><li>基于空间的架构（Space-Based Architecture）</li><li>编排驱动的服务导向架构（Orchestration-Driven Service-Oriented Architecture）</li><li>微服务架构（Microservices Architecture）</li></ol><p>FOSA 强调，只用结构来描述架构是不够的，因为它无法揭示系统为何如此构建。因此我们在设计之初，明确选择和识别现有系统的架构风格是基础，但必须超越这一层去理解其背后的驱动因素。</p><h2 id="1-2-架构特性">1.2 架构特性</h2><p>架构特性就是一堆的 <code>-ilities</code>，书中偏爱&quot;架构特性&quot;这个描述，而非&quot;非功能性需求&quot;或&quot;质量属性&quot;，因为这二者带有负面或事后评估的含义，而架构特性，应当是在架构设计之初，就被纳入深入思考。</p><p>架构特性有 3 个标准：</p><ol><li><strong>指定非领域设计考虑</strong>：更关注&quot;如何&quot;实现需求和&quot;为什么&quot;做出某些选择，而不是应用程序&quot;应该做什么&quot;的功能需求。</li><li><strong>影响设计的某种结构方面</strong>：架构特性要求在设计中进行特殊的结构考虑。</li><li><strong>对应用程序成功其重要作用</strong>：每个架构特性都会带来架构的复杂度，所以要尽可能选择最少的、但对成功至关重要的架构特性予以实施。</li></ol><p>架构特性可以分为 3 大类：</p><ol><li>操作型架构特性</li><li>结构型架构特性</li><li>交叉切面架构特性</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250626114830268.png" alt="架构特性分类"></p><p>将任意一个架构特性实现到极致的代价都是极大的，相应也会带来更复杂的架构设计，所以在项目早期，我们需要与领域专家和业务干系人紧密合作，识别和明确最重要的架构特性，用最少的努力，达到最大的产品效果。</p><h2 id="1-3-架构决策">1.3 架构决策</h2><p>架构决策定义了系统如何构建的规则。它们构成了系统的约束，并指导开发团队哪些是被允许的，哪些是不允许的。比如在分层架构中，架构师可能会规定只有业务层额和服务层可以访问数据库，从而限制了表示层直接调用数据库。</p><p>架构决策应当被文档化，例如使用架构决策记录（Architecture Decision Records，ADRs），这有助于解释决策的背景、理由和后果，避免重复讨论。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image.png" alt="架构决策记录 ADR"></p><h2 id="1-4-设计原则">1.4 设计原则</h2><p>设计原则是指导方针（Guideline）而非硬性规则（hard-and-fast rule），用于提供指引和建议，帮助开发团队在面对特定情景时做出最佳选择。</p><h1>2. 架构决策和设计原则的区别</h1><ul><li>架构决策：硬性规则</li><li>设计原则：指导方针</li></ul><h1>3. 软件架构师的核心期望</h1><h2 id="3-1-八大期望">3.1 八大期望</h2><ol><li><p>Make Architecture Decisions</p><p>架构师应定义指导团队技术决策的架构决策和设计原则。核心是&quot;指导（guide）“而非&quot;指定（specify”。</p></li><li><p>Continually Analyze the Architecture</p><p>架构师必须持续、全面地分析技术和问题域的变化，以确保架构的健壮性和业务相关性。</p></li><li><p>Keep Current with Latest Trends</p><p>架构师需要不断跟踪和保持对最新技术、框架、平台和环境的了解。</p></li><li><p>Ensure Compliance with Decisions</p><p>架构师需要持续验证开发团队是否遵循已定义、文档化和沟通的架构决策和设计原则。</p></li><li><p>Diverse Exposure and Experience</p><p>架构师应接触并体验多种多样的技术、框架、平台和环境，从而帮助架构师在面对新问题时，可以从更广阔的技术栈中选择最佳解决方案。</p></li><li><p>Have Business Domain Knowledge</p><p>优秀的软件架构师不仅理解技术，还理解问题空间的业务领域，从而设计出贴合业务发展的有效架构。</p></li><li><p>Possess Interpersonal Skills</p><p>成为一名有效架构师，人际交往能力至少占一半。架构师需要积极与团队协作、进行双向沟通，提供指导和辅导，避免成为象牙塔架构师（Ivory Tower Architecture）。</p></li><li><p>Understand and Navigate Politics</p><p>架构师需要理解企业内部的政治环境，并能驾驭其复杂性。在架构决策受到挑战时，沟通过程中需要始终提供技术和业务上的双重理由，学习将强硬要求转化为请求，并利用同理心和影响力而非头衔来推动决策。</p></li></ol><h2 id="3-2-成长指南">3.2 成长指南</h2><p>成长为一名合格的软件架构师是一个持续学习和实践的过程，涵盖技术、沟通和领导力等多个方面，这里笔者结合 FOSA 书中的 19~24 章内容进行梳理总结：</p><ul><li><strong>持续学习和扩展技术广度</strong><ul><li>20 分钟法则：每天至少投入 20 分钟学习新知识或深入研究特定主题，这里笔者推荐可以每天（或每周）跟 LLM 深入探讨一个技术话题或前沿技术概念。</li><li>技术雷达：利用如 ThoughtWorks 技术雷达的方法来组织和评估新技术，识别值得投入时间深入研究的&quot;试用&quot;技术，并根据趋势更新知识库。</li><li>社交媒体：积极利用社交媒体发现新趋势和技术，将其放入个人技术雷达的&quot;评估&quot;环中。</li></ul></li><li><strong>实践权衡分析</strong><ul><li>失败乃成功之母，实践是检验真理的唯一标准。只有在实践中不断的进行架构设计、权衡抉择、推翻重建，才能不断深化对理论知识、业务领域和现实世界的理解。</li><li>培养批判性思维，避免过度设计和&quot;黄金镀层&quot;现象，专注于解决实际问题，而不是为了技术而技术。软件架构中没有错误的答案，只有昂贵的答案。</li></ul></li><li><strong>培养沟通和协作能力</strong><ul><li>通用语言：参考 DDD（领域驱动设计）思想，在所有项目相关沟通中（包括代码和文档）都使用通用语言，避免沟通歧义，减少沟通成本。</li><li>4C 原则：在沟通中始终关注沟通（Communication）、协作（Collaboration）、清晰（Clarity）和简洁（Concisensess）这 4 个要素。</li><li>主动倾听：认真倾听利益相关者的声音，理解他们的业务需求和痛点，并寻求澄清。</li></ul></li><li><strong>通过榜样领导团队</strong><ul><li>赢得尊重</li><li>辅导和引导</li><li>化请求为帮助</li><li>使用清单</li></ul></li><li><strong>深入业务领域</strong><ul><li>分析业务领域和子域，识别公司的主要活动领域、竞争策略。</li><li>学习领域驱动设计，始终让业务驱动软件设计决策，而不是为了应用最新的技术而技术。</li></ul></li></ul><h1>4. 软件架构的第一定律</h1><ol><li>Everything in software architecture is a trade-off.</li><li>If an architecture thinks they have discovered something that isn’t a trade-off, more likely they just haven’t identified the trade-off yet.</li><li>Why is more important than how.</li></ol><p>软件架构中的一切都是**<font color="red">权衡</font>**。一个解决方案是否是&quot;最佳&quot;的，取决于部署环境、业务驱动因素、公司文化、预算、时间限制、开发人员技能集以及其他数多种因素。架构师应追求&quot;<strong>最不差架构</strong>（least worst architecture）“，而非&quot;最佳架构”。试图支持过多的架构特性往往会导致过于通用且笨重的设计，使其难以成功。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第一章的课后思考题，深入探讨软件架构的四个定义维度、架构决策与设计原则的区别、软件架构师的核心职责，以及软件架构的第一定律，帮助建立对软件架构的全面认识。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
  </entry>
  
  <entry>
    <title>Q&amp;A丨在 AI 时代，如何应对技术焦虑？</title>
    <link href="https://hedon.top/2025/06/21/qa-how-to-deal-with-tech-anxiety-in-ai-era/"/>
    <id>https://hedon.top/2025/06/21/qa-how-to-deal-with-tech-anxiety-in-ai-era/</id>
    <published>2025-06-20T19:06:00.000Z</published>
    <updated>2025-06-26T03:00:09.051Z</updated>
    
    <content type="html"><![CDATA[<p>长期以来我一直陷于技术海洋之中无法自拔，各种追逐技术，有过偶尔的专注，也获得了很大的提升，但更多时候，还是处于多头乱撞、内耗焦虑当中。</p><p>在 AI 快速发展的这段时间，我的焦虑更甚，减法做得越来越差，所以最近专门跟 Google Gemini 聊了这个话题，我觉得它的回答非常好，解答了我很多的疑惑，也让我对未来有了更多的信心，特此整理此篇，以图内心获得更多的宁静。</p><h2 id="在-AI-时代，还有必要学习底层技术吗？">在 AI 时代，还有必要学习底层技术吗？</h2><p>第一个问题我是跟 ChatGPT 讨论的：<a href="https://hedon.top/2025/06/17/qa-should-learn-underlying-principles-in-ai-era/">在 AI 时代，程序员还有必要学习底层技术吗？</a></p><p>它给了我 5 个直击内心的理由：</p><ol><li>抽象层终会&quot;泄露&quot;，底层知识是你的救生筏；</li><li>问题的根源，往往深藏于你看不到的地方；</li><li>真正的工程判断力，建立在对权衡的理解之上；</li><li>你的职业天花板，由底层知识决定；</li><li>创新，源于对第一性原理的掌握。</li></ol><p>我觉得非常有道理：</p><ol><li>当 AI 失灵或表现不佳时，能拯救你的不是另一个 AI，而是你对底层的掌控力。</li><li>只懂“驾驶”的人在车坏了时只能打电话求助，而懂“机械”的人能自己打开发动机盖解决问题。我要做后者。</li><li>AI 可以成为我的顾问，但最终做出决策、并为之负责的人是我。我的决策质量，直接取决于我的底层知识深度。</li><li>AI 会拉平初级和中级工程师的差距，但底层技术功底是区分高级/资深工程师与普通工程师的护城河。</li><li>学习底层技术，不仅是为了解决今天的问题，更是为了获得解决明天未知问题、甚至定义未来的能力。</li></ol><p>所以在保持积极学习前沿技术的同时，我应当将更多的时间，有计划地、持续地加深我的纵向底层知识，从&quot;为什么会这样？&quot;开始，一路向下挖掘，直到触及问题的本质。</p><h2 id="如何应对技术焦虑">如何应对技术焦虑</h2><p>第二个问题我是跟 Google Gemini 讨论的：<a href="https://g.co/gemini/share/819b80654773">后端工程师如何应对技术焦虑</a>。</p><h3 id="原则重于朝生暮死的工具">原则重于朝生暮死的工具</h3><p>后端开发的核心能力，强调那些超越特定语言或框架的底层原则。尽管工具日新月异，但其试图解决的根本问题和所遵循的基本模式却保持着相当的一致性。</p><p>后端工程技能三阶模型：</p><ol><li>是什么：掌握基本工具和概念，能够完成独立任务。</li><li>怎么做：熟练运用框架和模式，构建稳定、可维护的系统。</li><li>为什么：进行系统级思考，设计高可用、高扩展性的复杂系统。</li></ol><p>技术焦虑的一个重要来源，是将职业发展视为一个永无止境的&quot;技能清单&quot;勾选过程。今天学会了 Django，明天又要追逐 FastAPI；刚掌握了 Docker，Kubernetes 的生态又让人望而生畏。这种思维模式必然导致疲于奔命。</p><p><strong>真正的“不变之核”，不是技能本身，而是该技能所体现的原则。</strong></p><p>技术焦虑的逻辑拆解：</p><ol><li>开发者面临的困境是新技术层出不穷，感到焦虑 [用户问题]。</li><li>行业分析罗列了大量&quot;必备技能&quot;，如 Python、Django、Docker、Kubernetes 等 。</li><li>如果只是简单地告诉开发者去学习这个清单，只会加剧焦虑，因为清单永远在变长。</li><li>与此同时，另一些分析强调了基础概念的重要性，如面向对象、结构化思维、解决问题的能力 。</li><li>将这两类信息结合起来，我们能看到更深层的联系：<ul><li>Django 和 Ruby on Rails 是 MVC（模型-视图-控制器）架构模式的实现。</li><li>Spring Boot 框架深度应用了依赖注入（DI）和面向切面编程（AOP）的思想。</li><li>Docker 和 Kubernetes 是为了解决“环境一致性”和“服务编排与生命周期管理”这两个根本问题而诞生的解决方案。</li></ul></li><li>因此，真正持久的技能，是理解这些问题和模式（即&quot;为什么&quot;），而不仅仅是掌握某个工具（即&quot;是什么&quot;）。一个理解了 MVC 模式的工程师，可以快速上手任何一个采用类似模式的新框架。而一个只&quot;会用 Django&quot;的工程师，当行业风向转变时，可能会陷入困境。</li></ol><p>数据结构、算法、计算机网络、操作系统和计算理论等 CS 基础知识为工程师提供了一个统一的、抽象的框架，用以推理和分析所有计算系统，无论其外在形态如何变化 。这种力量体现在它能够培养一种至关重要的能力：<strong>结构化思维和问题分解</strong>。</p><p>CS 基础知识的另一个巨大价值在于，它能帮助工程师&quot;快速理解不熟悉的系统&quot;，比如：</p><ul><li>当你看到一个 HTML 或 XML 文档时，你不会只看到一堆标签，你会看到一棵<strong>树（Tree）</strong>。这个认知让你立刻能够运用所有关于树的知识来思考它：DOM 遍历算法（深度优先、广度优先）、节点操作的效率、以及如何优化渲染性能。</li><li>当你接触到一个新的键值存储（Key-Value Store）系统时，你脑海中浮现的应该是<strong>哈希表（Hash Table）</strong>。这个抽象模型让你能够立即开始推理其核心特性和潜在问题：哈希冲突如何解决？负载因子过高时性能会如何衰减？它的时间复杂度在理想和最坏情况下分别是多少？</li><li>当你研究像 Apache Kafka 这样的消息系统时，你会认识到从单个消费者的角度看，一个 Topic 本质上就是一个<strong>队列（Queue）</strong>。这个模型帮助你理解消费者组（Consumer Group）的行为、偏移量（Offset）的管理机制，以及消息的顺序性保证等核心概念。</li></ul><p>这种通过高层抽象和模式匹配来快速定位和理解新技术核心本质的能力，是在日新月异的技术环境中保持方向感和学习效率的关键。它让你在面对任何一个新框架、新平台或新工具时，都能迅速地抓住其要害，而不是迷失在纷繁复杂的 API 和配置细节之中。</p><p>在人工智能时代，我们越来越多地与一些极其复杂的系统打交道，尤其是大型语言模型（LLM），它们在很多开发者眼中就像一个&quot;黑箱&quot;。我们知道如何向它提问并获得惊艳的答案，但对其内部工作原理却知之甚少。这种未知感，正是技术焦虑的重要来源之一——我们称之为&quot;黑箱焦虑&quot;。</p><p>一个拥有扎实 CS 基础的工程师面对一个新 AI 系统的场景：</p><p><strong>场景一：向量数据库。</strong> 当他听说一个应用使用了向量数据库（Vector Database）来实现语义搜索时 ，他不会仅仅惊叹于其&quot;神奇&quot;的效果。他的大脑会立即启动基于 CS 基础的推理：</p><ul><li><strong>数据结构层面：</strong> 为了实现高效的近邻搜索，这个向量数据库内部很可能使用了某种空间分割数据结构，比如 k-d 树（k-d tree），或者更现代的、基于图的 HNSW（Hierarchical Navigable Small World）算法。这两种结构在查询速度、内存占用和索引构建时间上有什么不同的权衡？</li><li><strong>算法层面：</strong> 它使用的距离度量是欧氏距离还是余弦相似度？这对于不同类型的嵌入向量（Embeddings）意味着什么？</li><li><strong>系统层面：</strong> 这是一个单体数据库还是分布式系统？如果是分布式的，它是如何处理数据分片和查询路由的？</li></ul><p><strong>场景二：AI Agent 系统。</strong> 当他了解到 AI Agent 能够自主规划并执行一系列复杂任务时 ，他不会感到无所适从。他会联想到：</p><ul><li><strong>算法层面：</strong> 这种任务规划本质上是一个在巨大的状态空间中进行搜索的问题。它可能在内部使用了某种图搜索算法，比如 A* 算法，或者蒙特卡洛树搜索（MCTS）。这些算法的潜在缺陷是什么？比如，是否可能陷入局部最优解，或者面临组合爆炸的问题？</li><li><strong>系统层面：</strong> 这个 Agent 系统是如何与外部工具（Tools）进行交互的？是通过结构化的 API 调用吗？那么 API 的可靠性和延迟将成为整个系统的瓶颈。它如何处理工具调用失败的情况？有重试机制或错误处理逻辑吗？</li></ul><h3 id="工程师心智模型">工程师心智模型</h3><p>一个工程师最持久、最宝贵的资产，并非某项具体的技术，而是一种特定的思维方式。这种&quot;工程师心智模式&quot;（Engineering Mindset）是运行所有其他技能的底层操作系统，是应对一切变化的最终依仗。</p><p>综合多方研究，我们可以将工程师心智模式的核心特质归纳为以下几点：</p><ol><li>系统性的问题解决方法</li><li>数据驱动与逻辑推理</li><li>对持续改进的执着</li><li>韧性与适应性</li><li>主动的好奇心</li></ol><p>软技能：</p><ol><li>沟通</li><li>协作</li><li>时间管理</li></ol><h3 id="AI-革命在历史进程中的位置">AI 革命在历史进程中的位置</h3><p>软件开发的历史并非一条平滑的直线，而是由一系列深刻的范式转移（Paradigm Shift）所驱动的。这些变革往往是为了应对上一代范式所暴露出的危机或局限性而生 。</p><ol><li>个体创作时代（Individual Creation）：在软件开发的早期，程序被视为天才程序员在&quot;作坊&quot;中创作的精妙艺术品。</li><li>工程范式时代（Engineering Paradigm）：随着软件系统规模和复杂度的急剧增长，个体创作模式难以为继，导致了&quot;软件危机&quot;。为了应对危机，业界引入了工业化生产的管理思想，提出了&quot;软件工程&quot;的概念，强调需求分析、流程分解、文档规范和质量控制，将软件开发从个体创作推向了大规模、有组织的群体生产 。</li><li>开源范式时代（Open Source Paradigm）：工程范式在应对互联网时代的需求不确定性和快速变化时显得力不从心。此时，以&quot;代码开源、过程开放、大众参与&quot;为特征的开源运动蓬勃发展，形成了一种新的范式。它不强调预先确定的需求，而是通过&quot;自下而上、演化涌现&quot;的方式，激发大规模群体的创作灵感和智慧 。</li><li>群智范式时代（Crowd Intelligence Paradigm）：为了平衡工程范式的确定性和开源范式的不可控性，群智范式应运而生。它试图在规范生产和自由创作之间找到平衡，通过&quot;宏观演化，微观求精&quot;的理念，结合核心团队的引导和外围群体的贡献，实现软件的持续迭代和演化 。</li></ol><table><thead><tr><th>范式</th><th>核心理念</th><th>对&quot;需求&quot;的看法</th><th>对&quot;质量&quot;的看法</th><th>对&quot;效率&quot;的看法</th><th>主要瓶颈</th></tr></thead><tbody><tr><td><strong>工程范式</strong></td><td>自上而下，逐步求精</td><td>开发的起点和依据，需预先明确和规范化</td><td>满足需求规格的程度，通过验证和测试保障</td><td>投入产出比，通过过程控制和自动化提升</td><td>协同效率瓶颈（人月神话），无法适应网络时代的需求不确定性</td></tr><tr><td><strong>开源范式</strong></td><td>自下而上，演化涌现</td><td>不必预先明确，可由开发者自身构思驱动</td><td>体现为社区规模和口碑</td><td>体现为项目迭代效率（如缺陷修复速率）</td><td>结果不可控，将创意作品收敛为产品的成本极高</td></tr><tr><td><strong>群智范式</strong></td><td>宏观演化，微观求精</td><td>持续获取与凝练的过程，以原型版本和疑修(Issue)集合呈现</td><td>宏观上是生态适应能力，微观上是版本满足里程碑的程度</td><td>包含激发效率和汇聚效率，体现为迭代演化的成本与时间</td><td>如何设计高效的协作机制与智能化工具以保障激发与汇聚效能</td></tr></tbody></table><p>当前企业和社会对 AI 的采纳过程，与十多年的云计算转型惊人地相似，我们可以从中汲取宝贵的经验教训：</p><ol><li>始于业务问题，而非技术本身（Start with the Business Problem)</li><li>清晰评估现状（Assess the Current State）</li><li>切勿忽视人的因素（Don’t forget the Humans）</li><li>警惕技术蔓延与技术债务（Avoid Sprawl and Techinal Debt）</li></ol><h3 id="AI-不是威胁而是工具">AI 不是威胁而是工具</h3><p>生成式 AI 正以前所未有的深度和广度渗透到软件开发生命周期（Software Development Lifecycle, SDLC）的每一个环节，从根本上改变着开发者的工作方式 。</p><ol><li>构思与规划（Ideation &amp; Planning）：<ul><li>**需求识别与优先级排序: **分析用户反馈、市场趋势数据，辅助产品负责人识别关键需求并进行优先级排序。</li><li><strong>可行性与资源预测:</strong> 基于历史项目数据，预测项目成本、时间和资源需求，做出更精准的规划。</li><li><strong>数据驱动决策:</strong> 使早期规划更具客观依据，减少主观臆断。</li><li><strong>减少需求冲突:</strong> 自动识别不完整或相互矛盾的需求描述，降低后期返工风险。</li></ul></li><li>设计（Design）<ul><li><strong>原型加速创建:</strong> 快速生成用户界面原型、线框图和流程图。</li><li><strong>架构模式推荐:</strong> 基于项目约束和最佳实践，推荐最优的系统架构或设计模式。</li><li><strong>缩短设计周期:</strong> 大幅减少手动绘制原型和设计文档的时间。</li><li><strong>避免早期架构失误:</strong> 借助 AI 的知识库，帮助团队在项目初期做出更稳健的架构选择 。</li></ul></li><li>开发（Development）<ul><li><strong>智能代码补全与生成:</strong> 基于上下文，自动补全代码行、函数甚至整个逻辑块 (如 GitHub Copilot) 。</li><li><strong>从自然语言生成代码:</strong> 根据高层级的功能描述，直接生成多种语言的代码片段 。</li><li><strong>代码重构与翻译:</strong> 自动将老旧代码（如 COBOL）重构为更易读的现代语言（如 Java），或在不同语言间进行转换。</li></ul></li><li>测试（Testing）<ul><li><strong>自动化测试用例生成:</strong> 从用户故事或需求文档直接生成功能测试用例，包括人类测试者可能忽略的边缘情况。</li><li><strong>AI 辅助代码审查:</strong> 在代码提交前，实时扫描潜在的安全漏洞、逻辑错误或性能瓶颈。</li><li><strong>提升测试覆盖率:</strong> 自动生成全面的测试套件，确保软件质量。</li><li><strong>缺陷左移 (Shift-Left):</strong> 在开发早期发现并修复缺陷，显著降低修复成本和后期风险 。</li></ul></li><li>部署（Deployment）<ul><li><strong>自动化部署脚本生成:</strong> 自动生成部署脚本或基础设施即代码（IaC）的配置文件（如 Terraform, Ansible）。</li><li><strong>CI/CD 流水线优化:</strong> 辅助编排代码、基础设施和配置管理，实现更快的持续交付。</li><li><strong>减少手动部署错误:</strong> 自动化配置过程，降低人为失误的概率。</li><li><strong>加速产品上市时间:</strong> 实现更快速、更频繁的生产环境更新，快速响应市场变化。</li></ul></li><li>运维与维护（Maintainice &amp; Operations）<ul><li><strong>智能监控与异常检测:</strong> 学习系统正常行为模式，主动识别异常，预测潜在故障 。</li><li><strong>自动化事件响应与修复:</strong> 自动执行事件分类、根本原因分析，甚至触发自动化修复脚本 。</li><li><strong>文档与知识库维护:</strong> 自动生成或更新技术文档、API 文档和知识库文章 。</li><li><strong>从被动响应到主动预防:</strong> 在问题影响用户之前进行干预。</li><li><strong>降低平均解决时间 (MTTR):</strong> 快速定位并解决生产问题。</li><li><strong>提升知识管理效率:</strong> 确保文档与代码同步，降低团队沟通成本。</li></ul></li></ol><h3 id="开发者角色的转变">开发者角色的转变</h3><p>经验丰富的工程师的角色，就从亲自编写每一行代码，转变为更高层次的<strong>审查者、整合者和架构师</strong> 。他们的核心工作变成了：</p><ol><li><strong>定义问题与设定目标</strong>：清晰地向 AI 描述要实现的功能和约束条件。</li><li><strong>批判性审查 AI 的输出</strong>：评估 AI 生成的代码是否符合架构设计、是否遵循编码规范、是否存在潜在的性能和安全问题。</li><li><strong>整合与调试</strong>：将 AI 生成的代码片段无缝地整合到现有系统中，并调试其中可能存在的错误。</li><li><strong>做出架构权衡</strong>：决定何时使用 AI、使用哪个 AI 工具，并对 AI 无法处理的、需要深刻理解业务和系统长期演进的复杂架构问题做出决策。</li></ol><h3 id="智能后端的崛起：AIOps-与系统架构">智能后端的崛起：AIOps 与系统架构</h3><p>AI 不再仅仅是用于<strong>构建</strong>后端的工具，而是成为了后端系统本身的<strong>核心组成部分</strong>。这种融合催生了名为 AIOps 的新领域，正在彻底改变我们对系统运维和架构的认知。</p><p>AIOps，即人工智能运维（Artificial Intelligence for IT Operations），是由 Gartner 提出的概念，指的是将大数据和机器学习技术应用于 IT 运维流程，以实现自动化和增强 。在传统的运维模式中，工程师们常常扮演着&quot;救火队员&quot;的角色，在系统发生故障后被动地响应告警、排查问题。而 AIOps 的目标，是利用 AI 的预测和模式识别能力，将运维从<strong>被动响应</strong>转变为<strong>主动预防</strong>，甚至实现<strong>预测性维护</strong> 。</p><p>AIOps 通过分析海量的系统遥测数据（包括日志、指标和追踪），为后端系统的稳定性、性能和安全性带来了革命性的提升。</p><ul><li>主动的事件侦测与预防（Proactive Incident Detection &amp; Prevention）：传统监控系统依赖于预设的静态阈值（例如，CPU 使用率超过 90% 则告警）。而 AIOps 平台通过机器学习算法，能够学习系统在不同负载和时间下的&quot;正常行为&quot;基线。当系统行为偏离这个动态基线时，即使没有触及任何静态阈值，AIOps 也能识别出异常，从而在问题升级为严重故障、影响到终端用户之前，就向工程师发出预警 。</li><li>告警降噪与智能关联（Noise Reduction &amp; Intelligent Alerting）：在复杂的微服务架构中，一个底层的故障（如数据库慢查询）可能会引发连锁反应，导致成百上千个相关服务的告警同时爆发，形成&quot;告警风暴&quot;，让待命工程师（On-call Engineer）不堪重负。AIOps 能够自动将这些相关的告警进行关联和分组，并识别出最初的根源事件，将数百条告警压缩为一条包含丰富上下文的、可操作的事件通知，极大地减少了告警噪音，降低了工程师的认知负担。</li><li><strong>自动化的根本原因分析 (Automated Root Cause Analysis)</strong>：当故障发生时，最耗时的工作往往是定位根本原因（Root Cause）。AIOps 通过分析跨越整个技术栈（应用、中间件、数据库、网络、基础设施）的数据，能够自动识别不同组件之间的因果关系和依赖关系，快速推断出问题的根源，将工程师从繁琐的手动排查中解放出来 。</li><li><strong>自愈与自动化修复 (Self-Healing and Automated Remediation)</strong>：这是 AIOps 最前沿的演进方向，有时也被称为&quot;Agentic AIOps&quot;。在这种模式下，系统不仅能检测和分析问题，还能<strong>自主地采取行动进行修复</strong>。例如：<ul><li>检测到某个服务实例无响应时，自动重启该实例。</li><li>预测到流量高峰即将来临时，自动扩展相关服务的计算资源。</li><li>发现数据库连接池耗尽时，自动调整连接池大小。</li><li>识别到安全威胁时，自动执行隔离或封禁 IP 等安全策略 。</li></ul></li></ul><p>AIOps 的崛起，意味着后端工程师在运维领域的角色正在发生根本性的转变。他们的工作重心将从<strong>被动的&quot;救火&quot;</strong>，转向<strong>主动的&quot;防火&quot;和&quot;消防系统设计&quot;</strong>。具体来说：</p><ol><li>成为 AIOps 平台的架构师和维护者；</li><li>理解并应用机器机器学习模型的基本原理、适用场景和局限性；</li><li>为可观测性而设计（Design for Observability），为 AIOps 提供高质量的&quot;燃料&quot;。</li></ol><h3 id="AI-赋能工程师的基础技能栈">AI 赋能工程师的基础技能栈</h3><ol><li>数学与统计学基础（Mach &amp; Stats Foundation）：这是理解 AI 模型&quot;如何工作&quot;的基石，而不仅仅是&quot;如何使用&quot;。一个扎实的数学基础能让你在面对模型调优、性能瓶颈分析和结果解读时，具备更深刻的洞察力。<ul><li><strong>线性代数 (Linear Algebra)</strong>：理解向量、矩阵、张量及其运算。这是理解数据表示、神经网络结构和各种转换的基础 。</li><li><strong>微积分 (Calculus)</strong>：理解导数、偏导数和链式法则。这是理解梯度下降等优化算法如何工作的关键 。</li><li><strong>概率论与统计学 (Probability and Statistics)</strong>：掌握概率分布、贝叶斯定理、假设检验等概念。这是理解和评估模型性能、处理不确定性的基础 。</li></ul></li><li>核心机器学习概念（Core ML Concepts）：这是 AI 应用领域的通用语言，构成了解决大多数商业问题的基础。<ul><li><strong>学习范式</strong>：清晰地区分监督学习（Supervised Learning）、无监督学习（Unsupervised Learning）和强化学习（Reinforcement Learning）的适用场景 。</li><li><strong>关键算法</strong>：了解一些经典的算法，如线性回归、逻辑回归、支持向量机（SVM）、K-均值聚类（K-Means）以及集成方法（如随机森林、梯度提升树）。</li><li><strong>核心流程</strong>：掌握特征工程（Feature Engineering）、模型评估（Model Evaluation）和超参数调优（Hyperparameter Tuning）等关键环节 。</li></ul></li><li>深度学习与生成式 AI（Deep Learning &amp; Generative AI）：这是当前 AI 浪潮的核心驱动力，也是后端工程师需要重点关注的新兴领域。<ul><li><strong>神经网络基础</strong>：理解神经网络的基本构成，如卷积神经网络（CNNs）和循环神经网络（RNNs）的原理和应用场景 。</li><li><strong>Transformer 架构</strong>：深入理解作为现代大语言模型（LLM）基石的 Transformer 架构 。</li><li><strong>生成式 AI 核心技术</strong>：熟悉检索增强生成（Retrieval-Augmented Generation, RAG）的原理和实现方式，这是将私有数据与 LLM 结合的关键技术 。</li></ul></li><li>AI 框架与平台（AI Framework and Platforms）：将理论知识转化为实践能力，离不开对主流工具的掌握。<ul><li><strong>开发框架</strong>：具备使用 PyTorch 进行模型构建和训练的实践经验 。</li><li><strong>模型生态</strong>：熟悉 Hugging Face 等平台，能够利用其丰富的预训练模型生态系统来加速开发 。</li><li><strong>云 AI 服务</strong>：了解并能够使用主流云服务商（如 AWS Bedrock, Azure AI, Google Vertex AI）提供的 AI 平台和 API 服务 。</li></ul></li></ol><h3 id="应对焦虑的小建议">应对焦虑的小建议</h3><ul><li><strong>高效地休息 (Take Effective Breaks)</strong>：长时间不间断地工作，尤其是在编程这种高强度脑力劳动中，会导致效率下降和精神紧张。采用番茄工作法（Pomodoro Technique），即工作 25-30 分钟后，强制自己休息 5 分钟，或者每工作 1.5-2 小时，进行 10-20 分钟的休息，能够有效恢复精力 。关键在于，休息时要真正地&quot;脱离&quot;，即离开电脑屏幕，站起来走动，或者看看远方，而不是切换到手机上继续浏览信息 。</li><li><strong>关注身体健康 (Physical Well-being)</strong>：身心健康密不可分。规律的体育锻炼和健康的营养摄入，是维持长期成功的两个最重要因素 。运动能释放内啡肽，缓解压力；均衡的饮食能为大脑提供稳定的能量。这就像维护一台高性能的服务器，必须为其提供稳定的电力和良好的散热。</li><li><strong>正念与减负荷 (Mindfulness and De-stimulation)</strong>：<ul><li><strong>正念练习</strong>：每天进行几分钟的冥想练习，可以帮助训练大脑的专注力，减少杂念。可以使用 Headspace、Waking Up 等应用，或者 YouTube 上 的引导式冥想视频 。</li><li><strong>减少咖啡因/酒精摄入</strong>：过量的咖啡因会加剧焦虑感。可以尝试用绿茶等含有 L-茶氨酸（L-Theanine）的饮品来替代，它具有镇静作用 。</li><li><strong>避免过度刺激</strong>：下班后，尽量避免进行高刺激性的活动，如玩竞技类游戏、看动作大片或无休止地刷社交媒体。可以选择散步、听有声书、阅读、做瑜伽等舒缓的活动，让大脑真正地放松下来 。</li></ul></li><li><strong>设立清晰的边界 (Set Boundaries)</strong>：在远程办公和弹性工作日益普遍的今天，工作与生活的边界变得模糊，这极易导致职业倦怠。必须有意识地设立并捍卫自己的边界。<ul><li><strong>明确工作时间</strong>：设定固定的上下班时间，并严格遵守。</li><li><strong>管理通知</strong>：使用手机的&quot;专注模式&quot;或类似功能，在非工作时间屏蔽工作相关的通知，在工作时间屏蔽不必要的干扰 。</li><li><strong>优先排序</strong>：要清醒地认识到，家庭、健康和个人生活，远比修复一个明天才到截止日期的 BUG 更重要。学会对不合理的要求说&quot;不&quot;。</li></ul></li><li><strong>关注过程，而非终点 (Focus on Process, Not Outcome)</strong>：拥抱成长型思维，将你的目标从&quot;完全掌握 AI&quot;这个不切实际的终点，转变为&quot;保持持续学习的状态&quot;这个可控的过程。技术的演进没有终点，因此你的学习也不应有终点。接受这一点，能让你从对&quot;完成&quot;的焦虑中解脱出来，转而享受学习和进步本身带来的乐趣。</li></ul><h2 id="如何高效学习底层与新技术">如何高效学习底层与新技术</h2><p>应对当前挑战的最优策略，是向&quot; AI 增强的 T 型工程师（AI-Augmented T-Shaped Engineer）&quot;转型：</p><ol><li><strong>深度的垂直支柱</strong>：投入时间系统性学习那些具有长期价值的计算机科学基础原理，如算法、系统设计、编译原理等。这是职业生涯的&quot;压舱石&quot;，构成了 T 型的垂直笔画。</li><li><strong>广阔的水平横梁</strong>：建立一个高效的机制，以保持对新兴技术，特别是 AI 领域的广泛、自适应的认知。</li></ol><h3 id="精通技艺：用费曼学习法实现深度理解">精通技艺：用费曼学习法实现深度理解</h3><p>需要掌握：</p><ol><li>计算机理论与编程范式：《计算机程序的构造和解释》。</li><li>编译器与语言原理：《用 go 语言自制解释器》、《用 go 语言自制编译器》。</li><li>算法与数据结构：《业务开发算法 50 讲》、《数据结构与算法之美》。</li><li>操作系统：《手写 OS》、《Writing an OS in Rust》。</li><li>软件工艺：《程序员的修炼：从优秀到卓越》。</li></ol><p>费曼学习法：</p><ol><li>选择一个概念；</li><li>尝试教会一个 12 岁的孩子。</li><li>识别理解的缺口。</li><li>回顾与简化。</li></ol><h3 id="水平横梁：构建情报引擎-微实践">水平横梁：构建情报引擎 &amp; 微实践</h3><p>优质信息源：</p><table><thead><tr><th>信息源名称</th><th>关注领域</th><th>频率</th><th>为何具有高信噪比</th></tr></thead><tbody><tr><td><strong>Benedict’s Newsletter</strong></td><td>宏观科技战略与趋势</td><td>每周</td><td>由顶尖分析师提供深刻的行业洞察，帮助理解技术背后的商业逻辑</td></tr><tr><td><strong>The Pragmatic Engineer</strong></td><td>软件工程实践、文化、职业发展</td><td>每周</td><td>由前 Uber 工程领导者撰写，提供来自一线的、深入的工程管理和技术决策分析</td></tr><tr><td><strong>TLDR Newsletter</strong></td><td>科技、编程、网络安全新闻摘要</td><td>每日</td><td>极其简明扼要，用几句话总结当日最重要的技术新闻，适合快速扫描</td></tr><tr><td><strong>Import AI</strong></td><td>AI 研究、政策与安全</td><td>每周</td><td>由 Anthropic 联合创始人策划，提供对 AI 领域重大进展和伦理影响的专业解读</td></tr><tr><td><strong>ByteByteGo Newsletter</strong></td><td>系统设计与架构</td><td>每周</td><td>深入浅出地讲解复杂的系统设计概念，对后端工程师极具价值</td></tr></tbody></table><p>学习新技术的最佳方式是动手实践。然而，为了不影响核心的深度学习，这种实践必须是目标明确且时间受限的。这里引入&quot;即时学习&quot;（Just-in-Time Learning）和&quot;微问题解决&quot;（Micro-Problem Solving）两个概念。</p><ul><li><p><strong>即时学习（JIT Learning）</strong>：这是一种按需学习的模式，即在需要应用某项知识或技能时才去学习它，而不是进行大规模的预先学习 。这种方式可以减轻认知负担，并将学习与实际应用紧密结合，从而提高知识留存率。</p></li><li><p><strong>玩具项目（Toy Projects）</strong>：当一个新技术（例如一个新的 AI 框架如 LangGraph 或一个向量数据库）出现并显得重要时，为其分配一个严格限定时间的&quot;玩具项目&quot;，比如一个周末或几个晚上的时间 。项目的目标不是构建一个生产级应用，而是通过动手实践，获得对该技术核心概念、API 设计和工作流程的直观理解。</p></li><li><p><strong>微问题解决（Micro-Problem Solving）</strong>：将玩具项目分解为一系列最小的可执行任务 。例如，学习构建一个 RAG（检索增强生成）应用，可以分解为以下微问题：</p><ol><li>加载一篇 PDF 文档；</li><li>将文本分割成块（chunking）；</li><li>为文本块生成向量嵌入（embeddings）；</li><li>将嵌入存储到向量数据库；</li><li>根据用户查询检索最相关的文本块；</li><li>将检索到的内容与原始查询结合，生成最终答案 。</li></ol><p>这种分解使得学习过程 manageable，并能提供持续的、小步快跑式的成就感。</p></li></ul><h3 id="拓展横梁：认知-AI-产品生态系统">拓展横梁：认知 AI 产品生态系统</h3><p>在 AI 时代，一名高级工程师的&quot;广度&quot;已不再局限于技术本身。由于 AI 技术的选择（如模型、框架）直接影响到产品的成本、延迟、用户信任乃至商业模式，工程决策与商业战略的联系变得前所未有地紧密 。</p><p>因此，现代工程师的 T 型横梁需要延伸至对 AI 产品生态的理解。这包括：</p><ul><li><strong>AI 产品管理框架</strong>：了解如何识别和验证 AI 用例，评估其商业价值、技术可行性和用户可用性 。</li><li><strong>AI 产品上市策略（GTM）</strong>：理解 AI 产品，尤其是具有不确定性输出的概率性产品的市场定位、定价模型和营销渠道策略 。</li><li><strong>构建可防御的&quot;护城河&quot;</strong>：明白在 AI 技术本身易于复制的背景下，产品的长期竞争力更多地来自于专有数据、独特的工作流集成、强大的用户体验和生态系统 。</li></ul><h3 id="时间管理：深度工作与扫描协议">时间管理：深度工作与扫描协议</h3><p><strong>深度工作模块 (The Vertical Bar)</strong>：这是为 T 型模型的&quot;垂直支柱&quot;——即基础原理学习——专门预留的时间。</p><ul><li><p><strong>方法</strong>：每周规划 2 到 3 个<strong>不可协商的、时长为 2 小时的“深度工作”时间块</strong> 。将这些时间块像对待最重要的会议一样标记在日历上，并告知团队成员在此期间除非紧急情况，否则不要打扰。</p><blockquote><p>认知科学研究表明，一次中断后，人需要平均 23 分钟才能重新进入专注状态，对于复杂的编程任务，这个时间更长 。因此，长时间、不受干扰的模块对于攻克 SICP 或 DDIA 中的复杂概念至关重要。</p></blockquote></li></ul><p><strong>扫描与即时学习模块 (The Horizontal Bar)</strong>：这是为 T 型模型的“水平横梁”——即技术雷达扫描和即时探索——设计的时间。</p><ul><li><strong>方法</strong>：安排更短、更频繁的时间块，例如<strong>每日 30-45 分钟</strong>，用于&quot;扫描&quot;活动。利用这段时间阅读筛选过的新闻通讯、浏览新技术发布、或推进你的&quot;玩具项目&quot;。这个协议的目的是防止对新技术的追逐侵占宝贵的深度工作时间。</li></ul><p><strong>任务批处理 (Task Batching)</strong>：</p><ul><li><strong>方法</strong>：将性质类似的&quot;浅层工作&quot;（shallow work）归集在一起，在指定的时间块内一次性处理完毕 。例如，将所有非紧急的邮件回复、代码审查（Code Review）或行政事务集中在下午的某个固定时段处理。这可以有效减少任务切换带来的认知损耗，为深度工作保留宝贵的精力。</li></ul>]]></content>
    
    
    <summary type="html">本文探讨了在 AI 时代如何应对技术焦虑的问题。通过分析底层技术学习的必要性，提出了&quot;原则重于工具&quot;的核心观点，并构建了包含 T 型知识结构、时间盒管理、即时学习等策略的系统性解决方案，帮助工程师在技术海洋中找到方向，从焦虑走向成长。</summary>
    
    
    
    <category term="ai问答" scheme="https://hedon.top/categories/ai%E9%97%AE%E7%AD%94/"/>
    
    
    <category term="思考" scheme="https://hedon.top/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Q&amp;A丨在 AI 时代，还有必要学习底层技术吗？</title>
    <link href="https://hedon.top/2025/06/17/qa-should-learn-underlying-principles-in-ai-era/"/>
    <id>https://hedon.top/2025/06/17/qa-should-learn-underlying-principles-in-ai-era/</id>
    <published>2025-06-17T11:13:00.000Z</published>
    <updated>2025-06-26T03:00:09.051Z</updated>
    
    <content type="html"><![CDATA[<p>毫无疑问，<strong>绝对有必要，甚至比以往任何时候都更加重要。</strong></p><p>AI 时代，应用层的技术和工具变得越来越“智能”和“易用”，这反而造成了一种危险的错觉：似乎我们不再需要理解那些复杂的底层原理了。但真相恰恰相反。</p><p>把自己想象成一位 F1 赛车手。AI 工具就像一个极其先进的驾驶辅助系统，它能帮你自动换挡、优化过弯路线，甚至在某些直道上自动驾驶。这能让你开得更快，但如果你想成为冠军，你必须理解：</p><ul><li><strong>引擎的工作原理（操作系统、CPU）</strong>：为什么在某个转速下引擎会抖动？如何压榨出极限动力？</li><li><strong>空气动力学（网络、I/O）</strong>：为什么今天赛车感觉有点“飘”？是风向变了还是下压力调校出了问题？</li><li><strong>轮胎与悬挂（数据结构、数据库）</strong>：如何根据赛道温度和磨损情况选择轮胎？悬挂的软硬如何影响抓地力？</li></ul><p>只依赖驾驶辅助系统的车手，在赛车一切正常时表现尚可。一旦出现任何异常——轮胎异常磨损、引擎过热、通信系统延迟——他将束手无策，只能无奈退赛。而理解底层的车手，能通过细微的反馈感知到问题，与工程师沟通，调整策略，最终赢得比赛。</p><hr><h3 id="五个无法回避的理由">五个无法回避的理由</h3><p>当你再对学习底层技术产生动摇时，请用以下几点来说服自己：</p><h4 id="1-抽象层终会“泄漏”，底层知识是你的救生筏">1. 抽象层终会“泄漏”，底层知识是你的救生筏</h4><p>这是软件工程颠扑不破的“<strong>抽象泄漏定律</strong>”（The Law of Leaky Abstractions）。任何为了简化而存在的上层工具（包括 AI），都无法完美隐藏其底层的复杂性。当问题发生时，这个“泄漏”就会出现。</p><ul><li><strong>场景 A</strong>：AI 帮你生成了一段代码，用于从数据库查询数据，但在生产环境压力下响应极慢。AI 无法告诉你原因是索引失效、发生了锁竞争还是因为 N+1 查询。这时，你需要<strong>数据库底层知识</strong>来分析执行计划、优化索引。</li><li><strong>场景 B</strong>：一个由 AI 调度的微服务出现随机性高延迟。AI 无法告诉你这是因为容器的 CPU 被限制、发生了网络丢包，还是因为 JVM 的垃圾回收（GC）暂停。这时，你需要<strong>操作系统和网络的底层知识</strong>来定位根源。</li><li><strong>场景 C</strong>：你的 RAG 应用召回结果不理想。AI 无法告诉你是因为向量嵌入模型选择不当，还是向量数据库的索引策略（如 HNSW）参数需要调优。这需要你理解<strong>数据结构和算法</strong>。</li></ul><p><strong>说服自己：当 AI 失灵或表现不佳时，能拯救你的不是另一个 AI，而是你对底层的掌控力。</strong></p><h4 id="2-问题的根源，往往深藏于你看不到的地方">2. 问题的根源，往往深藏于你看不到的地方</h4><p>高级的故障排查（Troubleshooting）是后端工程师的核心价值之一。问题的表象（Symptom）和根源（Root Cause）往往不在同一个层面。</p><ul><li>一个 API 超时，表象是应用层错误。根源可能是 TCP 连接池耗尽、是 DNS 解析缓慢、是磁盘 I/O 达到瓶颈。</li><li>AI 可以帮你分析日志，找到那个超时的 API。但它很难跨越多个技术栈，将零散的线索串联起来，形成一个完整的证据链，最终定位到那个深藏的根源。这种系统性的诊断能力，源于你脑中那张完整的技术底层地图。</li></ul><p><strong>说服自己：只懂“驾驶”的人在车坏了时只能打电话求助，而懂“机械”的人能自己打开发动机盖解决问题。我要做后者。</strong></p><h4 id="3-真正的工程判断力，建立在对权衡（Trade-off）的理解之上">3. 真正的工程判断力，建立在对权衡（Trade-off）的理解之上</h4><p>AI 可以提供“方案”，但无法为你做出最佳的“决策”。工程的核心是权衡。</p><ul><li>用关系型数据库还是 NoSQL？用 Redis 还是本地缓存？服务间通信用 gRPC 还是 RESTful API？</li><li>每一个选择背后，都是对性能、成本、一致性、可用性、开发效率等一系列因素的综合考量。而这些考量的依据，正是来自你对各种技术底层实现机制的理解。不了解 TCP 和 HTTP/2 的底层差异，你如何能在 gRPC 和 REST 之间做出最合理的选择？不了解 B+树和 LSM 树，你如何为特定场景选择最合适的数据库？</li></ul><p><strong>说服自己：AI 可以成为我的顾问，但最终做出决策、并为之负责的人是我。我的决策质量，直接取决于我的底层知识深度。</strong></p><h4 id="4-你的职业天花板，由底层知识决定">4. 你的职业天花板，由底层知识决定</h4><p>随着 AI 自动化掉越来越多重复性的、模式化的编码工作，未来后端工程师的价值会更加向两个方向集中：</p><ul><li><strong>向上</strong>：深入理解业务，进行业务建模和架构设计。</li><li><strong>向下</strong>：解决硬核的技术难题，进行极致的性能优化和系统稳定性保障。</li></ul><p>这两个方向，都极度依赖底层技术。没有底层知识，你的架构设计就是空中楼阁；没有底层知识，你永远无法成为解决最棘手问题的那个关键人物。</p><p><strong>说服自己：AI 会拉平初级和中级工程师的差距，但底层技术功底是区分高级/资深工程师与普通工程师的护城河。</strong></p><h4 id="5-创新，源于对第一性原理的掌握">5. 创新，源于对第一性原理的掌握</h4><p>我们使用的所有 AI 工具、框架、平台，本身就是由那些深刻理解底层技术的人创造出来的。他们不是简单地“使用”技术，而是基于对计算、存储、网络等第一性原理的理解，去“创造”新的技术。</p><p>如果你满足于只做一个技术的使用者，或许可以忽略底层。但如果你心中还有一丝火花，想在技术的世界里留下自己的印记，想创造出真正有价值的东西，那么掌握底层就是你唯一的路径。</p><p><strong>说服自己：学习底层技术，不仅是为了解决今天的问题，更是为了获得解决明天未知问题、甚至定义未来的能力。</strong></p><hr><h3 id="结论：如何平衡学习">结论：如何平衡学习</h3><p>这并非要求你立刻放下所有 AI 学习，去埋头啃《计算机程序的构造和解释》。正确的做法是：</p><ul><li><strong>保持“T 型”结构</strong>：在积极拥抱和学习 AI 这个横向技能的同时，有计划地、持续地加深你的纵向底层知识。</li><li><strong>问题驱动学习</strong>：在应用 AI 或开发业务时，遇到任何性能、稳定性、或“匪夷所思”的问题，都不要轻易放过。把它当作一个深入学习底层技术的绝佳契机。从“为什么会这样？”开始，一路向下挖掘，直到你触及问题的本质。</li></ul><p>AI 时代，底层技术不是你的“备选项”，而是你的“压舱石”。它能让你的技术大船在 AI 的巨浪中，行得更稳、更快、更远。</p>]]></content>
    
    
    <summary type="html">本文讨论了在 AI 时代继续扎根学习底层技术的重要性，并给出 5 个说服自己的理由。</summary>
    
    
    
    <category term="ai问答" scheme="https://hedon.top/categories/ai%E9%97%AE%E7%AD%94/"/>
    
    
    <category term="思考" scheme="https://hedon.top/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《Rust Atomics and Locks》</title>
    <link href="https://hedon.top/2025/06/12/note-rust-atomics-and-locks/"/>
    <id>https://hedon.top/2025/06/12/note-rust-atomics-and-locks/</id>
    <published>2025-06-12T01:01:24.000Z</published>
    <updated>2025-06-17T11:12:23.462Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><a href="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust 原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust 实战丨手写一个 SpinLock</a></li><li><a href="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust 实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust 实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust 原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust 实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust 实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust 实战丨手写一个 RwLock</a></li><li><a href="https://hedon.top/2025/06/12/note-rust-atomics-and-locks/">读书笔记丨《Rust Atomics and Locks》</a>👈 本篇</li></ul><hr><p>本文整理总结 <em>Mara Bos</em> 所著《Rust Atomics and Locks》一书的核心内容，系统归纳 Rust 并发编程中原子操作与锁机制的关键概念和技术细节。内容涵盖原子操作与内存顺序、Rust 并发的基础工具（内部可变性、线程安全保证、操作系统并发原语），以及多种常用并发原语（自旋锁、一次性通道、原子引用计数、互斥锁、条件变量、读写锁）的实现要点。通过这些内容的串联，展示概念之间的联系、底层原理、Rust 标准库实现方式与实际工程实践的关系，方便读者快速回顾并用作知识索引。</p><h2 id="原子操作基础">原子操作基础</h2><p>Rust 提供了一系列<strong>原子类型</strong>（如 <code>AtomicBool</code>、<code>AtomicUsize</code> 等）来实现线程之间的<strong>无锁并发</strong>数据共享。对原子类型的操作分为三大类别：</p><ul><li><strong>Load（加载）</strong> 与 <strong>Store（存储）</strong>：分别用于原子地读取和写入值。</li><li><strong>Fetch-and-Modify（获取并修改）</strong>：在返回旧值的同时，原子地对值进行修改，例如 <code>fetch_add</code>、<code>fetch_sub</code>、<code>fetch_or</code>、<code>fetch_and</code>、<code>fetch_xor</code>、<code>swap</code> 等。</li><li><strong>Compare-and-Exchange（比较并交换）</strong>：即原子地执行“如果当前值等于预期值则交换”的操作，包括 <code>compare_exchange</code> 和 <code>compare_exchange_weak</code>。</li></ul><p>不同计算机体系结构对原子操作的支持方式有所差异，主要体现在<strong>指令集类别</strong>和<strong>内存模型</strong>上。现代CPU通常分为两种指令集架构：</p><ul><li><strong>CISC（复杂指令集）</strong>：典型代表是 x86 架构（包括 x86-64）。CISC 指令集功能丰富、单条指令可执行复杂操作，但硬件实现复杂。x86-64 是基于 CISC 的 64 位扩展架构，由 AMD 设计主导，追求通过硬件复杂性换取高性能和广泛兼容性，主导了桌面与服务器领域。</li><li><strong>RISC（精简指令集）</strong>：典型代表是 ARM 架构（如 ARM64）。RISC 指令集精简、每条指令功能单一，硬件实现相对简单且能效更高。ARM64 基于 RISC 的 64 位架构，由 ARM 设计，指令简洁、低功耗，在移动设备占主导地位并逐步进入服务器和 PC 领域。</li></ul><p><strong>原子性的实现机制：</strong> 在 x86-64 上，保证原子性的关键是使用 <code>lock</code> 前缀锁定总线或缓存行来原子执行指令；而在 ARM64 上，则依赖 Load-Linked/Store-Conditional（<strong>LL/SC</strong>）指令对实现原子操作。例如，x86 上原子的 compare-and-swap 通常通过 <code>LOCK CMPXCHG</code> 指令完成，而 ARM 上通过一对原子链式的加载/存储指令完成。如果处理器不支持所需的原子指令，Rust 会在编译期报错以防止不安全的并发操作。</p><p><strong>内存序模型差异：</strong> 不同架构的内存序保证也不同。x86-64 属于<strong>强顺序</strong>（Total Store Order, TSO）模型，对内存操作的重排序有限制，而 ARM64 属于<strong>弱顺序</strong>模型，需要显式的内存屏障来保证顺序。具体来说，x86-64 默认禁止以下重排序：</p><ul><li><strong>Load → 后续操作</strong> 不允许乱序：例如在同一线程中，先执行的读取不能被后执行的操作越过。</li><li><strong>Store → 前序操作</strong> 不允许乱序：一个存储不能提前到先前未执行完的操作之前。</li><li><strong>Store → 随后的 Load</strong> 则<strong>可能</strong>乱序：即一个存储操作后紧跟的加载操作在实际执行中可能被处理器提升到存储之前执行（典型的 Store-Load 重排）。</li></ul><p>相比之下，ARM 等弱序模型中，大多数内存操作在缺乏同步指令时都可能被重排序，因此所有原子操作默认<strong>可能乱序</strong>，需要利用内存屏障指令（ARM 上如 <code>dmb ish</code>、<code>dmb ishld</code>）来提供顺序保证。此外，在 compare-and-exchange 操作上，x86-64 并未提供真正的“弱”版本（即不会出现无故失败的情况），因而 Rust 中的 <code>compare_exchange_weak</code> 在 x86 上实际上与强语义等价；而 ARM64 的 LL/SC 实现存在可能的自发失败，因此区分了 weak 版本以便需要时重试。</p><p>综上，<strong>硬件架构对原子操作的支持</strong>直接影响Rust并发库的实现策略：在强序的 x86 上，一些内存序保证可由硬件天然提供，而在弱序的 ARM 上则必须借助显式屏障指令来达成。Rust 的原子类型实现会针对不同架构插入相应的汇编指令，以确保提供声明的原子性和内存序语义。</p><h2 id="内存顺序与内存模型">内存顺序与内存模型</h2><p>多线程环境下面临两大核心问题：</p><ol><li><strong>指令乱序执行（Out-of-Order Execution）</strong>：现代CPU会对指令进行乱序执行和优化，这可能导致程序实际执行顺序与源码顺序不一致。</li><li><strong>跨线程内存可见性</strong>：不同线程对内存修改的可见性无法保证——一个线程写入的数据，何时及如何对其他线程可见，需要通过同步手段来控制。</li></ol><p>为解决上述问题，需要了解内存模型中的两类关键顺序关系：</p><ul><li><strong>Sequenced-Before（先行顺序）</strong>：描述单个线程内操作的先后顺序。按照程序中的先后关系确定，在同一线程内如果操作 A 在源码中位于操作 B 之前，那么 A <em>sequenced-before</em> B。先行顺序遵循以下规则：若操作 B 数据依赖于 A，则 A 必定在 B 之前执行；针对同一原子变量的操作按程序顺序执行；若两个独立操作无数据依赖且访问不同变量，那么处理器可能对它们重排。总之，先行顺序限定单线程的执行次序，为编译器和 CPU 提供本线程内优化的依据。</li><li><strong>Happens-Before（先发生）</strong>：描述跨线程的操作顺序和可见性。如果操作 A <em>happens-before</em> 操作 B，意味着 A 的所有内存效果对于 B 是可见的。Happens-Before 建立在线程间的同步关系上，例如：在同一线程中，函数 <code>f()</code> 调用在前而 <code>g()</code> 在后，则 <code>f()</code> happens-before <code>g()</code>；一个线程调用 <code>thread::spawn</code> 创建新线程发生在对该新线程的 <code>join</code> 之前；再如互斥锁的<strong>加锁</strong>先于<strong>解锁</strong>操作（unlock 发生在 lock 之前释放锁的线程完成临界区之后）。这些 Happens-Before 规则确保了特定事件的<strong>跨线程可见性</strong>和执行顺序。</li></ul><p>Rust 的原子操作支持五种内存顺序（<code>Ordering</code> 枚举），从最松弛到最严格依次为 <strong>Relaxed</strong>、<strong>Release</strong>、<strong>Acquire</strong>、<strong>AcqRel</strong>、<strong>SeqCst</strong>。不同的内存顺序决定了原子操作在乱序和可见性方面的保证强度。下表总结了它们的语义、保证、使用场景和示例：</p><table><thead><tr><th>内存顺序</th><th>说明</th><th>保证</th><th>适用场景</th><th>示例</th></tr></thead><tbody><tr><td><strong>Relaxed</strong></td><td>最宽松的内存顺序</td><td>- 仅保证操作的原子性<br>- 不提供任何同步保证<br>- 不建立 happens-before 关系</td><td>- 简单计数器- 极高性能要求且确定不需要跨线程同步<br/>- 已通过其他方式确保数据可见性同步</td><td><code>counter.fetch_add(1, Ordering::Relaxed)</code></td></tr><tr><td><strong>Release</strong></td><td>用于存储操作</td><td>- 此操作之前的所有内存访问不会被重排到它之后<br/>- 与后续线程的 Acquire 操作配对可建立 happens-before 关系</td><td>- 典型“生产者-消费者”模型- 发布共享数据给其他线程<br/>- 写入一个“初始化完成”标志</td><td><code>data.store(val, Ordering::Release)</code></td></tr><tr><td><strong>Acquire</strong></td><td>用于加载操作</td><td>- 此操作之后的所有内存访问不会被重排到它之前<br/>- 与另一个线程先前的 Release 操作配对可建立 happens-before 关系</td><td>- “生产者-消费者”模型中获取数据- 读取共享数据（需确保数据已由其他线程准备好）<br/>- 检查某个初始化完成的标志</td><td><code>let val = data.load(Ordering::Acquire)</code></td></tr><tr><td><strong>AcqRel</strong></td><td>读改写操作的组合语义</td><td>- 同时具有 Acquire 和 Release 的所有内存顺序保证<br/>- 只能用于原子读-改-写操作（RMW），对读取部分提供 Acquire 保证，对写入部分提供 Release 保证</td><td>- 需要双向内存同步的原子操作v- 实现锁等同步原语（例如原子自增既读取又写入）<br/>- 较复杂的原子同步场景</td><td><code>value.fetch_add(1, Ordering::AcqRel)</code></td></tr><tr><td><strong>SeqCst</strong></td><td>全局顺序一致的最强顺序</td><td>- 包含 AcqRel 的所有保证<br/>- <strong>所有线程</strong>对所有 SeqCst 原子操作的观察顺序一致（总排序）<br/>- 提供跨线程全局的内存顺序一致性</td><td>- 需要严格的全局一致性场景<br/>- 不确定使用哪种顺序时采用（保守策略）<br/>- 对性能要求不敏感的代码</td><td><code>flag.store(true, Ordering::SeqCst)</code></td></tr></tbody></table><p>需要注意的是，<strong>Release</strong> 通常与 <strong>Acquire</strong> 搭配使用，共同建立线程间的同步关系。当线程 A 使用 Release 语义写入某个共享变量，线程 B 之后使用 Acquire 语义读取到了该值，那么可以保证：线程 A 中那次 Release 写入之前的所有内存写操作，对线程 B 在 Acquire 读取之后的所有操作都是可见的。换言之，通过 Release-Acquire 的配对建立了跨线程的 <em>happens-before</em>：生产者线程写入的数据对消费者线程可见。这就是典型的生产者-消费者模式同步的原理。例如，一个线程完成初始化后将标志位设为 true（Release），另一个线程反复以 Acquire 读取该标志，当读到 true 时即可安全地读取之前初始化的数据。</p><p>另一个重要概念是 <strong>释放序列（Release Sequence）</strong>。释放序列指的是：“以一次 Release 操作为开头，紧跟其后的、在同一原子变量上的所有<strong>同一线程</strong>的写操作或读改写操作（RMW），共同形成一个连续序列”。如果某线程在 Acquire 读取时读到了这个序列中的任意一个写，那么该 Acquire 将和序列开头的那次 Release 建立同步关系。简单理解，Release 序列涵盖了 Release 写入线程接下来对同一原子变量的后续修改，以及可能由其他线程执行的 RMW 操作，从而确保 Acquire 端读取到序列中任何结果时，都能看到序列开头 Release 之前的所有内存效果。</p><p>底层实现上，编译器和CPU通过**内存屏障（Memory Barrier）**指令来实现上述内存顺序保证。主要有三类内存屏障：</p><ol><li><strong>读屏障（Load Barrier）</strong>：确保屏障之前的所有读操作都已完成，并阻止后续读操作提前执行（即后面的读不会跑到屏障之前）。这相当于 Acquire 语义的效果，在很多架构上，Acquire Load 会在汇编层插入读屏障指令或使用带Acquire语义的特殊读指令。</li><li><strong>写屏障（Store Barrier）</strong>：确保屏障之前的所有写操作都已对内存可见，并阻止后续写操作提前执行（不让后面的写越到屏障之前）。这对应 Release 语义，Release Store 常通过写屏障指令或带Release语义的原子写指令实现。</li><li><strong>全屏障（Full Barrier）</strong>：同时具有读屏障和写屏障效果，禁止任何读或写的重排序。这通常用于 SeqCst 场景，确保全局一致的内存顺序。在 x86 上 <code>MFENCE</code> 指令就是一个全屏障，而 ARM 上则需要 <code>DMB ISH</code> 等全内存屏障指令来达到 SeqCst 效果。</li></ol><p>通过合理选择内存顺序和屏障，程序员可以在性能和内存可见性保证之间取得平衡：在确保数据跨线程可见性和操作顺序正确的前提下，尽量减少不必要的开销。</p><h2 id="Rust-并发的基础工具">Rust 并发的基础工具</h2><h3 id="UnsafeCell：内部可变性的支柱">UnsafeCell：内部可变性的支柱</h3><p>Rust 的所有权和借用规则在编译期就保证了单线程情况下的数据安全，例如通过不可变引用 <code>&amp;T</code> 阻止对数据的修改，通过可变引用 <code>&amp;mut T</code> 确保独占访问。然而，在实现并发数据结构时，经常需要突破这一限制：比如在只有不可变引用的情况下也能修改内部数据（典型场景是通过锁对象的不可变引用来获取内部数据的可变引用）。为此，Rust 提供了一个底层机制 <strong>UnsafeCell</strong> 来支持<em>内部可变性</em>。</p><p><strong>UnsafeCell</strong> 是 Rust 标准库中的一个关键类型，它包装了一个数据，使得即使只有对该容器的不可变引用，也可以通过 UnsafeCell 提供的方法来修改内部的数据。当然，这种内部修改必须在 <code>unsafe</code> 块中进行，因为它突破了编译器的借用检查。很多线程同步原语（例如 <code>Mutex</code>、<code>RwLock</code>，甚至原子类型如 <code>AtomicBool</code> 本身）内部都使用了 UnsafeCell 来绕过编译期的限制，从而允许在并发场景下安全地修改受保护的数据。</p><p>基于 UnsafeCell，Rust 标准库封装了几种提供不同程度内部可变性的类型：</p><ul><li><strong>Cell</strong>：提供最小程度的内部可变性，只能用于复制语义的类型（实现 <code>Copy</code> 的类型）。通过 <code>get</code> 和 <code>set</code> 方法在不违反借用规则的情况下读取或修改内部的值。</li><li><strong>RefCell</strong>：提供<em>运行时</em>的借用检查，实现更灵活的内部可变性，可以在运行时确保不可变借用和可变借用的不混淆。但 <code>RefCell</code> 不是线程安全的（不实现 <code>Sync</code>），只能用于单线程场景。</li><li><strong>Mutex</strong>：它利用锁机制保证线程安全的内部可变性。Mutex 本质上也是通过 UnsafeCell 允许内部数据可变访问，但同时提供了线程间互斥保护。相应地，Mutex的使用成本较高，需要在多线程间进行加锁和解锁的开销。</li></ul><p>通过 UnsafeCell 提供的内部可变性支撑，Rust 才能编写出安全的并发数据结构。在这些结构中，我们将看到 UnsafeCell 的身影，它保证了在编译器视角下“不可能”的行为（即在不可变引用下修改数据）在运行时被合理地使用。</p><h3 id="Send-与-Sync：无数据竞争的基石">Send 与 Sync：无数据竞争的基石</h3><p>Rust 类型系统通过两个重要的<em>标记 trait</em>（Marker Trait）来实现<strong>线程安全</strong>的静态检查，这两个 trait 就是 <strong>Send</strong> 和 <strong>Sync</strong>。它们没有具体的方法，实现这两个 trait 的类型会自动享有编译器的特殊处理，用于标记跨线程的使用安全性：</p><ul><li><strong>Send</strong> 表示一个类型的所有权可以在线程间安全地传递。如果类型 <code>T</code> 实现了 Send，则 <code>T</code> 或 <code>&amp;mut T</code> 可以从一个线程转移到另一个线程。例如，大部分基础类型和完全由 Send 组成的复合类型都是 Send。如果某个类型内部包含不安全的共享状态且未保护，那它可能不会实现 Send（编译器会自动推导决定，开发者也可手动禁止）。</li><li><strong>Sync</strong> 表示一个类型的<strong>不可变引用</strong>可以在线程间安全共享。也就是说，如果 <code>&amp;T</code> 实现了 Sync，则允许多个线程同时拥有对该类型的不可变引用。这要求类型内部的所有可能被并发访问的可变状态都已经被保护（比如用了原子或锁）。大部分基本类型的不可变引用都是 Sync，像 <code>&amp;i32</code> 等是可以多线程共享的。如果某类型不是 Sync，则即使它本身是只读的，也无法同时被多个线程引用（例如 <code>Rc&lt;T&gt;</code> 因为不是线程安全的引用计数，因此 <code>&amp;Rc&lt;T&gt;</code> 也不是 Sync）。</li></ul><p>Send 和 Sync 这两个标记 trait 是 Rust 保证无数据竞争（Data Race Free）的基石。编译器通过这两个trait禁止不安全的跨线程操作：任何在多个线程间共享或转移的值必须是 Send/Sync 的，否则将无法编译。这种机制在编译期就杜绝了绝大部分数据竞争情况，开发者只有在显式使用 <code>unsafe</code> 绕过时才可能违背这个保证。因此，在实现并发原语时，确保正确实现 Send/Sync（或适当地禁止它们）是非常重要的。Rust 标准库多数类型默认实现 Send/Sync（如果其组成部分实现的话），但像 <code>Rc&lt;T&gt;</code>（非线程安全引用计数）或 <code>RefCell&lt;T&gt;</code>（仅供单线程内部可变性）则没有实现，以防误用。</p><h3 id="操作系统并发原语：原子等待与唤醒">操作系统并发原语：原子等待与唤醒</h3><p>高效的阻塞式并发离不开操作系统提供的底层同步原语。目前主流的桌面/服务器操作系统（如 Linux、macOS、Windows）都提供了类似的原子等待/唤醒机制，以构建更高级的锁和并发结构。这些机制允许线程在等待某个条件时挂起睡眠，避免忙轮询浪费CPU，并在条件达成时高效地被唤醒。概括来说，有三个最重要的底层操作：</p><ul><li><strong>wait( &amp;AtomicU32, expected_value )</strong>：当指定的原子变量值等于给定期待值时，让当前线程陷入休眠等待；如果原子值不匹配则立即返回。这个操作通常是原子级的检查并挂起，如 Linux 上的 <code>futex</code> 系统调用 (<code>futex_wait</code>) 或 Windows 上的 <code>WaitOnAddress</code> 等，它们允许用户态线程在内核中高效睡眠，等待变量改变。</li><li><strong>wake_one( &amp;AtomicU32 )</strong>：唤醒<strong>一个</strong>在指定原子变量上等待的线程。对应地，Linux futex 提供 <code>futex_wake</code> 可以唤醒等待在同一个地址上的一个线程；Windows 提供 <code>WakeByAddressSingle</code> 等。</li><li><strong>wake_all( &amp;AtomicU32 )</strong>：唤醒<strong>所有</strong>在该原子变量上等待的线程。对应 futex 的 <code>wake</code> 可以指定唤醒所有等待的线程，Windows 有 <code>WakeByAddressAll</code> 等。</li></ul><p>这些原语本质上将<strong>原子变量的变化</strong>和<strong>线程调度</strong>结合起来，实现了类似 “当原子变量处于某值时让线程睡眠，直到变量改变再唤醒” 的机制。这为构建更高级的同步工具奠定了基础：例如 Mutex 在获取不到锁时，可以调用 wait 挂起线程等待锁的原子标志变为可用；当释放锁时，调用 wake_one 唤醒一个等待线程继续争夺锁。相比纯用户态的自旋，这种机制大幅提高了效率，因为等待线程无需占用 CPU。Rust 标准库的实现以及第三方并发库（如 <code>parking_lot</code>）都会利用操作系统提供的此类原语（在 Linux 上通常就是 futex，在其他平台可能用条件变量等模拟）来实现高性能的阻塞同步。</p><p>本书的示例实现中多次使用了 <code>atomic-wait</code> crate 来模拟 futex 等行为，以便在稳定版上构建自定义锁。</p><h2 id="自旋锁（SpinLock）">自旋锁（SpinLock）</h2><p><strong>自旋锁</strong>是一种最简单的锁实现，其特性是当一个线程尝试获取锁而锁已被占用时，该线程不会阻塞睡眠，而是在循环中反复检查锁是否可用（“忙等待”）。自旋锁避免了线程切换的开销，适用于临界区极短、锁持有时间非常小的场景，因为忙等待会浪费CPU时间。如果临界区较长，使用自旋锁会导致CPU空转浪费资源，此时应采用会阻塞线程的锁（如 Mutex）。Rust 标准库并未提供显式的自旋锁类型，但可以使用原子操作很容易地实现一个。书中通过实现一个简化的 SpinLock 展示了原子操作和 RAII 等在并发中的应用：</p><ul><li><strong>v0：最小化原子标记的实现</strong> – 采用一个原子布尔标志表示锁状态（如 <code>AtomicBool</code>），最初版本只实现了基本的 <code>lock()</code> 和 <code>unlock()</code>。当标志从 <code>false</code> 变为 <code>true</code> 表示获取锁成功。线程获取锁时使用原子交换 (<code>swap</code>) 将标志设为 true，并在获取失败时不断重试（忙等）。该版本功能最小，不负责保护任何数据。</li><li><strong>v1：绑定受保护数据</strong> – 将锁和需要保护的数据封装在一起，定义为如 <code>SpinLock&lt;T&gt;</code>，内部持有一个 <code>UnsafeCell&lt;T&gt;</code> 来存储数据。这保证了数据只能通过获取锁后才能访问，提升了数据安全性。接口上提供 <code>lock()</code> 返回一个包裹了 <code>&amp;mut T</code> 的锁守卫类型，以确保在持有锁期间才能访问内部数据。</li><li><strong>v2：引入 RAII 实现自动解锁</strong> – 利用 Rust 的 RAII（Resource Acquisition Is Initialization）惯用法，返回一个锁守卫（如 <code>SpinLockGuard</code>），其 <code>Drop</code> 实现中自动调用解锁操作。这样，当锁守卫离开作用域时（不论是正常离开还是因为 panic 等非常路径），都能确保锁被正确释放，不必依赖用户手动调用 <code>unlock()</code>。这一版本显著提高了易用性和安全性，防止了因忘记解锁导致的死锁。</li></ul><p>通过这三个版本的迭代，我们看到了从<strong>低级原子操作</strong>构建锁的基本过程，以及<strong>RAII 模式</strong>在确保资源释放中的威力。自旋锁虽然简单，但在Rust并发中并不作为公开接口广泛使用，更多是用于底层实现。例如标准库 Mutex 在短暂自旋优化时内部也会自旋尝试锁，以减少进入内核的机会。一般来说，高层代码应尽量使用更高级的 Mutex 而非自旋锁，除非在非常性能敏感且确定临界区极短的场景下才考虑自旋锁。</p><h2 id="一次性通道（One-shot-Channel）">一次性通道（One-shot Channel）</h2><p><strong>一次性通道</strong>指的是只发送一次消息并被接收一次的通信通道。它可以理解为只能容纳单个消息的生产者-消费者队列，在某些场景下（例如线程初始化后将结果发送给主线程）非常有用。Rust 标准库提供的 <code>std::sync::mpsc</code> 通道是多次发送的通用通道，而一次性通道可以做特别的优化。书中通过多个版本构建了一个一次性通道，以展示<strong>锁与无锁编程</strong>、<strong>内存管理</strong>以及<strong>线程同步</strong>的技巧：</p><ul><li><strong>v0：基于互斥锁的简单通道</strong> – 首先实现一个通用版本，内部用 <code>Mutex</code> + <code>Condvar</code> 等构造一个能发送任意条消息的通道，然后限制只发送一次。这是最直接的实现，但完全依赖锁，性能较低。</li><li><strong>v1：引入 UnsafeCell 与 AtomicBool 去锁化</strong> – 利用内部可变性和原子操作，实现一个无锁的一次性通道。使用 <code>AtomicBool</code> 标志消息是否已被接收，<code>UnsafeCell</code> 存放实际消息数据，实现 send 时设置数据和标志位，recv 时读取数据。通过原子操作保证发送和接收的同步，不再使用锁，从而减少开销。</li><li><strong>v2：使用 <code>MaybeUninit&lt;T&gt;</code> 代替 <code>Option&lt;T&gt;</code></strong> – 优化内存布局。由于一次性通道中的消息在发送前不存在，发送后存在，而 Option 构造会在内存中额外存储一个枚举标志，占用空间且可能导致不必要的初始化检查。改用 <code>MaybeUninit</code> 后，只在内存中保留消息所需空间，避免了初始化与未初始化状态的双重判断，减少内存开销。</li><li><strong>v3：增加动态检查以提高安全性</strong> – 在发送和接收操作中增加运行时检查，以确保不会出现重复发送、重复接收等误用情况。例如，如果重复调用 send 就立即 panic，防止破坏内部状态。这些检查提升了组件的健壮性。</li><li><strong>v4：实现 <code>Drop</code> Trait 以自动清理</strong> – 为通道的发送端和接收端实现 <code>Drop</code>，在对象被销毁时自动清理未被接收的值或通知另一端。这样可以避免内存泄漏，并在接收端丢弃前通知发送端等，提高使用时的正确性。</li><li><strong>v5：拆分 Sender 和 Receiver 类型</strong> – 将通道的发送者和接收者角色分开成不同的类型，确保编译层面对各自操作的权限限制。例如 Sender 只能发送不能接收，Receiver 只能接收不能发送。这一版本还通过类型系统防范了一些误用（如接收端克隆等）。</li><li><strong>v6：用生命周期替代 Arc，消除引用计数开销</strong> – 之前版本为了让 Sender 和 Receiver 在不同线程中存在，可能使用了 <code>Arc</code> 来共享通道内部状态。然而在一次性通道中，发送和接收两者的作用域其实可以静态地确定（如在线程函数中先发送后接收）。通过引入 Rust 的生命周期参数，将通道限定在创建它的作用域内传递引用，而非通过 Arc，在编译期保证了内存安全的同时，免去了原子引用计数的运行时开销。</li><li><strong>v7：使用线程停放（park/unpark）机制，实现阻塞等待</strong> – 先前版本的接收操作可能需要不停查询标志（自旋等待消息就绪），v7 引入了 Rust 标准库的 <code>park()</code>/<code>unpark()</code> 机制：当接收端发现消息尚未准备好时，调用 <code>thread::park</code> 挂起当前线程；发送端在放入消息后调用接收线程的句柄的 <code>unpark</code> 来唤醒它。这种做法避免了忙等占用 CPU，转而让线程阻塞等待，提升效率。同时通过去掉先前用于轮询的如 <code>is_ready</code> 标志，使误用的可能性进一步降低。</li><li><strong>v8：使用 PhantomData 防止跨线程误用</strong> – 最终版本利用 PhantomData 标记保证类型安全。通过在 Sender/Receiver 中加入带有生命周期或非 Send/Sync 标记的 PhantomData，编译器可以禁止用户将 Sender/Receiver 在不安全的方式跨线程使用。例如，可以防止 Sender/Receiver 被不恰当地发送到其他线程导致未定义行为。PhantomData 不占用空间，但可以在类型系统中充当标记，确保一次性通道的用法受到静态约束，彻底封堵错误用法。</li></ul><p>经过上述多次迭代，一次性通道从最初的锁实现逐步演进为<strong>无锁</strong>且<strong>高效</strong>的实现，并且在类型系统层面保证了安全使用。这个过程展示了 Rust 并发编程从<strong>简单正确</strong>到<strong>性能优化</strong>再到<strong>类型安全</strong>的完整思路。在实际工程中，类似的思想被用于实现各种高性能通道和同步数据结构，如 Rust 标准库和 <code>crossbeam</code> 库中的通道实现等。</p><h2 id="Arc-原子引用计数智能指针">Arc 原子引用计数智能指针</h2><p><strong>Arc</strong>（Atomically Reference Counted）是 Rust 标准库提供的多线程引用计数智能指针类型，允许在多个线程间共享所有权。通过原子增减引用计数，Arc 能确保即使多个线程同时持有指针，底层数据也只会在最后一个指针被释放后销毁。书中通过实现一个简化版的 Arc 及其改进版本，解释了 Arc 的工作原理和演进：</p><ul><li><strong>v0：基础版本，单原子计数的多所有权</strong> – 使用一个原子计数器（如 <code>AtomicUsize</code>）记录引用数，每次克隆 Arc 增加计数，删除时减少计数，减到零时销毁数据。这个版本实现了跨线程的多所有权共享。然而，此时 Arc 依然缺乏两方面能力：<strong>内部可变性</strong>（无法获得可变引用去修改内部数据），以及<strong>防止循环引用</strong>（如果两个 Arc 相互引用会导致计数永不为零，内存泄漏）。</li><li><strong>v1：引入独占借用 <code>&amp;mut Arc&lt;T&gt;</code> 及内部锁，实现可变访问</strong> – 标准库的 Arc 并不支持在存在多个引用时直接获得内部数据的可变引用，但本书尝试了一个改进思路：当我们持有 Arc 的独占引用 <code>&amp;mut Arc&lt;T&gt;</code> 时（意味着当前线程拥有 Arc 对象的独占管理权，没有其他 Arc 克隆存在），可以安全地修改内部数据。为此，v1 在 Arc 内部增加了一把原子锁或标志，用于在独占修改内部数据时临时阻止其他线程的访问。从而提供一个安全的 <code>get_mut()</code> 方法：当检测到当前只有一个强引用且锁定成功时，返回内部数据的可变引用。这实现了<strong>条件下的内部可变性</strong>：在不破坏线程安全的前提下，允许独占 Arc 进行内部修改。</li><li><strong>v2：加入弱引用（Weak）以解决循环引用问题</strong> – 弱引用是 Arc 非常重要的补充。Weak 指针不计入强引用计数，因此不会阻止数据被回收。v2 引入 <code>Weak&lt;T&gt;</code> 类型，当需要引用可能形成环的对象时，用 Weak 替代 Arc 中的一部分引用关系。这样即使对象之间形成环，相互的弱引用不会使强计数增加到无法归零，一旦没有强引用，数据可以正确释放。Weak 指针需要通过 <code>upgrade()</code> 尝试提升为 Arc 使用，在数据已被释放时会得到 <code>None</code>，从而避免了悬垂引用。</li><li><strong>v3：区分强引用计数和弱引用计数，优化无循环场景性能</strong> – 在 v2 基础上，v3 将引用计数拆分为两个独立的计数：强引用计数和弱引用计数。强计数为 0 时表示数据可销毁，但实际销毁要等弱计数也为 0（表示没有悬挂的 Weak 指针）。通过分离计数，Arc 在没有 Weak 场景下也不需要去增减弱计数，减少了不必要的开销。只有在存在 Weak 的情况下才维护弱计数。这一优化与实际 Rust 标准库 Arc 的实现一致：标准库 Arc 在内部使用两个计数（一个原子usize记录强引用数，一个记录弱引用数），并据此管理内存回收。</li></ul><p>Arc 智能指针的实现展示了<strong>原子操作在内存管理中的应用</strong>。由于使用了原子引用计数，Arc 的克隆、释放可以由多线程安全地执行。此外，引入 Weak 指针解决循环引用、双计数优化性能等设计，都是实际工业级智能指针需要考虑的问题。Rust 标准库的 <code>Arc&lt;T&gt;</code> 正是采用类似机制，保证了线程安全又兼顾性能。在并发编程实践中，Arc 被广泛用来共享只读数据或通过内部加锁来共享可变数据（比如 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 组合），理解其实现对深入掌握 Rust 的内存管理和线程安全非常有帮助。</p><h2 id="互斥锁（Mutex）">互斥锁（Mutex）</h2><p>**Mutex（互斥锁）**是一种常用的线程同步原语，用于保证同一时刻只有一个线程可以访问某份数据。Rust 提供了 <code>std::sync::Mutex&lt;T&gt;</code> 实现安全且高效的互斥锁，在内部结合了自旋和操作系统锁机制。书中构建了一个简化的 Mutex 实现，通过多个版本逐步逼近实际库中的优化：</p><ul><li><strong>v1：基本可用的互斥锁</strong> – 首先利用 <code>atomic-wait</code> 等底层原语实现一个基本的 Mutex。内部使用一个原子标志表示锁状态，采用类似自旋锁的方式尝试获取锁，如果失败则调用底层 <code>wait()</code> 将线程阻塞，等待锁可用时被唤醒。同时运用 RAII 思想，实现一个锁守卫，在 <code>Drop</code> 中释放锁。这一版本已经具备 Mutex 的核心功能：能阻塞等待，避免忙等；用 RAII 确保解锁。</li><li><strong>v2：避免不必要的系统调用</strong> – 优化 Mutex 在无竞争情况下的性能。设想如果锁空闲，线程应尽量避免调用内核提供的 <code>wait</code> 等系统调用，因为进入内核态有开销。v2 改进在于：获取锁时先用原子操作快速检查和设置锁标志，如果成功则直接进入临界区，不需要任何系统调用；只有当锁已被占用且需要等待时，才调用 <code>wait</code> 进入睡眠。同样，释放锁时如果发现没有任何线程在等待（可通过一个等待计数或标志判断），则不调用 <code>wake_one</code>，避免无谓的系统调用开销。这个版本通过“先检查再睡眠”的策略，提高了低争用情况下的性能。</li><li><strong>v3：加入短暂自旋进一步减少系统调用</strong> – 在锁竞争发生时，立即阻塞线程进入内核可能不是最优选择。如果锁很快就会被释放，先忙等一小段时间可避免不必要的上下文切换。v3 引入了<strong>自旋等待</strong>的优化：当发现锁被占用时，不马上调用 <code>wait</code> 阻塞线程，而是让线程自旋循环尝试获取锁若干次（或等待若干纳秒）。如果在短暂自旋期间锁被释放获取成功，就无需进入内核；只有超过自旋时限仍未成功，才执行阻塞等待。这个优化利用了临界区很短这种常见情况，大幅减少了内核调度开销。在实际实现中，Rust 标准库和 <code>parking_lot</code> 库的 Mutex 都采用了类似的自旋-休眠结合策略，以平衡延迟和吞吐量。</li></ul><p>经过这些改进，Mutex 实现已经非常接近真实场景：在无竞争时开销极低（原子操作和用户态逻辑），在有轻微竞争时通过自旋避免陷入内核，在竞争激烈或锁长时间被持有时再进入内核等待，从而综合优化不同场景下的性能。值得一提的是，Rust 标准库的 Mutex 实际上在底层是调用操作系统的原生实现（例如 Windows 临界区，pthread mutex等），而社区提供的 <code>parking_lot</code> crate 则使用了自定义的高性能实现（正是类似书中描述的策略）。理解这些机制有助于选择和使用锁，以及调优并发性能。</p><h2 id="条件变量（Condvar）">条件变量（Condvar）</h2><p><strong>条件变量</strong>是一种配合互斥锁使用的同步原语，用于线程间等待和通知机制。一个典型的 Condvar 场景是：线程 A 获取锁并检查某个条件，如果条件不满足则在条件变量上等待（这会释放锁并挂起线程A）；另一个线程B稍后满足条件后获取同一把锁，改变条件并通知唤醒条件变量，线程A被唤醒后重新获取锁继续执行。Rust 提供了 <code>std::sync::Condvar</code> 来实现这一机制。书中通过两步实现了 Condvar 的核心原理并进行了优化：</p><ul><li><strong>v1：利用 atomic-wait 实现等待/唤醒</strong> – 条件变量需要将线程挂起和唤醒与某个共享条件相结合。v1 实现中，每个 Condvar 内部维护一个原子计数或标志，当线程调用 <code>wait()</code> 时，先解锁关联的 Mutex，然后调用 <code>atomic_wait</code> 在该原子上休眠等待。另一线程调用 <code>notify_one</code> 或 <code>notify_all</code> 时，对同一个原子值执行修改并调用 <code>wake_one</code> 或 <code>wake_all</code> 来唤醒等待线程。这样利用前述操作系统原语，就实现了条件变量的等待和唤醒机制。需要注意唤醒后线程会重新尝试获取最初的Mutex锁，以恢复对共享状态的保护（这一过程通常由Condvar实现封装好）。</li><li><strong>v2：增加等待者计数避免无效唤醒</strong> – 为了优化唤醒通知的性能，v2 在 Condvar 内部引入了一个原子计数 <code>num_waiters</code>，记录当前有多少线程在此 Condvar 上等待。这样，当调用 <code>notify_one/all</code> 时，可以先检查如果没有等待者就直接返回，避免进行系统调用唤醒。同理，在等待时也增加和减少这个计数。这个简单的计数避免了无谓的唤醒操作调用（例如没有线程在等待却调用了唤醒系统调用）。实际中，大部分条件变量实现都会维护类似的状态来提升效率。Rust 标准库的 <code>Condvar</code> 在具体实现上依赖于系统提供的条件变量（如 pthread_cond_t），但原理一致。</li></ul><p>Condvar 的实现难点在于要安全地结合互斥锁使用，以及防止经典的“丢失信号”问题（即信号发送与等待错过时机导致永久沉睡）。通过精心设计的顺序（例如在 Mutex 解锁和 wait 挂起之间避免竞争）以及必要的重试循环（被唤醒后通常需要再次检查条件），可以确保 Condvar 的正确性。这部分内容体现了操作系统原语与高级并发抽象之间的结合：Rust 的实现隐藏了许多细节，但理解它有助于我们正确使用 Condvar（例如明白必须在循环中等待条件、防止虚假唤醒等）。</p><h2 id="读写锁（RwLock）">读写锁（RwLock）</h2><p><strong>读写锁</strong>允许多个读者并行地读取数据，但在有写者持有锁时所有读者都被阻止。这样在读多写少的场景下能提高并发性能。Rust 提供了 <code>std::sync::RwLock&lt;T&gt;</code> 来实现读写锁。与 Mutex 类似，RwLock 在实现上也可以结合自旋和操作系统原语，并需考虑读者与写者的公平性。书中实现的简易 RwLock 经过了三步演进，着重解决写者可能的饥饿问题：</p><ul><li><strong>v1：核心读写锁语义</strong> – 初始版本使用 <code>atomic-wait</code> 等机制和 RAII，支持多个读者或单个写者的互斥。具体来说，可用一个原子计数来表示锁状态：例如计数为非负时表示当前有该数目的读者持锁，计数为 -1 表示有写者持锁。实现 <code>read_lock</code> 时尝试将计数递增（若当前不是写模式），<code>write_lock</code> 则尝试将计数从0变为 -1 来独占。如果操作失败则调用 wait 挂起等待。当持锁线程释放锁时，更新计数并根据情况调用 wake_one/all 唤醒等待的线程。这一版本实现了基本的 RwLock 功能。</li><li><strong>v2：增加独立的写者唤醒计数</strong> – 为了避免写线程在竞争中空转，v2 引入了一个单独的 <code>writer_wake_counter</code> 或标志。因为读锁可能同时唤醒多个等待的读者，而写者通常只需单独唤醒。当一个写线程在等待时，如果持续有读锁进来，它可能长时间得不到机会。通过维护一个专门针对写者的等待计数或标志，释放锁时如果发现有写者在等待，可以更有针对性地唤醒写线程。这避免了写线程无谓地循环等待所有读者离开锁。</li><li><strong>v3：使用奇偶数编码巧妙解决写者饥饿</strong> – 最终版本采取了一个巧妙的方案：利用原子计数的<strong>最低位或奇偶性</strong>来标记写者意图，从而平衡读/写公平性。一种常见做法是，将计数的某一位作为“有写者等待”的标记。当有写线程等待时，设置该标记使新的读锁请求被延迟（即不再允许新的读者获取锁），从而逐步清空现有读者并最终让写者上锁。一旦写者获取锁并释放后，再清除标记放行读者。这种通过奇偶位（或其他位）区分读写状态的编码方式，可以防止写者一直被源源不断的读者饿死，又不会过度牺牲读性能。实际工程中，不少读写锁实现（包括 Rust 标准库和 <code>parking_lot</code> 的 RwLock）都采用类似思路：既避免写者饥饿，又保持尽可能高的读并发。</li></ul><p>读写锁相对于互斥锁有更复杂的状态管理，需要处理多读者、单写者之间的切换，以及公平性策略。通过上述改进，我们既实现了基本功能，又确保在竞争激烈时系统不会偏科（比如始终偏向读者或写者）。在 Rust 标准库中，<code>RwLock</code> 使用系统的 pthread_rwlock 或相似机制实现，而更优化的方案如 <code>parking_lot::RwLock</code> 则采用自己的算法，和书中描述的策略不谋而合。对于开发者来说，了解这些实现细节能够帮助理解 <code>RwLock</code> 的特性（例如为什么有时写锁可能拿不到是因为读锁频繁进来等），从而做出更好的并发设计决策。</p><h2 id="总结">总结</h2><p>通过对《Rust Atomics and Locks》全书内容的梳理，我们系统了解了 Rust 并发编程从<strong>底层原理</strong>到<strong>高级抽象</strong>的一系列知识点：</p><ul><li>原子操作及其内存序保证构成了无锁并发的基础，不同架构对其支持有所区别，理解硬件内存模型有助于写出正确高效的原子操作代码。</li><li>内存模型中的 happens-before 等概念和五种内存顺序提供了分析并发行为的工具，Rust 的类型系统和内存屏障一起确保了跨线程操作的可见性和有序性。</li><li>UnsafeCell 和 Send/Sync 等机制是 Rust 提供的编译期保障，既允许必要的“不安全”修改又保证线程安全边界分明，使我们能放心地构建并使用并发原语。</li><li>操作系统提供的 futex 等原语连接了用户态原子操作和内核调度，Rust 并发库巧妙地加以利用，实现既省CPU又高吞吐的锁和阻塞结构。</li><li>通过几个典型并发原语（自旋锁、通道、Arc、Mutex、Condvar、RwLock）的实现迭代，我们看到如何将上述原理应用于实际：从简单正确的初始版本，不断优化以提高性能和安全性，最终达到与工业级实现类似的效果。这些案例也强调了概念之间的联系——如自旋锁和 Mutex 体现了忙等与阻塞两种等待策略，Arc 的内部可变性依赖 UnsafeCell 而其计数安全依赖原子操作，条件变量依赖 Mutex 配合以及操作系统原语等等。</li></ul><p>Rust 并发的设计追求“<strong>无数据竞争</strong>”的同时，通过类型系统和底层优化取得了很好平衡。《Rust Atomics and Locks》深入浅出地展示了这一领域的方方面面。本笔记希望帮助读者快速回顾书中内容，在需要时可将各章节要点作为知识索引参考。相信将来面对具体并发编程挑战时，这些基础理论和实现经验将成为宝贵的指导，帮助我们写出健壮高效安全的 Rust 并发代码。</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">本篇是 Rust 并发编程系列文章的最后一篇，笔者将尝试对书中涉及到的关键知识点进行统一梳理，主要是为了便于查阅，所以不会再过多深入细节，感兴趣的读者可以跳转到对应篇章进行详细查阅。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨手写一个 RwLock</title>
    <link href="https://hedon.top/2025/06/11/rust-action-rwlock/"/>
    <id>https://hedon.top/2025/06/11/rust-action-rwlock/</id>
    <published>2025-06-11T00:56:08.000Z</published>
    <updated>2025-06-17T11:12:23.470Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><a href="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust 原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust 实战丨手写一个 SpinLock</a></li><li><a href="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust 实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust 实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust 原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust 实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust 实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust 实战丨手写一个 RwLock</a> 👈 本篇</li></ul><hr><p>本篇我们继续参考 <a href="https://marabos.nl/atomics/building-locks.html#reader-writer-lock">Rust Atomics and Locks</a> 一书来手写一个读写锁：<em><em>RwLock</em></em>。这也是这本书中的最后一个实战案例了，很幸运我们能坚持到现在，为自己鼓掌 👏🏻 ！</p><p>在本章开始之前，我们假设你已经：</p><ol><li>熟悉并理解 Rust 的各种原子操作。</li><li>阅读过 <a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a> 和 <a href="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust 原理丨从汇编角度看原子操作</a>，并理解内存顺序和内存屏障的原理和使用方法。</li><li>理解 Rust <code>UnsafeCell&lt;T&gt;</code> 提供的内部可变性允许我们在持有共享引用 <code>&amp;</code> 的时候可以对数据进行修改。</li><li>阅读过 <a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust 原理丨操作系统并发原语</a> 并了解 <a href="https://crates.io/crates/atomic-wait">atomic-wait</a> crate 中 <code>wait/wake_one/wake_all</code> 的适用场景和使用方法。</li></ol><h2 id="读完本篇你能学到什么">读完本篇你能学到什么</h2><ol><li><p>掌握读写锁的核心语义和基本原理</p><ul><li><p>理解读锁可共享、写锁需独占的设计哲学</p></li><li><p>学会使用原子操作和 Guard 模式实现线程安全</p></li><li><p>掌握 <code>UnsafeCell</code> 实现内部可变性的技巧</p></li></ul></li><li><p>解决写线程无用循环问题</p><ul><li><p>识别并发程序中的性能瓶颈</p></li><li><p>学会通过独立原子变量避免竞争</p></li><li><p>理解 <code>atomic-wait</code> 的高效使用方式</p></li></ul></li><li><p>巧妙解决写饥饿难题</p><ul><li><p>掌握奇偶数编码表达复杂状态的艺术</p></li><li><p>理解并发系统中性能与公平性的权衡</p></li><li><p>学会设计状态机解决复杂同步问题</p></li></ul></li></ol><h2 id="v1：基础实现">v1：基础实现</h2><p>按照惯例，我们先来思考数据结构该如何定义。所谓读写锁，即读锁与读锁之间是可以共存，而读锁与写锁、写锁与写锁之间是互斥的。</p><ol><li>我们需要一个变量 <code>state</code> 来表示当前是否有读线程、有多少读线程、是否有写线程，这里可以用 <code>state</code> 的值来表示有多少读线程，当其为最大值时，表示有写线程。因为 <a href="https://crates.io/crates/atomic-wait">atomic-wait</a> 仅支持 AtomicU32，所以这里我们的数据类型也定义为 AtomicU32.</li><li>抢到写锁的时候，是可以对数据 <code>value</code> 进行修改的，但因我们只持有 <code>&amp;RwLock</code> 共享引用，为了修改数据，我们依旧需要依赖 <code>UnsafeCell</code> 提供内部可变性。</li><li>我们需要 2 个守卫类型，分别作为读守卫和写守卫，它们都持有 RwLock 的引用。<ul><li>读守卫只能获取共享引用，所以我们为其实现 <code>Deref</code> trait。</li><li>写守卫可以获取独占引用，所以我们为其实现 <code>Deref</code> 和 <code>DerefMut</code> trait。</li></ul></li><li>另外，因为读锁是共享，写锁是独占，所以我们在为 <code>RwLock&lt;T&gt;</code> 实现 <code>Sync</code> trait 的时候，要求 <code>T</code> 必须满足 <code>Sync+Send</code>。</li></ol><p>综上，我们可以定出以下的数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RwLock</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// The number of read locks, u32::MAX if write locked.</span></span><br><span class="line">    state: AtomicU32,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ReadGuard</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    rwlock: &amp;<span class="symbol">&#x27;a</span> RwLock&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WriteGuard</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    rwlock: &amp;<span class="symbol">&#x27;a</span> RwLock&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">RwLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Sync</span> + <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">WriteGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*<span class="keyword">self</span>.rwlock.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> <span class="title class_">WriteGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.rwlock.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">ReadGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*<span class="keyword">self</span>.rwlock.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            state: AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">            value: UnsafeCell::<span class="title function_ invoke__">new</span>(value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，现在我们需要来实现最重要的功能：上锁和解锁。</p><p>我们先来看上读锁和解锁：当 <code>state != u32::MAX</code> 的时候，我们就可以尝试对 <code>state</code> 进行加 1 抢占读锁，在销毁 <code>ReadGuard</code> 的时候，我们只需要对 <code>state</code> 进行减 1，当最后一个读锁释放的时候，还需要唤醒一个潜在的阻塞中的写线程。且这里，加 1 和减 1 需要用一对 Acquire 和 Release 建立 happens-before 关系。</p><p>代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">read</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> ReadGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s &lt; <span class="type">u32</span>::MAX &#123;</span><br><span class="line">                <span class="built_in">assert!</span>(s != <span class="type">u32</span>::MAX - <span class="number">1</span>, <span class="string">&quot;too many readers&quot;</span>);</span><br><span class="line">              <span class="comment">// 尝试上读锁</span></span><br><span class="line">                <span class="keyword">match</span> <span class="keyword">self</span>.state.<span class="title function_ invoke__">compare_exchange_weak</span>(s, s + <span class="number">1</span>, Acquire, Relaxed) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="keyword">return</span> ReadGuard &#123; rwlock: <span class="keyword">self</span> &#125;,</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(e) =&gt; s = e,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> s == <span class="type">u32</span>::MAX &#123;<span class="comment">// 如果已经上了写锁，就陷入等待</span></span><br><span class="line">                <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.state, <span class="type">u32</span>::MAX);</span><br><span class="line">                s = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">ReadGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.rwlock.state.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Release) == <span class="number">1</span> &#123; <span class="comment">// 最后一个读锁释放</span></span><br><span class="line">            <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.rwlock.state);<span class="comment">// 唤醒一个潜在的写线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看上写锁和解锁：我们只需要尝试将 <code>state</code> 置为 <code>u32::MAX</code>，如果成功了，则说明上写锁成功，否则需要陷入等待。在解锁的时候，只需要将 <code>state</code> 置为 <code>0</code>，并唤醒所有潜在的阻塞的读线程和写线程。同样，这里也需要一对 Acquire 和 Release 建立 happens-before 关系。</p><p>代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> WriteGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">      <span class="comment">// 尝试置为 u32::MAX</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Err</span>(s) = <span class="keyword">self</span>.state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="type">u32</span>::MAX, Acquire, Relaxed) &#123;</span><br><span class="line">            <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.state, s); <span class="comment">// 陷入阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">        WriteGuard &#123; rwlock: <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">WriteGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rwlock.state.<span class="title function_ invoke__">store</span>(<span class="number">0</span>, Release);</span><br><span class="line">        <span class="title function_ invoke__">wake_all</span>(&amp;<span class="keyword">self</span>.rwlock.state); <span class="comment">// 唤醒所有阻塞的写线程和读线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们一个基本可用的 <code>RwLock</code> 就实现完毕了，你可以参考下图进行辅助理解：</p><pre class="mermaid">sequenceDiagram    participant A as 线程A (读者)    participant B as 线程B (读者)    participant C as 线程C (写者)    participant State as RwLock State    participant Wait as Wait/Wake 机制    Note over State: state = 0 (未锁定)    A->>State: read() - compare_exchange_weak(0, 1)    Note over State: state: 0 → 1    State-->>A: 成功，返回 ReadGuard    B->>State: read() - compare_exchange_weak(1, 2)    Note over State: state: 1 → 2 (两个读锁)    State-->>B: 成功，返回 ReadGuard    Note over A, B: 💡 读锁可以并发持有    C->>State: write() - compare_exchange(0, u32::MAX)    State-->>C: 失败 (state=2, 不等于0)    C->>Wait: wait(&state, 2)    Note over C: 🔒 写线程进入等待状态    Note over A: 线程A完成读操作    A->>State: drop(ReadGuard) - fetch_sub(1)    Note over State: state: 2 → 1    Note over A: 不是最后一个读锁，不唤醒    Note over B: 线程B完成读操作    B->>State: drop(ReadGuard) - fetch_sub(1)    Note over State: state: 1 → 0    Note over B: ✨ 最后一个读锁释放！    B->>Wait: wake_one(&state)    Note over C: 🎯 写线程被唤醒    C->>State: write() - compare_exchange(0, u32::MAX)    Note over State: state: 0 → u32::MAX    State-->>C: 成功，返回 WriteGuard    Note over C: 线程C执行写操作...    C->>State: drop(WriteGuard) - store(0)    Note over State: state: u32::MAX → 0    C->>Wait: wake_all(&state)    Note over Wait: 📢 唤醒所有等待的线程</pre><p>我们来写下单元测试验证功能是否正确：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> std::&#123;</span><br><span class="line">        thread::&#123;<span class="keyword">self</span>, sleep&#125;,</span><br><span class="line">        time::Duration,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rwl</span> = RwLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r1</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(r1.<span class="title function_ invoke__">len</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r2</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(r2.<span class="title function_ invoke__">len</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">drop</span>(r1);</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(r2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w</span> = rwl.<span class="title function_ invoke__">write</span>();</span><br><span class="line">        w.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r3</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(r3.<span class="title function_ invoke__">len</span>(), <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rwl</span> = RwLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line"></span><br><span class="line">        thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w</span> = rwl.<span class="title function_ invoke__">write</span>();</span><br><span class="line">                w.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">                w.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">                <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">r1</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *r1);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">r2</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *r2);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果是通过的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">running 2 tests</span><br><span class="line">test rwlock::tests::one_thread_should_work ... ok</span><br><span class="line">test rwlock::tests::cross_thread_should_work ... ok</span><br></pre></td></tr></table></figure><h2 id="v2：避免写线程无用循环">v2：避免写线程无用循环</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> WriteGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Err</span>(s) = <span class="keyword">self</span>.state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="type">u32</span>::MAX, Acquire, Relaxed) &#123;</span><br><span class="line">            <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.state, s);</span><br><span class="line">        &#125;</span><br><span class="line">        WriteGuard &#123; rwlock: <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察一下我们上个版本的 <code>write()</code> 实现，这里可能会出现一种情况：当上读锁非常频繁的时候，<code>state</code> 的值是一直在变化的，这个时候，<code>wait(&amp;self.state, s)</code> 就有可能因为 <code>state</code> 的值发生了变化，不等于 <code>s</code> 了，就不会陷入等待，而是继续循环尝试将 <code>state</code> 从 <code>0</code> 置为 <code>u32::MAX</code>。这时如果上读锁非常频繁的话，那这里会一直尝试获取，且是无意义的尝试。</p><pre class="mermaid">sequenceDiagram    participant W as 写线程    participant R1 as 读线程1    participant R2 as 读线程2    participant State as RwLock State    participant Wait as Wait 机制    Note over State: state = 1 (有一个读锁)    W->>State: write() - compare_exchange(0, u32::MAX)    State-->>W: 失败，返回 s=1    Note over W: 准备调用 wait(&state, 1)    R1->>State: drop(ReadGuard) - fetch_sub(1)    Note over State: state: 1 → 0 ⚡️ (在 wait 调用前状态就变了！)    W->>Wait: wait(&state, 1)    Note over Wait: ❌ 当前 state=0，不等于期望值1，立即返回！    Wait-->>W: 立即返回，没有真正等待    Note over R2: 💨 新读线程抢在 compare_exchange 前获取锁！    R2->>State: read() - compare_exchange_weak(0, 1)    Note over State: state: 0 → 1    Note over W: 🔄 进入下一轮循环    W->>State: compare_exchange(0, u32::MAX)    State-->>W: 失败，返回 s=1 (锁又被抢了！)    Note over W: 又准备调用 wait(&state, 1)    R2->>State: drop(ReadGuard) - fetch_sub(1)    Note over State: state: 1 → 0 ⚡️ (又在 wait 前变化了！)    W->>Wait: wait(&state, 1)    Wait-->>W: 又是立即返回！    Note over W: 🔄 无用循环开始...    Note over W: ⚠️ 写线程永远无法真正进入等待状态！    Note over W: 💀 CPU 被白白消耗在无效的重试上    Note over State: 🎯 问题核心：wait 调用前 state 总是被读锁改变    Note over State: 💡 解决：独立的 writer_wake_counter 避免这种竞争</pre><p>这里问题的根源在于 <strong><code>read()</code> 和 <code>write()</code> 监听的都是同一个原子变量 <code>state</code></strong>。</p><p>解决这个问题的方案之一，就是可以另外加一个原子变量，专门给 <code>write()</code>，从而与 <code>read()</code> 区分开来，避免互相影响，从而造成 <code>write()</code> 时产生无用循环。</p><p>我们在 <code>RwLock</code> 中新增一个属性：<code>writer_wake_counter</code>，用于唤醒抢占写锁的线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RwLock</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// The number of read locks, u32::MAX if write locked.</span></span><br><span class="line">    state: AtomicU32,</span><br><span class="line">    <span class="comment">/// Incremented to wake up waiters.</span></span><br><span class="line">    writer_wake_counter: AtomicU32,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            state: AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">            writer_wake_counter: AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">            value: UnsafeCell::<span class="title function_ invoke__">new</span>(value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候：</p><ol><li>我们在 <code>write()</code> 时没抢到锁，就不去 <code>wait(&amp;state)</code> 了，而是 <code>wait(&amp;writer_wake_counter)</code>。</li><li>最后一个 <code>ReadGuard</code> 在 drop 的时候，我们修改 <code>writer_wake_counter</code> 的值，并唤醒一个潜在的阻塞的写线程。</li><li><code>WriteGuard</code> 的时候，不仅要唤醒所有阻塞的读线程，还要唤醒一个潜在的阻塞的写线程。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> WriteGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span></span><br><span class="line">            .state</span><br><span class="line">            .<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="type">u32</span>::MAX, Acquire, Relaxed) <span class="comment">// 尝试抢锁</span></span><br><span class="line">            .<span class="title function_ invoke__">is_err</span>()</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 失败的话取出 writer_wake_counter，供待会 `wait` 使用。</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">w</span> = <span class="keyword">self</span>.writer_wake_counter.<span class="title function_ invoke__">load</span>(Acquire);</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed) != <span class="number">0</span> &#123; <span class="comment">// 再次检查 state，如果为 0，就不阻塞了，再次尝试抢锁</span></span><br><span class="line">                <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.writer_wake_counter, w); <span class="comment">// 否则陷入等待</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        WriteGuard &#123; rwlock: <span class="keyword">self</span> &#125; <span class="comment">// 抢锁成功，返回守卫对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">ReadGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.rwlock.state.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.rwlock.writer_wake_counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Release);</span><br><span class="line">            <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.rwlock.writer_wake_counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">WriteGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rwlock.state.<span class="title function_ invoke__">store</span>(<span class="number">0</span>, Release);</span><br><span class="line">        <span class="keyword">self</span>.rwlock.writer_wake_counter.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Release);</span><br><span class="line">        <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.rwlock.writer_wake_counter);  <span class="comment">// 唤醒一个写线程</span></span><br><span class="line">        <span class="title function_ invoke__">wake_all</span>(&amp;<span class="keyword">self</span>.rwlock.state);<span class="comment">// 唤醒所有的读线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个简单的优化，我们就可以避免写线程因为 <code>state</code> 的频繁变化而产生无用循环了。再次运行之前的测试用例，顺利通过的话就没有问题啦！</p><h2 id="v3：避免写饥饿">v3：避免写饥饿</h2><p>这个版本我们来做最后一个可尝试优化：<strong>避免写饥饿</strong>。</p><p>在之前的实现中，只要没上锁，或者上的是读锁，那么就可以一直不断地上读锁。而只有当没有任何读线程和写线程存在的时候，才可以上写锁。这就非常容易造成写饥饿了，因为那些后来的读线程依旧可以成功上读锁，而写线程抢到锁的条件太苛刻了。</p><p>为了解决这个问题，我们可以修改一下 <code>state</code> 的定义：</p><ol><li>当 <code>state</code> 为 <code>0</code> 的时候，说明没上锁。</li><li>当 <code>state</code> 为 <code>u32::MAX</code> 的时候，说明上了写锁。</li><li>当 <code>state</code> 为非 0 的偶数的时候，说明上了读锁，<strong>且没有阻塞中的写锁，这个时候可以继续上读锁</strong>。</li><li>当 <code>state</code> 为其他奇数的时候，说明这个时候有阻塞中的写锁，<strong>后面来的读锁也需要阻塞</strong>。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RwLock</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// 读线程的数量 *2，当有阻塞中的写线程的时候 +1</span></span><br><span class="line">  <span class="comment">/// 如果 state=u32::MAX，说上了写锁。</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 这意味着，当 state 是偶数的时候，可以继续上读锁，</span></span><br><span class="line">  <span class="comment">/// 但是，如果 state 是奇数的话，上读锁会被阻塞。</span></span><br><span class="line">    state: AtomicU32,</span><br><span class="line">    <span class="comment">/// Incremented to wake up waiters.</span></span><br><span class="line">    writer_wake_counter: AtomicU32,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的调整，我们就可以相对公平地去避免写饥饿的问题了。为此，我们需要调整读写锁的上锁和解锁的逻辑。</p><p><code>read()</code>:</p><ol><li>当 <code>state</code> 为偶数的时候，我们可以尝试对其进行 <strong>+2</strong> 继续抢占读锁；</li><li>当 <code>state</code> 为奇数的时候，我们需要调用 <code>wait</code> 陷入等待。</li></ol><p><code>ReadGuard.drop()</code>:</p><ol><li>解锁的时候对 <code>state</code> 进行 <strong>-2</strong>；</li><li>如果之前的值是 <code>3</code> 的话，说明这是最后一个释放的读锁，且存在被阻塞的写线程，这个时候需要调用 <code>wake_one</code> 进行唤醒。</li></ol><p><code>write()</code>:</p><ol><li>如果 <code>state</code> 为 <code>0</code>，则说明此时没有上锁：可以尝试将其置为 <code>u32::MAX</code> 抢占锁：<ol><li>如果成功，直接返回。</li><li>如果抢锁失败，则重新读取 <code>state</code> 值进行重新判断。</li></ol></li><li>如果 <code>state</code> 为非 0 偶数，则说明此时已经上了读锁了，我们需要将 <code>state</code> <strong>+1</strong> 设置为奇数，表示有写线程被阻塞着，阻止后面新来的读线程抢占读锁。</li><li>如果 <code>state</code> 为非 0 奇数：<ol><li>如果 <code>state</code> 等于 1，那说明既没有上写锁，也没有上读锁，但是有一个阻塞中的写线程，那有可能就是当前线程自己了！这个时候，我们依旧是可以尝试将其置为 <code>u32::MAX</code> 抢占锁，所以 <code>state</code> 为 <code>1</code> 的情况，可以跟 <code>state</code> 为 <code>0</code> 的情况进行合并处理。</li><li>如果 <code>state</code> 大于 1，则说明已经上了读锁，这个时候，需要陷入等待，等前面的读锁都释放了，才能进入下一轮循环，重新尝试抢占写锁。</li></ol></li></ol><p><code>WriteGuard.drop()</code>:</p><ol><li>将 <code>state</code> 置为 <code>0</code>；</li><li>唤醒潜在的所有阻塞的读线程和一个写线程。</li></ol><p>我画了个流程图，供你辅助理解：</p><pre class="mermaid">sequenceDiagram    participant R1 as 读线程1 (已持有)    participant R2 as 读线程2 (已持有)    participant W as 写线程 (等待)    participant R3 as 读线程3 (新来)    participant State as RwLock State    participant Wait as Wait/Wake 机制    Note over State: state = 4 (两个读锁，4 = 2×2)    Note over R1, R2: 💡 两个读线程正在工作...    W->>State: write() - 尝试获取写锁    Note over W: 发现有读锁，无法获取    W->>State: compare_exchange(4, 5) - 设置写等待标志    Note over State: state: 4 → 5 (奇数！有等待的写线程)    W->>Wait: wait(&writer_wake_counter, w)    Note over W: 🔒 写线程进入等待，但已设置奇数标志    Note over R3: 💨 新的读线程想要获取锁    R3->>State: read() - 检查 state % 2    Note over R3: state=5 是奇数，发现有等待的写线程！    R3->>Wait: wait(&state, 5)    Note over R3: 🚫 读线程被阻塞，无法抢占！    Note over R1: 读线程1完成工作    R1->>State: drop(ReadGuard) - fetch_sub(2)    Note over State: state: 5 → 3 (仍然是奇数)    Note over R1: 不是最后一个读锁，不唤醒    Note over R2: 读线程2完成工作    R2->>State: drop(ReadGuard) - fetch_sub(2)    Note over State: state: 3 → 1    Note over R2: ✨ 检测到 state=3，是最后一个读锁！    R2->>Wait: wake_one(&writer_wake_counter)    Note over W: 🎯 写线程被唤醒    W->>State: write() - compare_exchange(1, u32::MAX)    Note over State: state: 1 → u32::MAX    State-->>W: ✅ 成功获取写锁！    Note over W: 写线程执行关键操作...    Note over R3: 读线程3仍在等待，公平性得到保证！    W->>State: drop(WriteGuard) - store(0)    Note over State: state: u32::MAX → 0    W->>Wait: wake_all(&state) - 唤醒所有等待的读线程    Note over R3: 🎯 读线程3被唤醒，现在可以获取锁了    R3->>State: read() - compare_exchange_weak(0, 2)    Note over State: state: 0 → 2 (偶数，正常读锁)</pre><p>综上分析，我们最新的代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">read</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> ReadGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">          <span class="comment">// 如果是 0，则说明现在没有上锁，</span></span><br><span class="line">          <span class="comment">// 如果是偶数，则说明现在上的是读锁，写没有阻塞中的写线程，</span></span><br><span class="line">          <span class="comment">// 这两种情况，都可以尝试将 state+2 进行抢占读锁。</span></span><br><span class="line">            <span class="keyword">if</span> s % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">assert!</span>(s != <span class="type">u32</span>::MAX - <span class="number">2</span>, <span class="string">&quot;too many readers&quot;</span>);</span><br><span class="line">                <span class="keyword">match</span> <span class="keyword">self</span>.state.<span class="title function_ invoke__">compare_exchange_weak</span>(s, s + <span class="number">2</span>, Acquire, Relaxed) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="keyword">return</span> ReadGuard &#123; rwlock: <span class="keyword">self</span> &#125;,<span class="comment">// 抢占成功，直接返回。</span></span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(e) =&gt; s = e,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果 state 为奇数，说明有阻塞中的写线程。</span></span><br><span class="line">            <span class="keyword">if</span> s % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">              <span class="comment">// 这时候，后面来的读线程都需要阻塞，等待写锁的获取和释放。</span></span><br><span class="line">                <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.state, s);</span><br><span class="line">                s = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> WriteGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">          <span class="comment">// 0: 没有上锁，可以尝试抢锁。</span></span><br><span class="line">          <span class="comment">// 1: 没有上锁，但有阻塞的写线程，可能就是自己，依旧可以尝试抢锁。</span></span><br><span class="line">            <span class="keyword">if</span> s &lt;= <span class="number">1</span> &#123;</span><br><span class="line">              <span class="comment">// 尝试将 state 置为 u32::MAX，成功则直接返回</span></span><br><span class="line">                <span class="keyword">match</span> <span class="keyword">self</span>.state.<span class="title function_ invoke__">compare_exchange</span>(s, <span class="type">u32</span>::MAX, Acquire, Relaxed) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="keyword">return</span> WriteGuard &#123; rwlock: <span class="keyword">self</span> &#125;,</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">                        s = e;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 非 0 的偶数，说明现在上的是读锁，且之前没有阻塞的写线程。</span></span><br><span class="line">            <span class="keyword">if</span> s % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">              <span class="comment">// 将 state+1 置为奇数，表示已经有阻塞的写线程了，阻止后来的读线程抢占读锁。</span></span><br><span class="line">                <span class="keyword">match</span> <span class="keyword">self</span>.state.<span class="title function_ invoke__">compare_exchange</span>(s, s + <span class="number">1</span>, Relaxed, Relaxed) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(_) =&gt; &#123;&#125;</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">                        s = e;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">w</span> = <span class="keyword">self</span>.writer_wake_counter.<span class="title function_ invoke__">load</span>(Acquire);</span><br><span class="line">            s = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">            <span class="keyword">if</span> s &gt;= <span class="number">2</span> &#123;</span><br><span class="line">              <span class="comment">// 如果已经上了读锁，则陷入等待，等待前面所有读锁的释放。</span></span><br><span class="line">                <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.writer_wake_counter, w);</span><br><span class="line">                s = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放读锁</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">ReadGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="comment">// 对 state -=2，如果之前的值是 3，则说明当前是最后一个释放的读锁，且存在阻塞中的写线程。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.rwlock.state.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">2</span>, Release) == <span class="number">3</span> &#123;</span><br><span class="line">          <span class="comment">// 唤醒一个阻塞中的写线程。</span></span><br><span class="line">            <span class="keyword">self</span>.rwlock.writer_wake_counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Release);</span><br><span class="line">            <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.rwlock.writer_wake_counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放写锁</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">WriteGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="comment">// 将 state 重置为 0。</span></span><br><span class="line">        <span class="keyword">self</span>.rwlock.state.<span class="title function_ invoke__">store</span>(<span class="number">0</span>, Release);</span><br><span class="line">      <span class="comment">// 唤醒一个潜在的阻塞的写线程。</span></span><br><span class="line">        <span class="keyword">self</span>.rwlock.writer_wake_counter.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Release);</span><br><span class="line">        <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.rwlock.writer_wake_counter);</span><br><span class="line">      <span class="comment">// 唤醒所有潜在的阻塞的读线程。</span></span><br><span class="line">        <span class="title function_ invoke__">wake_all</span>(&amp;<span class="keyword">self</span>.rwlock.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们重新运行之前的测试用例，可以发现的顺利通过的！不过我们还需要加一个测试用例，来测试写饥饿是否被解决了！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">writer_starvation_should_resolved</span>() &#123;</span><br><span class="line">   <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;<span class="comment">// 跑 100 次，避免偶然</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> <span class="variable">rwl</span> = RwLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">      thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">          s.<span class="title function_ invoke__">spawn</span>(|| &#123;<span class="comment">// 线程 1</span></span><br><span class="line">              <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w</span> = rwl.<span class="title function_ invoke__">write</span>();</span><br><span class="line">              w.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">              w.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          s.<span class="title function_ invoke__">spawn</span>(|| &#123; <span class="comment">// 线程 2</span></span><br><span class="line">              <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line">              <span class="keyword">let</span> <span class="variable">r1</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">              <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *r1);</span><br><span class="line">              <span class="keyword">let</span> <span class="variable">r2</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">              <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *r2);</span><br><span class="line">              <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">50</span>)); <span class="comment">// stay locked to block after writers and readers</span></span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          s.<span class="title function_ invoke__">spawn</span>(|| &#123; <span class="comment">// 线程 3</span></span><br><span class="line">              <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">20</span>));</span><br><span class="line">              <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w2</span> = rwl.<span class="title function_ invoke__">write</span>();</span><br><span class="line">              w2.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          s.<span class="title function_ invoke__">spawn</span>(|| &#123; <span class="comment">// 线程 4</span></span><br><span class="line">              <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">30</span>));</span><br><span class="line">              <span class="keyword">let</span> <span class="variable">r</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">              <span class="built_in">assert_eq!</span>(r.<span class="title function_ invoke__">len</span>(), <span class="number">3</span>); <span class="comment">// must get lock after w2</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个测试用例中，线程 2/3/4 在开始之前分别会睡眠 10/20/30ms，所以抢占锁的时间顺序是 <code>w-&gt;r1-&gt;r2-&gt;w2-&gt;r</code>。并且线程 2 在退出之前，还睡眠了 50ms，所以线程 3 和线程 4 在抢占锁的时候，<code>r1/r2</code> 都还没释放。</p><p>如果我们成功解决了写饥饿问题的话，那这个时候，线程 3 应该会将 <code>state</code> 置为奇数，防止线程 4 抢占读锁。所以当线程 4 抢到读锁的时候，线程 3 一定已经释放写锁了，即 <code>vec</code> 里面一定有 3 条数据！通过运行 <code>writer_starvation_should_resolved</code> 测试用例，很幸运，我们已经成功解决了写饥饿的问题了！</p><p>完整代码可以参考：<a href="https://github.com/hedon-rust-road/conutils/blob/main/src/rwlock.rs">conutils/rwlock</a>。</p><h2 id="总结">总结</h2><p>本篇文章通过三个渐进式版本完整展示了如何从零开始手写一个功能完备的读写锁（RwLock）。</p><p>我们的实现历程体现了系统编程中常见的优化思路：</p><ul><li><p><strong>v1 基础实现</strong>：实现了核心的读写锁语义，确保功能正确性</p></li><li><p><strong>v2 性能优化</strong>：通过独立的 <code>writer_wake_counter</code> 避免写线程无用循环，提升了性能</p></li><li><p><strong>v3 公平性保证</strong>：巧妙使用奇偶数编码解决写饥饿问题，在性能与公平性间找到平衡</p></li></ul><p>通过这次实战，我们不仅掌握了 RwLock 的实现细节，更重要的是学会了并发编程的系统性思维方式。这些经验将在后续的系统编程实践中发挥重要作用。</p><p>这也是我们学习 <a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 这本优秀书籍的收官之战，笔者由衷地佩服 <a href="https://github.com/m-ou-se">Mara Bos</a> 能在短短 200 多页的篇幅将 Rust 的并发编程阐述得如何透彻、清晰且足够深入细节，笔者在整理本系列笔记的过程中，也真的是获益颇丰，希望也能给你带来一些收获，那我们下篇文章见！</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">通过三个渐进式版本深入理解 RwLock 的实现原理，从基础功能到性能优化再到公平性保证，掌握原子操作、内存顺序、条件变量等并发编程核心技术，并学会解决写饥饿等实际问题。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 实战" scheme="https://hedon.top/categories/rust/rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨手写一个 Condvar</title>
    <link href="https://hedon.top/2025/06/09/rust-action-condvar/"/>
    <id>https://hedon.top/2025/06/09/rust-action-condvar/</id>
    <published>2025-06-09T00:51:46.000Z</published>
    <updated>2025-06-17T11:12:23.465Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><a href="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust 原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust 实战丨手写一个 SpinLock</a></li><li><a href="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust 实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust 实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust 原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust 实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust 实战丨手写一个 Condvar</a> 👈 本篇</li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust 实战丨手写一个 RwLock</a></li></ul><hr><p>本篇我们继续参考 <a href="https://marabos.nl/atomics/building-locks.html#condition-variable">Rust Atomics and Locks</a> 一书来手写一个条件变量：<em>Condition Variable</em>，简称 <code>Condvar</code>。</p><p>在本章开始之前，我们假设你已经：</p><ol><li>熟悉并理解 Rust 的各种原子操作。</li><li>阅读过 <a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a> 和 <a href="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust 原理丨从汇编角度看原子操作</a>，并理解内存顺序和内存屏障的原理和使用方法。</li><li>理解 Rust <code>UnsafeCell&lt;T&gt;</code> 提供的内部可变性允许我们在持有共享引用 <code>&amp;</code> 的时候可以对数据进行修改。</li><li>阅读过 <a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust 原理丨操作系统并发原语</a> 并了解 <a href="https://crates.io/crates/atomic-wait">atomic-wait</a> crate 中 <code>wait/wake_one/wake_all</code> 的适用场景和使用方法。</li></ol><p>在 Rust 中，<code>Condvar</code> 是一个配合 <code>Mutex</code> 使用的线程同步原语，主要作用是让线程在满足某些“条件”之前主动<strong>睡眠</strong>（阻塞），待条件达成时再被唤醒。</p><p>典型的就是生产者和消费者模式，我们先来看一下标准库的 <code>Condvar</code> 如何使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> std::&#123;</span><br><span class="line">        collections::VecDeque,</span><br><span class="line">        sync::&#123;Condvar, Mutex&#125;,</span><br><span class="line">        thread,</span><br><span class="line">        time::Duration,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">condvar_usage</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">queue</span> = Mutex::<span class="title function_ invoke__">new</span>(VecDeque::<span class="title function_ invoke__">new</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">not_empty</span> = Condvar::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">          <span class="comment">// 消费者</span></span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">q</span> = queue.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">item</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(item) = q.<span class="title function_ invoke__">pop_front</span>() &#123; <span class="comment">// 从队列中获取数据</span></span><br><span class="line">                        <span class="keyword">break</span> item; <span class="comment">// 获取到则返回</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        q = not_empty.<span class="title function_ invoke__">wait</span>(q).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 获取不到数据则阻塞等待</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(q);</span><br><span class="line">                dbg!(item);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 生产者</span></span><br><span class="line">            <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">                queue.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">push_back</span>(i);  <span class="comment">// 往队列里面投放数据</span></span><br><span class="line">                not_empty.<span class="title function_ invoke__">notify_one</span>();  <span class="comment">// 唤醒潜在的阻塞线程</span></span><br><span class="line">                thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，我们实现了一对生产者和消费者：</p><ol><li>消费尝试获取锁，并从队列中获取数据：<ol><li>如果有，则释放锁并返回。</li><li>如果没有，则调用条件变量的 <code>wait</code> 陷入阻塞<strong>并释放锁</strong>。</li></ol></li><li>生产者尝试获取锁，并往队列中投放数据，并调用条件变量的 <code>notify_one</code> 唤醒潜在的阻塞线程。</li></ol><pre class="mermaid">flowchart LR    A[生产者] -->|添加数据| B[队列]    B -->|取数据| C[消费者]    A -->|notify_one| C    C -->|wait| A</pre><h2 id="读完本篇你能学到什么">读完本篇你能学到什么</h2><p>你是否在多线程编程中遇到过这些令人头疼的问题：</p><p>🤔 <strong>性能浪费问题</strong>：消费者线程需要不断轮询检查数据是否就绪，即使没有数据也要持续占用 CPU，这种&quot;忙等待&quot;让程序效率低下？</p><p>🤔 <strong>复杂的同步逻辑</strong>：在生产者-消费者模式中，如何让消费者在没有数据时优雅地进入休眠，而不是无休止地检查？</p><p>🤔 <strong>竞态条件的困扰</strong>：如何确保在多线程环境下，唤醒操作不会丢失，线程不会因丢失唤醒而永远沉睡？</p><p>🤔 <strong>性能优化的疑惑</strong>：系统调用开销很大，如何避免在没有等待线程时进行无意义的唤醒操作？</p><p>🤔 <strong>内存顺序的选择</strong>：在实现同步原语时，到底该用 <code>Acquire</code>、<code>Release</code> 还是 <code>Relaxed</code>？如何分析 happens-before 关系？</p><p>如果这些问题曾经让你困惑，那么本文正是为你准备的。下面我们就正式开始从零开始构建一个条件变量（Condvar），用最直观的方式解答这些并发编程中的经典难题。</p><h2 id="v1：基础实现">v1：基础实现</h2><p>先来思考一下如何定义 <code>Condvar</code> 这个数据结构，参考标准库，它会有 3 个方法：</p><ul><li><code>wait(MutexGuard)</code>: 释放 MutexGuard 并陷入等待。</li><li><code>notify_one()</code>: 唤醒一个 <code>wait</code> 的线程。</li><li><code>notify_all()</code>: 唤醒所有 <code>wait</code> 的线程。</li></ul><p>看过本系列前面几篇的读者应该可以敏锐觉察到，这里就是对应了 <code>atomic-wait</code> 中的 <code>wait/wake_one/wake_all</code>。</p><p>那局势就比较明朗了，我们可以在 <code>condvar.wait(guard)</code> 的时候调用 <code>atomic_wait::wait(&amp;atomic)</code> ，然后在 <code>condvar.notify_one()</code> 的时候修改 <code>&amp;atomic</code> 然后调用 <code>atomic_wait::wake_one()</code> 唤醒线程，<code>condvar.notify_all()</code> 也同理。</p><p>因此 <code>Condvar</code> 需要有一个 <code>AtomicU32</code> 类型的属性，这里我们称为 <code>counter</code>。故 <code>Condvar</code> 结构暂且定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    counter: AtomicU32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            counter: AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>notify_one</code> 和 <code>notify_all</code> 所上所述，就非常简单了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify_one</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed);</span><br><span class="line">        <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify_all</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed);</span><br><span class="line">        <span class="title function_ invoke__">wake_all</span>(&amp;<span class="keyword">self</span>.counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就剩下 <code>wait</code> 了，它的基本原理：</p><ol><li>接收一个 MutexGuard；</li><li>释放 MutexGuard；</li><li>陷入等待，等待唤醒；</li><li>被唤醒后，再次抢占锁。</li></ol><p>综上，我们可以有以下实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) mutex: &amp;<span class="symbol">&#x27;a</span> Mutex&lt;T&gt;,  <span class="comment">// &lt;---- 需要公开 mutex 字段，这里使用 pub(crate) 限制 crate 外部访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wait</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(&amp;<span class="keyword">self</span>, guard: MutexGuard&lt;<span class="symbol">&#x27;a</span>, T&gt;) <span class="punctuation">-&gt;</span> MutexGuard&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter_value</span> = <span class="keyword">self</span>.counter.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unlock the mutex by dropping the guard,</span></span><br><span class="line">        <span class="comment">// but remember the mutex so we can lock it again.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutex</span> = guard.mutex;</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(guard);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait, but only if the counter hasn&#x27;t changed since unlocking.</span></span><br><span class="line">        <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.counter, counter_value);</span><br><span class="line"></span><br><span class="line">        mutex.<span class="title function_ invoke__">lock</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，为了访问 <code>guard.mutex</code>，这里我们使用的是之前自己手写的 <a href="https://github.com/hedon-rust-road/conutils/blob/main/src/mutex.rs">MutexGuard</a>，并将 <code>mutex</code> 字段的私有程度修改为 <code>pub(crate)</code>。代码比较简单，这里就不赘述了，完整流程可参考下图理解。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250610230511147.png" alt=""></p><p>我们修改一下测试用例，运行后发现也是可以通过的！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> std::&#123;collections::VecDeque, thread, time::Duration&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> crate::&#123;condvar::Condvar, mutex::Mutex&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">condvar_usage</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">queue</span> = Mutex::<span class="title function_ invoke__">new</span>(VecDeque::<span class="title function_ invoke__">new</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">not_empty</span> = Condvar::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">q</span> = queue.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">item</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(item) = q.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">                        <span class="keyword">break</span> item;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        q = not_empty.<span class="title function_ invoke__">wait</span>(q);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(q);</span><br><span class="line">                dbg!(item);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">                queue.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">push_back</span>(i);</span><br><span class="line">                not_empty.<span class="title function_ invoke__">notify_one</span>();</span><br><span class="line">                thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="v2：减少不必要的系统调用">v2：减少不必要的系统调用</h2><p>第 1 个版本中，我们在 <code>notify_one</code> 和 <code>notify_all</code> 分别都无条件调用了 <code>wake_one</code> 和 <code>wake_all</code> 尝试唤醒潜在的线程，但是这个时候可能并没有线程被阻塞着，那这个系统调用就白白浪费了。</p><p>所以在这个版本中，我们尝试来优化这一点。为此，我们需要记录当前阻塞中的线程的数量，所以需要给 <code>Condvar</code> 加一个属性 <code>num_waiters</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    counter: AtomicU32,</span><br><span class="line">    num_waiters: AtomicUsize,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            counter: AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">            num_waiters: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>notify_one</code> 和 <code>notify_all</code> 的时候，我们仅当 <code>num_waiters&gt;0</code> 的时候，才进行系统调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify_one</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.num_waiters.<span class="title function_ invoke__">load</span>(Relaxed) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed); <span class="comment">// <span class="doctag">TODO:</span> memory order</span></span><br><span class="line">            <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify_all</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.num_waiters.<span class="title function_ invoke__">load</span>(Relaxed) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed); <span class="comment">// <span class="doctag">TODO:</span> memory order</span></span><br><span class="line">            <span class="title function_ invoke__">wake_all</span>(&amp;<span class="keyword">self</span>.counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>wait</code> 的时候，我们先标记自己是等待的，即 <code>num_waiters++</code>，然后在被唤醒后，解除这个标记，即 <code>num_waiters--</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wait</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(&amp;<span class="keyword">self</span>, guard: MutexGuard&lt;<span class="symbol">&#x27;a</span>, T&gt;) <span class="punctuation">-&gt;</span> MutexGuard&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.num_waiters.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed); <span class="comment">// <span class="doctag">TODO:</span> memory order  &lt;----  New!!!</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> <span class="variable">counter_value</span> = <span class="keyword">self</span>.counter.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unlock the mutex by dropping the guard,</span></span><br><span class="line">        <span class="comment">// but remember the mutex so we can lock it again.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutex</span> = guard.mutex;</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(guard);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait, but only if the counter hasn&#x27;t changed since unlocking.</span></span><br><span class="line">        <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.counter, counter_value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.num_waiters.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Relaxed); <span class="comment">//<span class="doctag">TODO:</span> memory order   &lt;----  New!!!</span></span><br><span class="line"></span><br><span class="line">        mutex.<span class="title function_ invoke__">lock</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，这里又到了最关键的问题了：<strong><font color="red">操作 num_waiters 时该用什么内存顺序？</font></strong></p><p>这个关键的问题的关键是什么呢？是要**<font color="green">确定哪些地方需要建立 happens-before 关系！</font>**</p><p>很明显，我们这里的关键就是要**<font color="red">防止 <code>wake_one</code> 的丢失</font>**，即确保如果一个线程即将进入等待状态，那么后续的通知操作能够看到这个等待者的存在。所以这里我们需要 <code>notify_one()</code> 中的 <code>load</code> 和 <code>condvar.wait()</code> 中的 <code>fetch_add</code> 建立 happens-before 关系。至于 <code>fetch_sub</code> 就无所谓了，因为这个时候已经被唤醒了，丢失或者重复唤醒都无所谓了。</p><p>不过这里其实可以省掉这对 <code>Release</code> 和 <code>Acquire</code>，直接用 <code>Relaxed</code>！为什么呢？</p><ol><li><p>在 <code>condvar.wait</code> 的 <code>fetch_add</code> 之前，我们必须先拿到 MutexGuard，即通过 <code>lock()</code> 抢占到锁，<code>lock()</code> 里面是啥操作？是一个 <strong><code>Acquire</code></strong>!</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Mutex&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> MutexGuard&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">lock_contended</span>(&amp;<span class="keyword">self</span>.state);</span><br><span class="line">        <span class="comment">// Swap successfully, means locked.</span></span><br><span class="line">        MutexGuard &#123; mutex: <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">lock_contended</span>(state: &amp;AtomicU32) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spin_count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Err</span>(s) = state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="number">1</span>, Ordering::Acquire, Ordering::Relaxed) &#123;</span><br><span class="line">        <span class="keyword">if</span> s == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> spin_count &lt; <span class="number">100</span> &#123;</span><br><span class="line">                spin_count += <span class="number">1</span>;</span><br><span class="line">                std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _ = state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">1</span>, <span class="number">2</span>, Ordering::Acquire, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">wait</span>(state, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们在调用 <code>atomic-wait::wait</code> 陷入等待之前，要先 <code>drop(guard</code>)，别忘了，<code>drop(guard)</code> 里面是啥操作？是一个 <strong><code>Release</code></strong>！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// If there are threads waiting for the lock, wait one of them.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.mutex.state.<span class="title function_ invoke__">swap</span>(<span class="number">0</span>, Ordering::Release) == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.mutex.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>所以呀，这里其实天然就已经有一对 <code>Release</code> 和 <code>Acquire</code> 了！happens-before 关系是成立的！所以我们之前的代码就已经满足要求了，再次运行前面的测试用例，依旧是顺利通过的！</p><p>完整代码可参考：<a href="https://github.com/hedon-rust-road/conutils/blob/main/src/condvar.rs">conutils/condvar</a>。具体流程你可以参考下图辅助理解。</p><pre class="mermaid">sequenceDiagram    participant Consumer as 消费者线程    participant Producer as 生产者线程    participant Mutex as Mutex状态    participant NumWaiters as num_waiters    participant Counter as counter    Consumer->>Mutex: lock() [Acquire]    Consumer->>Consumer: 检查条件，发现需要等待    Consumer->>NumWaiters: fetch_add(1) [Relaxed]    Consumer->>Counter: load() -> counter_value    Consumer->>Mutex: drop(guard) [Release]    Consumer->>Counter: wait(counter_value)    Note over Producer: 生产者在另一个线程    Producer->>Mutex: lock() [Acquire] ✅ 与Consumer的Release同步    Producer->>Producer: 修改共享数据    Producer->>Mutex: drop(guard) [Release]    Producer->>NumWaiters: load() > 0? ✅ 看到Consumer的increment    Producer->>Counter: fetch_add(1) [Relaxed]    Producer->>Counter: wake_one()    Consumer->>Consumer: 被唤醒    Consumer->>Mutex: lock() [Acquire]    Consumer->>NumWaiters: fetch_sub(1) [Relaxed]</pre><blockquote><p>另外，即使 <code>notify_one()</code> 在 <code>wait()</code> 之前调用，<code>atomic_wait::wait()</code> 的语义也能保证正确性。因为 <code>wait(&amp;counter, expected_value)</code> 只有在 <code>counter</code> 的值等于 <code>expected_value</code> 时才会阻塞，如果 <code>counter</code> 已经被修改，<code>wait</code> 会立即返回。</p></blockquote><h2 id="总结">总结</h2><p>通过本文的学习，我们从零开始实现了一个功能完整的条件变量（Condvar），并在这个过程中解决了多个重要问题：</p><ol><li><p><strong>理解条件变量的本质</strong>：Condvar 本质上是一个配合 Mutex 使用的线程同步工具，它解决了&quot;如何让线程在条件不满足时休眠，条件满足时被唤醒&quot;这一经典并发编程问题。</p></li><li><p><strong>掌握两种实现策略</strong>：</p><ul><li><strong>v1 基础版本</strong>：直接使用 <code>atomic-wait</code> 实现等待与唤醒机制</li><li><strong>v2 优化版本</strong>：通过 <code>num_waiters</code> 计数器避免不必要的系统调用</li></ul></li><li><p><strong>深入理解内存顺序</strong>：通过分析 happens-before 关系，我们发现可以使用 <code>Relaxed</code> 内存顺序，因为 Mutex 的 <code>Release</code>/<code>Acquire</code> 操作已经提供了必要的同步保障。</p></li></ol><p>掌握了这些知识后，你可以：</p><ul><li>在生产者-消费者场景中高效地同步线程</li><li>理解标准库 <code>std::sync::Condvar</code> 的实现原理</li><li>在设计自己的同步原语时做出正确的内存顺序选择</li><li>识别并避免并发编程中的常见陷阱</li></ul><p>条件变量虽然概念简单，但其背后涉及的原子操作、内存顺序、操作系统原语等知识却相当深入。通过亲手实现，我们不仅掌握了工具的使用，更重要的是理解了其背后的设计思想，这为我们后续学习更复杂的并发编程技巧打下了坚实基础。</p><p>下篇，我们将完成 <a href="https://marabos.nl/atomics/building-locks.html#reader-writer-lock">Rust Atomics and Locks</a> 的最后一个实战案例：手写一个读写锁（RwLock）！</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">在多线程编程中，你是否遇到过这样的困扰：消费者线程不断轮询检查数据是否准备好，白白浪费 CPU 资源？或者在生产者-消费者模式中，如何让消费者优雅地等待数据到来？本文将带你手写一个高效的 Condvar（条件变量），解决线程间的等待与唤醒问题。我们将从最基础的实现开始，逐步优化到减少不必要的系统调用，并深入分析内存顺序的选择，让你彻底理解条件变量背后的设计哲学。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 实战" scheme="https://hedon.top/categories/rust/rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨手写一个 Mutex</title>
    <link href="https://hedon.top/2025/06/09/rust-action-mutex/"/>
    <id>https://hedon.top/2025/06/09/rust-action-mutex/</id>
    <published>2025-06-09T00:51:46.000Z</published>
    <updated>2025-06-17T11:12:23.466Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><a href="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust 原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust 实战丨手写一个 SpinLock</a></li><li><a href="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust 实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust 实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust 原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust 实战丨手写一个 Mutex</a> 👈 本篇</li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust 实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust 实战丨手写一个 RwLock</a></li></ul><hr><p>继上篇 <a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust 原理丨操作系统并发原语</a>，我们学习了不同操作系统下的并发原语实现，理解了它们最重要的贡献就是提供了一套 <code>wait/wake_one/wake_all</code> 的机制。本篇，我们将借助 <a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 的作者 <a href="https://github.com/m-ou-se">Mara Bos</a> 封装的 <a href="https://github.com/m-ou-se/atomic-wait">atomic-wait</a> crate，来手写一个自己的 <code>Mutex</code>！</p><h2 id="v1：基本实现">v1：基本实现</h2><p>首先我们来思考一下如何定义数据结构：</p><ol><li>我们需要 1 个原子变量 <strong>state</strong> 来记录锁的状态（0: unlocked, 1: locked），因为 <code>atomic-wait</code> 只支持 AtomicU32，所以这里我们的类型也定义为 AtomicU32。</li><li>另外我们需要一个 <strong>value</strong> 字段来保存数据，当抢到锁的时候，是可以对 <strong>value</strong> 进行修改的，但是这个时候只有共享引用，所以我们需要 <code>UnsafeCell</code> 来提供内部可变性。</li></ol><p>同时，贯彻 *RAII（Resource Acquisition Is Initialization，资源获取即初始化）*原则：</p><ol><li>我们在 <code>lock(&amp;self)</code> 成功时返回一个 <code>MutexGuard</code>，它包含 <code>&amp;Mutex</code>。</li><li>在 <code>MutexGuard</code> drop 的时候，我们将 <strong>state</strong> 重置为 0，表示释放锁，并唤醒一个潜在的阻塞线程。</li></ol><p>为了让 <code>Mutex</code> 可以在线程之间共享，我们需要为其实现 <code>Sync</code> trait，而又因为 <code>Mutex</code> 实现的是独占访问，上锁成功的线程是拥有 T 的所有权的，即要求 T 可以在线程中转移，即要求 T 需要实现 <code>Send</code> trait。</p><p>综上，我们定义的 <code>Mutex</code> 和 <code>MutexGuard</code> 结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Mutex</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// 0: unlocked</span></span><br><span class="line">    <span class="comment">/// 1: locked</span></span><br><span class="line">    state: AtomicU32,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    mutex: &amp;<span class="symbol">&#x27;a</span> Mutex&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Mutex</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Mutex&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            state: AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">            value: UnsafeCell::<span class="title function_ invoke__">new</span>(value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方面访问内部数据，我们为 <code>MutexGuard</code> 实现 <code>Deref</code> 和 <code>DerefMut</code> 这 2 个 trait:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*<span class="keyword">self</span>.mutex.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.mutex.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>MutexGuard</code> 离开作用域的时候，即被 drop 的时候，我们需要释放锁，并调用 <code>wake_one</code> 去唤醒一个潜在的阻塞线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.mutex.state.<span class="title function_ invoke__">store</span>(<span class="number">0</span>, Release);</span><br><span class="line">        <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.mutex.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将 <code>state</code> 设置为 0，使用的内存顺序是 <code>Release</code>，是为了跟 <code>lock</code> 的时候使用 <code>Acquire</code> 建立 happens-before 原则，确保 state 的真实值在各个线程中都是可见的。</p><p>在 <code>lock</code> 的时候，我们需要将 <code>state</code> 从 0 替换为 1，如果成功，则说明上锁成功，直接返回 MutexGuard，如果失败，则说明锁已经被抢占了，这个时候我们使用 <code>atomic-wait</code> 的 <code>wait()</code> 陷入休眠，等待 <code>wake_one</code> 信号唤醒，再尝试抢锁。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Mutex&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> MutexGuard&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.state.<span class="title function_ invoke__">swap</span>(<span class="number">1</span>, Acquire) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.state, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MutexGuard &#123; mutex: <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们第一个版本的 <code>Mutex</code> 就完工了！是不是很简单！我们来写 2 个单元测试验证一下基本逻辑是否正确：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard</span> = l.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">    guard.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(guard);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guard</span> = l.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(guard[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard</span> = l.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">            guard.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>)); <span class="comment">// sleep for makeing the second thread to be blcoked.</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>)); <span class="comment">// make sure the first thread get the lock</span></span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard</span> = l.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">            guard.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guard</span> = l.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(guard.<span class="title function_ invoke__">len</span>(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">running 2 tests</span><br><span class="line">test mutex::tests::one_thread_should_work ... ok</span><br><span class="line">test mutex::tests::cross_thread_should_work ... ok</span><br></pre></td></tr></table></figure><h2 id="v2：减少系统调用">v2：减少系统调用</h2><p>当 <code>MutexGuard</code> 的时候，我们将 <code>state</code> 置为 0，并调用 <code>wake_one</code> 唤醒一个潜在的线程，这个时候如果没有阻塞中的线程的话，那这个系统调用就比较浪费了。</p><p>所以在 v2 版本我们尝试来优化这一点。为此，我们需要扩展我们的 <code>state</code> 字段，新增<strong>表示是否有阻塞线程</strong>的能力。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Mutex</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// 0: unlocked</span></span><br><span class="line">    <span class="comment">/// 1: locked, but no blocked thread</span></span><br><span class="line">    <span class="comment">/// 2: locked, but has blocked threads</span></span><br><span class="line">    state: AtomicU32,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改了 <code>state</code> 的定义后我们需要修改上锁和解锁的逻辑，在上锁的时候，我们先尝试将 <code>state</code> 从 <code>0</code> 置为 <code>1</code>，如果成功了，说明抢到了锁，否则，我们将 <code>state</code> 置为 <code>2</code>，表示有线程被阻塞了。</p><p>这里书中的实现是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Mutex&lt;T&gt; &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> MutexGuard&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">lock_contended</span>(&amp;<span class="keyword">self</span>.state);</span><br><span class="line">        MutexGuard &#123; mutex: <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">lock_contended</span>(state: &amp;AtomicU32) &#123;</span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="number">1</span>, Acquire, Relaxed).<span class="title function_ invoke__">is_err</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> state.<span class="title function_ invoke__">swap</span>(<span class="number">2</span>, Acquire) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">wait</span>(&amp;state, <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.mutex.state.<span class="title function_ invoke__">swap</span>(<span class="number">0</span>, Release) == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;wake_one&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.mutex.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lock()</code>:</p><ul><li>如果成功将 <code>state</code> 从 <code>0</code> 变换为 <code>1</code>，则说明当前线程抢锁成功，直接返回 <code>MutexGuard</code>。</li><li>如果失败了，就将 <code>state</code> 置为 <code>2</code>，然后调用 <code>wait</code> 进入休眠。</li></ul><p><code>unlock()</code>:</p><ul><li>将 <code>state</code> 置为 <code>0</code>，如果之前是 <code>2</code> 的话，那就说明有线程被阻塞着，这个时候才调用 <code>wake_one</code> 唤醒一个阻塞的线程。</li></ul><p>这个地方，笔者觉得有一些问题， <code>state.swap(2, Acquire)</code> 这一行代码会无条件将 <code>state</code> 置为 <code>2</code>，也就是说，当这个线程抢到锁后，它在 <code>unlock()</code> 的时候，无论有没有在阻塞的线程，这个时候 <code>state</code> 都是 <code>2</code>，所以都会调用 <code>wake_one</code>。</p><pre class="mermaid">sequenceDiagram    participant A as 线程A (持有锁)    participant B as 线程B (尝试获锁)    participant State as Mutex State    participant System as 系统调用    Note over State: state = 1 (线程A持有锁)    B->>State: compare_exchange(0, 1)    State-->>B: 失败 (返回 1)    Note over B: 进入 while 循环    B->>State: swap(2)    Note over State: state: 1 → 2    State-->>B: 返回 1 (≠ 0)    B->>System: wait(&state, 2)    Note over B: 线程B进入等待状态    Note over A: 线程A释放锁    A->>State: swap(0)    Note over State: state: 2 → 0    State-->>A: 返回 2    A->>System: wake_one()    Note over System: 正确的唤醒！线程B确实在等待    Note over B: 线程B被唤醒，继续循环    B->>State: swap(2)    Note over State: state: 0 → 2    State-->>B: 返回 0，退出循环    Note over B: 获得锁，但state=2 (问题所在)    Note over B: 使用锁...    B->>State: unlock() - swap(0)    Note over State: state: 2 → 0    State-->>B: 返回 2    B->>System: wake_one()    Note over System: 不必要的调用！此时没有等待者</pre><p>我们可以运行上面的测试用例 <code>cross_thread_should_work</code>，可以看到输出了 2 个 wake_one，但是通过分析，应该只需要调用一次 <code>wake_one</code> 就足够了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test mutex::tests::cross_thread_should_work ... ok</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line"></span><br><span class="line">---- mutex::tests::cross_thread_should_work stdout ----</span><br><span class="line">wake_one</span><br><span class="line">wake_one</span><br></pre></td></tr></table></figure><p>笔者的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">lock_contended</span>(state: &amp;AtomicU32) &#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Err</span>(s) = state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="number">1</span>, Acquire, Relaxed) &#123;</span><br><span class="line">        <span class="keyword">if</span> s == <span class="number">1</span> &#123;</span><br><span class="line">            _ = state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">1</span>, <span class="number">2</span>, Acquire, Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">wait</span>(&amp;state, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们获取 <code>state.compare_exchange(0,1)</code> 的返回值，如果成功，说明抢到锁，直接返回。</li><li>如果失败了：<ul><li>原始值是 <code>1</code>，那我们就尝试将 <code>state</code> 从 <code>1</code> 交换为 <code>2</code>，然后调用 <code>wait</code> 陷入休眠。</li><li>原始值是 <code>2</code>，说明已经有别的线程也被阻塞了，这个时候直接调用 <code>wait</code> 陷入休眠。</li></ul></li><li>当被 <code>wake_one</code> 唤醒时，重新执行 <code>state.compare_exchange(0,1)</code> 抢占锁。</li></ol><p>这个新的流程中，我们抢到锁的时候，<code>state</code> 会被正确的设置为 <code>1</code> 而不是 <code>2</code>，这个时候，在 <code>drop</code> 的时候就不会有不必要的 <code>wake_one</code> 的调用了。</p><pre class="mermaid">sequenceDiagram    participant A as 线程A (持有锁)    participant B as 线程B (尝试获锁)    participant State as Mutex State    participant System as 系统调用    Note over State: state = 1 (线程A持有锁)    B->>State: compare_exchange(0, 1)    State-->>B: 失败，返回 s=1    Note over B: s == 1，尝试设置等待者标志    B->>State: compare_exchange(1, 2)    Note over State: state: 1 → 2    State-->>B: 成功    B->>System: wait(&state, 2)    Note over B: 线程B进入等待状态    Note over A: 线程A完成工作，释放锁    A->>State: unlock() - swap(0)    Note over State: state: 2 → 0    State-->>A: 返回 2    A->>System: wake_one()    Note over System: 正确唤醒线程B    Note over B: 线程B被唤醒，重新尝试获取锁    B->>State: compare_exchange(0, 1)    Note over State: state: 0 → 1 (关键！)    State-->>B: 成功！退出循环    Note over B: 🎯 获得锁，state=1 (正确状态)    Note over B: 使用锁进行工作...    B->>State: unlock() - swap(0)    Note over State: state: 1 → 0    State-->>B: 返回 1 (不是2！)    Note over B: ✅ 返回值是1，不调用wake_one    Note over System: 🎯 避免了不必要的系统调用</pre><p>我们重新运行上面的测试用例 <code>cross_thread_should_work</code>，可以看到只输出了 1 个 wake_one：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test mutex::tests::cross_thread_should_work ... ok</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line"></span><br><span class="line">---- mutex::tests::cross_thread_should_work stdout ----</span><br><span class="line">wake_one</span><br></pre></td></tr></table></figure><blockquote><p>不过笔者在做 benchmark 后发现书中的实现性能其实更高，在 macbook m2max 机器上，书中的版本要比我的版本快 5~10% 左右，猜测大概率是 <code>swap</code> 的性能要比 <code>compare_exchange</code> 高。</p></blockquote><h2 id="v3：短暂自旋进一步避免系统调用">v3：短暂自旋进一步避免系统调用</h2><p>还有一种潜在的优化是，我们可以在抢锁失败且返回 <code>state</code> 为 <code>1</code> 的时候，进行短暂的自旋，如果实际场景中占用锁的时间非常短，那我们就可以再省略一次 <code>wake</code> 的系统调用了。</p><p>不过值得注意的是，这种优化未必是正向的，一方面，如果锁占用时间比较长，那前面的自旋就白白浪费了，另一方面，自旋的次数带来的性能消耗，未必就比系统调用要小（不同的平台表现可能很不一样）。</p><p>书中给出的经验值是自选 <strong>100</strong> 次。</p><p>优化后的 <code>lock_contended</code> 如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">lock_contended</span>(state: &amp;AtomicU32) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spin_count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Err</span>(s) = state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="number">1</span>, Acquire, Relaxed) &#123;</span><br><span class="line">        <span class="keyword">if</span> s == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> spin_count &lt; <span class="number">100</span> &#123;</span><br><span class="line">                spin_count += <span class="number">1</span>;</span><br><span class="line">                std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _ = state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">1</span>, <span class="number">2</span>, Acquire, Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">wait</span>(&amp;state, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>感兴趣的读者可以使用 <a href="https://bheisler.github.io/criterion.rs/book/getting_started.html">criterion</a> 做一个 benchmark 看看自旋与之前的版本的性能差异有多少。</p></blockquote><p>完整代码可参考：<a href="https://github.com/hedon-rust-road/conutils/blob/main/src/mutex.rs">conutils/mutex</a>。</p><h2 id="总结">总结</h2><p>在本篇中，我们从零开始，结合 Rust 原子操作和内存顺序的核心知识，实现一个 Rust 中的 Mutex 锁，逐步揭示 Mutex 背后的等待与唤醒机制，为更好理解标准库中的 Mutex 奠定了良好的基础。下篇，我们将尝试手写一个条件变量 <strong>Condition Variable</strong>！</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">本文带你从零开始实现一个 Rust 中的 Mutex 锁，结合 Rust 原子操作和内存顺序的核心知识，逐步揭示 Mutex 背后的等待与唤醒机制。通过阅读本文，你不仅可以掌握如何使用 Rust 的原子 API 实现一个高效的互斥锁，还能深入理解原子操作背后的内存模型，为掌握更复杂的并发编程技巧打下坚实基础。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 实战" scheme="https://hedon.top/categories/rust/rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rust 原理丨操作系统并发原语</title>
    <link href="https://hedon.top/2025/06/08/rust-os-primitives/"/>
    <id>https://hedon.top/2025/06/08/rust-os-primitives/</id>
    <published>2025-06-08T09:45:28.000Z</published>
    <updated>2025-06-17T11:12:23.471Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><a href="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust 原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust 实战丨手写一个 SpinLock</a></li><li><a href="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust 实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust 实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust 原理丨操作系统并发原语</a> 👈 本篇</li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust 实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust 实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust 实战丨手写一个 RwLock</a></li></ul><hr><p>在本系列的前面所有篇章中，我们对非阻塞类的并发操作进行了详细的阐述和实践（除了 SpinLock，不过自旋锁是通过自旋来实现阻塞作用，本质上线程并没有陷入阻塞等待的状态）。</p><p>后面我们将继续参考 <a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 书中的后续篇章，继续手写几个阻塞类的并发工具，有 Mutex（互斥锁）、RwLock（读写锁）和 CondVar（条件变量）。它们都有一个共同的特点：<strong>线程会陷入阻塞，让出 CPU，在等待某个条件满足要求后，会被唤醒并重新调度执行</strong>。这就需要借助内核的能力了，我们需要内核支持：</p><ol><li>记住那些陷入阻塞的线程；</li><li>在满足条件后，能够唤醒对应的正确的线程。</li></ol><p>熟悉操作系统原理的读者应该清楚，我们编写的应用程序，一般是处于<strong>用户态</strong>，而想要跟内核进行交互，需要陷入<strong>内核态</strong>，而这种切换，很大程度需要依赖于操作系统提供的系统调用能力，即 <code>syscall</code>。</p><p>所以在进入手写 Mutex、RwLock 和 CondVar 篇章之前，我们需要先来学习一下，不同的操作系统，都为我们在并发操作中提供了什么样的能力和限制。</p><p>在 <a href="https://marabos.nl/atomics/os-primitives.html">Rust Atomics and Locks</a> 第八章（Operating System Primitives）中，作者介绍并比较了各平台提供的操作系统级并发原语，包括 POSIX 的 <code>pthread</code> 系列、Linux 的 <code>futex</code>、macOS 的 <code>os_unfair_lock</code>，以及 Windows 的<code>重量级内核对象</code>、<code>轻量级对象</code>和<code>基于地址的等待机制</code>。</p><p>在本篇，笔者将基于自己的理解，尝试对这章进行梳理和总结，以便为后面的手写实践篇章奠定一个良好的理论基础，这里还是建议读者去阅读原文，以便获得更多的细节，加深理解。</p><h1>POSIX 线程原语 pthread</h1><p>在 Unix 类操作系统中，比如 Linux，<code>libc</code> 就承担了跟内核进行交互的标准接口。在 <code>libc</code> 的基础之前，诞生了一个标准：<em>Portable Operationg System Interface</em>，即熟知的 <strong>POSIX</strong>。在 Rust 中，对应了 <a href="https://crates.io/crates/libc">libc</a> crate。</p><p>Windows 系统并不遵循 POSIX 标准，而是一系列的系统库来提供内核交互能力，比如 <a href="https://www.geoffchappell.com/studies/windows/win32/kernel32/api/index.htm">kernel32.dll</a>。</p><p>针对线程操作，POSIX 定义了一系列的数据类型和函数，即所谓的 <strong>pthreads</strong>。它提供了以下几个比较重要的并发原语，我将其归纳为一个表格，供你参考。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250608190516988.png" alt=""></p><h1>Linux：Futex 用户态等待与唤醒</h1><p>在 Linux 中，所有 <code>pthread</code> 原语的实现，都是通过 <strong>futex</strong> 这个系统调用。它是全程是 <em>fast user-space mutex</em>。它的实现核心是：<strong>通过操作一个 32 位的原子变量来实现等待和唤醒</strong>。等待操作会将一个线程陷入睡眠，而唤醒操作会唤醒那些操作同一个原子变量的睡眠中的线程。</p><p>这里我们简单进行一下展开，思考一下这个 <code>futex</code> 这个名字的含义，<em>fast user-space mutex</em> 翻译成中文就是<em>快速用户空间互斥锁</em>。我们知道，系统调用的代价是比较昂贵的，需要频繁地在用户态和内核态之间进行切换，对性能是很不友好的。</p><p>在 Linux 系统中，<strong>futex</strong> 机制并非独立存在，而是与互斥锁、条件变量等同步原语协同工作，形成 “<strong>用户态自旋 + 内核态等待</strong>” 的分层设计，以兼顾性能与功能。</p><p>比如在 Mutex 互斥锁场景下，采用 “两级等待” 策略：</p><ul><li><strong>用户态自旋阶段</strong>：尝试获取锁时先通过原子操作（如<code>atomic_compare_exchange</code>）自旋尝试，避免内核调用。</li><li><strong>内核态等待阶段</strong>：若自旋失败，通过 Futex 的 <code>FUTEX_WAIT</code> 陷入内核，将线程挂起，直到其他线程通过 <code>FUTEX_WAKE</code> 唤醒。</li></ul><p>这样多数短时间持锁场景可在用户态完成，仅在长时间竞争时陷入内核，相比纯内核互斥锁（如 spinlock）大幅降低系统调用开销。</p><p>这里有个很重要的点：<strong>判断和陷入等待，是原子的</strong>。也就是说，线程 A 在确定陷入等待时，如果关联的原子变量已经发生了变化，这个时候，不会陷入等待，而是会直接返回。这也就避免了唤醒信号的丢失。</p><p>这里我整理了 <strong>futex</strong> 的核心操作，供你参考：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250608190538982.png" alt=""></p><h1>macOS：公平的 pthread 与非公平的 os_unfair_lock</h1><p>在 macOS 上，线程/锁的内核 syscalls（<code>__psynch_*</code> 等）<strong>不是公开稳定 ABI</strong>，官方要求开发者只通过 <strong>LibSystem</strong>（libc + libpthread + Objective-C/Swift runtime 等）来访问，它们都完全实现了 <code>pthread</code>。</p><p>不过值得注意的是，在 macOS 10.12 版本之前，macOS 的 pthread lock 默认都是公平锁（fair locks），不过在 macOS 10.12 (Sierra, 2016) 起新增了 <a href="https://developer.apple.com/documentation/os/os_unfair_lock">os_unfair_lock</a>，它是一个不公平、阻塞型、低开销的锁，取代了已弃用的 <code>OSSpinLock</code>。</p><p>需要注意，<code>os_unfair_lock</code> 没有提供对应的条件变量或读写锁功能 。也就是说，如果需要使用条件等待或读写锁语义，仍需使用 <code>pthread_cond_t</code> 或 <code>pthread_rwlock_t</code> 等 POSIX 原语，或者使用更高层的 GCD（Grand Central Dispatch）并发模型。Apple 将<code>os_unfair_lock</code> 定位为替代早期的 <code>OSSpinLock</code> 的低级锁，以解决 <code>OSSpinLock</code> 存在的优先级反转问题，同时提供比 <code>pthread_mutex</code> 更快的性能。<code>os_unfair_lock</code> 内部会在必要时让出 CPU 而非自旋等待，从而避免高优先级线程饥饿，但调度上又不像 <code>pthread_mutex</code> 那样严格 FIFO。</p><h1>Windows</h1><p>Windows 提供了一系列独特的并发原语，可分为<a href="https://learn.microsoft.com/en-us/windows/win32/sysinfo/kernel-objects">重量级内核对象</a>、轻量级对象（如 <a href="https://learn.microsoft.com/en-us/windows/win32/sync/critical-section-objects">Critical Section</a>、<a href="https://learn.microsoft.com/en-us/windows/win32/sync/slim-reader-writer--srw--locks">SRW 锁</a>、<a href="https://learn.microsoft.com/en-us/windows/win32/sync/condition-variables">Condition Variable 条件变量</a>等）和<a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitonaddress">基于地址的等待机制</a>三大类。它们在 API 设计、用法和实现上各不相同，体现了 Windows 从早期到现代的演进。</p><h2 id="重量级内核对象：基于-HANDLE-的-wait-与-notify">重量级内核对象：基于 HANDLE 的 wait 与 notify</h2><p>Windows 的重量级同步原语是由内核完全管理的对象，典型代表包括：<strong>Mutex</strong>（互斥量）、<strong>Event</strong>（事件）、<strong>Semaphore</strong>（信号量）、<strong>WaitableTimer</strong>（可等待计时器）等 。这些对象通过 Windows API 创建，相当于创建了一个内核对象句柄（<strong>HANDLE</strong>），类似打开文件会得到文件句柄一样 。每个对象在内核有对应的数据结构，操作系统维护其状态和等待队列。具体可以参考： <a href="https://learn.microsoft.com/en-us/windows/win32/sysinfo/kernel-objects">重量级内核对象</a>。</p><p>我整理了它们的基本使用方式，供你参考：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250608192945913.png" alt=""></p><h2 id="轻量级对象：CriticalSection、SRWLock-与-ConditionVariable">轻量级对象：CriticalSection、SRWLock 与 ConditionVariable</h2><p>&quot;轻量级&quot;同步原语是指<strong>不以独立内核对象形式存在、主要在用户态运作、仅在必要时调用内核的机制</strong>。</p><blockquote><p>是不是已经开始有点 futex 的感觉了？🤭</p></blockquote><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250608224608594.png" alt=""></p><p><strong>CRITICAL_SECTION</strong></p><p>它并非通过 Create 函数得到句柄，而是定义为结构体 <code>CRITICAL_SECTION</code>，需调用 <code>InitializeCriticalSection()</code> 初始化，之后直接用地址操作。本质上是一个递归互斥锁，同一个线程可以多次 <code>Enter</code>，内部有一个递归计数，必须对应次数的 <code>Leave</code> 才能完全释放。</p><p>Critical Section 在未争用情况下尝试通过用户态 Atomic 操作获取，比如 CAS 交换为当前线程，成功则进入，失败则可能先自旋尝试，依旧失败再进入内核等待。</p><p><strong>SRW Locks</strong></p><p>SRW Locks 不支持递归获取，同一线程如果持有写锁，再请求写锁会死锁。SRW 之所以被称为 “slim” 锁，是因为其实现相当高效，无锁时获取和释放都是用户态的 Atomic 操作，发生争用时，内核用一个优化的等待机制管理等待队列。</p><p><strong>Condition Variable</strong></p><p>是 <a href="https://wuu.wikipedia.org/wiki/Windows_Vista">Vista</a> 时代引入的新原语，它必须搭配 Critical Section 或 SWR Lock 使用。</p><h2 id="基于地址的等待机制：WaitOnAddress">基于地址的等待机制：WaitOnAddress</h2><p>Windows 在 8 版（2012）引入了全新的底层同步机制，与 Linux futex 非常相似，主要函数有：</p><ul><li><code>WaitOnAddress(address, compare_address, _,_)</code>: 让当前线程在 address 指向的内存值满足特定条件前进入睡眠，函数会将 address 处提供的值和 compare_address 提高的值逐字节比较，如果全等，则线程睡眠，等待后续唤醒，如果不等，函数立即返回。与 futex_wait 相同，<strong>比较与睡眠是一个原子操作</strong>：在检查内存值与期望值决定休眠的过程中，若有其他线程改变了 address 或发起唤醒，系统会保证不漏掉信号。</li><li><code>WakeByAddressSingle(address)</code>: 唤醒在指定地址上等待的一个线程。</li><li><code>WakeByAddressAll(address)</code>: 唤醒在指定地址上等待的所有线程。</li></ul><p>在实现上，WaitOnAddress 非常轻量，没有显式的内存对象或句柄。当线程等待时，内核只是将线程放入与那块内存地址相关联的等待队列中，唤醒时根据地址找到等待线程列表进行唤醒。</p><h1>总结</h1><p>通过对 3 个不同的操作系统的分析，从大的角度来讲，我们会发现它们的并发原语最重要的就是要利用原子变量，在用户态实现 3 个操作，以减少系统调用的出现，进一步提升性能。这 3 个操作可以归纳为：</p><ul><li><strong>wait(&amp;AtomicU32)</strong>: 在原子变量等于期望值的时候陷入等待，否则直接返回。</li><li><strong>wake_one(&amp;AtomicU32)</strong>: 唤醒某个 <code>wait()</code> 在当前变量的线程。</li><li><strong>wake_all(&amp;AtomicU32)</strong>: 唤醒所有 <code>wait()</code> 在当前变量的线程。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250608232051766.png" alt=""></p><p>所以下一步如果我们想在编程语言的层面上（Rust）实现自己的 <code>Mutex</code>、<code>REMutex</code> 和 <code>CondVar</code>，第一步就是需要针对不同的操作系统实现一套 <code>wait/wake_one/wake_all</code> 以屏蔽不同操作系统的实现差异，幸运的是 <a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 的作者 <a href="https://github.com/m-ou-se">Mara Bos</a> 已经帮我们实现好了：<a href="https://github.com/m-ou-se/atomic-wait">atomic-wait</a>。下篇，我们就利用这个 crate，来一步步手写一个自己的 <code>Mutex</code>！</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">操作系统的并发原语是实现各种锁、条件变量和同步工具的核心基础。无论是 Linux 中被广泛使用的 futex、macOS 中的 pthread 和 os_unfair_lock，还是 Windows 系统上的重量级内核对象、轻量级原语及地址等待机制，本质上都是围绕着三个基本动作展开：wait、wake_one 和 wake_all。本文将通过对三大主流操作系统底层并发原语的梳理与对比，帮助你建立统一的认知框架，更深入地理解并发编程背后的系统级支持，避免在实践和学习中被五花八门的概念搞晕。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 原理" scheme="https://hedon.top/categories/rust/rust-%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="操作系统" scheme="https://hedon.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Rust 原理丨从汇编角度看原子操作</title>
    <link href="https://hedon.top/2025/06/05/rust-atomic-in-processor/"/>
    <id>https://hedon.top/2025/06/05/rust-atomic-in-processor/</id>
    <published>2025-06-05T00:36:03.000Z</published>
    <updated>2025-06-17T11:12:23.470Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><a href="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust 原理丨从汇编角度看原子操作</a> 👈 本篇</li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust 实战丨手写一个 SpinLock</a></li><li><a href="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust 实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust 实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust 原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust 实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust 实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust 实战丨手写一个 RwLock</a></li></ul><hr><p>继上篇 <a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a>，我们详细介绍了 Rust 中的原子操作及内存顺序和内存屏障的诸多概念。我们知道，之所以要在硬件层面之上的编程语言中，抽象出这些顶层概念，是为屏蔽底层硬件的差异。那么本篇，我们就尝试从汇编代码和硬件层面来分析在不同的计算机架构下这些概念是如何被实现的，它们之间就有哪些具体的差异。</p><p>在展开之前，我们先来复习一下 Rust 中的内存顺序和内存屏障。</p><p>Rust 支持五种内存顺序（Ordering），从最松散到最严格依次为：</p><table><thead><tr><th>内存顺序</th><th>说明</th><th>保证</th><th>适用场景</th><th>示例</th></tr></thead><tbody><tr><td>Relaxed</td><td>最宽松的内存顺序</td><td>- 仅保证操作的原子性<br>- 不提供任何同步保证<br>- 不建立 happens-before 关系</td><td>- 简单计数器<br>- 性能要求极高且确定不需要同步<br>- 已通过其他方式确保同步</td><td><code>counter.fetch_add(1, Ordering::Relaxed)</code></td></tr><tr><td>Release</td><td>用于存储操作</td><td>- 之前的内存访问不会被重排到此操作之后<br>- 与 Acquire 配对使用可建立 happens-before 关系</td><td>- 生产者-消费者模式<br>- 发布共享数据<br>- 初始化完成标志</td><td><code>data.store(42, Ordering::Release)</code></td></tr><tr><td>Acquire</td><td>用于加载操作</td><td>- 之后的内存访问不会被重排到此操作之前<br>- 与 Release 配对使用可建立 happens-before 关系</td><td>- 生产者-消费者模式<br>- 获取共享数据<br>- 检查初始化标志</td><td><code>data.load(Ordering::Acquire)</code></td></tr><tr><td>AcqRel</td><td>同时包含 Acquire 和 Release 语义</td><td>- 结合了 Acquire 和 Release 的所有保证<br>- 用于读改写操作</td><td>- 需要双向同步的原子操作<br>- 锁的实现<br>- 复杂的同步原语</td><td><code>value.fetch_add(1, Ordering::AcqRel)</code></td></tr><tr><td>SeqCst</td><td>最严格的内存顺序</td><td>- 包含 AcqRel 的所有保证<br>- 所有线程看到的所有 SeqCst 操作顺序一致<br>- 提供全局的顺序一致性</td><td>- 需要严格的全局顺序<br>- 不确定使用哪种顺序时<br>- 对性能要求不高的场景</td><td><code>flag.store(true, Ordering::SeqCst)</code></td></tr></tbody></table><p>内存屏障主要分为以下几种类型：</p><ol><li><p><strong>Load Barrier（读屏障）</strong></p><ul><li>确保在屏障之前的所有读操作都执行完成</li><li>防止后续读操作被重排到屏障之前</li><li>对应 Acquire 语义</li></ul></li><li><p><strong>Store Barrier（写屏障）</strong></p><ul><li>确保在屏障之前的所有写操作都执行完成</li><li>防止后续写操作被重排到屏障之前</li><li>对应 Release 语义</li></ul></li><li><p><strong>Full Barrier（全屏障）</strong></p><ul><li>同时包含读屏障和写屏障的功能</li><li>防止任何内存操作的重排序</li><li>对应 SeqCst 语义</li></ul></li></ol><h1>读完本篇你能学到什么</h1><ol><li><p><strong>汇编分析能力</strong>：掌握从 Rust 代码到汇编指令的完整分析链路，能够使用 <code>cargo-show-asm</code> 或 Compiler Explorer 等工具深入理解代码的底层实现。</p></li><li><p><strong>跨平台差异洞察</strong>：深刻理解 x86-64（CISC）与 ARM64（RISC）两大主流架构在原子操作实现上的本质差异，为性能优化和平台适配提供理论基础。</p></li><li><p><strong>内存顺序选择策略</strong>：不再需要死记硬背五种内存顺序，而是基于硬件特性和性能考量做出明智选择 —— 知道何时用 <code>Relaxed</code> 追求极致性能，何时必须上 <code>SeqCst</code> 保证正确性。</p></li><li><p><strong>原子性保证机制</strong>：理解为什么同样的汇编代码，普通操作与原子操作在编译器层面有本质区别，以及对齐访问与跨缓存行访问的不同行为。</p></li><li><p><strong>硬件协议原理</strong>：掌握 MESI 缓存一致性协议、x86 的 <code>lock</code> 机制、ARM 的 <code>LL/SC</code> 机制等底层实现原理，能够解释多核环境下的数据同步过程。</p></li><li><p><strong>性能优化洞察</strong>：理解不同架构下内存屏障的开销差异，为高性能并发代码提供优化方向（如 ARM64 上 <code>compare_exchange_weak</code> 的真实优势）。</p></li><li><p><strong>并发问题调试</strong>：当遇到并发 bug 时，能够从汇编层面分析问题根因，判断是内存顺序问题还是原子性问题。</p></li><li><p><strong>架构适配能力</strong>：在跨平台开发中，能够针对不同架构的特性（如 x86-64 的强顺序 vs ARM64 的弱顺序）做出相应的代码调整。</p></li><li><p><strong>锁与无锁数据结构设计</strong>：基于硬件原理设计高效的同步原语，理解何时选择基于 CAS 的无锁算法，何时选择传统锁机制。</p></li></ol><p>在进入汇编代码的世界之前，我们先简单补充 2 个重要概念，分别是<strong>指令集</strong>和 CPU 缓存一致性协议 <strong>MESI</strong>。</p><h1>指令集</h1><p>两种指令集：</p><ul><li>CISC（Complex Instruction Set Computing，复杂指令集）</li><li>RISC（Reduced Instruction Set Computing，精简指令集）</li></ul><p>二者对比：</p><table><thead><tr><th style="text-align:left">特征</th><th style="text-align:left">RISC</th><th style="text-align:left">CISC</th></tr></thead><tbody><tr><td style="text-align:left">指令集</td><td style="text-align:left">精简，指令数目少</td><td style="text-align:left">复杂，指令数目多</td></tr><tr><td style="text-align:left">指令复杂性</td><td style="text-align:left">指令简单，每条指令执行单一功能</td><td style="text-align:left">指令复杂，可以执行多个功能</td></tr><tr><td style="text-align:left">寻址方式</td><td style="text-align:left">简单寻址方式</td><td style="text-align:left">复杂寻址方式</td></tr><tr><td style="text-align:left">硬件实现</td><td style="text-align:left">易于实现</td><td style="text-align:left">实现复杂</td></tr><tr><td style="text-align:left">编译器</td><td style="text-align:left">高效编译器</td><td style="text-align:left">编译器效率相对较低</td></tr><tr><td style="text-align:left">运算速度</td><td style="text-align:left">快速</td><td style="text-align:left">相对慢</td></tr></tbody></table><blockquote><p>具体可参考：<a href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/">risc vs. cisc</a>。</p></blockquote><p>两种指令集分别对应两种最典型的计算机架构：</p><ul><li><strong>x86-64</strong>：<strong>基于 CISC（复杂指令集）的 64 位扩展架构</strong>，由 AMD 设计并主导，兼容 x86 32 位生态，通过硬件复杂性换取高性能与广泛兼容性，主导桌面与服务器领域。</li><li><strong>arm64</strong>：<strong>基于 RISC（精简指令集）的 64 位架构</strong>，由 ARM 设计，以精简指令、高能效为核心，原生支持低功耗场景，主导移动设备并逐步扩展至服务器与 PC 领域。</li></ul><p>在本篇中，我们只涉及 2 个平台：</p><ul><li>x86_64-unknown-linux-musl（以下简称 x86-64）</li><li>aarch64-unknown-linux-musl（以下简称 ARM64）</li></ul><p>要将 Rust 代码编译为指定平台的可执行文件：</p><ol><li><p>安装对应的目标平台</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rustup target add x86_64-unknown-linux-musl  # x86-64</span><br><span class="line">rustup target add aarch64-unknown-linux-musl # ARM64</span><br></pre></td></tr></table></figure></li><li><p>编译时使用 <code>--target</code> 标志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release --target x86_64-unknown-linux-musl</span><br><span class="line">cargo build --release --target aarch64-unknown-linux-musl</span><br></pre></td></tr></table></figure></li></ol><h1>缓存一致性协议 MESI</h1><p>在多核系统中，每个核心都有自己的缓存（L1/L2 Cache），而内存中的数据可能被多个核心同时读取或修改。如果不加控制，会导致以下问题：</p><ul><li><strong>缓存不一致（Cache Coherence Problem）</strong>：不同核心的缓存可能持有同一内存地址的不同副本。</li><li><strong>脏数据（Dirty Data）</strong>：某个核心修改了数据，但其他核心仍使用旧值。</li></ul><p>MESI（<strong>Modified, Exclusive, Shared, Invalid</strong>）是一种广泛使用的 <strong>缓存一致性协议</strong>（Cache Coherence Protocol），用于确保多核处理器系统中各个核心的缓存数据保持一致。它定义了缓存行的 <strong>4 种状态</strong>，并通过状态转换和消息传递机制来协调多核间的数据访问。</p><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:left">含义</th><th style="text-align:left">特点</th></tr></thead><tbody><tr><td style="text-align:center"><strong>M (Modified)</strong></td><td style="text-align:left">当前核心独占此数据，且已修改（与内存不一致）</td><td style="text-align:left">只有本核心有最新数据，必须写回内存后才能被其他核心读取。</td></tr><tr><td style="text-align:center"><strong>E (Exclusive)</strong></td><td style="text-align:left">当前核心独占此数据，但未修改（与内存一致）</td><td style="text-align:left">可以安全读取或修改，无需通知其他核心。</td></tr><tr><td style="text-align:center"><strong>S (Shared)</strong></td><td style="text-align:left">多个核心共享此数据（与内存一致）</td><td style="text-align:left">所有核心只能读取，不能直接修改（需先升级为 <code>M</code> 或 <code>E</code>）。</td></tr><tr><td style="text-align:center"><strong>I (Invalid)</strong></td><td style="text-align:left">缓存行无效（数据已过期或未加载）</td><td style="text-align:left">必须从内存或其他核心重新加载最新数据。</td></tr></tbody></table><p>更多细节可参考：<a href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE">维基百科 MESI</a>。</p><h1>查看 Rust 汇编代码</h1><p>查看 Rust 汇编代码的常用方式有以下几种：</p><ol><li><p>cargo rustc --lib --release --target x86_64-unknown-linux-musl – --emit asm</p></li><li><p><a href="https://crates.io/crates/cargo-show-asm">cargo-show-asm</a>（推荐 ✅）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo asm --release --target=x86_64-unknown-linux-musl --lib &#123;module&#125;::&#123;func_name&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://godbolt.org/">Compiler Explorer</a> （推荐 ✅）</p></li></ol><p>接下来我们来看下各种 Atomic 操作的汇编代码是什么样的。</p><h2 id="Store">Store</h2><p>x86-64：</p><ul><li>普通类型的赋值操作跟原子操作在 <code>Relaxed</code> 顺序下生成的汇编的一模一样的！</li><li>在强顺序一致性要求的 <code>SeqCst</code> 下，使用了带有 <code>Lock</code> 语义的 <code>xchg</code> 指令保证内存顺序。</li></ul><p>ARM64：</p><ul><li>普通类型的赋值操作跟原子操作在 <code>Relaxed</code> 顺序下生成的汇编的也是一模一样的！</li><li>在强顺序一致性要求的 <code>SeqCst</code> 下，使用了原子存储指令 <code>stlr</code> 保证内存顺序。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607135548507.png" alt=""></p><p>那么问题就来了：普通类型的赋值操作与 Relaxed 的原子操作生成的汇编一样，那凭什么后者就有原子性的保证呢？</p><ol><li>在上述 2 个架构中，这仅能说明 <code>mov</code> 和 <code>str</code> 在（当前选择的）硬件层面是原子的，无论是否使用 Atomic 类型。这因为 CPU 的缓存一致性协议（MESI）和总线锁定机制确保<strong>对齐操作</strong>不会撕裂（tearing）。</li><li>但是对于<strong>未对齐或跨缓存行访问</strong>，普通操作不保证原子性，可能被拆分为多次访问（如未对齐的 i64 可能拆为 2 个 32 位写入）。</li></ol><p>所以在 Rust 编译器上：</p><ul><li><strong>普通操作（*x=0）</strong>：Rust 不将其视为原子操作，即使生成的汇编与 <code>Relaxed</code> 原子操作相同。编译器可能优化或重排普通操作，破坏原子性假设。<ul><li>如：循环中的多次普通写入可能被合并为一次（优化后仅保留最后一次写入）。</li></ul></li><li><strong>原子操作（x.store(0, Relaxed)）</strong>：Rust 强制保证原子性，无论硬件是否隐式支持：<ul><li>对齐访问：直接生成 <code>mov</code>（利用硬件原子性）。</li><li>未对齐访问：插入额外指令（如 <code>lock cmpxchg</code>）确保原子性。</li><li>禁止编译器优化重排或消除操作。</li></ul></li></ul><h2 id="Load">Load</h2><p>x86-64：</p><ul><li>三段代码生成的汇编代码一模一样！这是因为 x86-64 的强顺序策略默认保证 <code>mov</code> 具有顺序一致性（类似 SeqCst），因此无需显示内存屏障。</li></ul><p>ARM64：</p><ul><li>对于普通类型的加载操作和 load Relaxed 生成的汇编代码是一样的。</li><li>对于 load SeqCst，使用了专门的原子加载指令 <code>ldar</code>，它会隐式插入内存屏障，保证该操作之前的所有内存访问对其他线程可见。</li></ul><p>虽然 x86-64 对于上面的 3 段代码生成的汇编是一样的，但这只是 x86-64 硬件层面上的保证，且跟之前一样，仅在对齐时是原子的，如果未对齐或跨缓存行访问，是可能被撕裂成 2 个操作的。</p><p>在 ARM64 中，不依靠硬件层面的复杂性，而通过 <code>ldar</code> 原子加载指令来保证原子性。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607135525872.png" alt=""></p><h2 id="Read-Modify-Write">Read-Modify-Write</h2><p>x86-64:</p><ul><li>使用 <code>lock</code> 指令来锁定总线或缓存行，从而实现原子性。</li></ul><p>ARM64:</p><ul><li>使用 <code>LL/SC</code> 机制来实现原子操作（有点类似与乐观锁的味道）。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607135850075.png" alt=""></p><h2 id="Compare-and-Exchange">Compare-and-Exchange</h2><p>x86-64:</p><ul><li>二者没有任何区别，或者可以理解为，x86-64 就没有专门实现 <code>compare_exchange_weak</code>。</li></ul><p>ARM64:</p><ul><li>二者实现是不同的，在 ARM64 上，<code>compare_exchange_weak</code> 是真的具备 <code>weak</code> 的特性。所以如果在特定场景下想用 <code>compare_exchange_weak</code> 来进一步提升性能，在上层也一定要用循环来主动重试，避免虚假失败。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607135449552.png" alt=""></p><h2 id="Fence">Fence</h2><p>x86-64:</p><ul><li>Release 和 Acquire 并没有额外使用的指令。只有使用 SeqCst 内存屏障的时候，会插入一条 <code>mfence</code> (memory fence) 指令，这条指令会保证在越过它之前，前面所有的内存操作都已经完成。</li></ul><p>ARM64:</p><ul><li>Release、AcqRel 和 SeqCst 都插入了一条 <code>dmb ish</code>(data memory barrier, inner shared domain)。而 Acquire 则插入了一条 <code>dmb ishld</code>，它只会等待 load 操作的完成，但是允许 store 操作重排序到它后面。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607144937786.png" alt=""></p><h2 id="总结对比">总结对比</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607144757100.png" alt=""></p><p>到这里我们可以得到以下结论：</p><ol><li>x86-64 保证原子性的关键是 <code>lock</code> 机制，ARM64 保证原子性的关键是 <code>LL/SC</code> 机制。</li><li>x86-64 保证内存顺序的关键是 <code>mfence</code> 指令，ARM64 保证内存顺序的关键是 <code>dmb ish</code> 和 <code>dmb ishld</code> 指令。</li><li>x86-64 没有实现真实的 <code>compare_exchange_weak</code>，ARM64 实现了 <code>compare_exchange_weak</code>。</li><li>x86-64 使用的是强顺序策略，具体来说：<ul><li><strong>Load→ 后续操作</strong>：禁止重排序（如 <code>Load A</code> → <code>Store B</code> 必须保持顺序）。</li><li><strong>Store→ 前序操作</strong>：禁止重排序（如 <code>Load A</code> → <code>Store B</code> 中 <code>Store B</code> 不能提前到 <code>Load A</code> 前）。</li><li><strong>Store→ 后续 Load</strong>：允许重排序（如 <code>Store A</code> → <code>Load B</code> 可能实际执行为 <code>Load B</code> → <code>Store A</code></li></ul></li><li>ARM 使用的是弱顺序策略，即所有的原子操作都可能被重排序。</li><li>x86-64 中，Relaxed、Acquire、Release 和 AcqRel 的内存顺序效果是一致的。ARM64 中，Relaxed 没有任何内存顺序的保证，而 Release、AcqRel 和 SeqCst 是一样昂贵的，Acquire 稍微轻量一点，只保证了前面的 load 不会重排到后面。</li></ol><p><a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 书中给出了一张更细节的图，感兴趣的读者可以研究一下。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607151428218.png" alt="Rust Atomics and Locks: An overview of the instructions that the various atomic operations compile down to on ARM64 and x86-64 for each memory ordering"></p><h1>硬件原理</h1><p>最后我们尝试从硬件层面来进一步理解原子操作的底层实现。这块笔者并不专业，更多的是尝试通过 ChatGPT 等 LLM 查阅资料，进行梳理总结。</p><p>原子操作的底层实现（如 x86 的 <code>lock</code> 前缀或 ARM 的 <code>LL/SC</code>）依赖于硬件级别的协同机制，其核心是通过 <strong>缓存一致性协议</strong>、<strong>总线仲裁</strong> 和 <strong>指令集层面的特殊支持</strong> 来保证多核环境下的原子性和内存顺序。</p><h2 id="x86-的-lock-前缀：总线锁定与缓存一致性">x86 的 <code>lock</code> 前缀：总线锁定与缓存一致性</h2><ol><li><p><strong>总线锁定（Bus Locking）</strong></p><p>当 CPU 执行 <code>lock cmpxchg</code> 时，<code>lock</code> 前缀会向总线（或缓存一致性协议）发送信号，<strong>临时独占内存地址的访问权</strong>，阻止其他核心的干扰。</p><ol><li><strong>锁定范围</strong>：现代 CPU 通常锁定缓存行（通常 64 字节），而非整个总线。</li><li><strong>硬件支持</strong>：通过处理器的 <strong>原子操作单元</strong> 和 <strong>缓存控制器</strong> 协同实现。</li></ol></li><li><p><strong>MESI 缓存一致性协议</strong></p><blockquote><p>缓存一致性协议（如 MESI）会在硬件层面上确保所有核心对内存修改的观察一致：任何核心的修改会立即（或按协议约定）传播到其他核心的缓存。</p></blockquote><p><code>lock</code> 操作会强制目标缓存行进入 <strong>Modified（独占修改）</strong> 状态，并通知其他核心的缓存行失效（Invalid）。 如：</p><ol><li><p>核心 A 执行 <code>lock inc [x]</code>，缓存行 <code>x</code> 变为 Modified。</p></li><li><p>核心 B 尝试读取 <code>x</code>，触发缓存一致性协议：</p><ul><li><p>核心 A 将修改后的值写回主存或核心 B 的缓存（取决于协议变种如 MESIF/MOESI）。</p></li><li><p>核心 B 的缓存行 <code>x</code> 变为 <strong>Shared</strong> 或 <strong>Exclusive</strong>。</p></li></ul></li></ol></li><li><p><strong>内存屏障的隐含保证</strong></p><p>即使代码使用 <code>Relaxed</code> 内存序，<code>lock</code> 会隐式插入 <strong>StoreLoad</strong> 屏障，确保：</p><ol><li>该指令前的所有写操作对其他核心可见。</li><li>该指令后的读操作不会重排到指令前。</li></ol></li><li><p><strong>现代优化：缓存锁定（Cache Locking）</strong></p><p>新式 CPU（如 Intel Skylake+）优先在缓存层面实现原子性，仅当跨缓存行或未对齐时才降级为总线锁定，减少性能损耗。</p></li></ol><h2 id="ARM-的-LL-SC（Load-Linked-Store-Conditional）：轻量级独占标记">ARM 的 LL/SC（Load-Linked/Store-Conditional）：轻量级独占标记</h2><ol><li><p><strong>独占访问标记（Exclusive Monitor）</strong></p><p><strong>硬件状态机</strong>：每个 CPU 核心维护一个 <strong>独占访问标记</strong>，记录最近通过 <code>ldxr</code> 加载的内存地址。</p><ul><li><p><strong>标记触发</strong>：<code>ldxr [x]</code> 会标记地址 <code>x</code> 为当前核心的独占访问区域。</p></li><li><p><strong>标记清除条件</strong>：</p><ul><li><p>其他核心修改了 <code>x</code> 的缓存行（通过缓存一致性协议）。</p></li><li><p>当前核心执行 <code>clrex</code> 或上下文切换。</p></li></ul></li></ul></li><li><p><strong>条件存储（**</strong><code>stxr</code>*<strong>*）的原子性校验</strong></p><p><strong>校验独占标记</strong>：<code>stxr</code> 执行时，硬件会检查目标地址的独占标记是否仍属于当前核心：</p><ol><li><strong>若标记有效</strong>：存储成功，返回 0。</li><li><strong>若标记失效</strong>：存储失败，返回 1（需重试）。</li></ol></li><li><p><strong>与缓存一致性协议的交互</strong></p><p><strong>ARM 的 ACE 协议</strong>：LL/SC 依赖缓存一致性协议（如 CHI 或 ACE）监听其他核心的修改：</p><ol><li>核心 A 执行 <code>ldxr [x]</code>，缓存行 <code>x</code> 进入 <strong>Exclusive</strong> 状态。</li><li>若核心 B 写入 <code>x</code>，缓存行在核心 A 中变为 <strong>Invalid</strong>，独占标记被清除。</li><li>核心 A 的后续 <code>stxr</code> 会因标记失效而失败。</li></ol></li><li><p><strong>内存顺序的灵活控制</strong></p><p>ARM 的内存序（如 <code>Relaxed</code>/<code>SeqCst</code>）通过显式屏障指令实现：</p><ol><li><code>ldapr</code>（Load-Acquire）：确保后续操作不重排到加载前。</li><li><code>stlr</code>（Store-Release）：确保前序操作不重排到存储后。</li></ol></li></ol><h1>总结</h1><p>本篇文章通过查看 <code>x86_64-unknown-linux-musl</code> 和 <code>aarch64-unknown-linux-musl</code> 两大平台下的汇编代码 ，深入剖析了 Rust 原子操作的底层实现机制，揭示了同一行 Rust 代码在不同平台上截然不同的机器级行为。</p><p>到目前为止，我们学习的都是无锁（non-blocking）操作，下篇，我们将继续学习 <a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 中的第八章《Operating System Primitives》，为手写阻塞类组件（Mutex、RwLock、CondVar）做理论准备，咱们下篇见！</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">本篇文章沿着 “CPU → 汇编指令 → Rust 原子语义” 的链路，带你拆解 Atomic* 背后到底发生了什么。我们先用 x86-64 与 ARM64 的真实编译结果对比 Ordering 的生成代码，再结合缓存一致性协议与编译器重排规则，解释为什么同一行 Rust 代码在不同平台会呈现截然不同的机器级行为。读完后，你不必死记硬背五种内存顺序，也能判断何时选 Relaxed、何时必须上 SeqCst，并掌握一套“看 asm → 辨语义 → 做权衡”的分析方法，为写锁、并发容器或性能调优提供根底。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 底层原理" scheme="https://hedon.top/categories/rust/rust-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="rust 原理" scheme="https://hedon.top/tags/rust-%E5%8E%9F%E7%90%86/"/>
    
    <category term="并发原理" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="原子操作" scheme="https://hedon.top/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
    <category term="汇编" scheme="https://hedon.top/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨手写一个 Arc</title>
    <link href="https://hedon.top/2025/06/03/rust-action-arc/"/>
    <id>https://hedon.top/2025/06/03/rust-action-arc/</id>
    <published>2025-06-03T05:00:00.000Z</published>
    <updated>2025-06-26T05:23:18.787Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><a href="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust 原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust 实战丨手写一个 SpinLock</a></li><li><a href="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust 实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust 实战丨手写一个 Arc</a> 👈 本篇</li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust 原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust 实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust 实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust 实战丨手写一个 RwLock</a></li></ul><hr><p>继上篇 <a href="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust 实战丨手写一个 oneshot channel</a>，本篇我们继续参考 <a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 一书，来实现一个 <code>Arc</code>。</p><p>在本章开始之前，我们假设你已经：</p><ol><li>熟悉并理解 Rust 的各种原子操作。</li><li>阅读过 <a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a>，并理解内存顺序和内存屏障的原理和使用方法。</li><li>理解 Rust <code>UnsafeCell&lt;T&gt;</code> 提供的内部可变性允许我们在持有共享引用 <code>&amp;</code> 的时候可以对数据进行修改。</li></ol><h2 id="Arc-简介">Arc 简介</h2><p><code>Arc</code>（<em>Atomic Reference Counted</em>）是 Rust 标准库里位于 <code>std::sync</code> 模块中的智能指针，用于 <strong>在多个线程之间安全地共享只读数据</strong>。和只适用于单线程场景的 <code>Rc&lt;T&gt;</code> 不同，<code>Arc&lt;T&gt;</code> 的引用计数增减操作使用原子指令，从而保证跨线程的内存安全。</p><p><strong>为什么需要 Arc？</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Person &#123; age: <span class="number">18</span>, name: <span class="string">&quot;hedon&quot;</span>.<span class="title function_ invoke__">to_string</span>(), address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>() &#125;;</span><br><span class="line"></span><br><span class="line">thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">spawn</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;p)); <span class="comment">// ✅ scope 内的线程可以借用</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;p)); <span class="comment">// ❌ 需要 &#x27;static 生命周期</span></span><br></pre></td></tr></table></figure><p><strong>问题</strong>：<code>thread::spawn</code> 要求 <code>'static</code> 生命周期，但 <code>&amp;p</code> 只是栈上变量的借用。<br><strong>解决</strong>：使用 <code>Arc::new(p)</code> 把数据移到堆上，通过原子引用计数实现多所有权：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Arc::<span class="title function_ invoke__">new</span>(Person &#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p_clone</span> = p.<span class="title function_ invoke__">clone</span>(); <span class="comment">// 原子计数 +1</span></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p_clone)); <span class="comment">// ✅ 编译通过</span></span><br></pre></td></tr></table></figure><h2 id="读完本篇你能学到什么">读完本篇你能学到什么</h2><ul><li><strong>原子操作的内存顺序选择</strong>：通过引用计数这个具体例子，理解 <code>Relaxed / Acquire / Release / fence</code> 的使用场景。</li><li><strong>弱引用解决循环引用</strong>：<code>Weak&lt;T&gt;</code> 的设计原理和在图结构中的应用。</li><li><strong>Arc::get_mut 的安全性保证</strong>：理解「非原子两步校验」的巧妙设计。</li><li><strong>零成本抽象的实现细节</strong>：<code>UnsafeCell</code> + <code>ManuallyDrop</code> 相比 <code>Option&lt;T&gt;</code> 的优势。</li></ul><h2 id="v0-基础引用计数">v0: 基础引用计数</h2><h3 id="数据结构">数据结构</h3><p>我们先来分析一下基本的数据结构该如何定义，在之前的 <a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust 实战丨手写一个 SpinLock</a>，我们讲到了 C++/Rust 常用的并发编程方式 RAII（Resource Acquisition Is Initialization，资源获取即初始化），其核心思想是：<strong>在对象构造函数中获取资源，在析构函数中释放资源</strong>。上面的案例中，我们在初始化 <code>Person</code> 的时候其实也是应用了这种思路。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Arc::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    name: <span class="string">&quot;hedon&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以我们的自定义 <code>Arc</code> 需要泛型 <code>T</code>，使其可以承载不同的数据类型的数据 <code>data</code>，同时为了做引用计数，它需要一个数值类型 <code>ref_count</code> 来计数，为了并发安全，我们可以选择原子类型 <code>AtomicUsize</code>。</p><p>在 <code>Arc</code> 中，我们需要自己管理 <code>data</code> 的生命周期，除了使用裸指针 <code>*mut T</code> 或 <code>*const T</code> 之外，我们可以使用 <code>std::ptr::NonNull&lt;T&gt;</code> ，它是一个零成本、保证非空、支持协变（可安全向子类型转换）的裸指针包装器，具体可参考<strong>附录 1. NonNull&lt;T&gt;</strong>。</p><p>综上，我们可以定义以下数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    ref_count: AtomicUsize,</span><br><span class="line">    data: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Arc &#123;</span><br><span class="line">            ptr: NonNull::<span class="title function_ invoke__">from</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(ArcData &#123;</span><br><span class="line">                ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                data,</span><br><span class="line">            &#125;))),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们定义了 <code>ArcData</code> 和 <code>Arc</code> 两个结构，其中 <code>ArcData</code> 包含引用计数 <code>ref_count</code> 和实际数据 <code>data</code>。</li><li>在 <code>Arc</code> 中，我们使用 <code>NonNull</code> 来管理 <code>ArcData</code> 的生命周期。初始化时，先用 <code>Box::new()</code> 在堆上分配内存，再通过 <code>Box::leak()</code> 放弃 <code>Box&lt;T&gt;</code> 的所有权，交由 <code>Arc</code> 自行管理。</li></ol><pre class="mermaid">graph TB    subgraph Stack ["栈内存 Stack"]        ArcStruct["Arc&lt;T&gt;<br/>ptr: NonNull&lt;ArcData&lt;T&gt;&gt;"]    end    subgraph Heap ["堆内存 Heap"]        ArcDataStruct["ArcData&lt;T&gt;<br/>ref_count: AtomicUsize(1)<br/>data: T"]    end    ArcStruct -->|指向| ArcDataStruct    subgraph Process ["内存分配过程"]        Step1["Box::new(ArcData)"]        Step2["Box::leak()"]        Step3["NonNull::from()"]        Step1 --> Step2        Step2 --> Step3    end    classDef stackStyle fill:#e1f5fe,stroke:#01579b,stroke-width:2px    classDef heapStyle fill:#f3e5f5,stroke:#4a148c,stroke-width:2px    classDef processStyle fill:#fff3e0,stroke:#e65100,stroke-width:2px    class ArcStruct stackStyle    class ArcDataStruct heapStyle    class Step1,Step2,Step3 processStyle</pre><p>另外，跨线程发送 <code>Arc&lt;T&gt;</code> 会导致 <code>T</code> 对象被共享，即 <code>T</code> 需要满足 <code>Sync</code> trait，而跨线程发送 <code>Arc&lt;T&gt;</code> 也会导致需要由另外一个线程来释放 <code>T</code>，所以需要 <code>T</code> 满足 <code>Send</code> trait。所以只有当 <code>T</code> 满足 <code>Send+Sync</code> 的时候，<code>Arc&lt;T&gt;</code> 才是 <code>Send</code> 的，对于 <code>Sync</code> 也是同理，因为我们可以为 <code>Arc&lt;T&gt;</code> 分别实现 <code>Sync</code> 和 <code>Send</code> trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>为了能够便捷的获取 <code>data</code>，我们先为 <code>Arc&lt;T&gt;</code> 实现一个 <code>data()</code> 用于获取 <code>ArcData&lt;T&gt;</code>，同时为其实现 <code>Deref</code> trait，用于像指针一样无感操作 <code>data: T</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ref</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="维护引用计数">维护引用计数</h3><p>基础部分我们已经铺垫完了，现在我们需要来实现 2 个最重要的 trait 了：</p><ul><li><strong>Clone</strong>: <code>Arc</code> 引用计数的关键，在每次 <code>clone()</code> 的时候，我们不拷贝 <code>data</code>，而是让 <code>ref_count</code> 自增，进行引用计数。</li><li><strong>Drop</strong>: 在 <code>Arc&lt;T&gt;</code> 实例离开作用域的时候，我们需要让 <code>ref_count</code> 自减，同时在最后一个 <code>Arc&lt;T&gt;</code> 被销毁时，我们需要主动释放 <code>ArcData&lt;T&gt;</code> 的内存资源。</li></ul><p>我们先来实现 <code>Clone</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 处理整型溢出的情况</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed)</span><br><span class="line">        Arc &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里没有其他原子操作需要跟当前操作建立严格的 <code>happens-before</code> 关系，所以这里我们可以使用最松的 <code>Relaxed</code> 内存顺序。</p><p>接下来看下 <code>Drop</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> &lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, ???) == <span class="number">1</span> &#123; <span class="comment">// &lt;----- 这里需要什么使用内存顺序约束？</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>Drop</code>，我们就需要好好想一想需要什么内存顺序约束了。在最后一个 <code>drop</code> 的时候，我们有 2 个目标：</p><ol><li><strong>不能过早释放</strong>：确保在引用计数减到 0 并销毁对象之前，没有别的线程仍在使用这份数据；</li><li><strong>要看得见别人写的东西</strong>：如果别的线程在它们各自的 <code>drop</code> 里面对共享对象做了写入，最后一个线程做析构时必须&quot;看到&quot;这些写入，否则就可能出现数据竞争或次序错误。</li></ol><p>换言之，我们需要最后一个 <code>fetch_sub</code> 跟前面其他每一个 <code>fetch_sub</code> 都建立起 happens before 关系，也即我们需要一对 Release 和 Acquire 来保证 happens-before。</p><p>这里简单回顾一下 <code>Release</code> 和 <code>Acquire</code>，不熟悉的读者可以参阅：<a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a>。</p><ul><li><code>Release</code>: 作用于写操作（store），确保该操作之前的所有内存访问不会被重排到这个 Release 操作之后。</li><li><code>Acquire</code>: 作用于读操作（load），确保该操作之后的所有内存访问不会被重排到这个 Acquire 操作之前。</li><li>当一个线程通过 <code>Acquire</code> 读取到另一个线程通过 <code>Release</code> 写入的值时，会建立一个 happens-before 关系：<strong>线程 A 中 Release 写入之前的所有内存写操作，对于线程 B 中 Acquire 读取之后的所有内存读操作都是可见的</strong>。</li></ul><blockquote><p><strong>Release-Sequence 概念补充</strong>：当多个线程对同一个原子变量执行 Release 操作时，这些操作会形成一个 “release-sequence”。后续任何一个 Acquire 操作读取到这个序列中的任意值，都能与整个序列建立 happens-before 关系。这正是为什么我们的 <code>fence(Acquire)</code> 能够与之前<strong>所有线程</strong>的 <code>fetch_sub(Release)</code> 形成同步的关键。</p></blockquote><p>我们当然可以使用 <code> Release</code> 和 <code>Acquire</code> 的结合体 <code>AcqRel</code> 来一步到位解决这个问题。不过考虑到只有最后一个 <code>drop</code> 需要满足这个关系，我们可以尝试做得更优雅一些。</p><p><strong>在这种仅需在临界值保证 happens-before 的场景下，我们都可以单独在临界情况下使用一个 <code>fence</code> 来建立起 happens-before。</strong></p><p>具体来说：</p><ul><li><strong>对于非最终 <code>drop</code></strong>：我们只需要使用 <code>Release</code>，即 <code>fetch_sub(1, Ordering::Release)</code>，它保证了别的线程如果最终做&quot;最后一次 drop&quot;，只要它对相同原子执行一条 <em>Acquire</em> 操作，它就能同步到前面所有线程对数据做过的改动。</li><li><strong>对于最终 <code>drop</code></strong>：在调用 <code>fetch_sub</code> 的时候我们仍需要 <code>Release</code> 语义，但是调用时，我们并不知道自己是不是&quot;最后那个线程&quot;。当 <code>fetch_sub</code> 返回 <code>1</code> 的时候，说明我们是&quot;最后那个线程&quot;。这个时候，我们需要建立一个 <code>fetch(Acquire)</code>，与之前的所有 <code>Release</code> 形成配对，确保看到<strong>之前所有的历史写入</strong>，这个时候我们才能确定已经没有别的线程在使用数据了，我们才可以安全地销毁对象。</li></ul><p>如下图所示；</p><pre class="mermaid">sequenceDiagram    participant A as Thread A    participant B as Thread B    participant C as Thread C<br/>(最后 drop)    %% 普通写入    A->>A: write shared data …    B->>B: write shared data …    %% 非最终 drop：Release 写    A->>A: fetch_sub (Release)  ⬅ 计数 n→n-1    B->>B: fetch_sub (Release)  ⬅ 计数 n-1→n-2    %% 形成 release-sequence    Note over A,B: 这两次 Release 写组成<br/>同一条 release-sequence    %% 最终 drop：Release 写 & 返回 1    C->>C: fetch_sub (Release)  ⬅ 返回 1 → 计数 0    %% Acquire fence 同步    C-->>C: fence (Acquire)<br/>【接收 release-sequence】    %% 安全析构    C->>C: drop(Box::from_raw)    %% 结果说明    Note over C: fence (Acquire) 使 A/B<br/>对共享数据的写必定<br/>在析构前可见</pre><p>经过这么一顿分析后，我们最终的 <code>Drop</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// ❶ 所有 `drop` 都执行：Release</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// ❷ 只有最后一个引用才会进来</span></span><br><span class="line">            std::sync::atomic::<span class="title function_ invoke__">fence</span>(Ordering::Acquire); <span class="comment">// ❸ 补上 Acquire</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="comment">// ❹ 现在可以安全地回收并析构</span></span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现逻辑：</p><ol><li><strong>所有 drop</strong> 都用 <code>Release</code> 语义减引用计数，为可能的&quot;最后一次 drop&quot;做准备</li><li><strong>只有最后一次 drop</strong>（返回值为 1）才需要额外的 <code>fence(Acquire)</code> 与之前所有的 Release 建立 happens-before</li><li><strong>安全析构</strong>：现在可以确保看到所有历史写入，没人再持有引用</li></ol><h3 id="完整代码">完整代码</h3><p>自此，我们第一个版本的 <code>Arc</code> 就实现完毕了，我们来看一下最终完成的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering, fence&#125;;</span><br><span class="line"><span class="keyword">use</span> std::ptr::NonNull;</span><br><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    ref_count: AtomicUsize,</span><br><span class="line">    data: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Arc &#123;</span><br><span class="line">            ptr: NonNull::<span class="title function_ invoke__">from</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(ArcData &#123;</span><br><span class="line">                ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                data,</span><br><span class="line">            &#125;))),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ref</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        Arc &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试">单元测试</h3><p>写个单元测试验证一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">arc_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> NUM_DROPS: AtomicUsize = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DetectDrop</span>;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">DetectDrop</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">            NUM_DROPS.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 2 个 Arc 共享一个元组，包含一个字符串和 DetectDrop 对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Arc::<span class="title function_ invoke__">new</span>((<span class="string">&quot;hedon&quot;</span>, DetectDrop));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 x 转移到另外一个线程并使用它</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(x.<span class="number">0</span>, <span class="string">&quot;hedon&quot;</span>); <span class="comment">// 可以正常使用</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里，y 应该也是可以正常使用的</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(y.<span class="number">0</span>, <span class="string">&quot;hedon&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 t 线程执行完毕</span></span><br><span class="line">    t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个时候 `x` 已经被释放了，但是`y` 还没有被释放，</span></span><br><span class="line">    <span class="comment">// 所以 `DetectDrop` 应该还没被释放。</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(NUM_DROPS.<span class="title function_ invoke__">load</span>(Ordering::Relaxed), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动释放掉 `y`，这是最后一个 `Arc`，所以 `DetectDrop` 应该会被释放</span></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(y);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(NUM_DROPS.<span class="title function_ invoke__">load</span>(Ordering::Relaxed), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果是 ok 的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">running 1 test</span><br><span class="line">test arc::tests::arc_should_work ... ok</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line">    arc::tests::arc_should_work</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure><h2 id="v1-实现-get-mut-获取可变引用">v1: 实现 get_mut 获取可变引用</h2><p>按照前面版本的实现，我们是不能为 <code>Arc&lt;T&gt;</code> 实现 <code>DerefMut</code> trait 的，因为我们不能无条件地提供 <code>&amp;mut T</code> 可变引用，因为它可能同时被其他的 <code>Arc&lt;T&gt;</code> 所访问中。</p><p>不过，当满足一定条件的时候，我们还是可以提供 <code>&amp;mut T</code> 可变引用的。具体来说，需要满足 2 个条件：</p><ol><li>使用 <code>&amp;mut Arc&lt;T&gt;</code> 保证当前 <code>Arc&lt;T&gt;</code> 只有一个地方在使用；</li><li>需要确保全局只有一个 <code>Arc&lt;T&gt;</code>。</li></ol><p>为了避免跟 <code>DerefMut</code> 混淆，我们将其声明为一个静态方法，并将 <code>Arc&lt;T&gt;</code> 作为参数，同时因为只有满足特定条件的情况下，才能返回 <code>&amp;mut T</code>，所以我们使用 <code>Option</code> 作为返回值。如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(arc: &amp;<span class="keyword">mut</span> Arc&lt;T&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> arc.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">        <span class="comment">// Safety: 没有其他地方可以访问数据，</span></span><br><span class="line">        <span class="comment">// 因为我们使用了 &amp;mut 独占引用，而且此时只有一个 `Arc`。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> arc.ptr.<span class="title function_ invoke__">as_mut</span>().data) &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>这里我们在确定只有一个 <code>Arc</code> 实例的时候，使用 <code>fetch(Acquire)</code> 来跟所有其他 <code>Arc</code> 执行 <code>drop()</code> 的 <code>fetch_sub(Release)</code> 建立 happens-before 关系。</p></li><li><p>因为此时 <code>ref_count=1</code>，说明仅有当前 <code>Arc</code> 这一个实例，而 <code>get_mut</code> 需要的又是独占引用，所以当前 <code>Arc</code> 不可能再被拿去做 <code>clone()</code> 操作，所以在这个情况下，是可以保证有且仅有一个 <code>Arc</code> 实例，所以我们是可以安全返回 <code>&amp;mut T</code> 的。</p></li><li><p>返回的 <code>&amp;mut T</code> 会隐式地借用参数 <code>&amp;mut Arc&lt;T&gt;</code> 的生命周期，而 Rust 不允许可变引用和只读引用交叉存在，所以当前仅剩的这个 <code>Arc</code>，直到 <code>&amp;mut T</code> 作用域结束之前，都是不可用的，所以在那之前，不会再被拿去执行 <code>clone()</code> 和 <code>Deref</code> 等操作，所以是安全的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_mut_should_be_safe</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = Arc::<span class="title function_ invoke__">get_mut</span>(&amp;<span class="keyword">mut</span> x).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">clone</span>(); <span class="comment">// &lt;---- cannot borrow `x` as immutable</span></span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面这个例子，就会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable</span><br><span class="line"><span class="meta prompt_">   --&gt; </span><span class="language-bash">src/arc.rs:117:17</span></span><br><span class="line">    |</span><br><span class="line">114 |         let v = Arc::get_mut(&amp;mut x).unwrap();</span><br><span class="line">    |                              ------ mutable borrow occurs here</span><br><span class="line">...</span><br><span class="line">117 |         let y = x.clone();</span><br><span class="line">    |                 ^ immutable borrow occurs here</span><br><span class="line">118 |         v.push(2);</span><br><span class="line">    |         - mutable borrow later used here</span><br></pre></td></tr></table></figure></li></ol><h2 id="v2-弱指针-Weak-T-解决循环引用">v2: 弱指针 Weak&lt;T&gt; 解决循环引用</h2><h3 id="循环引用问题分析">循环引用问题分析</h3><pre class="mermaid">graph TDA --> B;A --> C;</pre><p>引用计数在各种数据结构的表示中非常有用，如上图所示的树形结构，当释放 A 的时候，因为 B 和 C 不再被引用，所以也可以顺带释放了。</p><p>但是，如果 B 和 C 也持有对 A 的引用，即形成了循环引用，那按照我们之前的实现，A、B、C 都将永远不会被释放了，因为它们的引用计数永不为 0，哪怕它们三者均不再被使用。如下图所示：</p><pre class="mermaid">graph TDA <--> B;A <--> C;B -.-> A;C -.-> A;</pre><p>为了应对这种场景，Rust 的标准库中提出的解决方案是：<strong><code>Weak&lt;T&gt;</code>，也称弱指针</strong>。<strong><code>T</code> 可以在 <code>Arc&lt;T&gt;</code> 和 <code>Weak&lt;T&gt;</code> 之间共享，当所有的 <code>Arc&lt;T&gt;</code> 都失效的时候，<code>T</code> 被释放，无论此时是否有 <code>Weak&lt;T&gt;</code> 的存在。</strong></p><p>如下图所示，父节点对子节点使用的是强引用，确保了父节点存活的时候，子节点都存在。而子节点对父节点使用的是弱引用，只即保留了子节点回溯父节点的能力，也不会阻止父节点的释放。</p><p>当父节点被释放时，所有强引用计数归零，节点可以依次被释放。</p><pre class="mermaid">graph TDA -- Arc --> B;A -- Arc --> C;B -.->|Weak| A;C -.->|Weak| A;</pre><h3 id="数据结构-2">数据结构</h3><p>OK，做了这么多铺垫后，我们来思考一下现在的 <code>ArcData</code> 该如何调整。</p><ol><li>之前我们用 <code>ref_count</code> 做引用计数，它代表的都是强引用，现在我们需要记录弱引用数量的相关字段。</li><li>当只有弱引用的时候，<code>data</code> 就已经被释放了，我们需要使用 <code>None</code> 来表示这种情况，所以 <code>data</code> 应该是一个 <code>Option&lt;T&gt;</code> 类型。</li><li>当 <code>ArcData&lt;T&gt;</code> 被一个 <code>Arc</code> 和多个 <code>Weak</code> 共享时，释放最后一个 <code>Arc</code> 时，我们仅拥有 <code>&amp;ArcData&lt;T&gt;</code> 不可变引用，这个时候我们需要将其从 <code>Some(T)</code> 置为 <code>None</code>，即要在不可变引用上实现修改，这就涉及到了前几篇提到的：<strong>内部可变性</strong>。<strong>UnsafeCell</strong> 是 Rust 提供的一个内部可变性工具类型，它包装一个数据，使得即使在只有不可变引用的情况下也可以进行修改（当然需要在 <code>unsafe</code> 块中操作）。所以我们需要将 <code>data</code> 再用 <code>UnsafeCell</code> 包一层，以满足此场景的需求。</li></ol><p>综上，最新的 <code>ArcData</code> 定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// `Arc` 的数量，也即数据 T 的强引用计数。</span></span><br><span class="line">    data_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// `Arc` + `Weak` 的数量。</span></span><br><span class="line">    alloc_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// 数据，当只有 `Weak` 的时候，为 None。</span></span><br><span class="line">    data: UnsafeCell&lt;<span class="type">Option</span>&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要定义一个新结构 <code>Weak&lt;T&gt;</code> ，用来表示弱引用，假定这个时候，我们将维护 <code>ArcData</code> 存活的职责交给 <code>Weak&lt;T&gt;</code>，那就可以将 <code>ArcData</code> 转给 <code>Weak&lt;T&gt;</code> 持有，然后在 <code>Arc&lt;T&gt;</code> 中持有一个 <code>Weak&lt;T&gt;</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// `Arc` 的数量，也即数据 T 的强引用计数。</span></span><br><span class="line">    data_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// `Arc` + `Weak` 的数量。</span></span><br><span class="line">    alloc_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// 数据，当只有 `Weak` 的时候，为 None。</span></span><br><span class="line">    data: UnsafeCell&lt;<span class="type">Option</span>&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    weak: Weak&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Arc &#123;</span><br><span class="line">            weak: Weak &#123;</span><br><span class="line">                ptr: NonNull::<span class="title function_ invoke__">from</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(ArcData &#123;</span><br><span class="line">                    alloc_ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                    data_ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                    data: UnsafeCell::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Some</span>(data)),</span><br><span class="line">                &#125;))),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Weak&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ref</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ptr</span> = <span class="keyword">self</span>.weak.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>();</span><br><span class="line">        <span class="comment">// Safety: 这个时候还有 Arc 存在，所以 data 肯定是生效的。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*ptr).<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，除了数据结构之外，我们做了 3 点调整：</p><ol><li>只需要为 <code>Weak&lt;T&gt;</code> 实现 <code>Sync</code> 和 <code>Send</code> trait，这个时候 <code>Arc&lt;T&gt;</code> 就会被自动实现这 2 个 triat。</li><li><code>data(&amp;self)</code> 辅助函数，移到了 <code>Weak&lt;T&gt;</code> 身上。</li><li><code>Arc&lt;T&gt;</code> 要从 <code>Deref</code> 获取 <code>&amp;T</code>，需要先经过一道 <code>Weak&lt;T&gt;</code>。</li></ol><pre class="mermaid">graph LR    subgraph Stack ["栈内存 Stack"]        ArcStruct["Arc&lt;T&gt;<br/>weak: Weak&lt;T&gt;"]        WeakStruct["Weak&lt;T&gt;<br/>ptr: NonNull&lt;ArcData&lt;T&gt;&gt;"]    end    subgraph Heap ["堆内存 Heap"]        ArcDataStruct["ArcData&lt;T&gt;<br/>data_ref_count: AtomicUsize(1)<br/>alloc_ref_count: AtomicUsize(1)<br/>data: UnsafeCell&lt;Option&lt;T&gt;&gt;"]    end    ArcStruct -->|包含| WeakStruct    WeakStruct -->|指向| ArcDataStruct    classDef stackStyle fill:#e1f5fe,stroke:#01579b,stroke-width:2px    classDef heapStyle fill:#f3e5f5,stroke:#4a148c,stroke-width:2px    classDef processStyle fill:#fff3e0,stroke:#e65100,stroke-width:2px    classDef refStyle fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px    class ArcStruct,WeakStruct stackStyle    class ArcDataStruct heapStyle    class Step1,Step2,Step3,Step4,Step5 processStyle    class DataRef,AllocRef,DataContent refStyle</pre><h3 id="维护引用计数-2">维护引用计数</h3><p>现在重点来了，我们需要来思考 <code>Weak&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code> 的 <code>Clone</code> 和 <code>Drop</code> 该如何实现。其实重点就是该<strong>如何管理 <code>alloc_ref_count</code> 和 <code>data_ref_count</code> 的计数</strong>。</p><p>再次明确下我们的定义：</p><ul><li><code>data_ref_count</code>: 代表的是强引用 <code>Arc&lt;T&gt;</code> 的数量。</li><li><code>alloc_ref_count</code>: 代表的是 <code>Arc&lt;T&gt;</code> + <code>Weak&lt;T&gt;</code> 的数量。</li></ul><p>因此：</p><ul><li>Clone:<ul><li>当 <code>Weak&lt;T&gt;</code> 拷贝时，仅增加了弱引用的数量，所以我们只需对 <code>alloc_ref_count</code> 进行自增。</li><li>当 <code>Arc&lt;T&gt;</code> 拷贝时，不仅需要拷贝内部的 <code>Weak&lt;T&gt;</code>，还增加了强引用的数量，所以我们还需要对 <code>data_ref_count</code> 进行自增。</li></ul></li><li>Drop:<ul><li>当 <code>Arc&lt;T&gt;</code> 被释放时，不仅释放了其内部的 <code>Weak&lt;T&gt;</code>，还减少了一个强引用，所以需要对 <code>data_ref_count</code> 进行自减。另外，如果是最后一个 <code>Arc&lt;T&gt;</code> 被释放，我们需要将 <code>ArcData&lt;T&gt;.data</code> 置为 <code>None</code>。</li><li>当 <code>Weak&lt;T&gt;</code> 被释放时，我们仅需减少弱引用的数量，即对 <code>alloc_ref_count</code> 进行自减。另外，当最后一个 <code>Weak&lt;T&gt;</code> 被释放时（此时肯定也没有 <code>Arc&lt;T&gt;</code> 了），我们还需要负责释放 <code>ArcData&lt;T&gt;</code> 。</li></ul></li></ul><p>综上，我们的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed) &gt; <span class="type">usize</span>::MAX / <span class="number">2</span> &#123;</span><br><span class="line">            std::process::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">weak</span> = <span class="keyword">self</span>.weak.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">if</span> weak.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed) &gt; <span class="type">usize</span>::MAX / <span class="number">2</span> &#123;</span><br><span class="line">            std::process::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Arc &#123; weak &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="comment">// Safety: 最后一个 Weak&lt;T&gt; 已经被释放了。</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span></span><br><span class="line">            .weak</span><br><span class="line">            .<span class="title function_ invoke__">data</span>()</span><br><span class="line">            .data_ref_count</span><br><span class="line">            .<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release)</span><br><span class="line">            == <span class="number">1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">ptr</span> = <span class="keyword">self</span>.weak.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>();</span><br><span class="line">            <span class="comment">// Safety: data_ref_count 已经为 0 了，没有地方在使用 data 了。</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123; (*ptr) = <span class="literal">None</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里考虑到实际场景中的内存限制，我们对引用计数进行了简单的限制，当其超过 <code>usize::Max/2</code> 的时候，就执行 <code>std::process:abort()</code> 让整个进程崩溃。</p></blockquote><h3 id="get-mut">get_mut()</h3><p>接下来我们来考虑下 <code>get_mut(arc: &amp;mut Arc&lt;T&gt;)</code> 该如何修改。什么时候可以返回 <code>&amp;mut T</code>，很明显，<strong>当且仅当只有一个 <code>Arc&lt;T&gt;</code> 的时候才可以</strong>。</p><p>故 <code>get_mut</code> 的实现修改如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(arc: &amp;<span class="keyword">mut</span> Arc&lt;T&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> arc.weak.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">        <span class="comment">// Safety: 这个时候没有其他地方能使用数据，因为只有一个 `Arc`，</span></span><br><span class="line">        <span class="comment">// 同时我们拥有仅存的这个 `Arc` 的不可变引用。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">arcdata</span> = <span class="keyword">unsafe</span> &#123; arc.weak.ptr.<span class="title function_ invoke__">as_mut</span>() &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">option</span> = arcdata.data.<span class="title function_ invoke__">get_mut</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = option.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们执行之前的 <code>arc_should_work</code> 测试用例，可以发现是顺利通过的。</p><h3 id="dowgrade">dowgrade()</h3><p>回顾下面这张图，为了提供 A 的 <code>Weak&lt;T&gt;</code> 指针，我们需要给 <code>Arc&lt;T&gt;</code> 提供一个 <code>downgrade()</code> 方法，用于将强引用降为弱引用，这是必然可以成功的。同时，当我们也可以为 <code>Weak&lt;T&gt;</code> 提供一个 <code>upgrade()</code> 方法，用于持有弱引用的情况下可以尝试访问数据，当然这未必能成功。</p><pre class="mermaid">graph TDA -- Arc --> B;A -- Arc --> C;B -.->|Weak| A;C -.->|Weak| A;</pre><p><code>downgrade()</code> 比较简单，我们直接 <code>clone()</code> 一个 <code>Weak&lt;T&gt;</code> 就可以了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">downgrade</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Weak&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.weak.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="upgrade">upgrade()</h3><p><code>upgrade()</code> 就比较复杂了，只有当存在 <code>Arc</code> 的时候，<code>data</code> 才没被释放，这个时候，才能返回升级后的 <code>Arc&lt;T&gt;</code>，即要求 <code>data_ref_count&gt;0</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Weak&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">upgrade</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;T&gt;&gt; &#123;</span><br><span class="line">      <span class="comment">// 获取 data_ref_count 的值</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">          <span class="comment">// 如果等于 0，则说明 data 已经被释放了，直接返回 None</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert!</span>(n &lt; <span class="type">usize</span>::MAX);</span><br><span class="line">          <span class="comment">// 不为 0 的话，data_ref_count 尝试进行 +1，失败了就重试</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">compare_exchange_weak</span>(</span><br><span class="line">                n,</span><br><span class="line">                n + <span class="number">1</span>,</span><br><span class="line">                Ordering::Relaxed,</span><br><span class="line">                Ordering::Relaxed,</span><br><span class="line">            ) &#123;</span><br><span class="line">                n = e;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 成功了，则 clone weak 即可（执行 alloc_ref_count++）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(Arc &#123; weak: <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>() &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来写一下测试用例，验证使用了 <code>Weak&lt;T&gt;</code> 后，我们的资源能否正确释放。在这之前，我们先写一个非 <code>Weak&lt;T&gt;</code> 版本的，看看资源是否真的没有被释放：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">no_weak_should_not_free_resource</span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> NUM_DROPS: AtomicUsize = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="comment">// 使用 RefCell，利用其内部可变性，方便我们建立父子关系</span></span><br><span class="line">        child: RefCell&lt;<span class="type">Vec</span>&lt;Arc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">        parent: RefCell&lt;<span class="type">Option</span>&lt;Arc&lt;Node&gt;&gt;&gt;, <span class="comment">// &lt;---- 这里持有的是强引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">            NUM_DROPS.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span> &#123;</span><br><span class="line">                child: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">                parent: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 建立父子关系</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_child</span>(parent: &amp;Arc&lt;Node&gt;, child: Arc&lt;Node&gt;) &#123;</span><br><span class="line">            *child.parent.<span class="title function_ invoke__">borrow_mut</span>() = <span class="title function_ invoke__">Some</span>(parent.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">            parent.child.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 限定作用域，离开作用域后，root/child1/child2 正常情况应该被释放。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">root</span> = Arc::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">new</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">child1</span> = Arc::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">new</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">child2</span> = Arc::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">new</span>());</span><br><span class="line"></span><br><span class="line">        Node::<span class="title function_ invoke__">add_child</span>(&amp;root, child1);</span><br><span class="line">        Node::<span class="title function_ invoke__">add_child</span>(&amp;root, child2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_ne!</span>(NUM_DROPS.<span class="title function_ invoke__">load</span>(Ordering::Relaxed), <span class="number">3</span>); <span class="comment">// 不为 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述用例后，我们可以发现 <code>NUM_DROPS</code> 还是 0，即 <code>root/child1/child2</code> 均没有被释放资源。</p><p>你可以将 <code>parent</code> 的引用修改为弱引用，然后再重新执行测试用例，就会发现 <code>root/child1/child2</code> 的资源都被正确释放了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    child: RefCell&lt;<span class="type">Vec</span>&lt;Arc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">    parent: RefCell&lt;<span class="type">Option</span>&lt;Weak&lt;Node&gt;&gt;&gt;, <span class="comment">// &lt;---- 这里持有的是弱引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            child: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">            parent: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立父子关系</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_child</span>(parent: &amp;Arc&lt;Node&gt;, child: Arc&lt;Node&gt;) &#123;</span><br><span class="line">        *child.parent.<span class="title function_ invoke__">borrow_mut</span>() = <span class="title function_ invoke__">Some</span>(parent.<span class="title function_ invoke__">downgrade</span>()); <span class="comment">// &lt;---- 使用 downgrade 转为弱引用</span></span><br><span class="line">        parent.child.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="v3-分离强弱引用，避免无用消耗">v3: 分离强弱引用，避免无用消耗</h2><p>上个版本我们通过引入了弱引用 <code>Weak&lt;T&gt;</code>，成功解决了循环引用的问题，这是个非常大的进步！</p><p>不过我们仍然有进一步优化的空间，可以观察到，<code>Arc&lt;T&gt;</code> 的每次拷贝，都会伴随一次拷贝 <code>Weak&lt;T&gt;</code>，但是，很多时候，我们其实没有循环引用关系的，也即我们并不是每一次都需要 <code>Weak&lt;T&gt;</code>，所以上个版本的实现，其实是有很多的浪费的。</p><h3 id="数据结构-3">数据结构</h3><p>所以我们可以考虑将 <code>Weak&lt;T&gt;</code> 从 <code>Arc&lt;T&gt;</code> 中分离出来：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 调整 Arc 的构造函数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Arc &#123;</span><br><span class="line">            ptr: NonNull::<span class="title function_ invoke__">from</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(ArcData &#123;</span><br><span class="line">                data_ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                alloc_ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                data: UnsafeCell::<span class="title function_ invoke__">new</span>(ManuallyDrop::<span class="title function_ invoke__">new</span>(data)),</span><br><span class="line">            &#125;))),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Arc 已经没有 Weak 了，这个时候，时候给它补一个 data() 辅助函数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ref</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相应地调整 Deref</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*<span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们需要对 <code>ArcData&lt;T&gt;</code> 结构中的引用技术进行重新定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// `Arc` 的数量</span></span><br><span class="line">    data_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// `Weak` 的数量，当存在 `Arc` 时，额外加 1</span></span><br><span class="line">    alloc_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// 数据，当只有 `Weak` 的时候，释放它。</span></span><br><span class="line">    data: UnsafeCell&lt;ManuallyDrop&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们总共做了 3 个重要的调整：</p><ol><li><p><code>Arc&lt;T&gt;</code> 不再包含 <code>Weak&lt;T&gt;</code>，而是各自独立，不过它们之前会共享底层的 <code>ArcData&lt;T&gt;</code>。</p></li><li><p><code>alloc_ref_count</code> 的语义，从**“Arc + Weak 的数量**”，变成&quot;<strong>Weak 的数量，当存在 Arc 时，额外加 1</strong>&quot;。</p><blockquote><p>换言之，对于所有的 <code>Arc&lt;T&gt;</code>，都共有一个隐式的 <code>Weak&lt;T&gt;</code> ，当释放最后一个 <code>Arc&lt;T&gt;</code> 的时候，这个隐式的 <code>Weak&lt;T&gt;</code> 也需要被释放（本质是执行 alloc_ref_count 减一，同时如果没有其他的 <code>Weak&lt;T&gt;</code>，需要顺带释放 <code>ArcData&lt;T&gt;</code>。</p></blockquote></li><li><p><code>data</code> 字段，我们使用 <code>ManuallyDrop</code> 来替代 <code>Option</code>，我们之前使用 <code>None</code> 来表示数据已经被释放，但其实 <code>data_ref_count</code> 已经能表达这层意思了，所以我们这里使用 <code>ManuallyDrop</code> 来进一步节省内存资源。</p></li></ol><blockquote><p><code>std::mem::ManuallyDrop&lt;T&gt;</code> 是一个零成本（zero-cost）包装器。它不改变 <code>T</code> 的布局，也不会产生额外的字节，在一些情况下，可以比 <code>Option&lt;T&gt;</code> 少一些标记位和字节对齐所占据的额外空间。具体可参考：<strong>附录 2. ManuallyDrop&lt;T&gt;</strong>。</p></blockquote><pre class="mermaid">graph TB    subgraph Stack ["栈内存 Stack"]        ArcStruct["Arc&lt;T&gt;<br/>ptr: NonNull&lt;ArcData&lt;T&gt;&gt;"]        WeakStruct["Weak&lt;T&gt;<br/>ptr: NonNull&lt;ArcData&lt;T&gt;&gt;"]    end    subgraph Heap ["堆内存 Heap"]        ArcDataStruct["ArcData&lt;T&gt;<br/>data_ref_count<br/>alloc_ref_count<br/>data"]    end    ArcStruct -->|直接指向| ArcDataStruct    WeakStruct -->|直接指向| ArcDataStruct    classDef stackStyle fill:#e1f5fe,stroke:#01579b,stroke-width:2px    classDef heapStyle fill:#f3e5f5,stroke:#4a148c,stroke-width:2px    class ArcStruct,WeakStruct stackStyle    class ArcDataStruct heapStyle</pre><h3 id="维护引用计数-3">维护引用计数</h3><p>修改了引用计数的语义后，我们需要重新思考如何管理引用计数。</p><ul><li>Clone:<ul><li>当 <code>Weak&lt;T&gt;</code> 拷贝时，仅增加了弱引用的数量，所以我们依旧只需对 <code>alloc_ref_count</code> 进行自增。</li><li>当 <code>Arc&lt;T&gt;</code> 拷贝时，这个时候，我们就只需要对 <code>data_ref_count</code> 进行自增即可。</li></ul></li><li>Drop:<ul><li>当 <code>Arc&lt;T&gt;</code> 被释放时，我们需要对 <code>data_ref_count</code> 进行自减。另外，如果是最后一个 <code>Arc&lt;T&gt;</code> 被释放，我们需要释放 <code>data</code> ，同时，我们还需要释放那个代表所有 <code>Arc</code> 的隐式 <code>Weak</code>。</li><li>当 <code>Weak&lt;T&gt;</code> 被释放时，我们仅需减少弱引用的数量，即对 <code>alloc_ref_count</code> 进行自减。另外，当最后一个 <code>Weak&lt;T&gt;</code> 被释放时，我们还需要负责释放 <code>ArcData&lt;T&gt;</code> 。</li></ul></li></ul><p>具体的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed) &gt; <span class="type">usize</span>::MAX / <span class="number">2</span> &#123;</span><br><span class="line">            std::process::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed) &gt; <span class="type">usize</span>::MAX / <span class="number">2</span> &#123;</span><br><span class="line">            std::process::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="comment">// 思考下这里为什么要用 Release？后面我们会揭晓！</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="comment">// Safety: 最后一个 Weak&lt;T&gt; 已经被释放了。</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="comment">// 释放 ArcData&lt;T&gt;</span></span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="comment">// 最后一个 `Arc` 被释放，需要做 2 件事情：</span></span><br><span class="line">            <span class="comment">// 1. 释放 ArcData.data</span></span><br><span class="line">            <span class="comment">// 2. 释放那个代表所有 `Arc` 的隐式 `Weak`</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                ManuallyDrop::<span class="title function_ invoke__">drop</span>(&amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在 `Weak` 那边 `drop()` 的时候：</span></span><br><span class="line">            <span class="comment">// 1. 会执行 alloc_ref_count--;</span></span><br><span class="line">            <span class="comment">// 2. 如果刚好是最后一个 `Weak`，那会顺带销毁 `AraData`。</span></span><br><span class="line">            <span class="title function_ invoke__">drop</span>(Weak &#123; ptr: <span class="keyword">self</span>.ptr &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个隐式 <code>Weak&lt;T&gt;</code>，如果你一时无法很好地 Get 到那个点，可以尝试手动写写整个实现的过程，相信多走几遍流程，你会有那种茅塞顿开的感觉！</p><pre class="mermaid">flowchart TD    subgraph Clone["Clone 操作"]        WeakClone["Weak&lt;T&gt;::clone()"]        ArcClone["Arc&lt;T&gt;::clone()"]        WeakClone --> WeakInc["alloc_ref_count.fetch_add(1)"]        ArcClone --> ArcInc["data_ref_count.fetch_add(1)"]        WeakInc --> WeakCheck{"计数 > usize::MAX/2?"}        ArcInc --> ArcCheck{"计数 > usize::MAX/2?"}        WeakCheck -->|是| Abort1["std::process::abort()"]        ArcCheck -->|是| Abort2["std::process::abort()"]        WeakCheck -->|否| WeakNew["返回新的 Weak&lt;T&gt;"]        ArcCheck -->|否| ArcNew["返回新的 Arc&lt;T&gt;"]    end    subgraph Drop["Drop 操作"]        WeakDrop["Weak&lt;T&gt;::drop()"]        ArcDrop["Arc&lt;T&gt;::drop()"]        WeakDrop --> WeakDec["alloc_ref_count.fetch_sub(1, Release)"]        ArcDrop --> ArcDec["data_ref_count.fetch_sub(1, Release)"]        WeakDec --> WeakDropCheck{"返回值 == 1?<br/>最后一个 Weak?"}        ArcDec --> ArcDropCheck{"返回值 == 1?<br/>最后一个 Arc?"}        WeakDropCheck -->|是| WeakFence["fence(Acquire)"]        WeakDropCheck -->|否| WeakEnd["结束"]        ArcDropCheck -->|是| ArcFence["fence(Acquire)"]        ArcDropCheck -->|否| ArcEnd["结束"]        WeakFence --> WeakFree["释放 ArcData&lt;T&gt;<br/>Box::from_raw(ptr)"]        ArcFence --> ArcDataFree["释放 data<br/>ManuallyDrop::drop()"]        ArcDataFree --> ImplicitWeak["释放隐式 Weak<br/>drop(Weak { ptr })"]        ImplicitWeak --> WeakDrop    end    subgraph Memory["内存释放顺序"]        Step1["① Arc 释放 data 内容"]        Step2["② Arc 释放隐式 Weak"]        Step3["③ Weak 释放 ArcData 结构"]        Step1 --> Step2        Step2 --> Step3    end    classDef cloneStyle fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px    classDef dropStyle fill:#ffebee,stroke:#c62828,stroke-width:2px    classDef memStyle fill:#fff3e0,stroke:#e65100,stroke-width:2px    classDef criticalStyle fill:#fce4ec,stroke:#880e4f,stroke-width:3px    class WeakClone,ArcClone,WeakInc,ArcInc,WeakNew,ArcNew cloneStyle    class WeakDrop,ArcDrop,WeakDec,ArcDec,WeakEnd,ArcEnd dropStyle    class WeakFree,ArcDataFree,ImplicitWeak criticalStyle    class Step1,Step2,Step3 memStyle</pre><p>至此，我们重新运行之前的测试用例 <code>arc_should_work()</code>，可以发现的成功通过的。</p><p>下面我们继续来调整 <code>get_mut</code>、<code>downgrade()</code> 和 <code>upgrade()</code>。</p><h3 id="upgrade-2">upgrade()</h3><p><code>upgrade()</code> 比较简单，它的规则还是不变，只有当存在 <code>Arc&lt;T&gt;</code> 时，即 <code>data_ref_count&gt;0</code> 时，才能升级成功：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Weak&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">upgrade</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;T&gt;&gt; &#123;</span><br><span class="line">      <span class="comment">// 获取 data_ref_count 的值。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">          <span class="comment">// 如果为 0，表示已经没有 Arc 了，升级失败。</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert!</span>(n &lt; <span class="type">usize</span>::MAX);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 存在 Arc，则对 data_ref_count 尝试进行 CAS 加 1。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">compare_exchange_weak</span>(</span><br><span class="line">                n,</span><br><span class="line">                n + <span class="number">1</span>,</span><br><span class="line">                Ordering::Relaxed,</span><br><span class="line">                Ordering::Relaxed,</span><br><span class="line">            ) &#123;</span><br><span class="line">              <span class="comment">// CAS 失败，则重试。</span></span><br><span class="line">                n = e;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// CAS 成功，则返回升级后的 Arc。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(Arc &#123; ptr: <span class="keyword">self</span>.ptr &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-mut-2">get_mut()</h3><p>接一下我们看 <code>get_mut</code>，规则也是不变：<strong>当前仅当只有一个 <code>Arc&lt;T&gt;</code>，且不存在 <code>Weak&lt;T&gt;</code> 时，才可以返回可变引用。</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个条件</span></span><br><span class="line"><span class="comment">// 1. 没有 Weak&lt;T&gt;</span></span><br><span class="line"><span class="comment">// 2. 没有其他的 Arc&lt;T&gt;</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(arc: &amp;<span class="keyword">mut</span> Arc&lt;T&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123;</span><br><span class="line">    <span class="comment">// 将 alloc_ref_count 从 1 置为 usize::Max。</span></span><br><span class="line">    <span class="comment">//  如果失败：说明之前不是 1，即存在其他的 Weak&lt;T&gt;，无法获取 &amp;mut T， None</span></span><br><span class="line">    <span class="comment">//  如果成功：说明当前没有 Weak&lt;T&gt;，第一步校验通过。</span></span><br><span class="line">    <span class="keyword">if</span> arc</span><br><span class="line">        .<span class="title function_ invoke__">data</span>()</span><br><span class="line">        .alloc_ref_count</span><br><span class="line">        .<span class="title function_ invoke__">compare_exchange</span>(<span class="number">1</span>, <span class="type">usize</span>::MAX, Ordering::Acquire, Ordering::Relaxed)</span><br><span class="line">        .<span class="title function_ invoke__">is_err</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_unique</span> = arc.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 alloc_ref_count</span></span><br><span class="line">    arc.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">store</span>(<span class="number">1</span>, Ordering::Release);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在其他的 Arc，则无法获取 &amp;mut T，返回 None</span></span><br><span class="line">    <span class="keyword">if</span> !is_unique &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在其他的 Arc，返回 &amp;mut T</span></span><br><span class="line">    <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> *arc.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的逻辑就不赘述了，但是这里有 <strong>3 个</strong>原子操作的内存顺序我们需要讨论一下！</p><p>分别是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Weak&lt;T&gt; 的数量并暂时锁定</span></span><br><span class="line">arc</span><br><span class="line">  .<span class="title function_ invoke__">data</span>()</span><br><span class="line">  .alloc_ref_count</span><br><span class="line">  .<span class="title function_ invoke__">compare_exchange</span>(<span class="number">1</span>, <span class="type">usize</span>::MAX, Ordering::Acquire, Ordering::Relaxed)</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Arc&lt;T&gt; 的数量</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">is_unique</span> = arc.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line"><span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放 alloc_ref_count</span></span><br><span class="line">arc.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">store</span>(<span class="number">1</span>, Ordering::Release);</span><br></pre></td></tr></table></figure><hr><p>首先看第 1 个，我们要判断当前是否已经没有 <code>Weak&lt;T&gt;</code> 了，所以我们需要保证看到之前所有 <code>drop(Weak&lt;T&gt;)</code> 的写入操作，所以这里需要建立起一个 happens-before，因此我们之前为 <code>Weak&lt;T&gt;</code> 实现 <code>Drop</code> trait 的时候，使用的是 <code>Release</code>，而这里，需要使用 <code>Acquire</code> 来进行配对，建立 happens-before。</p><hr><p>然后看第 2 个，这里我们要判断是否仅有一个 <code>Arc&lt;T&gt;</code>，所以我们需要保证看到之前所有 <code>drop&lt;Arc&lt;T&gt;</code> 的写入操作，因此我们之前为 <code>Arc&lt;T&gt;</code> 实现 <code>Drop</code> trait 的时候，使用的是 <code>Release</code>。但是在这里，我们仅需在仅剩 1 个 <code>Arc</code> 的时候，才有必要建立 happens-before，所以当 <code>is_unique=true</code> 时，我们补一个 <code>fence(Acquire)</code> 屏障，来建立跟 <code>drop(Arc&lt;T&gt;)</code> 的 happens-before。</p><hr><p>在分析第 3 个之前，我们需要来尝试挖一下当前 <code>get_mut</code> 的漏洞！相信有部分读者在看到上述实现后，跟笔者一样，会有一个疑惑：<strong><font color="red">上述 2 个条件的检查，并不是原子的，这样的检查还安全可靠吗？</font></strong></p><p>比如说：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(arc: &amp;<span class="keyword">mut</span> Arc&lt;T&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> arc</span><br><span class="line">        .<span class="title function_ invoke__">data</span>()</span><br><span class="line">        .alloc_ref_count</span><br><span class="line">        .<span class="title function_ invoke__">compare_exchange</span>(<span class="number">1</span>, <span class="type">usize</span>::MAX, Ordering::Acquire, Ordering::Relaxed)</span><br><span class="line">        .<span class="title function_ invoke__">is_err</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;------- 在这个间隙：另外一个 Arc downgrade() -&gt; Weak，然后 drop(Arc)</span></span><br><span class="line">    <span class="comment">// &lt;------- 那它也是检查通过的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_unique</span> = arc.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="number">1</span>;</span><br><span class="line">    arc.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">store</span>(<span class="number">1</span>, Ordering::Release);</span><br><span class="line">    <span class="keyword">if</span> !is_unique &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> *arc.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子中：</p><ol><li>假设我们已经通过了第一个检查；</li><li>在进行第二个检查之前的这个间隙中，存在另外一个 <code>Arc&lt;T&gt;</code>；</li><li>然后它通过 <code>downgrade()</code> 生成了一个 <code>Weak&lt;T&gt;</code>；</li><li>然后再 <code>drop(Arc&lt;T&gt;)</code>；</li><li>这个时候我们再检查 <code>Arc&lt;T&gt;</code> 的时候，会发现只有 1 个，检查就通过了。但是其实这个时候，存在了其他的 <code>Weak&lt;T&gt;</code>，所以是有问题的！</li></ol><pre class="mermaid">sequenceDiagram    participant A as T1 :get_mut()    participant B as T2 :downgrade()+drop(Arc)    participant C as ArcData    A->>C: CAS alloc_ref 1→MAX ✔    Note over A,B: 非原子窗口    B->>C: clone Weak <br> alloc_ref++ (Relaxed)    B->>C: drop(Arc) <br> fetch_sub data_ref (Release)    A->>C: load data_ref ==1 ✔    A->>C: store alloc_ref MAX→1 (Release)    A-->>A: fence(Acquire) → 返回 &mut T（已失效）</pre><p>所以：**<font color="green">我们不能让  <code>downgrade()</code>  在这个间隙中成功执行！</font>**这也是我们在前面将 <code>alloc_ref_count</code> 置为 <code>usize::Max</code>（上锁）的原因，在后面的 <code>downgrade()</code> 中，我们肯定要检查这个值，如果 <code>alloc_ref_count=usize::Max</code>，就不能 <code>downgrade()</code> 成功，直到 <code>alloc_ref_store(1, _)</code> 的时候，才能 <code>downgrade()</code> 成功。不过这个时候已经晚了！如果是这样，那 <code>is_unique</code> 肯定就不为 <code>true</code>，所以会返回 <code>None</code>，这个时候，我们不会返回 <code>&amp;mut T</code>，所以，危机就解除了！</p><h3 id="downgrade">downgrade()</h3><p>我们先来看一下 <code>downgrade()</code> 的实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">downgrade</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Weak&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取 Weak 的引用计数</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="comment">// 如果为 usize::MAX，说明已经被锁住了，这个时候自旋重试！</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="type">usize</span>::MAX &#123;</span><br><span class="line">                std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">                n = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert!</span>(n &lt; <span class="type">usize</span>::MAX - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// alloc_ref_count 没被锁住，尝试进行 +1 操作。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">compare_exchange_weak</span>(</span><br><span class="line">                n,</span><br><span class="line">                n + <span class="number">1</span>,</span><br><span class="line">                Ordering::Acquire,</span><br><span class="line">                Ordering::Relaxed,</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// +1 失败，重试。</span></span><br><span class="line">                n = e;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// +1 成功，表示降级成功，返回 Weak。</span></span><br><span class="line">            <span class="keyword">return</span> Weak &#123; ptr: <span class="keyword">self</span>.ptr &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>downgrade()</code> 的实现中，我们跟 <code>get_mut</code> 遥相呼应：</p><ol><li><p>如果 <code>alloc_ref_count=usize::MAX</code>，说明被锁住，这个时候需要自旋等待并重试。</p><blockquote><p><code>std::hint::spin_loop() </code>会向 CPU 发送特定指令（如 x86 的 pause 或 ARM 的 yield），提示当前处于忙等待状态，有利于优化 CPU 行为。</p></blockquote></li><li><p>如果 <code>alloc_ref_count</code> 没被锁住，我们尝试进行 CAS，这里成功的时候使用的 <code>Acquire</code> ，为什么呢？这是为了跟前面还未讨论的<strong>第 3 个原子操作</strong>建立 happens-before！</p></li></ol><p>现在我们终于可以来解开这第 3 个原子操作的原子顺序谜团了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放 alloc_ref_count</span></span><br><span class="line">arc.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">store</span>(<span class="number">1</span>, Ordering::Release);</span><br></pre></td></tr></table></figure><p>这里我们必须保证跟 <code>download()</code> 的 <code>compare_exchange(_,_,Acquire,_)</code> 建立起 happens-before 关系，即将 <code>alloc_ref_count</code> 置为 1 的结果必须被 <code>downgrade()</code> 所在的线程看到。不然的话，这里 <code>compare_exchange</code> 成功了，将 <code>alloc_ref_count</code> 置为 2 了，但是 <code>get_mut</code> 又将其置为 1 了，就乱套了！</p><h3 id="完整代码-2">完整代码</h3><p>到这里我们终于是完成了 v3 版本的优化工作了，真棒！介于篇幅已经够长了，这里就不再贴出完整的代码了，感兴趣的读者可以参阅：<a href="https://github.com/hedon-rust-road/conutils/blob/main/src/arc.rs">hedon-rust-road/conutils/arc</a>。</p><h2 id="浅探标准库的-Arc-T">浅探标准库的 Arc&lt;T&gt;</h2><p>在最后，我们来看一下标准库的 <code>Arc&lt;T&gt;</code> 是如何实现的，看文章开头说的<strong>实现一个可以媲美标准库的 <code>Arc&lt;T&gt;</code></strong> 是不是在吹牛！</p><p>标准库（rustc 1.87.0）的 <code>Arc&lt;T&gt;</code> 位于 <a href="https://github.com/rust-lang/rust/blob/1.87.0/library/alloc/src/sync.rs">sync.rs</a> 文件中，我们来看下它的数据结构定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;</span><br><span class="line">    T: ?<span class="built_in">Sized</span>,</span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="string">&quot;allocator_api&quot;</span>, issue = <span class="string">&quot;32838&quot;</span>)]</span> A: Allocator = Global,</span><br><span class="line">&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcInner&lt;T&gt;&gt;,</span><br><span class="line">    phantom: PhantomData&lt;ArcInner&lt;T&gt;&gt;,</span><br><span class="line">    alloc: A,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weak</span>&lt;</span><br><span class="line">    T: ?<span class="built_in">Sized</span>,</span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="string">&quot;allocator_api&quot;</span>, issue = <span class="string">&quot;32838&quot;</span>)]</span> A: Allocator = Global,</span><br><span class="line">&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcInner&lt;T&gt;&gt;,</span><br><span class="line">    alloc: A,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他一些莫名其妙的标记咱就不管了，映入眼帘可以看到一个 <code>ArcInner</code>，这不就是咱的 <code>ArcData</code> 吗！点进去看下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcInner</span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    strong: atomic::AtomicUsize,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the value usize::MAX acts as a sentinel for temporarily &quot;locking&quot; the</span></span><br><span class="line">    <span class="comment">// ability to upgrade weak pointers or downgrade strong ones; this is used</span></span><br><span class="line">    <span class="comment">// to avoid races in `make_mut` and `get_mut`.</span></span><br><span class="line">    weak: atomic::AtomicUsize,</span><br><span class="line"></span><br><span class="line">    data: T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好家伙！这不就是咱的 <code>ArcData</code> !</p><ul><li><code>strong</code>: 对应我们的 <code>data_ref_count</code></li><li><code>weak</code>: 对应我们的 <code>alloc_ref_count</code></li></ul><p><code>weak</code> 字段上面的注释也揭示了其核心逻辑跟咱是高度一致的！</p><p>我们简单看下最重要的 <code>Drop</code> 和 <code>Clone</code> 的实现，因为这涉及到引用计数的维护：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_REFCOUNT: <span class="type">usize</span> = (<span class="type">isize</span>::MAX) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arc: Clone</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>, A: Allocator + <span class="built_in">Clone</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T, A&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Arc&lt;T, A&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">old_size</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">inner</span>().strong.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed); <span class="comment">// fetch_add</span></span><br><span class="line">        <span class="keyword">if</span> old_size &gt; MAX_REFCOUNT &#123; <span class="comment">// 溢出保护</span></span><br><span class="line">            <span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">Self</span>::<span class="title function_ invoke__">from_inner_in</span>(<span class="keyword">self</span>.ptr, <span class="keyword">self</span>.alloc.<span class="title function_ invoke__">clone</span>()) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arc: Drop</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;<span class="meta">#[may_dangle]</span> T: ?<span class="built_in">Sized</span>, A: Allocator&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T, A&gt; &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// fetch_sub release 强引用</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">inner</span>().strong.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Release) != <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 最后一个 Arc 释放的时候，补一个 fence(Acquire)，</span></span><br><span class="line">      <span class="comment">// 与前面所有的 release 建立 happens-before。</span></span><br><span class="line">        acquire!(<span class="keyword">self</span>.<span class="title function_ invoke__">inner</span>().strong);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最后一个 Arc 释放的时候，释放 ArcInner 里面的 data</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">drop_slow</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Weak: Clone</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>, A: Allocator + <span class="built_in">Clone</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T, A&gt; &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Weak&lt;T, A&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(inner) = <span class="keyword">self</span>.<span class="title function_ invoke__">inner</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">old_size</span> = inner.weak.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed); <span class="comment">// fetch_add 弱引用数量</span></span><br><span class="line">            <span class="keyword">if</span> old_size &gt; MAX_REFCOUNT &#123; <span class="comment">// 溢出保护</span></span><br><span class="line">                <span class="title function_ invoke__">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回 Weak</span></span><br><span class="line">        Weak &#123; ptr: <span class="keyword">self</span>.ptr, alloc: <span class="keyword">self</span>.alloc.<span class="title function_ invoke__">clone</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Weak: Drop</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;<span class="meta">#[may_dangle]</span> T: ?<span class="built_in">Sized</span>, A: Allocator&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T, A&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inner</span> = <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(inner) = <span class="keyword">self</span>.<span class="title function_ invoke__">inner</span>() &#123; inner &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> inner.weak.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Release) == <span class="number">1</span> &#123; <span class="comment">// fetch_sub release 弱引用</span></span><br><span class="line">            acquire!(inner.weak);  <span class="comment">// 最后一个补一个 fence(acquire)</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;  <span class="comment">// 释放 ArcInner</span></span><br><span class="line">                <span class="keyword">self</span>.alloc.<span class="title function_ invoke__">deallocate</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">cast</span>(), Layout::for_value_raw(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到跟咱前面的实现是一样一样的！为啥？因为 <a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 一书的作者<a href="https://github.com/m-ou-se">Mara Bos</a> 就是 Rust 标准库团队的领导之一！牛逼！</p><h2 id="总结">总结</h2><p>通过三轮迭代，我们不仅实现了一个媲美了标准库的 <code>Arc&lt;T&gt;</code> ，还更进一步体验了 <strong>Rust 并发抽象的设计哲学</strong>：</p><ul><li><strong>v0 —— 能用</strong>：单计数 <code>ArcData&lt;T&gt;</code> 解决了跨线程多所有权，但仍缺乏可变视图与断环能力。</li><li><strong>v1 —— 能改</strong>：借助独占 <code>&amp;mut Arc&lt;T&gt;</code> + 原子 <em>锁</em>，在 <strong>不破坏并发安全</strong> 的前提下开放了 <code>get_mut</code>。</li><li><strong>v2 —— 能回收</strong>：双计数 + <code>Weak&lt;T&gt;</code> 消除了父子互指造成的泄漏，展示了 <em>弱引用</em> 在所有权图中的价值。</li><li><strong>v3 —— 更轻巧</strong>：将 <code>Weak</code> 独立、用 <code>ManuallyDrop</code> 替换 <code>Option&lt;T&gt;</code>，让没有循环引用需求的场景不再为弱引用买单。</li></ul><p>下篇我们将尝试实现一个 <code>Mutex&lt;T&gt;</code>，敬请期待！</p><p>Happy Coding! Peace~</p><h2 id="附录">附录</h2><h3 id="1-NonNull-T">1. NonNull&lt;T&gt;</h3><p><code>std::ptr::NonNull&lt;T&gt;</code> 是一个 <strong>零成本、非空、协变</strong> 的裸指针包装器。它本质上只是把一个原始指针塞进 <code>#[repr(transparent)]</code> 的新类型中，但强制保证 <strong>绝不为空</strong>，因此可以拿到「空值当作枚举判别位」这份额外信息 —— <code>Option&lt;NonNull&lt;T&gt;&gt;</code> 与一个普通指针占用同样大小。</p><p>重要特性：</p><ul><li><strong>永远非空</strong>：创建时若传入空指针即触发 <strong>未定义行为</strong>。编译器可依赖这一点做优化，例如把 <code>Option&lt;NonNull&lt;T&gt;&gt;</code> 合并为一个指针宽度。</li><li><strong>协变</strong>：与 <code>*mut T</code> 不同，<code>NonNull&lt;T&gt;</code> 可以在 <code>U: Deref&lt;Target = T&gt;</code> 的场景下安全向子类型转换（因为禁止空值带来了额外保证），这使它非常适合构建自定义智能指针。</li><li><strong>无自动 Drop</strong>：<code> NonNull</code> 只存地址，不持有所有权；销毁与释放内存仍由外部逻辑决定（如 <code>Box::from_raw</code>、<code>Vec::dealloc</code> 等）。</li></ul><p>我们将其与裸指针、 <code>Box&lt;T&gt;</code> 智能指针和引用 <code>&amp;T</code> 做一个简单的比较：</p><table><thead><tr><th>特性</th><th><code>*mut T</code> / <code>*const T</code></th><th><code>NonNull&lt;T&gt;</code></th><th><code>Box&lt;T&gt;</code> / <code>&amp;T</code></th></tr></thead><tbody><tr><td><strong>是否允许为空</strong></td><td>✅</td><td><strong>❌ 必须非空</strong></td><td>不适用</td></tr><tr><td><strong>协变性</strong></td><td><code>*mut</code> 不协变</td><td><strong>协变</strong>（可安全向子类型转换）</td><td><code>&amp;T</code> 协变</td></tr><tr><td><strong>Option 优化</strong></td><td>❌ 多 1 B 判别字节</td><td><strong>✅ 与裸指针同尺寸</strong></td><td>已自带优化</td></tr><tr><td><strong>所有权 / drop 责任</strong></td><td>没有</td><td>没有（纯指针）</td><td>有</td></tr><tr><td><strong>Send / Sync</strong></td><td>与 <code>T</code> 无关</td><td>默认 <code>!Send !Sync</code></td><td>取决于 <code>T</code></td></tr><tr><td><strong>常见用途</strong></td><td>FFI、底层算法</td><td><strong>智能指针内部、侵入式容器、裁掉空判</strong></td><td>高层所有权模型</td></tr></tbody></table><p>关键的 API：</p><table><thead><tr><th>分组</th><th>代表方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>构造</strong></td><td><code>NonNull::new(ptr)</code> → <code>Option&lt;NonNull&lt;T&gt;&gt;</code> <br><code>unsafe &#123; NonNull::new_unchecked(ptr) &#125;</code> <br><code>NonNull::dangling()</code></td><td>安全 / 不安全 / 占位</td></tr><tr><td><strong>引用视图</strong></td><td><code>unsafe</code> <br><code>fn as_ref</code> / <code>as_mut</code></td><td>把裸指针临时借用成 <code>&amp;T</code> / <code>&amp;mut T</code></td></tr><tr><td><strong>裸指针互转</strong></td><td><code>fn as_ptr</code></td><td>取回 <code>*mut T</code>，解引用仍需 <code>unsafe</code></td></tr><tr><td><strong>类型转换</strong></td><td><code>fn cast&lt;U&gt;</code> <br><code>fn cast_mut</code> / <code>cast_const</code></td><td>保留地址，换类型或可变性</td></tr><tr><td><strong>地址运算</strong></td><td><code>unsafe fn add / byte_add / sub / offset</code></td><td>指针算术，与 <code>ptr::add</code> 族一致</td></tr><tr><td><strong>切片助手</strong></td><td><code>NonNull::slice_from_raw_parts(data, len)</code> <br><code>fn len()</code></td><td>1.70+ 稳定，为 <code>[T]</code> 提供非空裸切片构造 (<a href="https://rustwiki.org/zh-CN/std/ptr/struct.NonNull.html?utm_source=chatgpt.com">rustwiki.org</a>)</td></tr></tbody></table><blockquote><p>⚠️ 任何把 <code>NonNull</code> 重新解释为引用或解引用的操作，都必须在 <code>unsafe</code> 块里手动保证内存有效性与别名规则。</p></blockquote><p>典型使用场景：</p><table><thead><tr><th>场景</th><th>作用</th></tr></thead><tbody><tr><td><strong>智能指针内部实现</strong> (<code>Box</code>/<code>Rc</code>/<code>Arc</code>)</td><td>需要 <em>非空</em> 原始指针存放被管对象，且要在 <code>Option</code> 等场景下节省空间</td></tr><tr><td><strong>自研侵入式链表 / 红黑树</strong></td><td>节点自身持有前后指针字段 <code>NonNull&lt;Node&lt;T&gt;&gt;</code>，天然避免空判分支</td></tr><tr><td><strong>惰性初始化 / <code>Vec::new</code></strong></td><td>先用 <code>NonNull::dangling()</code> 占位，等真正分配后再写入正确地址</td></tr><tr><td><strong>FFI</strong></td><td>C API 明确保证参数永不为空时，用 <code>NonNull</code> 在类型层面表达前置条件</td></tr><tr><td><strong>自引用结构（Pin 工作区）</strong></td><td>在完成真正初始化前使用 <code>NonNull::dangling()</code> 保存指向自身字段的指针</td></tr></tbody></table><h3 id="2-ManuallyDrop-T">2. ManuallyDrop&lt;T&gt;</h3><p><code>std::mem::ManuallyDrop&lt;T&gt;</code> 是一个零成本（zero-cost）包装器。把值包在 <code>ManuallyDrop</code> 里会告诉编译器：<strong>请不要在作用域结束时自动调用它的 <code>Drop</code> 实现，什么时候释放（或是否释放）由我手动决定。</strong></p><ul><li><code>ManuallyDrop&lt;T&gt;</code> 只是把 <strong>“是否自动 drop”</strong> 这一语义从编译器搬到了程序员身上；</li><li>它<strong>不改变</strong> <code>T</code> 的布局，也不会产生额外的字节，因此是零开销；</li><li><strong>unsafe 责任</strong>：你必须保证一份值<strong>恰好析构一次</strong>（不能漏掉，也不能多调）。</li></ul><p>它的核心 API 如表所示：</p><table><thead><tr><th>API</th><th>作用</th><th>重要注意点</th></tr></thead><tbody><tr><td><strong><code>ManuallyDrop::new(value)</code></strong></td><td>把 <code>T</code> 包装成 <code>ManuallyDrop&lt;T&gt;</code>，关闭自动析构</td><td>零开销；之后需显式 drop 或移动走</td></tr><tr><td><strong><code>ManuallyDrop::drop(&amp;mut self)</code></strong> <em>(unsafe)</em></td><td>手动触发内部值的析构</td><td>必须保证之后不会再访问 / 再 drop</td></tr><tr><td><strong><code>ManuallyDrop::take(&amp;mut self)</code></strong> <em>(unsafe)</em></td><td>从包装里&quot;搬走&quot;值（等价于 <code>ptr::read</code>）</td><td><code>v</code> 里留下未初始化内存，不能再用或再 drop</td></tr><tr><td><strong><code>ManuallyDrop::into_inner(self)</code></strong> <em>(unsafe)</em></td><td>消费 <code>ManuallyDrop</code> 返回内部值</td><td>取得所有权后，原包装已被移走（不会 double-drop）</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文手把手带你拆解并重构 Arc：从单线程引用计数，到跨线程 Weak 防环，再到剥离强/弱引用与内存序优化，层层深入 Rust 并发与内存模型核心。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 实战" scheme="https://hedon.top/categories/rust/rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
