<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HedonWang</title>
  
  <subtitle>君子求诸己，律己则安。</subtitle>
  <link href="https://hedon.top/atom.xml" rel="self"/>
  
  <link href="https://hedon.top/"/>
  <updated>2025-06-26T14:36:34.381Z</updated>
  <id>https://hedon.top/</id>
  
  <author>
    <name>Hedon Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FOSA丨01丨软件架构概述</title>
    <link href="https://hedon.top/2025/06/26/fosa-ch1/"/>
    <id>https://hedon.top/2025/06/26/fosa-ch1/</id>
    <published>2025-06-26T03:00:26.000Z</published>
    <updated>2025-06-26T14:36:34.381Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第一章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li>What are the four dimensions that define software architecture?软件架构定义的四个维度是什么？</li><li>What is the difference between an architecture decision and a designprinciple? 架构决策和设计原则有什么区别？</li><li>List the eight core expectations of a software architect.软件架构师的核心期望有哪些？</li><li>What is the First Law of Software Architecture?软件架构的第一定律是什么？</li></ol><hr /><h1 id="软件架构定义的四个维度">1. 软件架构定义的四个维度</h1><ul><li><strong>structure of the system</strong>: refres to the type ofarchitecture style (or styles) the system is implemented in (such asmicroservices, layered, or microkernel).</li><li><strong>architecture characteristics</strong>: define the successcriteria of a system, which is generally orthogonal to the functionalityof the system.</li><li><strong>architecture decisions</strong>: define the rules for how asystem should be constructed.</li><li><strong>design principles</strong>: differ from architecturedecisions in that a design principle is a guideline rather than ahard-and-fast rule.</li></ul><p>FOSA中强调，软件架构不单单是"架构"本身，因为它无法揭示系统为何如此构建（whyis more important than how），所以书中用了 4个维度来定义软件架构的方方面面。</p><h2 id="系统结构">1.1 系统结构</h2><p>系统结构可能就是我们最常谈到的"架构"，指的的整个软件的架构风格（ArchitectureStyle），例如微服务（Microservices）、分层架构（Layered）或微内核（Microkernel）。</p><p>书中后续篇章详细介绍了以下 8 种架构风格：</p><ol type="1"><li>分层架构（Layered Architecture）</li><li>流水线架构（Pipeline Architecture）</li><li>微内核架构（Microkernel Architecture）</li><li>基于服务的架构（Service-Based Architecture）</li><li>事件驱动架构（Event-Driven Architecture）</li><li>基于空间的架构（Space-Based Architecture）</li><li>编排驱动的服务导向架构（Orchestration-Driven Service-OrientedArchitecture）</li><li>微服务架构（Microservices Architecture）</li></ol><p>FOSA强调，只用结构来描述架构是不够的，因为它无法揭示系统为何如此构建。因此我们在设计之初，明确选择和识别现有系统的架构风格是基础，但必须超越这一层去理解其背后的驱动因素。</p><h2 id="架构特性">1.2 架构特性</h2><p>架构特性就是一堆的<code>-ilities</code>，书中偏爱"架构特性"这个描述，而非"非功能性需求"或"质量属性"，因为这二者带有负面或事后评估的含义，而架构特性，应当是在架构设计之初，就被纳入深入思考。</p><p>架构特性有 3 个标准：</p><ol type="1"><li><strong>指定非领域设计考虑</strong>：更关注"如何"实现需求和"为什么"做出某些选择，而不是应用程序"应该做什么"的功能需求。</li><li><strong>影响设计的某种结构方面</strong>：架构特性要求在设计中进行特殊的结构考虑。</li><li><strong>对应用程序成功其重要作用</strong>：每个架构特性都会带来架构的复杂度，所以要尽可能选择最少的、但对成功至关重要的架构特性予以实施。</li></ol><p>架构特性可以分为 3 大类：</p><ol type="1"><li>操作型架构特性</li><li>结构型架构特性</li><li>交叉切面架构特性</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250626114830268.png"alt="架构特性分类" /><figcaption aria-hidden="true">架构特性分类</figcaption></figure><p>将任意一个架构特性实现到极致的代价都是极大的，相应也会带来更复杂的架构设计，所以在项目早期，我们需要与领域专家和业务干系人紧密合作，识别和明确最重要的架构特性，用最少的努力，达到最大的产品效果。</p><h2 id="架构决策">1.3 架构决策</h2><p>架构决策定义了系统如何构建的规则。它们构成了系统的约束，并指导开发团队哪些是被允许的，哪些是不允许的。比如在分层架构中，架构师可能会规定只有业务层额和服务层可以访问数据库，从而限制了表示层直接调用数据库。</p><p>架构决策应当被文档化，例如使用架构决策记录（Architecture DecisionRecords，ADRs），这有助于解释决策的背景、理由和后果，避免重复讨论。</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image.png"alt="架构决策记录 ADR" /><figcaption aria-hidden="true">架构决策记录 ADR</figcaption></figure><h2 id="设计原则">1.4 设计原则</h2><p>设计原则是指导方针（Guideline）而非硬性规则（hard-and-fastrule），用于提供指引和建议，帮助开发团队在面对特定情景时做出最佳选择。</p><h1 id="架构决策和设计原则的区别">2. 架构决策和设计原则的区别</h1><ul><li>架构决策：硬性规则</li><li>设计原则：指导方针</li></ul><h1 id="软件架构师的核心期望">3. 软件架构师的核心期望</h1><h2 id="八大期望">3.1 八大期望</h2><ol type="1"><li><p>Make Architecture Decisions</p><p>架构师应定义指导团队技术决策的架构决策和设计原则。核心是"指导（guide）"而非"指定（specify"。</p></li><li><p>Continually Analyze the Architecture</p><p>架构师必须持续、全面地分析技术和问题域的变化，以确保架构的健壮性和业务相关性。</p></li><li><p>Keep Current with Latest Trends</p><p>架构师需要不断跟踪和保持对最新技术、框架、平台和环境的了解。</p></li><li><p>Ensure Compliance with Decisions</p><p>架构师需要持续验证开发团队是否遵循已定义、文档化和沟通的架构决策和设计原则。</p></li><li><p>Diverse Exposure and Experience</p><p>架构师应接触并体验多种多样的技术、框架、平台和环境，从而帮助架构师在面对新问题时，可以从更广阔的技术栈中选择最佳解决方案。</p></li><li><p>Have Business Domain Knowledge</p><p>优秀的软件架构师不仅理解技术，还理解问题空间的业务领域，从而设计出贴合业务发展的有效架构。</p></li><li><p>Possess Interpersonal Skills</p><p>成为一名有效架构师，人际交往能力至少占一半。架构师需要积极与团队协作、进行双向沟通，提供指导和辅导，避免成为象牙塔架构师（IvoryTower Architecture）。</p></li><li><p>Understand and Navigate Politics</p><p>架构师需要理解企业内部的政治环境，并能驾驭其复杂性。在架构决策受到挑战时，沟通过程中需要始终提供技术和业务上的双重理由，学习将强硬要求转化为请求，并利用同理心和影响力而非头衔来推动决策。</p></li></ol><h2 id="成长指南">3.2 成长指南</h2><p>成长为一名合格的软件架构师是一个持续学习和实践的过程，涵盖技术、沟通和领导力等多个方面，这里笔者结合FOSA 书中的 19~24 章内容进行梳理总结：</p><ul><li><strong>持续学习和扩展技术广度</strong><ul><li>20 分钟法则：每天至少投入 20分钟学习新知识或深入研究特定主题，这里笔者推荐可以每天（或每周）跟 LLM深入探讨一个技术话题或前沿技术概念。</li><li>技术雷达：利用如 ThoughtWorks技术雷达的方法来组织和评估新技术，识别值得投入时间深入研究的"试用"技术，并根据趋势更新知识库。</li><li>社交媒体：积极利用社交媒体发现新趋势和技术，将其放入个人技术雷达的"评估"环中。</li></ul></li><li><strong>实践权衡分析</strong><ul><li>失败乃成功之母，实践是检验真理的唯一标准。只有在实践中不断的进行架构设计、权衡抉择、推翻重建，才能不断深化对理论知识、业务领域和现实世界的理解。</li><li>培养批判性思维，避免过度设计和"黄金镀层"现象，专注于解决实际问题，而不是为了技术而技术。软件架构中没有错误的答案，只有昂贵的答案。</li></ul></li><li><strong>培养沟通和协作能力</strong><ul><li>通用语言：参考DDD（领域驱动设计）思想，在所有项目相关沟通中（包括代码和文档）都使用通用语言，避免沟通歧义，减少沟通成本。</li><li>4C原则：在沟通中始终关注沟通（Communication）、协作（Collaboration）、清晰（Clarity）和简洁（Concisensess）这4 个要素。</li><li>主动倾听：认真倾听利益相关者的声音，理解他们的业务需求和痛点，并寻求澄清。</li></ul></li><li><strong>通过榜样领导团队</strong><ul><li>赢得尊重</li><li>辅导和引导</li><li>化请求为帮助</li><li>使用清单</li></ul></li><li><strong>深入业务领域</strong><ul><li>分析业务领域和子域，识别公司的主要活动领域、竞争策略。</li><li>学习领域驱动设计，始终让业务驱动软件设计决策，而不是为了应用最新的技术而技术。</li></ul></li></ul><h1 id="软件架构的第一定律">4. 软件架构的第一定律</h1><ol type="1"><li>Everything in software architecture is a trade-off.</li><li>If an architecture thinks they have discovered something that isn'ta trade-off, more likely they just haven't identified the trade-offyet.</li><li>Why is more important than how.</li></ol><p>软件架构中的一切都是<strong><font color="red">权衡</font></strong>。一个解决方案是否是"最佳"的，取决于部署环境、业务驱动因素、公司文化、预算、时间限制、开发人员技能集以及其他数多种因素。架构师应追求"<strong>最不差架构</strong>（leastworstarchitecture）"，而非"最佳架构"。试图支持过多的架构特性往往会导致过于通用且笨重的设计，使其难以成功。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第一章的课后思考题，深入探讨软件架构的四个定义维度、架构决策与设计原则的区别、软件架构师的核心职责，以及软件架构的第一定律，帮助建立对软件架构的全面认识。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
  </entry>
  
  <entry>
    <title>Q&amp;A丨在 AI 时代，如何应对技术焦虑？</title>
    <link href="https://hedon.top/2025/06/21/qa-how-to-deal-with-tech-anxiety-in-ai-era/"/>
    <id>https://hedon.top/2025/06/21/qa-how-to-deal-with-tech-anxiety-in-ai-era/</id>
    <published>2025-06-20T19:06:00.000Z</published>
    <updated>2025-06-20T20:33:39.142Z</updated>
    
    <content type="html"><![CDATA[<p>长期以来我一直陷于技术海洋之中无法自拔，各种追逐技术，有过偶尔的专注，也获得了很大的提升，但更多时候，还是处于多头乱撞、内耗焦虑当中。</p><p>在 AI快速发展的这段时间，我的焦虑更甚，减法做得越来越差，所以最近专门跟Google Gemini聊了这个话题，我觉得它的回答非常好，解答了我很多的疑惑，也让我对未来有了更多的信心，特此整理此篇，以图内心获得更多的宁静。</p><h2 id="在-ai-时代还有必要学习底层技术吗">在 AI时代，还有必要学习底层技术吗？</h2><p>第一个问题我是跟 ChatGPT 讨论的：<ahref="https://hedon.top/2025/06/17/qa-should-learn-underlying-principles-in-ai-era/">在AI 时代，程序员还有必要学习底层技术吗？</a></p><p>它给了我 5 个直击内心的理由：</p><ol type="1"><li>抽象层终会"泄露"，底层知识是你的救生筏；</li><li>问题的根源，往往深藏于你看不到的地方；</li><li>真正的工程判断力，建立在对权衡的理解之上；</li><li>你的职业天花板，由底层知识决定；</li><li>创新，源于对第一性原理的掌握。</li></ol><p>我觉得非常有道理：</p><ol type="1"><li>当 AI 失灵或表现不佳时，能拯救你的不是另一个AI，而是你对底层的掌控力。</li><li>只懂“驾驶”的人在车坏了时只能打电话求助，而懂“机械”的人能自己打开发动机盖解决问题。我要做后者。</li><li>AI可以成为我的顾问，但最终做出决策、并为之负责的人是我。我的决策质量，直接取决于我的底层知识深度。</li><li>AI会拉平初级和中级工程师的差距，但底层技术功底是区分高级/资深工程师与普通工程师的护城河。</li><li>学习底层技术，不仅是为了解决今天的问题，更是为了获得解决明天未知问题、甚至定义未来的能力。</li></ol><p>所以在保持积极学习前沿技术的同时，我应当将更多的时间，有计划地、持续地加深我的纵向底层知识，从"为什么会这样？"开始，一路向下挖掘，直到触及问题的本质。</p><h2 id="如何应对技术焦虑">如何应对技术焦虑</h2><p>第二个问题我是跟 Google Gemini 讨论的：<ahref="https://g.co/gemini/share/819b80654773">后端工程师如何应对技术焦虑</a>。</p><h3 id="原则重于朝生暮死的工具">原则重于朝生暮死的工具</h3><p>后端开发的核心能力，强调那些超越特定语言或框架的底层原则。尽管工具日新月异，但其试图解决的根本问题和所遵循的基本模式却保持着相当的一致性。</p><p>后端工程技能三阶模型：</p><ol type="1"><li>是什么：掌握基本工具和概念，能够完成独立任务。</li><li>怎么做：熟练运用框架和模式，构建稳定、可维护的系统。</li><li>为什么：进行系统级思考，设计高可用、高扩展性的复杂系统。</li></ol><p>技术焦虑的一个重要来源，是将职业发展视为一个永无止境的"技能清单"勾选过程。今天学会了Django，明天又要追逐 FastAPI；刚掌握了 Docker，Kubernetes的生态又让人望而生畏。这种思维模式必然导致疲于奔命。</p><p><strong>真正的“不变之核”，不是技能本身，而是该技能所体现的原则。</strong></p><p>技术焦虑的逻辑拆解：</p><ol type="1"><li>开发者面临的困境是新技术层出不穷，感到焦虑 [用户问题]。</li><li>行业分析罗列了大量"必备技能"，如 Python、Django、Docker、Kubernetes等 。</li><li>如果只是简单地告诉开发者去学习这个清单，只会加剧焦虑，因为清单永远在变长。</li><li>与此同时，另一些分析强调了基础概念的重要性，如面向对象、结构化思维、解决问题的能力。</li><li>将这两类信息结合起来，我们能看到更深层的联系：<ul><li>Django 和 Ruby on Rails 是MVC（模型-视图-控制器）架构模式的实现。</li><li>Spring Boot框架深度应用了依赖注入（DI）和面向切面编程（AOP）的思想。</li><li>Docker 和 Kubernetes是为了解决“环境一致性”和“服务编排与生命周期管理”这两个根本问题而诞生的解决方案。</li></ul></li><li>因此，真正持久的技能，是理解这些问题和模式（即"为什么"），而不仅仅是掌握某个工具（即"是什么"）。一个理解了MVC模式的工程师，可以快速上手任何一个采用类似模式的新框架。而一个只"会用Django"的工程师，当行业风向转变时，可能会陷入困境。</li></ol><p>数据结构、算法、计算机网络、操作系统和计算理论等 CS基础知识为工程师提供了一个统一的、抽象的框架，用以推理和分析所有计算系统，无论其外在形态如何变化。这种力量体现在它能够培养一种至关重要的能力：<strong>结构化思维和问题分解</strong>。</p><p>CS基础知识的另一个巨大价值在于，它能帮助工程师"快速理解不熟悉的系统"，比如：</p><ul><li>当你看到一个 HTML 或 XML文档时，你不会只看到一堆标签，你会看到一棵<strong>树（Tree）</strong>。这个认知让你立刻能够运用所有关于树的知识来思考它：DOM遍历算法（深度优先、广度优先）、节点操作的效率、以及如何优化渲染性能。</li><li>当你接触到一个新的键值存储（Key-ValueStore）系统时，你脑海中浮现的应该是<strong>哈希表（HashTable）</strong>。这个抽象模型让你能够立即开始推理其核心特性和潜在问题：哈希冲突如何解决？负载因子过高时性能会如何衰减？它的时间复杂度在理想和最坏情况下分别是多少？</li><li>当你研究像 Apache Kafka这样的消息系统时，你会认识到从单个消费者的角度看，一个 Topic本质上就是一个<strong>队列（Queue）</strong>。这个模型帮助你理解消费者组（ConsumerGroup）的行为、偏移量（Offset）的管理机制，以及消息的顺序性保证等核心概念。</li></ul><p>这种通过高层抽象和模式匹配来快速定位和理解新技术核心本质的能力，是在日新月异的技术环境中保持方向感和学习效率的关键。它让你在面对任何一个新框架、新平台或新工具时，都能迅速地抓住其要害，而不是迷失在纷繁复杂的API 和配置细节之中。</p><p>在人工智能时代，我们越来越多地与一些极其复杂的系统打交道，尤其是大型语言模型（LLM），它们在很多开发者眼中就像一个"黑箱"。我们知道如何向它提问并获得惊艳的答案，但对其内部工作原理却知之甚少。这种未知感，正是技术焦虑的重要来源之一——我们称之为"黑箱焦虑"。</p><p>一个拥有扎实 CS 基础的工程师面对一个新 AI 系统的场景：</p><p><strong>场景一：向量数据库。</strong>当他听说一个应用使用了向量数据库（Vector Database）来实现语义搜索时，他不会仅仅惊叹于其"神奇"的效果。他的大脑会立即启动基于 CS基础的推理：</p><ul><li><strong>数据结构层面：</strong>为了实现高效的近邻搜索，这个向量数据库内部很可能使用了某种空间分割数据结构，比如k-d 树（k-d tree），或者更现代的、基于图的 HNSW（Hierarchical NavigableSmallWorld）算法。这两种结构在查询速度、内存占用和索引构建时间上有什么不同的权衡？</li><li><strong>算法层面：</strong>它使用的距离度量是欧氏距离还是余弦相似度？这对于不同类型的嵌入向量（Embeddings）意味着什么？</li><li><strong>系统层面：</strong>这是一个单体数据库还是分布式系统？如果是分布式的，它是如何处理数据分片和查询路由的？</li></ul><p><strong>场景二：AI Agent 系统。</strong> 当他了解到 AI Agent能够自主规划并执行一系列复杂任务时，他不会感到无所适从。他会联想到：</p><ul><li><strong>算法层面：</strong>这种任务规划本质上是一个在巨大的状态空间中进行搜索的问题。它可能在内部使用了某种图搜索算法，比如A*算法，或者蒙特卡洛树搜索（MCTS）。这些算法的潜在缺陷是什么？比如，是否可能陷入局部最优解，或者面临组合爆炸的问题？</li><li><strong>系统层面：</strong> 这个 Agent系统是如何与外部工具（Tools）进行交互的？是通过结构化的 API 调用吗？那么API的可靠性和延迟将成为整个系统的瓶颈。它如何处理工具调用失败的情况？有重试机制或错误处理逻辑吗？</li></ul><h3 id="工程师心智模型">工程师心智模型</h3><p>一个工程师最持久、最宝贵的资产，并非某项具体的技术，而是一种特定的思维方式。这种"工程师心智模式"（EngineeringMindset）是运行所有其他技能的底层操作系统，是应对一切变化的最终依仗。</p><p>综合多方研究，我们可以将工程师心智模式的核心特质归纳为以下几点：</p><ol type="1"><li>系统性的问题解决方法</li><li>数据驱动与逻辑推理</li><li>对持续改进的执着</li><li>韧性与适应性</li><li>主动的好奇心</li></ol><p>软技能：</p><ol type="1"><li>沟通</li><li>协作</li><li>时间管理</li></ol><h3 id="ai-革命在历史进程中的位置">AI 革命在历史进程中的位置</h3><p>软件开发的历史并非一条平滑的直线，而是由一系列深刻的范式转移（ParadigmShift）所驱动的。这些变革往往是为了应对上一代范式所暴露出的危机或局限性而生。</p><ol type="1"><li>个体创作时代（IndividualCreation）：在软件开发的早期，程序被视为天才程序员在"作坊"中创作的精妙艺术品。</li><li>工程范式时代（EngineeringParadigm）：随着软件系统规模和复杂度的急剧增长，个体创作模式难以为继，导致了"软件危机"。为了应对危机，业界引入了工业化生产的管理思想，提出了"软件工程"的概念，强调需求分析、流程分解、文档规范和质量控制，将软件开发从个体创作推向了大规模、有组织的群体生产。</li><li>开源范式时代（Open SourceParadigm）：工程范式在应对互联网时代的需求不确定性和快速变化时显得力不从心。此时，以"代码开源、过程开放、大众参与"为特征的开源运动蓬勃发展，形成了一种新的范式。它不强调预先确定的需求，而是通过"自下而上、演化涌现"的方式，激发大规模群体的创作灵感和智慧。</li><li>群智范式时代（Crowd IntelligenceParadigm）：为了平衡工程范式的确定性和开源范式的不可控性，群智范式应运而生。它试图在规范生产和自由创作之间找到平衡，通过"宏观演化，微观求精"的理念，结合核心团队的引导和外围群体的贡献，实现软件的持续迭代和演化。</li></ol><table><colgroup><col style="width: 5%" /><col style="width: 7%" /><col style="width: 22%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 23%" /></colgroup><thead><tr><th>范式</th><th>核心理念</th><th>对"需求"的看法</th><th>对"质量"的看法</th><th>对"效率"的看法</th><th>主要瓶颈</th></tr></thead><tbody><tr><td><strong>工程范式</strong></td><td>自上而下，逐步求精</td><td>开发的起点和依据，需预先明确和规范化</td><td>满足需求规格的程度，通过验证和测试保障</td><td>投入产出比，通过过程控制和自动化提升</td><td>协同效率瓶颈（人月神话），无法适应网络时代的需求不确定性</td></tr><tr><td><strong>开源范式</strong></td><td>自下而上，演化涌现</td><td>不必预先明确，可由开发者自身构思驱动</td><td>体现为社区规模和口碑</td><td>体现为项目迭代效率（如缺陷修复速率）</td><td>结果不可控，将创意作品收敛为产品的成本极高</td></tr><tr><td><strong>群智范式</strong></td><td>宏观演化，微观求精</td><td>持续获取与凝练的过程，以原型版本和疑修(Issue)集合呈现</td><td>宏观上是生态适应能力，微观上是版本满足里程碑的程度</td><td>包含激发效率和汇聚效率，体现为迭代演化的成本与时间</td><td>如何设计高效的协作机制与智能化工具以保障激发与汇聚效能</td></tr></tbody></table><p>当前企业和社会对 AI的采纳过程，与十多年的云计算转型惊人地相似，我们可以从中汲取宝贵的经验教训：</p><ol type="1"><li>始于业务问题，而非技术本身（Start with the Business Problem)</li><li>清晰评估现状（Assess the Current State）</li><li>切勿忽视人的因素（Don't forget the Humans）</li><li>警惕技术蔓延与技术债务（Avoid Sprawl and Techinal Debt）</li></ol><h3 id="ai-不是威胁而是工具">AI 不是威胁而是工具</h3><p>生成式 AI 正以前所未有的深度和广度渗透到软件开发生命周期（SoftwareDevelopment Lifecycle,SDLC）的每一个环节，从根本上改变着开发者的工作方式 。</p><ol type="1"><li>构思与规划（Ideation &amp; Planning）：<ul><li><strong>需求识别与优先级排序:</strong>分析用户反馈、市场趋势数据，辅助产品负责人识别关键需求并进行优先级排序。</li><li><strong>可行性与资源预测:</strong>基于历史项目数据，预测项目成本、时间和资源需求，做出更精准的规划。</li><li><strong>数据驱动决策:</strong>使早期规划更具客观依据，减少主观臆断。</li><li><strong>减少需求冲突:</strong>自动识别不完整或相互矛盾的需求描述，降低后期返工风险。</li></ul></li><li>设计（Design）<ul><li><strong>原型加速创建:</strong>快速生成用户界面原型、线框图和流程图。</li><li><strong>架构模式推荐:</strong>基于项目约束和最佳实践，推荐最优的系统架构或设计模式。</li><li><strong>缩短设计周期:</strong>大幅减少手动绘制原型和设计文档的时间。</li><li><strong>避免早期架构失误:</strong> 借助 AI的知识库，帮助团队在项目初期做出更稳健的架构选择 。</li></ul></li><li>开发（Development）<ul><li><strong>智能代码补全与生成:</strong>基于上下文，自动补全代码行、函数甚至整个逻辑块 (如 GitHub Copilot)。</li><li><strong>从自然语言生成代码:</strong>根据高层级的功能描述，直接生成多种语言的代码片段 。</li><li><strong>代码重构与翻译:</strong> 自动将老旧代码（如COBOL）重构为更易读的现代语言（如 Java），或在不同语言间进行转换。</li></ul></li><li>测试（Testing）<ul><li><strong>自动化测试用例生成:</strong>从用户故事或需求文档直接生成功能测试用例，包括人类测试者可能忽略的边缘情况。</li><li><strong>AI 辅助代码审查:</strong>在代码提交前，实时扫描潜在的安全漏洞、逻辑错误或性能瓶颈。</li><li><strong>提升测试覆盖率:</strong>自动生成全面的测试套件，确保软件质量。</li><li><strong>缺陷左移 (Shift-Left):</strong>在开发早期发现并修复缺陷，显著降低修复成本和后期风险 。</li></ul></li><li>部署（Deployment）<ul><li><strong>自动化部署脚本生成:</strong>自动生成部署脚本或基础设施即代码（IaC）的配置文件（如 Terraform,Ansible）。</li><li><strong>CI/CD 流水线优化:</strong>辅助编排代码、基础设施和配置管理，实现更快的持续交付。</li><li><strong>减少手动部署错误:</strong>自动化配置过程，降低人为失误的概率。</li><li><strong>加速产品上市时间:</strong>实现更快速、更频繁的生产环境更新，快速响应市场变化。</li></ul></li><li>运维与维护（Maintainice &amp; Operations）<ul><li><strong>智能监控与异常检测:</strong>学习系统正常行为模式，主动识别异常，预测潜在故障 。</li><li><strong>自动化事件响应与修复:</strong>自动执行事件分类、根本原因分析，甚至触发自动化修复脚本 。</li><li><strong>文档与知识库维护:</strong> 自动生成或更新技术文档、API文档和知识库文章 。</li><li><strong>从被动响应到主动预防:</strong>在问题影响用户之前进行干预。</li><li><strong>降低平均解决时间 (MTTR):</strong>快速定位并解决生产问题。</li><li><strong>提升知识管理效率:</strong>确保文档与代码同步，降低团队沟通成本。</li></ul></li></ol><h3 id="开发者角色的转变">开发者角色的转变</h3><p>经验丰富的工程师的角色，就从亲自编写每一行代码，转变为更高层次的<strong>审查者、整合者和架构师</strong>。他们的核心工作变成了：</p><ol type="1"><li><strong>定义问题与设定目标</strong>：清晰地向 AI描述要实现的功能和约束条件。</li><li><strong>批判性审查 AI 的输出</strong>：评估 AI生成的代码是否符合架构设计、是否遵循编码规范、是否存在潜在的性能和安全问题。</li><li><strong>整合与调试</strong>：将 AI生成的代码片段无缝地整合到现有系统中，并调试其中可能存在的错误。</li><li><strong>做出架构权衡</strong>：决定何时使用 AI、使用哪个 AI工具，并对 AI无法处理的、需要深刻理解业务和系统长期演进的复杂架构问题做出决策。</li></ol><h3 id="智能后端的崛起aiops-与系统架构">智能后端的崛起：AIOps与系统架构</h3><p>AI不再仅仅是用于<strong>构建</strong>后端的工具，而是成为了后端系统本身的<strong>核心组成部分</strong>。这种融合催生了名为AIOps 的新领域，正在彻底改变我们对系统运维和架构的认知。</p><p>AIOps，即人工智能运维（Artificial Intelligence for ITOperations），是由 Gartner提出的概念，指的是将大数据和机器学习技术应用于 IT运维流程，以实现自动化和增强。在传统的运维模式中，工程师们常常扮演着"救火队员"的角色，在系统发生故障后被动地响应告警、排查问题。而AIOps 的目标，是利用 AI的预测和模式识别能力，将运维从<strong>被动响应</strong>转变为<strong>主动预防</strong>，甚至实现<strong>预测性维护</strong>。</p><p>AIOps通过分析海量的系统遥测数据（包括日志、指标和追踪），为后端系统的稳定性、性能和安全性带来了革命性的提升。</p><ul><li>主动的事件侦测与预防（Proactive Incident Detection &amp;Prevention）：传统监控系统依赖于预设的静态阈值（例如，CPU 使用率超过 90%则告警）。而 AIOps平台通过机器学习算法，能够学习系统在不同负载和时间下的"正常行为"基线。当系统行为偏离这个动态基线时，即使没有触及任何静态阈值，AIOps也能识别出异常，从而在问题升级为严重故障、影响到终端用户之前，就向工程师发出预警。</li><li>告警降噪与智能关联（Noise Reduction &amp; IntelligentAlerting）：在复杂的微服务架构中，一个底层的故障（如数据库慢查询）可能会引发连锁反应，导致成百上千个相关服务的告警同时爆发，形成"告警风暴"，让待命工程师（On-callEngineer）不堪重负。AIOps能够自动将这些相关的告警进行关联和分组，并识别出最初的根源事件，将数百条告警压缩为一条包含丰富上下文的、可操作的事件通知，极大地减少了告警噪音，降低了工程师的认知负担。</li><li><strong>自动化的根本原因分析 (Automated Root CauseAnalysis)</strong>：当故障发生时，最耗时的工作往往是定位根本原因（RootCause）。AIOps通过分析跨越整个技术栈（应用、中间件、数据库、网络、基础设施）的数据，能够自动识别不同组件之间的因果关系和依赖关系，快速推断出问题的根源，将工程师从繁琐的手动排查中解放出来。</li><li><strong>自愈与自动化修复 (Self-Healing and AutomatedRemediation)</strong>：这是 AIOps 最前沿的演进方向，有时也被称为"AgenticAIOps"。在这种模式下，系统不仅能检测和分析问题，还能<strong>自主地采取行动进行修复</strong>。例如：<ul><li>检测到某个服务实例无响应时，自动重启该实例。</li><li>预测到流量高峰即将来临时，自动扩展相关服务的计算资源。</li><li>发现数据库连接池耗尽时，自动调整连接池大小。</li><li>识别到安全威胁时，自动执行隔离或封禁 IP 等安全策略 。</li></ul></li></ul><p>AIOps的崛起，意味着后端工程师在运维领域的角色正在发生根本性的转变。他们的工作重心将从<strong>被动的"救火"</strong>，转向<strong>主动的"防火"和"消防系统设计"</strong>。具体来说：</p><ol type="1"><li>成为 AIOps 平台的架构师和维护者；</li><li>理解并应用机器机器学习模型的基本原理、适用场景和局限性；</li><li>为可观测性而设计（Design for Observability），为 AIOps提供高质量的"燃料"。</li></ol><h3 id="ai-赋能工程师的基础技能栈">AI 赋能工程师的基础技能栈</h3><ol type="1"><li>数学与统计学基础（Mach &amp; Stats Foundation）：这是理解 AI模型"如何工作"的基石，而不仅仅是"如何使用"。一个扎实的数学基础能让你在面对模型调优、性能瓶颈分析和结果解读时，具备更深刻的洞察力。<ul><li><strong>线性代数 (LinearAlgebra)</strong>：理解向量、矩阵、张量及其运算。这是理解数据表示、神经网络结构和各种转换的基础。</li><li><strong>微积分(Calculus)</strong>：理解导数、偏导数和链式法则。这是理解梯度下降等优化算法如何工作的关键。</li><li><strong>概率论与统计学 (Probability andStatistics)</strong>：掌握概率分布、贝叶斯定理、假设检验等概念。这是理解和评估模型性能、处理不确定性的基础。</li></ul></li><li>核心机器学习概念（Core ML Concepts）：这是 AI应用领域的通用语言，构成了解决大多数商业问题的基础。<ul><li><strong>学习范式</strong>：清晰地区分监督学习（SupervisedLearning）、无监督学习（Unsupervised Learning）和强化学习（ReinforcementLearning）的适用场景 。</li><li><strong>关键算法</strong>：了解一些经典的算法，如线性回归、逻辑回归、支持向量机（SVM）、K-均值聚类（K-Means）以及集成方法（如随机森林、梯度提升树）。</li><li><strong>核心流程</strong>：掌握特征工程（FeatureEngineering）、模型评估（Model Evaluation）和超参数调优（HyperparameterTuning）等关键环节 。</li></ul></li><li>深度学习与生成式 AI（Deep Learning &amp; Generative AI）：这是当前AI 浪潮的核心驱动力，也是后端工程师需要重点关注的新兴领域。<ul><li><strong>神经网络基础</strong>：理解神经网络的基本构成，如卷积神经网络（CNNs）和循环神经网络（RNNs）的原理和应用场景。</li><li><strong>Transformer架构</strong>：深入理解作为现代大语言模型（LLM）基石的 Transformer 架构。</li><li><strong>生成式 AI核心技术</strong>：熟悉检索增强生成（Retrieval-Augmented Generation,RAG）的原理和实现方式，这是将私有数据与 LLM 结合的关键技术 。</li></ul></li><li>AI 框架与平台（AI Framework andPlatforms）：将理论知识转化为实践能力，离不开对主流工具的掌握。<ul><li><strong>开发框架</strong>：具备使用 PyTorch进行模型构建和训练的实践经验 。</li><li><strong>模型生态</strong>：熟悉 Hugging Face等平台，能够利用其丰富的预训练模型生态系统来加速开发 。</li><li><strong>云 AI 服务</strong>：了解并能够使用主流云服务商（如 AWSBedrock, Azure AI, Google Vertex AI）提供的 AI 平台和 API 服务 。</li></ul></li></ol><h3 id="应对焦虑的小建议">应对焦虑的小建议</h3><ul><li><strong>高效地休息 (Take EffectiveBreaks)</strong>：长时间不间断地工作，尤其是在编程这种高强度脑力劳动中，会导致效率下降和精神紧张。采用番茄工作法（PomodoroTechnique），即工作 25-30 分钟后，强制自己休息 5 分钟，或者每工作 1.5-2小时，进行 10-20 分钟的休息，能够有效恢复精力。关键在于，休息时要真正地"脱离"，即离开电脑屏幕，站起来走动，或者看看远方，而不是切换到手机上继续浏览信息。</li><li><strong>关注身体健康 (PhysicalWell-being)</strong>：身心健康密不可分。规律的体育锻炼和健康的营养摄入，是维持长期成功的两个最重要因素。运动能释放内啡肽，缓解压力；均衡的饮食能为大脑提供稳定的能量。这就像维护一台高性能的服务器，必须为其提供稳定的电力和良好的散热。</li><li><strong>正念与减负荷 (Mindfulness and De-stimulation)</strong>：<ul><li><strong>正念练习</strong>：每天进行几分钟的冥想练习，可以帮助训练大脑的专注力，减少杂念。可以使用Headspace、Waking Up 等应用，或者 YouTube 上 的引导式冥想视频 。</li><li><strong>减少咖啡因/酒精摄入</strong>：过量的咖啡因会加剧焦虑感。可以尝试用绿茶等含有L-茶氨酸（L-Theanine）的饮品来替代，它具有镇静作用 。</li><li><strong>避免过度刺激</strong>：下班后，尽量避免进行高刺激性的活动，如玩竞技类游戏、看动作大片或无休止地刷社交媒体。可以选择散步、听有声书、阅读、做瑜伽等舒缓的活动，让大脑真正地放松下来。</li></ul></li><li><strong>设立清晰的边界 (SetBoundaries)</strong>：在远程办公和弹性工作日益普遍的今天，工作与生活的边界变得模糊，这极易导致职业倦怠。必须有意识地设立并捍卫自己的边界。<ul><li><strong>明确工作时间</strong>：设定固定的上下班时间，并严格遵守。</li><li><strong>管理通知</strong>：使用手机的"专注模式"或类似功能，在非工作时间屏蔽工作相关的通知，在工作时间屏蔽不必要的干扰。</li><li><strong>优先排序</strong>：要清醒地认识到，家庭、健康和个人生活，远比修复一个明天才到截止日期的BUG 更重要。学会对不合理的要求说"不"。</li></ul></li><li><strong>关注过程，而非终点 (Focus on Process, NotOutcome)</strong>：拥抱成长型思维，将你的目标从"完全掌握AI"这个不切实际的终点，转变为"保持持续学习的状态"这个可控的过程。技术的演进没有终点，因此你的学习也不应有终点。接受这一点，能让你从对"完成"的焦虑中解脱出来，转而享受学习和进步本身带来的乐趣。</li></ul><h2 id="如何高效学习底层与新技术">如何高效学习底层与新技术</h2><p>应对当前挑战的最优策略，是向" AI 增强的 T 型工程师（AI-AugmentedT-Shaped Engineer）"转型：</p><ol type="1"><li><strong>深度的垂直支柱</strong>：投入时间系统性学习那些具有长期价值的计算机科学基础原理，如算法、系统设计、编译原理等。这是职业生涯的"压舱石"，构成了T 型的垂直笔画。</li><li><strong>广阔的水平横梁</strong>：建立一个高效的机制，以保持对新兴技术，特别是AI 领域的广泛、自适应的认知。</li></ol><h3id="精通技艺用费曼学习法实现深度理解">精通技艺：用费曼学习法实现深度理解</h3><p>需要掌握：</p><ol type="1"><li>计算机理论与编程范式：《计算机程序的构造和解释》。</li><li>编译器与语言原理：《用 go 语言自制解释器》、《用 go语言自制编译器》。</li><li>算法与数据结构：《业务开发算法 50讲》、《数据结构与算法之美》。</li><li>操作系统：《手写 OS》、《Writing an OS in Rust》。</li><li>软件工艺：《程序员的修炼：从优秀到卓越》。</li></ol><p>费曼学习法：</p><ol type="1"><li>选择一个概念；</li><li>尝试教会一个 12 岁的孩子。</li><li>识别理解的缺口。</li><li>回顾与简化。</li></ol><h3 id="水平横梁构建情报引擎-微实践">水平横梁：构建情报引擎 &amp;微实践</h3><p>优质信息源：</p><table><colgroup><col style="width: 20%" /><col style="width: 21%" /><col style="width: 3%" /><col style="width: 55%" /></colgroup><thead><tr><th>信息源名称</th><th>关注领域</th><th>频率</th><th>为何具有高信噪比</th></tr></thead><tbody><tr><td><strong>Benedict's Newsletter</strong></td><td>宏观科技战略与趋势</td><td>每周</td><td>由顶尖分析师提供深刻的行业洞察，帮助理解技术背后的商业逻辑</td></tr><tr><td><strong>The Pragmatic Engineer</strong></td><td>软件工程实践、文化、职业发展</td><td>每周</td><td>由前 Uber工程领导者撰写，提供来自一线的、深入的工程管理和技术决策分析</td></tr><tr><td><strong>TLDR Newsletter</strong></td><td>科技、编程、网络安全新闻摘要</td><td>每日</td><td>极其简明扼要，用几句话总结当日最重要的技术新闻，适合快速扫描</td></tr><tr><td><strong>Import AI</strong></td><td>AI 研究、政策与安全</td><td>每周</td><td>由 Anthropic 联合创始人策划，提供对 AI领域重大进展和伦理影响的专业解读</td></tr><tr><td><strong>ByteByteGo Newsletter</strong></td><td>系统设计与架构</td><td>每周</td><td>深入浅出地讲解复杂的系统设计概念，对后端工程师极具价值</td></tr></tbody></table><p>学习新技术的最佳方式是动手实践。然而，为了不影响核心的深度学习，这种实践必须是目标明确且时间受限的。这里引入"即时学习"（Just-in-TimeLearning）和"微问题解决"（Micro-Problem Solving）两个概念。</p><ul><li><p><strong>即时学习（JITLearning）</strong>：这是一种按需学习的模式，即在需要应用某项知识或技能时才去学习它，而不是进行大规模的预先学习。这种方式可以减轻认知负担，并将学习与实际应用紧密结合，从而提高知识留存率。</p></li><li><p><strong>玩具项目（ToyProjects）</strong>：当一个新技术（例如一个新的 AI 框架如 LangGraph或一个向量数据库）出现并显得重要时，为其分配一个严格限定时间的"玩具项目"，比如一个周末或几个晚上的时间。项目的目标不是构建一个生产级应用，而是通过动手实践，获得对该技术核心概念、API设计和工作流程的直观理解。</p></li><li><p><strong>微问题解决（Micro-ProblemSolving）</strong>：将玩具项目分解为一系列最小的可执行任务。例如，学习构建一个 RAG（检索增强生成）应用，可以分解为以下微问题：</p><ol type="1"><li>加载一篇 PDF 文档；</li><li>将文本分割成块（chunking）；</li><li>为文本块生成向量嵌入（embeddings）；</li><li>将嵌入存储到向量数据库；</li><li>根据用户查询检索最相关的文本块；</li><li>将检索到的内容与原始查询结合，生成最终答案 。</li></ol><p>这种分解使得学习过程manageable，并能提供持续的、小步快跑式的成就感。</p></li></ul><h3 id="拓展横梁认知-ai-产品生态系统">拓展横梁：认知 AI产品生态系统</h3><p>在 AI 时代，一名高级工程师的"广度"已不再局限于技术本身。由于 AI技术的选择（如模型、框架）直接影响到产品的成本、延迟、用户信任乃至商业模式，工程决策与商业战略的联系变得前所未有地紧密。</p><p>因此，现代工程师的 T 型横梁需要延伸至对 AI产品生态的理解。这包括：</p><ul><li><strong>AI 产品管理框架</strong>：了解如何识别和验证 AI用例，评估其商业价值、技术可行性和用户可用性 。</li><li><strong>AI 产品上市策略（GTM）</strong>：理解 AI产品，尤其是具有不确定性输出的概率性产品的市场定位、定价模型和营销渠道策略。</li><li><strong>构建可防御的"护城河"</strong>：明白在 AI技术本身易于复制的背景下，产品的长期竞争力更多地来自于专有数据、独特的工作流集成、强大的用户体验和生态系统。</li></ul><h3 id="时间管理深度工作与扫描协议">时间管理：深度工作与扫描协议</h3><p><strong>深度工作模块 (The Vertical Bar)</strong>：这是为 T型模型的"垂直支柱"——即基础原理学习——专门预留的时间。</p><ul><li><p><strong>方法</strong>：每周规划 2 到 3个<strong>不可协商的、时长为 2 小时的“深度工作”时间块</strong>。将这些时间块像对待最重要的会议一样标记在日历上，并告知团队成员在此期间除非紧急情况，否则不要打扰。</p><blockquote><p>认知科学研究表明，一次中断后，人需要平均 23分钟才能重新进入专注状态，对于复杂的编程任务，这个时间更长。因此，长时间、不受干扰的模块对于攻克 SICP 或 DDIA中的复杂概念至关重要。</p></blockquote></li></ul><p><strong>扫描与即时学习模块 (The Horizontal Bar)</strong>：这是为 T型模型的“水平横梁”——即技术雷达扫描和即时探索——设计的时间。</p><ul><li><strong>方法</strong>：安排更短、更频繁的时间块，例如<strong>每日30-45分钟</strong>，用于"扫描"活动。利用这段时间阅读筛选过的新闻通讯、浏览新技术发布、或推进你的"玩具项目"。这个协议的目的是防止对新技术的追逐侵占宝贵的深度工作时间。</li></ul><p><strong>任务批处理 (Task Batching)</strong>：</p><ul><li><strong>方法</strong>：将性质类似的"浅层工作"（shallowwork）归集在一起，在指定的时间块内一次性处理完毕。例如，将所有非紧急的邮件回复、代码审查（CodeReview）或行政事务集中在下午的某个固定时段处理。这可以有效减少任务切换带来的认知损耗，为深度工作保留宝贵的精力。</li></ul>]]></content>
    
    
    <summary type="html">本文探讨了在 AI 时代如何应对技术焦虑的问题。通过分析底层技术学习的必要性，提出了&quot;原则重于工具&quot;的核心观点，并构建了包含 T 型知识结构、时间盒管理、即时学习等策略的系统性解决方案，帮助工程师在技术海洋中找到方向，从焦虑走向成长。</summary>
    
    
    
    <category term="ai问答" scheme="https://hedon.top/categories/ai%E9%97%AE%E7%AD%94/"/>
    
    
    <category term="思考" scheme="https://hedon.top/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Q&amp;A丨在 AI 时代，还有必要学习底层技术吗？</title>
    <link href="https://hedon.top/2025/06/17/qa-should-learn-underlying-principles-in-ai-era/"/>
    <id>https://hedon.top/2025/06/17/qa-should-learn-underlying-principles-in-ai-era/</id>
    <published>2025-06-17T11:13:00.000Z</published>
    <updated>2025-06-20T19:04:29.938Z</updated>
    
    <content type="html"><![CDATA[<p>毫无疑问，<strong>绝对有必要，甚至比以往任何时候都更加重要。</strong></p><p>AI时代，应用层的技术和工具变得越来越“智能”和“易用”，这反而造成了一种危险的错觉：似乎我们不再需要理解那些复杂的底层原理了。但真相恰恰相反。</p><p>把自己想象成一位 F1 赛车手。AI工具就像一个极其先进的驾驶辅助系统，它能帮你自动换挡、优化过弯路线，甚至在某些直道上自动驾驶。这能让你开得更快，但如果你想成为冠军，你必须理解：</p><ul><li><strong>引擎的工作原理（操作系统、CPU）</strong>：为什么在某个转速下引擎会抖动？如何压榨出极限动力？</li><li><strong>空气动力学（网络、I/O）</strong>：为什么今天赛车感觉有点“飘”？是风向变了还是下压力调校出了问题？</li><li><strong>轮胎与悬挂（数据结构、数据库）</strong>：如何根据赛道温度和磨损情况选择轮胎？悬挂的软硬如何影响抓地力？</li></ul><p>只依赖驾驶辅助系统的车手，在赛车一切正常时表现尚可。一旦出现任何异常——轮胎异常磨损、引擎过热、通信系统延迟——他将束手无策，只能无奈退赛。而理解底层的车手，能通过细微的反馈感知到问题，与工程师沟通，调整策略，最终赢得比赛。</p><hr /><h3 id="五个无法回避的理由">五个无法回避的理由</h3><p>当你再对学习底层技术产生动摇时，请用以下几点来说服自己：</p><h4 id="抽象层终会泄漏底层知识是你的救生筏">1.抽象层终会“泄漏”，底层知识是你的救生筏</h4><p>这是软件工程颠扑不破的“<strong>抽象泄漏定律</strong>”（The Law ofLeaky Abstractions）。任何为了简化而存在的上层工具（包括AI），都无法完美隐藏其底层的复杂性。当问题发生时，这个“泄漏”就会出现。</p><ul><li><strong>场景 A</strong>：AI帮你生成了一段代码，用于从数据库查询数据，但在生产环境压力下响应极慢。AI无法告诉你原因是索引失效、发生了锁竞争还是因为 N+1查询。这时，你需要<strong>数据库底层知识</strong>来分析执行计划、优化索引。</li><li><strong>场景 B</strong>：一个由 AI 调度的微服务出现随机性高延迟。AI无法告诉你这是因为容器的 CPU 被限制、发生了网络丢包，还是因为 JVM的垃圾回收（GC）暂停。这时，你需要<strong>操作系统和网络的底层知识</strong>来定位根源。</li><li><strong>场景 C</strong>：你的 RAG 应用召回结果不理想。AI无法告诉你是因为向量嵌入模型选择不当，还是向量数据库的索引策略（如HNSW）参数需要调优。这需要你理解<strong>数据结构和算法</strong>。</li></ul><p><strong>说服自己：当 AI 失灵或表现不佳时，能拯救你的不是另一个AI，而是你对底层的掌控力。</strong></p><h4 id="问题的根源往往深藏于你看不到的地方">2.问题的根源，往往深藏于你看不到的地方</h4><p>高级的故障排查（Troubleshooting）是后端工程师的核心价值之一。问题的表象（Symptom）和根源（RootCause）往往不在同一个层面。</p><ul><li>一个 API 超时，表象是应用层错误。根源可能是 TCP 连接池耗尽、是 DNS解析缓慢、是磁盘 I/O 达到瓶颈。</li><li>AI 可以帮你分析日志，找到那个超时的API。但它很难跨越多个技术栈，将零散的线索串联起来，形成一个完整的证据链，最终定位到那个深藏的根源。这种系统性的诊断能力，源于你脑中那张完整的技术底层地图。</li></ul><p><strong>说服自己：只懂“驾驶”的人在车坏了时只能打电话求助，而懂“机械”的人能自己打开发动机盖解决问题。我要做后者。</strong></p><h4 id="真正的工程判断力建立在对权衡trade-off的理解之上">3.真正的工程判断力，建立在对权衡（Trade-off）的理解之上</h4><p>AI 可以提供“方案”，但无法为你做出最佳的“决策”。工程的核心是权衡。</p><ul><li>用关系型数据库还是 NoSQL？用 Redis 还是本地缓存？服务间通信用 gRPC还是 RESTful API？</li><li>每一个选择背后，都是对性能、成本、一致性、可用性、开发效率等一系列因素的综合考量。而这些考量的依据，正是来自你对各种技术底层实现机制的理解。不了解TCP 和 HTTP/2 的底层差异，你如何能在 gRPC 和 REST之间做出最合理的选择？不了解 B+树和 LSM树，你如何为特定场景选择最合适的数据库？</li></ul><p><strong>说服自己：AI可以成为我的顾问，但最终做出决策、并为之负责的人是我。我的决策质量，直接取决于我的底层知识深度。</strong></p><h4 id="你的职业天花板由底层知识决定">4.你的职业天花板，由底层知识决定</h4><p>随着 AI自动化掉越来越多重复性的、模式化的编码工作，未来后端工程师的价值会更加向两个方向集中：</p><ul><li><strong>向上</strong>：深入理解业务，进行业务建模和架构设计。</li><li><strong>向下</strong>：解决硬核的技术难题，进行极致的性能优化和系统稳定性保障。</li></ul><p>这两个方向，都极度依赖底层技术。没有底层知识，你的架构设计就是空中楼阁；没有底层知识，你永远无法成为解决最棘手问题的那个关键人物。</p><p><strong>说服自己：AI会拉平初级和中级工程师的差距，但底层技术功底是区分高级/资深工程师与普通工程师的护城河。</strong></p><h4 id="创新源于对第一性原理的掌握">5. 创新，源于对第一性原理的掌握</h4><p>我们使用的所有 AI工具、框架、平台，本身就是由那些深刻理解底层技术的人创造出来的。他们不是简单地“使用”技术，而是基于对计算、存储、网络等第一性原理的理解，去“创造”新的技术。</p><p>如果你满足于只做一个技术的使用者，或许可以忽略底层。但如果你心中还有一丝火花，想在技术的世界里留下自己的印记，想创造出真正有价值的东西，那么掌握底层就是你唯一的路径。</p><p><strong>说服自己：学习底层技术，不仅是为了解决今天的问题，更是为了获得解决明天未知问题、甚至定义未来的能力。</strong></p><hr /><h3 id="结论如何平衡学习">结论：如何平衡学习</h3><p>这并非要求你立刻放下所有 AI学习，去埋头啃《计算机程序的构造和解释》。正确的做法是：</p><ul><li><strong>保持“T 型”结构</strong>：在积极拥抱和学习 AI这个横向技能的同时，有计划地、持续地加深你的纵向底层知识。</li><li><strong>问题驱动学习</strong>：在应用 AI或开发业务时，遇到任何性能、稳定性、或“匪夷所思”的问题，都不要轻易放过。把它当作一个深入学习底层技术的绝佳契机。从“为什么会这样？”开始，一路向下挖掘，直到你触及问题的本质。</li></ul><p>AI时代，底层技术不是你的“备选项”，而是你的“压舱石”。它能让你的技术大船在AI 的巨浪中，行得更稳、更快、更远。</p>]]></content>
    
    
    <summary type="html">本文讨论了在 AI 时代继续扎根学习底层技术的重要性，并给出 5 个说服自己的理由。</summary>
    
    
    
    <category term="ai问答" scheme="https://hedon.top/categories/ai%E9%97%AE%E7%AD%94/"/>
    
    
    <category term="思考" scheme="https://hedon.top/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《Rust Atomics and Locks》</title>
    <link href="https://hedon.top/2025/06/12/note-rust-atomics-and-locks/"/>
    <id>https://hedon.top/2025/06/12/note-rust-atomics-and-locks/</id>
    <published>2025-06-12T01:01:24.000Z</published>
    <updated>2025-06-12T17:41:59.228Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><ahref="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust实战丨手写一个 SpinLock</a></li><li><ahref="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust实战丨手写一个 RwLock</a></li><li><ahref="https://hedon.top/2025/06/12/note-rust-atomics-and-locks/">读书笔记丨《RustAtomics and Locks》</a>👈 本篇</li></ul><hr /><p>本文整理总结 <em>Mara Bos</em> 所著《Rust Atomics andLocks》一书的核心内容，系统归纳 Rust并发编程中原子操作与锁机制的关键概念和技术细节。内容涵盖原子操作与内存顺序、Rust并发的基础工具（内部可变性、线程安全保证、操作系统并发原语），以及多种常用并发原语（自旋锁、一次性通道、原子引用计数、互斥锁、条件变量、读写锁）的实现要点。通过这些内容的串联，展示概念之间的联系、底层原理、Rust标准库实现方式与实际工程实践的关系，方便读者快速回顾并用作知识索引。</p><h2 id="原子操作基础">原子操作基础</h2><p>Rust 提供了一系列<strong>原子类型</strong>（如<code>AtomicBool</code>、<code>AtomicUsize</code>等）来实现线程之间的<strong>无锁并发</strong>数据共享。对原子类型的操作分为三大类别：</p><ul><li><strong>Load（加载）</strong> 与<strong>Store（存储）</strong>：分别用于原子地读取和写入值。</li><li><strong>Fetch-and-Modify（获取并修改）</strong>：在返回旧值的同时，原子地对值进行修改，例如<code>fetch_add</code>、<code>fetch_sub</code>、<code>fetch_or</code>、<code>fetch_and</code>、<code>fetch_xor</code>、<code>swap</code>等。</li><li><strong>Compare-and-Exchange（比较并交换）</strong>：即原子地执行“如果当前值等于预期值则交换”的操作，包括<code>compare_exchange</code> 和<code>compare_exchange_weak</code>。</li></ul><p>不同计算机体系结构对原子操作的支持方式有所差异，主要体现在<strong>指令集类别</strong>和<strong>内存模型</strong>上。现代CPU通常分为两种指令集架构：</p><ul><li><strong>CISC（复杂指令集）</strong>：典型代表是 x86 架构（包括x86-64）。CISC指令集功能丰富、单条指令可执行复杂操作，但硬件实现复杂。x86-64 是基于CISC 的 64 位扩展架构，由 AMD设计主导，追求通过硬件复杂性换取高性能和广泛兼容性，主导了桌面与服务器领域。</li><li><strong>RISC（精简指令集）</strong>：典型代表是 ARM 架构（如ARM64）。RISC指令集精简、每条指令功能单一，硬件实现相对简单且能效更高。ARM64 基于RISC 的 64 位架构，由 ARM设计，指令简洁、低功耗，在移动设备占主导地位并逐步进入服务器和 PC领域。</li></ul><p><strong>原子性的实现机制：</strong> 在 x86-64上，保证原子性的关键是使用 <code>lock</code>前缀锁定总线或缓存行来原子执行指令；而在 ARM64 上，则依赖Load-Linked/Store-Conditional（<strong>LL/SC</strong>）指令对实现原子操作。例如，x86上原子的 compare-and-swap 通常通过 <code>LOCK CMPXCHG</code>指令完成，而 ARM上通过一对原子链式的加载/存储指令完成。如果处理器不支持所需的原子指令，Rust会在编译期报错以防止不安全的并发操作。</p><p><strong>内存序模型差异：</strong> 不同架构的内存序保证也不同。x86-64属于<strong>强顺序</strong>（Total Store Order,TSO）模型，对内存操作的重排序有限制，而 ARM64属于<strong>弱顺序</strong>模型，需要显式的内存屏障来保证顺序。具体来说，x86-64默认禁止以下重排序：</p><ul><li><strong>Load → 后续操作</strong>不允许乱序：例如在同一线程中，先执行的读取不能被后执行的操作越过。</li><li><strong>Store → 前序操作</strong>不允许乱序：一个存储不能提前到先前未执行完的操作之前。</li><li><strong>Store → 随后的 Load</strong>则<strong>可能</strong>乱序：即一个存储操作后紧跟的加载操作在实际执行中可能被处理器提升到存储之前执行（典型的Store-Load 重排）。</li></ul><p>相比之下，ARM等弱序模型中，大多数内存操作在缺乏同步指令时都可能被重排序，因此所有原子操作默认<strong>可能乱序</strong>，需要利用内存屏障指令（ARM上如<code>dmb ish</code>、<code>dmb ishld</code>）来提供顺序保证。此外，在compare-and-exchange 操作上，x86-64并未提供真正的“弱”版本（即不会出现无故失败的情况），因而 Rust 中的<code>compare_exchange_weak</code> 在 x86 上实际上与强语义等价；而 ARM64的 LL/SC 实现存在可能的自发失败，因此区分了 weak版本以便需要时重试。</p><p>综上，<strong>硬件架构对原子操作的支持</strong>直接影响Rust并发库的实现策略：在强序的x86 上，一些内存序保证可由硬件天然提供，而在弱序的 ARM上则必须借助显式屏障指令来达成。Rust的原子类型实现会针对不同架构插入相应的汇编指令，以确保提供声明的原子性和内存序语义。</p><h2 id="内存顺序与内存模型">内存顺序与内存模型</h2><p>多线程环境下面临两大核心问题：</p><ol type="1"><li><strong>指令乱序执行（Out-of-OrderExecution）</strong>：现代CPU会对指令进行乱序执行和优化，这可能导致程序实际执行顺序与源码顺序不一致。</li><li><strong>跨线程内存可见性</strong>：不同线程对内存修改的可见性无法保证——一个线程写入的数据，何时及如何对其他线程可见，需要通过同步手段来控制。</li></ol><p>为解决上述问题，需要了解内存模型中的两类关键顺序关系：</p><ul><li><strong>Sequenced-Before（先行顺序）</strong>：描述单个线程内操作的先后顺序。按照程序中的先后关系确定，在同一线程内如果操作A 在源码中位于操作 B 之前，那么 A <em>sequenced-before</em>B。先行顺序遵循以下规则：若操作 B 数据依赖于 A，则 A 必定在 B之前执行；针对同一原子变量的操作按程序顺序执行；若两个独立操作无数据依赖且访问不同变量，那么处理器可能对它们重排。总之，先行顺序限定单线程的执行次序，为编译器和CPU 提供本线程内优化的依据。</li><li><strong>Happens-Before（先发生）</strong>：描述跨线程的操作顺序和可见性。如果操作A <em>happens-before</em> 操作 B，意味着 A 的所有内存效果对于 B是可见的。Happens-Before建立在线程间的同步关系上，例如：在同一线程中，函数 <code>f()</code>调用在前而 <code>g()</code> 在后，则 <code>f()</code> happens-before<code>g()</code>；一个线程调用 <code>thread::spawn</code>创建新线程发生在对该新线程的 <code>join</code>之前；再如互斥锁的<strong>加锁</strong>先于<strong>解锁</strong>操作（unlock发生在 lock 之前释放锁的线程完成临界区之后）。这些 Happens-Before规则确保了特定事件的<strong>跨线程可见性</strong>和执行顺序。</li></ul><p>Rust 的原子操作支持五种内存顺序（<code>Ordering</code>枚举），从最松弛到最严格依次为<strong>Relaxed</strong>、<strong>Release</strong>、<strong>Acquire</strong>、<strong>AcqRel</strong>、<strong>SeqCst</strong>。不同的内存顺序决定了原子操作在乱序和可见性方面的保证强度。下表总结了它们的语义、保证、使用场景和示例：</p><table><colgroup><col style="width: 5%" /><col style="width: 11%" /><col style="width: 30%" /><col style="width: 30%" /><col style="width: 21%" /></colgroup><thead><tr><th>内存顺序</th><th>说明</th><th>保证</th><th>适用场景</th><th>示例</th></tr></thead><tbody><tr><td><strong>Relaxed</strong></td><td>最宽松的内存顺序</td><td>- 仅保证操作的原子性<br>- 不提供任何同步保证<br>- 不建立happens-before 关系</td><td>- 简单计数器- 极高性能要求且确定不需要跨线程同步<br/>-已通过其他方式确保数据可见性同步</td><td><code>counter.fetch_add(1, Ordering::Relaxed)</code></td></tr><tr><td><strong>Release</strong></td><td>用于存储操作</td><td>- 此操作之前的所有内存访问不会被重排到它之后<br/>- 与后续线程的Acquire 操作配对可建立 happens-before 关系</td><td>- 典型“生产者-消费者”模型- 发布共享数据给其他线程<br/>-写入一个“初始化完成”标志</td><td><code>data.store(val, Ordering::Release)</code></td></tr><tr><td><strong>Acquire</strong></td><td>用于加载操作</td><td>- 此操作之后的所有内存访问不会被重排到它之前<br/>-与另一个线程先前的 Release 操作配对可建立 happens-before 关系</td><td>- “生产者-消费者”模型中获取数据-读取共享数据（需确保数据已由其他线程准备好）<br/>-检查某个初始化完成的标志</td><td><code>let val = data.load(Ordering::Acquire)</code></td></tr><tr><td><strong>AcqRel</strong></td><td>读改写操作的组合语义</td><td>- 同时具有 Acquire 和 Release 的所有内存顺序保证<br/>-只能用于原子读-改-写操作（RMW），对读取部分提供 Acquire保证，对写入部分提供 Release 保证</td><td>- 需要双向内存同步的原子操作v-实现锁等同步原语（例如原子自增既读取又写入）<br/>-较复杂的原子同步场景</td><td><code>value.fetch_add(1, Ordering::AcqRel)</code></td></tr><tr><td><strong>SeqCst</strong></td><td>全局顺序一致的最强顺序</td><td>- 包含 AcqRel 的所有保证<br/>- <strong>所有线程</strong>对所有SeqCst 原子操作的观察顺序一致（总排序）<br/>-提供跨线程全局的内存顺序一致性</td><td>- 需要严格的全局一致性场景<br/>-不确定使用哪种顺序时采用（保守策略）<br/>- 对性能要求不敏感的代码</td><td><code>flag.store(true, Ordering::SeqCst)</code></td></tr></tbody></table><p>需要注意的是，<strong>Release</strong> 通常与<strong>Acquire</strong> 搭配使用，共同建立线程间的同步关系。当线程 A使用 Release 语义写入某个共享变量，线程 B 之后使用 Acquire语义读取到了该值，那么可以保证：线程 A 中那次 Release写入之前的所有内存写操作，对线程 B 在 Acquire读取之后的所有操作都是可见的。换言之，通过 Release-Acquire的配对建立了跨线程的<em>happens-before</em>：生产者线程写入的数据对消费者线程可见。这就是典型的生产者-消费者模式同步的原理。例如，一个线程完成初始化后将标志位设为true（Release），另一个线程反复以 Acquire 读取该标志，当读到 true时即可安全地读取之前初始化的数据。</p><p>另一个重要概念是 <strong>释放序列（ReleaseSequence）</strong>。释放序列指的是：“以一次 Release操作为开头，紧跟其后的、在同一原子变量上的所有<strong>同一线程</strong>的写操作或读改写操作（RMW），共同形成一个连续序列”。如果某线程在Acquire 读取时读到了这个序列中的任意一个写，那么该 Acquire将和序列开头的那次 Release 建立同步关系。简单理解，Release 序列涵盖了Release 写入线程接下来对同一原子变量的后续修改，以及可能由其他线程执行的RMW 操作，从而确保 Acquire 端读取到序列中任何结果时，都能看到序列开头Release 之前的所有内存效果。</p><p>底层实现上，编译器和CPU通过<strong>内存屏障（MemoryBarrier）</strong>指令来实现上述内存顺序保证。主要有三类内存屏障：</p><ol type="1"><li><strong>读屏障（LoadBarrier）</strong>：确保屏障之前的所有读操作都已完成，并阻止后续读操作提前执行（即后面的读不会跑到屏障之前）。这相当于Acquire 语义的效果，在很多架构上，Acquire Load会在汇编层插入读屏障指令或使用带Acquire语义的特殊读指令。</li><li><strong>写屏障（StoreBarrier）</strong>：确保屏障之前的所有写操作都已对内存可见，并阻止后续写操作提前执行（不让后面的写越到屏障之前）。这对应Release 语义，Release Store常通过写屏障指令或带Release语义的原子写指令实现。</li><li><strong>全屏障（FullBarrier）</strong>：同时具有读屏障和写屏障效果，禁止任何读或写的重排序。这通常用于SeqCst 场景，确保全局一致的内存顺序。在 x86 上 <code>MFENCE</code>指令就是一个全屏障，而 ARM 上则需要 <code>DMB ISH</code>等全内存屏障指令来达到 SeqCst 效果。</li></ol><p>通过合理选择内存顺序和屏障，程序员可以在性能和内存可见性保证之间取得平衡：在确保数据跨线程可见性和操作顺序正确的前提下，尽量减少不必要的开销。</p><h2 id="rust-并发的基础工具">Rust 并发的基础工具</h2><h3 id="unsafecell内部可变性的支柱">UnsafeCell：内部可变性的支柱</h3><p>Rust的所有权和借用规则在编译期就保证了单线程情况下的数据安全，例如通过不可变引用<code>&amp;T</code> 阻止对数据的修改，通过可变引用<code>&amp;mut T</code>确保独占访问。然而，在实现并发数据结构时，经常需要突破这一限制：比如在只有不可变引用的情况下也能修改内部数据（典型场景是通过锁对象的不可变引用来获取内部数据的可变引用）。为此，Rust提供了一个底层机制 <strong>UnsafeCell</strong>来支持<em>内部可变性</em>。</p><p><strong>UnsafeCell</strong> 是 Rust标准库中的一个关键类型，它包装了一个数据，使得即使只有对该容器的不可变引用，也可以通过UnsafeCell 提供的方法来修改内部的数据。当然，这种内部修改必须在<code>unsafe</code>块中进行，因为它突破了编译器的借用检查。很多线程同步原语（例如<code>Mutex</code>、<code>RwLock</code>，甚至原子类型如<code>AtomicBool</code> 本身）内部都使用了 UnsafeCell来绕过编译期的限制，从而允许在并发场景下安全地修改受保护的数据。</p><p>基于 UnsafeCell，Rust标准库封装了几种提供不同程度内部可变性的类型：</p><ul><li><strong>Cell</strong>：提供最小程度的内部可变性，只能用于复制语义的类型（实现<code>Copy</code> 的类型）。通过 <code>get</code> 和 <code>set</code>方法在不违反借用规则的情况下读取或修改内部的值。</li><li><strong>RefCell</strong>：提供<em>运行时</em>的借用检查，实现更灵活的内部可变性，可以在运行时确保不可变借用和可变借用的不混淆。但<code>RefCell</code> 不是线程安全的（不实现<code>Sync</code>），只能用于单线程场景。</li><li><strong>Mutex</strong>：它利用锁机制保证线程安全的内部可变性。Mutex本质上也是通过 UnsafeCell允许内部数据可变访问，但同时提供了线程间互斥保护。相应地，Mutex的使用成本较高，需要在多线程间进行加锁和解锁的开销。</li></ul><p>通过 UnsafeCell 提供的内部可变性支撑，Rust才能编写出安全的并发数据结构。在这些结构中，我们将看到 UnsafeCell的身影，它保证了在编译器视角下“不可能”的行为（即在不可变引用下修改数据）在运行时被合理地使用。</p><h3 id="send-与-sync无数据竞争的基石">Send 与Sync：无数据竞争的基石</h3><p>Rust 类型系统通过两个重要的<em>标记 trait</em>（MarkerTrait）来实现<strong>线程安全</strong>的静态检查，这两个 trait 就是<strong>Send</strong> 和<strong>Sync</strong>。它们没有具体的方法，实现这两个 trait的类型会自动享有编译器的特殊处理，用于标记跨线程的使用安全性：</p><ul><li><strong>Send</strong>表示一个类型的所有权可以在线程间安全地传递。如果类型 <code>T</code>实现了 Send，则 <code>T</code> 或 <code>&amp;mut T</code>可以从一个线程转移到另一个线程。例如，大部分基础类型和完全由 Send组成的复合类型都是Send。如果某个类型内部包含不安全的共享状态且未保护，那它可能不会实现Send（编译器会自动推导决定，开发者也可手动禁止）。</li><li><strong>Sync</strong>表示一个类型的<strong>不可变引用</strong>可以在线程间安全共享。也就是说，如果<code>&amp;T</code> 实现了Sync，则允许多个线程同时拥有对该类型的不可变引用。这要求类型内部的所有可能被并发访问的可变状态都已经被保护（比如用了原子或锁）。大部分基本类型的不可变引用都是Sync，像 <code>&amp;i32</code> 等是可以多线程共享的。如果某类型不是Sync，则即使它本身是只读的，也无法同时被多个线程引用（例如<code>Rc&lt;T&gt;</code> 因为不是线程安全的引用计数，因此<code>&amp;Rc&lt;T&gt;</code> 也不是 Sync）。</li></ul><p>Send 和 Sync 这两个标记 trait 是 Rust 保证无数据竞争（Data RaceFree）的基石。编译器通过这两个trait禁止不安全的跨线程操作：任何在多个线程间共享或转移的值必须是Send/Sync的，否则将无法编译。这种机制在编译期就杜绝了绝大部分数据竞争情况，开发者只有在显式使用<code>unsafe</code>绕过时才可能违背这个保证。因此，在实现并发原语时，确保正确实现Send/Sync（或适当地禁止它们）是非常重要的。Rust 标准库多数类型默认实现Send/Sync（如果其组成部分实现的话），但像<code>Rc&lt;T&gt;</code>（非线程安全引用计数）或<code>RefCell&lt;T&gt;</code>（仅供单线程内部可变性）则没有实现，以防误用。</p><h3id="操作系统并发原语原子等待与唤醒">操作系统并发原语：原子等待与唤醒</h3><p>高效的阻塞式并发离不开操作系统提供的底层同步原语。目前主流的桌面/服务器操作系统（如Linux、macOS、Windows）都提供了类似的原子等待/唤醒机制，以构建更高级的锁和并发结构。这些机制允许线程在等待某个条件时挂起睡眠，避免忙轮询浪费CPU，并在条件达成时高效地被唤醒。概括来说，有三个最重要的底层操作：</p><ul><li><strong>wait( &amp;AtomicU32, expected_value)</strong>：当指定的原子变量值等于给定期待值时，让当前线程陷入休眠等待；如果原子值不匹配则立即返回。这个操作通常是原子级的检查并挂起，如Linux 上的 <code>futex</code> 系统调用 (<code>futex_wait</code>) 或Windows 上的 <code>WaitOnAddress</code>等，它们允许用户态线程在内核中高效睡眠，等待变量改变。</li><li><strong>wake_one( &amp;AtomicU32)</strong>：唤醒<strong>一个</strong>在指定原子变量上等待的线程。对应地，Linuxfutex 提供 <code>futex_wake</code>可以唤醒等待在同一个地址上的一个线程；Windows 提供<code>WakeByAddressSingle</code> 等。</li><li><strong>wake_all( &amp;AtomicU32)</strong>：唤醒<strong>所有</strong>在该原子变量上等待的线程。对应futex 的 <code>wake</code> 可以指定唤醒所有等待的线程，Windows 有<code>WakeByAddressAll</code> 等。</li></ul><p>这些原语本质上将<strong>原子变量的变化</strong>和<strong>线程调度</strong>结合起来，实现了类似“当原子变量处于某值时让线程睡眠，直到变量改变再唤醒”的机制。这为构建更高级的同步工具奠定了基础：例如 Mutex在获取不到锁时，可以调用 wait挂起线程等待锁的原子标志变为可用；当释放锁时，调用 wake_one唤醒一个等待线程继续争夺锁。相比纯用户态的自旋，这种机制大幅提高了效率，因为等待线程无需占用CPU。Rust 标准库的实现以及第三方并发库（如<code>parking_lot</code>）都会利用操作系统提供的此类原语（在 Linux上通常就是futex，在其他平台可能用条件变量等模拟）来实现高性能的阻塞同步。</p><p>本书的示例实现中多次使用了 <code>atomic-wait</code> crate 来模拟futex 等行为，以便在稳定版上构建自定义锁。</p><h2 id="自旋锁spinlock">自旋锁（SpinLock）</h2><p><strong>自旋锁</strong>是一种最简单的锁实现，其特性是当一个线程尝试获取锁而锁已被占用时，该线程不会阻塞睡眠，而是在循环中反复检查锁是否可用（“忙等待”）。自旋锁避免了线程切换的开销，适用于临界区极短、锁持有时间非常小的场景，因为忙等待会浪费CPU时间。如果临界区较长，使用自旋锁会导致CPU空转浪费资源，此时应采用会阻塞线程的锁（如Mutex）。Rust标准库并未提供显式的自旋锁类型，但可以使用原子操作很容易地实现一个。书中通过实现一个简化的SpinLock 展示了原子操作和 RAII 等在并发中的应用：</p><ul><li><strong>v0：最小化原子标记的实现</strong> –采用一个原子布尔标志表示锁状态（如<code>AtomicBool</code>），最初版本只实现了基本的 <code>lock()</code> 和<code>unlock()</code>。当标志从 <code>false</code> 变为<code>true</code> 表示获取锁成功。线程获取锁时使用原子交换(<code>swap</code>) 将标志设为true，并在获取失败时不断重试（忙等）。该版本功能最小，不负责保护任何数据。</li><li><strong>v1：绑定受保护数据</strong> –将锁和需要保护的数据封装在一起，定义为如<code>SpinLock&lt;T&gt;</code>，内部持有一个<code>UnsafeCell&lt;T&gt;</code>来存储数据。这保证了数据只能通过获取锁后才能访问，提升了数据安全性。接口上提供<code>lock()</code> 返回一个包裹了 <code>&amp;mut T</code>的锁守卫类型，以确保在持有锁期间才能访问内部数据。</li><li><strong>v2：引入 RAII 实现自动解锁</strong> – 利用 Rust 的RAII（Resource Acquisition Is Initialization）惯用法，返回一个锁守卫（如<code>SpinLockGuard</code>），其 <code>Drop</code>实现中自动调用解锁操作。这样，当锁守卫离开作用域时（不论是正常离开还是因为panic 等非常路径），都能确保锁被正确释放，不必依赖用户手动调用<code>unlock()</code>。这一版本显著提高了易用性和安全性，防止了因忘记解锁导致的死锁。</li></ul><p>通过这三个版本的迭代，我们看到了从<strong>低级原子操作</strong>构建锁的基本过程，以及<strong>RAII模式</strong>在确保资源释放中的威力。自旋锁虽然简单，但在Rust并发中并不作为公开接口广泛使用，更多是用于底层实现。例如标准库Mutex在短暂自旋优化时内部也会自旋尝试锁，以减少进入内核的机会。一般来说，高层代码应尽量使用更高级的Mutex而非自旋锁，除非在非常性能敏感且确定临界区极短的场景下才考虑自旋锁。</p><h2 id="一次性通道one-shot-channel">一次性通道（One-shot Channel）</h2><p><strong>一次性通道</strong>指的是只发送一次消息并被接收一次的通信通道。它可以理解为只能容纳单个消息的生产者-消费者队列，在某些场景下（例如线程初始化后将结果发送给主线程）非常有用。Rust标准库提供的 <code>std::sync::mpsc</code>通道是多次发送的通用通道，而一次性通道可以做特别的优化。书中通过多个版本构建了一个一次性通道，以展示<strong>锁与无锁编程</strong>、<strong>内存管理</strong>以及<strong>线程同步</strong>的技巧：</p><ul><li><strong>v0：基于互斥锁的简单通道</strong> –首先实现一个通用版本，内部用 <code>Mutex</code> + <code>Condvar</code>等构造一个能发送任意条消息的通道，然后限制只发送一次。这是最直接的实现，但完全依赖锁，性能较低。</li><li><strong>v1：引入 UnsafeCell 与 AtomicBool 去锁化</strong> –利用内部可变性和原子操作，实现一个无锁的一次性通道。使用<code>AtomicBool</code> 标志消息是否已被接收，<code>UnsafeCell</code>存放实际消息数据，实现 send 时设置数据和标志位，recv时读取数据。通过原子操作保证发送和接收的同步，不再使用锁，从而减少开销。</li><li><strong>v2：使用 <code>MaybeUninit&lt;T&gt;</code> 代替<code>Option&lt;T&gt;</code></strong> –优化内存布局。由于一次性通道中的消息在发送前不存在，发送后存在，而Option构造会在内存中额外存储一个枚举标志，占用空间且可能导致不必要的初始化检查。改用<code>MaybeUninit</code>后，只在内存中保留消息所需空间，避免了初始化与未初始化状态的双重判断，减少内存开销。</li><li><strong>v3：增加动态检查以提高安全性</strong> –在发送和接收操作中增加运行时检查，以确保不会出现重复发送、重复接收等误用情况。例如，如果重复调用send 就立即 panic，防止破坏内部状态。这些检查提升了组件的健壮性。</li><li><strong>v4：实现 <code>Drop</code> Trait 以自动清理</strong> –为通道的发送端和接收端实现<code>Drop</code>，在对象被销毁时自动清理未被接收的值或通知另一端。这样可以避免内存泄漏，并在接收端丢弃前通知发送端等，提高使用时的正确性。</li><li><strong>v5：拆分 Sender 和 Receiver 类型</strong> –将通道的发送者和接收者角色分开成不同的类型，确保编译层面对各自操作的权限限制。例如Sender 只能发送不能接收，Receiver只能接收不能发送。这一版本还通过类型系统防范了一些误用（如接收端克隆等）。</li><li><strong>v6：用生命周期替代 Arc，消除引用计数开销</strong> –之前版本为了让 Sender 和 Receiver 在不同线程中存在，可能使用了<code>Arc</code>来共享通道内部状态。然而在一次性通道中，发送和接收两者的作用域其实可以静态地确定（如在线程函数中先发送后接收）。通过引入Rust 的生命周期参数，将通道限定在创建它的作用域内传递引用，而非通过Arc，在编译期保证了内存安全的同时，免去了原子引用计数的运行时开销。</li><li><strong>v7：使用线程停放（park/unpark）机制，实现阻塞等待</strong> –先前版本的接收操作可能需要不停查询标志（自旋等待消息就绪），v7 引入了Rust 标准库的 <code>park()</code>/<code>unpark()</code>机制：当接收端发现消息尚未准备好时，调用 <code>thread::park</code>挂起当前线程；发送端在放入消息后调用接收线程的句柄的 <code>unpark</code>来唤醒它。这种做法避免了忙等占用CPU，转而让线程阻塞等待，提升效率。同时通过去掉先前用于轮询的如<code>is_ready</code> 标志，使误用的可能性进一步降低。</li><li><strong>v8：使用 PhantomData 防止跨线程误用</strong> – 最终版本利用PhantomData 标记保证类型安全。通过在 Sender/Receiver中加入带有生命周期或非 Send/Sync 标记的PhantomData，编译器可以禁止用户将 Sender/Receiver在不安全的方式跨线程使用。例如，可以防止 Sender/Receiver被不恰当地发送到其他线程导致未定义行为。PhantomData不占用空间，但可以在类型系统中充当标记，确保一次性通道的用法受到静态约束，彻底封堵错误用法。</li></ul><p>经过上述多次迭代，一次性通道从最初的锁实现逐步演进为<strong>无锁</strong>且<strong>高效</strong>的实现，并且在类型系统层面保证了安全使用。这个过程展示了Rust并发编程从<strong>简单正确</strong>到<strong>性能优化</strong>再到<strong>类型安全</strong>的完整思路。在实际工程中，类似的思想被用于实现各种高性能通道和同步数据结构，如Rust 标准库和 <code>crossbeam</code> 库中的通道实现等。</p><h2 id="arc-原子引用计数智能指针">Arc 原子引用计数智能指针</h2><p><strong>Arc</strong>（Atomically Reference Counted）是 Rust标准库提供的多线程引用计数智能指针类型，允许在多个线程间共享所有权。通过原子增减引用计数，Arc能确保即使多个线程同时持有指针，底层数据也只会在最后一个指针被释放后销毁。书中通过实现一个简化版的Arc 及其改进版本，解释了 Arc 的工作原理和演进：</p><ul><li><strong>v0：基础版本，单原子计数的多所有权</strong> –使用一个原子计数器（如 <code>AtomicUsize</code>）记录引用数，每次克隆Arc增加计数，删除时减少计数，减到零时销毁数据。这个版本实现了跨线程的多所有权共享。然而，此时Arc依然缺乏两方面能力：<strong>内部可变性</strong>（无法获得可变引用去修改内部数据），以及<strong>防止循环引用</strong>（如果两个Arc 相互引用会导致计数永不为零，内存泄漏）。</li><li><strong>v1：引入独占借用 <code>&amp;mut Arc&lt;T&gt;</code>及内部锁，实现可变访问</strong> – 标准库的 Arc并不支持在存在多个引用时直接获得内部数据的可变引用，但本书尝试了一个改进思路：当我们持有Arc 的独占引用 <code>&amp;mut Arc&lt;T&gt;</code> 时（意味着当前线程拥有Arc 对象的独占管理权，没有其他 Arc克隆存在），可以安全地修改内部数据。为此，v1 在 Arc内部增加了一把原子锁或标志，用于在独占修改内部数据时临时阻止其他线程的访问。从而提供一个安全的<code>get_mut()</code>方法：当检测到当前只有一个强引用且锁定成功时，返回内部数据的可变引用。这实现了<strong>条件下的内部可变性</strong>：在不破坏线程安全的前提下，允许独占Arc 进行内部修改。</li><li><strong>v2：加入弱引用（Weak）以解决循环引用问题</strong> – 弱引用是Arc 非常重要的补充。Weak指针不计入强引用计数，因此不会阻止数据被回收。v2 引入<code>Weak&lt;T&gt;</code> 类型，当需要引用可能形成环的对象时，用 Weak替代 Arc中的一部分引用关系。这样即使对象之间形成环，相互的弱引用不会使强计数增加到无法归零，一旦没有强引用，数据可以正确释放。Weak指针需要通过 <code>upgrade()</code> 尝试提升为 Arc使用，在数据已被释放时会得到<code>None</code>，从而避免了悬垂引用。</li><li><strong>v3：区分强引用计数和弱引用计数，优化无循环场景性能</strong>– 在 v2 基础上，v3将引用计数拆分为两个独立的计数：强引用计数和弱引用计数。强计数为 0时表示数据可销毁，但实际销毁要等弱计数也为 0（表示没有悬挂的 Weak指针）。通过分离计数，Arc 在没有 Weak场景下也不需要去增减弱计数，减少了不必要的开销。只有在存在 Weak的情况下才维护弱计数。这一优化与实际 Rust 标准库 Arc 的实现一致：标准库Arc在内部使用两个计数（一个原子usize记录强引用数，一个记录弱引用数），并据此管理内存回收。</li></ul><p>Arc智能指针的实现展示了<strong>原子操作在内存管理中的应用</strong>。由于使用了原子引用计数，Arc的克隆、释放可以由多线程安全地执行。此外，引入 Weak指针解决循环引用、双计数优化性能等设计，都是实际工业级智能指针需要考虑的问题。Rust标准库的 <code>Arc&lt;T&gt;</code>正是采用类似机制，保证了线程安全又兼顾性能。在并发编程实践中，Arc被广泛用来共享只读数据或通过内部加锁来共享可变数据（比如<code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 组合），理解其实现对深入掌握 Rust的内存管理和线程安全非常有帮助。</p><h2 id="互斥锁mutex">互斥锁（Mutex）</h2><p><strong>Mutex（互斥锁）</strong>是一种常用的线程同步原语，用于保证同一时刻只有一个线程可以访问某份数据。Rust提供了 <code>std::sync::Mutex&lt;T&gt;</code>实现安全且高效的互斥锁，在内部结合了自旋和操作系统锁机制。书中构建了一个简化的Mutex 实现，通过多个版本逐步逼近实际库中的优化：</p><ul><li><strong>v1：基本可用的互斥锁</strong> – 首先利用<code>atomic-wait</code> 等底层原语实现一个基本的Mutex。内部使用一个原子标志表示锁状态，采用类似自旋锁的方式尝试获取锁，如果失败则调用底层<code>wait()</code> 将线程阻塞，等待锁可用时被唤醒。同时运用 RAII思想，实现一个锁守卫，在 <code>Drop</code> 中释放锁。这一版本已经具备Mutex 的核心功能：能阻塞等待，避免忙等；用 RAII 确保解锁。</li><li><strong>v2：避免不必要的系统调用</strong> – 优化 Mutex在无竞争情况下的性能。设想如果锁空闲，线程应尽量避免调用内核提供的<code>wait</code> 等系统调用，因为进入内核态有开销。v2改进在于：获取锁时先用原子操作快速检查和设置锁标志，如果成功则直接进入临界区，不需要任何系统调用；只有当锁已被占用且需要等待时，才调用<code>wait</code>进入睡眠。同样，释放锁时如果发现没有任何线程在等待（可通过一个等待计数或标志判断），则不调用<code>wake_one</code>，避免无谓的系统调用开销。这个版本通过“先检查再睡眠”的策略，提高了低争用情况下的性能。</li><li><strong>v3：加入短暂自旋进一步减少系统调用</strong> –在锁竞争发生时，立即阻塞线程进入内核可能不是最优选择。如果锁很快就会被释放，先忙等一小段时间可避免不必要的上下文切换。v3引入了<strong>自旋等待</strong>的优化：当发现锁被占用时，不马上调用<code>wait</code>阻塞线程，而是让线程自旋循环尝试获取锁若干次（或等待若干纳秒）。如果在短暂自旋期间锁被释放获取成功，就无需进入内核；只有超过自旋时限仍未成功，才执行阻塞等待。这个优化利用了临界区很短这种常见情况，大幅减少了内核调度开销。在实际实现中，Rust标准库和 <code>parking_lot</code> 库的 Mutex都采用了类似的自旋-休眠结合策略，以平衡延迟和吞吐量。</li></ul><p>经过这些改进，Mutex实现已经非常接近真实场景：在无竞争时开销极低（原子操作和用户态逻辑），在有轻微竞争时通过自旋避免陷入内核，在竞争激烈或锁长时间被持有时再进入内核等待，从而综合优化不同场景下的性能。值得一提的是，Rust标准库的 Mutex 实际上在底层是调用操作系统的原生实现（例如 Windows临界区，pthread mutex等），而社区提供的 <code>parking_lot</code> crate则使用了自定义的高性能实现（正是类似书中描述的策略）。理解这些机制有助于选择和使用锁，以及调优并发性能。</p><h2 id="条件变量condvar">条件变量（Condvar）</h2><p><strong>条件变量</strong>是一种配合互斥锁使用的同步原语，用于线程间等待和通知机制。一个典型的Condvar 场景是：线程 A获取锁并检查某个条件，如果条件不满足则在条件变量上等待（这会释放锁并挂起线程A）；另一个线程B稍后满足条件后获取同一把锁，改变条件并通知唤醒条件变量，线程A被唤醒后重新获取锁继续执行。Rust提供了 <code>std::sync::Condvar</code>来实现这一机制。书中通过两步实现了 Condvar 的核心原理并进行了优化：</p><ul><li><strong>v1：利用 atomic-wait 实现等待/唤醒</strong> –条件变量需要将线程挂起和唤醒与某个共享条件相结合。v1 实现中，每个Condvar 内部维护一个原子计数或标志，当线程调用 <code>wait()</code>时，先解锁关联的 Mutex，然后调用 <code>atomic_wait</code>在该原子上休眠等待。另一线程调用 <code>notify_one</code> 或<code>notify_all</code> 时，对同一个原子值执行修改并调用<code>wake_one</code> 或 <code>wake_all</code>来唤醒等待线程。这样利用前述操作系统原语，就实现了条件变量的等待和唤醒机制。需要注意唤醒后线程会重新尝试获取最初的Mutex锁，以恢复对共享状态的保护（这一过程通常由Condvar实现封装好）。</li><li><strong>v2：增加等待者计数避免无效唤醒</strong> –为了优化唤醒通知的性能，v2 在 Condvar 内部引入了一个原子计数<code>num_waiters</code>，记录当前有多少线程在此 Condvar上等待。这样，当调用 <code>notify_one/all</code>时，可以先检查如果没有等待者就直接返回，避免进行系统调用唤醒。同理，在等待时也增加和减少这个计数。这个简单的计数避免了无谓的唤醒操作调用（例如没有线程在等待却调用了唤醒系统调用）。实际中，大部分条件变量实现都会维护类似的状态来提升效率。Rust标准库的 <code>Condvar</code> 在具体实现上依赖于系统提供的条件变量（如pthread_cond_t），但原理一致。</li></ul><p>Condvar的实现难点在于要安全地结合互斥锁使用，以及防止经典的“丢失信号”问题（即信号发送与等待错过时机导致永久沉睡）。通过精心设计的顺序（例如在Mutex 解锁和 wait挂起之间避免竞争）以及必要的重试循环（被唤醒后通常需要再次检查条件），可以确保Condvar的正确性。这部分内容体现了操作系统原语与高级并发抽象之间的结合：Rust的实现隐藏了许多细节，但理解它有助于我们正确使用Condvar（例如明白必须在循环中等待条件、防止虚假唤醒等）。</p><h2 id="读写锁rwlock">读写锁（RwLock）</h2><p><strong>读写锁</strong>允许多个读者并行地读取数据，但在有写者持有锁时所有读者都被阻止。这样在读多写少的场景下能提高并发性能。Rust提供了 <code>std::sync::RwLock&lt;T&gt;</code> 来实现读写锁。与 Mutex类似，RwLock在实现上也可以结合自旋和操作系统原语，并需考虑读者与写者的公平性。书中实现的简易RwLock 经过了三步演进，着重解决写者可能的饥饿问题：</p><ul><li><strong>v1：核心读写锁语义</strong> – 初始版本使用<code>atomic-wait</code> 等机制和RAII，支持多个读者或单个写者的互斥。具体来说，可用一个原子计数来表示锁状态：例如计数为非负时表示当前有该数目的读者持锁，计数为-1 表示有写者持锁。实现 <code>read_lock</code>时尝试将计数递增（若当前不是写模式），<code>write_lock</code>则尝试将计数从0变为 -1 来独占。如果操作失败则调用 wait挂起等待。当持锁线程释放锁时，更新计数并根据情况调用 wake_one/all唤醒等待的线程。这一版本实现了基本的 RwLock 功能。</li><li><strong>v2：增加独立的写者唤醒计数</strong> –为了避免写线程在竞争中空转，v2 引入了一个单独的<code>writer_wake_counter</code>或标志。因为读锁可能同时唤醒多个等待的读者，而写者通常只需单独唤醒。当一个写线程在等待时，如果持续有读锁进来，它可能长时间得不到机会。通过维护一个专门针对写者的等待计数或标志，释放锁时如果发现有写者在等待，可以更有针对性地唤醒写线程。这避免了写线程无谓地循环等待所有读者离开锁。</li><li><strong>v3：使用奇偶数编码巧妙解决写者饥饿</strong> –最终版本采取了一个巧妙的方案：利用原子计数的<strong>最低位或奇偶性</strong>来标记写者意图，从而平衡读/写公平性。一种常见做法是，将计数的某一位作为“有写者等待”的标记。当有写线程等待时，设置该标记使新的读锁请求被延迟（即不再允许新的读者获取锁），从而逐步清空现有读者并最终让写者上锁。一旦写者获取锁并释放后，再清除标记放行读者。这种通过奇偶位（或其他位）区分读写状态的编码方式，可以防止写者一直被源源不断的读者饿死，又不会过度牺牲读性能。实际工程中，不少读写锁实现（包括Rust 标准库和 <code>parking_lot</code> 的RwLock）都采用类似思路：既避免写者饥饿，又保持尽可能高的读并发。</li></ul><p>读写锁相对于互斥锁有更复杂的状态管理，需要处理多读者、单写者之间的切换，以及公平性策略。通过上述改进，我们既实现了基本功能，又确保在竞争激烈时系统不会偏科（比如始终偏向读者或写者）。在Rust 标准库中，<code>RwLock</code> 使用系统的 pthread_rwlock或相似机制实现，而更优化的方案如 <code>parking_lot::RwLock</code>则采用自己的算法，和书中描述的策略不谋而合。对于开发者来说，了解这些实现细节能够帮助理解<code>RwLock</code>的特性（例如为什么有时写锁可能拿不到是因为读锁频繁进来等），从而做出更好的并发设计决策。</p><h2 id="总结">总结</h2><p>通过对《Rust Atomics and Locks》全书内容的梳理，我们系统了解了 Rust并发编程从<strong>底层原理</strong>到<strong>高级抽象</strong>的一系列知识点：</p><ul><li>原子操作及其内存序保证构成了无锁并发的基础，不同架构对其支持有所区别，理解硬件内存模型有助于写出正确高效的原子操作代码。</li><li>内存模型中的 happens-before等概念和五种内存顺序提供了分析并发行为的工具，Rust的类型系统和内存屏障一起确保了跨线程操作的可见性和有序性。</li><li>UnsafeCell 和 Send/Sync 等机制是 Rust提供的编译期保障，既允许必要的“不安全”修改又保证线程安全边界分明，使我们能放心地构建并使用并发原语。</li><li>操作系统提供的 futex 等原语连接了用户态原子操作和内核调度，Rust并发库巧妙地加以利用，实现既省CPU又高吞吐的锁和阻塞结构。</li><li>通过几个典型并发原语（自旋锁、通道、Arc、Mutex、Condvar、RwLock）的实现迭代，我们看到如何将上述原理应用于实际：从简单正确的初始版本，不断优化以提高性能和安全性，最终达到与工业级实现类似的效果。这些案例也强调了概念之间的联系——如自旋锁和Mutex 体现了忙等与阻塞两种等待策略，Arc 的内部可变性依赖 UnsafeCell而其计数安全依赖原子操作，条件变量依赖 Mutex配合以及操作系统原语等等。</li></ul><p>Rust并发的设计追求“<strong>无数据竞争</strong>”的同时，通过类型系统和底层优化取得了很好平衡。《RustAtomics andLocks》深入浅出地展示了这一领域的方方面面。本笔记希望帮助读者快速回顾书中内容，在需要时可将各章节要点作为知识索引参考。相信将来面对具体并发编程挑战时，这些基础理论和实现经验将成为宝贵的指导，帮助我们写出健壮高效安全的Rust 并发代码。</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">本篇是 Rust 并发编程系列文章的最后一篇，笔者将尝试对书中涉及到的关键知识点进行统一梳理，主要是为了便于查阅，所以不会再过多深入细节，感兴趣的读者可以跳转到对应篇章进行详细查阅。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨手写一个 RwLock</title>
    <link href="https://hedon.top/2025/06/11/rust-action-rwlock/"/>
    <id>https://hedon.top/2025/06/11/rust-action-rwlock/</id>
    <published>2025-06-11T00:56:08.000Z</published>
    <updated>2025-06-12T17:06:27.060Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><ahref="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust实战丨手写一个 SpinLock</a></li><li><ahref="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust实战丨手写一个 RwLock</a> 👈 本篇</li></ul><hr /><p>本篇我们继续参考 <ahref="https://marabos.nl/atomics/building-locks.html#reader-writer-lock">RustAtomics and Locks</a>一书来手写一个读写锁：<em><em>RwLock</em></em>。这也是这本书中的最后一个实战案例了，很幸运我们能坚持到现在，为自己鼓掌👏🏻 ！</p><p>在本章开始之前，我们假设你已经：</p><ol type="1"><li>熟悉并理解 Rust 的各种原子操作。</li><li>阅读过 <ahref="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊Rust 的 Atomic 和内存顺序</a> 和 <ahref="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust原理丨从汇编角度看原子操作</a>，并理解内存顺序和内存屏障的原理和使用方法。</li><li>理解 Rust <code>UnsafeCell&lt;T&gt;</code>提供的内部可变性允许我们在持有共享引用 <code>&amp;</code>的时候可以对数据进行修改。</li><li>阅读过 <ahref="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a> 并了解 <ahref="https://crates.io/crates/atomic-wait">atomic-wait</a> crate 中<code>wait/wake_one/wake_all</code> 的适用场景和使用方法。</li></ol><h2 id="读完本篇你能学到什么">读完本篇你能学到什么</h2><ol type="1"><li><p>掌握读写锁的核心语义和基本原理</p><ul><li><p>理解读锁可共享、写锁需独占的设计哲学</p></li><li><p>学会使用原子操作和 Guard 模式实现线程安全</p></li><li><p>掌握 <code>UnsafeCell</code> 实现内部可变性的技巧</p></li></ul></li><li><p>解决写线程无用循环问题</p><ul><li><p>识别并发程序中的性能瓶颈</p></li><li><p>学会通过独立原子变量避免竞争</p></li><li><p>理解 <code>atomic-wait</code> 的高效使用方式</p></li></ul></li><li><p>巧妙解决写饥饿难题</p><ul><li><p>掌握奇偶数编码表达复杂状态的艺术</p></li><li><p>理解并发系统中性能与公平性的权衡</p></li><li><p>学会设计状态机解决复杂同步问题</p></li></ul></li></ol><h2 id="v1基础实现">v1：基础实现</h2><p>按照惯例，我们先来思考数据结构该如何定义。所谓读写锁，即读锁与读锁之间是可以共存，而读锁与写锁、写锁与写锁之间是互斥的。</p><ol type="1"><li>我们需要一个变量 <code>state</code>来表示当前是否有读线程、有多少读线程、是否有写线程，这里可以用<code>state</code>的值来表示有多少读线程，当其为最大值时，表示有写线程。因为 <ahref="https://crates.io/crates/atomic-wait">atomic-wait</a> 仅支持AtomicU32，所以这里我们的数据类型也定义为 AtomicU32.</li><li>抢到写锁的时候，是可以对数据 <code>value</code>进行修改的，但因我们只持有 <code>&amp;RwLock</code>共享引用，为了修改数据，我们依旧需要依赖 <code>UnsafeCell</code>提供内部可变性。</li><li>我们需要 2 个守卫类型，分别作为读守卫和写守卫，它们都持有 RwLock的引用。<ul><li>读守卫只能获取共享引用，所以我们为其实现 <code>Deref</code>trait。</li><li>写守卫可以获取独占引用，所以我们为其实现 <code>Deref</code> 和<code>DerefMut</code> trait。</li></ul></li><li>另外，因为读锁是共享，写锁是独占，所以我们在为<code>RwLock&lt;T&gt;</code> 实现 <code>Sync</code> trait 的时候，要求<code>T</code> 必须满足 <code>Sync+Send</code>。</li></ol><p>综上，我们可以定出以下的数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RwLock</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// The number of read locks, u32::MAX if write locked.</span></span><br><span class="line">    state: AtomicU32,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ReadGuard</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    rwlock: &amp;<span class="symbol">&#x27;a</span> RwLock&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WriteGuard</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    rwlock: &amp;<span class="symbol">&#x27;a</span> RwLock&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">RwLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Sync</span> + <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">WriteGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*<span class="keyword">self</span>.rwlock.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> <span class="title class_">WriteGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.rwlock.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">ReadGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*<span class="keyword">self</span>.rwlock.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            state: AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">            value: UnsafeCell::<span class="title function_ invoke__">new</span>(value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，现在我们需要来实现最重要的功能：上锁和解锁。</p><p>我们先来看上读锁和解锁：当 <code>state != u32::MAX</code>的时候，我们就可以尝试对 <code>state</code> 进行加 1 抢占读锁，在销毁<code>ReadGuard</code> 的时候，我们只需要对 <code>state</code> 进行减1，当最后一个读锁释放的时候，还需要唤醒一个潜在的阻塞中的写线程。且这里，加1 和减 1 需要用一对 Acquire 和 Release 建立 happens-before 关系。</p><p>代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">read</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> ReadGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s &lt; <span class="type">u32</span>::MAX &#123;</span><br><span class="line">                <span class="built_in">assert!</span>(s != <span class="type">u32</span>::MAX - <span class="number">1</span>, <span class="string">&quot;too many readers&quot;</span>);</span><br><span class="line">              <span class="comment">// 尝试上读锁</span></span><br><span class="line">                <span class="keyword">match</span> <span class="keyword">self</span>.state.<span class="title function_ invoke__">compare_exchange_weak</span>(s, s + <span class="number">1</span>, Acquire, Relaxed) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="keyword">return</span> ReadGuard &#123; rwlock: <span class="keyword">self</span> &#125;,</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(e) =&gt; s = e,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> s == <span class="type">u32</span>::MAX &#123;<span class="comment">// 如果已经上了写锁，就陷入等待</span></span><br><span class="line">                <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.state, <span class="type">u32</span>::MAX);</span><br><span class="line">                s = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">ReadGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.rwlock.state.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Release) == <span class="number">1</span> &#123; <span class="comment">// 最后一个读锁释放</span></span><br><span class="line">            <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.rwlock.state);<span class="comment">// 唤醒一个潜在的写线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看上写锁和解锁：我们只需要尝试将 <code>state</code> 置为<code>u32::MAX</code>，如果成功了，则说明上写锁成功，否则需要陷入等待。在解锁的时候，只需要将<code>state</code> 置为<code>0</code>，并唤醒所有潜在的阻塞的读线程和写线程。同样，这里也需要一对Acquire 和 Release 建立 happens-before 关系。</p><p>代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> WriteGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">      <span class="comment">// 尝试置为 u32::MAX</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Err</span>(s) = <span class="keyword">self</span>.state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="type">u32</span>::MAX, Acquire, Relaxed) &#123;</span><br><span class="line">            <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.state, s); <span class="comment">// 陷入阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">        WriteGuard &#123; rwlock: <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">WriteGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rwlock.state.<span class="title function_ invoke__">store</span>(<span class="number">0</span>, Release);</span><br><span class="line">        <span class="title function_ invoke__">wake_all</span>(&amp;<span class="keyword">self</span>.rwlock.state); <span class="comment">// 唤醒所有阻塞的写线程和读线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们一个基本可用的 <code>RwLock</code>就实现完毕了，你可以参考下图进行辅助理解：</p><pre class="mermaid">sequenceDiagram    participant A as 线程A (读者)    participant B as 线程B (读者)    participant C as 线程C (写者)    participant State as RwLock State    participant Wait as Wait/Wake 机制    Note over State: state = 0 (未锁定)    A->>State: read() - compare_exchange_weak(0, 1)    Note over State: state: 0 → 1    State-->>A: 成功，返回 ReadGuard    B->>State: read() - compare_exchange_weak(1, 2)    Note over State: state: 1 → 2 (两个读锁)    State-->>B: 成功，返回 ReadGuard    Note over A, B: 💡 读锁可以并发持有    C->>State: write() - compare_exchange(0, u32::MAX)    State-->>C: 失败 (state=2, 不等于0)    C->>Wait: wait(&state, 2)    Note over C: 🔒 写线程进入等待状态    Note over A: 线程A完成读操作    A->>State: drop(ReadGuard) - fetch_sub(1)    Note over State: state: 2 → 1    Note over A: 不是最后一个读锁，不唤醒    Note over B: 线程B完成读操作    B->>State: drop(ReadGuard) - fetch_sub(1)    Note over State: state: 1 → 0    Note over B: ✨ 最后一个读锁释放！    B->>Wait: wake_one(&state)    Note over C: 🎯 写线程被唤醒    C->>State: write() - compare_exchange(0, u32::MAX)    Note over State: state: 0 → u32::MAX    State-->>C: 成功，返回 WriteGuard    Note over C: 线程C执行写操作...    C->>State: drop(WriteGuard) - store(0)    Note over State: state: u32::MAX → 0    C->>Wait: wake_all(&state)    Note over Wait: 📢 唤醒所有等待的线程</pre><p>我们来写下单元测试验证功能是否正确：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> std::&#123;</span><br><span class="line">        thread::&#123;<span class="keyword">self</span>, sleep&#125;,</span><br><span class="line">        time::Duration,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rwl</span> = RwLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r1</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(r1.<span class="title function_ invoke__">len</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r2</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(r2.<span class="title function_ invoke__">len</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">drop</span>(r1);</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(r2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w</span> = rwl.<span class="title function_ invoke__">write</span>();</span><br><span class="line">        w.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r3</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(r3.<span class="title function_ invoke__">len</span>(), <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">rwl</span> = RwLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line"></span><br><span class="line">        thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w</span> = rwl.<span class="title function_ invoke__">write</span>();</span><br><span class="line">                w.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">                w.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">                <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">r1</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *r1);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">r2</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *r2);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果是通过的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">running 2 tests</span><br><span class="line">test rwlock::tests::one_thread_should_work ... ok</span><br><span class="line">test rwlock::tests::cross_thread_should_work ... ok</span><br></pre></td></tr></table></figure><h2 id="v2避免写线程无用循环">v2：避免写线程无用循环</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> WriteGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Err</span>(s) = <span class="keyword">self</span>.state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="type">u32</span>::MAX, Acquire, Relaxed) &#123;</span><br><span class="line">            <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.state, s);</span><br><span class="line">        &#125;</span><br><span class="line">        WriteGuard &#123; rwlock: <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察一下我们上个版本的 <code>write()</code>实现，这里可能会出现一种情况：当上读锁非常频繁的时候，<code>state</code>的值是一直在变化的，这个时候，<code>wait(&amp;self.state, s)</code>就有可能因为 <code>state</code> 的值发生了变化，不等于 <code>s</code>了，就不会陷入等待，而是继续循环尝试将 <code>state</code> 从<code>0</code> 置为<code>u32::MAX</code>。这时如果上读锁非常频繁的话，那这里会一直尝试获取，且是无意义的尝试。</p><pre class="mermaid">sequenceDiagram    participant W as 写线程    participant R1 as 读线程1    participant R2 as 读线程2    participant State as RwLock State    participant Wait as Wait 机制    Note over State: state = 1 (有一个读锁)    W->>State: write() - compare_exchange(0, u32::MAX)    State-->>W: 失败，返回 s=1    Note over W: 准备调用 wait(&state, 1)    R1->>State: drop(ReadGuard) - fetch_sub(1)    Note over State: state: 1 → 0 ⚡️ (在 wait 调用前状态就变了！)    W->>Wait: wait(&state, 1)    Note over Wait: ❌ 当前 state=0，不等于期望值1，立即返回！    Wait-->>W: 立即返回，没有真正等待    Note over R2: 💨 新读线程抢在 compare_exchange 前获取锁！    R2->>State: read() - compare_exchange_weak(0, 1)    Note over State: state: 0 → 1    Note over W: 🔄 进入下一轮循环    W->>State: compare_exchange(0, u32::MAX)    State-->>W: 失败，返回 s=1 (锁又被抢了！)    Note over W: 又准备调用 wait(&state, 1)    R2->>State: drop(ReadGuard) - fetch_sub(1)    Note over State: state: 1 → 0 ⚡️ (又在 wait 前变化了！)    W->>Wait: wait(&state, 1)    Wait-->>W: 又是立即返回！    Note over W: 🔄 无用循环开始...    Note over W: ⚠️ 写线程永远无法真正进入等待状态！    Note over W: 💀 CPU 被白白消耗在无效的重试上    Note over State: 🎯 问题核心：wait 调用前 state 总是被读锁改变    Note over State: 💡 解决：独立的 writer_wake_counter 避免这种竞争</pre><p>这里问题的根源在于 <strong><code>read()</code> 和<code>write()</code> 监听的都是同一个原子变量<code>state</code></strong>。</p><p>解决这个问题的方案之一，就是可以另外加一个原子变量，专门给<code>write()</code>，从而与 <code>read()</code>区分开来，避免互相影响，从而造成 <code>write()</code>时产生无用循环。</p><p>我们在 <code>RwLock</code>中新增一个属性：<code>writer_wake_counter</code>，用于唤醒抢占写锁的线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RwLock</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// The number of read locks, u32::MAX if write locked.</span></span><br><span class="line">    state: AtomicU32,</span><br><span class="line">    <span class="comment">/// Incremented to wake up waiters.</span></span><br><span class="line">    writer_wake_counter: AtomicU32,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            state: AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">            writer_wake_counter: AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">            value: UnsafeCell::<span class="title function_ invoke__">new</span>(value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候：</p><ol type="1"><li>我们在 <code>write()</code> 时没抢到锁，就不去<code>wait(&amp;state)</code> 了，而是<code>wait(&amp;writer_wake_counter)</code>。</li><li>最后一个 <code>ReadGuard</code> 在 drop 的时候，我们修改<code>writer_wake_counter</code>的值，并唤醒一个潜在的阻塞的写线程。</li><li><code>WriteGuard</code>的时候，不仅要唤醒所有阻塞的读线程，还要唤醒一个潜在的阻塞的写线程。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> WriteGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span></span><br><span class="line">            .state</span><br><span class="line">            .<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="type">u32</span>::MAX, Acquire, Relaxed) <span class="comment">// 尝试抢锁</span></span><br><span class="line">            .<span class="title function_ invoke__">is_err</span>()</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 失败的话取出 writer_wake_counter，供待会 `wait` 使用。</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">w</span> = <span class="keyword">self</span>.writer_wake_counter.<span class="title function_ invoke__">load</span>(Acquire);</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed) != <span class="number">0</span> &#123; <span class="comment">// 再次检查 state，如果为 0，就不阻塞了，再次尝试抢锁</span></span><br><span class="line">                <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.writer_wake_counter, w); <span class="comment">// 否则陷入等待</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        WriteGuard &#123; rwlock: <span class="keyword">self</span> &#125; <span class="comment">// 抢锁成功，返回守卫对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">ReadGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.rwlock.state.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.rwlock.writer_wake_counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Release);</span><br><span class="line">            <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.rwlock.writer_wake_counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">WriteGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rwlock.state.<span class="title function_ invoke__">store</span>(<span class="number">0</span>, Release);</span><br><span class="line">        <span class="keyword">self</span>.rwlock.writer_wake_counter.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Release);</span><br><span class="line">        <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.rwlock.writer_wake_counter);  <span class="comment">// 唤醒一个写线程</span></span><br><span class="line">        <span class="title function_ invoke__">wake_all</span>(&amp;<span class="keyword">self</span>.rwlock.state);<span class="comment">// 唤醒所有的读线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个简单的优化，我们就可以避免写线程因为 <code>state</code>的频繁变化而产生无用循环了。再次运行之前的测试用例，顺利通过的话就没有问题啦！</p><h2 id="v3避免写饥饿">v3：避免写饥饿</h2><p>这个版本我们来做最后一个可尝试优化：<strong>避免写饥饿</strong>。</p><p>在之前的实现中，只要没上锁，或者上的是读锁，那么就可以一直不断地上读锁。而只有当没有任何读线程和写线程存在的时候，才可以上写锁。这就非常容易造成写饥饿了，因为那些后来的读线程依旧可以成功上读锁，而写线程抢到锁的条件太苛刻了。</p><p>为了解决这个问题，我们可以修改一下 <code>state</code> 的定义：</p><ol type="1"><li>当 <code>state</code> 为 <code>0</code> 的时候，说明没上锁。</li><li>当 <code>state</code> 为 <code>u32::MAX</code>的时候，说明上了写锁。</li><li>当 <code>state</code> 为非 0的偶数的时候，说明上了读锁，<strong>且没有阻塞中的写锁，这个时候可以继续上读锁</strong>。</li><li>当 <code>state</code>为其他奇数的时候，说明这个时候有阻塞中的写锁，<strong>后面来的读锁也需要阻塞</strong>。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RwLock</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// 读线程的数量 *2，当有阻塞中的写线程的时候 +1</span></span><br><span class="line">  <span class="comment">/// 如果 state=u32::MAX，说上了写锁。</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 这意味着，当 state 是偶数的时候，可以继续上读锁，</span></span><br><span class="line">  <span class="comment">/// 但是，如果 state 是奇数的话，上读锁会被阻塞。</span></span><br><span class="line">    state: AtomicU32,</span><br><span class="line">    <span class="comment">/// Incremented to wake up waiters.</span></span><br><span class="line">    writer_wake_counter: AtomicU32,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的调整，我们就可以相对公平地去避免写饥饿的问题了。为此，我们需要调整读写锁的上锁和解锁的逻辑。</p><p><code>read()</code>:</p><ol type="1"><li>当 <code>state</code> 为偶数的时候，我们可以尝试对其进行<strong>+2</strong> 继续抢占读锁；</li><li>当 <code>state</code> 为奇数的时候，我们需要调用 <code>wait</code>陷入等待。</li></ol><p><code>ReadGuard.drop()</code>:</p><ol type="1"><li>解锁的时候对 <code>state</code> 进行 <strong>-2</strong>；</li><li>如果之前的值是 <code>3</code>的话，说明这是最后一个释放的读锁，且存在被阻塞的写线程，这个时候需要调用<code>wake_one</code> 进行唤醒。</li></ol><p><code>write()</code>:</p><ol type="1"><li>如果 <code>state</code> 为<code>0</code>，则说明此时没有上锁：可以尝试将其置为<code>u32::MAX</code> 抢占锁：<ol type="1"><li>如果成功，直接返回。</li><li>如果抢锁失败，则重新读取 <code>state</code> 值进行重新判断。</li></ol></li><li>如果 <code>state</code> 为非 0偶数，则说明此时已经上了读锁了，我们需要将 <code>state</code><strong>+1</strong>设置为奇数，表示有写线程被阻塞着，阻止后面新来的读线程抢占读锁。</li><li>如果 <code>state</code> 为非 0 奇数：<ol type="1"><li>如果 <code>state</code> 等于1，那说明既没有上写锁，也没有上读锁，但是有一个阻塞中的写线程，那有可能就是当前线程自己了！这个时候，我们依旧是可以尝试将其置为<code>u32::MAX</code> 抢占锁，所以 <code>state</code> 为 <code>1</code>的情况，可以跟 <code>state</code> 为 <code>0</code>的情况进行合并处理。</li><li>如果 <code>state</code> 大于1，则说明已经上了读锁，这个时候，需要陷入等待，等前面的读锁都释放了，才能进入下一轮循环，重新尝试抢占写锁。</li></ol></li></ol><p><code>WriteGuard.drop()</code>:</p><ol type="1"><li>将 <code>state</code> 置为 <code>0</code>；</li><li>唤醒潜在的所有阻塞的读线程和一个写线程。</li></ol><p>我画了个流程图，供你辅助理解：</p><pre class="mermaid">sequenceDiagram    participant R1 as 读线程1 (已持有)    participant R2 as 读线程2 (已持有)    participant W as 写线程 (等待)    participant R3 as 读线程3 (新来)    participant State as RwLock State    participant Wait as Wait/Wake 机制    Note over State: state = 4 (两个读锁，4 = 2×2)    Note over R1, R2: 💡 两个读线程正在工作...    W->>State: write() - 尝试获取写锁    Note over W: 发现有读锁，无法获取    W->>State: compare_exchange(4, 5) - 设置写等待标志    Note over State: state: 4 → 5 (奇数！有等待的写线程)    W->>Wait: wait(&writer_wake_counter, w)    Note over W: 🔒 写线程进入等待，但已设置奇数标志    Note over R3: 💨 新的读线程想要获取锁    R3->>State: read() - 检查 state % 2    Note over R3: state=5 是奇数，发现有等待的写线程！    R3->>Wait: wait(&state, 5)    Note over R3: 🚫 读线程被阻塞，无法抢占！    Note over R1: 读线程1完成工作    R1->>State: drop(ReadGuard) - fetch_sub(2)    Note over State: state: 5 → 3 (仍然是奇数)    Note over R1: 不是最后一个读锁，不唤醒    Note over R2: 读线程2完成工作    R2->>State: drop(ReadGuard) - fetch_sub(2)    Note over State: state: 3 → 1    Note over R2: ✨ 检测到 state=3，是最后一个读锁！    R2->>Wait: wake_one(&writer_wake_counter)    Note over W: 🎯 写线程被唤醒    W->>State: write() - compare_exchange(1, u32::MAX)    Note over State: state: 1 → u32::MAX    State-->>W: ✅ 成功获取写锁！    Note over W: 写线程执行关键操作...    Note over R3: 读线程3仍在等待，公平性得到保证！    W->>State: drop(WriteGuard) - store(0)    Note over State: state: u32::MAX → 0    W->>Wait: wake_all(&state) - 唤醒所有等待的读线程    Note over R3: 🎯 读线程3被唤醒，现在可以获取锁了    R3->>State: read() - compare_exchange_weak(0, 2)    Note over State: state: 0 → 2 (偶数，正常读锁)</pre><p>综上分析，我们最新的代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; RwLock&lt;T&gt; &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">read</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> ReadGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">          <span class="comment">// 如果是 0，则说明现在没有上锁，</span></span><br><span class="line">          <span class="comment">// 如果是偶数，则说明现在上的是读锁，写没有阻塞中的写线程，</span></span><br><span class="line">          <span class="comment">// 这两种情况，都可以尝试将 state+2 进行抢占读锁。</span></span><br><span class="line">            <span class="keyword">if</span> s % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">assert!</span>(s != <span class="type">u32</span>::MAX - <span class="number">2</span>, <span class="string">&quot;too many readers&quot;</span>);</span><br><span class="line">                <span class="keyword">match</span> <span class="keyword">self</span>.state.<span class="title function_ invoke__">compare_exchange_weak</span>(s, s + <span class="number">2</span>, Acquire, Relaxed) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="keyword">return</span> ReadGuard &#123; rwlock: <span class="keyword">self</span> &#125;,<span class="comment">// 抢占成功，直接返回。</span></span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(e) =&gt; s = e,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果 state 为奇数，说明有阻塞中的写线程。</span></span><br><span class="line">            <span class="keyword">if</span> s % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">              <span class="comment">// 这时候，后面来的读线程都需要阻塞，等待写锁的获取和释放。</span></span><br><span class="line">                <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.state, s);</span><br><span class="line">                s = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> WriteGuard&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">          <span class="comment">// 0: 没有上锁，可以尝试抢锁。</span></span><br><span class="line">          <span class="comment">// 1: 没有上锁，但有阻塞的写线程，可能就是自己，依旧可以尝试抢锁。</span></span><br><span class="line">            <span class="keyword">if</span> s &lt;= <span class="number">1</span> &#123;</span><br><span class="line">              <span class="comment">// 尝试将 state 置为 u32::MAX，成功则直接返回</span></span><br><span class="line">                <span class="keyword">match</span> <span class="keyword">self</span>.state.<span class="title function_ invoke__">compare_exchange</span>(s, <span class="type">u32</span>::MAX, Acquire, Relaxed) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="keyword">return</span> WriteGuard &#123; rwlock: <span class="keyword">self</span> &#125;,</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">                        s = e;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 非 0 的偶数，说明现在上的是读锁，且之前没有阻塞的写线程。</span></span><br><span class="line">            <span class="keyword">if</span> s % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">              <span class="comment">// 将 state+1 置为奇数，表示已经有阻塞的写线程了，阻止后来的读线程抢占读锁。</span></span><br><span class="line">                <span class="keyword">match</span> <span class="keyword">self</span>.state.<span class="title function_ invoke__">compare_exchange</span>(s, s + <span class="number">1</span>, Relaxed, Relaxed) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(_) =&gt; &#123;&#125;</span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">                        s = e;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">w</span> = <span class="keyword">self</span>.writer_wake_counter.<span class="title function_ invoke__">load</span>(Acquire);</span><br><span class="line">            s = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">            <span class="keyword">if</span> s &gt;= <span class="number">2</span> &#123;</span><br><span class="line">              <span class="comment">// 如果已经上了读锁，则陷入等待，等待前面所有读锁的释放。</span></span><br><span class="line">                <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.writer_wake_counter, w);</span><br><span class="line">                s = <span class="keyword">self</span>.state.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放读锁</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">ReadGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="comment">// 对 state -=2，如果之前的值是 3，则说明当前是最后一个释放的读锁，且存在阻塞中的写线程。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.rwlock.state.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">2</span>, Release) == <span class="number">3</span> &#123;</span><br><span class="line">          <span class="comment">// 唤醒一个阻塞中的写线程。</span></span><br><span class="line">            <span class="keyword">self</span>.rwlock.writer_wake_counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Release);</span><br><span class="line">            <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.rwlock.writer_wake_counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放写锁</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">WriteGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="comment">// 将 state 重置为 0。</span></span><br><span class="line">        <span class="keyword">self</span>.rwlock.state.<span class="title function_ invoke__">store</span>(<span class="number">0</span>, Release);</span><br><span class="line">      <span class="comment">// 唤醒一个潜在的阻塞的写线程。</span></span><br><span class="line">        <span class="keyword">self</span>.rwlock.writer_wake_counter.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Release);</span><br><span class="line">        <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.rwlock.writer_wake_counter);</span><br><span class="line">      <span class="comment">// 唤醒所有潜在的阻塞的读线程。</span></span><br><span class="line">        <span class="title function_ invoke__">wake_all</span>(&amp;<span class="keyword">self</span>.rwlock.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们重新运行之前的测试用例，可以发现的顺利通过的！不过我们还需要加一个测试用例，来测试写饥饿是否被解决了！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">writer_starvation_should_resolved</span>() &#123;</span><br><span class="line">   <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;<span class="comment">// 跑 100 次，避免偶然</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> <span class="variable">rwl</span> = RwLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">      thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">          s.<span class="title function_ invoke__">spawn</span>(|| &#123;<span class="comment">// 线程 1</span></span><br><span class="line">              <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w</span> = rwl.<span class="title function_ invoke__">write</span>();</span><br><span class="line">              w.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">              w.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          s.<span class="title function_ invoke__">spawn</span>(|| &#123; <span class="comment">// 线程 2</span></span><br><span class="line">              <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line">              <span class="keyword">let</span> <span class="variable">r1</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">              <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *r1);</span><br><span class="line">              <span class="keyword">let</span> <span class="variable">r2</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">              <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *r2);</span><br><span class="line">              <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">50</span>)); <span class="comment">// stay locked to block after writers and readers</span></span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          s.<span class="title function_ invoke__">spawn</span>(|| &#123; <span class="comment">// 线程 3</span></span><br><span class="line">              <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">20</span>));</span><br><span class="line">              <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w2</span> = rwl.<span class="title function_ invoke__">write</span>();</span><br><span class="line">              w2.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          s.<span class="title function_ invoke__">spawn</span>(|| &#123; <span class="comment">// 线程 4</span></span><br><span class="line">              <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">30</span>));</span><br><span class="line">              <span class="keyword">let</span> <span class="variable">r</span> = rwl.<span class="title function_ invoke__">read</span>();</span><br><span class="line">              <span class="built_in">assert_eq!</span>(r.<span class="title function_ invoke__">len</span>(), <span class="number">3</span>); <span class="comment">// must get lock after w2</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个测试用例中，线程 2/3/4 在开始之前分别会睡眠10/20/30ms，所以抢占锁的时间顺序是<code>w-&gt;r1-&gt;r2-&gt;w2-&gt;r</code>。并且线程 2在退出之前，还睡眠了 50ms，所以线程 3 和线程 4在抢占锁的时候，<code>r1/r2</code> 都还没释放。</p><p>如果我们成功解决了写饥饿问题的话，那这个时候，线程 3 应该会将<code>state</code> 置为奇数，防止线程 4 抢占读锁。所以当线程 4抢到读锁的时候，线程 3 一定已经释放写锁了，即 <code>vec</code>里面一定有 3 条数据！通过运行<code>writer_starvation_should_resolved</code>测试用例，很幸运，我们已经成功解决了写饥饿的问题了！</p><p>完整代码可以参考：<ahref="https://github.com/hedon-rust-road/conutils/blob/main/src/rwlock.rs">conutils/rwlock</a>。</p><h2 id="总结">总结</h2><p>本篇文章通过三个渐进式版本完整展示了如何从零开始手写一个功能完备的读写锁（RwLock）。</p><p>我们的实现历程体现了系统编程中常见的优化思路：</p><ul><li><p><strong>v1基础实现</strong>：实现了核心的读写锁语义，确保功能正确性</p></li><li><p><strong>v2 性能优化</strong>：通过独立的<code>writer_wake_counter</code> 避免写线程无用循环，提升了性能</p></li><li><p><strong>v3公平性保证</strong>：巧妙使用奇偶数编码解决写饥饿问题，在性能与公平性间找到平衡</p></li></ul><p>通过这次实战，我们不仅掌握了 RwLock的实现细节，更重要的是学会了并发编程的系统性思维方式。这些经验将在后续的系统编程实践中发挥重要作用。</p><p>这也是我们学习 <a href="https://marabos.nl/atomics/">Rust Atomics andLocks</a> 这本优秀书籍的收官之战，笔者由衷地佩服 <ahref="https://github.com/m-ou-se">Mara Bos</a> 能在短短 200 多页的篇幅将Rust的并发编程阐述得如何透彻、清晰且足够深入细节，笔者在整理本系列笔记的过程中，也真的是获益颇丰，希望也能给你带来一些收获，那我们下篇文章见！</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">通过三个渐进式版本深入理解 RwLock 的实现原理，从基础功能到性能优化再到公平性保证，掌握原子操作、内存顺序、条件变量等并发编程核心技术，并学会解决写饥饿等实际问题。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 实战" scheme="https://hedon.top/categories/rust/rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨手写一个 Condvar</title>
    <link href="https://hedon.top/2025/06/09/rust-action-condvar/"/>
    <id>https://hedon.top/2025/06/09/rust-action-condvar/</id>
    <published>2025-06-09T00:51:46.000Z</published>
    <updated>2025-06-12T17:07:15.199Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><ahref="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust实战丨手写一个 SpinLock</a></li><li><ahref="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust实战丨手写一个 Condvar</a> 👈 本篇</li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust实战丨手写一个 RwLock</a></li></ul><hr /><p>本篇我们继续参考 <ahref="https://marabos.nl/atomics/building-locks.html#condition-variable">RustAtomics and Locks</a> 一书来手写一个条件变量：<em>ConditionVariable</em>，简称 <code>Condvar</code>。</p><p>在本章开始之前，我们假设你已经：</p><ol type="1"><li>熟悉并理解 Rust 的各种原子操作。</li><li>阅读过 <ahref="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊Rust 的 Atomic 和内存顺序</a> 和 <ahref="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust原理丨从汇编角度看原子操作</a>，并理解内存顺序和内存屏障的原理和使用方法。</li><li>理解 Rust <code>UnsafeCell&lt;T&gt;</code>提供的内部可变性允许我们在持有共享引用 <code>&amp;</code>的时候可以对数据进行修改。</li><li>阅读过 <ahref="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a> 并了解 <ahref="https://crates.io/crates/atomic-wait">atomic-wait</a> crate 中<code>wait/wake_one/wake_all</code> 的适用场景和使用方法。</li></ol><p>在 Rust 中，<code>Condvar</code> 是一个配合 <code>Mutex</code>使用的线程同步原语，主要作用是让线程在满足某些“条件”之前主动<strong>睡眠</strong>（阻塞），待条件达成时再被唤醒。</p><p>典型的就是生产者和消费者模式，我们先来看一下标准库的<code>Condvar</code> 如何使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> std::&#123;</span><br><span class="line">        collections::VecDeque,</span><br><span class="line">        sync::&#123;Condvar, Mutex&#125;,</span><br><span class="line">        thread,</span><br><span class="line">        time::Duration,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">condvar_usage</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">queue</span> = Mutex::<span class="title function_ invoke__">new</span>(VecDeque::<span class="title function_ invoke__">new</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">not_empty</span> = Condvar::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">          <span class="comment">// 消费者</span></span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">q</span> = queue.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">item</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(item) = q.<span class="title function_ invoke__">pop_front</span>() &#123; <span class="comment">// 从队列中获取数据</span></span><br><span class="line">                        <span class="keyword">break</span> item; <span class="comment">// 获取到则返回</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        q = not_empty.<span class="title function_ invoke__">wait</span>(q).<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 获取不到数据则阻塞等待</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(q);</span><br><span class="line">                dbg!(item);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 生产者</span></span><br><span class="line">            <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">                queue.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">push_back</span>(i);  <span class="comment">// 往队列里面投放数据</span></span><br><span class="line">                not_empty.<span class="title function_ invoke__">notify_one</span>();  <span class="comment">// 唤醒潜在的阻塞线程</span></span><br><span class="line">                thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，我们实现了一对生产者和消费者：</p><ol type="1"><li>消费尝试获取锁，并从队列中获取数据：<ol type="1"><li>如果有，则释放锁并返回。</li><li>如果没有，则调用条件变量的 <code>wait</code>陷入阻塞<strong>并释放锁</strong>。</li></ol></li><li>生产者尝试获取锁，并往队列中投放数据，并调用条件变量的<code>notify_one</code> 唤醒潜在的阻塞线程。</li></ol><pre class="mermaid">flowchart LR    A[生产者] -->|添加数据| B[队列]    B -->|取数据| C[消费者]    A -->|notify_one| C    C -->|wait| A</pre><h2 id="读完本篇你能学到什么">读完本篇你能学到什么</h2><p>你是否在多线程编程中遇到过这些令人头疼的问题：</p><p>🤔<strong>性能浪费问题</strong>：消费者线程需要不断轮询检查数据是否就绪，即使没有数据也要持续占用CPU，这种"忙等待"让程序效率低下？</p><p>🤔<strong>复杂的同步逻辑</strong>：在生产者-消费者模式中，如何让消费者在没有数据时优雅地进入休眠，而不是无休止地检查？</p><p>🤔<strong>竞态条件的困扰</strong>：如何确保在多线程环境下，唤醒操作不会丢失，线程不会因丢失唤醒而永远沉睡？</p><p>🤔<strong>性能优化的疑惑</strong>：系统调用开销很大，如何避免在没有等待线程时进行无意义的唤醒操作？</p><p>🤔 <strong>内存顺序的选择</strong>：在实现同步原语时，到底该用<code>Acquire</code>、<code>Release</code> 还是<code>Relaxed</code>？如何分析 happens-before 关系？</p><p>如果这些问题曾经让你困惑，那么本文正是为你准备的。下面我们就正式开始从零开始构建一个条件变量（Condvar），用最直观的方式解答这些并发编程中的经典难题。</p><h2 id="v1基础实现">v1：基础实现</h2><p>先来思考一下如何定义 <code>Condvar</code>这个数据结构，参考标准库，它会有 3 个方法：</p><ul><li><code>wait(MutexGuard)</code>: 释放 MutexGuard 并陷入等待。</li><li><code>notify_one()</code>: 唤醒一个 <code>wait</code> 的线程。</li><li><code>notify_all()</code>: 唤醒所有 <code>wait</code> 的线程。</li></ul><p>看过本系列前面几篇的读者应该可以敏锐觉察到，这里就是对应了<code>atomic-wait</code> 中的 <code>wait/wake_one/wake_all</code>。</p><p>那局势就比较明朗了，我们可以在 <code>condvar.wait(guard)</code>的时候调用 <code>atomic_wait::wait(&amp;atomic)</code> ，然后在<code>condvar.notify_one()</code> 的时候修改 <code>&amp;atomic</code>然后调用 <code>atomic_wait::wake_one()</code>唤醒线程，<code>condvar.notify_all()</code> 也同理。</p><p>因此 <code>Condvar</code> 需要有一个 <code>AtomicU32</code>类型的属性，这里我们称为 <code>counter</code>。故 <code>Condvar</code>结构暂且定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    counter: AtomicU32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            counter: AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>notify_one</code> 和 <code>notify_all</code>所上所述，就非常简单了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify_one</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed);</span><br><span class="line">        <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify_all</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed);</span><br><span class="line">        <span class="title function_ invoke__">wake_all</span>(&amp;<span class="keyword">self</span>.counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就剩下 <code>wait</code> 了，它的基本原理：</p><ol type="1"><li>接收一个 MutexGuard；</li><li>释放 MutexGuard；</li><li>陷入等待，等待唤醒；</li><li>被唤醒后，再次抢占锁。</li></ol><p>综上，我们可以有以下实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) mutex: &amp;<span class="symbol">&#x27;a</span> Mutex&lt;T&gt;,  <span class="comment">// &lt;---- 需要公开 mutex 字段，这里使用 pub(crate) 限制 crate 外部访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wait</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(&amp;<span class="keyword">self</span>, guard: MutexGuard&lt;<span class="symbol">&#x27;a</span>, T&gt;) <span class="punctuation">-&gt;</span> MutexGuard&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter_value</span> = <span class="keyword">self</span>.counter.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unlock the mutex by dropping the guard,</span></span><br><span class="line">        <span class="comment">// but remember the mutex so we can lock it again.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutex</span> = guard.mutex;</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(guard);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait, but only if the counter hasn&#x27;t changed since unlocking.</span></span><br><span class="line">        <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.counter, counter_value);</span><br><span class="line"></span><br><span class="line">        mutex.<span class="title function_ invoke__">lock</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，为了访问<code>guard.mutex</code>，这里我们使用的是之前自己手写的 <ahref="https://github.com/hedon-rust-road/conutils/blob/main/src/mutex.rs">MutexGuard</a>，并将<code>mutex</code> 字段的私有程度修改为<code>pub(crate)</code>。代码比较简单，这里就不赘述了，完整流程可参考下图理解。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250610230511147.png" /></p><p>我们修改一下测试用例，运行后发现也是可以通过的！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> std::&#123;collections::VecDeque, thread, time::Duration&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> crate::&#123;condvar::Condvar, mutex::Mutex&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">condvar_usage</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">queue</span> = Mutex::<span class="title function_ invoke__">new</span>(VecDeque::<span class="title function_ invoke__">new</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">not_empty</span> = Condvar::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">q</span> = queue.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">item</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(item) = q.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">                        <span class="keyword">break</span> item;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        q = not_empty.<span class="title function_ invoke__">wait</span>(q);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(q);</span><br><span class="line">                dbg!(item);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">                queue.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">push_back</span>(i);</span><br><span class="line">                not_empty.<span class="title function_ invoke__">notify_one</span>();</span><br><span class="line">                thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="v2减少不必要的系统调用">v2：减少不必要的系统调用</h2><p>第 1 个版本中，我们在 <code>notify_one</code> 和<code>notify_all</code> 分别都无条件调用了 <code>wake_one</code> 和<code>wake_all</code>尝试唤醒潜在的线程，但是这个时候可能并没有线程被阻塞着，那这个系统调用就白白浪费了。</p><p>所以在这个版本中，我们尝试来优化这一点。为此，我们需要记录当前阻塞中的线程的数量，所以需要给<code>Condvar</code> 加一个属性 <code>num_waiters</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    counter: AtomicU32,</span><br><span class="line">    num_waiters: AtomicUsize,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            counter: AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">            num_waiters: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>notify_one</code> 和 <code>notify_all</code>的时候，我们仅当 <code>num_waiters&gt;0</code>的时候，才进行系统调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify_one</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.num_waiters.<span class="title function_ invoke__">load</span>(Relaxed) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed); <span class="comment">// <span class="doctag">TODO:</span> memory order</span></span><br><span class="line">            <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify_all</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.num_waiters.<span class="title function_ invoke__">load</span>(Relaxed) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.counter.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed); <span class="comment">// <span class="doctag">TODO:</span> memory order</span></span><br><span class="line">            <span class="title function_ invoke__">wake_all</span>(&amp;<span class="keyword">self</span>.counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>wait</code> 的时候，我们先标记自己是等待的，即<code>num_waiters++</code>，然后在被唤醒后，解除这个标记，即<code>num_waiters--</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Condvar</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wait</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(&amp;<span class="keyword">self</span>, guard: MutexGuard&lt;<span class="symbol">&#x27;a</span>, T&gt;) <span class="punctuation">-&gt;</span> MutexGuard&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.num_waiters.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed); <span class="comment">// <span class="doctag">TODO:</span> memory order  &lt;----  New!!!</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> <span class="variable">counter_value</span> = <span class="keyword">self</span>.counter.<span class="title function_ invoke__">load</span>(Relaxed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unlock the mutex by dropping the guard,</span></span><br><span class="line">        <span class="comment">// but remember the mutex so we can lock it again.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mutex</span> = guard.mutex;</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(guard);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait, but only if the counter hasn&#x27;t changed since unlocking.</span></span><br><span class="line">        <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.counter, counter_value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.num_waiters.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Relaxed); <span class="comment">//<span class="doctag">TODO:</span> memory order   &lt;----  New!!!</span></span><br><span class="line"></span><br><span class="line">        mutex.<span class="title function_ invoke__">lock</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，这里又到了最关键的问题了：<strong><font color="red">操作num_waiters 时该用什么内存顺序？</font></strong></p><p>这个关键的问题的关键是什么呢？是要<strong><font color="green">确定哪些地方需要建立happens-before 关系！</font></strong></p><p>很明显，我们这里的关键就是要<strong><font color="red">防止<code>wake_one</code>的丢失</font></strong>，即确保如果一个线程即将进入等待状态，那么后续的通知操作能够看到这个等待者的存在。所以这里我们需要<code>notify_one()</code> 中的 <code>load</code> 和<code>condvar.wait()</code> 中的 <code>fetch_add</code> 建立happens-before 关系。至于 <code>fetch_sub</code>就无所谓了，因为这个时候已经被唤醒了，丢失或者重复唤醒都无所谓了。</p><p>不过这里其实可以省掉这对 <code>Release</code> 和<code>Acquire</code>，直接用 <code>Relaxed</code>！为什么呢？</p><ol type="1"><li><p>在 <code>condvar.wait</code> 的 <code>fetch_add</code>之前，我们必须先拿到 MutexGuard，即通过 <code>lock()</code>抢占到锁，<code>lock()</code> 里面是啥操作？是一个<strong><code>Acquire</code></strong>!</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Mutex&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> MutexGuard&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">lock_contended</span>(&amp;<span class="keyword">self</span>.state);</span><br><span class="line">        <span class="comment">// Swap successfully, means locked.</span></span><br><span class="line">        MutexGuard &#123; mutex: <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">lock_contended</span>(state: &amp;AtomicU32) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spin_count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Err</span>(s) = state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="number">1</span>, Ordering::Acquire, Ordering::Relaxed) &#123;</span><br><span class="line">        <span class="keyword">if</span> s == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> spin_count &lt; <span class="number">100</span> &#123;</span><br><span class="line">                spin_count += <span class="number">1</span>;</span><br><span class="line">                std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _ = state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">1</span>, <span class="number">2</span>, Ordering::Acquire, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">wait</span>(state, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们在调用 <code>atomic-wait::wait</code> 陷入等待之前，要先<code>drop(guard</code>)，别忘了，<code>drop(guard)</code>里面是啥操作？是一个 <strong><code>Release</code></strong>！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// If there are threads waiting for the lock, wait one of them.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.mutex.state.<span class="title function_ invoke__">swap</span>(<span class="number">0</span>, Ordering::Release) == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.mutex.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>所以呀，这里其实天然就已经有一对 <code>Release</code> 和<code>Acquire</code> 了！happens-before关系是成立的！所以我们之前的代码就已经满足要求了，再次运行前面的测试用例，依旧是顺利通过的！</p><p>完整代码可参考：<ahref="https://github.com/hedon-rust-road/conutils/blob/main/src/condvar.rs">conutils/condvar</a>。具体流程你可以参考下图辅助理解。</p><pre class="mermaid">sequenceDiagram    participant Consumer as 消费者线程    participant Producer as 生产者线程    participant Mutex as Mutex状态    participant NumWaiters as num_waiters    participant Counter as counter    Consumer->>Mutex: lock() [Acquire]    Consumer->>Consumer: 检查条件，发现需要等待    Consumer->>NumWaiters: fetch_add(1) [Relaxed]    Consumer->>Counter: load() -> counter_value    Consumer->>Mutex: drop(guard) [Release]    Consumer->>Counter: wait(counter_value)    Note over Producer: 生产者在另一个线程    Producer->>Mutex: lock() [Acquire] ✅ 与Consumer的Release同步    Producer->>Producer: 修改共享数据    Producer->>Mutex: drop(guard) [Release]    Producer->>NumWaiters: load() > 0? ✅ 看到Consumer的increment    Producer->>Counter: fetch_add(1) [Relaxed]    Producer->>Counter: wake_one()    Consumer->>Consumer: 被唤醒    Consumer->>Mutex: lock() [Acquire]    Consumer->>NumWaiters: fetch_sub(1) [Relaxed]</pre><blockquote><p>另外，即使 <code>notify_one()</code> 在 <code>wait()</code>之前调用，<code>atomic_wait::wait()</code> 的语义也能保证正确性。因为<code>wait(&amp;counter, expected_value)</code> 只有在<code>counter</code> 的值等于 <code>expected_value</code>时才会阻塞，如果 <code>counter</code> 已经被修改，<code>wait</code>会立即返回。</p></blockquote><h2 id="总结">总结</h2><p>通过本文的学习，我们从零开始实现了一个功能完整的条件变量（Condvar），并在这个过程中解决了多个重要问题：</p><ol type="1"><li><p><strong>理解条件变量的本质</strong>：Condvar 本质上是一个配合Mutex使用的线程同步工具，它解决了"如何让线程在条件不满足时休眠，条件满足时被唤醒"这一经典并发编程问题。</p></li><li><p><strong>掌握两种实现策略</strong>：</p><ul><li><strong>v1 基础版本</strong>：直接使用 <code>atomic-wait</code>实现等待与唤醒机制</li><li><strong>v2 优化版本</strong>：通过 <code>num_waiters</code>计数器避免不必要的系统调用</li></ul></li><li><p><strong>深入理解内存顺序</strong>：通过分析 happens-before关系，我们发现可以使用 <code>Relaxed</code> 内存顺序，因为 Mutex 的<code>Release</code>/<code>Acquire</code>操作已经提供了必要的同步保障。</p></li></ol><p>掌握了这些知识后，你可以：</p><ul><li>在生产者-消费者场景中高效地同步线程</li><li>理解标准库 <code>std::sync::Condvar</code> 的实现原理</li><li>在设计自己的同步原语时做出正确的内存顺序选择</li><li>识别并避免并发编程中的常见陷阱</li></ul><p>条件变量虽然概念简单，但其背后涉及的原子操作、内存顺序、操作系统原语等知识却相当深入。通过亲手实现，我们不仅掌握了工具的使用，更重要的是理解了其背后的设计思想，这为我们后续学习更复杂的并发编程技巧打下了坚实基础。</p><p>下篇，我们将完成 <ahref="https://marabos.nl/atomics/building-locks.html#reader-writer-lock">RustAtomics and Locks</a> 的最后一个实战案例：手写一个读写锁（RwLock）！</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">在多线程编程中，你是否遇到过这样的困扰：消费者线程不断轮询检查数据是否准备好，白白浪费 CPU 资源？或者在生产者-消费者模式中，如何让消费者优雅地等待数据到来？本文将带你手写一个高效的 Condvar（条件变量），解决线程间的等待与唤醒问题。我们将从最基础的实现开始，逐步优化到减少不必要的系统调用，并深入分析内存顺序的选择，让你彻底理解条件变量背后的设计哲学。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 实战" scheme="https://hedon.top/categories/rust/rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨手写一个 Mutex</title>
    <link href="https://hedon.top/2025/06/09/rust-action-mutex/"/>
    <id>https://hedon.top/2025/06/09/rust-action-mutex/</id>
    <published>2025-06-09T00:51:46.000Z</published>
    <updated>2025-06-12T17:05:57.295Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><ahref="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust实战丨手写一个 SpinLock</a></li><li><ahref="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust实战丨手写一个 Mutex</a> 👈 本篇</li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust实战丨手写一个 RwLock</a></li></ul><hr /><p>继上篇 <ahref="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a>，我们学习了不同操作系统下的并发原语实现，理解了它们最重要的贡献就是提供了一套<code>wait/wake_one/wake_all</code> 的机制。本篇，我们将借助 <ahref="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 的作者 <ahref="https://github.com/m-ou-se">Mara Bos</a> 封装的 <ahref="https://github.com/m-ou-se/atomic-wait">atomic-wait</a>crate，来手写一个自己的 <code>Mutex</code>！</p><h2 id="v1基本实现">v1：基本实现</h2><p>首先我们来思考一下如何定义数据结构：</p><ol type="1"><li>我们需要 1 个原子变量 <strong>state</strong> 来记录锁的状态（0:unlocked, 1: locked），因为 <code>atomic-wait</code> 只支持AtomicU32，所以这里我们的类型也定义为 AtomicU32。</li><li>另外我们需要一个 <strong>value</strong>字段来保存数据，当抢到锁的时候，是可以对 <strong>value</strong>进行修改的，但是这个时候只有共享引用，所以我们需要<code>UnsafeCell</code> 来提供内部可变性。</li></ol><p>同时，贯彻 <em>RAII（Resource Acquisition IsInitialization，资源获取即初始化）</em>原则：</p><ol type="1"><li>我们在 <code>lock(&amp;self)</code> 成功时返回一个<code>MutexGuard</code>，它包含 <code>&amp;Mutex</code>。</li><li>在 <code>MutexGuard</code> drop 的时候，我们将<strong>state</strong> 重置为0，表示释放锁，并唤醒一个潜在的阻塞线程。</li></ol><p>为了让 <code>Mutex</code> 可以在线程之间共享，我们需要为其实现<code>Sync</code> trait，而又因为 <code>Mutex</code>实现的是独占访问，上锁成功的线程是拥有 T 的所有权的，即要求 T可以在线程中转移，即要求 T 需要实现 <code>Send</code> trait。</p><p>综上，我们定义的 <code>Mutex</code> 和 <code>MutexGuard</code>结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Mutex</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// 0: unlocked</span></span><br><span class="line">    <span class="comment">/// 1: locked</span></span><br><span class="line">    state: AtomicU32,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    mutex: &amp;<span class="symbol">&#x27;a</span> Mutex&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Mutex</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Mutex&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            state: AtomicU32::<span class="title function_ invoke__">new</span>(<span class="number">0</span>),</span><br><span class="line">            value: UnsafeCell::<span class="title function_ invoke__">new</span>(value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方面访问内部数据，我们为 <code>MutexGuard</code> 实现<code>Deref</code> 和 <code>DerefMut</code> 这 2 个 trait:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*<span class="keyword">self</span>.mutex.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.mutex.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>MutexGuard</code> 离开作用域的时候，即被 drop的时候，我们需要释放锁，并调用 <code>wake_one</code>去唤醒一个潜在的阻塞线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.mutex.state.<span class="title function_ invoke__">store</span>(<span class="number">0</span>, Release);</span><br><span class="line">        <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.mutex.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将 <code>state</code> 设置为 0，使用的内存顺序是<code>Release</code>，是为了跟 <code>lock</code> 的时候使用<code>Acquire</code> 建立 happens-before 原则，确保 state的真实值在各个线程中都是可见的。</p><p>在 <code>lock</code> 的时候，我们需要将 <code>state</code> 从 0替换为 1，如果成功，则说明上锁成功，直接返回MutexGuard，如果失败，则说明锁已经被抢占了，这个时候我们使用<code>atomic-wait</code> 的 <code>wait()</code> 陷入休眠，等待<code>wake_one</code> 信号唤醒，再尝试抢锁。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Mutex&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> MutexGuard&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.state.<span class="title function_ invoke__">swap</span>(<span class="number">1</span>, Acquire) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">wait</span>(&amp;<span class="keyword">self</span>.state, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MutexGuard &#123; mutex: <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们第一个版本的 <code>Mutex</code>就完工了！是不是很简单！我们来写 2个单元测试验证一下基本逻辑是否正确：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard</span> = l.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">    guard.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(guard);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guard</span> = l.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(guard[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">l</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard</span> = l.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">            guard.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>)); <span class="comment">// sleep for makeing the second thread to be blcoked.</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>)); <span class="comment">// make sure the first thread get the lock</span></span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guard</span> = l.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">            guard.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guard</span> = l.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(guard.<span class="title function_ invoke__">len</span>(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">running 2 tests</span><br><span class="line">test mutex::tests::one_thread_should_work ... ok</span><br><span class="line">test mutex::tests::cross_thread_should_work ... ok</span><br></pre></td></tr></table></figure><h2 id="v2减少系统调用">v2：减少系统调用</h2><p>当 <code>MutexGuard</code> 的时候，我们将 <code>state</code> 置为0，并调用 <code>wake_one</code>唤醒一个潜在的线程，这个时候如果没有阻塞中的线程的话，那这个系统调用就比较浪费了。</p><p>所以在 v2 版本我们尝试来优化这一点。为此，我们需要扩展我们的<code>state</code>字段，新增<strong>表示是否有阻塞线程</strong>的能力。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Mutex</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// 0: unlocked</span></span><br><span class="line">    <span class="comment">/// 1: locked, but no blocked thread</span></span><br><span class="line">    <span class="comment">/// 2: locked, but has blocked threads</span></span><br><span class="line">    state: AtomicU32,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改了 <code>state</code>的定义后我们需要修改上锁和解锁的逻辑，在上锁的时候，我们先尝试将<code>state</code> 从 <code>0</code> 置为<code>1</code>，如果成功了，说明抢到了锁，否则，我们将<code>state</code> 置为 <code>2</code>，表示有线程被阻塞了。</p><p>这里书中的实现是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Mutex&lt;T&gt; &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> MutexGuard&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">lock_contended</span>(&amp;<span class="keyword">self</span>.state);</span><br><span class="line">        MutexGuard &#123; mutex: <span class="keyword">self</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">lock_contended</span>(state: &amp;AtomicU32) &#123;</span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="number">1</span>, Acquire, Relaxed).<span class="title function_ invoke__">is_err</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> state.<span class="title function_ invoke__">swap</span>(<span class="number">2</span>, Acquire) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">wait</span>(&amp;state, <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.mutex.state.<span class="title function_ invoke__">swap</span>(<span class="number">0</span>, Release) == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;wake_one&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">wake_one</span>(&amp;<span class="keyword">self</span>.mutex.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lock()</code>:</p><ul><li>如果成功将 <code>state</code> 从 <code>0</code> 变换为<code>1</code>，则说明当前线程抢锁成功，直接返回<code>MutexGuard</code>。</li><li>如果失败了，就将 <code>state</code> 置为 <code>2</code>，然后调用<code>wait</code> 进入休眠。</li></ul><p><code>unlock()</code>:</p><ul><li>将 <code>state</code> 置为 <code>0</code>，如果之前是 <code>2</code>的话，那就说明有线程被阻塞着，这个时候才调用 <code>wake_one</code>唤醒一个阻塞的线程。</li></ul><p>这个地方，笔者觉得有一些问题， <code>state.swap(2, Acquire)</code>这一行代码会无条件将 <code>state</code> 置为<code>2</code>，也就是说，当这个线程抢到锁后，它在 <code>unlock()</code>的时候，无论有没有在阻塞的线程，这个时候 <code>state</code> 都是<code>2</code>，所以都会调用 <code>wake_one</code>。</p><pre class="mermaid">sequenceDiagram    participant A as 线程A (持有锁)    participant B as 线程B (尝试获锁)    participant State as Mutex State    participant System as 系统调用    Note over State: state = 1 (线程A持有锁)    B->>State: compare_exchange(0, 1)    State-->>B: 失败 (返回 1)    Note over B: 进入 while 循环    B->>State: swap(2)    Note over State: state: 1 → 2    State-->>B: 返回 1 (≠ 0)    B->>System: wait(&state, 2)    Note over B: 线程B进入等待状态    Note over A: 线程A释放锁    A->>State: swap(0)    Note over State: state: 2 → 0    State-->>A: 返回 2    A->>System: wake_one()    Note over System: 正确的唤醒！线程B确实在等待    Note over B: 线程B被唤醒，继续循环    B->>State: swap(2)    Note over State: state: 0 → 2    State-->>B: 返回 0，退出循环    Note over B: 获得锁，但state=2 (问题所在)    Note over B: 使用锁...    B->>State: unlock() - swap(0)    Note over State: state: 2 → 0    State-->>B: 返回 2    B->>System: wake_one()    Note over System: 不必要的调用！此时没有等待者</pre><p>我们可以运行上面的测试用例<code>cross_thread_should_work</code>，可以看到输出了 2 个wake_one，但是通过分析，应该只需要调用一次 <code>wake_one</code>就足够了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test mutex::tests::cross_thread_should_work ... ok</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line"></span><br><span class="line">---- mutex::tests::cross_thread_should_work stdout ----</span><br><span class="line">wake_one</span><br><span class="line">wake_one</span><br></pre></td></tr></table></figure><p>笔者的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">lock_contended</span>(state: &amp;AtomicU32) &#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Err</span>(s) = state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="number">1</span>, Acquire, Relaxed) &#123;</span><br><span class="line">        <span class="keyword">if</span> s == <span class="number">1</span> &#123;</span><br><span class="line">            _ = state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">1</span>, <span class="number">2</span>, Acquire, Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">wait</span>(&amp;state, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>我们获取 <code>state.compare_exchange(0,1)</code>的返回值，如果成功，说明抢到锁，直接返回。</li><li>如果失败了：<ul><li>原始值是 <code>1</code>，那我们就尝试将 <code>state</code> 从<code>1</code> 交换为 <code>2</code>，然后调用 <code>wait</code>陷入休眠。</li><li>原始值是<code>2</code>，说明已经有别的线程也被阻塞了，这个时候直接调用<code>wait</code> 陷入休眠。</li></ul></li><li>当被 <code>wake_one</code> 唤醒时，重新执行<code>state.compare_exchange(0,1)</code> 抢占锁。</li></ol><p>这个新的流程中，我们抢到锁的时候，<code>state</code> 会被正确的设置为<code>1</code> 而不是 <code>2</code>，这个时候，在 <code>drop</code>的时候就不会有不必要的 <code>wake_one</code> 的调用了。</p><pre class="mermaid">sequenceDiagram    participant A as 线程A (持有锁)    participant B as 线程B (尝试获锁)    participant State as Mutex State    participant System as 系统调用    Note over State: state = 1 (线程A持有锁)    B->>State: compare_exchange(0, 1)    State-->>B: 失败，返回 s=1    Note over B: s == 1，尝试设置等待者标志    B->>State: compare_exchange(1, 2)    Note over State: state: 1 → 2    State-->>B: 成功    B->>System: wait(&state, 2)    Note over B: 线程B进入等待状态    Note over A: 线程A完成工作，释放锁    A->>State: unlock() - swap(0)    Note over State: state: 2 → 0    State-->>A: 返回 2    A->>System: wake_one()    Note over System: 正确唤醒线程B    Note over B: 线程B被唤醒，重新尝试获取锁    B->>State: compare_exchange(0, 1)    Note over State: state: 0 → 1 (关键！)    State-->>B: 成功！退出循环    Note over B: 🎯 获得锁，state=1 (正确状态)    Note over B: 使用锁进行工作...    B->>State: unlock() - swap(0)    Note over State: state: 1 → 0    State-->>B: 返回 1 (不是2！)    Note over B: ✅ 返回值是1，不调用wake_one    Note over System: 🎯 避免了不必要的系统调用</pre><p>我们重新运行上面的测试用例<code>cross_thread_should_work</code>，可以看到只输出了 1 个wake_one：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test mutex::tests::cross_thread_should_work ... ok</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line"></span><br><span class="line">---- mutex::tests::cross_thread_should_work stdout ----</span><br><span class="line">wake_one</span><br></pre></td></tr></table></figure><blockquote><p>不过笔者在做 benchmark 后发现书中的实现性能其实更高，在 macbook m2max机器上，书中的版本要比我的版本快 5~10% 左右，猜测大概率是<code>swap</code> 的性能要比 <code>compare_exchange</code> 高。</p></blockquote><h2id="v3短暂自旋进一步避免系统调用">v3：短暂自旋进一步避免系统调用</h2><p>还有一种潜在的优化是，我们可以在抢锁失败且返回 <code>state</code> 为<code>1</code>的时候，进行短暂的自旋，如果实际场景中占用锁的时间非常短，那我们就可以再省略一次<code>wake</code> 的系统调用了。</p><p>不过值得注意的是，这种优化未必是正向的，一方面，如果锁占用时间比较长，那前面的自旋就白白浪费了，另一方面，自旋的次数带来的性能消耗，未必就比系统调用要小（不同的平台表现可能很不一样）。</p><p>书中给出的经验值是自选 <strong>100</strong> 次。</p><p>优化后的 <code>lock_contended</code> 如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">lock_contended</span>(state: &amp;AtomicU32) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spin_count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Err</span>(s) = state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">0</span>, <span class="number">1</span>, Acquire, Relaxed) &#123;</span><br><span class="line">        <span class="keyword">if</span> s == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> spin_count &lt; <span class="number">100</span> &#123;</span><br><span class="line">                spin_count += <span class="number">1</span>;</span><br><span class="line">                std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _ = state.<span class="title function_ invoke__">compare_exchange</span>(<span class="number">1</span>, <span class="number">2</span>, Acquire, Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">wait</span>(&amp;state, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>感兴趣的读者可以使用 <ahref="https://bheisler.github.io/criterion.rs/book/getting_started.html">criterion</a>做一个 benchmark 看看自旋与之前的版本的性能差异有多少。</p></blockquote><p>完整代码可参考：<ahref="https://github.com/hedon-rust-road/conutils/blob/main/src/mutex.rs">conutils/mutex</a>。</p><h2 id="总结">总结</h2><p>在本篇中，我们从零开始，结合 Rust原子操作和内存顺序的核心知识，实现一个 Rust 中的 Mutex 锁，逐步揭示Mutex 背后的等待与唤醒机制，为更好理解标准库中的 Mutex奠定了良好的基础。下篇，我们将尝试手写一个条件变量 <strong>ConditionVariable</strong>！</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">本文带你从零开始实现一个 Rust 中的 Mutex 锁，结合 Rust 原子操作和内存顺序的核心知识，逐步揭示 Mutex 背后的等待与唤醒机制。通过阅读本文，你不仅可以掌握如何使用 Rust 的原子 API 实现一个高效的互斥锁，还能深入理解原子操作背后的内存模型，为掌握更复杂的并发编程技巧打下坚实基础。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 实战" scheme="https://hedon.top/categories/rust/rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rust 原理丨操作系统并发原语</title>
    <link href="https://hedon.top/2025/06/08/rust-os-primitives/"/>
    <id>https://hedon.top/2025/06/08/rust-os-primitives/</id>
    <published>2025-06-08T09:45:28.000Z</published>
    <updated>2025-06-12T17:06:47.213Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><ahref="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust实战丨手写一个 SpinLock</a></li><li><ahref="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a> 👈 本篇</li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust实战丨手写一个 RwLock</a></li></ul><hr /><p>在本系列的前面所有篇章中，我们对非阻塞类的并发操作进行了详细的阐述和实践（除了SpinLock，不过自旋锁是通过自旋来实现阻塞作用，本质上线程并没有陷入阻塞等待的状态）。</p><p>后面我们将继续参考 <a href="https://marabos.nl/atomics/">Rust Atomicsand Locks</a> 书中的后续篇章，继续手写几个阻塞类的并发工具，有Mutex（互斥锁）、RwLock（读写锁）和CondVar（条件变量）。它们都有一个共同的特点：<strong>线程会陷入阻塞，让出CPU，在等待某个条件满足要求后，会被唤醒并重新调度执行</strong>。这就需要借助内核的能力了，我们需要内核支持：</p><ol type="1"><li>记住那些陷入阻塞的线程；</li><li>在满足条件后，能够唤醒对应的正确的线程。</li></ol><p>熟悉操作系统原理的读者应该清楚，我们编写的应用程序，一般是处于<strong>用户态</strong>，而想要跟内核进行交互，需要陷入<strong>内核态</strong>，而这种切换，很大程度需要依赖于操作系统提供的系统调用能力，即<code>syscall</code>。</p><p>所以在进入手写 Mutex、RwLock 和 CondVar篇章之前，我们需要先来学习一下，不同的操作系统，都为我们在并发操作中提供了什么样的能力和限制。</p><p>在 <a href="https://marabos.nl/atomics/os-primitives.html">RustAtomics and Locks</a> 第八章（Operating SystemPrimitives）中，作者介绍并比较了各平台提供的操作系统级并发原语，包括POSIX 的 <code>pthread</code> 系列、Linux 的 <code>futex</code>、macOS的 <code>os_unfair_lock</code>，以及 Windows的<code>重量级内核对象</code>、<code>轻量级对象</code>和<code>基于地址的等待机制</code>。</p><p>在本篇，笔者将基于自己的理解，尝试对这章进行梳理和总结，以便为后面的手写实践篇章奠定一个良好的理论基础，这里还是建议读者去阅读原文，以便获得更多的细节，加深理解。</p><h1 id="posix-线程原语-pthread">POSIX 线程原语 pthread</h1><p>在 Unix 类操作系统中，比如 Linux，<code>libc</code>就承担了跟内核进行交互的标准接口。在 <code>libc</code>的基础之前，诞生了一个标准：<em>Portable Operationg SystemInterface</em>，即熟知的 <strong>POSIX</strong>。在 Rust 中，对应了 <ahref="https://crates.io/crates/libc">libc</a> crate。</p><p>Windows 系统并不遵循 POSIX标准，而是一系列的系统库来提供内核交互能力，比如 <ahref="https://www.geoffchappell.com/studies/windows/win32/kernel32/api/index.htm">kernel32.dll</a>。</p><p>针对线程操作，POSIX 定义了一系列的数据类型和函数，即所谓的<strong>pthreads</strong>。它提供了以下几个比较重要的并发原语，我将其归纳为一个表格，供你参考。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250608190516988.png" /></p><h1 id="linuxfutex-用户态等待与唤醒">Linux：Futex 用户态等待与唤醒</h1><p>在 Linux 中，所有 <code>pthread</code> 原语的实现，都是通过<strong>futex</strong> 这个系统调用。它是全程是 <em>fast user-spacemutex</em>。它的实现核心是：<strong>通过操作一个 32位的原子变量来实现等待和唤醒</strong>。等待操作会将一个线程陷入睡眠，而唤醒操作会唤醒那些操作同一个原子变量的睡眠中的线程。</p><p>这里我们简单进行一下展开，思考一下这个 <code>futex</code>这个名字的含义，<em>fast user-space mutex</em>翻译成中文就是<em>快速用户空间互斥锁</em>。我们知道，系统调用的代价是比较昂贵的，需要频繁地在用户态和内核态之间进行切换，对性能是很不友好的。</p><p>在 Linux 系统中，<strong>futex</strong>机制并非独立存在，而是与互斥锁、条件变量等同步原语协同工作，形成“<strong>用户态自旋 + 内核态等待</strong>”的分层设计，以兼顾性能与功能。</p><p>比如在 Mutex 互斥锁场景下，采用 “两级等待” 策略：</p><ul><li><strong>用户态自旋阶段</strong>：尝试获取锁时先通过原子操作（如<code>atomic_compare_exchange</code>）自旋尝试，避免内核调用。</li><li><strong>内核态等待阶段</strong>：若自旋失败，通过 Futex 的<code>FUTEX_WAIT</code> 陷入内核，将线程挂起，直到其他线程通过<code>FUTEX_WAKE</code> 唤醒。</li></ul><p>这样多数短时间持锁场景可在用户态完成，仅在长时间竞争时陷入内核，相比纯内核互斥锁（如spinlock）大幅降低系统调用开销。</p><p>这里有个很重要的点：<strong>判断和陷入等待，是原子的</strong>。也就是说，线程A在确定陷入等待时，如果关联的原子变量已经发生了变化，这个时候，不会陷入等待，而是会直接返回。这也就避免了唤醒信号的丢失。</p><p>这里我整理了 <strong>futex</strong> 的核心操作，供你参考：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250608190538982.png" /></p><h1 id="macos公平的-pthread-与非公平的-os_unfair_lock">macOS：公平的pthread 与非公平的 os_unfair_lock</h1><p>在 macOS 上，线程/锁的内核 syscalls（<code>__psynch_*</code>等）<strong>不是公开稳定 ABI</strong>，官方要求开发者只通过<strong>LibSystem</strong>（libc + libpthread + Objective-C/Swiftruntime 等）来访问，它们都完全实现了 <code>pthread</code>。</p><p>不过值得注意的是，在 macOS 10.12 版本之前，macOS 的 pthread lock默认都是公平锁（fair locks），不过在 macOS 10.12 (Sierra, 2016) 起新增了<ahref="https://developer.apple.com/documentation/os/os_unfair_lock">os_unfair_lock</a>，它是一个不公平、阻塞型、低开销的锁，取代了已弃用的<code>OSSpinLock</code>。</p><p>需要注意，<code>os_unfair_lock</code>没有提供对应的条件变量或读写锁功能。也就是说，如果需要使用条件等待或读写锁语义，仍需使用<code>pthread_cond_t</code> 或 <code>pthread_rwlock_t</code> 等 POSIX原语，或者使用更高层的 GCD（Grand Central Dispatch）并发模型。Apple将<code>os_unfair_lock</code> 定位为替代早期的 <code>OSSpinLock</code>的低级锁，以解决 <code>OSSpinLock</code>存在的优先级反转问题，同时提供比 <code>pthread_mutex</code>更快的性能。<code>os_unfair_lock</code> 内部会在必要时让出 CPU而非自旋等待，从而避免高优先级线程饥饿，但调度上又不像<code>pthread_mutex</code> 那样严格 FIFO。</p><h1 id="windows">Windows</h1><p>Windows 提供了一系列独特的并发原语，可分为<ahref="https://learn.microsoft.com/en-us/windows/win32/sysinfo/kernel-objects">重量级内核对象</a>、轻量级对象（如<ahref="https://learn.microsoft.com/en-us/windows/win32/sync/critical-section-objects">CriticalSection</a>、<ahref="https://learn.microsoft.com/en-us/windows/win32/sync/slim-reader-writer--srw--locks">SRW锁</a>、<ahref="https://learn.microsoft.com/en-us/windows/win32/sync/condition-variables">ConditionVariable 条件变量</a>等）和<ahref="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitonaddress">基于地址的等待机制</a>三大类。它们在API 设计、用法和实现上各不相同，体现了 Windows 从早期到现代的演进。</p><h2id="重量级内核对象基于-handle-的-wait-与-notify">重量级内核对象：基于HANDLE 的 wait 与 notify</h2><p>Windows的重量级同步原语是由内核完全管理的对象，典型代表包括：<strong>Mutex</strong>（互斥量）、<strong>Event</strong>（事件）、<strong>Semaphore</strong>（信号量）、<strong>WaitableTimer</strong>（可等待计时器）等。这些对象通过 Windows API创建，相当于创建了一个内核对象句柄（<strong>HANDLE</strong>），类似打开文件会得到文件句柄一样。每个对象在内核有对应的数据结构，操作系统维护其状态和等待队列。具体可以参考：<ahref="https://learn.microsoft.com/en-us/windows/win32/sysinfo/kernel-objects">重量级内核对象</a>。</p><p>我整理了它们的基本使用方式，供你参考：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250608192945913.png" /></p><h2id="轻量级对象criticalsectionsrwlock-与-conditionvariable">轻量级对象：CriticalSection、SRWLock与 ConditionVariable</h2><p>"轻量级"同步原语是指<strong>不以独立内核对象形式存在、主要在用户态运作、仅在必要时调用内核的机制</strong>。</p><blockquote><p>是不是已经开始有点 futex 的感觉了？🤭</p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250608224608594.png" /></p><p><strong>CRITICAL_SECTION</strong></p><p>它并非通过 Create 函数得到句柄，而是定义为结构体<code>CRITICAL_SECTION</code>，需调用<code>InitializeCriticalSection()</code>初始化，之后直接用地址操作。本质上是一个递归互斥锁，同一个线程可以多次<code>Enter</code>，内部有一个递归计数，必须对应次数的<code>Leave</code> 才能完全释放。</p><p>Critical Section 在未争用情况下尝试通过用户态 Atomic 操作获取，比如CAS交换为当前线程，成功则进入，失败则可能先自旋尝试，依旧失败再进入内核等待。</p><p><strong>SRW Locks</strong></p><p>SRW Locks 不支持递归获取，同一线程如果持有写锁，再请求写锁会死锁。SRW之所以被称为 "slim"锁，是因为其实现相当高效，无锁时获取和释放都是用户态的 Atomic操作，发生争用时，内核用一个优化的等待机制管理等待队列。</p><p><strong>Condition Variable</strong></p><p>是 <a href="https://wuu.wikipedia.org/wiki/Windows_Vista">Vista</a>时代引入的新原语，它必须搭配 Critical Section 或 SWR Lock 使用。</p><h2id="基于地址的等待机制waitonaddress">基于地址的等待机制：WaitOnAddress</h2><p>Windows 在 8 版（2012）引入了全新的底层同步机制，与 Linux futex非常相似，主要函数有：</p><ul><li><code>WaitOnAddress(address, compare_address, _,_)</code>:让当前线程在 address 指向的内存值满足特定条件前进入睡眠，函数会将address 处提供的值和 compare_address提高的值逐字节比较，如果全等，则线程睡眠，等待后续唤醒，如果不等，函数立即返回。与futex_wait相同，<strong>比较与睡眠是一个原子操作</strong>：在检查内存值与期望值决定休眠的过程中，若有其他线程改变了address 或发起唤醒，系统会保证不漏掉信号。</li><li><code>WakeByAddressSingle(address)</code>:唤醒在指定地址上等待的一个线程。</li><li><code>WakeByAddressAll(address)</code>:唤醒在指定地址上等待的所有线程。</li></ul><p>在实现上，WaitOnAddress非常轻量，没有显式的内存对象或句柄。当线程等待时，内核只是将线程放入与那块内存地址相关联的等待队列中，唤醒时根据地址找到等待线程列表进行唤醒。</p><h1 id="总结">总结</h1><p>通过对 3个不同的操作系统的分析，从大的角度来讲，我们会发现它们的并发原语最重要的就是要利用原子变量，在用户态实现3 个操作，以减少系统调用的出现，进一步提升性能。这 3个操作可以归纳为：</p><ul><li><strong>wait(&amp;AtomicU32)</strong>:在原子变量等于期望值的时候陷入等待，否则直接返回。</li><li><strong>wake_one(&amp;AtomicU32)</strong>: 唤醒某个<code>wait()</code> 在当前变量的线程。</li><li><strong>wake_all(&amp;AtomicU32)</strong>: 唤醒所有<code>wait()</code> 在当前变量的线程。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250608232051766.png" /></p><p>所以下一步如果我们想在编程语言的层面上（Rust）实现自己的<code>Mutex</code>、<code>REMutex</code> 和<code>CondVar</code>，第一步就是需要针对不同的操作系统实现一套<code>wait/wake_one/wake_all</code>以屏蔽不同操作系统的实现差异，幸运的是 <ahref="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 的作者 <ahref="https://github.com/m-ou-se">Mara Bos</a> 已经帮我们实现好了：<ahref="https://github.com/m-ou-se/atomic-wait">atomic-wait</a>。下篇，我们就利用这个crate，来一步步手写一个自己的 <code>Mutex</code>！</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">操作系统的并发原语是实现各种锁、条件变量和同步工具的核心基础。无论是 Linux 中被广泛使用的 futex、macOS 中的 pthread 和 os_unfair_lock，还是 Windows 系统上的重量级内核对象、轻量级原语及地址等待机制，本质上都是围绕着三个基本动作展开：wait、wake_one 和 wake_all。本文将通过对三大主流操作系统底层并发原语的梳理与对比，帮助你建立统一的认知框架，更深入地理解并发编程背后的系统级支持，避免在实践和学习中被五花八门的概念搞晕。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 原理" scheme="https://hedon.top/categories/rust/rust-%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="操作系统" scheme="https://hedon.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Rust 原理丨从汇编角度看原子操作</title>
    <link href="https://hedon.top/2025/06/05/rust-atomic-in-processor/"/>
    <id>https://hedon.top/2025/06/05/rust-atomic-in-processor/</id>
    <published>2025-06-05T00:36:03.000Z</published>
    <updated>2025-06-12T17:06:55.608Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><ahref="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust原理丨从汇编角度看原子操作</a> 👈 本篇</li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust实战丨手写一个 SpinLock</a></li><li><ahref="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust实战丨手写一个 RwLock</a></li></ul><hr /><p>继上篇 <a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust原理丨聊一聊 Rust 的 Atomic 和内存顺序</a>，我们详细介绍了 Rust中的原子操作及内存顺序和内存屏障的诸多概念。我们知道，之所以要在硬件层面之上的编程语言中，抽象出这些顶层概念，是为屏蔽底层硬件的差异。那么本篇，我们就尝试从汇编代码和硬件层面来分析在不同的计算机架构下这些概念是如何被实现的，它们之间就有哪些具体的差异。</p><p>在展开之前，我们先来复习一下 Rust 中的内存顺序和内存屏障。</p><p>Rust 支持五种内存顺序（Ordering），从最松散到最严格依次为：</p><table><colgroup><col style="width: 3%" /><col style="width: 12%" /><col style="width: 37%" /><col style="width: 29%" /><col style="width: 16%" /></colgroup><thead><tr><th>内存顺序</th><th>说明</th><th>保证</th><th>适用场景</th><th>示例</th></tr></thead><tbody><tr><td>Relaxed</td><td>最宽松的内存顺序</td><td>- 仅保证操作的原子性<br>- 不提供任何同步保证<br>- 不建立happens-before 关系</td><td>- 简单计数器<br>- 性能要求极高且确定不需要同步<br>-已通过其他方式确保同步</td><td><code>counter.fetch_add(1, Ordering::Relaxed)</code></td></tr><tr><td>Release</td><td>用于存储操作</td><td>- 之前的内存访问不会被重排到此操作之后<br>- 与 Acquire配对使用可建立 happens-before 关系</td><td>- 生产者-消费者模式<br>- 发布共享数据<br>- 初始化完成标志</td><td><code>data.store(42, Ordering::Release)</code></td></tr><tr><td>Acquire</td><td>用于加载操作</td><td>- 之后的内存访问不会被重排到此操作之前<br>- 与 Release配对使用可建立 happens-before 关系</td><td>- 生产者-消费者模式<br>- 获取共享数据<br>- 检查初始化标志</td><td><code>data.load(Ordering::Acquire)</code></td></tr><tr><td>AcqRel</td><td>同时包含 Acquire 和 Release 语义</td><td>- 结合了 Acquire 和 Release 的所有保证<br>- 用于读改写操作</td><td>- 需要双向同步的原子操作<br>- 锁的实现<br>- 复杂的同步原语</td><td><code>value.fetch_add(1, Ordering::AcqRel)</code></td></tr><tr><td>SeqCst</td><td>最严格的内存顺序</td><td>- 包含 AcqRel 的所有保证<br>- 所有线程看到的所有 SeqCst操作顺序一致<br>- 提供全局的顺序一致性</td><td>- 需要严格的全局顺序<br>- 不确定使用哪种顺序时<br>-对性能要求不高的场景</td><td><code>flag.store(true, Ordering::SeqCst)</code></td></tr></tbody></table><p>内存屏障主要分为以下几种类型：</p><ol type="1"><li><p><strong>Load Barrier（读屏障）</strong></p><ul><li>确保在屏障之前的所有读操作都执行完成</li><li>防止后续读操作被重排到屏障之前</li><li>对应 Acquire 语义</li></ul></li><li><p><strong>Store Barrier（写屏障）</strong></p><ul><li>确保在屏障之前的所有写操作都执行完成</li><li>防止后续写操作被重排到屏障之前</li><li>对应 Release 语义</li></ul></li><li><p><strong>Full Barrier（全屏障）</strong></p><ul><li>同时包含读屏障和写屏障的功能</li><li>防止任何内存操作的重排序</li><li>对应 SeqCst 语义</li></ul></li></ol><h1 id="读完本篇你能学到什么">读完本篇你能学到什么</h1><ol type="1"><li><p><strong>汇编分析能力</strong>：掌握从 Rust代码到汇编指令的完整分析链路，能够使用 <code>cargo-show-asm</code> 或Compiler Explorer 等工具深入理解代码的底层实现。</p></li><li><p><strong>跨平台差异洞察</strong>：深刻理解 x86-64（CISC）与ARM64（RISC）两大主流架构在原子操作实现上的本质差异，为性能优化和平台适配提供理论基础。</p></li><li><p><strong>内存顺序选择策略</strong>：不再需要死记硬背五种内存顺序，而是基于硬件特性和性能考量做出明智选择—— 知道何时用 <code>Relaxed</code> 追求极致性能，何时必须上<code>SeqCst</code> 保证正确性。</p></li><li><p><strong>原子性保证机制</strong>：理解为什么同样的汇编代码，普通操作与原子操作在编译器层面有本质区别，以及对齐访问与跨缓存行访问的不同行为。</p></li><li><p><strong>硬件协议原理</strong>：掌握 MESI 缓存一致性协议、x86 的<code>lock</code> 机制、ARM 的 <code>LL/SC</code>机制等底层实现原理，能够解释多核环境下的数据同步过程。</p></li><li><p><strong>性能优化洞察</strong>：理解不同架构下内存屏障的开销差异，为高性能并发代码提供优化方向（如ARM64 上 <code>compare_exchange_weak</code> 的真实优势）。</p></li><li><p><strong>并发问题调试</strong>：当遇到并发 bug时，能够从汇编层面分析问题根因，判断是内存顺序问题还是原子性问题。</p></li><li><p><strong>架构适配能力</strong>：在跨平台开发中，能够针对不同架构的特性（如x86-64 的强顺序 vs ARM64 的弱顺序）做出相应的代码调整。</p></li><li><p><strong>锁与无锁数据结构设计</strong>：基于硬件原理设计高效的同步原语，理解何时选择基于CAS 的无锁算法，何时选择传统锁机制。</p></li></ol><p>在进入汇编代码的世界之前，我们先简单补充 2个重要概念，分别是<strong>指令集</strong>和 CPU 缓存一致性协议<strong>MESI</strong>。</p><h1 id="指令集">指令集</h1><p>两种指令集：</p><ul><li>CISC（Complex Instruction Set Computing，复杂指令集）</li><li>RISC（Reduced Instruction Set Computing，精简指令集）</li></ul><p>二者对比：</p><table><colgroup><col style="width: 15%" /><col style="width: 45%" /><col style="width: 39%" /></colgroup><thead><tr><th style="text-align: left;">特征</th><th style="text-align: left;">RISC</th><th style="text-align: left;">CISC</th></tr></thead><tbody><tr><td style="text-align: left;">指令集</td><td style="text-align: left;">精简，指令数目少</td><td style="text-align: left;">复杂，指令数目多</td></tr><tr><td style="text-align: left;">指令复杂性</td><td style="text-align: left;">指令简单，每条指令执行单一功能</td><td style="text-align: left;">指令复杂，可以执行多个功能</td></tr><tr><td style="text-align: left;">寻址方式</td><td style="text-align: left;">简单寻址方式</td><td style="text-align: left;">复杂寻址方式</td></tr><tr><td style="text-align: left;">硬件实现</td><td style="text-align: left;">易于实现</td><td style="text-align: left;">实现复杂</td></tr><tr><td style="text-align: left;">编译器</td><td style="text-align: left;">高效编译器</td><td style="text-align: left;">编译器效率相对较低</td></tr><tr><td style="text-align: left;">运算速度</td><td style="text-align: left;">快速</td><td style="text-align: left;">相对慢</td></tr></tbody></table><blockquote><p>具体可参考：<ahref="https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/">riscvs. cisc</a>。</p></blockquote><p>两种指令集分别对应两种最典型的计算机架构：</p><ul><li><strong>x86-64</strong>：<strong>基于 CISC（复杂指令集）的 64位扩展架构</strong>，由 AMD 设计并主导，兼容 x86 32位生态，通过硬件复杂性换取高性能与广泛兼容性，主导桌面与服务器领域。</li><li><strong>arm64</strong>：<strong>基于 RISC（精简指令集）的 64位架构</strong>，由 ARM设计，以精简指令、高能效为核心，原生支持低功耗场景，主导移动设备并逐步扩展至服务器与PC 领域。</li></ul><p>在本篇中，我们只涉及 2 个平台：</p><ul><li>x86_64-unknown-linux-musl（以下简称 x86-64）</li><li>aarch64-unknown-linux-musl（以下简称 ARM64）</li></ul><p>要将 Rust 代码编译为指定平台的可执行文件：</p><ol type="1"><li><p>安装对应的目标平台</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rustup target add x86_64-unknown-linux-musl  # x86-64</span><br><span class="line">rustup target add aarch64-unknown-linux-musl # ARM64</span><br></pre></td></tr></table></figure></li><li><p>编译时使用 <code>--target</code> 标志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release --target x86_64-unknown-linux-musl</span><br><span class="line">cargo build --release --target aarch64-unknown-linux-musl</span><br></pre></td></tr></table></figure></li></ol><h1 id="缓存一致性协议-mesi">缓存一致性协议 MESI</h1><p>在多核系统中，每个核心都有自己的缓存（L1/L2Cache），而内存中的数据可能被多个核心同时读取或修改。如果不加控制，会导致以下问题：</p><ul><li><strong>缓存不一致（Cache CoherenceProblem）</strong>：不同核心的缓存可能持有同一内存地址的不同副本。</li><li><strong>脏数据（DirtyData）</strong>：某个核心修改了数据，但其他核心仍使用旧值。</li></ul><p>MESI（<strong>Modified, Exclusive, Shared,Invalid</strong>）是一种广泛使用的<strong>缓存一致性协议</strong>（Cache CoherenceProtocol），用于确保多核处理器系统中各个核心的缓存数据保持一致。它定义了缓存行的<strong>4种状态</strong>，并通过状态转换和消息传递机制来协调多核间的数据访问。</p><table><colgroup><col style="width: 14%" /><col style="width: 37%" /><col style="width: 48%" /></colgroup><thead><tr><th style="text-align: center;">状态</th><th style="text-align: left;">含义</th><th style="text-align: left;">特点</th></tr></thead><tbody><tr><td style="text-align: center;"><strong>M (Modified)</strong></td><tdstyle="text-align: left;">当前核心独占此数据，且已修改（与内存不一致）</td><tdstyle="text-align: left;">只有本核心有最新数据，必须写回内存后才能被其他核心读取。</td></tr><tr><td style="text-align: center;"><strong>E (Exclusive)</strong></td><tdstyle="text-align: left;">当前核心独占此数据，但未修改（与内存一致）</td><tdstyle="text-align: left;">可以安全读取或修改，无需通知其他核心。</td></tr><tr><td style="text-align: center;"><strong>S (Shared)</strong></td><td style="text-align: left;">多个核心共享此数据（与内存一致）</td><td style="text-align: left;">所有核心只能读取，不能直接修改（需先升级为<code>M</code> 或 <code>E</code>）。</td></tr><tr><td style="text-align: center;"><strong>I (Invalid)</strong></td><td style="text-align: left;">缓存行无效（数据已过期或未加载）</td><tdstyle="text-align: left;">必须从内存或其他核心重新加载最新数据。</td></tr></tbody></table><p>更多细节可参考：<ahref="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE">维基百科MESI</a>。</p><h1 id="查看-rust-汇编代码">查看 Rust 汇编代码</h1><p>查看 Rust 汇编代码的常用方式有以下几种：</p><ol type="1"><li><p>cargo rustc --lib --release --target x86_64-unknown-linux-musl ----emit asm</p></li><li><p><ahref="https://crates.io/crates/cargo-show-asm">cargo-show-asm</a>（推荐✅）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo asm --release --target=x86_64-unknown-linux-musl --lib &#123;module&#125;::&#123;func_name&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://godbolt.org/">Compiler Explorer</a> （推荐✅）</p></li></ol><p>接下来我们来看下各种 Atomic 操作的汇编代码是什么样的。</p><h2 id="store">Store</h2><p>x86-64：</p><ul><li>普通类型的赋值操作跟原子操作在 <code>Relaxed</code>顺序下生成的汇编的一模一样的！</li><li>在强顺序一致性要求的 <code>SeqCst</code> 下，使用了带有<code>Lock</code> 语义的 <code>xchg</code> 指令保证内存顺序。</li></ul><p>ARM64：</p><ul><li>普通类型的赋值操作跟原子操作在 <code>Relaxed</code>顺序下生成的汇编的也是一模一样的！</li><li>在强顺序一致性要求的 <code>SeqCst</code> 下，使用了原子存储指令<code>stlr</code> 保证内存顺序。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607135548507.png" /></p><p>那么问题就来了：普通类型的赋值操作与 Relaxed的原子操作生成的汇编一样，那凭什么后者就有原子性的保证呢？</p><ol type="1"><li>在上述 2 个架构中，这仅能说明 <code>mov</code> 和 <code>str</code>在（当前选择的）硬件层面是原子的，无论是否使用 Atomic 类型。这因为 CPU的缓存一致性协议（MESI）和总线锁定机制确保<strong>对齐操作</strong>不会撕裂（tearing）。</li><li>但是对于<strong>未对齐或跨缓存行访问</strong>，普通操作不保证原子性，可能被拆分为多次访问（如未对齐的i64 可能拆为 2 个 32 位写入）。</li></ol><p>所以在 Rust 编译器上：</p><ul><li><strong>普通操作（*x=0）</strong>：Rust不将其视为原子操作，即使生成的汇编与 <code>Relaxed</code>原子操作相同。编译器可能优化或重排普通操作，破坏原子性假设。<ul><li>如：循环中的多次普通写入可能被合并为一次（优化后仅保留最后一次写入）。</li></ul></li><li><strong>原子操作（x.store(0, Relaxed)）</strong>：Rust强制保证原子性，无论硬件是否隐式支持：<ul><li>对齐访问：直接生成 <code>mov</code>（利用硬件原子性）。</li><li>未对齐访问：插入额外指令（如<code>lock cmpxchg</code>）确保原子性。</li><li>禁止编译器优化重排或消除操作。</li></ul></li></ul><h2 id="load">Load</h2><p>x86-64：</p><ul><li>三段代码生成的汇编代码一模一样！这是因为 x86-64 的强顺序策略默认保证<code>mov</code> 具有顺序一致性（类似SeqCst），因此无需显示内存屏障。</li></ul><p>ARM64：</p><ul><li>对于普通类型的加载操作和 load Relaxed 生成的汇编代码是一样的。</li><li>对于 load SeqCst，使用了专门的原子加载指令<code>ldar</code>，它会隐式插入内存屏障，保证该操作之前的所有内存访问对其他线程可见。</li></ul><p>虽然 x86-64 对于上面的 3 段代码生成的汇编是一样的，但这只是 x86-64硬件层面上的保证，且跟之前一样，仅在对齐时是原子的，如果未对齐或跨缓存行访问，是可能被撕裂成2 个操作的。</p><p>在 ARM64 中，不依靠硬件层面的复杂性，而通过 <code>ldar</code>原子加载指令来保证原子性。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607135525872.png" /></p><h2 id="read-modify-write">Read-Modify-Write</h2><p>x86-64:</p><ul><li>使用 <code>lock</code> 指令来锁定总线或缓存行，从而实现原子性。</li></ul><p>ARM64:</p><ul><li>使用 <code>LL/SC</code>机制来实现原子操作（有点类似与乐观锁的味道）。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607135850075.png" /></p><h2 id="compare-and-exchange">Compare-and-Exchange</h2><p>x86-64:</p><ul><li>二者没有任何区别，或者可以理解为，x86-64 就没有专门实现<code>compare_exchange_weak</code>。</li></ul><p>ARM64:</p><ul><li>二者实现是不同的，在 ARM64 上，<code>compare_exchange_weak</code>是真的具备 <code>weak</code> 的特性。所以如果在特定场景下想用<code>compare_exchange_weak</code>来进一步提升性能，在上层也一定要用循环来主动重试，避免虚假失败。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607135449552.png" /></p><h2 id="fence">Fence</h2><p>x86-64:</p><ul><li>Release 和 Acquire 并没有额外使用的指令。只有使用 SeqCst内存屏障的时候，会插入一条 <code>mfence</code> (memory fence)指令，这条指令会保证在越过它之前，前面所有的内存操作都已经完成。</li></ul><p>ARM64:</p><ul><li>Release、AcqRel 和 SeqCst 都插入了一条 <code>dmb ish</code>(datamemory barrier, inner shared domain)。而 Acquire 则插入了一条<code>dmb ishld</code>，它只会等待 load 操作的完成，但是允许 store操作重排序到它后面。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607144937786.png" /></p><h2 id="总结对比">总结对比</h2><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607144757100.png" /></p><p>到这里我们可以得到以下结论：</p><ol type="1"><li>x86-64 保证原子性的关键是 <code>lock</code> 机制，ARM64保证原子性的关键是 <code>LL/SC</code> 机制。</li><li>x86-64 保证内存顺序的关键是 <code>mfence</code> 指令，ARM64保证内存顺序的关键是 <code>dmb ish</code> 和 <code>dmb ishld</code>指令。</li><li>x86-64 没有实现真实的 <code>compare_exchange_weak</code>，ARM64实现了 <code>compare_exchange_weak</code>。</li><li>x86-64 使用的是强顺序策略，具体来说：<ul><li><strong>Load→ 后续操作</strong>：禁止重排序（如 <code>Load A</code>→ <code>Store B</code> 必须保持顺序）。</li><li><strong>Store→ 前序操作</strong>：禁止重排序（如 <code>Load A</code>→ <code>Store B</code> 中 <code>Store B</code> 不能提前到<code>Load A</code> 前）。</li><li><strong>Store→ 后续 Load</strong>：允许重排序（如<code>Store A</code> → <code>Load B</code> 可能实际执行为<code>Load B</code> → <code>Store A</code></li></ul></li><li>ARM 使用的是弱顺序策略，即所有的原子操作都可能被重排序。</li><li>x86-64 中，Relaxed、Acquire、Release 和 AcqRel的内存顺序效果是一致的。ARM64 中，Relaxed 没有任何内存顺序的保证，而Release、AcqRel 和 SeqCst 是一样昂贵的，Acquire稍微轻量一点，只保证了前面的 load 不会重排到后面。</li></ol><p><a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a>书中给出了一张更细节的图，感兴趣的读者可以研究一下。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250607151428218.png"alt="Rust Atomics and Locks: An overview of the instructions that the various atomic operations compile down to on ARM64 and x86-64 for each memory ordering" /><figcaption aria-hidden="true">Rust Atomics and Locks: An overview ofthe instructions that the various atomic operations compile down to onARM64 and x86-64 for each memory ordering</figcaption></figure><h1 id="硬件原理">硬件原理</h1><p>最后我们尝试从硬件层面来进一步理解原子操作的底层实现。这块笔者并不专业，更多的是尝试通过ChatGPT 等 LLM 查阅资料，进行梳理总结。</p><p>原子操作的底层实现（如 x86 的 <code>lock</code> 前缀或 ARM 的<code>LL/SC</code>）依赖于硬件级别的协同机制，其核心是通过<strong>缓存一致性协议</strong>、<strong>总线仲裁</strong> 和<strong>指令集层面的特殊支持</strong>来保证多核环境下的原子性和内存顺序。</p><h2 id="x86-的-lock-前缀总线锁定与缓存一致性">x86 的 <code>lock</code>前缀：总线锁定与缓存一致性</h2><ol type="1"><li><p><strong>总线锁定（Bus Locking）</strong></p><p>当 CPU 执行 <code>lock cmpxchg</code> 时，<code>lock</code>前缀会向总线（或缓存一致性协议）发送信号，<strong>临时独占内存地址的访问权</strong>，阻止其他核心的干扰。</p><ol type="1"><li><strong>锁定范围</strong>：现代 CPU 通常锁定缓存行（通常 64字节），而非整个总线。</li><li><strong>硬件支持</strong>：通过处理器的<strong>原子操作单元</strong> 和 <strong>缓存控制器</strong>协同实现。</li></ol></li><li><p><strong>MESI 缓存一致性协议</strong></p><blockquote><p>缓存一致性协议（如MESI）会在硬件层面上确保所有核心对内存修改的观察一致：任何核心的修改会立即（或按协议约定）传播到其他核心的缓存。</p></blockquote><p><code>lock</code> 操作会强制目标缓存行进入<strong>Modified（独占修改）</strong>状态，并通知其他核心的缓存行失效（Invalid）。 如：</p><ol type="1"><li><p>核心 A 执行 <code>lock inc [x]</code>，缓存行 <code>x</code> 变为Modified。</p></li><li><p>核心 B 尝试读取 <code>x</code>，触发缓存一致性协议：</p><ul><li><p>核心 A 将修改后的值写回主存或核心 B 的缓存（取决于协议变种如MESIF/MOESI）。</p></li><li><p>核心 B 的缓存行 <code>x</code> 变为 <strong>Shared</strong> 或<strong>Exclusive</strong>。</p></li></ul></li></ol></li><li><p><strong>内存屏障的隐含保证</strong></p><p>即使代码使用 <code>Relaxed</code> 内存序，<code>lock</code>会隐式插入 <strong>StoreLoad</strong> 屏障，确保：</p><ol type="1"><li>该指令前的所有写操作对其他核心可见。</li><li>该指令后的读操作不会重排到指令前。</li></ol></li><li><p><strong>现代优化：缓存锁定（Cache Locking）</strong></p><p>新式 CPU（如 IntelSkylake+）优先在缓存层面实现原子性，仅当跨缓存行或未对齐时才降级为总线锁定，减少性能损耗。</p></li></ol><h2 id="arm-的-llscload-linkedstore-conditional轻量级独占标记">ARM 的LL/SC（Load-Linked/Store-Conditional）：轻量级独占标记</h2><ol type="1"><li><p><strong>独占访问标记（Exclusive Monitor）</strong></p><p><strong>硬件状态机</strong>：每个 CPU 核心维护一个<strong>独占访问标记</strong>，记录最近通过 <code>ldxr</code>加载的内存地址。</p><ul><li><p><strong>标记触发</strong>：<code>ldxr [x]</code> 会标记地址<code>x</code> 为当前核心的独占访问区域。</p></li><li><p><strong>标记清除条件</strong>：</p><ul><li><p>其他核心修改了 <code>x</code>的缓存行（通过缓存一致性协议）。</p></li><li><p>当前核心执行 <code>clrex</code> 或上下文切换。</p></li></ul></li></ul></li><li><p><strong>条件存储（**</strong><code>stxr</code>*<strong>*）的原子性校验</strong></p><p><strong>校验独占标记</strong>：<code>stxr</code>执行时，硬件会检查目标地址的独占标记是否仍属于当前核心：</p><ol type="1"><li><strong>若标记有效</strong>：存储成功，返回 0。</li><li><strong>若标记失效</strong>：存储失败，返回 1（需重试）。</li></ol></li><li><p><strong>与缓存一致性协议的交互</strong></p><p><strong>ARM 的 ACE 协议</strong>：LL/SC 依赖缓存一致性协议（如 CHI 或ACE）监听其他核心的修改：</p><ol type="1"><li>核心 A 执行 <code>ldxr [x]</code>，缓存行 <code>x</code> 进入<strong>Exclusive</strong> 状态。</li><li>若核心 B 写入 <code>x</code>，缓存行在核心 A 中变为<strong>Invalid</strong>，独占标记被清除。</li><li>核心 A 的后续 <code>stxr</code> 会因标记失效而失败。</li></ol></li><li><p><strong>内存顺序的灵活控制</strong></p><p>ARM 的内存序（如<code>Relaxed</code>/<code>SeqCst</code>）通过显式屏障指令实现：</p><ol type="1"><li><code>ldapr</code>（Load-Acquire）：确保后续操作不重排到加载前。</li><li><code>stlr</code>（Store-Release）：确保前序操作不重排到存储后。</li></ol></li></ol><h1 id="总结">总结</h1><p>本篇文章通过查看 <code>x86_64-unknown-linux-musl</code> 和<code>aarch64-unknown-linux-musl</code> 两大平台下的汇编代码，深入剖析了 Rust 原子操作的底层实现机制，揭示了同一行 Rust代码在不同平台上截然不同的机器级行为。</p><p>到目前为止，我们学习的都是无锁（non-blocking）操作，下篇，我们将继续学习<a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a>中的第八章《Operating SystemPrimitives》，为手写阻塞类组件（Mutex、RwLock、CondVar）做理论准备，咱们下篇见！</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">本篇文章沿着 “CPU → 汇编指令 → Rust 原子语义” 的链路，带你拆解 Atomic* 背后到底发生了什么。我们先用 x86-64 与 ARM64 的真实编译结果对比 Ordering 的生成代码，再结合缓存一致性协议与编译器重排规则，解释为什么同一行 Rust 代码在不同平台会呈现截然不同的机器级行为。读完后，你不必死记硬背五种内存顺序，也能判断何时选 Relaxed、何时必须上 SeqCst，并掌握一套“看 asm → 辨语义 → 做权衡”的分析方法，为写锁、并发容器或性能调优提供根底。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 底层原理" scheme="https://hedon.top/categories/rust/rust-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="rust 原理" scheme="https://hedon.top/tags/rust-%E5%8E%9F%E7%90%86/"/>
    
    <category term="并发原理" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="原子操作" scheme="https://hedon.top/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
    <category term="汇编" scheme="https://hedon.top/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨手写一个 Arc</title>
    <link href="https://hedon.top/2025/06/03/rust-action-arc/"/>
    <id>https://hedon.top/2025/06/03/rust-action-arc/</id>
    <published>2025-06-03T05:00:00.000Z</published>
    <updated>2025-06-12T17:07:08.511Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><ahref="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust实战丨手写一个 SpinLock</a></li><li><ahref="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust实战丨手写一个 Arc</a> 👈 本篇</li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust实战丨手写一个 RwLock</a></li></ul><hr /><p>继上篇 <ahref="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust实战丨手写一个 oneshot channel</a>，本篇我们继续参考 <ahref="https://marabos.nl/atomics/">Rust Atomics and Locks</a>一书，来实现一个 <code>Arc</code>。</p><p>在本章开始之前，我们假设你已经：</p><ol type="1"><li>熟悉并理解 Rust 的各种原子操作。</li><li>阅读过 <ahref="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊Rust 的 Atomic和内存顺序</a>，并理解内存顺序和内存屏障的原理和使用方法。</li><li>理解 Rust <code>UnsafeCell&lt;T&gt;</code>提供的内部可变性允许我们在持有共享引用 <code>&amp;</code>的时候可以对数据进行修改。</li></ol><h2 id="arc-简介">Arc 简介</h2><p><code>Arc</code>（<em>Atomic Reference Counted</em>）是 Rust标准库里位于 <code>std::sync</code> 模块中的智能指针，用于<strong>在多个线程之间安全地共享只读数据</strong>。和只适用于单线程场景的<code>Rc&lt;T&gt;</code> 不同，<code>Arc&lt;T&gt;</code>的引用计数增减操作使用原子指令，从而保证跨线程的内存安全。</p><p><strong>为什么需要 Arc？</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Person &#123; age: <span class="number">18</span>, name: <span class="string">&quot;hedon&quot;</span>.<span class="title function_ invoke__">to_string</span>(), address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>() &#125;;</span><br><span class="line"></span><br><span class="line">thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">spawn</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;p)); <span class="comment">// ✅ scope 内的线程可以借用</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;p)); <span class="comment">// ❌ 需要 &#x27;static 生命周期</span></span><br></pre></td></tr></table></figure><p><strong>问题</strong>：<code>thread::spawn</code> 要求<code>'static</code> 生命周期，但 <code>&amp;p</code>只是栈上变量的借用。<br /><strong>解决</strong>：使用 <code>Arc::new(p)</code>把数据移到堆上，通过原子引用计数实现多所有权：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Arc::<span class="title function_ invoke__">new</span>(Person &#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p_clone</span> = p.<span class="title function_ invoke__">clone</span>(); <span class="comment">// 原子计数 +1</span></span><br><span class="line">thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p_clone)); <span class="comment">// ✅ 编译通过</span></span><br></pre></td></tr></table></figure><h2 id="读完本篇你能学到什么">读完本篇你能学到什么</h2><ul><li><strong>原子操作的内存顺序选择</strong>：通过引用计数这个具体例子，理解<code>Relaxed / Acquire / Release / fence</code> 的使用场景。</li><li><strong>弱引用解决循环引用</strong>：<code>Weak&lt;T&gt;</code>的设计原理和在图结构中的应用。</li><li><strong>Arc::get_mut的安全性保证</strong>：理解「非原子两步校验」的巧妙设计。</li><li><strong>零成本抽象的实现细节</strong>：<code>UnsafeCell</code> +<code>ManuallyDrop</code> 相比 <code>Option&lt;T&gt;</code>的优势。</li></ul><h2 id="v0-基础引用计数">v0: 基础引用计数</h2><h3 id="数据结构">数据结构</h3><p>我们先来分析一下基本的数据结构该如何定义，在之前的 <ahref="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust实战丨手写一个 SpinLock</a>，我们讲到了 C++/Rust 常用的并发编程方式RAII（Resource Acquisition IsInitialization，资源获取即初始化），其核心思想是：<strong>在对象构造函数中获取资源，在析构函数中释放资源</strong>。上面的案例中，我们在初始化<code>Person</code> 的时候其实也是应用了这种思路。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Arc::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    name: <span class="string">&quot;hedon&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以我们的自定义 <code>Arc</code> 需要泛型<code>T</code>，使其可以承载不同的数据类型的数据<code>data</code>，同时为了做引用计数，它需要一个数值类型<code>ref_count</code> 来计数，为了并发安全，我们可以选择原子类型<code>AtomicUsize</code>。</p><p>在 <code>Arc</code> 中，我们需要自己管理 <code>data</code>的生命周期，除了使用裸指针 <code>*mut T</code> 或 <code>*const T</code>之外，我们可以使用 <code>std::ptr::NonNull&lt;T&gt;</code>，它是一个零成本、保证非空、支持协变（可安全向子类型转换）的裸指针包装器，具体可参考<strong>附录1. NonNull&lt;T&gt;</strong>。</p><p>综上，我们可以定义以下数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    ref_count: AtomicUsize,</span><br><span class="line">    data: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Arc &#123;</span><br><span class="line">            ptr: NonNull::<span class="title function_ invoke__">from</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(ArcData &#123;</span><br><span class="line">                ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                data,</span><br><span class="line">            &#125;))),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>我们定义了 <code>ArcData</code> 和 <code>Arc</code> 两个结构，其中<code>ArcData</code> 包含引用计数 <code>ref_count</code> 和实际数据<code>data</code>。</li><li>在 <code>Arc</code> 中，我们使用 <code>NonNull</code> 来管理<code>ArcData</code> 的生命周期。初始化时，先用 <code>Box::new()</code>在堆上分配内存，再通过 <code>Box::leak()</code> 放弃<code>Box&lt;T&gt;</code> 的所有权，交由 <code>Arc</code>自行管理。</li></ol><pre class="mermaid">graph TB    subgraph Stack ["栈内存 Stack"]        ArcStruct["Arc&lt;T&gt;<br/>ptr: NonNull&lt;ArcData&lt;T&gt;&gt;"]    end    subgraph Heap ["堆内存 Heap"]        ArcDataStruct["ArcData&lt;T&gt;<br/>ref_count: AtomicUsize(1)<br/>data: T"]    end    ArcStruct -->|指向| ArcDataStruct    subgraph Process ["内存分配过程"]        Step1["Box::new(ArcData)"]        Step2["Box::leak()"]        Step3["NonNull::from()"]        Step1 --> Step2        Step2 --> Step3    end    classDef stackStyle fill:#e1f5fe,stroke:#01579b,stroke-width:2px    classDef heapStyle fill:#f3e5f5,stroke:#4a148c,stroke-width:2px    classDef processStyle fill:#fff3e0,stroke:#e65100,stroke-width:2px    class ArcStruct stackStyle    class ArcDataStruct heapStyle    class Step1,Step2,Step3 processStyle</pre><p>另外，跨线程发送 <code>Arc&lt;T&gt;</code> 会导致 <code>T</code>对象被共享，即 <code>T</code> 需要满足 <code>Sync</code>trait，而跨线程发送 <code>Arc&lt;T&gt;</code>也会导致需要由另外一个线程来释放 <code>T</code>，所以需要 <code>T</code>满足 <code>Send</code> trait。所以只有当 <code>T</code> 满足<code>Send+Sync</code> 的时候，<code>Arc&lt;T&gt;</code> 才是<code>Send</code> 的，对于 <code>Sync</code> 也是同理，因为我们可以为<code>Arc&lt;T&gt;</code> 分别实现 <code>Sync</code> 和<code>Send</code> trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>为了能够便捷的获取 <code>data</code>，我们先为<code>Arc&lt;T&gt;</code> 实现一个 <code>data()</code> 用于获取<code>ArcData&lt;T&gt;</code>，同时为其实现 <code>Deref</code>trait，用于像指针一样无感操作 <code>data: T</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ref</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="维护引用计数">维护引用计数</h3><p>基础部分我们已经铺垫完了，现在我们需要来实现 2 个最重要的 trait了：</p><ul><li><strong>Clone</strong>: <code>Arc</code> 引用计数的关键，在每次<code>clone()</code> 的时候，我们不拷贝 <code>data</code>，而是让<code>ref_count</code> 自增，进行引用计数。</li><li><strong>Drop</strong>: 在 <code>Arc&lt;T&gt;</code>实例离开作用域的时候，我们需要让 <code>ref_count</code>自减，同时在最后一个 <code>Arc&lt;T&gt;</code>被销毁时，我们需要主动释放 <code>ArcData&lt;T&gt;</code>的内存资源。</li></ul><p>我们先来实现 <code>Clone</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 处理整型溢出的情况</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed)</span><br><span class="line">        Arc &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里没有其他原子操作需要跟当前操作建立严格的<code>happens-before</code> 关系，所以这里我们可以使用最松的<code>Relaxed</code> 内存顺序。</p><p>接下来看下 <code>Drop</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> &lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, ???) == <span class="number">1</span> &#123; <span class="comment">// &lt;----- 这里需要什么使用内存顺序约束？</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>Drop</code>，我们就需要好好想一想需要什么内存顺序约束了。在最后一个<code>drop</code> 的时候，我们有 2 个目标：</p><ol type="1"><li><strong>不能过早释放</strong>：确保在引用计数减到 0并销毁对象之前，没有别的线程仍在使用这份数据；</li><li><strong>要看得见别人写的东西</strong>：如果别的线程在它们各自的<code>drop</code>里面对共享对象做了写入，最后一个线程做析构时必须"看到"这些写入，否则就可能出现数据竞争或次序错误。</li></ol><p>换言之，我们需要最后一个 <code>fetch_sub</code> 跟前面其他每一个<code>fetch_sub</code> 都建立起 happens before 关系，也即我们需要一对Release 和 Acquire 来保证 happens-before。</p><p>这里简单回顾一下 <code>Release</code> 和<code>Acquire</code>，不熟悉的读者可以参阅：<ahref="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊Rust 的 Atomic 和内存顺序</a>。</p><ul><li><code>Release</code>:作用于写操作（store），确保该操作之前的所有内存访问不会被重排到这个Release 操作之后。</li><li><code>Acquire</code>:作用于读操作（load），确保该操作之后的所有内存访问不会被重排到这个Acquire 操作之前。</li><li>当一个线程通过 <code>Acquire</code> 读取到另一个线程通过<code>Release</code> 写入的值时，会建立一个 happens-before关系：<strong>线程 A 中 Release 写入之前的所有内存写操作，对于线程 B 中Acquire 读取之后的所有内存读操作都是可见的</strong>。</li></ul><blockquote><p><strong>Release-Sequence概念补充</strong>：当多个线程对同一个原子变量执行 Release操作时，这些操作会形成一个 "release-sequence"。后续任何一个 Acquire操作读取到这个序列中的任意值，都能与整个序列建立 happens-before关系。这正是为什么我们的 <code>fence(Acquire)</code>能够与之前<strong>所有线程</strong>的 <code>fetch_sub(Release)</code>形成同步的关键。</p></blockquote><p>我们当然可以使用 <code>Release</code> 和 <code>Acquire</code>的结合体 <code>AcqRel</code>来一步到位解决这个问题。不过考虑到只有最后一个 <code>drop</code>需要满足这个关系，我们可以尝试做得更优雅一些。</p><p><strong>在这种仅需在临界值保证 happens-before的场景下，我们都可以单独在临界情况下使用一个 <code>fence</code> 来建立起happens-before。</strong></p><p>具体来说：</p><ul><li><strong>对于非最终 <code>drop</code></strong>：我们只需要使用<code>Release</code>，即<code>fetch_sub(1, Ordering::Release)</code>，它保证了别的线程如果最终做"最后一次drop"，只要它对相同原子执行一条 <em>Acquire</em>操作，它就能同步到前面所有线程对数据做过的改动。</li><li><strong>对于最终 <code>drop</code></strong>：在调用<code>fetch_sub</code> 的时候我们仍需要 <code>Release</code>语义，但是调用时，我们并不知道自己是不是"最后那个线程"。当<code>fetch_sub</code> 返回 <code>1</code>的时候，说明我们是"最后那个线程"。这个时候，我们需要建立一个<code>fetch(Acquire)</code>，与之前的所有 <code>Release</code>形成配对，确保看到<strong>之前所有的历史写入</strong>，这个时候我们才能确定已经没有别的线程在使用数据了，我们才可以安全地销毁对象。</li></ul><p>如下图所示；</p><pre class="mermaid">sequenceDiagram    participant A as Thread A    participant B as Thread B    participant C as Thread C<br/>(最后 drop)    %% 普通写入    A->>A: write shared data …    B->>B: write shared data …    %% 非最终 drop：Release 写    A->>A: fetch_sub (Release)  ⬅ 计数 n→n-1    B->>B: fetch_sub (Release)  ⬅ 计数 n-1→n-2    %% 形成 release-sequence    Note over A,B: 这两次 Release 写组成<br/>同一条 release-sequence    %% 最终 drop：Release 写 & 返回 1    C->>C: fetch_sub (Release)  ⬅ 返回 1 → 计数 0    %% Acquire fence 同步    C-->>C: fence (Acquire)<br/>【接收 release-sequence】    %% 安全析构    C->>C: drop(Box::from_raw)    %% 结果说明    Note over C: fence (Acquire) 使 A/B<br/>对共享数据的写必定<br/>在析构前可见</pre><p>经过这么一顿分析后，我们最终的 <code>Drop</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// ❶ 所有 `drop` 都执行：Release</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// ❷ 只有最后一个引用才会进来</span></span><br><span class="line">            std::sync::atomic::<span class="title function_ invoke__">fence</span>(Ordering::Acquire); <span class="comment">// ❸ 补上 Acquire</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="comment">// ❹ 现在可以安全地回收并析构</span></span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现逻辑：</p><ol type="1"><li><strong>所有 drop</strong> 都用 <code>Release</code>语义减引用计数，为可能的"最后一次 drop"做准备</li><li><strong>只有最后一次 drop</strong>（返回值为 1）才需要额外的<code>fence(Acquire)</code> 与之前所有的 Release 建立happens-before</li><li><strong>安全析构</strong>：现在可以确保看到所有历史写入，没人再持有引用</li></ol><h3 id="完整代码">完整代码</h3><p>自此，我们第一个版本的 <code>Arc</code>就实现完毕了，我们来看一下最终完成的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering, fence&#125;;</span><br><span class="line"><span class="keyword">use</span> std::ptr::NonNull;</span><br><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    ref_count: AtomicUsize,</span><br><span class="line">    data: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Arc &#123;</span><br><span class="line">            ptr: NonNull::<span class="title function_ invoke__">from</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(ArcData &#123;</span><br><span class="line">                ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                data,</span><br><span class="line">            &#125;))),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ref</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        Arc &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试">单元测试</h3><p>写个单元测试验证一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">arc_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> NUM_DROPS: AtomicUsize = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DetectDrop</span>;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">DetectDrop</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">            NUM_DROPS.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 2 个 Arc 共享一个元组，包含一个字符串和 DetectDrop 对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Arc::<span class="title function_ invoke__">new</span>((<span class="string">&quot;hedon&quot;</span>, DetectDrop));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 x 转移到另外一个线程并使用它</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(x.<span class="number">0</span>, <span class="string">&quot;hedon&quot;</span>); <span class="comment">// 可以正常使用</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里，y 应该也是可以正常使用的</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(y.<span class="number">0</span>, <span class="string">&quot;hedon&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 t 线程执行完毕</span></span><br><span class="line">    t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个时候 `x` 已经被释放了，但是`y` 还没有被释放，</span></span><br><span class="line">    <span class="comment">// 所以 `DetectDrop` 应该还没被释放。</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(NUM_DROPS.<span class="title function_ invoke__">load</span>(Ordering::Relaxed), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动释放掉 `y`，这是最后一个 `Arc`，所以 `DetectDrop` 应该会被释放</span></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(y);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(NUM_DROPS.<span class="title function_ invoke__">load</span>(Ordering::Relaxed), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果是 ok 的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">running 1 test</span><br><span class="line">test arc::tests::arc_should_work ... ok</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line">    arc::tests::arc_should_work</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure><h2 id="v1-实现-get_mut-获取可变引用">v1: 实现 get_mut 获取可变引用</h2><p>按照前面版本的实现，我们是不能为 <code>Arc&lt;T&gt;</code> 实现<code>DerefMut</code> trait 的，因为我们不能无条件地提供<code>&amp;mut T</code> 可变引用，因为它可能同时被其他的<code>Arc&lt;T&gt;</code> 所访问中。</p><p>不过，当满足一定条件的时候，我们还是可以提供 <code>&amp;mut T</code>可变引用的。具体来说，需要满足 2 个条件：</p><ol type="1"><li>使用 <code>&amp;mut Arc&lt;T&gt;</code> 保证当前<code>Arc&lt;T&gt;</code> 只有一个地方在使用；</li><li>需要确保全局只有一个 <code>Arc&lt;T&gt;</code>。</li></ol><p>为了避免跟 <code>DerefMut</code>混淆，我们将其声明为一个静态方法，并将 <code>Arc&lt;T&gt;</code>作为参数，同时因为只有满足特定条件的情况下，才能返回<code>&amp;mut T</code>，所以我们使用 <code>Option</code>作为返回值。如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(arc: &amp;<span class="keyword">mut</span> Arc&lt;T&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> arc.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">        <span class="comment">// Safety: 没有其他地方可以访问数据，</span></span><br><span class="line">        <span class="comment">// 因为我们使用了 &amp;mut 独占引用，而且此时只有一个 `Arc`。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> arc.ptr.<span class="title function_ invoke__">as_mut</span>().data) &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li><p>这里我们在确定只有一个 <code>Arc</code> 实例的时候，使用<code>fetch(Acquire)</code> 来跟所有其他 <code>Arc</code> 执行<code>drop()</code> 的 <code>fetch_sub(Release)</code> 建立happens-before 关系。</p></li><li><p>因为此时 <code>ref_count=1</code>，说明仅有当前 <code>Arc</code>这一个实例，而 <code>get_mut</code> 需要的又是独占引用，所以当前<code>Arc</code> 不可能再被拿去做 <code>clone()</code>操作，所以在这个情况下，是可以保证有且仅有一个 <code>Arc</code>实例，所以我们是可以安全返回 <code>&amp;mut T</code> 的。</p></li><li><p>返回的 <code>&amp;mut T</code> 会隐式地借用参数<code>&amp;mut Arc&lt;T&gt;</code> 的生命周期，而 Rust不允许可变引用和只读引用交叉存在，所以当前仅剩的这个<code>Arc</code>，直到 <code>&amp;mut T</code>作用域结束之前，都是不可用的，所以在那之前，不会再被拿去执行<code>clone()</code> 和 <code>Deref</code> 等操作，所以是安全的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_mut_should_be_safe</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = Arc::<span class="title function_ invoke__">get_mut</span>(&amp;<span class="keyword">mut</span> x).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">clone</span>(); <span class="comment">// &lt;---- cannot borrow `x` as immutable</span></span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面这个例子，就会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable</span><br><span class="line"><span class="meta prompt_">   --&gt; </span><span class="language-bash">src/arc.rs:117:17</span></span><br><span class="line">    |</span><br><span class="line">114 |         let v = Arc::get_mut(&amp;mut x).unwrap();</span><br><span class="line">    |                              ------ mutable borrow occurs here</span><br><span class="line">...</span><br><span class="line">117 |         let y = x.clone();</span><br><span class="line">    |                 ^ immutable borrow occurs here</span><br><span class="line">118 |         v.push(2);</span><br><span class="line">    |         - mutable borrow later used here</span><br></pre></td></tr></table></figure></li></ol><h2 id="v2-弱指针-weakt-解决循环引用">v2: 弱指针 Weak&lt;T&gt;解决循环引用</h2><h3 id="循环引用问题分析">循环引用问题分析</h3><pre class="mermaid">graph TD    A --> B;    A --> C;</pre><p>引用计数在各种数据结构的表示中非常有用，如上图所示的树形结构，当释放A 的时候，因为 B 和 C 不再被引用，所以也可以顺带释放了。</p><p>但是，如果 B 和 C 也持有对 A的引用，即形成了循环引用，那按照我们之前的实现，A、B、C都将永远不会被释放了，因为它们的引用计数永不为0，哪怕它们三者均不再被使用。如下图所示：</p><pre class="mermaid">graph TD    A <--> B;    A <--> C;    B -.-> A;    C -.-> A;</pre><p>为了应对这种场景，Rust的标准库中提出的解决方案是：<strong><code>Weak&lt;T&gt;</code>，也称弱指针</strong>。<strong><code>T</code>可以在 <code>Arc&lt;T&gt;</code> 和 <code>Weak&lt;T&gt;</code>之间共享，当所有的 <code>Arc&lt;T&gt;</code>都失效的时候，<code>T</code> 被释放，无论此时是否有<code>Weak&lt;T&gt;</code> 的存在。</strong></p><p>如下图所示，父节点对子节点使用的是强引用，确保了父节点存活的时候，子节点都存在。而子节点对父节点使用的是弱引用，只即保留了子节点回溯父节点的能力，也不会阻止父节点的释放。</p><p>当父节点被释放时，所有强引用计数归零，节点可以依次被释放。</p><pre class="mermaid">graph TD    A -- Arc --> B;    A -- Arc --> C;    B -.->|Weak| A;    C -.->|Weak| A;</pre><h3 id="数据结构-1">数据结构</h3><p>OK，做了这么多铺垫后，我们来思考一下现在的 <code>ArcData</code>该如何调整。</p><ol type="1"><li>之前我们用 <code>ref_count</code>做引用计数，它代表的都是强引用，现在我们需要记录弱引用数量的相关字段。</li><li>当只有弱引用的时候，<code>data</code> 就已经被释放了，我们需要使用<code>None</code> 来表示这种情况，所以 <code>data</code> 应该是一个<code>Option&lt;T&gt;</code> 类型。</li><li>当 <code>ArcData&lt;T&gt;</code> 被一个 <code>Arc</code> 和多个<code>Weak</code> 共享时，释放最后一个 <code>Arc</code> 时，我们仅拥有<code>&amp;ArcData&lt;T&gt;</code> 不可变引用，这个时候我们需要将其从<code>Some(T)</code> 置为<code>None</code>，即要在不可变引用上实现修改，这就涉及到了前几篇提到的：<strong>内部可变性</strong>。<strong>UnsafeCell</strong>是 Rust提供的一个内部可变性工具类型，它包装一个数据，使得即使在只有不可变引用的情况下也可以进行修改（当然需要在<code>unsafe</code> 块中操作）。所以我们需要将 <code>data</code> 再用<code>UnsafeCell</code> 包一层，以满足此场景的需求。</li></ol><p>综上，最新的 <code>ArcData</code> 定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// `Arc` 的数量，也即数据 T 的强引用计数。</span></span><br><span class="line">    data_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// `Arc` + `Weak` 的数量。</span></span><br><span class="line">    alloc_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// 数据，当只有 `Weak` 的时候，为 None。</span></span><br><span class="line">    data: UnsafeCell&lt;<span class="type">Option</span>&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要定义一个新结构 <code>Weak&lt;T&gt;</code>，用来表示弱引用，假定这个时候，我们将维护 <code>ArcData</code>存活的职责交给 <code>Weak&lt;T&gt;</code>，那就可以将<code>ArcData</code> 转给 <code>Weak&lt;T&gt;</code> 持有，然后在<code>Arc&lt;T&gt;</code> 中持有一个 <code>Weak&lt;T&gt;</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// `Arc` 的数量，也即数据 T 的强引用计数。</span></span><br><span class="line">    data_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// `Arc` + `Weak` 的数量。</span></span><br><span class="line">    alloc_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// 数据，当只有 `Weak` 的时候，为 None。</span></span><br><span class="line">    data: UnsafeCell&lt;<span class="type">Option</span>&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    weak: Weak&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Arc &#123;</span><br><span class="line">            weak: Weak &#123;</span><br><span class="line">                ptr: NonNull::<span class="title function_ invoke__">from</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(ArcData &#123;</span><br><span class="line">                    alloc_ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                    data_ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                    data: UnsafeCell::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Some</span>(data)),</span><br><span class="line">                &#125;))),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Weak&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ref</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ptr</span> = <span class="keyword">self</span>.weak.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>();</span><br><span class="line">        <span class="comment">// Safety: 这个时候还有 Arc 存在，所以 data 肯定是生效的。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*ptr).<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，除了数据结构之外，我们做了 3 点调整：</p><ol type="1"><li>只需要为 <code>Weak&lt;T&gt;</code> 实现 <code>Sync</code> 和<code>Send</code> trait，这个时候 <code>Arc&lt;T&gt;</code>就会被自动实现这 2 个 triat。</li><li><code>data(&amp;self)</code> 辅助函数，移到了<code>Weak&lt;T&gt;</code> 身上。</li><li><code>Arc&lt;T&gt;</code> 要从 <code>Deref</code> 获取<code>&amp;T</code>，需要先经过一道 <code>Weak&lt;T&gt;</code>。</li></ol><pre class="mermaid">graph LR    subgraph Stack ["栈内存 Stack"]        ArcStruct["Arc&lt;T&gt;<br/>weak: Weak&lt;T&gt;"]        WeakStruct["Weak&lt;T&gt;<br/>ptr: NonNull&lt;ArcData&lt;T&gt;&gt;"]    end    subgraph Heap ["堆内存 Heap"]        ArcDataStruct["ArcData&lt;T&gt;<br/>data_ref_count: AtomicUsize(1)<br/>alloc_ref_count: AtomicUsize(1)<br/>data: UnsafeCell&lt;Option&lt;T&gt;&gt;"]    end    ArcStruct -->|包含| WeakStruct    WeakStruct -->|指向| ArcDataStruct    classDef stackStyle fill:#e1f5fe,stroke:#01579b,stroke-width:2px    classDef heapStyle fill:#f3e5f5,stroke:#4a148c,stroke-width:2px    classDef processStyle fill:#fff3e0,stroke:#e65100,stroke-width:2px    classDef refStyle fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px    class ArcStruct,WeakStruct stackStyle    class ArcDataStruct heapStyle    class Step1,Step2,Step3,Step4,Step5 processStyle    class DataRef,AllocRef,DataContent refStyle</pre><h3 id="维护引用计数-1">维护引用计数</h3><p>现在重点来了，我们需要来思考 <code>Weak&lt;T&gt;</code> 和<code>Arc&lt;T&gt;</code> 的 <code>Clone</code> 和 <code>Drop</code>该如何实现。其实重点就是该<strong>如何管理 <code>alloc_ref_count</code>和 <code>data_ref_count</code> 的计数</strong>。</p><p>再次明确下我们的定义：</p><ul><li><code>data_ref_count</code>: 代表的是强引用<code>Arc&lt;T&gt;</code> 的数量。</li><li><code>alloc_ref_count</code>: 代表的是 <code>Arc&lt;T&gt;</code> +<code>Weak&lt;T&gt;</code> 的数量。</li></ul><p>因此：</p><ul><li>Clone:<ul><li>当 <code>Weak&lt;T&gt;</code>拷贝时，仅增加了弱引用的数量，所以我们只需对<code>alloc_ref_count</code> 进行自增。</li><li>当 <code>Arc&lt;T&gt;</code> 拷贝时，不仅需要拷贝内部的<code>Weak&lt;T&gt;</code>，还增加了强引用的数量，所以我们还需要对<code>data_ref_count</code> 进行自增。</li></ul></li><li>Drop:<ul><li>当 <code>Arc&lt;T&gt;</code> 被释放时，不仅释放了其内部的<code>Weak&lt;T&gt;</code>，还减少了一个强引用，所以需要对<code>data_ref_count</code> 进行自减。另外，如果是最后一个<code>Arc&lt;T&gt;</code> 被释放，我们需要将<code>ArcData&lt;T&gt;.data</code> 置为 <code>None</code>。</li><li>当 <code>Weak&lt;T&gt;</code>被释放时，我们仅需减少弱引用的数量，即对 <code>alloc_ref_count</code>进行自减。另外，当最后一个 <code>Weak&lt;T&gt;</code>被释放时（此时肯定也没有 <code>Arc&lt;T&gt;</code>了），我们还需要负责释放 <code>ArcData&lt;T&gt;</code> 。</li></ul></li></ul><p>综上，我们的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed) &gt; <span class="type">usize</span>::MAX / <span class="number">2</span> &#123;</span><br><span class="line">            std::process::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">weak</span> = <span class="keyword">self</span>.weak.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">if</span> weak.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed) &gt; <span class="type">usize</span>::MAX / <span class="number">2</span> &#123;</span><br><span class="line">            std::process::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Arc &#123; weak &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="comment">// Safety: 最后一个 Weak&lt;T&gt; 已经被释放了。</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span></span><br><span class="line">            .weak</span><br><span class="line">            .<span class="title function_ invoke__">data</span>()</span><br><span class="line">            .data_ref_count</span><br><span class="line">            .<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release)</span><br><span class="line">            == <span class="number">1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">ptr</span> = <span class="keyword">self</span>.weak.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>();</span><br><span class="line">            <span class="comment">// Safety: data_ref_count 已经为 0 了，没有地方在使用 data 了。</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123; (*ptr) = <span class="literal">None</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里考虑到实际场景中的内存限制，我们对引用计数进行了简单的限制，当其超过<code>usize::Max/2</code> 的时候，就执行<code>std::process:abort()</code> 让整个进程崩溃。</p></blockquote><h3 id="get_mut">get_mut()</h3><p>接下来我们来考虑下 <code>get_mut(arc: &amp;mut Arc&lt;T&gt;)</code>该如何修改。什么时候可以返回<code>&amp;mut T</code>，很明显，<strong>当且仅当只有一个<code>Arc&lt;T&gt;</code> 的时候才可以</strong>。</p><p>故 <code>get_mut</code> 的实现修改如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(arc: &amp;<span class="keyword">mut</span> Arc&lt;T&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> arc.weak.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">        <span class="comment">// Safety: 这个时候没有其他地方能使用数据，因为只有一个 `Arc`，</span></span><br><span class="line">        <span class="comment">// 同时我们拥有仅存的这个 `Arc` 的不可变引用。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">arcdata</span> = <span class="keyword">unsafe</span> &#123; arc.weak.ptr.<span class="title function_ invoke__">as_mut</span>() &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">option</span> = arcdata.data.<span class="title function_ invoke__">get_mut</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = option.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们执行之前的 <code>arc_should_work</code>测试用例，可以发现是顺利通过的。</p><h3 id="dowgrade">dowgrade()</h3><p>回顾下面这张图，为了提供 A 的 <code>Weak&lt;T&gt;</code>指针，我们需要给 <code>Arc&lt;T&gt;</code> 提供一个<code>downgrade()</code>方法，用于将强引用降为弱引用，这是必然可以成功的。同时，当我们也可以为<code>Weak&lt;T&gt;</code> 提供一个 <code>upgrade()</code>方法，用于持有弱引用的情况下可以尝试访问数据，当然这未必能成功。</p><pre class="mermaid">graph TD    A -- Arc --> B;    A -- Arc --> C;    B -.->|Weak| A;    C -.->|Weak| A;</pre><p><code>downgrade()</code> 比较简单，我们直接 <code>clone()</code> 一个<code>Weak&lt;T&gt;</code> 就可以了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">downgrade</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Weak&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.weak.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="upgrade">upgrade()</h3><p><code>upgrade()</code> 就比较复杂了，只有当存在 <code>Arc</code>的时候，<code>data</code> 才没被释放，这个时候，才能返回升级后的<code>Arc&lt;T&gt;</code>，即要求 <code>data_ref_count&gt;0</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Weak&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">upgrade</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;T&gt;&gt; &#123;</span><br><span class="line">      <span class="comment">// 获取 data_ref_count 的值</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">          <span class="comment">// 如果等于 0，则说明 data 已经被释放了，直接返回 None</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert!</span>(n &lt; <span class="type">usize</span>::MAX);</span><br><span class="line">          <span class="comment">// 不为 0 的话，data_ref_count 尝试进行 +1，失败了就重试</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">compare_exchange_weak</span>(</span><br><span class="line">                n,</span><br><span class="line">                n + <span class="number">1</span>,</span><br><span class="line">                Ordering::Relaxed,</span><br><span class="line">                Ordering::Relaxed,</span><br><span class="line">            ) &#123;</span><br><span class="line">                n = e;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 成功了，则 clone weak 即可（执行 alloc_ref_count++）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(Arc &#123; weak: <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>() &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来写一下测试用例，验证使用了 <code>Weak&lt;T&gt;</code>后，我们的资源能否正确释放。在这之前，我们先写一个非<code>Weak&lt;T&gt;</code> 版本的，看看资源是否真的没有被释放：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">no_weak_should_not_free_resource</span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> NUM_DROPS: AtomicUsize = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="comment">// 使用 RefCell，利用其内部可变性，方便我们建立父子关系</span></span><br><span class="line">        child: RefCell&lt;<span class="type">Vec</span>&lt;Arc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">        parent: RefCell&lt;<span class="type">Option</span>&lt;Arc&lt;Node&gt;&gt;&gt;, <span class="comment">// &lt;---- 这里持有的是强引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">            NUM_DROPS.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span> &#123;</span><br><span class="line">                child: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">                parent: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 建立父子关系</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_child</span>(parent: &amp;Arc&lt;Node&gt;, child: Arc&lt;Node&gt;) &#123;</span><br><span class="line">            *child.parent.<span class="title function_ invoke__">borrow_mut</span>() = <span class="title function_ invoke__">Some</span>(parent.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">            parent.child.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 限定作用域，离开作用域后，root/child1/child2 正常情况应该被释放。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">root</span> = Arc::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">new</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">child1</span> = Arc::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">new</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">child2</span> = Arc::<span class="title function_ invoke__">new</span>(Node::<span class="title function_ invoke__">new</span>());</span><br><span class="line"></span><br><span class="line">        Node::<span class="title function_ invoke__">add_child</span>(&amp;root, child1);</span><br><span class="line">        Node::<span class="title function_ invoke__">add_child</span>(&amp;root, child2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_ne!</span>(NUM_DROPS.<span class="title function_ invoke__">load</span>(Ordering::Relaxed), <span class="number">3</span>); <span class="comment">// 不为 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述用例后，我们可以发现 <code>NUM_DROPS</code> 还是 0，即<code>root/child1/child2</code> 均没有被释放资源。</p><p>你可以将 <code>parent</code>的引用修改为弱引用，然后再重新执行测试用例，就会发现<code>root/child1/child2</code> 的资源都被正确释放了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    child: RefCell&lt;<span class="type">Vec</span>&lt;Arc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">    parent: RefCell&lt;<span class="type">Option</span>&lt;Weak&lt;Node&gt;&gt;&gt;, <span class="comment">// &lt;---- 这里持有的是弱引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            child: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">            parent: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立父子关系</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_child</span>(parent: &amp;Arc&lt;Node&gt;, child: Arc&lt;Node&gt;) &#123;</span><br><span class="line">        *child.parent.<span class="title function_ invoke__">borrow_mut</span>() = <span class="title function_ invoke__">Some</span>(parent.<span class="title function_ invoke__">downgrade</span>()); <span class="comment">// &lt;---- 使用 downgrade 转为弱引用</span></span><br><span class="line">        parent.child.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="v3-分离强弱引用避免无用消耗">v3: 分离强弱引用，避免无用消耗</h2><p>上个版本我们通过引入了弱引用<code>Weak&lt;T&gt;</code>，成功解决了循环引用的问题，这是个非常大的进步！</p><p>不过我们仍然有进一步优化的空间，可以观察到，<code>Arc&lt;T&gt;</code>的每次拷贝，都会伴随一次拷贝<code>Weak&lt;T&gt;</code>，但是，很多时候，我们其实没有循环引用关系的，也即我们并不是每一次都需要<code>Weak&lt;T&gt;</code>，所以上个版本的实现，其实是有很多的浪费的。</p><h3 id="数据结构-2">数据结构</h3><p>所以我们可以考虑将 <code>Weak&lt;T&gt;</code> 从<code>Arc&lt;T&gt;</code> 中分离出来：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 调整 Arc 的构造函数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Arc &#123;</span><br><span class="line">            ptr: NonNull::<span class="title function_ invoke__">from</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(ArcData &#123;</span><br><span class="line">                data_ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                alloc_ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                data: UnsafeCell::<span class="title function_ invoke__">new</span>(ManuallyDrop::<span class="title function_ invoke__">new</span>(data)),</span><br><span class="line">            &#125;))),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Arc 已经没有 Weak 了，这个时候，时候给它补一个 data() 辅助函数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ref</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相应地调整 Deref</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*<span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们需要对 <code>ArcData&lt;T&gt;</code>结构中的引用技术进行重新定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// `Arc` 的数量</span></span><br><span class="line">    data_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// `Weak` 的数量，当存在 `Arc` 时，额外加 1</span></span><br><span class="line">    alloc_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// 数据，当只有 `Weak` 的时候，释放它。</span></span><br><span class="line">    data: UnsafeCell&lt;ManuallyDrop&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们总共做了 3 个重要的调整：</p><ol type="1"><li><p><code>Arc&lt;T&gt;</code> 不再包含<code>Weak&lt;T&gt;</code>，而是各自独立，不过它们之前会共享底层的<code>ArcData&lt;T&gt;</code>。</p></li><li><p><code>alloc_ref_count</code> 的语义，从<strong>"Arc + Weak的数量</strong>"，变成"<strong>Weak 的数量，当存在 Arc 时，额外加1</strong>"。</p><blockquote><p>换言之，对于所有的 <code>Arc&lt;T&gt;</code>，都共有一个隐式的<code>Weak&lt;T&gt;</code> ，当释放最后一个 <code>Arc&lt;T&gt;</code>的时候，这个隐式的 <code>Weak&lt;T&gt;</code> 也需要被释放（本质是执行alloc_ref_count 减一，同时如果没有其他的<code>Weak&lt;T&gt;</code>，需要顺带释放<code>ArcData&lt;T&gt;</code>。</p></blockquote></li><li><p><code>data</code> 字段，我们使用 <code>ManuallyDrop</code> 来替代<code>Option</code>，我们之前使用 <code>None</code>来表示数据已经被释放，但其实 <code>data_ref_count</code>已经能表达这层意思了，所以我们这里使用 <code>ManuallyDrop</code>来进一步节省内存资源。</p></li></ol><blockquote><p><code>std::mem::ManuallyDrop&lt;T&gt;</code>是一个零成本（zero-cost）包装器。它不改变 <code>T</code>的布局，也不会产生额外的字节，在一些情况下，可以比<code>Option&lt;T&gt;</code>少一些标记位和字节对齐所占据的额外空间。具体可参考：<strong>附录 2.ManuallyDrop&lt;T&gt;</strong>。</p></blockquote><pre class="mermaid">graph TB    subgraph Stack ["栈内存 Stack"]        ArcStruct["Arc&lt;T&gt;<br/>ptr: NonNull&lt;ArcData&lt;T&gt;&gt;"]        WeakStruct["Weak&lt;T&gt;<br/>ptr: NonNull&lt;ArcData&lt;T&gt;&gt;"]    end    subgraph Heap ["堆内存 Heap"]        ArcDataStruct["ArcData&lt;T&gt;<br/>data_ref_count<br/>alloc_ref_count<br/>data"]    end    ArcStruct -->|直接指向| ArcDataStruct    WeakStruct -->|直接指向| ArcDataStruct    classDef stackStyle fill:#e1f5fe,stroke:#01579b,stroke-width:2px    classDef heapStyle fill:#f3e5f5,stroke:#4a148c,stroke-width:2px    class ArcStruct,WeakStruct stackStyle    class ArcDataStruct heapStyle</pre><h3 id="维护引用计数-2">维护引用计数</h3><p>修改了引用计数的语义后，我们需要重新思考如何管理引用计数。</p><ul><li>Clone:<ul><li>当 <code>Weak&lt;T&gt;</code>拷贝时，仅增加了弱引用的数量，所以我们依旧只需对<code>alloc_ref_count</code> 进行自增。</li><li>当 <code>Arc&lt;T&gt;</code> 拷贝时，这个时候，我们就只需要对<code>data_ref_count</code> 进行自增即可。</li></ul></li><li>Drop:<ul><li>当 <code>Arc&lt;T&gt;</code> 被释放时，我们需要对<code>data_ref_count</code> 进行自减。另外，如果是最后一个<code>Arc&lt;T&gt;</code> 被释放，我们需要释放 <code>data</code>，同时，我们还需要释放那个代表所有 <code>Arc</code> 的隐式<code>Weak</code>。</li><li>当 <code>Weak&lt;T&gt;</code>被释放时，我们仅需减少弱引用的数量，即对 <code>alloc_ref_count</code>进行自减。另外，当最后一个 <code>Weak&lt;T&gt;</code>被释放时，我们还需要负责释放 <code>ArcData&lt;T&gt;</code> 。</li></ul></li></ul><p>具体的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed) &gt; <span class="type">usize</span>::MAX / <span class="number">2</span> &#123;</span><br><span class="line">            std::process::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed) &gt; <span class="type">usize</span>::MAX / <span class="number">2</span> &#123;</span><br><span class="line">            std::process::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="comment">// 思考下这里为什么要用 Release？后面我们会揭晓！</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="comment">// Safety: 最后一个 Weak&lt;T&gt; 已经被释放了。</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="comment">// 释放 ArcData&lt;T&gt;</span></span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="comment">// 最后一个 `Arc` 被释放，需要做 2 件事情：</span></span><br><span class="line">            <span class="comment">// 1. 释放 ArcData.data</span></span><br><span class="line">            <span class="comment">// 2. 释放那个代表所有 `Arc` 的隐式 `Weak`</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                ManuallyDrop::<span class="title function_ invoke__">drop</span>(&amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在 `Weak` 那边 `drop()` 的时候：</span></span><br><span class="line">            <span class="comment">// 1. 会执行 alloc_ref_count--;</span></span><br><span class="line">            <span class="comment">// 2. 如果刚好是最后一个 `Weak`，那会顺带销毁 `AraData`。</span></span><br><span class="line">            <span class="title function_ invoke__">drop</span>(Weak &#123; ptr: <span class="keyword">self</span>.ptr &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个隐式 <code>Weak&lt;T&gt;</code>，如果你一时无法很好地 Get到那个点，可以尝试手动写写整个实现的过程，相信多走几遍流程，你会有那种茅塞顿开的感觉！</p><pre class="mermaid">flowchart TD    subgraph Clone["Clone 操作"]        WeakClone["Weak&lt;T&gt;::clone()"]        ArcClone["Arc&lt;T&gt;::clone()"]        WeakClone --> WeakInc["alloc_ref_count.fetch_add(1)"]        ArcClone --> ArcInc["data_ref_count.fetch_add(1)"]        WeakInc --> WeakCheck{"计数 > usize::MAX/2?"}        ArcInc --> ArcCheck{"计数 > usize::MAX/2?"}        WeakCheck -->|是| Abort1["std::process::abort()"]        ArcCheck -->|是| Abort2["std::process::abort()"]        WeakCheck -->|否| WeakNew["返回新的 Weak&lt;T&gt;"]        ArcCheck -->|否| ArcNew["返回新的 Arc&lt;T&gt;"]    end    subgraph Drop["Drop 操作"]        WeakDrop["Weak&lt;T&gt;::drop()"]        ArcDrop["Arc&lt;T&gt;::drop()"]        WeakDrop --> WeakDec["alloc_ref_count.fetch_sub(1, Release)"]        ArcDrop --> ArcDec["data_ref_count.fetch_sub(1, Release)"]        WeakDec --> WeakDropCheck{"返回值 == 1?<br/>最后一个 Weak?"}        ArcDec --> ArcDropCheck{"返回值 == 1?<br/>最后一个 Arc?"}        WeakDropCheck -->|是| WeakFence["fence(Acquire)"]        WeakDropCheck -->|否| WeakEnd["结束"]        ArcDropCheck -->|是| ArcFence["fence(Acquire)"]        ArcDropCheck -->|否| ArcEnd["结束"]        WeakFence --> WeakFree["释放 ArcData&lt;T&gt;<br/>Box::from_raw(ptr)"]        ArcFence --> ArcDataFree["释放 data<br/>ManuallyDrop::drop()"]        ArcDataFree --> ImplicitWeak["释放隐式 Weak<br/>drop(Weak { ptr })"]        ImplicitWeak --> WeakDrop    end    subgraph Memory["内存释放顺序"]        Step1["① Arc 释放 data 内容"]        Step2["② Arc 释放隐式 Weak"]        Step3["③ Weak 释放 ArcData 结构"]        Step1 --> Step2        Step2 --> Step3    end    classDef cloneStyle fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px    classDef dropStyle fill:#ffebee,stroke:#c62828,stroke-width:2px    classDef memStyle fill:#fff3e0,stroke:#e65100,stroke-width:2px    classDef criticalStyle fill:#fce4ec,stroke:#880e4f,stroke-width:3px    class WeakClone,ArcClone,WeakInc,ArcInc,WeakNew,ArcNew cloneStyle    class WeakDrop,ArcDrop,WeakDec,ArcDec,WeakEnd,ArcEnd dropStyle    class WeakFree,ArcDataFree,ImplicitWeak criticalStyle    class Step1,Step2,Step3 memStyle</pre><p>至此，我们重新运行之前的测试用例<code>arc_should_work()</code>，可以发现的成功通过的。</p><p>下面我们继续来调整 <code>get_mut</code>、<code>downgrade()</code> 和<code>upgrade()</code>。</p><h3 id="upgrade-1">upgrade()</h3><p><code>upgrade()</code> 比较简单，它的规则还是不变，只有当存在<code>Arc&lt;T&gt;</code> 时，即 <code>data_ref_count&gt;0</code>时，才能升级成功：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Weak&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">upgrade</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Arc&lt;T&gt;&gt; &#123;</span><br><span class="line">      <span class="comment">// 获取 data_ref_count 的值。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">          <span class="comment">// 如果为 0，表示已经没有 Arc 了，升级失败。</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert!</span>(n &lt; <span class="type">usize</span>::MAX);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 存在 Arc，则对 data_ref_count 尝试进行 CAS 加 1。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">compare_exchange_weak</span>(</span><br><span class="line">                n,</span><br><span class="line">                n + <span class="number">1</span>,</span><br><span class="line">                Ordering::Relaxed,</span><br><span class="line">                Ordering::Relaxed,</span><br><span class="line">            ) &#123;</span><br><span class="line">              <span class="comment">// CAS 失败，则重试。</span></span><br><span class="line">                n = e;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// CAS 成功，则返回升级后的 Arc。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(Arc &#123; ptr: <span class="keyword">self</span>.ptr &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get_mut-1">get_mut()</h3><p>接一下我们看<code>get_mut</code>，规则也是不变：<strong>当前仅当只有一个<code>Arc&lt;T&gt;</code>，且不存在 <code>Weak&lt;T&gt;</code>时，才可以返回可变引用。</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个条件</span></span><br><span class="line"><span class="comment">// 1. 没有 Weak&lt;T&gt;</span></span><br><span class="line"><span class="comment">// 2. 没有其他的 Arc&lt;T&gt;</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(arc: &amp;<span class="keyword">mut</span> Arc&lt;T&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123;</span><br><span class="line">    <span class="comment">// 将 alloc_ref_count 从 1 置为 usize::Max。</span></span><br><span class="line">    <span class="comment">//  如果失败：说明之前不是 1，即存在其他的 Weak&lt;T&gt;，无法获取 &amp;mut T， None</span></span><br><span class="line">    <span class="comment">//  如果成功：说明当前没有 Weak&lt;T&gt;，第一步校验通过。</span></span><br><span class="line">    <span class="keyword">if</span> arc</span><br><span class="line">        .<span class="title function_ invoke__">data</span>()</span><br><span class="line">        .alloc_ref_count</span><br><span class="line">        .<span class="title function_ invoke__">compare_exchange</span>(<span class="number">1</span>, <span class="type">usize</span>::MAX, Ordering::Acquire, Ordering::Relaxed)</span><br><span class="line">        .<span class="title function_ invoke__">is_err</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_unique</span> = arc.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 alloc_ref_count</span></span><br><span class="line">    arc.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">store</span>(<span class="number">1</span>, Ordering::Release);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在其他的 Arc，则无法获取 &amp;mut T，返回 None</span></span><br><span class="line">    <span class="keyword">if</span> !is_unique &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在其他的 Arc，返回 &amp;mut T</span></span><br><span class="line">    <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> *arc.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的逻辑就不赘述了，但是这里有 <strong>3个</strong>原子操作的内存顺序我们需要讨论一下！</p><p>分别是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Weak&lt;T&gt; 的数量并暂时锁定</span></span><br><span class="line">arc</span><br><span class="line">  .<span class="title function_ invoke__">data</span>()</span><br><span class="line">  .alloc_ref_count</span><br><span class="line">  .<span class="title function_ invoke__">compare_exchange</span>(<span class="number">1</span>, <span class="type">usize</span>::MAX, Ordering::Acquire, Ordering::Relaxed)</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Arc&lt;T&gt; 的数量</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">is_unique</span> = arc.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line"><span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放 alloc_ref_count</span></span><br><span class="line">arc.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">store</span>(<span class="number">1</span>, Ordering::Release);</span><br></pre></td></tr></table></figure><hr /><p>首先看第 1 个，我们要判断当前是否已经没有 <code>Weak&lt;T&gt;</code>了，所以我们需要保证看到之前所有 <code>drop(Weak&lt;T&gt;)</code>的写入操作，所以这里需要建立起一个 happens-before，因此我们之前为<code>Weak&lt;T&gt;</code> 实现 <code>Drop</code> trait 的时候，使用的是<code>Release</code>，而这里，需要使用 <code>Acquire</code>来进行配对，建立 happens-before。</p><hr /><p>然后看第 2 个，这里我们要判断是否仅有一个<code>Arc&lt;T&gt;</code>，所以我们需要保证看到之前所有<code>drop&lt;Arc&lt;T&gt;</code> 的写入操作，因此我们之前为<code>Arc&lt;T&gt;</code> 实现 <code>Drop</code> trait 的时候，使用的是<code>Release</code>。但是在这里，我们仅需在仅剩 1 个 <code>Arc</code>的时候，才有必要建立 happens-before，所以当 <code>is_unique=true</code>时，我们补一个 <code>fence(Acquire)</code> 屏障，来建立跟<code>drop(Arc&lt;T&gt;)</code> 的 happens-before。</p><hr /><p>在分析第 3 个之前，我们需要来尝试挖一下当前 <code>get_mut</code>的漏洞！相信有部分读者在看到上述实现后，跟笔者一样，会有一个疑惑：<strong><font color="red">上述2个条件的检查，并不是原子的，这样的检查还安全可靠吗？</font></strong></p><p>比如说：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(arc: &amp;<span class="keyword">mut</span> Arc&lt;T&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> arc</span><br><span class="line">        .<span class="title function_ invoke__">data</span>()</span><br><span class="line">        .alloc_ref_count</span><br><span class="line">        .<span class="title function_ invoke__">compare_exchange</span>(<span class="number">1</span>, <span class="type">usize</span>::MAX, Ordering::Acquire, Ordering::Relaxed)</span><br><span class="line">        .<span class="title function_ invoke__">is_err</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;------- 在这个间隙：另外一个 Arc downgrade() -&gt; Weak，然后 drop(Arc)</span></span><br><span class="line">    <span class="comment">// &lt;------- 那它也是检查通过的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_unique</span> = arc.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="number">1</span>;</span><br><span class="line">    arc.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">store</span>(<span class="number">1</span>, Ordering::Release);</span><br><span class="line">    <span class="keyword">if</span> !is_unique &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> *arc.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子中：</p><ol type="1"><li>假设我们已经通过了第一个检查；</li><li>在进行第二个检查之前的这个间隙中，存在另外一个<code>Arc&lt;T&gt;</code>；</li><li>然后它通过 <code>downgrade()</code> 生成了一个<code>Weak&lt;T&gt;</code>；</li><li>然后再 <code>drop(Arc&lt;T&gt;)</code>；</li><li>这个时候我们再检查 <code>Arc&lt;T&gt;</code> 的时候，会发现只有 1个，检查就通过了。但是其实这个时候，存在了其他的<code>Weak&lt;T&gt;</code>，所以是有问题的！</li></ol><pre class="mermaid">sequenceDiagram    participant A as T1 :get_mut()    participant B as T2 :downgrade()+drop(Arc)    participant C as ArcData    A->>C: CAS alloc_ref 1→MAX ✔    Note over A,B: 非原子窗口    B->>C: clone Weak <br> alloc_ref++ (Relaxed)    B->>C: drop(Arc) <br> fetch_sub data_ref (Release)    A->>C: load data_ref ==1 ✔    A->>C: store alloc_ref MAX→1 (Release)    A-->>A: fence(Acquire) → 返回 &mut T（已失效）</pre><p>所以：<strong><font color="green">我们不能让 <code>downgrade()</code> 在这个间隙中成功执行！</font></strong>这也是我们在前面将<code>alloc_ref_count</code> 置为<code>usize::Max</code>（上锁）的原因，在后面的 <code>downgrade()</code>中，我们肯定要检查这个值，如果<code>alloc_ref_count=usize::Max</code>，就不能 <code>downgrade()</code>成功，直到 <code>alloc_ref_store(1, _)</code> 的时候，才能<code>downgrade()</code> 成功。不过这个时候已经晚了！如果是这样，那<code>is_unique</code> 肯定就不为 <code>true</code>，所以会返回<code>None</code>，这个时候，我们不会返回<code>&amp;mut T</code>，所以，危机就解除了！</p><h3 id="downgrade">downgrade()</h3><p>我们先来看一下 <code>downgrade()</code> 的实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">downgrade</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Weak&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取 Weak 的引用计数</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="comment">// 如果为 usize::MAX，说明已经被锁住了，这个时候自旋重试！</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="type">usize</span>::MAX &#123;</span><br><span class="line">                std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">                n = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert!</span>(n &lt; <span class="type">usize</span>::MAX - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// alloc_ref_count 没被锁住，尝试进行 +1 操作。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">compare_exchange_weak</span>(</span><br><span class="line">                n,</span><br><span class="line">                n + <span class="number">1</span>,</span><br><span class="line">                Ordering::Acquire,</span><br><span class="line">                Ordering::Relaxed,</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// +1 失败，重试。</span></span><br><span class="line">                n = e;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// +1 成功，表示降级成功，返回 Weak。</span></span><br><span class="line">            <span class="keyword">return</span> Weak &#123; ptr: <span class="keyword">self</span>.ptr &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>downgrade()</code> 的实现中，我们跟 <code>get_mut</code>遥相呼应：</p><ol type="1"><li><p>如果<code>alloc_ref_count=usize::MAX</code>，说明被锁住，这个时候需要自旋等待并重试。</p><blockquote><p><code>std::hint::spin_loop()</code>会向 CPU 发送特定指令（如 x86 的pause 或 ARM 的 yield），提示当前处于忙等待状态，有利于优化 CPU行为。</p></blockquote></li><li><p>如果 <code>alloc_ref_count</code> 没被锁住，我们尝试进行CAS，这里成功的时候使用的 <code>Acquire</code>，为什么呢？这是为了跟前面还未讨论的<strong>第 3 个原子操作</strong>建立happens-before！</p></li></ol><p>现在我们终于可以来解开这第 3 个原子操作的原子顺序谜团了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放 alloc_ref_count</span></span><br><span class="line">arc.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">store</span>(<span class="number">1</span>, Ordering::Release);</span><br></pre></td></tr></table></figure><p>这里我们必须保证跟 <code>download()</code> 的<code>compare_exchange(_,_,Acquire,_)</code> 建立起 happens-before关系，即将 <code>alloc_ref_count</code> 置为 1 的结果必须被<code>downgrade()</code> 所在的线程看到。不然的话，这里<code>compare_exchange</code> 成功了，将 <code>alloc_ref_count</code>置为 2 了，但是 <code>get_mut</code> 又将其置为 1 了，就乱套了！</p><h3 id="完整代码-1">完整代码</h3><p>到这里我们终于是完成了 v3版本的优化工作了，真棒！介于篇幅已经够长了，这里就不再贴出完整的代码了，感兴趣的读者可以参阅：<ahref="https://github.com/hedon-rust-road/conutils/blob/main/src/arc.rs">hedon-rust-road/conutils/arc</a>。</p><h2 id="浅探标准库的-arct">浅探标准库的 Arc&lt;T&gt;</h2><p>在最后，我们来看一下标准库的 <code>Arc&lt;T&gt;</code>是如何实现的，看文章开头说的<strong>实现一个可以媲美标准库的<code>Arc&lt;T&gt;</code></strong> 是不是在吹牛！</p><p>标准库（rustc 1.87.0）的 <code>Arc&lt;T&gt;</code> 位于 <ahref="https://github.com/rust-lang/rust/blob/1.87.0/library/alloc/src/sync.rs">sync.rs</a>文件中，我们来看下它的数据结构定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;</span><br><span class="line">    T: ?<span class="built_in">Sized</span>,</span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="string">&quot;allocator_api&quot;</span>, issue = <span class="string">&quot;32838&quot;</span>)]</span> A: Allocator = Global,</span><br><span class="line">&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcInner&lt;T&gt;&gt;,</span><br><span class="line">    phantom: PhantomData&lt;ArcInner&lt;T&gt;&gt;,</span><br><span class="line">    alloc: A,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weak</span>&lt;</span><br><span class="line">    T: ?<span class="built_in">Sized</span>,</span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="string">&quot;allocator_api&quot;</span>, issue = <span class="string">&quot;32838&quot;</span>)]</span> A: Allocator = Global,</span><br><span class="line">&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcInner&lt;T&gt;&gt;,</span><br><span class="line">    alloc: A,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他一些莫名其妙的标记咱就不管了，映入眼帘可以看到一个<code>ArcInner</code>，这不就是咱的 <code>ArcData</code>吗！点进去看下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcInner</span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    strong: atomic::AtomicUsize,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the value usize::MAX acts as a sentinel for temporarily &quot;locking&quot; the</span></span><br><span class="line">    <span class="comment">// ability to upgrade weak pointers or downgrade strong ones; this is used</span></span><br><span class="line">    <span class="comment">// to avoid races in `make_mut` and `get_mut`.</span></span><br><span class="line">    weak: atomic::AtomicUsize,</span><br><span class="line"></span><br><span class="line">    data: T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好家伙！这不就是咱的 <code>ArcData</code> !</p><ul><li><code>strong</code>: 对应我们的 <code>data_ref_count</code></li><li><code>weak</code>: 对应我们的 <code>alloc_ref_count</code></li></ul><p><code>weak</code>字段上面的注释也揭示了其核心逻辑跟咱是高度一致的！</p><p>我们简单看下最重要的 <code>Drop</code> 和 <code>Clone</code>的实现，因为这涉及到引用计数的维护：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_REFCOUNT: <span class="type">usize</span> = (<span class="type">isize</span>::MAX) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arc: Clone</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>, A: Allocator + <span class="built_in">Clone</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T, A&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Arc&lt;T, A&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">old_size</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">inner</span>().strong.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed); <span class="comment">// fetch_add</span></span><br><span class="line">        <span class="keyword">if</span> old_size &gt; MAX_REFCOUNT &#123; <span class="comment">// 溢出保护</span></span><br><span class="line">            <span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">Self</span>::<span class="title function_ invoke__">from_inner_in</span>(<span class="keyword">self</span>.ptr, <span class="keyword">self</span>.alloc.<span class="title function_ invoke__">clone</span>()) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arc: Drop</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;<span class="meta">#[may_dangle]</span> T: ?<span class="built_in">Sized</span>, A: Allocator&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T, A&gt; &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// fetch_sub release 强引用</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">inner</span>().strong.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Release) != <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 最后一个 Arc 释放的时候，补一个 fence(Acquire)，</span></span><br><span class="line">      <span class="comment">// 与前面所有的 release 建立 happens-before。</span></span><br><span class="line">        acquire!(<span class="keyword">self</span>.<span class="title function_ invoke__">inner</span>().strong);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最后一个 Arc 释放的时候，释放 ArcInner 里面的 data</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">drop_slow</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Weak: Clone</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>, A: Allocator + <span class="built_in">Clone</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T, A&gt; &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Weak&lt;T, A&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(inner) = <span class="keyword">self</span>.<span class="title function_ invoke__">inner</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">old_size</span> = inner.weak.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Relaxed); <span class="comment">// fetch_add 弱引用数量</span></span><br><span class="line">            <span class="keyword">if</span> old_size &gt; MAX_REFCOUNT &#123; <span class="comment">// 溢出保护</span></span><br><span class="line">                <span class="title function_ invoke__">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回 Weak</span></span><br><span class="line">        Weak &#123; ptr: <span class="keyword">self</span>.ptr, alloc: <span class="keyword">self</span>.alloc.<span class="title function_ invoke__">clone</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Weak: Drop</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;<span class="meta">#[may_dangle]</span> T: ?<span class="built_in">Sized</span>, A: Allocator&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T, A&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">inner</span> = <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(inner) = <span class="keyword">self</span>.<span class="title function_ invoke__">inner</span>() &#123; inner &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> inner.weak.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Release) == <span class="number">1</span> &#123; <span class="comment">// fetch_sub release 弱引用</span></span><br><span class="line">            acquire!(inner.weak);  <span class="comment">// 最后一个补一个 fence(acquire)</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;  <span class="comment">// 释放 ArcInner</span></span><br><span class="line">                <span class="keyword">self</span>.alloc.<span class="title function_ invoke__">deallocate</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">cast</span>(), Layout::for_value_raw(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到跟咱前面的实现是一样一样的！为啥？因为 <ahref="https://marabos.nl/atomics/">Rust Atomics and Locks</a>一书的作者<a href="https://github.com/m-ou-se">Mara Bos</a> 就是 Rust标准库团队的领导之一！牛逼！</p><h2 id="总结">总结</h2><p>通过三轮迭代，我们不仅实现了一个媲美了标准库的<code>Arc&lt;T&gt;</code> ，还更进一步体验了 <strong>Rust并发抽象的设计哲学</strong>：</p><ul><li><strong>v0 —— 能用</strong>：单计数 <code>ArcData&lt;T&gt;</code>解决了跨线程多所有权，但仍缺乏可变视图与断环能力。</li><li><strong>v1 —— 能改</strong>：借助独占<code>&amp;mut Arc&lt;T&gt;</code> + 原子 <em>锁</em>，在<strong>不破坏并发安全</strong> 的前提下开放了<code>get_mut</code>。</li><li><strong>v2 —— 能回收</strong>：双计数 + <code>Weak&lt;T&gt;</code>消除了父子互指造成的泄漏，展示了 <em>弱引用</em>在所有权图中的价值。</li><li><strong>v3 —— 更轻巧</strong>：将 <code>Weak</code> 独立、用<code>ManuallyDrop</code> 替换<code>Option&lt;T&gt;</code>，让没有循环引用需求的场景不再为弱引用买单。</li></ul><p>下篇我们将尝试实现一个 <code>Mutex&lt;T&gt;</code>，敬请期待！</p><p>Happy Coding! Peace~</p><h2 id="附录">附录</h2><h3 id="nonnullt">1. NonNull&lt;T&gt;</h3><p><code>std::ptr::NonNull&lt;T&gt;</code> 是一个<strong>零成本、非空、协变</strong>的裸指针包装器。它本质上只是把一个原始指针塞进<code>#[repr(transparent)]</code> 的新类型中，但强制保证<strong>绝不为空</strong>，因此可以拿到「空值当作枚举判别位」这份额外信息—— <code>Option&lt;NonNull&lt;T&gt;&gt;</code>与一个普通指针占用同样大小。</p><p>重要特性：</p><ul><li><strong>永远非空</strong>：创建时若传入空指针即触发<strong>未定义行为</strong>。编译器可依赖这一点做优化，例如把<code>Option&lt;NonNull&lt;T&gt;&gt;</code> 合并为一个指针宽度。</li><li><strong>协变</strong>：与 <code>*mut T</code>不同，<code>NonNull&lt;T&gt;</code> 可以在<code>U: Deref&lt;Target = T&gt;</code>的场景下安全向子类型转换（因为禁止空值带来了额外保证），这使它非常适合构建自定义智能指针。</li><li><strong>无自动 Drop</strong>：<code>NonNull</code>只存地址，不持有所有权；销毁与释放内存仍由外部逻辑决定（如<code>Box::from_raw</code>、<code>Vec::dealloc</code> 等）。</li></ul><p>我们将其与裸指针、 <code>Box&lt;T&gt;</code> 智能指针和引用<code>&amp;T</code> 做一个简单的比较：</p><table><colgroup><col style="width: 22%" /><col style="width: 21%" /><col style="width: 39%" /><col style="width: 15%" /></colgroup><thead><tr><th>特性</th><th><code>*mut T</code> / <code>*const T</code></th><th><code>NonNull&lt;T&gt;</code></th><th><code>Box&lt;T&gt;</code> / <code>&amp;T</code></th></tr></thead><tbody><tr><td><strong>是否允许为空</strong></td><td>✅</td><td><strong>❌ 必须非空</strong></td><td>不适用</td></tr><tr><td><strong>协变性</strong></td><td><code>*mut</code> 不协变</td><td><strong>协变</strong>（可安全向子类型转换）</td><td><code>&amp;T</code> 协变</td></tr><tr><td><strong>Option 优化</strong></td><td>❌ 多 1 B 判别字节</td><td><strong>✅ 与裸指针同尺寸</strong></td><td>已自带优化</td></tr><tr><td><strong>所有权 / drop 责任</strong></td><td>没有</td><td>没有（纯指针）</td><td>有</td></tr><tr><td><strong>Send / Sync</strong></td><td>与 <code>T</code> 无关</td><td>默认 <code>!Send !Sync</code></td><td>取决于 <code>T</code></td></tr><tr><td><strong>常见用途</strong></td><td>FFI、底层算法</td><td><strong>智能指针内部、侵入式容器、裁掉空判</strong></td><td>高层所有权模型</td></tr></tbody></table><p>关键的 API：</p><table><colgroup><col style="width: 5%" /><col style="width: 43%" /><col style="width: 51%" /></colgroup><thead><tr><th>分组</th><th>代表方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>构造</strong></td><td><code>NonNull::new(ptr)</code> →<code>Option&lt;NonNull&lt;T&gt;&gt;</code><br><code>unsafe &#123; NonNull::new_unchecked(ptr) &#125;</code><br><code>NonNull::dangling()</code></td><td>安全 / 不安全 / 占位</td></tr><tr><td><strong>引用视图</strong></td><td><code>unsafe</code> <br><code>fn as_ref</code> /<code>as_mut</code></td><td>把裸指针临时借用成 <code>&amp;T</code> /<code>&amp;mut T</code></td></tr><tr><td><strong>裸指针互转</strong></td><td><code>fn as_ptr</code></td><td>取回 <code>*mut T</code>，解引用仍需 <code>unsafe</code></td></tr><tr><td><strong>类型转换</strong></td><td><code>fn cast&lt;U&gt;</code> <br><code>fn cast_mut</code> /<code>cast_const</code></td><td>保留地址，换类型或可变性</td></tr><tr><td><strong>地址运算</strong></td><td><code>unsafe fn add / byte_add / sub / offset</code></td><td>指针算术，与 <code>ptr::add</code> 族一致</td></tr><tr><td><strong>切片助手</strong></td><td><code>NonNull::slice_from_raw_parts(data, len)</code><br><code>fn len()</code></td><td>1.70+ 稳定，为 <code>[T]</code> 提供非空裸切片构造 (<ahref="https://rustwiki.org/zh-CN/std/ptr/struct.NonNull.html?utm_source=chatgpt.com">rustwiki.org</a>)</td></tr></tbody></table><blockquote><p>⚠️ 任何把 <code>NonNull</code> 重新解释为引用或解引用的操作，都必须在<code>unsafe</code> 块里手动保证内存有效性与别名规则。</p></blockquote><p>典型使用场景：</p><table><colgroup><col style="width: 36%" /><col style="width: 63%" /></colgroup><thead><tr><th>场景</th><th>作用</th></tr></thead><tbody><tr><td><strong>智能指针内部实现</strong>(<code>Box</code>/<code>Rc</code>/<code>Arc</code>)</td><td>需要 <em>非空</em> 原始指针存放被管对象，且要在 <code>Option</code>等场景下节省空间</td></tr><tr><td><strong>自研侵入式链表 / 红黑树</strong></td><td>节点自身持有前后指针字段<code>NonNull&lt;Node&lt;T&gt;&gt;</code>，天然避免空判分支</td></tr><tr><td><strong>惰性初始化 / <code>Vec::new</code></strong></td><td>先用 <code>NonNull::dangling()</code>占位，等真正分配后再写入正确地址</td></tr><tr><td><strong>FFI</strong></td><td>C API 明确保证参数永不为空时，用 <code>NonNull</code>在类型层面表达前置条件</td></tr><tr><td><strong>自引用结构（Pin 工作区）</strong></td><td>在完成真正初始化前使用 <code>NonNull::dangling()</code>保存指向自身字段的指针</td></tr></tbody></table><h3 id="manuallydropt">2. ManuallyDrop&lt;T&gt;</h3><p><code>std::mem::ManuallyDrop&lt;T&gt;</code>是一个零成本（zero-cost）包装器。把值包在 <code>ManuallyDrop</code>里会告诉编译器：<strong>请不要在作用域结束时自动调用它的<code>Drop</code>实现，什么时候释放（或是否释放）由我手动决定。</strong></p><ul><li><code>ManuallyDrop&lt;T&gt;</code> 只是把 <strong>"是否自动drop"</strong> 这一语义从编译器搬到了程序员身上；</li><li>它<strong>不改变</strong> <code>T</code>的布局，也不会产生额外的字节，因此是零开销；</li><li><strong>unsafe责任</strong>：你必须保证一份值<strong>恰好析构一次</strong>（不能漏掉，也不能多调）。</li></ul><p>它的核心 API 如表所示：</p><table><colgroup><col style="width: 33%" /><col style="width: 32%" /><col style="width: 34%" /></colgroup><thead><tr><th>API</th><th>作用</th><th>重要注意点</th></tr></thead><tbody><tr><td><strong><code>ManuallyDrop::new(value)</code></strong></td><td>把 <code>T</code> 包装成<code>ManuallyDrop&lt;T&gt;</code>，关闭自动析构</td><td>零开销；之后需显式 drop 或移动走</td></tr><tr><td><strong><code>ManuallyDrop::drop(&amp;mut self)</code></strong><em>(unsafe)</em></td><td>手动触发内部值的析构</td><td>必须保证之后不会再访问 / 再 drop</td></tr><tr><td><strong><code>ManuallyDrop::take(&amp;mut self)</code></strong><em>(unsafe)</em></td><td>从包装里"搬走"值（等价于 <code>ptr::read</code>）</td><td><code>v</code> 里留下未初始化内存，不能再用或再 drop</td></tr><tr><td><strong><code>ManuallyDrop::into_inner(self)</code></strong><em>(unsafe)</em></td><td>消费 <code>ManuallyDrop</code> 返回内部值</td><td>取得所有权后，原包装已被移走（不会 double-drop）</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文手把手带你拆解并重构 Arc：从单线程引用计数，到跨线程 Weak 防环，再到剥离强/弱引用与内存序优化，层层深入 Rust 并发与内存模型核心。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 实战" scheme="https://hedon.top/categories/rust/rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨手写一个 oneshot channel</title>
    <link href="https://hedon.top/2025/05/29/rust-action-oneshot-channel/"/>
    <id>https://hedon.top/2025/05/29/rust-action-oneshot-channel/</id>
    <published>2025-05-29T14:11:03.000Z</published>
    <updated>2025-06-12T17:06:35.189Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><ahref="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust实战丨手写一个 SpinLock</a></li><li><ahref="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust实战丨手写一个 oneshot channel</a> 👈 本篇</li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust实战丨手写一个 RwLock</a></li></ul><hr /><p>继上篇 <ahref="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust实战丨手写一个 SpinLock</a>，本篇我们继续参考 <ahref="https://marabos.nl/atomics/">Rust Atomics and Locks</a>一书，来实现一个 <code>oneshot channel</code>。</p><p>在 Go 语言中，有一句名言：</p><blockquote><p>Don't communicate by sharing memory, share memory by communicating.不要通过共享内存来通信，而要通过通信来共享内存。</p></blockquote><p>讲的就是通道 <code>channel</code>。使用 <code>channel</code>来通信，一方面可以避免共享状态的并发竞争问题，另一方面可以解耦生产者和消费者。</p><p><code>channel</code> 根据生产者和消费者的数量，可以分为以下几种：</p><ol type="1"><li><strong>单生产者单消费者</strong> (SPSC)</li><li><strong>单生产者多消费者</strong> (SPMC)</li><li><strong>多生产者单消费者</strong> (MPSC)</li><li><strong>多生产者多消费者</strong> (MPMC)</li></ol><p>在<strong>单生产者单消费者</strong>这个分类中，有一种特殊且常用的场景，叫<strong>一次性通道</strong>（oneshotchannel）。它在 SPSC的基础上增加了额外约束：整个生命周期内只传递一次数据，传递完成后通道就失效了。</p><p>熟悉 Go 语言的读者应该对以下使用场景很熟悉，这些都是典型的 oneshotchannel 应用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ... do something</span></span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">oneShot := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">oneShot &lt;- generateText()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">text := &lt;-oneShot</span><br><span class="line">doSthWithText(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateText</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSthWithText</span><span class="params">(text <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Rust 社区里面，就有一个非常优秀的 <ahref="https://docs.rs/oneshot/latest/oneshot/">oneshot</a>实现，在详细深入它的实现之前，我们先参考 <ahref="https://marabos.nl/atomics/building-channels.html">Rust Atomicsand Locks</a> 一书，来尝试实现一个 <code>oneshot channel</code>!</p><h2 id="读完本篇你能学到什么">读完本篇你能学到什么</h2><ol type="1"><li><p><strong>一次性 (oneshot) 通道的场景与优势</strong></p><ul><li>了解它与多生产者/多消费者通道的区别</li><li>掌握常见使用模式（如线程同步、单次结果返回）</li></ul></li><li><p><strong>Rust 并发核心原语的渐进式实践</strong></p><ul><li><code>UnsafeCell</code>：内部可变性基石</li><li><code>AtomicBool</code> +<code>Ordering::&#123;Release,Acquire&#125;</code>：最小化同步原语</li><li><code>MaybeUninit&lt;T&gt;</code>：零成本延迟初始化</li></ul></li><li><p><strong>用所有权与生命周期设计零误用 API</strong></p><ul><li>将 <code>Sender</code> / <code>Receiver</code> 拆分并一次性消费</li><li>生命周期引用 vs <code>Arc</code> 的权衡与替换技巧</li></ul></li><li><p><strong>线程挂起/唤醒机制</strong></p><ul><li><code>std::thread::park / unpark</code> 的阻塞式等待模型</li></ul></li><li><p><strong>类型系统层面的“防呆”手段</strong></p><ul><li>利用 <code>PhantomData</code> 禁止跨线程误用</li><li><code>Drop</code> 手动回收，避免内存泄漏</li></ul></li><li><p><strong>一步步优化的思考路径</strong></p><ul><li>如何发现问题 → 提出假设 → 实现 → 验证 → 再迭代</li></ul></li></ol><p>带着这些目标，跟随本文一路迭代到<strong>v8</strong>，你将拥有一个高性能、零误用的 oneshotchannel，以及一整套可迁移到其它并发场景的设计思维。</p><h2 id="热身版-v0基于锁的通道">热身版 v0：基于锁的通道</h2><p>我们先来实现一个<strong>万能版</strong> <code>channel</code>热热身。顾名思义，<code>channel</code> 分为 2 个功能，<code>send</code>和 <code>receive</code>，其中：</p><ul><li><code>send</code> 往 <code>channel</code> 一头放数据。</li><li><code>receive</code> 从 <code>channel</code>另外一头取数据，如果没有数据，则阻塞住，直到有数据时返回取出数据并返回。</li></ul><p>在 Rust 中，我们可以用队列 <code>VecQueue</code>来作为数据的承载，同时为了对队列访问的并发安全，我们需要使用锁<code>Mutex</code>来保护它，另外，在消费者取数据时，如果没有数据，则需要阻塞并等待唤醒（使用循环等待就太耗CPU 了），所以我们可以使用条件变量 <code>Condvar</code>来实现挂起和唤醒。</p><p>经过以上分析，我们可以定义如下的结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    collections::VecDeque,</span><br><span class="line">    sync::&#123;Condvar, Mutex&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,</span><br><span class="line">    item_ready: Condvar,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>send</code> 和 <code>receive</code>方法也比较简单，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            queue: Mutex::<span class="title function_ invoke__">new</span>(VecDeque::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">            item_ready: Condvar::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: T) &#123;</span><br><span class="line">      <span class="comment">// 上锁并从队列后面插入数据</span></span><br><span class="line">        <span class="keyword">self</span>.queue.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">push_back</span>(message);</span><br><span class="line">        <span class="comment">// 唤醒一个等待数据的线程</span></span><br><span class="line">        <span class="keyword">self</span>.item_ready.<span class="title function_ invoke__">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">receive</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">      <span class="comment">// 抢占队列</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="keyword">self</span>.queue.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">          <span class="comment">// 尝试从队列中获取数据，如果获取到，则直接返回（并释放锁）</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(message) = b.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 没有数据，则挂起当前线程（同时释放锁）</span></span><br><span class="line">            b = <span class="keyword">self</span>.item_ready.<span class="title function_ invoke__">wait</span>(b).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，<code>self.queue.lock().unwrap()</code> 返回的<code>b</code> 是一个 <code>MutextGuard</code>，所以当执行<code>self.item_ready.wait(b)</code>的时候，在挂起当前线程的时候，会释放<code>b</code>，所以这里不会一直占用锁，而导致其他线程抢不到锁。</p><p>这个版本的实现在功能上当然没有问题，但是在性能上还有非常多可以优化的地方，尤其是在锁的使用上，在高并发的情况下，锁的竞争会非常激烈。</p><p>OK，热完身后，我们开始基于这个实现，来一步步实现一个高性能的<code>oneshot channel</code>！</p><h2 id="基础版-v1unsafe-提醒使用者">基础版 v1：unsafe 提醒使用者</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,</span><br><span class="line">    item_ready: Condvar,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来分析一下，一个 <code>oneshot channel</code>的结构，需要包含哪些字段。</p><ol type="1"><li>首先它可能会有 0 条数据或 1 条数据，所以很当然，数据可以用一个<code>Option</code> 来承载。</li><li>另外，<code>send</code> 和 <code>receive</code>可以在不同的线程中被调用，所以我们只能用共享只读引用，而不是用<code>mut</code> 独享可变引用，但是 <code>send</code> 和<code>receive</code>都需要对数据进行修改，所以我们这里就需要一个支持内部可变性的数据结构，这个时候，就用到了上篇<ahref="https://hedon.top/2025/05/13/rust-action-spinlock/#%E5%8D%87%E7%BA%A7%E7%89%88-v1">Rust实战丨手写一个 SpinLock</a> 介绍的<code>UnsafeCell&lt;T&gt;</code>，它允许在共享引用下进行内部可变性修改，是Rust 并发原语的基石，这里不再赘述。</li><li>最后，我们需要一个变量来表明是否有数据，为了并发安全，这里可以用<code>AtomicBool</code>，为此，我们也增加了一个 <code>is_ready</code>的方法，用于判断数据是否已准备好。对于原子变量，我们使用一对<code>Release</code> 和 <code>Acquire</code>（<code>Release</code>确保之前的写入对其他线程可见，<code>Acquire</code> 确保能看到之前的<code>Release</code> 写入）来确保原子变量的跨线程可见性。</li></ol><p>基于以上分析，我们定出了新的 <code>Channel</code> 结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    message: UnsafeCell&lt;<span class="type">Option</span>&lt;T&gt;&gt;,</span><br><span class="line">    ready: AtomicBool,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 <code>send</code>、<code>receive</code> 和<code>is_ready</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            message: UnsafeCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">            ready: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Safety: Only call this once!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: T) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.message.<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">write</span>(<span class="title function_ invoke__">Some</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.ready.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_ready</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.ready.<span class="title function_ invoke__">load</span>(Ordering::Acquire)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Safety: Only call this once,</span></span><br><span class="line">    <span class="comment">/// and only after is_ready() returns true!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">receive</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.message.<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个版本中：</p><ol type="1"><li>我们暂且使用 <code>unsafe</code> 加注释的方式，来<strong>提醒</strong> 使用者，<code>send</code> 和 <code>receive</code>只能被调用一次，同时，在调用 <code>receive</code> 之前，必须先使用<code>is_ready</code> 进行数据检查。</li><li>对于原子变量，我们使用一对 Release 和 Acquire来确保原子变量的跨线程可见性，具体可参考 <ahref="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊Rust 的 Atomic 和内存顺序</a>。</li></ol><p>另外别忘了，<code>UnsafeCell&lt;T&gt;</code> 是不支持<code>Sync</code> 的，所以为了我们的 <code>Channel</code>可以跨线程使用，我们需要为其实现 <code>Sync</code> trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Channel&lt;T&gt; 可以在不同的线程中被分别执行 send 和 receive，所以它的引用可以在线程中共享，所以需要实现 Sync；</span></span><br><span class="line"><span class="comment">// 2. T 由线程 1 生成并放入 Channel，然后由线程 2 从 Channel 中获取，所以它需要从一个线程转移到另外一个线程，所以需要实现 Send。</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Channel</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        channel.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> channel.<span class="title function_ invoke__">is_ready</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msg</span> = <span class="keyword">unsafe</span> &#123; channel.<span class="title function_ invoke__">receive</span>() &#125;;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(msg, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                channel.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> channel.<span class="title function_ invoke__">is_ready</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">unsafe</span> &#123; channel.<span class="title function_ invoke__">receive</span>() &#125;;</span><br><span class="line">                <span class="built_in">assert_eq!</span>(res, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础版-v2使用-maybeuninit-替代-option-减少内存开销">基础版v2：使用 MaybeUninit 替代 Option 减少内存开销</h2><p>我们先来思考一个问题：<strong>Option&lt;T&gt;的内存占用是多少？</strong></p><blockquote><p>结论是：：<strong><code>Option&lt;T&gt;</code> 相比于T，可能需要额外消耗标记位和填充位的空间</strong>。具体可参考<u>附录：1.Option&lt;T&gt; 的内存占用是多少</u>。</p></blockquote><p>另外一点是，<code>Option&lt;T&gt;</code>其实已经包含了是否存在值的信息了，它跟 <code>ready</code>这个标志的作用其实重复了，有一些浪费。</p><p>在当下场景，我们可以使用另外一个数据结构来替代<code>Option&lt;T&gt;</code> ——<code>MaybeUninit&lt;T&gt;</code>，相比于<code>Option&lt;T&gt;</code>，它有以下优势：</p><ol type="1"><li><strong>内存占用优化</strong>：在 <code>Option&lt;T&gt;</code>中，对于非空指针优化（Niche Optimization）的类型，<code>None</code>会占用额外的空间（一个字节的标签+可能的对齐填充）。而<code>MaybeUninit&lt;T&gt;</code> 本身就是一个大小与 <code>T</code>相同的未初始化内存，它没有标签，因此不会引入额外的内存开销。</li><li><strong>避免初始化开销</strong>：使用 <code>Option&lt;T&gt;</code>时，在初始化时设置为 <code>None</code>，实际上会写入一个表示<code>None</code> 的值（即进行初始化）。而<code>MaybeUninit&lt;T&gt;</code> 的 <code>uninit()</code>不会对内存进行任何初始化，这在性能敏感的场景下可以避免不必要的初始化开销（特别是当<code>T</code> 很大时）。</li><li><strong>更灵活地控制初始化</strong>：在通道的实现中，消息可能由生产者写入，然后通过设置<code>ready</code> 标志来通知消费者。使用 <code>MaybeUninit</code>允许我们延迟初始化，直到实际需要写入消息的时候。这样，在通道创建时，我们不需要为<code>T</code> 类型的值进行任何初始化（即使是<code>None</code>），而是留出一块未初始化的内存，在后续由生产者写入实际的值。</li><li><strong>与原子标志配合更高效</strong>：在上个版本的视线中，<code>ready</code>是一个 <code>AtomicBool</code>，用于指示消息是否就绪。在<code>Option&lt;T&gt;</code> 版本中，我们需要检查 <code>Option</code>是否为 <code>Some</code>，同时还要检查 <code>ready</code> 标志。而使用<code>MaybeUninit</code> 后，我们完全依赖 <code>ready</code>标志来判断消息是否可用，避免了双重检查（因为 <code>MaybeUninit</code>本身不携带状态，所以状态完全由 <code>ready</code>控制）。这样，结构体的内存布局更紧凑，且访问模式更直接。</li><li><strong>潜在的性能提升</strong>：由于避免了额外的标签和初始化，以及更紧凑的内存布局，可能会提高缓存利用率，从而提升性能。</li></ol><p><code>MaybeUninit&lt;T&gt;</code> 有以下常用方法：</p><table><colgroup><col style="width: 28%" /><col style="width: 46%" /><col style="width: 25%" /></colgroup><thead><tr><th>常用方法</th><th>作用</th><th>安全级别</th></tr></thead><tbody><tr><td><code>MaybeUninit::uninit()</code></td><td>创建一块<strong>完全未初始化</strong>的内存</td><td><code>const fn</code>、<code>safe</code></td></tr><tr><td><code>as_mut_ptr()</code> / <code>as_ptr()</code></td><td>取出裸指针，供外部写入或读取</td><td><code>safe</code></td></tr><tr><td><code>assume_init()</code> / <code>assume_init_read()</code></td><td>告诉编译器“这里已经是一个合法的 <code>T</code> 了”，并返回它</td><td><code>unsafe</code>（因为你得保证真初始化过）</td></tr><tr><td><code>write(val)</code></td><td><strong>按位把 <code>val</code> 复制/移动</strong>到这块未初始化内存；此后视为已初始化</td><td><code>unsafe</code></td></tr></tbody></table><p>经过上面一顿分析，我们来使用 <code>MaybeUninit&lt;T&gt;</code> 来替代<code>Option&lt;T&gt;</code>，进一步减少内存占用和提升性能，新的<code>Channel</code> 结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    message: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,</span><br><span class="line">    ready: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">          <span class="comment">// 创建一块完全未初始化的内存，先占位</span></span><br><span class="line">            message: UnsafeCell::<span class="title function_ invoke__">new</span>(MaybeUninit::<span class="title function_ invoke__">uninit</span>()),</span><br><span class="line">            ready: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 <code>send</code> 和 <code>receive</code> 实现更新如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// Safety: Only call this once!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: T) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="comment">// 从 UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt; 中取出 MaybeUninit&lt;T&gt; 并写入数据。</span></span><br><span class="line">            (*<span class="keyword">self</span>.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">write</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.ready.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Safety: Only call this once,</span></span><br><span class="line">    <span class="comment">/// and only after is_ready() returns true!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">receive</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">      <span class="comment">// 从 UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt; 中取出 MaybeUninit&lt;T&gt; 并读出数据。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*<span class="keyword">self</span>.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">assume_init_read</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>send</code> 中，<code>(*self.message.get())</code> 从<code>UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;</code> 中取出<code>MaybeUninit&lt;T&gt;</code>，然后调用 <code>write</code> 方法把<code>message</code>写入这块未初始化的内存中，此后视为已初始化，并可以使用使用<code>assume_init_read</code> 进行读取。</p><p>修改后，测试代码没有发生变化，我们执行之前的测试代码，发现还是可以通过的！</p><h2 id="基础版-v3增加动态检查提高安全性">基础版v3：增加动态检查提高安全性</h2><p>上述版本中，我们通过 <code>unsafe</code>和注释去“要求”调用者严格遵循以下约束：</p><ol type="1"><li><code>send</code> 和 <code>receive</code> 最多只调用一次。</li><li><code>receive</code> 调用之前，必须先经过 <code>is_ready</code>的检查。</li></ol><p>在这个版本中，我们加一下动态检查，如果调用者不按要求做事，那就直接<code>panic</code> 给出告警。</p><p>在 <code>receive</code> 中，我们需要做 2 点保证：① 已经有数据了，②数据只被消耗了一次。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">receive</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="keyword">self</span>.ready.<span class="title function_ invoke__">swap</span>(<span class="literal">false</span>, Ordering::Acquire) &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;no message available!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; (*<span class="keyword">self</span>.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">assume_init_read</span>() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用 <code>swap</code>，将 <code>ready</code> 从<code>false</code> 转为 <code>true</code>，达到了 2 个目的：</p><ol type="1"><li>如果返回了 <code>false</code>，则说明之前的 <code>ready</code> 为<code>false</code>，即数据没准备好。</li><li>如果返回了<code>true</code>，则说明数据已经准备好了，这个时候，也已经将<code>ready</code> 置为 <code>false</code>，这样后面调用的<code>receive</code> 也将失败。</li></ol><p>对于<code>send</code>，我们需要保证只写入一次，所以这里我们需要引入一个新的变量<code>in_user</code>，表示 <code>send</code> 是否已经使用了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    message: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,</span><br><span class="line">    in_use: AtomicBool, <span class="comment">// 新变量，表示 send 是否已经使用了。</span></span><br><span class="line">    ready: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            message: UnsafeCell::<span class="title function_ invoke__">new</span>(MaybeUninit::<span class="title function_ invoke__">uninit</span>()),</span><br><span class="line">            in_use: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">            ready: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>send</code> 中，我们依旧使用 <code>swap</code>，来将<code>in_use</code> 从转为 <code>true</code>，如果返回<code>true</code>，则说明之前已经执行过 <code>send</code>了，这个时候将执行 panic 进行告警。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Panics when trying to send more than one message.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: T) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.in_use.<span class="title function_ invoke__">swap</span>(<span class="literal">true</span>, Ordering::Relaxed) &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;can&#x27;t send more than one message&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        (*<span class="keyword">self</span>.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">write</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.ready.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述的 2 个优化，我们的 <code>Channel</code>又“安全”了一丢丢！</p><h2 id="基础版-v4实现-drop-自动清理无用内存">基础版 v4：实现 Drop自动清理无用内存</h2><p>因为我们使用了<code>MaybeUninit&lt;T&gt;</code>，所以我们需要自己管理 <code>T</code>的内存管理，但在上述的实现中，可能存在一种情况，导致内存得不到释放：<strong>我们只执行了<code>send</code>，但直到 <code>Channel</code>超过作用域的时候，都没有被 <code>receive</code></strong>。</p><p>为此，我们可以为 <code>Channel</code> 实现 <code>Drop</code>trait，当有数据的时候，对<code>MaybeUninit&lt;T&gt;</code>进行内存释放：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> *<span class="keyword">self</span>.ready.<span class="title function_ invoke__">get_mut</span>() &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.message.<span class="title function_ invoke__">get_mut</span>().<span class="title function_ invoke__">assume_init_drop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安全非阻塞版-v5提供安全方法减少使用者误用">安全非阻塞版v5：提供安全方法，减少使用者误用</h2><p>在这个版本中，我们来解决前面实现的最大问题：<strong>方法是不安全的，严重依赖调用者的自觉性，没有充分发挥Rust 强大编译器的检查能力</strong>。</p><p>回顾我们的需求：<strong>我们要实现的是一个<code>oneshot channel</code>，即只能调用一次 <code>send</code> 和<code>receive</code></strong>。</p><p>第一个问题是：如何利用 Rust天然的编译器检查能力来约束这一点呢？很明显，就是<strong>所有权机制</strong>！什么东西只能执行一次呢？消耗所有权的东西！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于第一个参数为 self 的方法，执行时，会转移所有权，执行后，原变量就不能再用了，因为所有权已经转移了。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do</span>(<span class="keyword">self</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>好，那第二个问题就来了：<code>self</code>方法只能调用一次，但很明显我们总共需要 2 次的调用（<code>send</code> 和<code>receive</code>），所以这里我们可以将 <code>Channel</code>进行拆开，分成 <code>Sender</code> 和 <code>Receiver</code>。</p><p>那第三个问题也就随之而来了，<code>Sender</code> 和<code>Receiver</code> 都需要持有<code>Channel</code>，并且可能处于不同的线程，这里我们可以先用<code>Arc</code> 来对 <code>Channel</code> 进行引用。</p><p>解决了上述 3 个问题，我们可以梳理新的数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Sender</span>&lt;T&gt; &#123;</span><br><span class="line">    channel: Arc&lt;Channel&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Receiver</span>&lt;T&gt; &#123;</span><br><span class="line">    channel: Arc&lt;Channel&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    message: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,</span><br><span class="line">    ready: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">channel</span>&lt;T&gt;() <span class="punctuation">-&gt;</span> (Sender&lt;T&gt;, Receiver&lt;T&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Arc::<span class="title function_ invoke__">new</span>(Channel &#123;</span><br><span class="line">        message: UnsafeCell::<span class="title function_ invoke__">new</span>(MaybeUninit::<span class="title function_ invoke__">uninit</span>()),</span><br><span class="line">        ready: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">    (Sender &#123; channel: a.<span class="title function_ invoke__">clone</span>() &#125;, Receiver &#123; channel: a &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li><code>Channel</code> 中移除了 <code>in_use</code>属性，因为我们已经有 <code>self</code> 做所有权检查了，不再需要<code>in_use</code> 来避免重复调用 <code>send</code> 了。</li><li>新增了 <code>Sender&lt;T&gt;</code> 和<code>Receiver&lt;T&gt;</code> 两个结构，它们都各自持有了一个<code>Arc&lt;Channel&gt;</code>。</li></ol><p>对应的 <code>send</code> 和 <code>receive</code> 方法当然也就转移到<code>Sender&lt;T&gt;</code> 和 <code>Receiver&lt;T&gt;</code>身上了，实现也和之前基本一致：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Sender&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">send</span>(<span class="keyword">self</span>, messgae: T) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*<span class="keyword">self</span>.channel.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">write</span>(messgae) &#125;;</span><br><span class="line">        <span class="keyword">self</span>.channel.ready.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Receiver&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_ready</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.channel.ready.<span class="title function_ invoke__">load</span>(Ordering::Relaxed)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Safety: only after is_ready() returns true!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">receive</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.channel.ready.<span class="title function_ invoke__">swap</span>(<span class="literal">false</span>, Ordering::Acquire) &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;no message available!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*<span class="keyword">self</span>.channel.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">assume_init_read</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drop 没变</span></span><br></pre></td></tr></table></figure><p>修改了结构了，我们需要修改对应的测试代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = <span class="title function_ invoke__">channel</span>();</span><br><span class="line">    sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> receiver.<span class="title function_ invoke__">is_ready</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msg</span> = receiver.<span class="title function_ invoke__">receive</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(msg, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = <span class="title function_ invoke__">channel</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line">            sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>); <span class="comment">// 没有 unsafe 了！</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> receiver.<span class="title function_ invoke__">is_ready</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">res</span> = receiver.<span class="title function_ invoke__">receive</span>(); <span class="comment">// 没有 unsafe 了！</span></span><br><span class="line">                <span class="built_in">assert_eq!</span>(res, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最新的测试代码中，我们已经不再需要 <code>unsafe</code>代码了！这对于使用者来说，就非常友好了！</p><p>而且这个时候，你如果尝试执行多次 <code>send</code> 和<code>receive</code> 的时候，编译器就会报错了！</p><p>不过它还是有 2 个缺点：</p><ol type="1"><li><code>Arc</code> 的复制还是有一些开销的。</li><li>我们依旧依赖使用者提前用 <code>is_ready</code> 来检查，否则直接调用<code>receive</code> 就有可能会 <code>panic</code>。</li></ol><p>我们先来解决第 1 个问题。</p><h2id="安全非阻塞版-v6使用生命周期加引用避免-arc-的复制开销">安全非阻塞版v6：使用生命周期加引用，避免 Arc 的复制开销</h2><p>为了避免 Arc 的开销，我们需要在 <code>Sender&lt;T&gt;</code> 和<code>Receiver&lt;T&gt;</code> 中持有 <code>Channel&lt;T&gt;</code>的引用，而引用的对象的生命周期是不确定的，所以我们需要加入生命周期标注，来告诉编译器我们的引用是逻辑自洽的。</p><p>新的结构和构造函数如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Sender</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    channel: &amp;<span class="symbol">&#x27;a</span> Channel&lt;T&gt;, <span class="comment">// 使用引用替代 Arc，并加入生命周期标注</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Receiver</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    channel: &amp;<span class="symbol">&#x27;a</span> Channel&lt;T&gt;, <span class="comment">// 使用引用替代 Arc，并加入生命周期标注</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    message: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,</span><br><span class="line">    ready: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            message: UnsafeCell::<span class="title function_ invoke__">new</span>(MaybeUninit::<span class="title function_ invoke__">uninit</span>()),</span><br><span class="line">            ready: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">split</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> (Sender&lt;<span class="symbol">&#x27;a</span>, T&gt;, Receiver&lt;<span class="symbol">&#x27;a</span>, T&gt;) &#123;</span><br><span class="line">        *<span class="keyword">self</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        (Sender &#123; channel: <span class="keyword">self</span> &#125;, Receiver &#123; channel: <span class="keyword">self</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drop 没变</span></span><br></pre></td></tr></table></figure><p>在这个版本的实现中，我们新增了 <code>split</code> 方法：</p><ol type="1"><li>其中参数 <code>&amp;'a mut self</code> 表明它是一个独占引用，即<code>channel.split()</code> 不会有并发问题。</li><li>第一行代码 <code>*self = Self::new()</code> 我们对原有的<code>Channel</code>进行重置，保证<strong>拆分之前通道里绝对没有残留数据</strong>，避免旧消息被下一对<code>Sender/Receiver</code> 误使用。</li><li><code>'a</code> 直接来自于<code>&amp;'a mut self</code>，保证两端把手<strong>绝不会比原始<code>Channel</code> 活得更久</strong>。</li></ol><p>新的测试代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel.<span class="title function_ invoke__">split</span>();</span><br><span class="line">    sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> receiver.<span class="title function_ invoke__">is_ready</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msg</span> = receiver.<span class="title function_ invoke__">receive</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(msg, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel.<span class="title function_ invoke__">split</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">            sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> !receiver.<span class="title function_ invoke__">is_ready</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(receiver.<span class="title function_ invoke__">receive</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安全阻塞版-v7去掉-is_ready-完全避免使用者误调用">安全阻塞版v7：去掉 is_ready 完全避免使用者误调用</h2><p>截止目前的实现版本中，我们还是依赖使用者在执行 <code>receive</code>之前先执行 <code>is_ready</code>进行数据检查，还是存在一定的误操作性。现在我们来实现一个完全阻塞的版本，来完全避免这个情况。</p><p>我们需要做几件事情：</p><ol type="1"><li>去掉 <code>is_ready</code> 方法；</li><li>在 <code>receive</code> 中，根据 <code>ready</code>判断是否存在数据：<ol type="1"><li>如果存在，则直接取出数据并返回；</li><li>如果不存在，则需要先挂起当前线程，等待唤醒（直接 CPU循环检查肯定可以，但不够优雅！咱不干！）；</li></ol></li><li>在 <code>send</code>中，放入数据后，尝试唤醒可能处于挂起中的线程。</li></ol><p>那现在最重要的一个问题是：<strong>如何唤醒处于挂起中的线程？</strong>更进一步，<strong>唤醒哪个线程？</strong></p><p>这里其实是说不定的，因为 <code>Sender</code> 和 <code>Receiver</code>都可能被放入任何一个线程中，不过在 <ahref="https://marabos.nl/atomics/building-channels.html">Rust Atomicsand Locks</a> 书中，作者假定了 <code>Receiver</code> 会固定在调用<code>split</code> 的那个线程。</p><p>笔者认为这个假设是简单且有效的，回顾一下我们前面举的 Go 语言的 2个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 类似于 split</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ... do something</span></span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-done  <span class="comment">// receiver</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">oneShot := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)  <span class="comment">// 类似于 split</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">oneShot &lt;- generateText()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">text := &lt;-oneShot  <span class="comment">// receiver</span></span><br><span class="line">doSthWithText(text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这两个最常见的 <code>oneshot channel</code>的例子中，<code>Receiver</code> 就是处于调用 <code>split</code>的线程中。所以我们可以基于这个假设来实现这个版本。</p><p>先回顾下 <code>Thread</code> 2 个最核心的方法：</p><ul><li><code>Thread.park(thread)</code>: 挂起线程，等待唤醒。</li><li><code>thread.unpark()</code>: 唤醒线程。</li></ul><p>首先我们需要在 <code>Sender</code> 中保存待唤醒的线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Sender</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    channel: &amp;<span class="symbol">&#x27;a</span> Channel&lt;T&gt;,</span><br><span class="line">    receiving_thread: Thread,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>split()</code> 的时候，我们需要获取当前线程并保存在<code>Sender</code> 中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">split</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> (Sender&lt;<span class="symbol">&#x27;a</span>, T&gt;, Receiver&lt;<span class="symbol">&#x27;a</span>, T&gt;) &#123;</span><br><span class="line">    *<span class="keyword">self</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    (</span><br><span class="line">        Sender &#123;</span><br><span class="line">            channel: <span class="keyword">self</span>,</span><br><span class="line">          <span class="comment">// 获取当前线程。记住！这里我们假设了 receiver 会固定在 split 的线程中！</span></span><br><span class="line">            receiving_thread: thread::<span class="title function_ invoke__">current</span>(),</span><br><span class="line">        &#125;,</span><br><span class="line">        Receiver &#123; channel: <span class="keyword">self</span> &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>recevie</code>的时候，如果没有数据，我们就可以挂起当前线程，等待唤醒：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Receiver&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">receive</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">while</span> !<span class="keyword">self</span>.channel.ready.<span class="title function_ invoke__">swap</span>(<span class="literal">false</span>, Ordering::Acquire) &#123;</span><br><span class="line">            thread::<span class="title function_ invoke__">park</span>(); <span class="comment">// 挂起当前线程，即 thread::current() 线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*<span class="keyword">self</span>.channel.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">assume_init_read</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>send</code> 完数据后，唤醒可能挂起的线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Sender&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">send</span>(<span class="keyword">self</span>, messgae: T) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*<span class="keyword">self</span>.channel.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">write</span>(messgae) &#125;;</span><br><span class="line">        <span class="keyword">self</span>.channel.ready.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release);</span><br><span class="line">        Thread::<span class="title function_ invoke__">unpark</span>(&amp;<span class="keyword">self</span>.receiving_thread); <span class="comment">// 唤醒 receiver 线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后删除之前的 <code>is_ready</code>方法，然后更新我们的测试代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel.<span class="title function_ invoke__">split</span>();</span><br><span class="line">    sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = receiver.<span class="title function_ invoke__">receive</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel.<span class="title function_ invoke__">split</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">            sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(receiver.<span class="title function_ invoke__">receive</span>(), <span class="number">1</span>); <span class="comment">// 不再需要检查 is_ready，这里会阻塞一直直到有数据到来</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="最终版-v8使用-phantomdata-来保证-receiver-处于-split-线程">最终版v8：使用 PhantomData 来保证 Receiver 处于 split() 线程</h2><p>是不是觉得，上述实现已经完美无瑕了！其实不然，我们虽然假设了<code>Receiver</code> 处于调用 <code>split()</code>的线程中，但是还是无法阻止使用者将 <code>Receiver</code>转移到其他线程。</p><p>再次回顾下我们现在的 <code>Channel</code> 和<code>Receiver</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Receiver</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    channel: &amp;<span class="symbol">&#x27;a</span> Channel&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    message: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,</span><br><span class="line">    ready: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Channel</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们为 <code>Channel&lt;T&gt;</code> 实现了 <code>Sync</code>trait，而标准库中有这 2 行代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> &amp;T &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> &amp;T &#123;&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>&amp;Channel&lt;T&gt;</code> 实现了 <code>Sync/Send</code>trait，而 <code>Receiver</code> 只持有了一个<code>&amp;'a Channel&lt;T&gt;</code>，所以它也是 <code>Send</code>的！</p><p>所以 <code>Receiver</code>是可以被转移到其他线程的，即下述的测试代码在编译上也是通过的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel.<span class="title function_ invoke__">split</span>(); <span class="comment">// 执行 split() 的线程</span></span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">            sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里在另外一个线程中，执行了 `receiver.receive()`</span></span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="built_in">assert_eq!</span>(receiver.<span class="title function_ invoke__">receive</span>(), <span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们执行后会发现，<code>receiver.receive()</code>会被永久阻塞住，这是因为 <code>sender.send(1)</code> 只会唤醒执行<code>split()</code> 的线程。</p><p>为了避免这种情况的发生，我们需要强行防止 <code>Receiver</code> 实现<code>Send</code> trait！</p><p>怎么办呢？我们需要做到 2 件事情：</p><ol type="1"><li>让 <code>Receiver</code> 持有一个非 <code>Sync</code> 的属性；</li><li>这个属性除了标记没有其他作用，最好不要占用任何的资源。</li></ol><p>这里我们介绍一位新朋友：<code>PhantomData</code>：</p><blockquote><p><code>PhantomData</code> 是一个零大小类型（Zero-Sized Type,ZST），用于在编译期向类型系统传递额外信息，而不占用运行时内存。</p><p>我们可以用它在包一个 <code>!Send</code> 的类型，这样<code>Receiver</code> 就是 <code>!Send</code> 的了。关于<code>PhantomData</code> 的更多介绍，可以参考<u>附录2：PhantomData</u>。</p></blockquote><p>在介绍完 <code>PhantomData</code> 后，我们就可以使用它来防止<code>Receiver</code> 实现 <code>Send</code> trait 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Receiver</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    channel: &amp;<span class="symbol">&#x27;a</span> Channel&lt;T&gt;,</span><br><span class="line">    _no_send: PhantomData&lt;*<span class="title function_ invoke__">const</span> ()&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>*const()</code> 是 <code>!Send</code> 的，所以我们的<code>Receiver</code> 再也不会被转移到其他线程了，而 <code>send</code>是要求 <code>self</code>，所以即便是 <code>Sync</code>的也无所谓了，因为无法通过引用来执行 <code>receive()</code> 方法。</p><p>现在我们可以再次执行上面的测试代码（强行将 Receiver移动到其他线程中），将会得到以下的报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `*const ()` cannot be sent between threads safely</span><br><span class="line"><span class="meta prompt_">   --&gt; </span><span class="language-bash">src/oneshotchannel.rs:103:21</span></span><br><span class="line">    |</span><br><span class="line">103 |               s.spawn(|| &#123;</span><br><span class="line">    |                 ----- ^-</span><br><span class="line">    |                 |     |</span><br><span class="line">    |  _______________|_____within this `&#123;closure@oneshotchannel.rs:103:21&#125;`</span><br><span class="line">    | |               |</span><br><span class="line">    | |               required by a bound introduced by this call</span><br><span class="line">104 | |                 assert_eq!(receiver.receive(), 1);</span><br><span class="line">105 | |             &#125;);</span><br><span class="line">    | |_____________^ `*const ()` cannot be sent between threads safely</span><br></pre></td></tr></table></figure><p>到这里，通过 8个版本，我们一步步实现了一个高性能、低内存占用且安全可用的<code>oneshot channel</code> 了！</p><h2 id="总结">总结</h2><p>至此，通过 8 个小版本，我们不仅手写了一个 <strong>高性能、安全友好的oneshot channel</strong>，还更进一步体验了 Rust 在并发领域<strong>“以类型系统驱动正确性”</strong>的威力。我们来做一个简单的小结。</p><p>关键收获：</p><table><colgroup><col style="width: 8%" /><col style="width: 52%" /><col style="width: 39%" /></colgroup><thead><tr><th>版本</th><th>新增能力</th><th>解决了什么问题</th></tr></thead><tbody><tr><td><strong>v0</strong></td><td><code>Mutex</code> + <code>Condvar</code> 通用通道</td><td>打开话题、对比后续无锁方案</td></tr><tr><td><strong>v1</strong></td><td><code>UnsafeCell&lt;Option&lt;T&gt;&gt;</code> +<code>AtomicBool</code></td><td>去锁化、最小可行一次性通道</td></tr><tr><td><strong>v2</strong></td><td>替换为 <code>MaybeUninit&lt;T&gt;</code></td><td>节省内存&amp;避免双状态检查</td></tr><tr><td><strong>v3</strong></td><td>运行时检查 (<code>swap</code>)</td><td>阻止未准备/二次调用导致 UB</td></tr><tr><td><strong>v4</strong></td><td><code>Drop</code> 清理</td><td>防止“只 send 不 recv”泄漏</td></tr><tr><td><strong>v5</strong></td><td><code>Sender</code> / <code>Receiver</code> 所有权 API</td><td>编译期保证“仅调用一次”</td></tr><tr><td><strong>v6</strong></td><td>生命周期引用替换 <code>Arc</code></td><td>消除引用计数开销</td></tr><tr><td><strong>v7</strong></td><td><code>park / unpark</code> 阻塞模型</td><td>使用者不再需要轮询 <code>is_ready</code></td></tr><tr><td><strong>v8</strong></td><td><code>PhantomData</code> 防跨线程误用</td><td>类型系统彻底封死错误用法</td></tr></tbody></table><p>核心记忆点：</p><ul><li><strong>内部可变性</strong>：<code>UnsafeCell</code>是所有并发原语的基石。</li><li><strong>延迟初始化</strong>：<code>MaybeUninit&lt;T&gt;</code> +“就绪标志” 是零成本组合。</li><li><strong>Release / Acquire</strong>：最轻量的跨线程可见性保障。</li><li><strong>所有权设计 API</strong>：让编译器替你兜底逻辑约束。</li><li><strong>PhantomData</strong>：零大小但能影响 <code>Send/Sync</code>的类型级标记。</li><li><strong>迭代思路</strong>：先跑通，再收口安全性与性能，最后用类型系统“防呆”。</li></ul><p>完整的代码可以参考：<ahref="https://github.com/hedon-rust-road/conutils/blob/main/src/oneshot.rs">conutils-oneshot</a>。</p><h2 id="oneshot-crate-浅探">oneshot crate 浅探</h2><h2 id="附录">附录</h2><h3 id="optiont-的内存占用是多少">1. Option&lt;T&gt;的内存占用是多少？</h3><p>在 Rust 中，<code>Option&lt;T&gt;</code>类型占用的内存，取决于泛型参数 <code>T</code>的类型特性。具体可分为两种情况：</p><ul><li>当 T是<strong>非指针类型</strong>（如基本类型、结构体等）时，<code>Option&lt;T&gt;</code>需要额外的空间存储 Some 或 None 的标签，此时：<ul><li>内存布局：包含一个 1 字节的标签（标识 Some 或 None）和<code>T</code> 类型的数据空间（可能包含对齐填充）。</li><li>即使为 <code>None</code>，仍需保留 <code>T</code>所需的内存空间（含填充），以保障枚举值大小统一。如<code>Option&lt;i32&gt;</code> 占用 8 字节（1 字节标签 + 4 字节 i32 + 3字节填充）。</li></ul></li><li>当 T 是<strong>不可为空的指针类型</strong>（如Box&lt;T&gt;、&amp;T、&amp;mut T）时，Rust编译器会启用<strong>空指针优化</strong>（NicheOptimization）。即利用<strong>指针不能为 0</strong> 的特性，将<code>None</code> 标识为全零位模式（0x00），而 <code>Some(ptr)</code>存储实际指针地址，此时无需额外标签。这个时候，<code>None</code> 和<code>Some(T)</code> 不占用任何的额外空间，大小与 T 相同。</li></ul><p>我们可以写个程序来简单验证一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_option</span>() &#123;</span><br><span class="line">    <span class="comment">// 1. 基本数据类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span>: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i_none</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i_some</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;基本类型：&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;i32: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;i), &amp;i); <span class="comment">// 4 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;None&lt;i32&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;i_none), &amp;i_none); <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Some&lt;i32&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;i_some), &amp;i_some); <span class="comment">// 8 bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 自定义类型</span></span><br><span class="line">    <span class="meta">#[repr(C)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">        a: <span class="type">u64</span>,</span><br><span class="line">        b: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = Data &#123; a: <span class="number">1</span>, b: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_none</span>: <span class="type">Option</span>&lt;Data&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_some</span>: <span class="type">Option</span>&lt;Data&gt; = <span class="title function_ invoke__">Some</span>(Data &#123; a: <span class="number">1</span>, b: <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n自定义结构体：&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Data: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;data), &amp;data); <span class="comment">// 16 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;None&lt;Data&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;data_none), &amp;data_none); <span class="comment">// 24 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Some&lt;Data&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;data_some), &amp;data_some); <span class="comment">// 24 bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 指针类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b_none</span>: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="type">i32</span>&gt;&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b_some</span>: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="type">i32</span>&gt;&gt; = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n指针类型：&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Box&lt;i32&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;b), &amp;b); <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;None&lt;Box&lt;i32&gt;&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;b_none), &amp;b_none); <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Some&lt;Box&lt;i32&gt;&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;b_some), &amp;b_some); <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none_value</span> = <span class="keyword">unsafe</span> &#123; *(&amp;b_none <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i64</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;None&lt;Box&lt;i32&gt;&gt; bit pattern: &#123;:#x&#125;&quot;</span>, none_value); <span class="comment">// 0x0</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">some_value</span> = <span class="keyword">unsafe</span> &#123; *(&amp;b_some <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i64</span>) &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;None&lt;Box&lt;i32&gt;&gt; bit pattern: &#123;:#x&#125;&quot;</span>, some_value); <span class="comment">// 0x15d0043c0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在笔者的电脑下，输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">基本类型：</span><br><span class="line">i32: 4 bytes, ptr: 0x16bef203c</span><br><span class="line">None&lt;i32&gt;: 8 bytes, ptr: 0x16bef2040</span><br><span class="line">Some&lt;i32&gt;: 8 bytes, ptr: 0x16bef2048</span><br><span class="line"></span><br><span class="line">自定义结构体：</span><br><span class="line">Data: 16 bytes, ptr: 0x16bef2200</span><br><span class="line">None&lt;Data&gt;: 24 bytes, ptr: 0x16bef2210</span><br><span class="line">Some&lt;Data&gt;: 24 bytes, ptr: 0x16bef2228</span><br><span class="line"></span><br><span class="line">指针类型：</span><br><span class="line">Box&lt;i32&gt;: 8 bytes, ptr: 0x16bef23f8</span><br><span class="line">None&lt;Box&lt;i32&gt;&gt;: 8 bytes, ptr: 0x16bef2400</span><br><span class="line">Some&lt;Box&lt;i32&gt;&gt;: 8 bytes, ptr: 0x16bef2408</span><br><span class="line">None&lt;Box&lt;i32&gt;&gt; bit pattern: 0x0</span><br></pre></td></tr></table></figure><p>通过输出我们可以观察到经过<strong>空指针优化</strong>，<code>Option&lt;Box&lt;i32&gt;&gt;</code>的 <code>None</code> 和 <code>Some</code> 都只占 <strong>8字节</strong>（与 <code>Box&lt;i32&gt;</code> 相同），同时通过为<code>None</code> 复用类型的无效位模式（如<code>0x0</code>）消除枚举标签，实现零成本抽象。</p><h3 id="phantomdata">2. PhantomData</h3><p>Rust 中的 <code>PhantomData</code> 是一个零大小类型（Zero-Sized Type,ZST），用于在编译期向类型系统传递额外信息，而不占用运行时内存。它在泛型编程、生命周期管理和所有权标记中扮演关键角色。</p><p>它有以下的核心特性和作用：</p><ol type="1"><li><p><strong>零内存开销</strong>：<code>PhantomData&lt;T&gt;</code>本身不存储任何数据，编译后会被优化掉，因此<strong>不会增加结构体的实际内存占用</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker::PhantomData;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>&lt;T&gt; &#123;</span><br><span class="line">    data: <span class="type">u32</span>,</span><br><span class="line">    _marker: PhantomData&lt;T&gt;, <span class="comment">// 不占空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>标记未使用的泛型参数</strong>：Rust要求泛型参数必须在结构体中被显式使用。若泛型参数未直接出现在字段中，可通过<code>PhantomData</code> 标记其存在性，避免编译错误。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Resource</span>&lt;T&gt; &#123;</span><br><span class="line">    handle: *<span class="title function_ invoke__">mut</span> (),</span><br><span class="line">    _phantom: PhantomData&lt;T&gt;, <span class="comment">// 标记类型 T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>声明生命周期依赖</strong>：当结构体包含原始指针（如<code>*const T</code>）时，<code>PhantomData</code>可绑定生命周期，确保引用的数据有效性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Slice</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    start: *<span class="keyword">const</span> T,</span><br><span class="line">    end: *<span class="keyword">const</span> T,</span><br><span class="line">    _phantom: PhantomData&lt;&amp;<span class="symbol">&#x27;a</span> T&gt;, <span class="comment">// 绑定生命周期 &#x27;a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>协变与逆变控制</strong>：通过<code>PhantomData&lt;&amp;'a T&gt;</code> 或<code>PhantomData&lt;*mut T&gt;</code>等不同形式，调整类型的协变/逆变行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker::PhantomData;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记类型为 !Send 且 !Sync</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NotThreadSafe</span> &#123;</span><br><span class="line">    _marker: PhantomData&lt;Rc&lt;()&gt;&gt;, <span class="comment">// Rc&lt;()&gt; 本身是 !Send + !Sync</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">本文从零开始，通过多版本迭代，实现一个安全的 Rust oneshot channel。我们将深入 `AtomicBool`、`UnsafeCell`、`MaybeUninit` 的使用，通过 `Drop` 管理内存，并最终以 `Sender`/`Receiver` 模式和所有权机制封装 `unsafe`，构建健壮的并发原语。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 实战" scheme="https://hedon.top/categories/rust/rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨手写一个 SpinLock</title>
    <link href="https://hedon.top/2025/05/13/rust-action-spinlock/"/>
    <id>https://hedon.top/2025/05/13/rust-action-spinlock/</id>
    <published>2025-05-13T04:58:25.000Z</published>
    <updated>2025-06-11T17:33:12.089Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><ahref="https://hedon.top/2025/06/05/rust-atomic-in-processor/">Rust原理丨从汇编角度看原子操作</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust实战丨手写一个 SpinLock</a> 👈 本篇</li><li><ahref="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust实战丨手写一个 oneshot channel</a></li><li><a href="https://hedon.top/2025/06/03/rust-action-arc/">Rust实战丨手写一个 Arc</a></li><li><a href="https://hedon.top/2025/06/08/rust-os-primitives/">Rust原理丨操作系统并发原语</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-mutex/">Rust实战丨手写一个 Mutex</a></li><li><a href="https://hedon.top/2025/06/09/rust-action-condvar/">Rust实战丨手写一个 Condvar</a></li><li><a href="https://hedon.top/2025/06/11/rust-action-rwlock/">Rust实战丨手写一个 RwLock</a></li></ul><hr /><p>在并发编程中，<strong>锁</strong>（lock）是一种常用的同步机制，用于保护共享数据避免竞态条件。然而，在许多编程语言中，锁的使用往往需要手动“加锁”和“解锁”。<strong>手动解锁</strong>的时机很难控制——如果程序在临界区出现错误而跳出了正常流程，开发者可能会忘记解锁锁，从而导致其他线程永远无法取得该锁，发生死锁。另外，还可能发生<strong>重复解锁</strong>的问题：比如线程A 解锁后，线程 B 很快加锁，这时如果线程 A的异常处理代码再次执行了解锁操作，就会把线程 B的锁过早释放，造成数据竞态。另外，大部分语言中<strong>锁和它所保护的数据缺乏关联</strong>：编译器并不知道某个数据必须在特定锁保护下访问，这样一来，程序员很容易犯“未加锁就访问数据”的错误。这些问题对于新手来说尤其常见，而且<strong>编译器无法帮助检查</strong>并发使用上的这些Bug。</p><p>为了解决上述问题，理想情况是让<strong>锁的管理和资源的生命周期绑定</strong>，由语言帮我们自动管理解锁。Rust正是通过所有权和生命周期机制，实现了资源与作用域生命周期的绑定，即典型的<strong>RAII</strong> 技术（<em>Resource Acquisition IsInitialization</em>，资源获取即初始化）。</p><p>在 Rust 标准库中，像 <code>Mutex</code>（互斥锁）就利用了RAII：获取锁会返回一个守卫对象（例如<code>MutexGuard</code>），当守卫对象被丢弃（析构）时自动解锁，从而避免显式解锁的麻烦。Rust标准库的 <code>Mutex</code>底层利用了操作系统的锁机制，在线程争用时会使线程休眠挂起，以避免浪费CPU。然而，在一些场景下，比如<strong>无操作系统环境（no_std）</strong>的内核开发、<strong>中断处理</strong>、或者<strong>临界区极短</strong>的场合，我们可能希望使用<strong>自旋锁</strong>（SpinLock）来忙等待锁，而不进入休眠。自旋锁在锁竞争短暂时能省去线程切换的开销，但如果锁被占用时间过长，会浪费大量CPU 时间，因此需要慎重使用。</p><p>接下来，我们将参考 <a href="https://marabos.nl/atomics/">Rust Atomicsand Locks</a> 一书，<strong>从零开始实现一个 Rust 版本的SpinLock</strong>。我们会按三个版本逐步引入功能和概念：</p><ol type="1"><li>首先实现基本的 <strong>v0</strong>版本（不保护具体数据，仅提供加锁/解锁机制）；</li><li>然后扩展为能够保护数据的 <strong>v1</strong> 版本；</li><li>最后加入 RAII 机制实现自动解锁的<strong>v2</strong>版本。</li></ol><p>过程中，我们会讨论相关的 Rust 并发概念，包括 <strong>Atomic</strong>原子类型、<strong>Ordering</strong>内存序、<strong>UnsafeCell</strong>、<strong>Send/Sync</strong>并发安全标记、以及 RAII 中的 <strong>Deref/Drop</strong> trait 等。</p><p>让我们一步步实现这个自旋锁吧！</p><h2 id="读完本篇你能学到什么">读完本篇你能学到什么</h2><ol type="1"><li><strong>自旋锁与互斥锁的权衡</strong>：了解自旋锁适合的场景（极短临界区、内核/中断上下文、无OS 环境），以及为何在锁竞争时间较长时应优先选择休眠式互斥锁。</li><li><strong>原子操作 + 内存顺序的实战用法</strong>：学会使用<code>AtomicBool</code>，并理解 <code>Acquire / Release</code>在加锁、解锁时建立的 <em>happens-before</em> 关系；掌握<code>swap</code> 与 <code>spin_loop</code> 的配合细节。</li><li><strong>内部可变性（UnsafeCell）</strong>：掌握如何在持有不可变引用的情况下对数据进行安全修改。</li><li><strong>RAII + <code>Drop</code>机制消除“忘记解锁”Bug</strong>：通过 <code>SpinLockGuard</code> +<code>Drop</code>，体验如何把“资源释放”交给作用域管理，彻底根除忘记/重复解锁的风险。</li><li><strong><code>Deref</code> / <code>DerefMut</code>的零成本抽象</strong>：掌握为守卫对象实现<code>Deref</code>/<code>DerefMut</code>，让使用者像操作普通引用一样操作受保护数据，而不引入额外运行时开销。</li></ol><h2 id="基础版-v0自旋锁的基本实现">基础版 v0：自旋锁的基本实现</h2><p>我们先从最基础的版本开始，我们在 <code>lock</code>的时候，如果失败了，就一直循环尝试，直到成功获取锁：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">  <span class="comment">// 原子布尔标志，表示锁是否被占用</span></span><br><span class="line">    locked: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            locked: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用原子操作尝试将 flag 变为 true，并返回之前的值：</span></span><br><span class="line">      <span class="comment">//   如果返回的是 true，则说明锁已经被其他线程抢走了。</span></span><br><span class="line">      <span class="comment">// 如果返回的是 false，则说明当前线程抢占锁成功。</span></span><br><span class="line">        <span class="comment">// 获取锁使用 Acquire 语义以确保后续对受保护数据的内存访问不会被重排到锁获取之前。</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.locked.<span class="title function_ invoke__">swap</span>(<span class="literal">true</span>, Ordering::Acquire) &#123;</span><br><span class="line">            <span class="comment">// 向处理器发出一个提示，表示当前线程正忙等待。</span></span><br><span class="line">          <span class="comment">// 这在某些架构上可以减少功耗或让处理器优化性能（比如 x86 上的 PAUSE 指令），避免无效地占用总线。</span></span><br><span class="line">            std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unlock</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 将标志置回 false，释放锁。使用 Release 语义以确保之前临界区的修改对后续获取锁的线程可见。</span></span><br><span class="line">        <span class="keyword">self</span>.locked.<span class="title function_ invoke__">store</span>(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述实现中，我们定义了结构<code>SpinLock</code>，它包含一个原子变量 <code>locked</code>。</p><p>在 <code>lock</code> 方法中，我们尝试对 <code>locked</code>原子变量进行 <code>swap</code> 为 <code>true</code>的操作，<code>swap</code> 会返回交换之前的值，如果是<code>false</code>，那就说明抢锁成功了，这个时候 <code>lock</code>就成功返回，否则，则调用 <code>std::hint::spin_loop()</code>进行自旋，在下一次 <code>while</code> 循环中再尝试获取锁。</p><p>在 <code>unlock</code> 方法中，我们只需要将 <code>locked</code>设置为 <code>false</code> 即可。</p><p>示例图如下：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250513131603680.png" /></p><p>这里有几个需要关注的点：</p><ol type="1"><li><code>std::hint::spin_loop()</code> 会向 CPU 发送特定指令（如 x86 的pause 或 ARM 的 yield），提示当前处于忙等待状态。这允许 CPU优化执行行为：<ul><li><strong>降低功耗</strong>：减少自旋期间的计算资源消耗。</li><li><strong>提升多线程效率</strong>：在超线程架构中，避免单个核心的忙等待阻塞其他线程的执行。</li></ul></li><li><code>locked</code> 是一个原子变量，对其的操作称为原子操作（AtomicOperation）。<strong>原子操作是指在多线程情况下不可被中断的操作，能保证对变量的读/写要么完整完成要么不发生，因此不存在数据竞争</strong>。在Rust 中，每个原子操作都需要指定内存顺序（MemoryOrdering）参数，用于约束编译器和 CPU对指令重排的规则。更详细的规则可参阅：<ahref="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊Rust 的 Atomic 和内存顺序</a>。</li><li>这里我们内存顺序使用了一对 <code>Acquire</code> 和<code>Release</code>。其中：<ul><li>获取锁的时候使用 <code>Acquire</code>确保后续对受保护数据的内存访问不会被重排到锁获取之前。</li><li>释放锁的时候使用 <code>Release</code>确保之前临界区内的所有修改都完成发布（对其他线程可见），再让其他线程获取锁。</li></ul></li></ol><p>我们来撰写单元测试：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = SpinLock::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = <span class="built_in">vec!</span>[]; <span class="comment">// 临界区资源</span></span><br><span class="line"></span><br><span class="line">        lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        data.<span class="title function_ invoke__">push</span>(<span class="number">1</span>); <span class="comment">// 临界区代码</span></span><br><span class="line">        lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line"></span><br><span class="line">        lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, data); <span class="comment">// 临界区代码</span></span><br><span class="line">        lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = <span class="built_in">vec!</span>[];  <span class="comment">// 临界区资源</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = SpinLock::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">                lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">                <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">data_ptr</span> = &amp;data <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;;</span><br><span class="line">                    (*data_ptr).<span class="title function_ invoke__">push</span>(<span class="number">1</span>);  <span class="comment">// 临界区代码</span></span><br><span class="line">                &#125;</span><br><span class="line">                lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">            lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">data_ptr</span> = &amp;data <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;;</span><br><span class="line">                (*data_ptr).<span class="title function_ invoke__">push</span>(<span class="number">2</span>); <span class="comment">// 临界区代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, data);  <span class="comment">// 临界区代码</span></span><br><span class="line">        lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在跨线程的测试用例 <code>cross_thread_should_work</code> 中，为了对<code>data</code> 进行修改，我们只能在 <code>unsafe</code>里面强行使用裸指针来进行操作，否则编译就会失败。</p><h2 id="升级版-v1将锁与数据关联">升级版 v1：将锁与数据关联</h2><p>在上一个基础版本中，虽然这么做能起到互斥的作用，但是存在 2个问题：</p><ol type="1"><li>我们会发现操作临界资源非常麻烦，因为临界资源的类型，可能是不满足<code>Sync</code> 和 <code>Send</code>的，所以它们无法在跨线程中进行传递或转移，所以即便我们能从逻辑上断定它们是并发安全的，但是编译器可没那么聪明，所以我们只能通过<code>unsafe</code> 强行绕过编译期的检查。</li><li>锁和被保护的数据是分离的。程序员必须小心确保每次访问共享数据都正确地调用了<code>lock()</code> 和 <code>unlock()</code>。一旦忘记调用<code>unlock()</code>，或者搞错了加锁解锁的配对关系，编译器都不会报错，但程序的并发行为就可能出问题。</li></ol><p>显然，我们希望让<strong>锁与数据关联</strong>起来，从语法层面降低误用的可能，同时便于我们为临界资源的数据类型限定相关的trait，提高资源访问的便捷性。这正是下一步要做的改进。</p><p>我们看看标准库的 <code>Mutex</code> 是怎么实现的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> LockResult&lt;MutexGuard&lt;<span class="symbol">&#x27;_</span>, T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.inner.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        MutexGuard::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;a</span>, T: ?<span class="built_in">Sized</span> + <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    lock: &amp;<span class="symbol">&#x27;a</span> Mutex&lt;T&gt;,</span><br><span class="line">    poison: poison::Guard,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，标准的锁是将要保护的临界资源放在了锁里，在获取锁的时候，就返回这个临界资源的<code>Guard</code>。</p><p>OK，我们先不着急引入这个<code>Guard</code>，我们就直接在获取锁的时候返回临界资源的可变引用即可。</p><p>更新后的版本如下所示；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpinLock</span>&lt;T&gt; &#123;</span><br><span class="line">    locked: AtomicBool,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; SpinLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            locked: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">            value: UnsafeCell::<span class="title function_ invoke__">new</span>(value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> T &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.locked.<span class="title function_ invoke__">swap</span>(<span class="literal">true</span>, Ordering::Acquire) &#123;</span><br><span class="line">            std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// Safety: 我们知道这个时候同时只可能有一个线程能获取到 value，</span></span><br><span class="line">      <span class="comment">// 也知道这个 value 一定存在，所以可以直接 unwrap()。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.value.<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unlock</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.locked.<span class="title function_ invoke__">store</span>(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">SpinLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">SpinLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在 <code>SpinLock</code> 中加入了类型为<code>UnsafeCell&lt;T&gt;</code> 的字段 <code>value</code>，然后在<code>lock()</code> 抢到锁的时候，通过<code>self.value.get().as_mut().unwrap()</code> 获取 <code>value</code>的可变引用，我们知道这里是安全的，所以 <code>unsafe</code>是安全的。</p><p>在这个版本中，我们见到了一个新朋友<code>UnsafeCell</code>，事实上它是 Rust标准库中所有的并发工具的基石，它涉及到了一个概念：<strong>内部可变性</strong>。</p><p>在 Rust的类型系统中，如果我们只有一个对锁的不可变引用（<code>&amp;SpinLock&lt;T&gt;</code>），按正常规则是无法直接获得对内部数据的可变引用（<code>&amp;mut T</code>）的——<strong>毕竟Rust不允许在仅持有不可变引用的情况下修改数据</strong>。但对于实现锁这种特殊结构，我们清楚只有获取锁后才会独占数据的访问权，此时产生一个可变引用是安全的。为了突破编译器的限制，我们需要借助<code>std::cell::UnsafeCell</code>。</p><p><strong>UnsafeCell</strong> 是 Rust提供的一个内部可变性工具类型，它包装一个数据，使得即使在只有不可变引用的情况下也可以进行修改（当然需要在<code>unsafe</code> 块中操作）。很多线程同步原语（比如<code>Mutex</code>、<code>AtomicBool</code> 自身等）内部都用<code>UnsafeCell</code> 来允许内部数据的可变访问。</p><p>标准库中，基于<code>UnsafeCell&lt;T</code>&gt;，封装了一些满足<strong>内部可变性</strong>的类型：</p><ul><li><p><code>Cell&lt;T&gt;</code>: 只允许 Copy 类型，通过 get()/set()操作。</p></li><li><p><code>RefCell&lt;T&gt;</code>: 运行时借用检查，但不是Sync。</p></li><li><p><code>Mutex&lt;T&gt;</code>: 线程安全，但性能开销大。</p></li></ul><p>同时也因为 <code>UnsafeCell&lt;T</code>&gt; 并不满足<code>Send</code> 和 <code>Sync</code>trait，所以我们需要手动为其实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">SpinLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">SpinLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们修改我们的测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = SpinLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]); <span class="comment">// 临界资源包在锁里面了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        data.<span class="title function_ invoke__">push</span>(<span class="number">1</span>); <span class="comment">// 临界区代码</span></span><br><span class="line">        lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, data); <span class="comment">// 临界区代码</span></span><br><span class="line">        lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = SpinLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]); <span class="comment">// 临界资源包在锁里面了</span></span><br><span class="line">        thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">data1</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">                data1.<span class="title function_ invoke__">push</span>(<span class="number">1</span>); <span class="comment">// 临界区代码</span></span><br><span class="line">                lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">data2</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">            data2.<span class="title function_ invoke__">push</span>(<span class="number">2</span>); <span class="comment">// 临界区代码</span></span><br><span class="line">            lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, data); <span class="comment">// 临界区代码</span></span><br><span class="line">        lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的测试用例中，对于使用者来说，很明显就简洁很多了，再也不需要使用<code>unsafe</code> 这种危险工具了。</p><h2 id="最终版-v2引入-raii-的自旋锁守卫">最终版 v2：引入 RAII的自旋锁守卫</h2><p>v1的实现仍然存在隐患，它要求调用者严格按照正确的顺序使用。我们可以想象一些误用场景：</p><ul><li><strong>忘记解锁：</strong> 如果线程获得了锁却没有调用<code>unlock()</code>就结束了，那么锁将一直保持锁定状态，导致其他线程永远自旋等待，无法前进。</li><li><strong>重复解锁：</strong> 如果调用者不小心对同一个锁调用了两次<code>unlock()</code>，第二次解锁会将另一个线程持有的锁误释放，造成数据同时被两个线程访问的风险。</li><li><strong>未加锁访问：</strong> 由于我们提供了 <code>lock()</code>返回 <code>&amp;mut T</code>的接口，调用者理论上可以持有这个引用不放，然后调用 <code>unlock()</code>解锁。这样一来，就出现了一个悬空引用——锁已经释放但仍持有先前的<code>&amp;mut T</code>，如果此时另一线程加锁并修改数据，两个线程将同时持有对同一数据的可变引用，发生数据竞争！换言之，v1的接口并不能防止调用者违反“先锁后用、用完解锁”的约定，Rust编译器也无法帮我们检查这种逻辑错误。</li></ul><p>综上，v1尽管把数据和锁绑定在一起，但<strong>正确使用仍然完全依赖程序员自觉</strong>，稍有不慎就可能出错。这显然不符合Rust一贯的“编译期保证安全”的理念。有没有办法在<strong>编译阶段</strong>就防止上述误用呢？这就是我们下一步要做的：引入<strong>RAII</strong> 机制，用 Rust 的所有权来管理锁的获取和释放。</p><blockquote><p>RAII（Resource Acquisition Is Initialization，资源获取即初始化）是C++/Rust中的核心编程范式，通过将资源的生命周期与对象的生命周期绑定，实现资源的自动管理。其核心思想是：<strong>在对象构造函数中获取资源，在析构函数中释放资源</strong>，确保资源在任何情况下（包括异常）都能被正确释放。</p></blockquote><p>这个时候，<code>Guard</code> 就可以登场了，我们可以参考标准库一样，在<code>lock</code> 的时候返回一个 <code>Guard</code>，当这个<code>Guard</code> 离开作用域的时候，它的 <code>drop</code>就会被调用，我们可以在里面，执行 <code>unlock</code> 操作，这有 2个好处：</p><ol type="1"><li><code>drop(guard)</code>是要消耗所有权的，所以可以避免重复释放锁；</li><li><code>drop(guard)</code>在变量离开作用域后会被自动调用，所以可以避免忘记释放锁的情况发生。</li></ol><p>更新后的版本如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpinLock</span>&lt;T&gt; &#123;</span><br><span class="line">    locked: AtomicBool,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpinLockGuard</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    lock: &amp;<span class="symbol">&#x27;a</span> SpinLock&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">SpinLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">SpinLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; SpinLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            locked: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">            value: UnsafeCell::<span class="title function_ invoke__">new</span>(value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> SpinLockGuard&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.locked.<span class="title function_ invoke__">swap</span>(<span class="literal">true</span>, Ordering::Acquire) &#123;</span><br><span class="line">            std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        SpinLockGuard::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; SpinLockGuard&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(lock: &amp;<span class="symbol">&#x27;a</span> SpinLock&lt;T&gt;) <span class="punctuation">-&gt;</span> SpinLockGuard&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; lock &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">SpinLockGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="comment">// 释放锁。</span></span><br><span class="line">        <span class="keyword">self</span>.lock.locked.<span class="title function_ invoke__">store</span>(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">SpinLockGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="comment">// Safety: 这里我们已经拿到锁（SpinLockGuard）了，</span></span><br><span class="line">        <span class="comment">// 所以可以确保数据的存在且独占的。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*<span class="keyword">self</span>.lock.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> <span class="title class_">SpinLockGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="comment">// Safety: 这里我们已经拿到锁（SpinLockGuard）了，</span></span><br><span class="line">        <span class="comment">// 所以可以确保数据的存在且独占的。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.lock.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>我们引入了类型 <code>SpinLockGuard</code>，它包含了一个<code>SpinLock</code> 的引用，所以我们需要用生命周期 <code>'a</code>进行标注。</li><li><code>SpinLock</code> 在 <code>lock()</code> 成功时，返回一个<code>SpinLockGuard</code>。</li><li>我们为 <code>SpinLockGuard</code> 实现 <code>drop</code>trait，让其在被 drop 时自动执行<code>unlock</code>，这样就实现了离开作用域自动 unlock 的功能。</li><li>同时为了操作数据的简单性，我们为 <code>SpinLockGuard</code> 实现了<code>Deref</code> 和 <code>DerefMut</code> 这 2 个 trait。</li></ol><p>修改一下我们的测试代码，可以发现更加简洁了，同时有编译器的保护，我们想犯错都难了！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = SpinLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);  <span class="comment">// 临界资源包在锁里面了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        data.<span class="title function_ invoke__">push</span>(<span class="number">1</span>); <span class="comment">// 临界代码区</span></span><br><span class="line">        <span class="title function_ invoke__">drop</span>(data); <span class="comment">// 主动调用 drop 释放锁。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *data);</span><br><span class="line">      <span class="comment">// 离开作用域后，这里编译器会自动调用 drop(data) 释放锁。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = SpinLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);  <span class="comment">// 临界资源包在锁里面了</span></span><br><span class="line">        thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data1</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">                data1.<span class="title function_ invoke__">push</span>(<span class="number">1</span>); <span class="comment">// 临界代码区</span></span><br><span class="line">              <span class="comment">// data1 离开作用域，自动调用 drop(data1)，释放锁。</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data2</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">            data2.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>总结一下，在本实战篇中，我们从最初简单的原子标志锁出发，逐步演进，最终实现了一个拥有RAII 机制的自旋锁<code>SpinLock</code>。让我们回顾一下这个自旋锁的特点：</p><ul><li><strong>忙等待实现：</strong>使用原子变量和循环实现锁的争用等待，而不涉及线程休眠。这样做在临界区很短时可以省去线程切换的开销，但如果锁持有时间较长，会浪费大量CPU时间。因此，本实现适合在<strong>短临界区</strong>或者<strong>无操作系统</strong>环境（如内核/中断上下文）使用。</li><li><strong>RAII 保证解锁：</strong> 通过引入 <code>SpinLockGuard</code>守卫并实现<code>Drop</code>，我们将解锁操作自动化。开发者无须显式调用解锁函数，避免了因遗忘或异常路径导致的死锁。同时也防止了双重解锁的发生——同一把锁只有一个守卫，Rust不允许守卫被意外复制或重复释放。</li><li><strong>锁与数据绑定：</strong>自旋锁内部直接持有被保护的数据，并通过类型系统将两者关联。任何对数据的访问都必须经由自旋锁提供的方法，这使“未加锁就访问数据”在语法上变得不可能（否则无法拿到数据的引用）。</li><li><strong>编译期并发检查：</strong> 利用 Rust的所有权和借用规则，我们实现了<strong>一定程度的编译期并发安全检查</strong>。只要代码编译通过，就已经避免了绝大多数常见并发错误（数据竞争、未解锁等）。当然，这不意味着可以高枕无忧，我们仍需注意避免死锁等逻辑问题，但Rust 会提供最大程度的帮助。</li></ul><p>同时，我们更进一步地理解原子变量和内存顺序的应用，也结识了一个新的朋友<code>UnsafeCell</code>，它是 Rust中同步原语的基础，后面我们还会经常见到。</p><p>下篇我们将尝试实现一个非常实用的工具：<code>oneshot-channel</code>（一次性通道），敬请期待！</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">本文以三段迭代示例演示如何在 Rust 中手写自旋锁：从最小化原子标志实现，到绑定受保护数据，再到借助 RAII 实现自动解锁。过程中深入讲解 Atomic 内存顺序、UnsafeCell 内部可变性、Send/Sync 并发标记，以及 Drop/Deref 零成本抽象，帮助读者理解自旋锁适用场景与潜在陷阱，并掌握将并发安全问题前移到编译期的工程思维。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="rust 实战" scheme="https://hedon.top/categories/rust/rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>RAG 技术概览</title>
    <link href="https://hedon.top/2025/04/13/ai-rag-tech-overview/"/>
    <id>https://hedon.top/2025/04/13/ai-rag-tech-overview/</id>
    <published>2025-04-13T14:23:22.000Z</published>
    <updated>2025-06-05T00:39:21.819Z</updated>
    
    <content type="html"><![CDATA[<p>RAG的整个流程可概括为如下图所示，主要分成<strong>索引</strong>、<strong>检索</strong>和<strong>生成</strong>三个部分。</p><p>本文提供配套的完整案例，源码可参考：<ahref="https://github.com/hedon-ai-road/rag-demo">hedon-ai-road/rag-demo</a>，每个commit 都引入了一个新的技术点，感兴趣的读者可根据 commit记录一一查探。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250413223908403.png" /></p><h2 id="文档解析技术">文档解析技术</h2><blockquote><p><ahref="https://github.com/hedon-ai-road/rag-demo/commit/26d52ac964ca099e1726fccb5f4c18adc0fd940f#diff-b10564ab7d2c520cdd0243874879fb0a782862c3c902ab535faabe57d5a505e1">代码示例</a></p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/c60419a3c73f3090651a4c2761e05583.png" /></p><h3 id="pdf">PDF</h3><ul><li>基于规则的开源库<ul><li>pyPDF2</li><li>PyMuPDF</li><li>pdfminer</li><li>pdfplumber</li><li>papermage</li></ul></li><li>基于深度学习的开源库<ul><li>Layout-parser</li><li>PP-StructureV2</li><li>PDF-Extract-Kit</li><li>pix2text</li><li>MinerU</li><li>marker</li><li>Gptpdf（基于 LLM API）</li></ul></li><li>商业闭源库<ul><li>Textln.com</li><li>Doc2x</li><li>mathpix</li><li>庖丁 PDFlux</li><li>腾讯云文档识别</li></ul></li></ul><h2 id="分块策略">分块策略</h2><blockquote><p><ahref="https://github.com/hedon-ai-road/rag-demo/commit/a26ae8895da7a9673660b31904857307a149c983">代码示例</a></p><p><a href="https://chunkviz.up.railway.app/">分块演示工具</a></p></blockquote><p>3 个关键部分组成：</p><ul><li>大小</li><li>重叠</li><li>拆分</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/63b052c1b1639bfa66c23342cf28d9ef.jpg" style="zoom: 33%;" /></p><h3 id="固定大小分块fixed-size-chunking">固定大小分块（Fixed SizeChunking）</h3><p>适用场景：</p><ol type="1"><li>作为分块策略的基准线；</li><li>对大型数据集进行初步分析；</li><li>实现简单且可观测性高，分块便于管理；</li><li>适用于格式和大小相似的同质数据集，如新闻文章或博客文章。</li></ol><p>问题：</p><ol type="1"><li>不考虑内容上下文，容易导致无意义的文本块；</li><li>缺乏灵活性，无法适应文本的自然结构</li></ol><h3 id="重叠分块overlap-chunking">重叠分块（Overlap Chunking）</h3><p>使用场景：</p><ol type="1"><li>需要深入理解语义并保持上下文完整性的文档，如法律文档、技术手册或科研论文；</li><li>提升分块内容的连贯性，以提高分析质量。</li></ol><p>问题：</p><ol type="1"><li>计算复杂度增加，处理效率降低；</li><li>冗余信息的存储和管理成为负担。</li></ol><h3 id="递归分块recursive-chunking">递归分块（Recursive Chunking）</h3><ul><li>通过预定义的文本分隔符（如换行符、、句号、逗号、感叹号、空格等）迭代地将文本分解为更小的块，以实现段大小的均匀性和语义完整性。</li><li>先按较大的逻辑单元分割，再逐步递归到较小单元，确保在分块大小限制内保留最强的语义片段。</li></ul><p>使用场景：</p><ol type="1"><li>需要逐层分析的文本文档或需要分解成长片段、长段落的长文档，如研究报告、法律文档等。</li></ol><p>问题：</p><ol type="1"><li>在块边界处模糊语义，容易将完整的语义单元切分开。</li></ol><h3 id="文档特定分块document-specific-chunking">文档特定分块（DocumentSpecific Chunking）</h3><ul><li>根据文档的格式（如 Markdown、Latex、或编程语言如 Python等）进行定制化分割的技术。此方法依据文档的特定格式和结构规则，例如Markdown 的标题、列表项，或 Python代码中的函数和类定义等，来确定分块边界。</li></ul><p>适用场景：</p><ol type="1"><li>有特定的文档结构，如编程语言、Markdown、Latex 等结构文档。</li></ol><p>问题：</p><ol type="1"><li>格式依赖性强，不同格式之间的分块策略不通用；</li><li>无法处理格式不规范及混合多种格式的情况。</li></ol><h3 id="语义分块semantic-chunking">语义分块（Semantic Chunking）</h3><ul><li>基于文本的自然语言边界（如句子、段落或主题中断）进行分段的技术，需要使用NLP技术根据语义分词分句，旨在确保每个分块都包含语义连贯的信息单元。</li></ul><p>适用场景：</p><ol type="1"><li>确保每个文档块的信息完整性且语义连贯；</li><li>提高检索结果的相关性和准确性；</li><li>适用于复杂文档和上下文敏感的精细化分析。</li></ol><p>问题：</p><ol type="1"><li>需要额外的高计算资源，特别是在处理大型或动态变化的文档数据时；</li><li>处理效率降低。</li></ol><h3 id="混合分块mix-chunking">混合分块（Mix Chunking）</h3><ul><li>在初始阶段使用固定长度分块快速整理大量文档，而在后续阶段使用语义分块进行更精细的分类和主题提取。根据实际业务场景，设计多种分块策略的混合，能够灵活适应各种需求，提供更强大的分块方案。</li></ul><p>适用场景：</p><ol type="1"><li>适用于多层次的精细化分块场景；</li><li>数据集动态变化，包含多种文档格式与结构；</li><li>平衡处理速度与准确性的场景。</li></ol><p>问题：</p><ol type="1"><li>实现复杂度高；</li><li>策略调优难度高；</li><li>资源消耗增加。</li></ol><h2 id="embedding-技术">Embedding 技术</h2><ul><li>Embedding嵌入是指将文本、图像、音频、视频等形式的信息映射为高维空间中的密集向量表示。这些向量在语义空间中起到坐标的作用，捕捉对象之间的语义关系和隐含的意义。通过在向量空间中进行计算（例如余弦相似度），可以量化和衡量这些对象之间的语义相似性。</li><li>向量检索（VectorRetrieval）是一种基于向量表示的搜索技术，通过计算查询向量与已知文本向量的相似度来识别最相关的文本数据。向量检索的高效性在于，它能在大规模数据集中快速、准确地找到与查询最相关的内容，这得益于向量表示中蕴含的丰富语义信息。</li></ul><p>评估指标：（MTEB、C-MTEB）</p><ol type="1"><li>特定领域的适用性</li><li>检索精度</li><li>支持的语言</li><li>文本块长度</li><li>模型大小</li><li>检索效率</li></ol><h2 id="向量数据库">向量数据库</h2><blockquote><p><ahref="https://github.com/hedon-ai-road/rag-demo/commit/1f9c07ec6b10d6bfdb55c17c2c6a7ad461b00ab2">代码示例</a></p></blockquote><ul><li>向量数据库是一种专门用于存储和检索多维向量的数据库类型，与传统的基于行列结构的数据库不同，它主要处理高维空间中的数据点。</li><li>向量数据库的操作逻辑是基于相似性搜索，即在查询时，应用特定的相似性度量（如余弦相似度、欧几里得距离等）来查找与查询向量最相似的向量。</li></ul><p>向量数据库的核心在于其高效的索引和搜索机制。为了优化查询性能，它采用了如哈希、量化和基于图形的多种算法。</p><ul><li>层次化可导航小世界（<strong>HNSW</strong>）：通过在多层结构中将相似向量连接在一起，快速缩小搜索范围。</li><li>产品量化（<strong>PQ</strong>）：通过压缩高维向量，减少内存占用并加速检索。</li><li>位置敏感哈希（<strong>LSH</strong>）：通过哈希函数将相似向量聚集在一起，便于快速定位。</li></ul><p>向量数据库的工作流程：</p><ol type="1"><li>数据处理与向量化</li><li>向量存储</li><li>向量索引</li><li>向量搜索<ul><li>余弦相似度：主要用于文本处理和信息检索，关注向量之间的角度，以捕捉语义相似性。</li><li>欧几里得距离：测量向量之间的实际距离，适用于密集特征集的聚类或分类。</li><li>曼哈顿距离：通过计算笛卡尔坐标中的绝对差值之和，适用于稀疏数据的处理。</li></ul></li><li>数据检索</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/c27b4yy6748a414dae0c679835a1eccc.jpg" /></p><h2 id="混合检索">混合检索</h2><blockquote><p><ahref="https://github.com/hedon-ai-road/rag-demo/commit/38f1739c7ac1d3fc58023cb12bf863d3f502c419">代码示例</a></p></blockquote><ul><li>混合检索（HybridSearch）通过结合关键词检索和语义匹配的优势，可以首先利用关键词检索精确定位到“订单12345”的信息，然后通过语义匹配扩展与该订单相关的其他上下文或客户操作的信息，例如“12开头的订单、包装破损严重”等。这样不仅能够获取精确的订单详情，还能获得与之相关的额外有用信息。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/7eddf214ee696b2e1f5977d72a4db134.jpg" /></p><h2 id="重排序技术">重排序技术</h2><blockquote><p><ahref="https://github.com/hedon-ai-road/rag-demo/commit/4837ef3220d177297169f28fbff5f52eaaee720e">代码示例</a></p></blockquote><ul><li>重排序技术（Reranking）通过对初始检索结果进行重新排序，改善检索结果的相关性，为生成模型提供更优质的上下文，从而提升整体RAG 系统的效果。</li><li>重排序模型大多是基于<strong>双塔</strong>或<strong>交叉编码架构</strong>的模型，在此基础上进一步计算更精确的相关性分数，能够捕捉查询词与文档块之间更细致的相关性，从而在细节层面上提高检索精度。</li></ul><h2 id="提示工程">提示工程</h2><p>一个提示（prompt）通常包含以下几个元素：</p><ol type="1"><li><strong>指令（Instruction）</strong>：指明模型要执行的特定任务或操作。</li><li><strong>上下文（Context）</strong>：为模型提供额外信息或背景，可以帮助引导模型生成更准确的响应。</li><li><strong>输入数据（InputData）</strong>：我们希望模型回答的问题或感兴趣的输入内容。</li><li><strong>输出指示符（OutputIndicator）</strong>：指定模型的输出类型或格式，例如格式、是否要生成代码、总结文本或回答具体问题。</li></ol><p>核心技巧：</p><ul><li><strong>具体指令法</strong>：具体、细致地告诉大模型要做什么。</li><li><strong>示例学习</strong>：给出具体详尽的期望示例。</li><li><strong>默认回复策略</strong>：设定默认回复策略，避免模型产生“幻觉”，让它不知道就说不知道。</li><li><strong>任务角色设定</strong>：设定身份，可以帮助模型更好地理解任务要求和角色责任，从而输出更加一致、专业的内容。</li><li><strong>解释理由法</strong>：向模型解释为什么某些任务需要特定的处理方式，帮助其理解任务背景。</li><li><strong>文档基础说明</strong>：提供文档的背景信息和文本来源。</li></ul><h2 id="优化技术">优化技术</h2><h3 id="数据清洗和预处理">数据清洗和预处理</h3><blockquote><p>在 RAG索引流程中，文档解析之后、文本块切分之前，进行数据清洗和预处理能够有效减少脏数据和噪声，提升文本的整体质量和信息密度。</p><p>通过清除冗余信息、统一格式、处理异常字符等手段，数据清洗和预处理过程确保文档更加规范和高质量，从而提高RAG 系统的检索效果和信息准确性。</p></blockquote><ul><li>处理冗余的模型内容。</li><li>消除文档中的额外空白和格式不一致。</li><li>去除无用的文档脚注、页眉页脚、版权信息。</li></ul><h3 id="查询扩展">查询扩展</h3><blockquote><p>查询扩展策略通过大模型从原始查询语句生成多个语义相关的查询，可以覆盖向量空间中的不同区域，从而提高检索的全面性和准确性。</p></blockquote><p>查询扩展的指令模版：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你是一个AI语言模型助手。</span><br><span class="line">你的任务是生成五个不同版本的用户问题，以便从向量数据库中检索相关文档。</span><br><span class="line">通过从多个角度生成用户问题，你的目标是帮助用户克服基于距离的相似性搜索的一些局限性。</span><br><span class="line">请将这些替代问题用换行符分隔。原始问题：&#123;查询原文&#125;</span><br></pre></td></tr></table></figure><p>假设问题：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面报告中涉及了哪几个行业的案例以及总结各自面临的挑战？</span><br></pre></td></tr></table></figure><p>结果示例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请问报告中提到的案例涉及了哪些行业？这些行业各自面临的挑战有哪些？</span><br><span class="line">报告中有哪些行业的案例被讨论？每个行业在报告中描述的挑战是什么？</span><br><span class="line">这个报告中具体提到了哪些行业的案例？能否总结一下这些行业当前面临的主要挑战？</span><br><span class="line">该报告中涵盖了哪些行业案例，并对各行业的挑战进行了哪些讨论？</span><br><span class="line">在报告中提到的行业案例有哪些？这些行业分别遇到的主要问题和挑战是什么？</span><br></pre></td></tr></table></figure><p>通过这种查询扩展策略，原始问题被分解为多个子查询，每个子查询独立检索相关文档并生成相应的结果。随后，系统将所有子查询的检索结果进行合并和重新排序，效果会更全面更准确。</p><h3 id="自查询">自查询</h3><blockquote><p>自查询策略通过大语言模型自动提取查询中对业务场景至关重要的元数据字段（如标签、作者ID、评论数量等关键信息），并将这些信息结合到嵌入检索过程中。</p></blockquote><p>自查询的指令模版：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你是一个AI语言模型助手。</span><br><span class="line">你的任务是从用户问题中提取关键信息，你的回复应仅包含提取的关键信息。</span><br><span class="line">用户问题：&#123;查询原文&#125;</span><br></pre></td></tr></table></figure><p>假设问题：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面报告中涉及了哪几个行业的案例以及总结各自面临的挑战？</span><br></pre></td></tr></table></figure><p>结果示例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行业，案例，挑战</span><br></pre></td></tr></table></figure><h3 id="提示压缩">提示压缩</h3><blockquote><p>提示压缩通过精简上下文、过滤掉不相关的信息，确保系统只处理与查询最相关、最重要的内容。</p></blockquote><p>提示压缩的指令模版：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">你是一个AI语言模型助手，负责对检索到的文档进行上下文压缩。</span><br><span class="line">你的目标是从文档中提取与用户查询高度相关的段落，并删除与查询无关或噪声较大的部分。</span><br><span class="line">你应确保保留所有能够直接回答用户查询的问题核心信息。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">用户查询：&#123;用户的原始查询&#125;</span><br><span class="line">检索到的文档：&#123;检索到的文档内容&#125;</span><br><span class="line"></span><br><span class="line">输出要求：</span><br><span class="line">提取与用户查询最相关的段落和信息。</span><br><span class="line">删除所有与查询无关的内容，包括噪声、背景信息或扩展讨论。</span><br><span class="line">压缩后的内容应简洁清晰，直指用户的核心问题。</span><br><span class="line"></span><br><span class="line">输出格式：</span><br><span class="line">&#123;压缩段落1&#125;</span><br><span class="line">&#123;压缩段落2&#125;</span><br><span class="line">&#123;压缩段落3&#125;</span><br></pre></td></tr></table></figure><h2 id="rag-效果评估">RAG 效果评估</h2><ol type="1"><li>大模型打分：通过 LLM 对 RAG的输出进行自动评分。效率高，但是准确性一般。</li><li>人工打分：手工针对 RAG的输出进行逐一打分。更精确、细致的反馈，成本高。</li></ol><p>评估指标：</p><ol type="1"><li><strong>CR（ContextRelevancy）</strong>检索相关性：检索到的信息是否偏离了原始查询。</li><li><strong>AR（AnswerRelevancy）</strong>答案相关性：是否能解决用户的问题，且内容是否逻辑连贯。</li><li><strong>F（Faithfulness）</strong>可信度：是否存在幻觉或不准确之处。</li></ol><p>打分标准：</p><ol type="1"><li>完美（Perfect）1.0 分</li><li>可接受（Acceptable）0.75 分</li><li>缺失（Missing）0.5 分</li><li>错误（Incorrect）0.25 分</li></ol><h2 id="更高级的-rag">更高级的 RAG</h2><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/7c3ebbe6ec9d9f2886881d7e534396a0.jpg" /></p><h2 id="graphrag">GraphRAG</h2><p>GraphRAG通过构建知识图谱，将实体和实体之间的关系结构化地表示出来，克服了传统 RAG的复杂推理局限性。</p><p>有以下优势：</p><ol type="1"><li>提高答案的准确性和完整性</li><li>提高数据理解和迭代效率</li><li>提升可解释性和可追溯性</li></ol><p>知识图谱的构建步骤：</p><ol type="1"><li><strong>实体识别</strong>：从文本或数据源中识别出关键实体。</li><li><strong>关系抽取</strong>：确定实体之间的关系，可能通过自然语言处理技术实现。</li><li><strong>三元组生成</strong>：将实体和关系表示为 (主体，关系，客体)的形式。</li><li><strong>图谱存储</strong>：使用图数据库或专门的存储系统保存知识图谱。</li></ol><p>知识图谱的主要<strong>成本</strong>挑战：</p><ol type="1"><li>数据收集与清洗成本</li><li>知识图谱构建成本</li><li>图谱的维护与更新</li></ol>]]></content>
    
    
    <summary type="html">本文是在笔者学习了极客时间《RAG 快速开发实战》课程后，对 RAG 相关技术进行一个梳理归纳，帮助开发者在 RAG 开发中进行快速定位、系统学习。</summary>
    
    
    
    <category term="ai" scheme="https://hedon.top/categories/ai/"/>
    
    <category term="rag" scheme="https://hedon.top/categories/ai/rag/"/>
    
    
    <category term="ai" scheme="https://hedon.top/tags/ai/"/>
    
    <category term="rag" scheme="https://hedon.top/tags/rag/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《Unit Testing Principles, Practices, and Patterns》</title>
    <link href="https://hedon.top/2025/04/09/note-unit-testing/"/>
    <id>https://hedon.top/2025/04/09/note-unit-testing/</id>
    <published>2025-04-09T05:19:20.000Z</published>
    <updated>2025-04-15T16:25:59.245Z</updated>
    
    <content type="html"><![CDATA[<p>本篇在上一篇的基础上，梳理下笔者的个人见解，感兴趣的读者可参考原文对比阅读：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://hedon.top/2025/04/09/note-unit-testing-excerpt/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://hedon.top/2025/04/09/note-unit-testing-excerpt/" autofill="title,icon"><div class="left"><span class="title">https://hedon.top/2025/04/09/note-unit-testing-excerpt/</span><span class="cap link footnote">https://hedon.top/2025/04/09/note-unit-testing-excerpt/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><div class="tag-plugin quot"><h2 class="content" id="揪心疑惑" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">揪心疑惑</span><span class="empty"></span></h2></div><p>在撰写单元测试的过程中，你是否曾经被以下问题困扰过？</p><ol type="1"><li>为什么要写单元测试？单元测试的目标是什么？</li><li>单元测试的粒度是怎样的？什么叫单元？a class, a function, or abehavior, or an observable behavior?</li><li>单测覆盖率真的有用吗？有什么用？又有哪些限制？</li><li>怎样才能写好单元测试？怎样才能写出性价比最高的单元测试？</li><li>如何判断一个单元测试的好坏？有没有具体可供参阅的维度？</li><li>哪些代码需要写单元测试，哪些代码没必要写单元测试？</li><li>单元测试和集成测试的边界是什么？</li><li>（单元丨集成）测试到底是要测什么东西？</li><li>单元测试的侧重点是什么？集成测试的侧重点是什么？二者的比例该是怎样的？</li><li>如何使用 Mock？哪些东西是需要 Mock 的？哪些东西是不应该 Mock的？需要 Mock 的东西，应该在哪个层次进行 Mock？（你的 repository 层需要Mock 吗？）</li><li>为什么你的测试代码很脆弱，总是需要频繁修改，维护起来难度很大？</li><li>如何减少测试结果的假阳性和假阴性？</li></ol><div class="tag-plugin quot"><h2 class="content" id="四根柱子" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">四根柱子</span><span class="empty"></span></h2></div><p>对于第 5 个问题，作者提出了 4 个维度：</p><ul><li><strong>Protection againstregressions：防止回归</strong>，通过自动化验证代码修改后原有功能不受破坏。<ul><li><em>The amount of code that is executed during the test.</em></li><li><em>The complexity of that code.</em></li><li><em>The code’s domain significance.</em></li></ul></li><li><strong>Resistance torefactoring：抗重构性</strong>，重构业务代码时，测试代码无需过多变动便可通过用例，证明重构无误。<ul><li><em>Tests provide an early warning when you break existingfunctionality</em>.</li><li><em>You become confident that your code changes won’t lead toregressions</em>.</li></ul></li><li><strong>Fast feedback：快速反馈</strong>。</li><li><strong>Maintainability：可维护性</strong>。<ul><li><em>How hard it is to understand the test.</em></li><li><em>How hard it is to run the test.</em></li></ul></li></ul><p>对于这 4 个问题，你是否又有以下疑问：</p><ol type="1"><li>哪个维度是最重要的？</li><li>怎样才能写出满足各个维度的测试代码？</li><li>如果维度之间存在矛盾，如何 trade off？</li></ol><h2 id="为什么要写单元测试">为什么要写单元测试？</h2><p>三个最重要的原因：</p><ol type="1"><li><p>验证你的程序逻辑正确性。</p></li><li><p>带来更好的代码设计。</p><p>因为单元测试能够让你站在使用者的角度去使用暴露的接口，如果接口不好用，逻辑不好测，测试条件不好构建，大概率说明代码的设计本身是有缺陷的，包括但不限于：抽象不合理、逻辑划分不清晰、与其他模块耦合严重等。</p></li><li><p>使软件项目更可持续发展。</p><p>如果你的需求没有发生变化，那原本能运行通过的单测应该一直都能运行，这有助于避免在团队协作中不小心改坏你不知道的代码，也有助于你执行各种重构措施。</p></li></ol><p>这三个原因的重要性是显而易见的，但笔者个人觉得还有一个更深层次的最重要的原因：</p><ul><li>你要对你做的事情负责，好的代码一定要先过自己这关。</li></ul><h2 id="单元测试的粒度是什么">单元测试的粒度是什么？</h2><p>这是一个很有争议的话题，单元测试的「单元」到底是什么？</p><ul><li>一个类？</li><li>一个函数？</li><li>还是多个类组成的一个模块？</li><li>还是多个函数组成的一个大逻辑？</li></ul><p>在《Unit Testing》书中，作者指出：<strong>「单元」指的是 anobservable behavior，即一个外部系统可观测到的行为</strong>。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2010.png" /></p><p>为什么是可观测行为：</p><ol type="1"><li>一个帮助客户端实现目标的操作（operation）。</li><li>一个帮助客户端实现目标的状态（state）。</li></ol><p>换言之，也就是我在撰写单元测试的时候，我就是在使用系统提供的能力，我就是个使用者，我只要验证你能提供我要的功能，就 OK了，你背后怎么做，为了这个功能所拆分的类也好，小的辅助函数也好，都不重要，都不属于我要验证的范畴。</p><p>所以这更像是黑盒测试（black-box test）。</p><p>当然，会有例外，如果你底层有一个特别特别复杂的逻辑，你有必要专门花精力去验证它的逻辑正确性，那是可以针对它撰写专门的白盒测试（white-boxtest）的。针对这个情况，作者其实也提出了一个观点，对于这个复杂的逻辑，也可以抽成一个单独的模块，由它来提供能力给你当前模块使用。</p><p>总结：</p><ol type="1"><li>优先选择黑盒测试。</li><li>对于涉及复杂算法的逻辑，单独撰写白盒测试。</li><li>结合覆盖率工具去看哪些代码没被覆盖，然后再站在使用者的角度去思考为什么没被覆盖，是这个分支压根没必要存在，还是还有未考虑到的使用场景。</li></ol><h2 id="如何组织单元测试">如何组织单元测试？</h2><p>两种结构：</p><ul><li>AAA: Arrange-Act-Assert</li><li>GWT: Given-When-Then</li></ul><p>其实都是一个思路：准备前置条件→执行待验证代码→验证逻辑正确性。</p><p>几个建议：</p><ol type="1"><li>尽量避免一个单元测试中包含多个 AAA/GWT。</li><li>避免在单元测试中使用 <code>if</code> 等分支语句。</li><li>命名的时候，尽可能让非程序员也能看懂，即这个命名需要描述一个领域问题。</li></ol><h2 id="如何发挥单测的最大价值">如何发挥单测的最大价值？</h2><ol type="1"><li>单元测试用例必须持续不断反复执行验证。</li><li>用最小的维护代价提供最大价值的单元测试。<ol type="1"><li>识别一个有价值的测试</li><li>撰写一个有价值的测试</li></ol></li><li>验证代码中最重要的部分（领域模型）。</li></ol><h3 id="单元测试用例必须持续不断反复执行验证">1.单元测试用例必须持续不断反复执行验证</h3><p>这里推荐笔者的个人实践：</p><ul><li>在 <code>pre-commit</code>执行<strong>增量单元测试</strong>，确保本次修改的代码涉及的单测可正确通过。</li><li>在 <code>gitlab-ci/github-action</code>流程中执行<strong>全量单元测试</strong>，全面覆盖，避免本次修改的代码影响到其他模块的正常功能。同时如果是合并到主分支的请求，加入增量覆盖率阈值检测，不满足阈值的，发送飞书消息卡片进行告警通知。</li></ul><h4 id="pre-commit-增量单测">pre-commit 增量单测</h4><p><code>.pre-commit-config.yaml</code> 配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">go-unit-tests</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">go-unit-tests</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">run</span> <span class="string">go</span> <span class="string">tests</span> <span class="string">with</span> <span class="string">race</span> <span class="string">detector</span></span><br><span class="line">        <span class="attr">entry:</span> <span class="string">bash</span> <span class="string">-c</span> <span class="string">&#x27;./script/run_diff_go_test.sh&#x27;</span></span><br><span class="line">        <span class="attr">language:</span> <span class="string">golang</span></span><br><span class="line">        <span class="attr">files:</span> <span class="string">\.*$</span></span><br><span class="line">        <span class="attr">pass_filenames:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>run_diff_go_test.sh</code> 脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export GOTOOLCHAIN=auto</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前改动的 Go 文件</span></span><br><span class="line">changed_files=$(git diff --name-only --cached --diff-filter=d | grep &#x27;\.go$&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有改动的 Go 文件，退出</span></span><br><span class="line">if [ -z &quot;$changed_files&quot; ]; then</span><br><span class="line">    echo &quot;No Go files changed.&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提取改动文件所在的包路径（使用相对路径），并排除 vendor 目录</span></span><br><span class="line">test_dirs=$(echo &quot;$changed_files&quot; | xargs -n1 dirname | grep -v &#x27;^vendor&#x27; | sort -u)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对每个改动的包路径运行 go <span class="built_in">test</span></span></span><br><span class="line">for dir in $test_dirs; do</span><br><span class="line">    # 检查目录是否存在</span><br><span class="line">    if [ ! -d &quot;$dir&quot; ]; then</span><br><span class="line">        echo &quot;Directory $dir does not exist. Skipping...&quot;</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 检查是否存在 go.mod 文件，确保在 Go 模块路径中</span><br><span class="line">    if [ -f &quot;$dir/go.mod&quot; ] || [ -f &quot;./go.mod&quot; ]; then</span><br><span class="line">        echo &quot;Running tests in $dir...&quot;</span><br><span class="line">        (cd &quot;$dir&quot; &amp;&amp; go test -mod=vendor -gcflags=all=-l -short ./...)</span><br><span class="line">        if [ $? -ne 0 ]; then</span><br><span class="line">            echo &quot;Tests failed in $dir&quot;</span><br><span class="line">            exit 1</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">        echo &quot;Skipping $dir (no go.mod found)&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;All tests passed.&quot;</span><br></pre></td></tr></table></figure><h4 id="gitlab-ci-全量单测">gitlab-ci 全量单测</h4><p><code>gitlab-ci.yml</code> 配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">go-unit-test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">go-unit-test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sh</span> <span class="string">script/unittest.sh</span> <span class="string">&quot;$CI_MERGE_REQUEST_TITLE&quot;</span> <span class="string">&quot;$GITLAB_USER_EMAIL&quot;</span> <span class="string">&quot;$CI_PIPELINE_ID&quot;</span> <span class="string">&quot;$CI_MERGE_REQUEST_TARGET_BRANCH_NAME&quot;</span> <span class="string">&quot;$CI_JOB_ID&quot;</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_PIPELINE_SOURCE</span> <span class="string">==</span> <span class="string">&quot;merge_request_event&quot;</span> <span class="string">&amp;&amp;</span> <span class="string">$CI_MERGE_REQUEST_TARGET_BRANCH_NAME</span> <span class="string">==</span> <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_PIPELINE_SOURCE</span> <span class="string">==</span> <span class="string">&quot;merge_request_event&quot;</span> <span class="string">&amp;&amp;</span> <span class="string">$CI_MERGE_REQUEST_TARGET_BRANCH_NAME</span> <span class="string">==</span> <span class="string">&#x27;release&#x27;</span></span><br><span class="line">  <span class="attr">coverage:</span> <span class="string">&#x27;/coverage: \d+.\d+% of statements/&#x27;</span></span><br></pre></td></tr></table></figure><p><code>unittest.sh</code> 单测执行脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export GOPROXY=&quot;https://goproxy.cn,direct&quot;</span><br><span class="line"></span><br><span class="line">function generate_coverage_report &#123;</span><br><span class="line">  gocover-cobertura &lt; coverage.out &gt; coverage.xml</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 gotestsum 执行单元测试</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果单测执行失败，会发送飞书消息卡片到告警群中</span></span><br><span class="line">if ! gotestsum --junitfile report.xml --post-run-command=&quot;./script/send_fs_card.sh \&quot;$1\&quot; \&quot;$2\&quot; \&quot;$3\&quot; \&quot;$5\&quot;&quot;  -- ./... -timeout 3s -short -mod=vendor -gcflags=all=-l -coverpkg=./... -coverprofile=coverage.out ; then</span><br><span class="line">  generate_coverage_report</span><br><span class="line">  sh script/cal_diff_coverage.sh &quot;$4&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成单元测试覆盖率报告</span></span><br><span class="line">generate_coverage_report</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果增量覆盖率不满足阈值，会发送飞书消息卡片到告警群中</span></span><br><span class="line">source script/cal_diff_coverage.sh &quot;$4&quot;</span><br><span class="line"></span><br><span class="line">if [[ &quot;$4&quot; == &quot;release&quot; ]]; then</span><br><span class="line">  source script/check_test_coverage.sh &quot;$1&quot; &quot;$2&quot; &quot;$3&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中 <code>cal_diff_coverage.sh</code> 用于计算增量覆盖率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">export COVERAGE_PERCENT=0.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保 coverage.xml 文件存在</span></span><br><span class="line">if [ ! -f coverage.xml ]; then</span><br><span class="line">  echo &quot;coverage: 0.0% of statements&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 diff-cover 生成覆盖率报告</span></span><br><span class="line">diff-cover coverage.xml --exclude **/docs.go --html-report report.html --compare-branch &quot;$1&quot; &gt; diff_detail.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否成功生成报告</span></span><br><span class="line">if [ ! -f report.html ]; then</span><br><span class="line">  echo &quot;coverage: 0.0% of statements&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 grep 和 awk 提取覆盖率信息</span></span><br><span class="line">COVERAGE=$(grep &quot;Coverage:&quot; diff_detail.txt | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果找到了覆盖率数据，检查是否包含小数点</span></span><br><span class="line">if [ -n &quot;$COVERAGE&quot; ]; then</span><br><span class="line">  if [[ &quot;$COVERAGE&quot; != *&quot;.&quot;* ]]; then</span><br><span class="line">    # 如果没有小数点，在百分号前面加上 &#x27;.0&#x27;</span><br><span class="line">    # 这里这么做的目的是不知道为什么 gitlab ci 无法正确解析下面这个正则</span><br><span class="line">    # /coverage: \d+(.\d+)?% of statements/</span><br><span class="line">    # 只能解析这个</span><br><span class="line">    # /coverage: \d+.\d+% of statements/</span><br><span class="line">    COVERAGE=&quot;$&#123;COVERAGE/\%/.0%&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;coverage: $COVERAGE of statements&quot;</span><br><span class="line">else</span><br><span class="line">  COVERAGE=&quot;0.0%&quot;</span><br><span class="line">  echo &quot;coverage: 0.0% of statements&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 COVERAGE 的百分号去掉，只保留数字</span></span><br><span class="line">export COVERAGE_PERCENT=$(echo &quot;$COVERAGE&quot; | sed &#x27;s/%//&#x27;)</span><br></pre></td></tr></table></figure><h3 id="用最小的维护代价提供最大价值的单元测试">2.用最小的维护代价提供最大价值的单元测试</h3><p>如何评价一个单元测试价值是否足够大呢？或者，更简单的说法是，如何评价一个单元测试写得好不好？</p><p>可以从 4 个角度进行评估：</p><ol type="1"><li>protection against regressions</li><li>resistance to refactoring</li><li>fast feedback</li><li>maintainability</li></ol><p>更具体地说：</p><h4 id="防止回归">2.1 防止回归</h4><blockquote><p>代码修改后，原有功能不受影响。</p></blockquote><p>评价指标：</p><ol type="1"><li>被测试代码执行到的业务代码数量（测试覆盖率）。</li><li>业务代码的复杂度。</li><li>业务代码的领域重要性。</li></ol><h4 id="抵抗重构">2.2 抵抗重构</h4><blockquote><p>非功能性重构，测试仍能通过，确保功能一致性。</p></blockquote><p>评价指标：</p><ol type="1"><li>越少的“假阳性”越好。</li><li>在重构代码时，引入了破坏性变更，测试代码能否快速反馈，即越少的“假阴性”越好。</li><li>测试代码是否为你重构代码提供了足够的信心。</li><li>测试代码测试的是业务代码的 observablebehavior，而不是其背后的每一个步骤。</li></ol><h4 id="快速反馈">2.3 快速反馈</h4><blockquote><p>测试代码执行时间越快，则反馈间隔越短，缺陷修复效率和质量就越高。</p></blockquote><p>评价指标：</p><ol type="1"><li>代码执行速度</li></ol><h4 id="可维护性">2.4 可维护性</h4><blockquote><p>测试代码的修改成本，可维护的测试代码更有利于适应需求变更。</p></blockquote><p>评价指标：</p><ol type="1"><li>测试代码有多难理解？</li><li>测试代码的代码行数有多少？</li><li>测试代码的执行难度有多高？即有多少的外部依赖？</li></ol><h4 id="如何权衡">2.5 如何权衡</h4><p>单元测试的价值可以通过上述 4个指标的<strong>乘积</strong>来进行估算，但现实是，这 4者，往往无法兼得。那我们如何做权衡呢？</p><p>首先回顾「为什么要写单元测试」，核心目的是为了<strong>程序逻辑正确性、使软件项目更可持续发展</strong>。所以：</p><ul><li><strong>可维护性（maintainability）</strong>是不可商量的，必须要撰写可维护的测试代码。</li><li><strong>抵抗重构（resistance torefactoring）</strong>是不可商量的，我们的测试代码应尽可能对错误的逻辑进行告警，也应避免对正确的逻辑进行误告警。</li></ul><p>所以我们能权衡的其实就是 protection againts regressions 和 fastfeedback，二者的矛盾很清晰：</p><ol type="1"><li>如果执行的代码越多，相应的效率就越低。</li><li>如果执行的代码太少，那验证的逻辑范围就越小。</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%206.png" style="zoom:33%;" /></p><p>为了权衡这二者，业界提出了“测试金字塔”的概念。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%207.png" style="zoom:33%;" /></p><ol type="1"><li>单元测试的单位更小，涉及的外部依赖也更少，更加 <strong>fastfeedback</strong>，所以在这个层次我们要撰写更多的测试，去尽可能覆盖更多的单元逻辑。</li><li>集成测试、端到端测试的逻辑覆盖范围更大，更加 <strong>resistance torefactoring</strong>，但是往往会依赖更多的组件，执行的效率也更低，所以在这2个层次，我们可以只撰写覆盖最重要（乐观）的业务路径的测试代码，在牺牲有限的执行效率的情况下，尝试更大的防止回归效果。</li></ol><h3 id="验证代码中最重要的部分">3. 验证代码中最重要的部分</h3><p>什么是代码中最重要的部分呢？我们可以将代码分成以下 4 个种类：</p><ol type="1"><li><strong>领域模型和算法（Domain Model andAlgorithms）</strong>：领域模型是对业务领域核心概念和逻辑的抽象，算法则是解决特定问题的计算步骤。两者共同构成系统的核心业务逻辑。</li><li><strong>琐碎代码（TrivialCode）</strong>：实现简单功能、无复杂逻辑的代码片段，通常为工具方法或数据转换层。</li><li><strong>控制器（Controllers）</strong>：协调业务逻辑与外部交互的中间层，常见于MVC 或分层架构中。</li><li><strong>过度复杂代码（OvercomplicatedCode）</strong>：既包含核心业务逻辑，又包含控制器逻辑。</li></ol><p>作者建议：</p><ol type="1"><li>永远为 <strong>Domain Model and Algorithms</strong>撰写全面细致的单元测试。</li><li>永远不为 <strong>Trivial Code</strong> 撰写单元测试。</li><li>为 <strong>Controllers</strong> 撰写集成测试，而不是单元测试。</li><li>避免写 <strong>Overcomplicated Code</strong>，将其拆分成<strong>Domain Model and Algorithms</strong> 和<strong>Controllers</strong> 。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2015.png" /></p><h2 id="如何让代码更容易测试">如何让代码更容易测试？</h2><p>根据不同处理架构的业务代码，可以将测试代码分成以下 3 个种类：</p><ol type="1"><li><code>output-based</code>：业务代码只产生输出结果，所以只需要<strong>验证输出</strong>。</li><li><code>state-based</code>：业务代码会修改内部状态或依赖状态，所以需要<strong>验证状态变化</strong>。</li><li><code>communication-based</code>：业务代码会跟协作方进行交互，所以需要<strong>验证交互情况</strong>。对于这种场景，我们会使用<code>mock</code> 工具来进行验证。关于 <code>mock</code>这个话题，文章后续会进行详细讨论。</li></ol><p>我们按照上述 4 个分析维度，对这 3 种测试代码进行比较：</p><table><colgroup><col style="width: 9%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 21%" /><col style="width: 19%" /></colgroup><thead><tr><th></th><th>protection againts regressions</th><th>resistance to refactoring</th><th>fast feedback</th><th>maintainability</th></tr></thead><tbody><tr><td><strong>output-based</strong></td><td>⭐️⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️⭐️ 最好，不需要外部依赖。</td></tr><tr><td><strong>state-based</strong></td><td>⭐️⭐️⭐️</td><td>⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️ 比较差，需要外部依赖。</td></tr><tr><td><strong>communication-based</strong></td><td>⭐️⭐️ 过度使用会导致需要到处mock，而真正执行的业务代码数量很少。</td><td>⭐️最差，因为验证交互情况，往往会陷入实现细节，很容易在重构过程中出现误警告。</td><td>⭐️⭐️ 大差不差，但是 mock 工具效率可能会相对低一点点。</td><td>⭐️ 最差，需要引入大量的 mock 工具和 mock 代码。</td></tr></tbody></table><p>所以我们应该尽可能写 <strong>output-based</strong> 测试，减少<strong>communication-based</strong> 测试。</p><p>可以采取 <code>functional architecture</code>，将代码分成 2个阶段：</p><ol type="1"><li>根据业务规则做出决定</li><li>根据决定做出行为</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2014.png" /></p><p>为此，在可能的场景下，我们可以尝试通过 2个步骤来优化我们的测试代码：</p><ol type="1"><li>使用 <code>mock</code> 来替代外部依赖<code>out-of-process dependency</code>。</li><li>使用 <code>functional architecture</code> 来替代<code>mock</code>。</li></ol><h2 id="聊一下-mock">聊一下 Mock</h2><p>在撰写单元测试的过程中，如果业务逻辑依赖的组件不好实例化的时候，我们常常会借助各种<code>Mock</code>工具来实现“模拟”功能，使单测更易撰写，这里有一个更准确的词叫<code>test doubles</code>（测试替身）。</p><h3 id="test-double-的种类">test double 的种类</h3><p>从大的方面可以分为 2 种：</p><ol type="1"><li>用于模拟和验证对象间的输出交互（如方法调用次数、参数匹配），则为<code>mock</code>。</li><li>用于模拟输入交互，提供预定义的数据，则为 <code>stub</code>。</li></ol><p>更进一步可以分为：</p><ul><li><code>mock</code><ul><li><code>mock</code>: 由 mock 工具生成。</li><li><code>spy</code>: 手工撰写。</li></ul></li><li><code>stub</code><ul><li><code>stub</code>: 可以通过配置在不同的场景下返回不同的数据。</li><li><code>dummy</code>: 占位符，仅用于填充参数，不参与实际逻辑。</li><li><code>fake</code>: 跟 <code>stub</code> 几乎一样，唯一的区别是<code>fake</code> 经常用于替代尚未开发或复杂的依赖。</li></ul></li></ul><blockquote><p>需要注意的是：永远不要去验证（assert）跟 <code>stub</code>的交互，没必要！</p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%208.png" /></p><h3 id="哪些东西需要-mock">哪些东西需要 Mock？</h3><p>在回答这个问题之前，我们先做下铺垫，聊一下接口的误解、依赖的种类和两种交互的概念。</p><h4 id="接口的误解">接口的误解</h4><p>在谈如何更好地利用 mock之前，我们先来聊一下接口（interface）的误解。</p><p>在业务开发当中，我们经常能看到一些企图进行“优雅”架构设计的代码，上来每一层都定义接口，每一层都使用接口进行交互，反正遇到问题先定义接口再说。</p><p>目的有二：</p><ol type="1"><li>抽象外部依赖，进行解耦。</li><li>可以在不修改既有代码的情况下扩展功能，即所谓的开闭原则（Open-Closedprinciple）。</li></ol><p>但这其实存在一些误区，作者在书中指出：</p><ol type="1"><li><strong>只有一个实现的接口</strong>，并不是抽象，也并没有比具体的对象起到太多所谓的解耦作用。</li><li>上述第 2 点违反了一个更重要的原则 <strong>YAGNI（You are not gonnaneed it）</strong>，也就是你所谓的功能扩展大概率是不需要的。</li><li>上述做法的唯一好处是什么：<strong>使测试成为可能！</strong>因为你不隔离掉外部依赖的话，你的单元测试撰写会非常困难，也无法做到fast feedback。</li></ol><div class="tag-plugin colorful note" color="green"><div class="title">🙋🏻‍♀️</div><div class="body"><p>抽象是发现出来的，而不是发明出来的！</p></div></div><h4 id="依赖的种类">依赖的种类</h4><ul><li><code>shared dependency</code>: 一个在测试代码中的共享对象。</li><li><code>out-of-process dependency</code>:独立于当前应用程序的另外一个进程对象，如数据库、STMP 服务器等。<ul><li><code>managed dependency</code>:仅当前应用程序可访问的依赖（对其他程序、服务是不可见的）。</li><li><code>unmanaged dependency</code>:除了当前应用，其他应用也可见。</li></ul></li><li><code>private dependency</code>: 一个私有对象。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2019.png" /></p><h4 id="两种交互">两种交互</h4><ul><li><code>intra-system communication</code>: 应用程序内部的交互。</li><li><code>inter-system communication</code>: 应用程序之间的交互。</li></ul><h4 id="哪些东西需要-mock-1">哪些东西需要 Mock？</h4><p>铺垫完接口的误解、依赖的种类和两种交互的概念之后，我们来聊一下哪些东西需要Mock？</p><p>在抉择的时候，需要牢记我们测试粒度和评价指标。</p><p>测试粒度：<strong>an observable behavior ⭐️⭐️⭐️⭐️⭐️</strong></p><p>评价指标：</p><ul><li>防止回归：protection against regressions</li><li>抵抗重构：resistance to refactoring</li><li>快速反馈：fast feedback</li><li>可维护性：maintainability</li></ul><p>集合测试粒度和评价指标，Mock 哪些东西可以用一句话来概括：</p><div class="tag-plugin colorful note" color="green"><div class="title">✅</div><div class="body"><p>Mock 那些外部可观测到的交互，而尽量避免 Mock 内部的实现细节。</p></div></div><p>更具体来说：</p><ol type="1"><li><strong>仅对 <code>unmanaged dependency</code> 应用<code>mock</code>对象。</strong>因为我们无法预知其他应用会对这些依赖进行什么操作，所以只能隔离开。</li><li><strong>对系统最外围的边界进行<code>mock</code>。</strong>只有系统边界，才是可观测行为，内部都是实现细节，对实现细节过多Mock，意味着破坏了 resistance to refactoring。</li><li><strong>尽量只在集成测试中使用 mock，避免在单元测试中使用mock。</strong></li><li><strong>只 mock 属于你的对象，不去 mock 依赖库中的对象。</strong><ul><li>始终在第三方库之上编写自己的适配器，并对这些适配器进行 mock，而不是mock底层类型。</li><li>仅从库中暴露你所需要的功能。</li><li>使用项目的领域语言（domain language）来完成上述操作。</li></ul></li></ol><p>举个例子：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2021.png" /></p><p>在上图中，右侧是我们的应用程序，它依赖了左下角的<code>Message bus</code> 这个外部依赖，准确说是<code>unmanaged dependency</code>。对此，我们为其创建了适配器接口<code>IBus</code>，在这个通用接口之上，我们又根据具体业务创建了<code>IMessageBus</code>。</p><p>针对这种情况，我们在进行 mock 的时候，只需要 mock <code>IBus</code>对象，而不是去 mock <code>Message bus</code> 和<code>IMessageBus</code>。</p><h3 id="数据库要不要-mock">数据库要不要 Mock？</h3><p>这个话题比较有意思，作者的建议是：</p><ol type="1"><li>如果这个数据库只有你这个应用可以访问，那就不要 mock。</li><li>如果这个数据库存在可以被其他应用访问的部分，那就只 mock这一部分，不去 mock 独属于你应用的那部分。</li></ol><p>要践行上述标准，需要做到以下前提：</p><ol type="1"><li>将数据库的信息也放在源码控制系统中（git），包括：<ul><li>schema</li><li>reference data（项目启动必须要的初始数据）</li><li>migration（数据变更记录）</li></ul></li><li>每个开发者有一个单独的数据库（测试环境下）</li><li>但数据库变更的时候，不要直接修改，而是要写一条对应 sql去进行修改，同时将这条 sql 也纳入源码控制系统中。</li></ol><p>作者不建议 <code>mock</code> 数据库，包括使用内存数据库替代，如sqlite 替代MySQL，核心原因是：你无法保证这些数据库能跟线上环境的行为一致，可能会导致一些无效测试用例，即假阴性。</p><p>笔者并不完全采纳这个建议，诚然，如果能做到以上前提，是可以考虑践行的。然而，它的要求很高，收益却相对较小，在单元测试环境下，使用内存数据库进行mock，在保证了 fast feedback 和 maintainability的情况下，也能够避免绝大多数的逻辑漏洞了，假阴性的情况会非常少，即便有，也可以交给集成测试和端到端测试去解决。</p><h2 id="反面案例">反面案例</h2><ol type="1"><li>测试私有方法。</li><li>暴露私有状态。</li><li>泄露领域知识到测试中。</li><li>在业务代码中撰写只用于测试的代码。</li><li>mock 具体的类。</li></ol><p>第 3 点比较有意思，比如下面这个例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Adding_two_numbers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> value1 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> value2 = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> expected = value1 + value2;   <span class="comment">// &lt;-----The leakage</span></span><br><span class="line">        <span class="comment">// int expected = 4 // the better one</span></span><br><span class="line">        <span class="built_in">int</span> actual = Calculator.Add(value1, value2);</span><br><span class="line">        Assert.Equal(expected, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么叫做泄露领域知识呢？</p><p>比如你要验证一个加法 <code>Add</code>对不对，但是在测试代码中，你的期望值也是用加法来获得的，这个“加法”就是领域知识，因为这样测的话，就很有可能会出现“<strong>负负得正</strong>”的情况。</p><p>正确的做法是<strong>直接断言你预期的最终结果</strong>，以确保逻辑符合预期。</p><h2 id="go-实践案例">Go 实践案例</h2><p>本章将分享一些笔者在 Go项目实战过程中的一些实践案例，希望对读者撰写单元测试能提供一些帮助。</p><h3 id="依赖-redis-的逻辑怎么测">依赖 Redis 的逻辑怎么测</h3><p>可以使用 <code>miniredis</code>，这是一个使用 Go 语言实现的内存版Redis。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/alicebob/miniredis" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/alicebob/miniredis" autofill="title,icon"><div class="left"><span class="title">https://github.com/alicebob/miniredis</span><span class="cap link footnote">https://github.com/alicebob/miniredis</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><p>可以封装一个函数，用于快速启动 miniredis 并返回客户端对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMiniRedis</span><span class="params">()</span></span> *redis.Client &#123;</span><br><span class="line">    <span class="keyword">var</span> redisClient *redis.Client</span><br><span class="line">    <span class="keyword">var</span> miniRedisClient *miniredis.Miniredis</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    miniRedisClient, err = miniredis.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    redisClient = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">       Addr: miniRedisClient.Addr(),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> redisClient</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里可能会出现作者提到的不要使用内存数据库替代真实的数据库，因为你无法保证它们的行为一致。</p><p>比如这里是单机的，而生产环境可能是集群的，在 Redis Cluster 中，涉及到lua 脚本和事务的所有 key，都必须保证在同一个 slot 上，在这种情况下，使用<code>miniredis</code> 是测不出问题的。</p></blockquote><h3 id="依赖-mysql-的逻辑怎么测">依赖 MySQL 的逻辑怎么测</h3><p>核心挑战：</p><ol type="1"><li>依赖真实 MySQL 则容易因为网络原因而导致测试失败（不可重复性）</li><li>依赖真实 MySQL 会严重影响单侧执行效率</li><li>数据预备</li><li>数据清洗</li><li>单测之间的数据隔离，互不影响</li><li>并发安全</li></ol><p>为了解决上述问题，提供更优雅的 MySQL 单测解决方案，笔者借助<code>dolthub/go-mysql-server</code> 和 <code>gorm</code>的能力，实现了一个 <code>go-mysql-mocker</code>，简称<code>gmm</code>。</p><p>其中：</p><ul><li><code>dolthub/go-mysql-server</code> 提供了内存 MySQL 引擎。</li><li><code>gorm</code> 提供了快速建表和插入数据的能力。</li></ul><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/go-mysql-mocker" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/go-mysql-mocker" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/go-mysql-mocker</span><span class="cap link footnote">https://github.com/hedon954/go-mysql-mocker</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><p>核心功能：</p><ol type="1"><li>内存版数据库，无网络依赖；</li><li>每个单测可单独启动一个数据库，天然做到数据隔离和清洗；</li><li>支持 struct、slice、sql stmt、sql file多种方式进行数据初始化，支持需要前置数据的业务逻辑测试。</li></ol><h3 id="随机概率逻辑怎么测">随机概率逻辑怎么测</h3><p>场景：随机抽奖</p><p>难点：随机概率的结果是不确定的，直接通过 <code>assert.Equal</code>是无法写出可稳定重复运行的单测的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AssertMapRatioEqual 检查实际计数的比例是否符合预期权重的比例</span></span><br><span class="line"><span class="comment">// actual: 实际获得的计数 map[id]count</span></span><br><span class="line"><span class="comment">// expected: 预期的权重 map[id]weight</span></span><br><span class="line"><span class="comment">// tolerance: 允许的误差范围（如 0.05 表示允许 5% 的误差）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssertMapRatioEqual</span><span class="params">(t *testing.T, actual <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int64</span>, expected <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int64</span>, tolerance <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    t.Helper()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算总数</span></span><br><span class="line">    <span class="keyword">var</span> actualTotal, expectedTotal <span class="type">int64</span></span><br><span class="line">    <span class="keyword">for</span> _, count := <span class="keyword">range</span> actual &#123;</span><br><span class="line">        actualTotal += count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, weight := <span class="keyword">range</span> expected &#123;</span><br><span class="line">        expectedTotal += weight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查每个 ID 的比例</span></span><br><span class="line">    <span class="keyword">for</span> id, expectedWeight := <span class="keyword">range</span> expected &#123;</span><br><span class="line">        actualCount, exists := actual[id]</span><br><span class="line">        <span class="keyword">if</span> !exists &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;ID %d 在实际结果中不存在&quot;</span>, id)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        expectedRatio := <span class="type">float64</span>(expectedWeight) / <span class="type">float64</span>(expectedTotal)</span><br><span class="line">        actualRatio := <span class="type">float64</span>(actualCount) / <span class="type">float64</span>(actualTotal)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> diff := math.Abs(expectedRatio - actualRatio); diff &gt; tolerance &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;ID %d 的比例不符合预期: 期望 %.3f, 实际 %.3f, 差异 %.3f, 超出允许误差 %.3f&quot;</span>,</span><br><span class="line">                id, expectedRatio, actualRatio, diff, tolerance)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有多余的 ID</span></span><br><span class="line">    <span class="keyword">for</span> id := <span class="keyword">range</span> actual &#123;</span><br><span class="line">        <span class="keyword">if</span> _, exists := expected[id]; !exists &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;实际结果中存在未预期的 ID: %d&quot;</span>, id)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLottery_randOnce</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Run(<span class="string">&quot;大量抽取应符合权重配置比例&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        gotCount := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int64</span>)</span><br><span class="line">        totalCount := <span class="type">int64</span>(<span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">int64</span>(<span class="number">0</span>); i &lt; totalCount; i++ &#123;</span><br><span class="line">            reward, err := lotteryOnce(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">            assert.Nil(t, err)</span><br><span class="line">            assert.NotNil(t, reward)</span><br><span class="line">            gotCount[reward.Id] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        expectedRatio := <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int64</span>&#123;</span><br><span class="line">            <span class="number">1</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="number">2</span>: <span class="number">20</span>,</span><br><span class="line">            <span class="number">3</span>: <span class="number">30</span>,</span><br><span class="line">            <span class="number">4</span>: <span class="number">40</span>,</span><br><span class="line">            <span class="number">5</span>: <span class="number">40</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        testutil.AssertMapRatioEqual(t, gotCount, expectedRatio, <span class="number">0.05</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="http-接口怎么测">HTTP 接口怎么测</h3><p>挑战：</p><ol type="1"><li>如何快速构建请求体并发送请求？</li><li>如何快速断言异常情况？</li><li>如何快速断言成功情况，并解析出期望的返回值？</li></ol><h4 id="构造请求">1. 构造请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速创建请求体 form 表单格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPPostRequest</span><span class="params">(path <span class="type">string</span>, data any)</span></span> *http.Request &#123;</span><br><span class="line">    req := httptest.NewRequest(<span class="string">&quot;POST&quot;</span>, path, NewHTTPBody(data))</span><br><span class="line">    req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> req</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPBody</span><span class="params">(data any)</span></span> io.Reader &#123;</span><br><span class="line">    values := url.Values&#123;&#125;</span><br><span class="line">    v := reflect.ValueOf(data)</span><br><span class="line">    t := v.Type()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v.Kind() == reflect.Ptr &#123;</span><br><span class="line">        v = v.Elem()</span><br><span class="line">        t = v.Type()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v.Kind() != reflect.Struct &#123;</span><br><span class="line">        <span class="keyword">return</span> strings.NewReader(values.Encode())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">        field := t.Field(i)</span><br><span class="line">        value := v.Field(i)</span><br><span class="line"></span><br><span class="line">        tag := field.Tag.Get(<span class="string">&quot;form&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理复杂类型（结构体、切片、map）</span></span><br><span class="line">        <span class="keyword">switch</span> value.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.Struct, reflect.Slice, reflect.Map:</span><br><span class="line">            jsonBytes, err := json.Marshal(value.Interface())</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                values.Set(tag, <span class="type">string</span>(jsonBytes))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">&quot;Error marshaling %v: %v&quot;</span>, value.Kind(), err)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 处理其他类型</span></span><br><span class="line">            values.Set(tag, fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, value.Interface()))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strings.NewReader(values.Encode())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送请求">2. 发送请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w := httptest.NewRecorder()</span><br><span class="line">sfRouterTest.ServeHTTP(w, request)</span><br></pre></td></tr></table></figure><h4 id="断言异常">3. 断言异常</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AssertRspErr 断言 http 响应异常，expectedErr 为期望的错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssertRspErr</span><span class="params">(w *httptest.ResponseRecorder, t *testing.T, expectedErr <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    assert.Equal(t, http.StatusOK, w.Code)</span><br><span class="line">    body := w.Result().Body</span><br><span class="line">    <span class="keyword">defer</span> body.Close()</span><br><span class="line">    rsp, err := FromHTTPResp[any](body)</span><br><span class="line">    assert.Nil(t, rsp)</span><br><span class="line">    assert.Equal(t, expectedErr, err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="断言正确且返回响应值">4. 断言正确且返回响应值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FromHTTPResp 从 http 响应中解析出数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromHTTPResp</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(resp io.ReadCloser)</span></span> (*T, <span class="type">error</span>) &#123;</span><br><span class="line">    body, err := io.ReadAll(resp)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = resp.Close() &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t httpResp[T]</span><br><span class="line">    err = json.Unmarshal(body, &amp;t)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.Code != <span class="number">200</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(t.Message)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;t.Data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AssertRspOk 断言 http 响应成功，并返回响应体 T</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssertRspOk</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(w *httptest.ResponseRecorder, t *testing.T)</span></span> *T &#123;</span><br><span class="line">    assert.Equal(t, http.StatusOK, w.Code)</span><br><span class="line">    body := w.Result().Body</span><br><span class="line">    <span class="keyword">defer</span> body.Close()</span><br><span class="line">    rsp, err := FromHTTPResp[T](body)</span><br><span class="line">    assert.Nil(t, err)</span><br><span class="line">    assert.NotNil(t, rsp)</span><br><span class="line">    <span class="keyword">return</span> rsp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里其实就违反了上一张反面案例中的第 3点”泄露领域知识到测试中“，因为这里接受响应的时候，还是使用的领域对象结构，所以可能会出现负负得正的情况，比如你的对象字段名就是拼写错误了，但是因为你业务逻辑和断言处都是用的一个结构，所以内部形成了循环，就负负得正了，但是真正到了客户端那，就解析失败了。</p><p>不过在这个情况下，笔者认为这个情况下的这种风险是可以接受的，远盖不住其带来的效率提升。</p></blockquote><h4 id="组合起来">5. 组合起来</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendHTTPRequest</span>[<span class="title">Rsp</span> <span class="title">any</span>]<span class="params">(t *testing.T, server HTTPServer, path <span class="type">string</span>, data any, errMsg ...<span class="type">string</span>)</span></span> *Rsp &#123;</span><br><span class="line">    req := NewHTTPPostRequest(path, data)</span><br><span class="line">    w := httptest.NewRecorder()</span><br><span class="line">    server.ServeHTTP(w, req)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(errMsg) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        AssertRspErr(w, t, errMsg[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AssertRspOk[Rsp](w, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="案例">6. 案例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_GetCollectReward</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Run(<span class="string">&quot;重复领取&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        uid := buildUserInfo(&amp;UserInfo&#123;</span><br><span class="line">            Got: <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>&#123;</span><br><span class="line">                <span class="number">1</span>: &#123;<span class="number">1</span>&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;, apiTest.svc)</span><br><span class="line">        _ = testutil.SendHTTPRequest[GetCollectRewardResp](t, routerTest,</span><br><span class="line">            <span class="string">&quot;/get_collect_reward&quot;</span>, &amp;GetCollectRewardReq&#123;</span><br><span class="line">                UID:       uid,</span><br><span class="line">                CollectID: <span class="number">1</span>,</span><br><span class="line">            &#125;, <span class="string">&quot;重复领取&quot;</span>) <span class="comment">// 错误信息</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    t.Run(<span class="string">&quot;领取成功&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">      uid := uuid.NewString()</span><br><span class="line">        rsp := testutil.SendHTTPRequest[GetCollectRewardResp](t, routerTest,</span><br><span class="line">            <span class="string">&quot;/get_collect_reward&quot;</span>, &amp;GetCollectRewardReq&#123;</span><br><span class="line">                UID:       uid,</span><br><span class="line">                CollectID: <span class="number">1</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line">        assert.NotNil(t, rsp.Reward) <span class="comment">// 正确结果</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖时间的逻辑怎么测">依赖时间的逻辑怎么测</h3><ol type="1"><li>尽量不要依赖时间。</li><li>考虑将时间作为参数，避免 <code>time.Now()</code>。</li></ol><p>也可以参考：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://hedon.top/2025/03/06/go-lib-synctest/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://hedon.top/2025/03/06/go-lib-synctest/" autofill="title,icon"><div class="left"><span class="title">https://hedon.top/2025/03/06/go-lib-synctest/</span><span class="cap link footnote">https://hedon.top/2025/03/06/go-lib-synctest/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><h3 id="并发逻辑怎么测">并发逻辑怎么测</h3><ul><li><code>go test</code> 推荐开启 <code>-race</code>用于检测并发冲突。</li></ul><p>更多可参考：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://hedon.top/2025/03/06/go-lib-synctest/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://hedon.top/2025/03/06/go-lib-synctest/" autofill="title,icon"><div class="left"><span class="title">https://hedon.top/2025/03/06/go-lib-synctest/</span><span class="cap link footnote">https://hedon.top/2025/03/06/go-lib-synctest/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div>]]></content>
    
    
    <summary type="html">本文总结了读者在阅读《Unit Testing》书籍中的收获和思考。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>书籍摘抄丨《Unit Testing Principles, Practices, and Patterns》</title>
    <link href="https://hedon.top/2025/04/09/note-unit-testing-excerpt/"/>
    <id>https://hedon.top/2025/04/09/note-unit-testing-excerpt/</id>
    <published>2025-04-09T04:52:14.000Z</published>
    <updated>2025-06-08T18:35:10.816Z</updated>
    
    <content type="html"><![CDATA[<p>Learning unit testing doesn’t stop at mastering the technical bits ofit, such as your favorite test framework, mocking library, and so on.There’s much more to unit testing than the act of writing tests. Youalways have to achieve the best return on the time you invest in unittesting, minimizing the effort you put into tests and maximizing thebenefits they provide. Achieving both things isn’t an easy task.</p><ul><li>They grow effortlessly, don’t require much maintenance, and canquickly adapt to their customers’ ever-changing needs.</li></ul><p>The ratio between the production code and the test code could beanywhere between <code>1:1</code> and <code>1:3</code>.</p><h1 id="coverage-limitations">Coverage limitations</h1><ul><li>You can’t guarantee that the test verifies all the possible outcomesof the system under test.</li><li>No coverage metric can take into account code paths in externallibraries.</li></ul><h1 id="the-goal-of-unit-testing">The goal of unit testing</h1><ol type="1"><li>lead to a better code design</li><li>enable sustainable(可持续的) growth of the software project</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image.png" /></p><p>the cost components of writing unit tests:</p><ol type="1"><li>refactoring the test when you refactor the underlying code</li><li>running the test on each code change</li><li>dealing with false alarms raised by the test</li><li>spending time reading the test when you’re trying to understandinghow the underlying code behaves</li></ol><p>a successful test suite must:</p><ol type="1"><li>integrated into the development cycle</li><li>targets only the most important parts of the code base<ol type="1"><li>👉🏻 domain logic</li><li>infrastructure code</li><li>external services and dependencies</li><li>code that glues everything together</li></ol></li><li>provides maximum value with minimum maintenance costs<ol type="1"><li>recognize a valuable test (and, by extension, a test of lowvalue)</li><li>write a valuable test</li></ol></li></ol><h1 id="what-is-a-unit-test">What is a unit test?</h1><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%201.png" /></p><ol type="1"><li>verifies a single unit of behavior</li><li>dose it quickly</li><li>dost it in isolation from other tests</li></ol><p>An integration test, then, is a test that doesn’t meet one of thesecriteria.</p><p>End-to-end tests are a subset of integration tests.</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%202.png" /></p><h1 id="how-to-structure-a-unit-test">How to structure a unit test?</h1><table><thead><tr><th>Type</th><th>Components</th></tr></thead><tbody><tr><td>AAA</td><td>Arrange - Act - Assert</td></tr><tr><td>GWT</td><td>Given - When - Then</td></tr></tbody></table><ol type="1"><li>avoid multiple arrange, act, and assert sections.</li><li>avoid if statements in tests.</li><li>name the test as if you were describing the scenario to anon-programmer who is familiar with the problem domain.</li><li>separate words with underscores.</li><li>structure a test is to make it tell a story about the problemdomain</li></ol><h1 id="four-pillars-of-a-good-unit-test">Four pillars of a good unittest</h1><blockquote><p><em>code is not an asset, it’s a liability.</em></p></blockquote><ol type="1"><li><p><strong>protection against regressions</strong></p><ol type="1"><li>the amount of code that is executed during the test</li><li>the complexity of that code</li><li>the code’s domain significance</li></ol></li><li><p><strong>resistance to refactoring</strong></p><ol type="1"><li>the fewer false positives the test generates, the better</li><li>tests provides an early warning when you break exisitingfunctionality</li><li>you become confident that your code changes won’t lead toregressions</li><li>the more the test is coupled to the implementation details of thesystem under set(SUT), the more false alarms it generates</li><li>you need to make sure the test verifies the end result the SUTdelivers: its observable behavior, not the steps it takes to dothat.</li><li>the best way to structure a test is to make it tell a story aboutthe problem domain</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%203.png" /></p></li><li><p><strong>fast feedback</strong></p></li><li><p><strong>maintainability</strong></p><ol type="1"><li>how hard it is to understand the test, which is a function of thetest’s size</li><li>how hard it is to run the test, which is a function of how manyout-of-process dependencies the test works with directly</li></ol></li></ol><h2 id="the-intrinsic-connection-between-the-first-two-attributes">Theintrinsic connection between the first two attributes</h2><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%204.png" /></p><p>Type II Error:</p><ul><li>if functionality is broken, the test should fail, but if the testalso passed, means it is not a good unit test, should if it fails, meansit offers protection against regressions.</li></ul><p>Type I Error:</p><ul><li>if functionality is correct but the test fails, means that the testdose not test the nature of behavior. The good unit test should alwayspass when the functionality is correct. This would help us a lot when wetry to do refactor. If we refactor the code correctly, but the unittests always failed, means that the unit tests are not good enough, weneed to optimize them.</li></ul><h1 id="an-ideal-test">An ideal test</h1><ul><li>value = <code>[0..1] * [0..1] * [0..1] * [0..1]</code>(correspondingto the four pillars)</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%205.png" /></p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%206.png" /></p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%207.png" /></p><h2 id="black-box-and-white-box-testing">black-box and white-boxtesting</h2><ol type="1"><li>choose black-box testing over white-box testing by default.</li><li>the only exception is when the test covers utility code with highalgorithmic complexity</li><li>use code coverage tools to see which code branches are notexercised, but then turn around and test them as if you know nothingabout the code’s internal structure.</li></ol><h1 id="mock">Mock</h1><h2 id="types-of-test-doubles">types of test doubles</h2><ul><li>mock: help to emulate and examine <code>outcoming</code>interactions —— change state<ul><li>mock: generated by tools</li><li>spy: written manually</li></ul></li><li>stub: help to emulate <code>incoming</code> interactions —— getinput data<ul><li>stub: can configure to return different values for differentscenarios.</li><li>dummy: a simple, hardcoded value such as a null value or a made-upstring.</li><li>fake: the same as a stub for most purposes, only except for itscreation, it is usually implemented to replace a dependency that dosenot yet exist</li></ul></li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%208.png" /></p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%209.png" /></p><blockquote><p>never asserting interactions with stubs.</p></blockquote><h2 id="observable-behavior">Observable behavior</h2><ol type="1"><li>expose an <code>operation</code> that helps the client achieve oneof its goals. An operation is a method that performs a calculation orincurs a side effect or both.</li><li>expose a <code>state</code> that helps the client achieve one of itsgoals. State is the current condition of the system.</li></ol><blockquote><p>Whether the code is observable behavior depends on who its client isand what the goals of that client are.</p></blockquote><blockquote><p>Ideally, the system’s public API surface should coincide with itsobservable behavior, and all its implementation details should be hiddenfrom the eyes of the clients.</p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2010.png" /></p><h2 id="mocks-and-test-fragility">Mocks and test fragility</h2><ul><li><code>Intra-system</code> communications are communications betweenclasses inside your application.</li><li><code>Inter-system</code> communications are when your applicationtalks to other applications.</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2011.png" /></p><ol type="1"><li>The use of mocks is <code>beneficial</code> when verifying thecommunication pattern between your system and externalapplications.</li><li>Using mocks to verify communications between classes inside yoursystem results in tests that couple to implementation details andtherefore fall short of the <code>resistance-to-refactoring</code>metric.</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2012.png" /></p><h2 id="types-of-dependencies">Types of dependencies</h2><ul><li><code>shared dependency</code>: a dependency shared by test (notproduction code)</li><li><code>out-of-process dependency</code>: a dependency hosted by aprocess other than the program’s execution process (database, stmpserver)</li><li><code>private dependency</code>: any dependency that is notshared</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2013.png" /></p><h1 id="styles-of-unit-testing">Styles of unit testing</h1><ul><li><code>output-based</code>: only need to verify the output.</li><li><code>state-based</code>: the underlying code changes its own state,the state of its collaborators, or the state of an out-of-processdependency.</li><li><code>communication-based</code>: use mocks to verify communicationsbetween the SUT and its collaborators, to verify the communicationsituations.</li></ul><h2 id="compare">compare</h2><h3 id="protection-against-regressions">protection againstregressions</h3><ul><li>for the most part, they are not very different</li><li>but overusing the <code>communication-based</code> style can resultin shallow tests that verify only a thin slice of code and mock outeverything else.</li></ul><h3 id="fast-feedback">fast feedback</h3><ul><li>for the most part, they are not very different</li><li><code>communication-based</code> testing can be slightly worsebecause the cost of mocks.</li></ul><h3 id="resistance-to-refactoring">resistance to refactoring</h3><ul><li><code>state-based</code> is the best one.</li><li><code>communication-based</code> is the worse one, because it is themost vulnerable to false alarms.</li></ul><h3 id="maintainability">maintainability</h3><ul><li><code>output-based</code> is the best one, because they do not dealwith out-of-process dependencies.</li><li><code>state-based</code> is less maintainable because stateverification takes up more space than output verification.</li><li><code>communication-based</code> is the worst one, it requiressetting up test doubles and interaction assertions, and that takes up alot of space.</li></ul><h2 id="functional-architecture">functional architecture</h2><p><code>*Functional architecture</code>* maximizes the amount of codewritten in a purely functional (immutable) way, while minimizing codethat deals with side effects. <em>Immutable</em> means unchangeable:once an object is created, its state can’t be modified. This is incontrast to a *mutable* object (changeable object), which can bemodified after it is created.</p><p>Separate two kinds of code:</p><ul><li>code that make a decision</li><li>code that acts upon that decision</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2014.png" /></p><h2 id="tips">Tips</h2><ul><li>Moving from using an out-of-process dependency to using mocks.</li><li>Moving from using mocks to using functional architecture</li></ul><h1 id="four-kinds-of-code">Four kinds of code</h1><ul><li>Domain model and algorithms</li><li>Trivial code</li><li>Controllers</li><li>Overcomplicated code</li></ul><h2 id="tips-1">Tips</h2><ol type="1"><li>always write completed unit tests for<code>domain model the algorithms</code> code</li><li>never test <code>trivial code</code></li><li>write integration test for <code>controllers</code></li><li>do not write overcomplicated code, try to separate it into<code>domain model and algorithms</code> and<code>controllers</code></li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2015.png" /></p><h2 id="trade-off">Trade-off</h2><ul><li>domain model testability</li><li>controller simplicity</li><li>performance</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2016.png" /></p><ol type="1"><li>push all external reads and writes to the edges anyway</li><li>inject the out-of-process dependencies into the domain model</li><li><strong>split the decision-making process into more granularsteps</strong> 👈<ol type="1"><li><code>CanExecute/Execute</code> pattern</li><li>domain events</li></ol></li></ol><h2 id="canexecuteexecute-pattern">CanExecute/Execute pattern</h2><p>You can use <code>CanExecute/Execute</code> pattern to balance the<code>performance</code> and <code>testability</code> , but concedescontroller simplicity, but it is manageable in most cases.</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2017.png" /></p><h2 id="domain-events">Domain events</h2><p>Domain events help track important changes in the domain model, andthen convert those changes to calls to out-of-process dependencies. Thispattern removes the tracking responsibility from the controller.</p><ul><li>extract a <code>DomainEvent</code> base class and introduce a baseclass for all domain classes, which would contain a collection of suchevents: <code>List&lt;DomainEvent&gt; events</code></li></ul><h1 id="integration-tests">Integration tests</h1><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2018.png" /></p><ol type="1"><li>check as many of the business scenario’s edge cases as possible withunit tests</li><li>use integration tests to cover one happy path, as well as any edgecases that can’t be covered by unit tests</li><li>if there’s no one path that goes through all happy paths, writeadditional integration tests—as many as needed to capture communicationswith <strong>every</strong> external system</li><li>attempt to apply the <code>fail-fast principle</code> as a viablealternative to integration test.</li></ol><h2 id="two-types-of-out-of-process-dependencies">two types ofout-of-process dependencies</h2><ul><li><code>managed dependencies</code>: only accessible through yourapplication. it is implement details and should not be mock.</li><li><code>unmanaged dependencies</code>: you don’t have full controlover it. It is observable behavior and you should mock it.</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2019.png" /></p><h2 id="interface-misunderstand">interface misunderstand</h2><div class="tag-plugin quot"><p class="content" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e092ff.png" /><span class="text">🙋🏻‍♀️ Genuine abstractions are discovered, not invented.</span><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e0ab55.png" /></p></div><p>👉🏻 For an interface to be a genuine abstraction, it must have atlease two implemtations.</p><p>The common reasoning behind the use of interfaces is that they helpto:</p><ol type="1"><li>Abstract out-of-process dependencies, thus achieving loosecoupling.</li><li>Add new functionality without changing the existing code, thusadhering to the <code>Open-Closed principle</code></li></ol><p>Misconceptions:</p><ol type="1"><li>Interfaces with a single implementation are not abstractions anddon’t provide loose coupling any more than concrete classes thatimplement those interfaces.</li><li>The second reason violates a more foundational principle:<code>YAGNI (You are not gonna need it)</code>.</li><li>The only reason to use interfaces for out-of-process dependencies itis to <code>enable testing</code>!</li><li>Do not introduce interfaces for out-of-process dependencies unlessyou need to mock out those dependencies.</li></ol><h2 id="integration-test-best-practices">integration test bestpractices</h2><ol type="1"><li>making domain model boundaries explicit</li><li>reducing the number of layers in the application</li><li>eliminating circular dependencies</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2020.png" /></p><h2 id="maximozing-mocks-value">maximozing mock’s value</h2><ol type="1"><li><p>when mocking, always try to <strong>verify interactions withunmanaged dependencies at the very edges of your system</strong>.</p><blockquote><p>Mocking <code>IBus</code> instead of <code>IMessageBus</code>maximizes the mock’s protection against regressions.</p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2021.png" /></p></li><li><p>A call to an unmanaged dependency goes through several stagesbefore it leaves your application. <strong>Pick the last suchstage</strong>. It is the best way to ensure backward compatibility withexternal systems, which is the goal that mocks help youachieve.</p></li><li><p>In some cases, you can use <code>spy</code> instead of<code>mock</code> for more succinct and expressive.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Changing_email_from_corporate_to_non_corporate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> busSpy = <span class="keyword">new</span> BusSpy();</span><br><span class="line">    <span class="keyword">var</span> messageBus = <span class="keyword">new</span> MessageBus(busSpy);</span><br><span class="line">    <span class="keyword">var</span> loggerMock = <span class="keyword">new</span> Mock&lt;IDomainLogger&gt;();</span><br><span class="line">    <span class="keyword">var</span> sut = <span class="keyword">new</span> UserController(db, messageBus, loggerMock.Object);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">    busSpy.ShouldSendNumberOfMessages(<span class="number">1</span>)</span><br><span class="line">        .WithEmailChangedMessage(user.UserId, <span class="string">&quot;new@gmail.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="mocking-best-practices">mocking best practices</h2><ol type="1"><li>applying mocks to unmanaged dependencies only</li><li>verifying the interactions with those dependencies at the very edgesof your system</li><li>using mocks in integration tests only, not in unit test</li><li>always verifying the number of calls made to the mock</li><li>do not rely on production code when making assertions. Use aseparate set of literals and constants in tests.</li><li>mocking only types that you own<ol type="1"><li>always write your own adapters on top of third-party libraries andmock those adapters instead of the underlying types.</li><li>only expose features you need from the library</li><li>do that using your project’s domain language</li><li>this guideline dose not apply to in-process dependencies. There isno need to abstract in-memory or managed dependencies. Similarly,there’s no need to abstract an ORM as long as it’s used for accessing adatabase that isn’t visible to external applications.</li></ol></li></ol><h1 id="testing-the-database">Testing the database</h1><h2 id="prerequisites">prerequisites</h2><ol type="1"><li><p>keeping the database in the source control system</p><ol type="1"><li>database schemas</li><li>reference data</li></ol></li><li><p>using a separate database instance for every developer</p></li><li><p>applying the migration-based approach to database delivery</p><blockquote><p>applying every modification to the database schema (includingreference data) through migrations. Do not modify migrations once theyare committed to the source control. If a migration is incorrect, createa new migration instead of fixing the old one. Make exceptions to thisrule only when the incorrect migration can lead to data loss.</p></blockquote></li></ol><h2 id="transaction">transaction</h2><p>split the <code>Database</code> class into <code>repositories</code>and a <code>transaction</code>:</p><ul><li><code>repositories</code> are classes that enable access to andmodification of the data in the database.</li><li><code>transaction</code> is a class that either commits or rollsback data updates in full. This will be a custom class relying on theunderlying database’s transactions to provide atomicity of datamodification.</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2022.png" /></p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2023.png" /></p><h2 id="tips-2">tips</h2><ol type="1"><li>use at least three transactions or units of work in an integrationstest: one per each arrange, act and assert section.</li><li>your tests should not depend on the state of the database. Yourtests should bring that state to the required condition on theirown.</li><li>create two collections for unit and integrations, and then disabletest parallelization in the collection with the integration test.</li><li>clean up data at the beginning of a test</li><li>write the SQL script manually. It’s simpler and gives you moregranular control over the deletion process.</li><li>the best way to shorten integration is by extracting technical,non-business-related bits into private methods or helper classes.</li><li>only the most complex or important read operations should be test,disregard the rest.</li><li>do not test repositories directly, only as part of the overarchingintegration test suite.</li></ol><h1 id="unit-testing-anti-patterns">Unit testing anti-patterns</h1><blockquote><p>⚠️ Do not do the things like below!</p></blockquote><ol type="1"><li><p>unit testing private methods</p><blockquote><p>Private methods are implementation details! Just test observablebehaviors!</p></blockquote><blockquote><p><strong>If the private method is too complex to be tested as part ofthe public API that uses it, that’s an indication of a missingabstraction. Extract this abstraction into a separate class instead ofmaking the private method public.</strong></p></blockquote></li><li><p>expose private state</p></li><li><p>leaking domain knowledges to tests</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Adding_two_numbers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> value1 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> value2 = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> expected = value1 + value2;   <span class="comment">// &lt;-----The leakage</span></span><br><span class="line">        <span class="comment">// int expected = 4 // the better one</span></span><br><span class="line">        <span class="built_in">int</span> actual = Calculator.Add(value1, value2);</span><br><span class="line">        Assert.Equal(expected, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>code pollution</p><blockquote><p>Code pollution is adding production code that’s only needed fortesting.</p></blockquote></li><li><p>mocking concrete classes</p></li><li><p>working with time</p></li></ol>]]></content>
    
    
    <summary type="html">本文对《Unit Testing》的关键观点进行了梳理总结。</summary>
    
    
    
    <category term="书籍摘抄" scheme="https://hedon.top/categories/%E4%B9%A6%E7%B1%8D%E6%91%98%E6%8A%84/"/>
    
    <category term="单元测试" scheme="https://hedon.top/categories/%E4%B9%A6%E7%B1%8D%E6%91%98%E6%8A%84/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="书籍摘抄" scheme="https://hedon.top/tags/%E4%B9%A6%E7%B1%8D%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>一步步推导出 MySQL 数据的底层存储结构</title>
    <link href="https://hedon.top/2025/04/08/mysql-ibd/"/>
    <id>https://hedon.top/2025/04/08/mysql-ibd/</id>
    <published>2025-04-08T04:54:13.000Z</published>
    <updated>2025-04-15T16:25:59.245Z</updated>
    
    <content type="html"><![CDATA[<p>以下均以 InnoDB 引擎为基础进行分析。假设我们现在有 3行数据，如下：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408125932725.png" /></p><p>其中：</p><ul><li><code>id</code> 是主键索引。</li><li><code>a</code> 和 <code>b</code> 都是数据字段。</li><li><code>tx_id</code> 是隐藏字段，表示事务 id，用于实现 MVCC。</li><li><code>rollback_ptr</code> 是回指针，用于 undo log。</li></ul><p>在将数据存储到文件的时候，我们会将这三行数据进行序列化，然后以二进制流的形式存储到文件中。</p><p>现在我们要解决第一个问题：</p><div class="tag-plugin quot"><h4 class="content" id="如何按照主键（id）排序？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如何按照主键（id）排序？</span><span class="empty"></span></h4></div><p>在 InnoDB 中，会在每一行的前面，加一个 <code>next_record</code>字段，用于指向比当前数据 id 大的下一条数据，我们假设一行数据占 20个字节，那么就如下图所示：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408130510505.png" /></p><p>另外，为了便于定位每一行，InnoDB 会在每一行前面再加一个字段<code>heap_no</code>，它的规则很简单，就是自增，在内部会用于定位一行记录，方便上锁等各种操作。</p><p>所以现在的存储结构如下图所示：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408130840634.png" /></p><p>现在我们来解决解决第二个问题：</p><div class="tag-plugin quot"><h4 class="content" id="如何快速定位到起点（最小）和终点（最大）？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如何快速定位到起点（最小）和终点（最大）？</span><span class="empty"></span></h4></div><p>在最前面加 2 条特殊的记录：</p><ul><li><code>PAGE_NEW_INFIMUM</code>：指向最小记录。</li><li><code>PAGE_NEW_SUPERMUM</code>：最大记录，最大的一个 id会指向它。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408130825820.png" /></p><p>第三个问题：</p><div class="tag-plugin quot"><h4 class="content" id="每次 select * from t where id = ? 都要进行 I/O 操作吗？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">每次 select * from t where id = ? 都要进行 I/O 操作吗？</span><span class="empty"></span></h4></div><p>很显然是不行的，效率太低了。这个相信绝大多数读者都知道 ，InnoDB 会以Page（默认16KB）为最小单位，一次性将数据从磁盘加载到内存中。为此，需要在最前面再加一条记录，且该记录的前三行分别为：</p><ul><li><code>page_no</code>：页号，自增，InnoDB 最多支持 32位页号，所以存储上限是 16KB * 2<sup>32</sup> = 64T。</li><li><code>prev_page</code>：指向上一页。</li><li><code>next_page</code>：指向下一页。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250409000055738.png" /></p><div class="tag-plugin quot"><h4 class="content" id="如果一个 Page 放不下呢？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如果一个 Page 放不下呢？</span><span class="empty"></span></h4></div><p>很显然，那就要进行分页，即按照 ID 的顺序进行一分为二，前者取范围<code>[a, b)</code>，后者取范围 <code>[b, c)</code>。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408131632390.png" /></p><div class="tag-plugin quot"><h4 class="content" id="如何快速定位到数据在哪个 Page 上呢？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如何快速定位到数据在哪个 Page 上呢？</span><span class="empty"></span></h4></div><p>这个时候，我们需要新创建一个 Page，专门用于管理这些数据 Page 的，这个Page 我们这里暂且称为索引 Page。</p><p>其中核心数据就是 2 个：</p><ul><li><code>min_id</code>：即当前页存储的最小主键 ID。</li><li><code>page_no</code>：页号，用于定位到 Page。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408131810905.png" /></p><p>这是什么呀？这其实就是 B+树！在文件层面的存储，是连续存储的，但是为了便于理解，我们可以在逻辑层面将其绘制成B+ 树的形态。如下图可以看到这其实就是一颗 B+ 树。</p><p>在主键索引树上：</p><ol type="1"><li>叶子节点存储的就是具体某一行的数据（聚簇索引）。</li><li>非叶子节点存储的是索引。</li><li>每一层的节点，都是一条有序的双向链表。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408132026228.png" /></p><div class="tag-plugin quot"><h4 class="content" id="如果对非主键索引 a 创建索引呢？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如果对非主键索引 a 创建索引呢？</span><span class="empty"></span></h4></div><p>因为要建索引，所以需要先对 a 进行排序，然后针对 a 建立一颗 b+树。而且由于 a是非主键索引，即辅助索引，所以叶子节点存储的是主键的值，用于回表。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408132300926.png" /></p><div class="tag-plugin quot"><h4 class="content" id="假设 a =15 的数据非常多，一个 page 放不下呢？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">假设 a =15 的数据非常多，一个 page 放不下呢？</span><span class="empty"></span></h4></div><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408132323227.png" /></p><p>会加入主键 ID 作为二维排序来进行分裂：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408132350638.png" /></p><div class="tag-plugin quot"><h4 class="content" id="估算一下一个三层的 B+ 树可以存储多少条数据？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">估算一下一个三层的 B+ 树可以存储多少条数据？</span><span class="empty"></span></h4></div><ul><li>一个 Page 是 16KB</li><li>假设 1 个 Page 可以存放 1000 个 key</li><li>假设 1 个 Page 可以存放 200 条记录</li></ul><p>基于这种估算：</p><ul><li>第 1 层：1 个节点是 1 个 Page，存放 1000 个 key，对应 1000个分叉</li><li>第 2 层：1000 个节点 1000 个 Page，存放 1000*1000 个 Key，对应1000*1000 个分叉</li><li>第 3 层：1000*1000 个 Page，每个 Page 200 条数据，共 1000*1000*200=2亿条数据 = 16KB*1000*1000=16GB</li></ul><p>🐂🐂🐂</p>]]></content>
    
    
    <summary type="html">本文从最简单的数据格式开始，通过不断解决一个个关键问题，最终推导出 MySQL 数据的底层存储结构，即 B+ 树。</summary>
    
    
    
    <category term="数据库" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mysql" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
    <category term="mysql" scheme="https://hedon.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 博客中优雅地集成 Markmap 思维导图</title>
    <link href="https://hedon.top/2025/03/17/mindmap-for-hexo/"/>
    <id>https://hedon.top/2025/03/17/mindmap-for-hexo/</id>
    <published>2025-03-17T10:21:18.000Z</published>
    <updated>2025-04-05T14:31:32.876Z</updated>
    
    <content type="html"><![CDATA[<p>在技术博客写作中，思维导图是一个非常有用的工具，它可以帮助我们更清晰地展示知识结构和概念关系。本文将介绍如何在Hexo 博客中集成 Markmap，让你能够直接在 Markdown文件中创建交互式思维导图。</p><h2 id="什么是-markmap">什么是 Markmap？</h2><p>Markmap 是一个将 Markdown格式的文本转换为思维导图的开源工具。它允许我们使用熟悉的 Markdown语法来创建漂亮的、交互式的思维导图。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://markmap.js.org/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://markmap.js.org/" autofill="title,icon"><div class="left"><span class="title">https://markmap.js.org/</span><span class="cap link footnote">https://markmap.js.org/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><h2 id="实现方案">实现方案</h2><h3 id="安装必要依赖">1. 安装必要依赖</h3><p>首先，我们需要安装 <code>uuid</code>包，这是用来给我们每一个思维导图生成一个唯一的 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uuid --save</span><br></pre></td></tr></table></figure><h3 id="创建自定义标签插件">2. 创建自定义标签插件</h3><p>在 <code>scripts/markmap_tag.js</code> 中创建自定义标签：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Markmap Tag Plugin for Hexo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">v4</span>: uuidv4 &#125; = <span class="built_in">require</span>(<span class="string">&quot;uuid&quot;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(</span><br><span class="line">  <span class="string">&quot;markmap&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">args, content</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">uuidv4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div class=&quot;markmap&quot; id=&quot;markmap-<span class="subst">$&#123;id&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;script type=&quot;text/template&quot;&gt;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;content&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123;</span></span><br><span class="line"><span class="string">  const template = document.querySelector(&#x27;#markmap-<span class="subst">$&#123;id&#125;</span> script[type=&quot;text/template&quot;]&#x27;);</span></span><br><span class="line"><span class="string">  if (template) &#123;</span></span><br><span class="line"><span class="string">    const content = template.textContent;</span></span><br><span class="line"><span class="string">    window.markmap.autoLoader.renderString(content, null, document.querySelector(&#x27;#markmap-<span class="subst">$&#123;id&#125;</span>&#x27;));</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">ends</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="添加样式">3. 添加样式</h3><p>创建 <code>source/css/markmap.css</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Markmap Styles */</span></span><br><span class="line"><span class="selector-class">.markmap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eaeaea</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.markmap</span> <span class="selector-tag">svg</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 响应式设计 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.markmap</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">480px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.markmap</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新主题配置">4. 更新主题配置</h3><p>在主题配置文件中添加必要的资源引用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/markmap.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/npm/markmap-autoloader@0.18&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用方法">使用方法</h2><div class="tag-plugin tabs" align="center"id="tab_1"><div class="nav-tabs"><div class="tab active"><a href="#tab_1-1">代码块</a></div><div class="tab"><a href="#tab_1-2">效果</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_1-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% markmap %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 技术栈</span><br><span class="line"><span class="bullet">  -</span> 前端</span><br><span class="line"><span class="bullet">    -</span> Vue.js</span><br><span class="line"><span class="bullet">    -</span> React</span><br><span class="line"><span class="bullet">    -</span> Angular</span><br><span class="line"><span class="bullet">  -</span> 后端</span><br><span class="line"><span class="bullet">    -</span> Node.js</span><br><span class="line"><span class="bullet">    -</span> Python</span><br><span class="line"><span class="bullet">    -</span> Go</span><br><span class="line"><span class="bullet">  -</span> 数据库</span><br><span class="line"><span class="bullet">    -</span> MySQL</span><br><span class="line"><span class="bullet">    -</span> MongoDB</span><br><span class="line"><span class="bullet">    -</span> Redis</span><br><span class="line"></span><br><span class="line">&#123;% endmarkmap %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab_1-2"><style>svg.markmap {        width: 100%;        height: 500px;      }</style><div id="markmap-6c5c8590-d4f9-4c5e-9d9d-c17cd00ce9a6" class="markmap"><script type="text/template">- 技术栈  - 前端    - Vue.js    - React    - Angular  - 后端    - Node.js    - Python    - Go  - 数据库    - MySQL    - MongoDB    - Redis  </script></div></div></div></div><h2 id="工作原理">工作原理</h2><h3 id="hexo-插件系统">1. Hexo 插件系统</h3><ul><li>Hexo 提供了强大的插件系统，允许我们通过 <code>hexo.extend</code> API来扩展功能</li><li>我们使用了 <code>hexo.extend.tag</code> 来注册自定义标签，这是 Hexo提供的标准扩展点之一</li></ul><h3 id="标签插件的工作原理">2. 标签插件的工作原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(</span><br><span class="line">  <span class="string">&quot;markmap&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">args, content</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">uuidv4</span>(); <span class="comment">// 生成唯一ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;markmap&quot; id=&quot;markmap-<span class="subst">$&#123;id&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;script type=&quot;text/template&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;content&#125;</span></span></span><br><span class="line"><span class="string">      &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">ends</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>当 Hexo 解析到 <code>markmap</code>标签时，会调用这个注册的函数</li><li><code>content</code> 参数包含了标签之间的所有内容（你的 markdown结构）</li><li><code>&#123;ends: true&#125;</code> 表示这是一个闭合标签（需要 endmarkmap结束）</li></ul><h3 id="markmap-库的渲染过程">3. Markmap 库的渲染过程</h3><ul><li>Markmap 库使用 <code>markmap-autoloader</code> 自动处理 markdown到思维导图的转换</li><li>转换过程：<ol type="1"><li>Markdown 文本被解析成层级结构</li><li>层级结构被转换为 SVG 路径</li><li>SVG 被渲染到页面上，并添加交互功能</li></ol></li></ul><h3 id="html-结构设计">4. HTML 结构设计</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;markmap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;markmap-$&#123;id&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/template&quot;</span>&gt;</span></span><br><span class="line">    $&#123;content&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>script type="text/template"</code> 来存储原始markdown</li><li>每个思维导图都有唯一 ID，避免页面上多个图表互相干扰</li></ul><h3 id="javascript-初始化">5. JavaScript 初始化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> template = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(</span><br><span class="line">    <span class="string">&#x27;#markmap-$&#123;id&#125; script[type=&quot;text/template&quot;]&#x27;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (template) &#123;</span><br><span class="line">    <span class="keyword">const</span> content = template.<span class="property">textContent</span>;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">markmap</span>.<span class="property">autoLoader</span>.<span class="title function_">renderString</span>(</span><br><span class="line">      content,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#markmap-$&#123;id&#125;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>等待页面加载完成</li><li>获取模板中的 markdown 内容</li><li>使用 markmap 库渲染思维导图</li></ul><h3 id="样式控制">6. 样式控制</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.markmap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eaeaea</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>提供响应式布局</li><li>确保思维导图在各种屏幕尺寸下都能正常显示</li></ul><h3 id="主题集成">7. 主题集成</h3><ul><li>在主题配置中注入必要的 CSS 和 JavaScript</li><li>确保资源在正确的时机加载</li></ul>]]></content>
    
    
    <summary type="html">本文详细介绍了如何在 Hexo 博客中优雅地集成 Markmap 思维导图，让你能够直接在 Markdown 文件中创建交互式思维导图。同时这也是一个 Hexo 插件的标准实现案例。</summary>
    
    
    
    <category term="小技术" scheme="https://hedon.top/categories/%E5%B0%8F%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="hexo" scheme="https://hedon.top/tags/hexo/"/>
    
    <category term="markmap" scheme="https://hedon.top/tags/markmap/"/>
    
  </entry>
  
  <entry>
    <title>为什么 OpenTelemetry 的 SDK 中不支持尾采样 Hook？</title>
    <link href="https://hedon.top/2025/03/13/opentelemetry-tail-sampler/"/>
    <id>https://hedon.top/2025/03/13/opentelemetry-tail-sampler/</id>
    <published>2025-03-13T07:10:27.000Z</published>
    <updated>2025-04-05T14:31:32.877Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式追踪系统中，采样策略直接影响着系统的性能和可观测性。OpenTelemetry作为当前最流行的可观测性框架，其采样机制设计有着深刻的考量。本文将深入探讨OpenTelemetry 的采样机制，特别是为什么它在 SDK 层面不支持尾采样。</p><h2 id="前置采样-vs-尾采样">前置采样 vs 尾采样</h2><p>在讨论 OpenTelemetry的采样机制前，我们需要理解两种主要的采样策略：</p><p><strong>前置采样（Head-based Sampling）</strong>：</p><ul><li>在链路开始时就决定是否采样</li><li>决策一旦做出，整个链路都遵循这个决策</li><li>不需要缓存完整的链路数据</li></ul><p><strong>尾采样（Tail-based Sampling）</strong>：</p><ul><li>在链路结束后决定是否保留</li><li>可以基于完整链路信息（如总耗时、是否有错误）做决策</li><li>需要临时缓存所有链路数据</li></ul><h2 id="opentelemetry-的采样实现">OpenTelemetry 的采样实现</h2><p>通过分析 <ahref="https://github.com/open-telemetry/opentelemetry-go/blob/v1.35.0/sdk/trace/tracer.go#L65">OpenTelemetryGo SDK的源码</a>，我们可以清晰地看到它采用的是前置采样策略。关键代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tr *tracer)</span></span> newSpan(ctx context.Context, name <span class="type">string</span>, config *trace.SpanConfig) trace.Span &#123;</span><br><span class="line">    <span class="comment">// ... 前面的代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行采样决策</span></span><br><span class="line">    samplingResult := tr.provider.sampler.ShouldSample(SamplingParameters&#123;</span><br><span class="line">        ParentContext: ctx,</span><br><span class="line">        TraceID:       tid,</span><br><span class="line">        Name:          name,</span><br><span class="line">        Kind:          config.SpanKind(),</span><br><span class="line">        Attributes:    config.Attributes(),</span><br><span class="line">        Links:         config.Links(),</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置采样标志</span></span><br><span class="line">    <span class="keyword">if</span> isSampled(samplingResult) &#123;</span><br><span class="line">        scc.TraceFlags = psc.TraceFlags() | trace.FlagsSampled</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scc.TraceFlags = psc.TraceFlags() &amp;^ trace.FlagsSampled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 后面的代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码揭示了几个关键点：</p><ol type="1"><li>采样决策在 span 创建时就已经做出</li><li>采样标志通过位操作设置在 TraceFlags 中</li><li>这个标志会随着 SpanContext 传播到整个分布式系统</li></ol><h2 id="采样标志的传播机制">采样标志的传播机制</h2><p>特别值得注意的是设置采样标志的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> isSampled(samplingResult) &#123;</span><br><span class="line">    scc.TraceFlags = psc.TraceFlags() | trace.FlagsSampled</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scc.TraceFlags = psc.TraceFlags() &amp;^ trace.FlagsSampled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用位操作来设置或清除采样标志：</p><ul><li><code>|</code> 操作用于设置采样标志，保留其他标志位不变</li><li><code>&amp;^</code>操作用于清除采样标志，同样保留其他标志位不变</li></ul><p>这确保了采样决策能够一致地传播到整个分布式链路中。</p><h2 id="为什么-opentelemetry-不支持尾采样">为什么 OpenTelemetry不支持尾采样？</h2><p>最重要的原因是：<font color="red">在 SDK中找不到尾巴！因为不知道链路什么时候结束！</font></p><p>在分布式系统中，一条链路可能跨越多个服务，所以你在某一个服务中，是不知道链路是否结束的，而OpenTelemetry 也不是一次性上报一整条链路，而是每个 <code>span</code>独立上报，最后再拼接到一起。</p><h3 id="opentelemetry-上报原理">OpenTelemetry 上报原理</h3><ol type="1"><li><p>独立上报</p><ul><li><p>每个 <code>span</code> 在结束时（调用<code>span.End()</code>）会被传递给 <code>SpanProcessor</code></p></li><li><p><code>SpanProcessor</code> 决定如何处理这个<code>span</code>（立即导出或批量导出）</p></li><li><p>导出是独立的，不会等待整个 <code>trace</code> 完成</p></li></ul></li><li><p>批处理机制</p><ul><li><p>默认使用 <code>BatchSpanProcessor</code>，它会收集一定数量的<code>spans</code> 或等待一定时间然后批量导出</p></li><li><p>但这个批处理与 <code>trace</code>完整性无关，只是为了效率</p></li></ul></li></ol><h3 id="collector-如何实现尾采样">Collector 如何实现尾采样</h3><p>Collector 通过以下方式解决这些问题：</p><ol type="1"><li><p>设置等待时间窗口</p><ul><li><p>为每个 trace 设置一个等待期（如 10 秒）</p></li><li><p>在此期间收集该 trace 的所有 spans</p></li><li><p><strong>超过等待期后，基于已收集的 spans 做决策</strong></p></li></ul></li><li><p>集中式收集</p><ul><li><p>所有服务的 spans 都发送到 Collector</p></li><li><p>Collector 有更全面的视图来关联 spans</p></li></ul></li><li><p>专门的资源分配：Collector作为独立组件，有专门的资源处理这种复杂逻辑，不会影响应用性能。</p></li></ol><h2 id="如何在-opentelemetry-生态中实现尾采样">如何在 OpenTelemetry生态中实现尾采样？</h2><p>虽然 SDK 不直接支持尾采样，但 OpenTelemetry生态提供了其他方式实现类似功能：</p><h3 id="使用-opentelemetry-collector">1. 使用 OpenTelemetryCollector</h3><p>Collector 提供了 Tail SamplingProcessor，可以在数据聚合层实现尾采样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">tail_sampling:</span></span><br><span class="line">    <span class="attr">decision_wait:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">num_traces:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">expected_new_traces_per_sec:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">policies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">error-policy</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">status_code</span></span><br><span class="line">        <span class="attr">status_code:</span> <span class="string">ERROR</span></span><br></pre></td></tr></table></figure><h3 id="结合前置采样和错误捕获">2. 结合前置采样和错误捕获</h3><p>可以实现一个智能的前置采样器，对特定场景（如包含错误属性）强制采样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SmartSampler <span class="keyword">struct</span> &#123;</span><br><span class="line">    baseSamplingRate <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartSampler)</span></span> ShouldSample(p trace.SamplingParameters) trace.SamplingResult &#123;</span><br><span class="line">    <span class="comment">// 错误请求必采样</span></span><br><span class="line">    <span class="keyword">for</span> _, attr := <span class="keyword">range</span> p.Attributes &#123;</span><br><span class="line">        <span class="keyword">if</span> attr.Key == <span class="string">&quot;error&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> trace.SamplingResult&#123;Decision: trace.RecordAndSample&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他请求使用基础采样率</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">float64</span>(p.TraceID[<span class="number">0</span>])/<span class="number">255.0</span> &lt; s.baseSamplingRate &#123;</span><br><span class="line">        <span class="keyword">return</span> trace.SamplingResult&#123;Decision: trace.RecordAndSample&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> trace.SamplingResult&#123;Decision: trace.Drop&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用专门的后端系统">3. 使用专门的后端系统</h3><p>一些专门的可观测性后端系统提供了尾采样功能：</p><ul><li><p>Jaeger 的 Adaptive Sampling</p></li><li><p>SkyWalking 的 Trace Sampling</p></li><li><p>Grafana Tempo 的 Trace Sampling</p></li></ul><h2 id="结论">结论</h2><p>OpenTelemetry SDK采用前置采样而非尾采样，是基于分布式系统一致性、性能优化和架构分层等多方面考虑的结果。虽然这意味着无法基于完整链路信息做采样决策，但OpenTelemetry 生态提供了多种方式来弥补这一限制。</p><p>在实际应用中，我们可以：</p><ol type="1"><li>在 SDK 层使用智能前置采样策略，确保关键链路被采样</li><li>在 Collector 层实现尾采样，进一步筛选有价值的链路</li><li>结合使用多种采样策略，平衡性能和可观测性</li></ol><p>通过这种分层设计，OpenTelemetry既保证了高效的数据收集，又为高级采样策略提供了可能性，满足了不同场景的需求。</p><div class="tag-plugin quot"><h2 class="content" id="实战案例" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">实战案例</span><span class="empty"></span></h2></div><p>笔者实现一个 Go 语言的开源项目 <code>goapm</code>，对多个 Go语言中常用的组件进行了 trace、log 和 metrics 的集成封装，用于快速在 Go语言项目中实现可观测性，同时还提供了 <code>goapm-example</code>实战案例，可供参考。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/goapm" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/goapm" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/goapm</span><span class="cap link footnote">https://github.com/hedon954/goapm</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/goapm-example" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/goapm-example" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/goapm-example</span><span class="cap link footnote">https://github.com/hedon954/goapm-example</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div>]]></content>
    
    
    <summary type="html">本文介绍了 OpenTelemetry 的采样机制，特别是为什么它在 SDK 层面不支持尾采样。</summary>
    
    
    
    <category term="服务监控" scheme="https://hedon.top/categories/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
    
    <category term="opentelemetry" scheme="https://hedon.top/tags/opentelemetry/"/>
    
    <category term="服务监控" scheme="https://hedon.top/tags/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《悟道领域驱动设计》</title>
    <link href="https://hedon.top/2025/03/11/note-ddd-awareness/"/>
    <id>https://hedon.top/2025/03/11/note-ddd-awareness/</id>
    <published>2025-03-11T06:45:32.000Z</published>
    <updated>2025-06-05T00:39:43.936Z</updated>
    
    <content type="html"><![CDATA[<div class="tag-plugin quot"><h2 class="content" id="思维转变" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">思维转变</span><span class="empty"></span></h2></div><p>领域驱动设计（Domain-Driven Design，以下简称DDD）的核心价值在于其对「业务领域」的深度聚焦。这里的「领域」并非单纯的技术范畴，而是指代软件系统所要映射的现实业务场景及其核心价值主张。DDD通过建立与业务高度契合的领域模型，使得技术实现与业务本质形成同频共振，从而有效解决复杂业务场景下的认知鸿沟问题。</p><p>在 VUCA（Volatile 易变性、Uncertain 不确定性、Complex复杂性、Ambiguous模糊性）特征愈发显著的现代商业环境中，任何架构设计都面临固有局限。这种局限性既源于业务需求本身的动态演进，也受制于人类认知的有限性——正如Eric Evans在开山之作中强调的“<strong>模型永远是对现实的近似抽象</strong>”。但正是这种局限性，凸显了DDD 方法论的战略意义：</p><div class="tag-plugin colorful note" color="blue"><div class="body"><p>它通过"战略设计"构建业务全景图，运用限界上下文划定领域边界，通过"战术设计"落地聚合根、实体/值对象等模式，形成应对复杂性的结构化解决方案。</p></div></div><p>需要特别指出的是，DDD的复杂性并非方法论本身的缺陷，而是其应对现实业务复杂度的必要代价。这种复杂性体现在三个维度：</p><ol type="1"><li><strong>认知复杂性</strong>：要求开发团队与领域专家共建"通用语言"，实现业务概念与代码模型的精准映射。</li><li><strong>架构复杂性</strong>：通过分层架构实现业务逻辑与技术实现的解耦，采用防腐层处理系统集成问题。</li><li><strong>演进复杂性</strong>：借助子域划分和上下文映射，为持续演进的业务提供可扩展的架构基础。</li></ol><p>对于实践者而言，DDD 的价值不在于提供完美无缺的终极方案，而是为 VUCA环境下的系统建设提供基础性指引。其核心思想——无论是通过限界上下文实现的领域自治，还是通过聚合根维护的业务一致性——都为控制软件熵增提供了可落地的模式库。即便不完全采用DDD完整体系，其领域建模思想、分层架构理念等核心要素，仍能显著提升复杂系统的可维护性和演进能力。这种开放包容的哲学，恰是DDD 历经二十年仍保持生命力的关键所在。</p><h3 id="贫血模型-vs.-充血模型">贫血模型 vs. 充血模型</h3><ul><li>贫血模型：指的是只有属性而没有行为的模型。</li><li>充血模型：指的是既有属性又有行为的模型。</li></ul><p>笔者过往的实践中，基本上都使用类似于<code>controller→service→repository[model]</code> 的三层架构：</p><ul><li><code>conrtoller</code> 负责暴露对外接口。</li><li><code>service</code> 负责执行所有的业务逻辑。</li><li><code>repository</code> 复杂数据的存储和缓存，包含数据对象<code>model</code> 的定义。</li></ul><p>在这个模式下，基本上所有的核心逻辑都充斥在 <code>service</code>层中，所以 <code>service</code>层一般都会非常大，它要扮演多面手，即要负责跟各个模块协作，还要负责处理具体的业务规则，最终完成一个业务行为。这个过程中，<code>model</code>即为贫血模型，因为逻辑都给 <code>service</code>处理了，这种架构也称为<strong>贫血三层架构</strong>。</p><p>在 DDD的理念下，很多的核心业务概念都会被建模为「领域对象」，这些「领域对象」本身就是一种业务规则的体现，所以把业务的处理逻辑，都归属到这些「领域对象」的行为当中了，即所谓的充血模型。</p><p>在这个理念下，一个优化后的<strong>充血四层架构</strong>如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250311152623058.png"alt="充血四层架构" /><figcaption aria-hidden="true">充血四层架构</figcaption></figure><p>贫血模型推荐场景：业务简单、迭代快速、团队技术栈偏传统（如 SpringBoot+MyBatis）时，避免过度设计。</p><p>充血模型推荐场景：业务复杂、需长期演进（如核心交易系统）、团队具备DDD 经验时，通过实体、值对象、领域服务等战术设计理念降低系统熵增。</p><p>混合使用的场景：部分核心领域用充血模型（如订单、支付），非核心模块用贫血模型（如日志、配置），平衡效率与质量。</p><p>实际上，充血模型因其状态完整，适合进行<strong>状态变更类</strong>的操作，以确保业务操作符合领域规则；贫血模型由于其轻量级，更适合作为不会涉及状态变更的操作的数据容器。这其实就是CQRS 的理念。</p><div class="tag-plugin quot"><h2 class="content" id="概念清单" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">概念清单</span><span class="empty"></span></h2></div><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/ddd.jpg" /></p><h3 id="战术设计">战术设计</h3><details class="tag-plugin colorful folding" ><summary><p>实体</p></summary><div class="body"><p><strong>定义</strong>：会随着业务变化发生变化的业务概念叫作实体对象。</p><p><strong>关键点</strong>：实体需要唯一表示</p></div></details><details class="tag-plugin colorful folding" ><summary><p>值对象</p></summary><div class="body"><p><strong>定义</strong>：一些对象在表达业务概念时是必须的，可业务并不围绕着它们进行，它们仅是对这些重要业务概念的描述，这一类对象叫作值对象。</p><p><strong>关键点</strong>：</p><ol type="1"><li>值对象的意义取决于属性，只要对象的属性一模一样，那么对象就是相同的。</li><li>尽量把值对象实现为不可变对象。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>领域服务</p></summary><div class="body"><p><strong>定义</strong>：领域服务自身是没有数据的，只是表达了某种业务计算逻辑，或者业务的某种策略。</p><p><strong>关键点</strong>：</p><ol type="1"><li>领域服务是无状态的。</li><li>只有在确实表达了一个相对独立的业务概念或者业务策略，并且不能简单地把它归结到某个既有的业务对象上时，才是一个真正的领域服务。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>领域事件</p></summary><div class="body"><p><strong>定义</strong>：领域事件代表从业务专家视角看到的某种重要的事情发生了。</p><p><strong>关键点</strong>：</p><ol type="1"><li>领域事件是一种特殊的值对象。</li><li>应该根据限界上下文中的通用语言来命名事件：AccountActivited。</li><li>应该将事件建模成值对象或贫血对象。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>聚合</p></summary><div class="body"><p><strong>定义</strong>：聚合从本质上讲是在基础的构造块上增加了一层边界，用边界把那些紧密相关的对象放到了一起。</p><p><strong>关键点</strong>：</p><ol type="1"><li>紧密相关的对象存在数据一致性问题；</li><li>缺乏边界时，维护数据一致性是困难的；</li><li>划分边界的关键在于既不要让整个系统成为一个整体，又让每个单独划分出的聚合具有明确的业务意义；</li><li>聚合需要关注三条法则：<ol type="1"><li>生命周期一致性：如果一个对象在聚合根消失之后仍然有意义，那么说明此时在系统中必然存在能够访问该对象的方法。这和聚合的定义矛盾，所以聚合内的其他元素必然在聚合根消失后失效。</li><li>问题域一致性：不属于同一个问题域的对象，不应该出现在同一个聚合中。</li><li>尽量小的聚合：聚合的本质作用是提升对象系统的粒度，确保一致性、降低复杂度。不过，粒度绝不是越大越好。如果聚合的粒度太大，那内部的逻辑复杂度也会大大增加还会影响到复用度。因此，要能够比较容易地断开聚合。</li></ol></li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>资源库</p></summary><div class="body"><p><strong>定义</strong>：对于查询、创建、修改、删除数据的操作，领域模型使用“资源库(Repository)”这个概念来承载它们。</p><p><strong>关键点</strong>：一个聚合对应一个资源库，应以聚合根命名资源库，除了聚合根之外的其他对象，都不应该提供资源库对象。</p></div></details><details class="tag-plugin colorful folding" ><summary><p>工厂</p></summary><div class="body"><p><strong>定义</strong>：工厂用于构建聚合。</p><p><strong>关键点</strong>：一个聚合往往包含多个对象，这些对象的数据之间又可能存在联系，如果允许分别创建这些对象，就会让聚合是业务完整性的单元这个定义面临失败。</p></div></details><h3 id="战略设计">战略设计</h3><details class="tag-plugin colorful folding" ><summary><p>统一语言</p></summary><div class="body"><p><strong>定义</strong>：与业务专家协作定义全团队通用的术语表，消除沟通歧义。</p><p><strong>关键点</strong>：</p><ol type="1"><li>同一个概念在不同的上下文中可能存在不同的含义；</li><li>同一个概念在同一上下文中的不同环节，也可能存在不同的含义，需要非常明确清晰的界定，降低沟通成本。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>子域</p></summary><div class="body"><p><strong>定义</strong>：子域是对业务领域的逻辑划分，用于分解复杂问题。通常分为<strong>核心子域</strong>（业务核心竞争力）、<strong>支撑子域</strong>（辅助核心业务）和<strong>通用子域</strong>（可复用的标准化能力）。</p><p><strong>关键点</strong>：因业务目标、团队定位和组织发展阶段等方面的不同，这三个子域的划分并非一成不变，而是会互相转换。</p></div></details><details class="tag-plugin colorful folding" ><summary><p>限界上下文</p></summary><div class="body"><p><strong>定义</strong>：限界上下文本质上是一个自治的小世界，它有完备的职责，还有清晰的边界。</p><p><strong>关键点</strong>：</p><ol type="1"><li>一个子域的一切资产，包括领域模型、数据库、包、可执行程序、接口声明等，都应该封装在限界上下文中，避免跨越边界。</li><li>如何平衡边界的价值和不利影响，是划分边界时要做的一种重要取舍。<strong>一个较为稳妥的策略是考虑认知的渐进特征，不要过早隔离。在已经确定的边界上进行划分，延缓划分那些尚具模糊性的边界，在这些边界逐渐变得清晰时再分离它们。</strong></li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>上下文映射</p></summary><div class="body"><p><strong>定义</strong>：限界上下文约定了基于领域模型的架构层次的设计分解，而分解必然意味着集成和协作。上下文映射就是对限界上下文之间的协作关系的模式总结。</p><p><strong>关键点</strong>：</p><ol type="1"><li>在边界上完成概念映射是一种基本模式。通过在应用层组装或者使用适配器完成概念映射，可以保持领域概念的清晰，避免领域模型遭到不必要的污染。</li><li>防腐层模式、标准开放服务模式、客户-供应商模式、追随者模式。</li></ol></div></details><h3 id="串讲">串讲</h3><p>在应对复杂业务系统时，DDD通过<strong>分治策略</strong>将业务领域拆分为多个<strong>子域</strong>（如电商系统的订单、支付子域），每个子域对应一个<strong>限界上下文</strong>——这是技术与业务对齐的关键边界，既承载领域模型的实现，也通过<strong>上下文映射</strong>（如防腐层、共享内核等模式）实现跨子域协作，避免模型污染。</p><p>限界上下文内的<strong>领域对象</strong>是业务逻辑的载体：具备唯一标识和生命周期的<strong>实体</strong>（如订单实体通过ID跟踪状态变化）、描述特征且不可变的<strong>值对象</strong>（如地址由省市构成，修改需整体替换），以及通过<strong>聚合根</strong>统一操作保证一致性的<strong>聚合</strong>（如订单聚合根管理订单项和配送信息）。当业务逻辑跨越多个聚合时，由无状态的<strong>领域服务</strong>协调（如支付计算需整合订单、账户聚合）。</p><p>对象的创建与持久化分别由<strong>工厂</strong>（封装复杂初始化逻辑）和<strong>资源库</strong>（隔离存储细节）负责，而<strong>领域事件</strong>（如订单支付成功事件）则驱动跨上下文的异步协作。</p><div class="tag-plugin quot"><h2 class="content" id="战术设计" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">战术设计</span><span class="empty"></span></h2></div><h3 id="factory">factory</h3><ul><li>factory 用于构建复杂的领域对象。</li></ul><h3 id="repository">repository</h3><ul><li>只有聚合根有 repository。</li><li>repository 就只提供 <code>load</code> 和 <code>save</code>功能，且要保证事务一致性。</li><li>尽可能提供行级的 repository，而不是表级的 repository，对于表级的repository，可以抽成一个领域服务。</li></ul><h3 id="设计模式">设计模式</h3><h4 id="责任链模式">责任链模式</h4><blockquote><p>将请求的发送者和接受者解耦，使多个对象都有机会处理请求。</p></blockquote><ul><li>责任链模式的使用要点在于要将维护责任链的代码和业务代码分开。</li><li>在 DDD中使用责任链模式时，应创建一个领域服务，在领域服务中完成责任链的创建和执行。</li><li>尽量不要在责任链的处理器中通过 <code>set</code>修改领域对象（聚合根）的状态，责任链应仅用于某些值的计算，最终将计算结果交给聚合根完成业务操作。</li></ul><p>笔者实现了一个快速构建责任链的工具：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go</span><span class="cap link footnote">https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><h4 id="策略模式">策略模式</h4><blockquote><p>允许在运行时根据需要选择不同的实现。</p></blockquote><ul><li>在 DDD中使用策略模式时，通常先定义一个领域服务接口，再在其实现类中完成策略的加载、选择和执行。</li><li>注意屏蔽策略模式的实现细节，避免上层关注领域服务内的设计模式细节。</li></ul><h4 id="桥接模式">桥接模式</h4><blockquote><p>旨在通过解耦抽象和实现，使两者能够独立扩展和变化。</p></blockquote><ul><li><strong>多维解耦机制</strong>：桥接模式通过组合/聚合关系替代继承关系，将原本紧密耦合的抽象层（功能定义）与实现层（具体操作）分离例如遥控器（抽象）与电视（实现）的协作，遥控器通过接口控制电视，无需关注具体品牌。</li><li><strong>正交扩展能力</strong>：支持两个独立变化维度（如消息类型与通知渠道、图形与渲染方式），避免类数量呈指数级增长（M×N组合问题）。电商物流系统中，新增微信通知渠道时，无需修改所有消息类即可实现扩展。</li></ul><h4 id="规约模式">规约模式</h4><blockquote><p>规约模式是一种用于定义业务领域中规则和约束的模式，通常由规约接口（Specification）和验证器（Validator）两个部分组成。</p></blockquote><ul><li>在 DDD中，规约模式并不是在聚合根进行业务操作之前做前置校验，而是在聚合根完成业务操作之后做后置校验，确保Repository 保存的聚合根符合业务规则。</li></ul><h4 id="适配器模式">适配器模式</h4><blockquote><p>将<strong>被适配者（Adaptee）的接口</strong>转换为<strong>目标接口（Target）</strong>，使原本因接口不兼容而无法协同工作的类能够协同。</p></blockquote><ul><li>在 DDD中，可以使用适配器模式来实现防腐层，以将外部上下文接口（如开放主机服务）返回的模型转换为本地上下文定义的领域模型，并将本地上下文的操作转换为对外部上下文的操作。可以有效隔离外部上下文的领域模型，避免互相污染。</li></ul><h3 id="领域事件">领域事件</h3><h4 id="幂等性">幂等性</h4><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image.png" /></p><h4 id="领域事件的定义">领域事件的定义</h4><blockquote><p>领域事件是领域模型的组成部分，它通常由聚合根产生，并被其他聚合或者限界上下文订阅和处理，触发相应的业务逻辑。</p></blockquote><p>注意点：</p><ul><li>应该根据限界上下文中的通用语言来命名事件：AccountActivited。</li><li>应该将事件建模成值对象或贫血对象。</li></ul><p>应用：</p><ol type="1"><li>解耦领域对象之间的关系；</li><li>触发其他领域对象的行为；</li><li>记录领域内已发生的状态变化；</li><li>实现跨聚合的最终一致性；</li><li>进行限界上下文集成。</li></ol><p>消息体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;event_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;event_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;entity_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;event_time&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extra_data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="领域事件的生成">领域事件的生成</h4><ol type="1"><li>应用层创建领域事件。</li><li>聚合根创建领域事件。</li></ol><p>要避免在聚合根内部调用基础实施发布领域事件，而是生成后返回给应用层，由应用层去发布。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entity <span class="keyword">struct</span> &#123;</span><br><span class="line">  Events []Event</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e *Entity)</span></span>ResgisterEvent(event Event) &#123;</span><br><span class="line">  e.Events = <span class="built_in">append</span>(e.Events. event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e *Entity)</span></span> GetEvents() []Event &#123;</span><br><span class="line">  res := e.Events()</span><br><span class="line">  e.Events = []Event&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="领域事件的发布">领域事件的发布</h4><ol type="1"><li>直接发布并轮询补偿：为事件存储一个发布状态标识，用于记录是否补发成功。并提供定时任务检索超时未发布成功的事件进行重新发布。</li><li>采用事务日志拖尾：引入变更数据捕获组件（Change Data Capture，简称CDC），捕获数据的变更日志，解析后获得领域事件并发布。</li></ol><h4 id="领域事件的订阅">领域事件的订阅</h4><p>将领域事件订阅者放置在用户接口层<code>user-interface-subscriber</code>，收到事件后调用应用服务执行业务逻辑。</p><h3 id="事件溯源">事件溯源</h3><p>事件溯源（Event Sourcing）是一种将所有的领域事件（DomainEvent）存储到事件存储（EventStore）中，并通过重放历史事件来还原领域对象状态的模式。</p><p>核心思想是将系统中所有的状态变更都视为事件，将这些事件以事件顺序记录下来，并存储到事件存储中。这样，可以通过重放这些事件，来还原任意时刻的系统状态。</p><p>三种方案：</p><ol type="1"><li>通过回放所有的历史事件重建聚合根。</li><li>通过快照提高重建聚合根的效率。</li><li><strong>通过拉链表生成所有事件对应的快照。</strong></li></ol><div class="tag-plugin colorful note" color="green"><div class="body"><p>拉链表是一种用于处理缓慢变化维度问题的数据结构，它可以有效地处理维度数据的历史变化。在拉链表中，每个记录都有一个开始时间和结束时间，用于描述该记录的存活时间，即该记录的有效期。</p></div></div><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250312183214921.png"alt="拉链法示意图" /><figcaption aria-hidden="true">拉链法示意图</figcaption></figure><h3 id="cqrs">CQRS</h3><p>CQRS 将系统的操作分为两类：</p><ul><li><strong>命令（Command）</strong>：负责数据的写操作（增、删、改），不返回数据。</li><li><strong>查询（Query）</strong>：负责数据的读操作，仅返回结果且不修改数据。</li></ul><p>两者的数据模型可独立设计，甚至使用不同的数据库或存储技术。</p><details class="tag-plugin colorful folding" color="blue"><summary><p>适用场景</p></summary><div class="body"><p><strong>应对高并发读写场景</strong></p><ul><li><p>案例 1：B 站点赞系统</p><p>在日均活跃用户近亿的 B 站，点赞功能通过 CQRS分离读写操作。写入端通过消息队列（如Kafka）异步处理请求，避免数据库锁竞争；查询端通过缓存优化读取性能，显著提升系统吞吐量和稳定性。</p></li><li><p>案例 2：实时答题 PK 游戏</p><p>高并发的答题得分计算场景中，CQRS 结合事件溯源（EventSourcing）记录每个操作事件，确保读写模型的最终一致性，同时支持复杂战况数据的实时展示。</p></li></ul><p><strong>解决复杂查询需求</strong></p><ul><li><p>案例 3：电商订单查询</p><p>随着订单查询需求多样化（如按时间筛选、跨实体聚合数据），CQRS通过独立读模型简化查询逻辑，避免领域模型被复杂查询逻辑污染。</p></li><li><p>案例 4：微服务数据聚合</p><p>在微服务架构中，CQRS允许通过事件同步跨服务数据到专用读库，避免跨服务联表查询的性能瓶颈（如行程管理服务与用户信息服务的聚合查询）。</p></li></ul><p><strong>提升数据模型灵活性</strong></p><ul><li><p>案例 5：文本增量更新</p><p>针对大型文本编辑场景，CQRS拆分读写模型，增量保存修改记录并通过事件合并，减少网络传输数据量，同时支持任意版本的历史数据恢复。</p></li></ul></div></details><details class="tag-plugin colorful folding" color="orange"><summary><p>不适用场景</p></summary><div class="body"><ul><li>简单 CRUD 系统（如小型管理后台）</li><li>强一致性要求的金融交易场景（如实时扣款）</li><li>团队缺乏事件驱动架构经验时</li></ul></div></details><h3 id="一致性">一致性</h3><h4 id="聚合内事务实现">聚合内事务实现</h4><ul><li>聚合内事务控制不要放在应用层，会使应用层承担过多的责任。应用层应专注于协调领域对象和基础设施以完成业务操作，不应过多涉及数据访问和事务控制的细节。</li><li>聚合内事务控制可以交给 <code>Repository</code>来实现，采用乐观锁解决并发问题，可以基于版本号和时间戳，一般重试 1-3次即可。</li></ul><h4 id="聚合间事务实现">聚合间事务实现</h4><ul><li><p>聚合间控制可以单独建立一个领域服务 Domain Service来完成。</p></li><li><p>对于实时性要求不高，仅需最终一致性，可以使用<strong>本地消息表</strong>或者<strong>最大努力通知</strong>的方案。</p></li><li><p>对于实时性一致性要求比较高，可以采用<strong>TCC（Try-Confirm-Cancel）</strong> 事务方案。</p></li><li><p>对于长事务场景，或者涉及外部系统、遗留系统，可以考虑<strong>Saga</strong> 事务方案。</p><blockquote><p>Saga将事务分为多个事务，这些分支事务按照一定的顺序执行。当某个分支事务执行成功后，会通过消息通知下一个分支执行；当某个分支事务执行失败时，会按照正常事务执行顺序的相反方向进行一系列的补偿操作，以确保全局事务的一致性。</p></blockquote></li></ul><div class="tag-plugin quot"><h2 class="content" id="战略设计" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">战略设计</span><span class="empty"></span></h2></div><h3 id="事件风暴">事件风暴</h3><h4 id="核心概念与元素">核心概念与元素</h4><table><colgroup><col style="width: 40%" /><col style="width: 5%" /><col style="width: 54%" /></colgroup><thead><tr><th>元素名称</th><th>颜色标识</th><th>说明</th></tr></thead><tbody><tr><td><font color="#FFA500"><strong>领域事件（DomainEvent）</strong></font></td><td>橙色</td><td>表示已发生的业务事实，以“动词过去式”命名（如“订单已提交”），是事件风暴的核心起点。</td></tr><tr><td><font color="#00008B"><strong>命令（Command）</strong></font></td><td>深蓝色</td><td>触发领域事件的操作或意图（如“提交订单”），通常由用户或系统触发。</td></tr><tr><td><font color="#FFFF00"><strong>参与者（Actor）</strong></font></td><td>黄色</td><td>执行命令的角色，包括用户、部门或外部系统（如“客户”触发支付命令）。</td></tr><tr><td><font color="#FFC0CB"><strong>外部系统（ExternalSystem）</strong></font></td><td>粉色</td><td>与当前系统交互的第三方服务（如支付网关回调生成事件）。</td></tr><tr><td><font color="#800080"><strong>策略（Policy）</strong></font></td><td>紫色</td><td>业务规则或约束条件（如“库存不足时取消订单”），决定事件触发的逻辑。</td></tr><tr><td><font color="#008000"><strong>读模型（ReadModel）</strong></font></td><td>绿色</td><td>为查询优化的数据视图（如“用户订单列表”），支持决策展示。</td></tr><tr><td><font color="#FFD700"><strong>聚合（Aggregate）</strong></font></td><td>大黄色</td><td>业务对象集合（如“订单聚合”包含订单项和状态），维护一致性和完整性。</td></tr><tr><td><font color="#FF0000"><strong>问题（Question）</strong></font></td><td>红色</td><td>未达成共识的争议点（如事件定义分歧），需后续专项讨论。</td></tr></tbody></table><h4 id="实施流程与步骤">实施流程与步骤</h4><ol type="1"><li><p><strong>准备工作</strong></p><ul><li><strong>参与人员</strong>：业务专家、开发、产品、测试等跨职能角色，需领域专家主导。</li><li><strong>物料</strong>：多色便签、白板、马克笔，线上工具辅助远程协作。</li></ul></li><li><p><strong>识别领域事件</strong>团队通过头脑风暴罗列所有可能事件（如电商场景的“订单已创建”“库存已扣减”），按时间轴排列，争议事件用红色便签标记并暂存。</p></li><li><p><strong>补充命令与角色</strong>为每个事件关联触发命令及执行者（如“客户”执行“支付订单”命令生成“支付完成”事件），区分内部操作与外部系统调用。</p></li><li><p><strong>定义策略与读模型</strong> 添加业务规则（如“订单金额 ≥1000元需审核”）和数据展示需求（如“实时库存看板”）。</p></li><li><p><strong>构建聚合与划分子域</strong>将相关事件、命令归类为聚合（如“支付聚合”），划分限界上下文（如“订单服务”“库存服务”），明确微服务边界。</p></li></ol><h4 id="注意事项">注意事项</h4><ol type="1"><li><p><strong>事件粒度的把控</strong>：避免过度细化（如“用户已睁眼"）或过于宽泛（如“订单已修改”），需聚焦业务关键节点。</p></li><li><p><strong>争议处理与迭代</strong>：对未达成共识的事件标记为“问题”（红色便签），后续专题讨论；定期回顾模型，修正错误或补充遗漏。</p></li><li><p><strong>技术实现衔接</strong>：事件风暴的输出需转化为代码模型，例如通过事件溯源（EventSourcing）持久化事件流，或结合 CQRS 分离读写逻辑。</p></li></ol><h3 id="c4-架构模型">C4 架构模型</h3><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://c4model.com/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://c4model.com/" autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div><span class="cap link footnote">https://c4model.com/</span></div><div class="bottom"><span class="title">https://c4model.com/</span><span class="cap desc footnote"></span></div></a></div><table><colgroup><col style="width: 11%" /><col style="width: 26%" /><col style="width: 15%" /><col style="width: 46%" /></colgroup><thead><tr><th><strong>层级</strong></th><th><strong>核心目标</strong></th><th><strong>受众</strong></th><th><strong>关键元素</strong></th></tr></thead><tbody><tr><td><strong>Context（上下文）</strong></td><td>描述系统与外部实体（用户、第三方系统）的交互关系</td><td>非技术人员（如业务方、客户）</td><td>系统边界、用户角色、外部依赖（如支付网关）</td></tr><tr><td><strong>Container（容器）</strong></td><td>展示系统内部的高阶技术组件（进程级单元）</td><td>技术管理者、架构师</td><td>Web 应用、数据库、消息队列等独立进程单元，关注技术选型与通信协议（如REST API、gRPC）</td></tr><tr><td><strong>Component（组件）</strong></td><td>细化容器内部的业务模块与交互逻辑</td><td>开发团队</td><td>服务、模块、接口（如订单服务、库存服务），强调职责划分与依赖关系</td></tr><tr><td><strong>Code（代码）</strong></td><td>展示组件实现的代码结构</td><td>开发者</td><td>类、方法、数据库表（如 UML 类图、ER 图），通常由 IDE工具自动生成</td></tr></tbody></table><p>除了四层核心视图，C4 模型还提供：</p><ul><li><strong>部署图</strong>：展示容器在物理环境中的分布（如 Kubernetes集群部署）。</li><li><strong>动态图</strong>：描述业务流程（如用户下单到支付完成的时序交互）。</li><li><strong>系统景观图</strong>：多系统协同的全局视图（如企业级中台架构）。</li></ul><div class="tag-plugin tabs" align="center"id="tab_2"><div class="nav-tabs"><div class="tab active"><a href="#tab_2-1">Context</a></div><div class="tab"><a href="#tab_2-2">Container</a></div><div class="tab"><a href="#tab_2-3">Component</a></div><div class="tab"><a href="#tab_2-4">Code</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_2-1"><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/SystemContext-20250312173256060.png" /></p></div><div class="tab-pane" id="tab_2-2"><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Containers-20250312173305921.png" /></p></div><div class="tab-pane" id="tab_2-3"><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Components-20250312173320890.png" /></p></div><div class="tab-pane" id="tab_2-4"><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/MainframeBankingSystemFacade-20250312173313572.png" /></p></div></div></div><div class="tag-plugin quot"><h2 class="content" id="实践案例" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">实践案例</span><span class="empty"></span></h2></div><p>参考作者的 <ahref="https://github.com/feiniaojin/ddd-archetype">ddd-archetype</a>，笔者实现了一个 Go 版本的 <code>ddd-archetype-go</code>：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon-go-road/ddd-archetype-go" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon-go-road/ddd-archetype-go" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon-go-road/ddd-archetype-go</span><span class="cap link footnote">https://github.com/hedon-go-road/ddd-archetype-go</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><p>整体架构如下：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/ddd-ruoyi.drawio.png" /></p>]]></content>
    
    
    <summary type="html">阅读《悟道领域驱动设计》后的一些笔记和思考。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="ddd" scheme="https://hedon.top/tags/ddd/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.24 新特性解读：使用 testing/synctest 优雅地测试并发代码</title>
    <link href="https://hedon.top/2025/03/06/go-lib-synctest/"/>
    <id>https://hedon.top/2025/03/06/go-lib-synctest/</id>
    <published>2025-03-06T07:00:18.000Z</published>
    <updated>2025-06-05T00:38:50.822Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go语言开发中，并发编程一直是其最引人注目的特性之一。然而，如何有效地测试并发代码却常常让开发者感到头疼。Go1.24 版本引入的实验性包 <code>testing/synctest</code>为这个问题带来了优雅的解决方案。今天，让我们深入了解这个新特性。</p><h1 id="并发测试的传统困境">并发测试的传统困境</h1><p>在介绍新方案之前，我们先看看传统的并发测试面临哪些问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTraditional</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 执行某些操作</span></span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待操作完成</span></span><br><span class="line">    time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">if</span> !done &#123;</span><br><span class="line">        t.Fatal(<span class="string">&quot;操作未完成&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式存在明显的问题：</p><ol type="1"><li><strong>时间依赖</strong>：需要通过 Sleep等待，导致测试运行缓慢</li><li><strong>不稳定性</strong>：在不同环境下可能产生不同结果</li><li><strong>精确性差</strong>：难以准确把握检查时机</li></ol><h1 id="synctest优雅的解决方案">synctest：优雅的解决方案</h1><p><code>testing/synctest</code> 包通过两个核心函数改变了这一切：</p><ul><li><code>Run()</code>: 创建隔离的测试环境（bubble）</li><li><code>Wait()</code>: 等待所有 goroutine 进入稳定状态</li></ul><p>让我们看看如何改写上面的测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWithSynctest</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 执行某些操作</span></span><br><span class="line">            time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">            done = <span class="literal">true</span></span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        synctest.Wait()  <span class="comment">// 等待所有 goroutine 进入稳定状态</span></span><br><span class="line">        <span class="keyword">if</span> !done &#123;</span><br><span class="line">            t.Fatal(<span class="string">&quot;操作未完成&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="深入理解-wait-机制">深入理解 Wait 机制</h1><h2 id="wait-的本质">Wait 的本质</h2><p>很多开发者初次接触 <code>Wait()</code>时可能会感到困惑：它到底在等待什么？什么时候会返回？</p><p>想象一个场景：你在拍摄一张全家福，需要等待所有人都找到自己的位置，站好不动，才能按下快门。<code>Wait()</code>就像这个摄影师，它在等待所有goroutine（就像照片中的人）都进入一个稳定的状态（站好不动）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 类比：三个人要拍全家福</span></span><br><span class="line">    <span class="keyword">go</span> person1()  <span class="comment">// 第一个人找位置</span></span><br><span class="line">    <span class="keyword">go</span> person2()  <span class="comment">// 第二个人找位置</span></span><br><span class="line">    <span class="keyword">go</span> person3()  <span class="comment">// 第三个人找位置</span></span><br><span class="line"></span><br><span class="line">    synctest.Wait()  <span class="comment">// 等待所有人都站好不动</span></span><br><span class="line">    <span class="comment">// 这时可以安全地&quot;按下快门&quot;（检查程序状态）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="为什么需要-wait">为什么需要 Wait？</h2><p>在并发程序中，我们经常需要在特定时刻检查程序状态。但是，如果某些goroutine 还在运行，这个状态可能随时发生变化。<code>Wait()</code>通过确保所有 goroutine 都进入稳定状态，为我们提供了一个"快照"时刻。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        result = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    synctest.Wait()  <span class="comment">// 等待 goroutine 进入稳定状态</span></span><br><span class="line">    <span class="comment">// 此时 result 的值是确定的，不会突然改变</span></span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="持久阻塞的概念">持久阻塞的概念</h2><p>哪些操作会导致持久阻塞？</p><ul><li>channel 操作（同一 bubble 内）</li><li>time.Sleep</li><li>sync.WaitGroup.Wait</li><li>sync.Cond.Wait</li></ul><p>哪些操作不算持久阻塞？</p><ul><li>互斥锁操作</li><li>外部 I/O</li><li>外部 channel 操作</li></ul><h1 id="虚拟时钟测试的神器">虚拟时钟：测试的神器</h1><p><code>synctest</code> 的另一个强大特性是虚拟时钟机制。在 bubble内部，所有时间相关的操作都使用虚拟时钟，这意味着：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 看似等待24小时</span></span><br><span class="line">    time.Sleep(<span class="number">24</span> * time.Hour)</span><br><span class="line">    <span class="comment">// 实际上立即执行完成！</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个特性让我们能够：</p><ol type="1"><li>快速测试长时间操作</li><li>精确控制时间流逝</li><li>避免测试的不确定性</li></ol><h1 id="实战案例深入理解-http-100-continue-测试">实战案例：深入理解 HTTP100 Continue 测试</h1><h2 id="背景知识">背景知识</h2><p>HTTP 的 100 Continue 机制是一个优化大文件上传的协议特性：</p><ol type="1"><li>客户端想上传大文件时，先发送带有 "Expect: 100-continue"头的请求</li><li>服务器可以决定是否接受这个上传：<ul><li>如果接受，返回 "100 Continue"</li><li>如果拒绝，可以直接返回错误状态码</li></ul></li><li>客户端根据服务器的响应决定是否发送文件内容</li></ol><h2 id="详细测试实现">详细测试实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHTTPContinue</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 第一步：建立测试环境</span></span><br><span class="line">        srvConn, cliConn := net.Pipe()</span><br><span class="line">        <span class="keyword">defer</span> srvConn.Close()</span><br><span class="line">        <span class="keyword">defer</span> cliConn.Close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二步：配置 HTTP 客户端</span></span><br><span class="line">        tr := &amp;http.Transport&#123;</span><br><span class="line">            DialContext: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, address <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cliConn, <span class="literal">nil</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ExpectContinueTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三步：准备测试数据</span></span><br><span class="line">        body := <span class="string">&quot;request body&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第四步：发送请求</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            req, _ := http.NewRequest(<span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;http://test.tld/&quot;</span>,</span><br><span class="line">                strings.NewReader(body))</span><br><span class="line">            req.Header.Set(<span class="string">&quot;Expect&quot;</span>, <span class="string">&quot;100-continue&quot;</span>)</span><br><span class="line">            resp, err := tr.RoundTrip(req)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                t.Errorf(<span class="string">&quot;请求失败: %v&quot;</span>, err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.Body.Close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第五步：验证请求头</span></span><br><span class="line">        req, err := http.ReadRequest(bufio.NewReader(srvConn))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;读取请求失败: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第六步：验证请求体未发送</span></span><br><span class="line">        <span class="keyword">var</span> gotBody strings.Builder</span><br><span class="line">        <span class="keyword">go</span> io.Copy(&amp;gotBody, req.Body)</span><br><span class="line">        synctest.Wait()</span><br><span class="line">        <span class="keyword">if</span> got := gotBody.String(); got != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;在发送 100 Continue 之前，意外收到请求体: %q&quot;</span>, got)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第七步：发送 100 Continue</span></span><br><span class="line">        srvConn.Write([]<span class="type">byte</span>(<span class="string">&quot;HTTP/1.1 100 Continue\r\n\r\n&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第八步：验证请求体</span></span><br><span class="line">        synctest.Wait()</span><br><span class="line">        <span class="keyword">if</span> got := gotBody.String(); got != body &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;收到的请求体 %q，期望 %q&quot;</span>, got, body)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第九步：完成请求</span></span><br><span class="line">        srvConn.Write([]<span class="type">byte</span>(<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试的关键点解析">测试的关键点解析</h2><ol type="1"><li><p><strong>使用 net.Pipe()</strong></p><ul><li>创建内存中的网络连接</li><li>避免依赖真实网络</li><li>保证测试的可重复性</li></ul></li><li><p><strong>请求发送过程</strong></p><ul><li>在独立的 goroutine 中发送请求</li><li>设置 "Expect: 100-continue" 头</li><li>准备要发送的请求体</li></ul></li><li><p><strong>验证关键行为</strong></p><ul><li>确认请求头正确发送</li><li>验证请求体在收到 100 Continue 之前未发送</li><li>验证请求体在收到 100 Continue 后正确发送</li></ul></li><li><p><strong>使用 Wait 的时机</strong></p><ul><li>在检查请求体之前调用 Wait</li><li>确保所有数据传输操作都已完成或阻塞</li><li>获得稳定的程序状态进行验证</li></ul></li></ol><h1 id="使用建议">使用建议</h1><ol type="1"><li><strong>明确边界</strong>：理解什么操作会导致持久阻塞，什么不会</li><li><strong>清理资源</strong>：确保所有 goroutine 在测试结束前退出</li><li><strong>模拟 I/O</strong>：使用内存管道替代真实网络连接</li><li><strong>合理使用 Wait</strong>：在需要检查状态的关键点调用</li></ol><h1 id="注意事项">注意事项</h1><ol type="1"><li>目前是实验性功能，需要设置 <code>GOEXPERIMENT=synctest</code></li><li>不支持测试真实的外部 I/O 操作</li><li>互斥锁操作不被视为持久阻塞</li></ol>]]></content>
    
    
    <summary type="html">本文介绍了 Go 1.24 版本引入的实验性包 testing/synctest，并详细讲解了如何使用它优雅地测试并发代码。</summary>
    
    
    
    <category term="go" scheme="https://hedon.top/categories/go/"/>
    
    
    <category term="go" scheme="https://hedon.top/tags/go/"/>
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
