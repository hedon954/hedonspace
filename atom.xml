<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HedonSpace</title>
  
  
  <link href="https://hedon.top/atom.xml" rel="self"/>
  
  <link href="https://hedon.top/"/>
  <updated>2025-01-15T11:57:12.315Z</updated>
  <id>https://hedon.top/</id>
  
  <author>
    <name>Hedon Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读书笔记丨解密 QUIC/HTTP3：未来互联网的基石</title>
    <link href="https://hedon.top/2025/01/15/book-quic-http3/"/>
    <id>https://hedon.top/2025/01/15/book-quic-http3/</id>
    <published>2025-01-15T11:17:20.000Z</published>
    <updated>2025-01-15T11:57:12.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="quic-产生背景">1. QUIC 产生背景</h1><h2 id="常见网络协议">常见网络协议</h2><ul><li><code>UDP</code></li><li><code>TCP</code></li><li><code>SCTP</code>（Stream Control TransmissionProtocol）：用于电话网络。</li><li><code>KCP</code>：基于 UDP在应用层实现可靠性传输，牺牲带宽换取效率。</li><li><code>RTP</code>（Real-time Transport Protocol）：与 RTCP配合传输实时数据，如交互式音频和视频数据。<ul><li>RTCP：传输控制信息</li><li>RTP：传输实时数据</li></ul></li></ul><h2 id="tsl-版本演化">TSL 版本演化</h2><ul><li><p><code>SSLv2</code>：安全性低</p></li><li><p><code>SSLv3</code>：分为握手阶段和数据传输阶段。</p><ul><li>握手阶段完成对端点的认证和确定保护数据传输的密钥。</li><li>一旦确定了密钥，后面的数据传输和SSL协议过程都受到加密和完整性保护。</li></ul></li><li><p><code>TSL1.0</code>：基于 SSLv3，存在 CBC（Cipher BlockChaining，密文分组链接）加密和解密模式漏洞，使得主动攻击者可以观察到当前记录的IV（IntiallizationVector，初始化向量），猜测一个数据库，进行数据注入。</p></li><li><p><code>TSL1.1</code>：修复了 TSL1.0 的一些关键安全问题：</p><ul><li>BC 加密使用每条记录一个的显式IV；</li><li>为了防止 CBC 填充攻击，使用 bad_record_mac 错误码代替decryption_failed 回复填充错误；</li><li>支持传输参数的IANA（Internet Assigned NumbersAuthority，互联网数字分配机构）注册，增加了传输参数的灵活性；</li><li>改进了连接关闭过早情况下的连接恢复问题。</li></ul><p>有些加密算法还是存在安全漏洞，使用的 MD5 也不安全。</p></li><li><p><code>TSL1.2</code>：主要关注了架构灵活性和安全问题。</p><ul><li>架构：<ul><li>客户端可以指定自己支持的签名和 hash 算法列表；</li><li>支持非协议固定的算法；</li></ul></li><li>安全：<ul><li>增加了对 AEAD（Authenticated Encryption with Associated Data关联数据认证加密）的支持，可以在加密中认证没有加密部分的关键数据，甚至是不在报文中的关键数据，可以保护更大的范围。</li><li>规定必须实现密码套件 TLS_RSA_WITH_AES_128_CBC_SHA。</li><li>增加了 HMAC-SHA256 密码套件。</li><li>删除了包含已废弃算法的 IDEA 和 DES 密码套件。</li><li>对 EncryptedPreMasterSecret 版本号进行了更严格的检查。</li></ul></li></ul></li><li><p><code>TSL1.3</code>：除了增加安全性，重点改进了连接速度，首次连接发送数据最低可以1-RTT，恢复连接发送数据最低可以 0-RTT。</p><ul><li>安全：<ul><li>删除了所有被证明有问题的对称加密算法，只保留了 AEAD的加密套件。密码套件的概念也已经改变，将认证和密钥交换机制与加密算法和散列（用于密钥导出函数和握手消息认证码）分离。</li><li>删除 RSA 和静态 DH 密码套件，因为静态 RSA加密预主密钥的方式和使用静态 DH私钥都不能保证前向安全性，很容易泄露密钥。只保留能保证前向安全的密钥交换算法，如使用临时私钥的ECDHE（Elliptic Curve Diffie-Hellman Ephemeral，椭圆曲线 DH临时密钥交换算法）和 DHE（Diffie-Hellman Ephemeral, DH临时密钥交换算法）。</li><li>ServerHello 之后的消息都加密传输。</li><li>删除了压缩功能。之前版本的压缩功能由于存在被攻击的风险实际上很少使用，而且现代的压缩基本都在应用层实现，比如HTTP就自己实现的压缩。</li></ul></li></ul></li></ul><h2 id="http-版本演化">HTTP 版本演化</h2><ul><li><p><code>HTTP0.9</code>：仅支持简单的请求响应，只能访问<strong>简单的文本</strong>文档。</p></li><li><p><code>HTTP1.0</code>：HTTP1中引入了<strong>请求头和响应头</strong>，请求时可以指定 HTTP版本号、用户代理、接收类型等，响应可以指明响应状态、内容长度、内容类型等。</p></li><li><p><code>HTTP1.1</code>：增加了<strong>重用 TCP连接</strong>（keep-alive）的方法，默认保持连接，除非显式通知关闭连接[插图]。这样可以在一个TCP 连接上完成多个请求-响应，消除了 TCP 建立的延迟，也避免了新建立的 TCP连接的慢启动过程。</p><ul><li>HTTP1.1 在 HTTP 请求首部中增加了 Host 字段，用来支持共享 IP地址的虚拟主机服务器。</li><li>同时支持了更多的方法，如 PUT、PATCH、DELETE、OPTIONS。</li><li>引入分块传输支持动态内容。</li><li>引入了更多的缓存控制策略。</li><li>支持请求部分内容。</li></ul></li><li><p><code>HTTP2</code>：修改了 HTTP1.1的封装格式，增加了一个二进制分帧层。基于二进制分层，HTTP2 实现了 HTTP的<strong>多路复用</strong>。HTTP2为每个请求分配了一个流标识，服务器响应时带上相同的流标识，客户端就可以方便地将响应与请求关联起来，而不用依赖顺序，从而可以降低延迟和提高吞吐量。</p><ul><li>HTTP2 还增加了首部压缩 HPACK（Header Compression for HTTP2，HTTP2首部压缩算法）。</li><li>支持请求优先级。</li><li>支持服务器主动推送。</li><li>增加了 ALPN（Application-Layer ProtocolNegotiation，应用层协议协商）。</li><li>支持认证、加密和完整性保护，即 <code>HTTPS</code>。</li></ul><p>但多个请求或响应在同一个 TCP 上发送时，仍然受制于 TCP的队首阻塞问题。</p></li><li><p><code>HTTP3</code>：基于 <code>QUIC</code> 协议，底层使用 UDP实现，摆脱了 TCP 的队首阻塞问题。同时改进了 TCP中存在的一些其他问题，比如拥塞控制、协议僵化、启动慢、重连慢、安全弱等。</p><ul><li>实现了没有队首阻塞的并发。如果 QUIC丢了一个报文，仅仅影响对应流的交付，不会阻塞其他流。</li><li>与 TLS1.3 紧密合作，尽可能的加密。还增加了 QUIC报文的首部加密，除保证了报文安全性，提高了攻击门槛，还避免了协议僵化。</li><li>选择 UDP 作为底层实现。一方面避免了 TCP的首部阻塞，另一方面互联网中绝大部分的主机和中间件都是 TCP 和 UDP的天下，所以天然支持。</li><li>用户态实现。不依赖于内核，容易单独升级。</li><li>低延迟的建立。实现了首次最低 1-RTT发送应用数据，恢复连接时发送应用数据最低只需 0-RTT。</li><li>无缝的连接迁移。QUIC 的连接基于连接标识，改变 IP 或者 UDP端口号并不影响连接的识别，因此可以实现无缝的连接迁移。但是负载均衡就麻烦了。</li><li>改进的流量控制。</li><li>协议行为作为负载。</li></ul></li></ul><h1 id="quic-报文">2. QUIC 报文</h1>]]></content>
    
    
    <summary type="html">整理阅读《解密 QUIC/HTTP3：未来互联网的基石》笔记。</summary>
    
    
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="QUIC" scheme="https://hedon.top/tags/QUIC/"/>
    
    <category term="HTTP3" scheme="https://hedon.top/tags/HTTP3/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>匠心码道丨01 编写优质代码的十大黄金法则</title>
    <link href="https://hedon.top/2024/12/12/clean-code-10-rules/"/>
    <id>https://hedon.top/2024/12/12/clean-code-10-rules/</id>
    <published>2024-12-12T02:22:49.000Z</published>
    <updated>2024-12-12T02:47:27.499Z</updated>
    
    <content type="html"><![CDATA[<p>代码质量的优劣直接影响着项目的可维护性和团队的开发效率。一个经验丰富的开发者不仅要能实现功能，更要善于编写清晰易懂、结构合理的代码。本文将介绍10 条帮助你编写清晰、易维护且可扩展代码的重要规则。</p><h1 id="规则">规则</h1><h2 id="使用有意义的变量和函数名称">1. 使用有意义的变量和函数名称</h2><p>变量、函数和类的命名应该具有描述性和意义。你的代码应该能够清晰地表达其意图，而无需额外的注释来解释。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">get</span>();<br><span class="hljs-keyword">const</span> arr = users.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.<span class="hljs-property">a</span> === <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> maxRetries = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> currentDate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-keyword">const</span> userResponse = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">getUserProfile</span>();<br><span class="hljs-keyword">const</span> activeUsers = users.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.<span class="hljs-property">isActive</span> === <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure></p><p>有意义的命名能讲述代码的故事。读者应该能够仅通过名称就理解变量或函数的用途。</p><p>💡实践建议：</p><ul><li>使用动词前缀命名函数：<code>getUserProfile()</code>、<code>validateInput()</code>、<code>calculateTotal()</code></li><li>使用名词命名变量：<code>userCount</code>、<code>activeUsers</code>、<code>orderStatus</code></li><li>布尔值使用 is/has/should等前缀：<code>isValid</code>、<code>hasPermission</code>、<code>shouldUpdate</code></li></ul><h2 id="保持函数简短且专注">2. 保持函数简短且专注</h2><p>函数应该保持简短，并且只做一件事。函数承担的责任越多，测试、调试和理解起来就越困难。</p><p><strong>反面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_order</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-comment"># 多个责任：验证、定价、折扣、配送等</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">validate_order</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_total</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">apply_discount</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></p><p>每个函数应该只有一个责任。如果你需要用"和"来描述函数的功能，那么这个函数可能做得太多了。</p><p>💡 最佳实践：</p><ul><li>函数建议保持在 20-30 行以内</li><li>如果超过 50 行，应该考虑拆分</li><li>一个函数最好不要超过 3 个参数</li></ul><h2 id="避免深层嵌套">3. 避免深层嵌套</h2><p>深层嵌套的循环和条件语句会使代码难以理解。通过使用提前返回、函数拆分或将大问题分解为小问题来使代码扁平化。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (user.<span class="hljs-title function_">isActive</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (order != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-title function_">processOrder</span>(order);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || !user.<span class="hljs-title function_">isActive</span>()) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (order == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-title function_">processOrder</span>(order);<br></code></pre></td></tr></table></figure></p><p>提前返回可以减少读者的认知负担，使代码更简单、更容易理解。</p><h2 id="明智地使用注释">4. 明智地使用注释</h2><p>注释不应该解释代码做了什么；代码本身应该是自解释的。只在必要时使用注释来解释复杂逻辑背后的"原因"，而不是"是什么"。</p><p><strong>反面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 设置用户状态为激活</span><br><span class="hljs-variable">$user</span>-&gt;isActive = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 登录成功后将用户标记为激活状态</span><br><span class="hljs-variable">$user</span>-&gt;isActive = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure></p><p>注释应该增加价值，解释特定实现背后的原因或解释复杂的业务逻辑。</p><h2 id="保持一致的格式">5. 保持一致的格式</h2><p>一致的代码格式使代码更容易阅读和导航。在项目中使用统一的缩进、间距和对齐方式。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-keyword">return</span> a+b;&#125;<br></code></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>许多团队使用 Prettier 或 ESLint等工具来自动格式化并强制执行代码风格规则。</p><h2 id="不要重复自己dry-原则">6. 不要重复自己（DRY 原则）</h2><p>代码重复会导致不一致、bug 和不必要的复杂性。应用 DRY原则可以保持代码库精简，更易于维护。</p><p><strong>反面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> (<span class="hljs-variable">$userType</span> == <span class="hljs-string">&quot;admin&quot;</span>) &#123;<br>    <span class="hljs-comment">// 复杂逻辑</span><br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$userType</span> == <span class="hljs-string">&quot;superadmin&quot;</span>) &#123;<br>    <span class="hljs-comment">// 相同的复杂逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">userIsAdmin</span>(<span class="hljs-variable">$userType</span>)) &#123;<br>    <span class="hljs-comment">// 复杂逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过将共同逻辑抽象到函数、类或工具中来避免代码重复。</p><h2 id="单一责任原则srp">7. 单一责任原则（SRP）</h2><p>每个类和函数应该只有一个改变的理由。遵循单一责任原则使代码模块化，更容易重构。</p><p><strong>反面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendEmail</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendEmail</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>承担太多责任的类更难维护。SRP 使代码更模块化，更容易测试。</p><h2 id="避免魔法数字和字符串">8. 避免魔法数字和字符串</h2><p>魔法数字（或字符串）是没有上下文或解释的硬编码值。使用常量或枚举代替，这样可以增加代码的清晰度。</p><p><strong>反面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">discount = <span class="hljs-number">0.05</span><br><span class="hljs-keyword">if</span> user.role == <span class="hljs-string">&quot;admin&quot;</span>:<br></code></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">DISCOUNT_RATE = <span class="hljs-number">0.05</span><br>ADMIN_ROLE = <span class="hljs-string">&quot;admin&quot;</span><br>discount = DISCOUNT_RATE<br><span class="hljs-keyword">if</span> user.role == ADMIN_ROLE:<br></code></pre></td></tr></table></figure></p><p>常量为数字或字符串提供了含义，使代码更容易理解。</p><h2 id="编写测试">9. 编写测试</h2><p>单元测试和集成测试确保你的代码按预期工作，并且在进行更改时不会出错。编写测试使代码更可靠，长期更易于维护。</p><p><strong>反面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法没有测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processOrder</span><span class="hljs-params">(Order order)</span> &#123;<br>    <span class="hljs-comment">// 逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testProcessOrder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>    <span class="hljs-comment">// 断言</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>测试应该成为你工作流程的一部分，确保代码无 BUG 且稳定。</p><h2 id="保持简单kiss-原则">10. 保持简单（KISS 原则）</h2><p>KISS（Keep It Simple,Stupid）原则提醒我们简单是关键。复杂的解决方案会导致混淆，更难维护。在面对决策时，选择最简单、最直接的方案来满足需求。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 过度复杂的购物车商品总价计算</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateTotal</span>(<span class="hljs-params">items</span>) &#123;<br>    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> discount = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 复杂的折扣计算逻辑</span><br>    items.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (item.<span class="hljs-property">category</span> === <span class="hljs-string">&#x27;electronics&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (item.<span class="hljs-property">price</span> &gt; <span class="hljs-number">1000</span>) &#123;<br>                discount += item.<span class="hljs-property">price</span> * <span class="hljs-number">0.1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.<span class="hljs-property">price</span> &gt; <span class="hljs-number">500</span>) &#123;<br>                discount += item.<span class="hljs-property">price</span> * <span class="hljs-number">0.05</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.<span class="hljs-property">category</span> === <span class="hljs-string">&#x27;books&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (item.<span class="hljs-property">quantity</span> &gt; <span class="hljs-number">3</span>) &#123;<br>                discount += item.<span class="hljs-property">price</span> * item.<span class="hljs-property">quantity</span> * <span class="hljs-number">0.15</span>;<br>            &#125;<br>        &#125;<br>        total += item.<span class="hljs-property">price</span> * item.<span class="hljs-property">quantity</span>;<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> total - discount;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 将复杂逻辑拆分成小函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateDiscount</span>(<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-keyword">if</span> (item.<span class="hljs-property">category</span> === <span class="hljs-string">&#x27;electronics&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> item.<span class="hljs-property">price</span> &gt; <span class="hljs-number">1000</span> ? <span class="hljs-number">0.1</span> : (item.<span class="hljs-property">price</span> &gt; <span class="hljs-number">500</span> ? <span class="hljs-number">0.05</span> : <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (item.<span class="hljs-property">category</span> === <span class="hljs-string">&#x27;books&#x27;</span> &amp;&amp; item.<span class="hljs-property">quantity</span> &gt; <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.15</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateTotal</span>(<span class="hljs-params">items</span>) &#123;<br>    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> discount = <span class="hljs-title function_">calculateDiscount</span>(item);<br>        <span class="hljs-keyword">const</span> itemTotal = item.<span class="hljs-property">price</span> * item.<span class="hljs-property">quantity</span>;<br>        <span class="hljs-keyword">return</span> total + itemTotal * (<span class="hljs-number">1</span> - discount);<br>    &#125;, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>💡 最佳实践：</p><ul><li>将复杂逻辑拆分成小的、容易理解的函数</li><li>避免在一个函数中处理过多的条件判断</li><li>使用清晰的命名来表达意图</li><li>保持函数的单一职责</li></ul><h1 id="总结">总结</h1><p>干净的代码对于可维护性、可读性和协作至关重要。遵循这 10条规则——使用有意义的命名、保持函数简短、避免魔法数字、编写测试等，将会带来更健壮、更易理解和更易扩展的代码库。编写代码不仅仅是要让它能工作，更要让其他人（包括未来的你）能够轻松理解和扩展。</p><h1 id="代码审查清单">代码审查清单</h1><p>在提交代码前，可以使用以下清单进行自查：</p><ul class="task-list"><li><label><inputtype="checkbox" />变量和函数名称是否具有描述性</label></li><li><label><input type="checkbox" />函数是否只做一件事</label></li><li><label><input type="checkbox" />是否存在重复代码</label></li><li><label><input type="checkbox" />是否有未使用的魔法数字</label></li><li><label><input type="checkbox" />是否编写了相应的测试</label></li><li><label><input type="checkbox" />代码格式是否统一</label></li><li><label><input type="checkbox" />注释是否有价值</label></li><li><label><input type="checkbox" />嵌套是否过深</label></li></ul><h1 id="参考">参考</h1><ul><li><ahref="https://www.thecodingdev.com/2024/09/top-10-clean-code-rules-every-developer.html?ref=dailydev">top-10-clean-code-rules-every-developer-should-follow</a></li></ul>]]></content>
    
    
    <summary type="html">详解编写整洁代码的十大原则，帮你写出更好的代码。</summary>
    
    
    
    <category term="匠心码道" scheme="https://hedon.top/categories/%E5%8C%A0%E5%BF%83%E7%A0%81%E9%81%93/"/>
    
    
    <category term="编程规范" scheme="https://hedon.top/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
    <category term="代码质量" scheme="https://hedon.top/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
    <category term="最佳实践" scheme="https://hedon.top/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Rust 入门丨01 类型系统概述</title>
    <link href="https://hedon.top/2024/11/28/rust-01-type-system/"/>
    <id>https://hedon.top/2024/11/28/rust-01-type-system/</id>
    <published>2024-11-28T09:52:47.000Z</published>
    <updated>2024-11-28T11:02:06.988Z</updated>
    
    <content type="html"><![CDATA[<p>在 Rust 编程世界中，绝大部分的特性和能力都离不开 Rust强大的类型系统，所以在这个系列的第 1 篇我们先来对 Rust的类型系统做一个全局概述，希望可以帮助你建立起对 Rust的基本印象。在后续的实践过程中，我推荐你可以经常回来思考下为什么 Rust要构建这样的类型系统，在每一个分支点是如何做出决策的，这些决策又体现在代码的哪些地方。相信这样可以帮助你更好地入门Rust。</p><p>废话不多说，进入正文。</p><h1 id="什么是类型系统">什么是类型系统？</h1><p>在进入 Rust类型系统讨论之前，我们先尝试占在更高的角度，即整个编程语言界的角度去思考，<font color="red">什么是类型系统？</font></p><blockquote><p>编程语言的类型系统是指一套规则，用于定义和管理程序中数据的类型。类型系统的主要目的是帮助捕获程序中的错误，提高代码的可靠性和可读性。</p></blockquote><p>类型系统可以根据多种特性进行分类，主要包括以下几个方面：</p><ol type="1"><li><strong>静态类型和动态类型</strong>：<ul><li><strong>静态类型</strong>：在编译时检查变量类型。例如，Java、C++ 和Haskell都是静态类型语言。在这些语言中，变量的类型必须在编译时确定，这样可以在编译阶段捕获许多类型错误。</li><li><strong>动态类型</strong>：在运行时检查变量类型。例如，Python、Ruby和 JavaScript是动态类型语言。在这些语言中，变量的类型是在程序运行时确定的，这提供了更大的灵活性，但也可能导致运行时错误。</li></ul></li><li><strong>强类型和弱类型</strong>：<ul><li><strong>强类型</strong>：严格限制不同类型之间的操作。例如，Python 和Java是强类型语言。强类型系统通常不允许隐式类型转换，这意味着在进行不同类型之间的操作时，必须显式地进行类型转换。</li><li><strong>弱类型</strong>：允许更多隐式类型转换。例如，JavaScript 和Perl是弱类型语言。在这些语言中，编译器或解释器会在需要时自动进行类型转换，这可能导致难以预料的行为。</li></ul></li><li><strong>显式类型和隐式类型</strong>：<ul><li><strong>显式类型</strong>：程序员必须明确声明每个变量的类型。例如，Java和 C++ 要求在声明变量时指定其类型。</li><li><strong>隐式类型</strong>：编译器或解释器会根据上下文自动推断变量的类型。例如，Python和 JavaScript 使用隐式类型，程序员不需要显式声明变量类型。</li></ul></li><li><strong>子类型和多态</strong>：<ul><li><strong>子类型</strong>：一种类型系统允许一种类型作为另一种类型的子集。例如，在面向对象编程中，子类是父类的子类型。</li><li><strong>多态</strong>：允许一个接口被多种不同类型实现。多态性有多种形式，包括参数多态（如泛型）和子类型多态（如继承）。</li></ul></li><li><strong>类型推断</strong>：<ul><li>类型推断是指编译器自动确定表达式的类型，而无需明确的类型注释。例如，Haskell和 Scala 使用类型推断来减少程序员的负担，同时保持静态类型的安全性。</li></ul></li><li><strong>代数数据类型和类型构造</strong>：<ul><li>代数数据类型（ADT）是通过组合其他类型来构造新类型的机制，常见于函数式编程语言，如Haskell 和 OCaml。ADT 包括产品类型（如元组）和和类型（如枚举）。</li></ul></li><li><strong>结构类型和名义类型</strong>：<ul><li><strong>结构类型</strong>：基于对象的结构来确定类型的兼容性。例如，TypeScript和 Go 使用结构类型系统。</li><li><strong>名义类型</strong>：基于名称来确定类型的兼容性。例如，Java 和C++ 使用名义类型系统。</li></ul></li></ol><p>这里我梳理了一张图，供你参考：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241128183852984.png"alt="编程语言类型系统" /><figcaption aria-hidden="true">编程语言类型系统</figcaption></figure><blockquote><p>注：本图参考了陈天老师在 Rust训练营课程上提供的教案并进行了增改。</p></blockquote><h1 id="rust-类型系统">Rust 类型系统</h1><p>Rust为了在提供高性能的同时保证内存安全和线程安全，花了大量力气构建了一个强大的类型系统。</p><p>基于之前提到的七个方面，我们来梳理下 Rust 的类型系统：</p><ol type="1"><li><p><strong>静态类型</strong>：Rust是静态类型语言，这意味着变量的类型在编译时就被确定。这种设计使得 Rust在编译阶段就可以捕获许多类型错误，从而提高代码的安全性和性能。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>; <span class="hljs-comment">// 明确指定类型</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>强类型</strong>：Rust是强类型语言，它严格限制不同类型之间的操作。Rust不允许隐式类型转换（例如，不能自动将整数转换为浮点数），需要显式地使用as 进行类型转换。这种严格性有助于避免许多常见的编程错误。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: <span class="hljs-type">f64</span> = <span class="hljs-number">10.0</span>;<br><br>    <span class="hljs-comment">// 错误：不能将 i32 隐式转换为 f64</span><br>    <span class="hljs-comment">// let sum = x + y;</span><br><br>    <span class="hljs-comment">// 正确：需要显式转换</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = x <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> + y;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Sum = &#123;&#125;&quot;</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>显式类型和类型推断</strong>：虽然 Rust是显式类型语言，要求在某些情况下声明变量类型，但它也具有强大的类型推断能力。编译器可以根据上下文推断出大多数变量的类型，减少了程序员的负担。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[];<br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">5u8</span>);  <span class="hljs-comment">// 结合这里，Rust 编译器可以推断出 v 的类型是 Vec&lt;u8&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>子类型和多态</strong>：Rust 支持泛型和trait，这是一种多态性的实现方式。trait类似于接口，允许定义类型可以实现的一组方法。泛型允许定义函数、结构体和枚举时使用占位类型，从而实现代码的重用和灵活性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 这里 std::fmt::Display 就是一个 trait，目前，你可以先简单理解为 trait 就是接口</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_value</span>&lt;T: std::fmt::Display&gt;(value: T) &#123;  <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, value);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">print_value</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 42 默认为 i32，标准库为其是实现了 Display trait</span><br>    <span class="hljs-title function_ invoke__">print_value</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>); <span class="hljs-comment">// &amp;str 也实现了 Display trait</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>类型推断</strong>：Rust的类型推断系统非常强大，能够根据代码上下文自动推断变量和表达式的类型。这使得代码更简洁，同时保持了类型安全性。</p></li><li><p><strong>代数数据类型和类型构造</strong>：Rust支持代数数据类型，通过枚举（enum）和结构体（struct）来实现。枚举允许定义一个类型，该类型可以是几种不同的变体之一，每个变体可以携带不同的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>结构类型和名义类型</strong>：Rust使用名义类型系统。每个类型都有一个显式的名称，类型的兼容性基于名称而不是结构。这意味着即使两个结构体有相同的字段，它们也被视为不同的类型，除非通过特征或显式转换来实现兼容性。</p></li></ol><p>除此之外，Rust的类型系统还提供了其他非常强大且有用的特效，如所有权和借用、生命周期以及模式匹配。</p><ul><li><p><strong>所有权和借用（Ownership and Borrowing）</strong>：</p><ul><li>Rust的类型系统与其所有权模型紧密结合。所有权模型通过所有权、借用和生命周期的概念来管理内存，从而在无垃圾回收器的情况下确保内存安全。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;s); <span class="hljs-comment">// 借用</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>生命周期（Lifetimes）</strong>：</p><ul><li>Rust使用生命周期标注来跟踪引用的有效范围，确保引用在使用时始终有效。这是Rust 类型系统中一个独特的特性，帮助防止悬空引用和数据竞争。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;long string is long&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-string">&quot;xyz&quot;</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(), string2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The longest string is &#x27;&#123;&#125;&#x27;&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>模式匹配</strong>：</p><ul><li>Rust提供强大的模式匹配功能，尤其是在处理枚举和复杂数据结构时，使得代码更具表达力和安全性。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Quit,<br>    Move &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;,<br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">process_message</span>(msg: Message) &#123;<br>    <span class="hljs-keyword">match</span> msg &#123;<br>        Message::Quit =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Quit the application&quot;</span>);<br>        &#125;<br>        Message::Move &#123; x, y &#125; =&gt; &#123;  <span class="hljs-comment">// 模式匹配能根据数据类型直接拆解出来，使用起来非常方便</span><br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Move to coordinates: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);<br>        &#125;<br>        Message::<span class="hljs-title function_ invoke__">Write</span>(text) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Text message: &#123;&#125;&quot;</span>, text);<br>        &#125;<br>        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Change color to RGB(&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;</span>, r, g, b);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>Rust的类型系统通过上述特性实现了高效、安全和灵活的编程模型，适合系统编程和高性能应用。它在编译期捕获许多潜在错误，使得运行时更为安全可靠。</p><p>当然，如果你之前没有学习过Rust，那这些概念和代码对你来说大概率是云里雾里，不要着急，我们先建立起一个大概的印象就行了。这里我针对Rust 类型系统梳理了一张图，你可以在以后的学习中时常回来看看：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241128185615522.png"alt="Rust 类型系统" /><figcaption aria-hidden="true">Rust 类型系统</figcaption></figure><blockquote><p>注：本图参考了陈天老师在 Rust训练营课程上提供的教案并进行了增改。</p></blockquote><p>本篇就到这里，下篇我们将介绍 Rust 的数据类型，enjoy coding~</p>]]></content>
    
    
    <summary type="html">本文从编程语言的角度介绍了类型系统的基本概念，并详细阐述了 Rust 类型系统的特点，包括静态类型、强类型、所有权系统等核心特性。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 入门" scheme="https://hedon.top/categories/Rust/Rust-%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 入门丨02 数据类型</title>
    <link href="https://hedon.top/2024/11/28/rust-02-data-type/"/>
    <id>https://hedon.top/2024/11/28/rust-02-data-type/</id>
    <published>2024-11-28T09:41:08.000Z</published>
    <updated>2024-12-16T06:59:25.488Z</updated>
    
    <content type="html"><![CDATA[<p>上文中，我们简单探讨了 <ahref="https://hedon.top/2024/11/28/rust-01-type-system/">Rust的类型系统</a>，这一篇我们继续来了解 Rust 的数据类型。我画了一张 Rust基础知识图谱，希望可以帮助你更好地定位当前所在的位置。</p><pre><code class=" mermaid">mindmap  root((Rust 数据类型))    数值类型      整数        有符号          i8/i16/i32/i64/i128/isize        无符号          u8/u16/u32/u64/u128/usize      浮点数        f32        f64      布尔型        bool      字符型        char    复合类型      元组 Tuple      数组 Array      切片 Slice      字符串        String        str      结构体 Struct      枚举 Enum    特殊类型      单元类型 unit      Never类型 !      指针类型        引用 &amp;T        原始指针 *const/*mut        智能指针</code></pre>]]></content>
    
    
    <summary type="html">本文介绍了 Rust 中的数据类型。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 训练营总结丨第三次入门 Rust</title>
    <link href="https://hedon.top/2024/11/26/rust-bootcamp/"/>
    <id>https://hedon.top/2024/11/26/rust-bootcamp/</id>
    <published>2024-11-26T11:10:08.000Z</published>
    <updated>2024-11-27T10:48:54.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起">缘起</h1><p>2023年我给自己定了很多个目标，最终的结果是每个都做了一些事情，但是没有一个是做得比较彻底的，印证了《孙子兵法》的那句：“无所不备，则无所不寡”。</p><p>在 2023.10.23 出于好奇，我订阅了《Rust语言从入门到实战》的专栏，跟着课程的更新节奏学习完了整个专栏。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Rust%E8%AF%AD%E8%A8%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E7%BB%93%E8%AF%BE%E8%AF%81%E4%B9%A6.png" alt="Rust语言从入门到实战结课证书" style="zoom:33%;" /></p><p>虽然我第一次入门 Rust 失败了，但也被 Rust的种种特性所吸引。我是个特别喜欢“痛苦前置”的人，而 Rust编译器"睚眦必报"的编译器检查正给予了我被虐的爽感，编译通过后程序的稳定运行也符合我追求成为一位“靠谱”工程师的愿景。</p><p>加之我的主力语言是Go，一门应用编程语言，所以我一直希望学习一门系统编程语言，以期将来有能力窥探一些底层的细节原理。C/C++太古老了，特性太多了，大神太多了，我怎么学都不可能赶得上别人，嘿嘿，学个新的，大家都没学过，这不就舒服了么。</p><p>后来极客时间决定开设《Rust 训练营》，讲师是<ahref="https://www.zhihu.com/people/tchen">陈天</a>老师，我去搜了关于陈天老师的一些资料，看了一些他写的文章和技术分享视频，甚至油管上还有他之前面试的视频。OK，这个人得到了我的认可，我想跟这样的人交个朋友，哪怕只是加个微信，至少我多了个口子，得以窥探精英阶层人士的生活一角。</p><p>结合 2023 年的教训，2024年年初我就给自己制定了一年的目标，只有一个，就是<strong>踏踏实实、完完整整学习完整个Rust 训练营，其他所有事情和目标，都要为其让步</strong>。</p><blockquote><p>其实是 2 个目标 hhh，另外一个目标是：完成人生的第一场半程马拉松。</p></blockquote><h1 id="筑基">筑基</h1><p>为了更好服务于《Rust 训练营》，在 1-4 月份，我花了差不多 3个多月的时间啃下了<ahref="https://book.douban.com/subject/36547630/">《Rust程序设计（第二版）》</a>，对整个 Rust的语言特性建立了更加完善的体系基础，也多奠定了一些基础，当然，这是我第二次入门Rust 失败。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241127172804063.png" alt="Rust 程序设计（第二版）阅读计划" style="zoom: 25%;" /></p><h1 id="修炼">修炼</h1><p>4 月 18 号开营，本来是预计 7月份结营的，不过陈天老师分享的欲望刹不住车，硬是“拖堂”到了 11 月 22号。事实上，这是有点难受的，一个事情拖太久，思维上很容易疲惫，懒惰也愈难克服。不过从消费者的角度，这是赚翻了，毕竟，学着学着，花呗的12 期无息分期也差不多要还完了。</p><p>所以，其实一个 1095 的程序员，在 4.20 到 11.22 是可以花 279 小时 54分钟学完 202 讲课程的。</p><blockquote><p>即使你将来不使用Rust，相信你学完这门课程后也能成为一位更好的软件工程师。 —— 陈天</p></blockquote><p>是的，在学习中，更多时候感受到的不仅仅是在学习Rust，而是在重学软件工程，我开始切身接触优秀的软件开发具备了哪些不可或缺的流程。为了效仿这些优秀的思想和实践，在实际工作中，今年我做了一些尝试：</p><ol type="1"><li>引入更丰富的 CI/CD流程，尽可能发挥机器的能力，让机器不厌其烦地做那些的重复劳动，而这些不起眼的重复劳动，却能以最小代码为我们排查出最多难以发现的“失误”BUG。</li><li>开始学习写单测，开始学习如何将代码写得能单测、易单测，学习着如何将那些不能单测的💩代码改造成可单测的代码，也将单测运行加入了CI/CD的流程中。在单测多次帮我揪出那些我意识不到的不小心改错的逻辑的时候，我才切身感受到单测的作用，也真正理解了“写单测并不会影响开发效率，如果影响了，那也是提高了开发效率”。幸运的是，截至目前（11.27），我已经连续2 次，在上千行代码的需求开发中，提测阶段和线上发布阶段，都是 0Bug，运气不错。</li><li>引入监控系统，在指标上，存储层、应用层、业务层和网关层进行分层监控，在开发时，从业务无关组件（<ahref="https://github.com/hedon954/goapm">goapm</a>），到业务相关通用组件，最后再到应用程序特定组件的分阶段分层次开发，开始学习着“先解决业务背后的领域问题，顺带解决业务问题”。</li><li>开始思考一些架构层面的东西，开始思考一些代码组织、接口契约、领域模块划分的问题，以期写出质量更好的代码。</li></ol><p>为了支撑上面这些事情，今年我又顺带读了一些书，我是个很少读书的人，因为我总觉得：“读书好慢”。而且我读书也确实很慢，主要是，很困😅。然而，当我回望来时路，一切却都在我的意料之外。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241127180300408.png"alt="hedon 2024 的书单" /><figcaption aria-hidden="true">hedon 2024 的书单</figcaption></figure><p>这个时候我才知道：</p><ul><li>慢就是快</li><li>少就是多</li></ul><h1 id="历劫">历劫</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241127161520649.png"alt="rust-road" /><figcaption aria-hidden="true">rust-road</figcaption></figure><p>这些书其实都不在我的计划之内，因为 2024 我只有一个目标：<strong>完成Rust训练营的学习</strong>。它们只不过是我完成既定计划之余的加餐罢了。</p><p>而幸好我只有一个目标，所以才能有更多时间和精力去应对跟随训练营学习中的一些困难：</p><ul><li>晚上 9 点下班，真累啊，休息下吧，真不想学了。</li><li>工作了一周，真累啊，周末要不就休息吧，真不想学了。</li><li>编译器报错好多啊，算了，要不直接 copy 现成的代码吧。</li><li>这知识点在讲啥啊，算了，先不懂装懂吧，后面还那么多课，先赶进度再说。</li><li>前端和客户端的知识，好像跟我没啥关系，算了，不听了，过过过。</li><li>单测我就不写了，浪费时间。</li><li>学完咯，感觉没啥好总结的，算了，下一个吧。</li><li>....</li></ul><p>运气不错，上述的 n 多种情况，至少在 50-70% 的时候，我能做到：</p><ul><li>学一下再说，累了再停。</li><li>下午出去玩，早上先学了再说。</li><li>算了，狠点，盲写，自己尝试解决一下，咦，也就那么回事。写完后再对比下，哦，其实这块没听懂。</li><li>弄懂再说，多听几遍课，重新看几遍书，再搜一些相关博客，哦，这个知识点是这个意思，读书百遍其义自见原来是这味？</li><li>算了，试试现在 LLM 是否如吹的那么牛，嗯，好像用 LLM来实现前端和客户端的基础功能还真可以，也没那么无聊嘛。</li><li>算了，先试着写下单测吧。哦，我的代码这么难测啊，哦，这行代码怎么就犯蠢了呢，哦，花不了多少时间嘛。</li><li>要不还是总结下吧，哦，原来这个地方是这个意思，哦，原来还讲到了这个点。</li></ul><p>所以这个时候我又知道了：</p><ul><li>慢就是快</li><li>少就是多</li></ul><h1 id="小成">小成</h1><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs tap">➜  hedon-rust-road ll<br>total 0<br>drwxr-xr-x <span class="hljs-number"> 21 </span>wangjiahan  staff   672B Nov<span class="hljs-number"> 27 </span>18:26 aicomm<br>drwxr-xr-x <span class="hljs-number"> 23 </span>wangjiahan  staff   736B Sep<span class="hljs-number"> 11 </span>13:55 chat<br>drwxr-xr-x <span class="hljs-number"> 17 </span>wangjiahan  staff   544B Sep<span class="hljs-number"> 11 </span>18:31 chatapp<br>drwxr-xr-x <span class="hljs-number"> 26 </span>wangjiahan  staff   832B Nov<span class="hljs-number"> 27 </span>18:26 crm<br>drwxr-xr-x <span class="hljs-number"> 22 </span>wangjiahan  staff   704B Nov<span class="hljs-number"> 27 </span>18:26 dino<br>drwxr-xr-x <span class="hljs-number"> 16 </span>wangjiahan  staff   512B Nov<span class="hljs-number"> 27 </span>18:29 error-info<br>drwxr-xr-x <span class="hljs-number"> 18 </span>wangjiahan  staff   576B Sep <span class="hljs-number"> 4 </span>19:00 hackernews<br>drwxr-xr-x <span class="hljs-number"> 22 </span>wangjiahan  staff   704B Sep<span class="hljs-number"> 12 </span>15:54 hedon-bot<br>drwxr-xr-x  <span class="hljs-number"> 9 </span>wangjiahan  staff   288B Nov<span class="hljs-number"> 27 </span>18:29 httpie<br>drwxr-xr-x <span class="hljs-number"> 13 </span>wangjiahan  staff   416B Aug<span class="hljs-number"> 22 </span>10:40 inverted-index-concurrency<br>drwxr-xr-x  <span class="hljs-number"> 7 </span>wangjiahan  staff   224B Nov<span class="hljs-number"> 27 </span>18:28 json-macro<br>drwxr-xr-x <span class="hljs-number"> 26 </span>wangjiahan  staff   832B Sep <span class="hljs-number"> 3 </span>19:30 learn-ffi<br>drwxr-xr-x  <span class="hljs-number"> 8 </span>wangjiahan  staff   256B Nov<span class="hljs-number"> 27 </span>18:29 learn-proc-macro<br>drwxr-xr-x  <span class="hljs-number"> 7 </span>wangjiahan  staff   224B Nov<span class="hljs-number"> 27 </span>18:30 mandelbrot<br>drwxr-xr-x <span class="hljs-number"> 10 </span>wangjiahan  staff   320B Aug<span class="hljs-number"> 22 </span>10:40 matrix-multi<br>drwxr-xr-x  <span class="hljs-number"> 7 </span>wangjiahan  staff   224B Nov<span class="hljs-number"> 27 </span>18:29 pest-parser-collection<br>drwxr-xr-x <span class="hljs-number"> 19 </span>wangjiahan  staff   608B Nov<span class="hljs-number"> 27 </span>18:27 r-redis<br>drwxr-xr-x <span class="hljs-number"> 21 </span>wangjiahan  staff   672B Aug<span class="hljs-number"> 22 </span>10:40 rcli<br>drwxr-xr-x <span class="hljs-number"> 17 </span>wangjiahan  staff   544B Aug<span class="hljs-number"> 22 </span>10:40 simple-chat<br>drwxr-xr-x <span class="hljs-number"> 17 </span>wangjiahan  staff   544B Aug<span class="hljs-number"> 22 </span>10:40 simple-shortener<br>drwxr-xr-x <span class="hljs-number"> 21 </span>wangjiahan  staff   672B Aug<span class="hljs-number"> 22 </span>10:40 taotie<br>drwxr-xr-x@<span class="hljs-number"> 18 </span>wangjiahan  staff   576B Nov<span class="hljs-number"> 27 </span>15:38 thumbor<br>drwxr-xr-x <span class="hljs-number"> 19 </span>wangjiahan  staff   608B Aug<span class="hljs-number"> 29 </span>10:56 winnow-parser-collection<br>➜  hedon-rust-road tokei -t rust<br>===============================================================================<br> Language            Files        Lines         Code     Comments       Blanks<br>===============================================================================<br> Rust                 <span class="hljs-number"> 336 </span>      <span class="hljs-number"> 25451 </span>      <span class="hljs-number"> 21615 </span>        <span class="hljs-number"> 644 </span>        3192<br> |- Markdown           <span class="hljs-number"> 53 </span>        <span class="hljs-number"> 546 </span>          <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 476 </span>          70<br> (Total)                         <span class="hljs-number"> 25997 </span>      <span class="hljs-number"> 21615 </span>       <span class="hljs-number"> 1120 </span>        3262<br>===============================================================================<br> Total                <span class="hljs-number"> 336 </span>      <span class="hljs-number"> 25451 </span>      <span class="hljs-number"> 21615 </span>        <span class="hljs-number"> 644 </span>        3192<br>===============================================================================<br></code></pre></td></tr></table></figure><p>看老师画了那么多牛逼的图，要不“邯郸学步”模仿一下吧。故而又忍着“下一个吧”的念头，梳理了下这几个月到底做了些什么。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/8abb5b2a2f3020ca36f75087ae76a53c.PNG"alt="rcli" /><figcaption aria-hidden="true">rcli</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/4ac783c6adaa38a45853861753112e35.PNG"alt="r-redis" /><figcaption aria-hidden="true">r-redis</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/4bdd0cba75aa773c6f4e941cf5c5fe29.PNG"alt="macro-json" /><figcaption aria-hidden="true">macro-json</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/969e023d9003b3c28ea1c95a7c1d9388.PNG"alt="macro-error-info" /><figcaption aria-hidden="true">macro-error-info</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/f25b8a0f1c95ac306ecda6c4ff3954a3.PNG"alt="rust-ecosystem" /><figcaption aria-hidden="true">rust-ecosystem</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/d04da8bf3577f1d09b7fce647451a700.PNG"alt="crm" /><figcaption aria-hidden="true">crm</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/c85939619088cda8c9a763ba514d235e.PNG"alt="taotie" /><figcaption aria-hidden="true">taotie</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/2d3892c57b0742707c6ff3a1267f532a.PNG"alt="dino" /><figcaption aria-hidden="true">dino</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/874082e0f9f9410f342d875f8559bd15.PNG"alt="aicomm" /><figcaption aria-hidden="true">aicomm</figcaption></figure><h1 id="归元">归元</h1><ul><li>知是行之始，行是知之成。</li><li>遇事不决，可问春风。春风不语，既随本心。</li></ul><p>2025 见！</p>]]></content>
    
    
    <summary type="html">本文记录了我在 Rust 训练营的学习历程，也映射了我 2024 年全年的成长轨迹。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="总结" scheme="https://hedon.top/categories/Rust/%E6%80%BB%E7%BB%93/"/>
    
    <category term="2024" scheme="https://hedon.top/categories/Rust/%E6%80%BB%E7%BB%93/2024/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</title>
    <link href="https://hedon.top/2024/11/11/rust-memory-order/"/>
    <id>https://hedon.top/2024/11/11/rust-memory-order/</id>
    <published>2024-11-11T05:06:49.000Z</published>
    <updated>2024-11-28T11:04:00.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="atomic">Atomic</h1><p>在 Rust 的 <code>std::sync::atomic</code>模块中包含了无锁并发编程的原子化类型，与通常的算术运算符和逻辑运算符不同，原子化类型会暴露执行原子化操作的方法，单独的加载、存储、交换和算术运算都会作为一个单元安全地进行，哪怕其他线程也在执行操作同一内存的原子化操作也没问题。</p><p>Rust 提供了以下几种原子化类型：</p><ul><li><code>AtomicIsize</code> 和 <code>AtomicUsize</code> 是与单线程<code>isize</code> 类型和 <code>usize</code>类型对应的共享整数类型。</li><li><code>AtomicI8</code>、<code>AtomicI16</code>、<code>AtomicI32</code>、<code>AtomicI64</code>及其无符号变体（如<code>AtomicU8</code>）是共享整数类型，对应于单线程中的类型<code>i8</code>、<code>i16</code> 等。</li><li><code>AtomicBool</code> 是一个共享的 <code>bool</code> 值。</li><li><code>AtomicPtr</code> 是不安全指针类型 <code>*mut T</code>的共享值。</li></ul><p>这些类型都会以下几类核心功能：</p><ul><li><code>Load</code> 、<code>Store</code>: 存取值</li><li><code>Fetch-and-Modify</code>: 获取并修改</li><li><code>Compare-and-Exchange</code>: 比较并交换</li></ul><p>下面我们对上述提到的几种核心功能进行举例。</p><h2 id="load-store">Load &amp; Store</h2><ul><li><strong>load</strong>:从原子化类型中获取起对应的基本数据类型的值。</li><li><strong>store</strong>:将一个基本数据类型的值存储到其对应的原子化类型中。</li></ul><p>在下面的例子中，我们使用 <code>AtomicUsize::new(0)</code>初始化了一个原子类型，它对应的基本数据类型是 <code>usize</code>。</p><p>我们起了一个子线程，在 for 循环中不断地使用 <code>store</code>函数修改 <code>num_done</code> 的值，然后在主线程中使用<code>load</code> 获取起对应的值，当发现值为 <code>100</code>时，就退出循环，进程结束。</p><p>得益于原子化类型的并发安全特性，所以这里两个线程对<code>num_done</code> 进行并发读写都是安全的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num_done</span> = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">main_thread</span> = thread::<span class="hljs-title function_ invoke__">current</span>();<br><br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> &#123;<br>                <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">10</span>));<br>                num_done.<span class="hljs-title function_ invoke__">store</span>(i + <span class="hljs-number">1</span>, std::sync::atomic::Ordering::Relaxed);  <span class="hljs-comment">// store 存储</span><br>                main_thread.<span class="hljs-title function_ invoke__">unpark</span>();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = num_done.<span class="hljs-title function_ invoke__">load</span>(std::sync::atomic::Ordering::Relaxed); <span class="hljs-comment">// load 获取</span><br>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">100</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Working... &#123;n&#125;/100 done&quot;</span>);<br>            thread::<span class="hljs-title function_ invoke__">park_timeout</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里我们暂且忽略 <code>std::sync::atomic::Ordering::Relaxed</code>这个参数的含义，在后续的「内存顺序」章节会进行详细阐述。</p></blockquote><h2 id="fetch-and-modify">Fetch-and-Modify</h2><p><strong>Fetch-and-Modify</strong>操作用于在获取当前值的同时对其进行修改。这类操作包括<code>fetch_add</code>、<code>fetch_sub</code>、<code>fetch_and</code>、<code>fetch_or</code>、<code>fetch_xor</code>等。</p><p>我们将上面的例子修改一下，不再是直接 <code>store</code>一个值，而是不断进行加 1 操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num_done</span> = &amp;AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> &#123;<br>                num_done.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, std::sync::atomic::Ordering::Relaxed); <span class="hljs-comment">// 使用 fetch_add 进行加 1</span><br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = num_done.<span class="hljs-title function_ invoke__">load</span>(std::sync::atomic::Ordering::Relaxed);<br>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">100</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Working... &#123;n&#125;/100 done&quot;</span>);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="compare-and-exchange">Compare-and-Exchange</h2><p><strong>Compare-and-Exchange</strong>是一种条件更新操作，只有在当前值等于预期值时才会更新。</p><p>下面的例子中我们实现了一个函数<code>allocate_new_id</code>，它支持在并发环境下分配新的<code>id</code>，这里我们使用了 <code>compare_exchange(id, id+1)</code>进行条件更新，只有当 <code>id</code>没有发生变化的时候，才运行对其进行加1，这就保证了在并发下，只有一个线程可以成功执行该语句，从而保证<code>id</code> 的递增性和唯一性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">allocate_new_id</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-keyword">static</span> NEXT_ID: AtomicU32 = AtomicU32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">id</span> = NEXT_ID.<span class="hljs-title function_ invoke__">load</span>(std::sync::atomic::Ordering::Relaxed);<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">assert!</span>(id &lt; <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;Too many IDs!&quot;</span>);<br>        <span class="hljs-keyword">match</span> NEXT_ID.<span class="hljs-title function_ invoke__">compare_exchange</span>(  <span class="hljs-comment">// 只有 id 没有发生变化，才允许进行加 1</span><br>            id,<br>            id + <span class="hljs-number">1</span>,<br>            std::sync::atomic::Ordering::Relaxed,<br>            std::sync::atomic::Ordering::Relaxed,<br>        ) &#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-keyword">return</span> id,<br>            <span class="hljs-title function_ invoke__">Err</span>(v) =&gt; id = v,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>在 Rust中，原子化类型还提供了另外一个函数：<code>compare_exchange_weak</code>，它与<code>compare_exchange</code>的主要区别在于它们在<strong>失败时</strong>的行为：</p><p><strong>compare_exchange</strong>:</p><ul><li>只会在实际值不等于期望值时失败。</li><li>提供更强的保证，但可能性能较低。</li><li>适用于不在循环中的单次比较交换操作。</li></ul><p><strong>compare_exchange_weak</strong>:</p><ul><li>即使实际值等于期望值时也可能失败（称为“虚假失败”或“spuriousfailure”）。</li><li>性能可能更好，因为允许在某些架构上生成更高效的代码。</li><li>最适合在循环中使用，因为需要处理可能的虚假失败。</li></ul><p>在实际应用中:</p><ul><li>如果操作在循环中,使用 <code>compare_exchange_weak</code>通常更好。</li><li>如果是单次操作,使用 <code>compare_exchange</code> 更合适。</li><li>在某些平台上，这两个操作可能没有性能差异,但<code>compare_exchange_weak</code> 的行为仍然可能不同。</li></ul><p>这种区别的存在是因为在某些 CPU架构上,允许虚假失败可以生成更高效的机器码。比如在 ARM架构上，<code>compare_exchange_weak</code> 可以直接映射到单个LL/SC（Load-Link/Store-Conditional）指令。</p>          </div><h2 id="硬件原理">硬件原理</h2><p>在一些处理器架构中，当一个 CPU执行需要原子性的操作时，它可以通过锁定内存总线来确保在操作完成之前，其他CPU 无法访问相关的内存地址。</p><p>基本工作流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">CPU 发出 LOCK 信号<br>   └── 激活处理器的 LOCK# 引脚<br>      └── 获得总线的独占访问权<br>          └── 执行原子操作<br>              └── 释放 LOCK 信号<br>                  └── 其他处理器可以访问内存<br></code></pre></td></tr></table></figure><p>主流的有 2 种锁定机制：</p><ul><li><p><strong>总线锁定（BusLocking）</strong>：总线锁定是一种机制，它通过锁定内存总线来确保在执行原子操作时，其他处理器无法访问内存。这种方法虽然简单，但会导致总线的其他操作被阻塞，从而影响系统性能。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">优点：<br><span class="hljs-bullet">-</span> 绝对的原子性保证<br><span class="hljs-bullet">-</span> 适用于所有内存位置<br><br>缺点：<br><span class="hljs-bullet">-</span> 性能开销大<br><span class="hljs-bullet">-</span> 会阻塞其他 CPU 对内存的访问<br></code></pre></td></tr></table></figure></li><li><p><strong>缓存锁定（CacheLocking）</strong>：现代处理器通常使用缓存锁定来实现原子操作。缓存锁定通过锁定处理器的缓存行来实现，而不是锁定整个总线。这种方法可以减少对总线的影响，提高系统的并发性能。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">优点：<br><span class="hljs-bullet">-</span> 性能更好<br><span class="hljs-bullet">-</span> 不会完全阻塞内存访问<br><br>条件：<br><span class="hljs-bullet">-</span> 数据必须在缓存行中<br><span class="hljs-bullet">-</span> 缓存行必须是独占状态<br></code></pre></td></tr></table></figure></li></ul><p>缓存锁定通常依赖于缓存一致性协议（如 <strong>MESI</strong>协议）来确保在多个处理器之间的数据一致性。通过这些协议，处理器可以在本地缓存中执行原子操作，并在必要时与其他处理器同步。</p><p><strong>MESI</strong> 协议即：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">M (Modified)：已修改<br>E (Exclusive)：独占<br>S (Shared)：共享<br>I (Invalid)：无效<br><br>操作流程：<br><span class="hljs-bullet">1.</span> 检查数据是否在缓存中<br><span class="hljs-bullet">2.</span> 如果在，将状态改为 Exclusive<br><span class="hljs-bullet">3.</span> 执行原子操作<br><span class="hljs-bullet">4.</span> 通知其他 CPU 使其缓存失效<br></code></pre></td></tr></table></figure><p>不同的架构有不同的锁定方式：</p><ul><li>x86/x64：使用 LOCK 前缀</li><li>ARM：使用 exclusive load/store 指令</li><li>PowerPC：使用 load-linked/store-conditional</li></ul><p>以下是 x86 汇编的一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; 原子加法操作<br>lock add dword ptr [memory], 1<br><br>; 比较并交换<br>lock cmpxchg dword ptr [memory], eax<br></code></pre></td></tr></table></figure><p>为了充分利用<strong>缓存锁定</strong>的优势，我们在编写代码时，可以有以下的性能考虑：</p><ul><li><p><strong>缓存行对齐，避免伪共享</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicI32, Ordering&#125;;<br><br><span class="hljs-comment">// 在 Rust 中，可以使用 #[repr(align(N))] 属性来确保结构体或变量的对齐方式，以避免伪共享。</span><br><span class="hljs-comment">// 伪共享是指多个线程访问不同的变量，但这些变量共享同一个缓存行，从而导致不必要的缓存一致性流量。</span><br><span class="hljs-meta">#[repr(align(64))]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlignedCounter</span> &#123;<br>    counter: AtomicI32,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = AlignedCounter &#123;<br>        counter: AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>),<br>    &#125;;<br>    <span class="hljs-comment">// 使用 counter.counter.fetch_add(...) 进行操作</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>避免频繁的总线锁定</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicI32, Ordering&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 不好的做法：频繁的原子操作</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1000</span> &#123;<br>        counter.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Ordering::SeqCst);<br>    &#125;<br><br>    <span class="hljs-comment">// 更好的做法：本地累加后一次性更新</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">local_sum</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1000</span> &#123;<br>        local_sum += <span class="hljs-number">1</span>;<br>    &#125;<br>    counter.<span class="hljs-title function_ invoke__">fetch_add</span>(local_sum, Ordering::SeqCst);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="rust-实战查看汇编">Rust 实战查看汇编</h3><blockquote><p>笔者使用的是 ARM64 架构的 macbook。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicI64, Ordering&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">static</span> ATOMIC: AtomicI64 = AtomicI64::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        ATOMIC.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">10086</span>, Ordering::Release);<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">val</span> = ATOMIC.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire);<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;val&#125;&quot;</span>);<br>    &#125;);<br><br>    t1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    t2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>rustc</code> 编译并输出汇编代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rustc -O --emit asm src/main.rs<br></code></pre></td></tr></table></figure><p>代码中我特地设置了 <code>10086</code>这个特殊的值，这是为了可以在输出的 <code>main.s</code> 文件中快速找到<code>store</code> 对应的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__ZN3std3sys9backtrace28__rust_begin_short_backtrace17h750d7a3a9c81fc67E:<br>.cfi_startproc<br>Lloh8:<br>adrpx8, __ZN4main6ATOMIC17hd0b0dbf92e477148E.0@PAGE<br>Lloh9:<br>addx8, x8, __ZN4main6ATOMIC17hd0b0dbf92e477148E.0@PAGEOFF<br>movw9, #10086 ; 将值 10086 移入寄存器<br>stlrx9, [x8] ; Store-Release 指令，原子地存储值<br>; InlineAsm Start<br>; InlineAsm End<br>ret<br>.loh AdrpAddLloh8, Lloh9<br>.cfi_endproc<br></code></pre></td></tr></table></figure><p>在这个代码中，<code>stlr</code> 就是 <code>Store Release</code>的意思，另外一个关键字是 <code>ladpr</code>，表示<code>Load Acquire</code> 的意思，通过这个关键字，你可以找到<code>load</code> 对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Lloh11:<br>addx8, x8, __ZN4main6ATOMIC17hd0b0dbf92e477148E.0@PAGEOFF<br>ldaprx8, [x8] ; ; Load-Acquire 指令，原子地加载值<br>strx8, [sp, #8]<br></code></pre></td></tr></table></figure><h3 id="go-实战查看汇编">Go 实战查看汇编</h3><blockquote><p>笔者使用的是 ARM64 架构的 macbook。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>data := atomic.Int64&#123;&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>data.Store(<span class="hljs-number">10086</span>)<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>a := data.Load()<br><span class="hljs-built_in">println</span>(a)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>使用如下命令，可以输出优化后的汇编代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go build -gcflags=-S -ldflags=-w main.go 2&gt; assembly.txt<br></code></pre></td></tr></table></figure><p>查看输出的文件，我们同样搜索 <code>10086</code>，可以快速找到<code>store</code> 的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x0008 00008 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:109)MOVD$10086, R1<br>0x000c 00012 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:109)STLRR1, (R0)<br></code></pre></td></tr></table></figure><p>可以看到，这里同样也是使用了 <code>STLR</code> 指令。接着我们看第 14行代码的位置对应的汇编：可以发现这里使用的 <code>LDAR</code>指令，也就是 <code>Load Acuqire</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x001c 00028 (/Users/wangjiahan/goStudy/go-atomic/main.go:14)HINT$0<br>0x0020 00032 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:106)LDAR(R0), R0<br>0x0024 00036 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:106)MOVDR0, main..autotmp_6-8(SP)<br></code></pre></td></tr></table></figure><h1 id="内存顺序">内存顺序</h1><p>在了解了 Rust Atomic的基本用法和基本原理之后，我们回过头来谈一谈原子操作参数中的<code>std::sync::atomic::Ordering::Relaxed</code>，这个就是本篇的主题：<strong>内存顺序</strong>。内存顺序要解决的核心问题是<u>如何合理地限制单一线程中的代码执行顺序，使得在不使用锁的情况下，既能最大化利用CPU 的计算能力，又能保证多线程环境下不会出现逻辑错误。</u></p><h2 id="指令乱序">指令乱序</h2><p>CPU和编译器都会在保证程序运行结果不发生改变的前提下，尽一切可能让我们的程序运行得尽可能快。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>(a: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>, b: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>) &#123;<br>  *a += <span class="hljs-number">1</span>;<br>  *b += <span class="hljs-number">1</span>;<br>  *a += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>像上述代码，编译器完全可以优化成下面的代码，从而提高程序的运行效率：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>(a: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>, b: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>) &#123;<br>  *a += <span class="hljs-number">2</span>;<br>  *b += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个过程中，就可能会出现<strong>指令重排</strong>，甚至是<strong>代码重写</strong>，不过这带来了指令乱序的问题，即<u>程序的实际执行顺序跟我们的代码顺序是不一致的</u>。</p><p>不过，编译器保证的是<strong>在单线程环境下，执行的结果最终一致</strong>，所以，指令乱序在单线程环境下完全是允许的。对于编译器来说，它只知道：在当前线程中，数据的读写以及数据之间的依赖关系。但是，<strong>编译器并不知道哪些数据是在线程间共享，而且是有可能会被修改的</strong>。而这些是需要开发人员去保证的。</p><h2 id="内存模型">内存模型</h2><p>为了解决指令乱序带来的并发问题，Rust 采用了内存模型（MemoryModel）这一概念。这个概念主要借鉴自 C++11中引入的内存模型，它定义了在多线程环境下内存访问的行为规范。</p><p>内存模型的核心目标是在以下三方面之间取得平衡：</p><ol type="1"><li><strong>正确性保证</strong>：确保多线程程序的行为是可预测和一致的。</li><li><strong>性能优化</strong>：允许编译器和 CPU在不违反正确性的前提下进行优化。</li><li><strong>跨平台兼容</strong>：提供一个统一的抽象层，使代码可以在不同的硬件架构上正确运行。</li></ol><p>具体来说，内存模型：</p><ul><li>为开发者提供了清晰的规则，说明在多线程环境下，什么样的内存访问行为是合法的，什么样的行为会导致未定义行为。</li><li>为编译器开发者提供了明确的标准，指导他们在不同平台上实现必要的内存同步原语。</li><li>通过定义不同的内存顺序级别（如 Relaxed、Release/Acquire、SeqCst等），让开发者可以根据需要选择合适的同步强度。</li></ul><p>这种抽象让开发者可以专注于并发逻辑本身，而不必过分关注底层硬件的具体实现细节。</p><h2 id="sequenced-before">Sequenced-Before</h2><p>在讨论内存顺序之前，我们需要先对 2 个重要关系术语进行简单阐述，分别是<code>Sequenced-Before</code> 和 <code>Happens-Before</code>。</p><p><strong>Sequenced-Before</strong>描述的是<strong>单个线程内</strong>的操作顺序。它基于程序的源代码顺序，表示在同一线程中，一个操作在程序中出现在另一个操作之前。</p><p>具体来说，如果操作 A sequenced-before 操作 B，那么：</p><ol type="1"><li><p><strong>数据依赖关系</strong>：如果 B 依赖于 A 的结果，那么 A一定会在 B 之前执行。例如： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;      <span class="hljs-comment">// 操作 A</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 操作 B - 依赖于 A 的结果</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>原子操作的顺序</strong>：对同一个原子变量的操作会保持程序顺序。例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">5</span>, Relaxed);    <span class="hljs-comment">// 一定先执行</span><br>X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">10</span>, Relaxed);   <span class="hljs-comment">// 一定后执行</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>独立操作的可重排性</strong>：如果两个操作之间没有数据依赖关系，且操作的是不同的变量，那么它们可能会被重排序。例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">X.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, Relaxed);  <span class="hljs-comment">// 这两个操作可能会被重排序</span><br>Y.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">2</span>, Relaxed);  <span class="hljs-comment">// 因为它们操作的是不同的变量</span><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="happens-before">Happens-Before</h2><p><strong>Happens-Before</strong>则描述了<strong>跨线程</strong>的操作顺序。它定义了不同线程中的操作之间的可见性和顺序关系。如果操作A Happens-Before 操作 B，那么 A 的内存写入对 B 是可见的。</p><p>典型的 Happens-Before 有：</p><ol type="1"><li>同一线程内，如果先调用 <code>f()</code>，再调佣 <code>g()</code>，则<code>f()</code> happens-before <code>g()</code>，其实这就是<code>sequenced-before</code>。</li><li><code>spawing</code> happens-before <code>joining</code>。</li><li><code>lock</code> happens-before <code>unlock</code>。</li></ol><p>举个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> X: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(f);<br>    X.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">2</span>, Relaxed);<br>    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    X.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">3</span>, Relaxed);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-built_in">assert!</span>(x == <span class="hljs-number">1</span> || x == <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子的执行顺序如下图所示，因为 <code>spawn</code>happens-before<code>join</code>，所以我们可以确定的执行顺序是：<strong>“store 1 toX”→“store 2 to X”→“store 3 to X”</strong>。而 <strong>load fromX</strong> 介于 spawn 和 join之间，且没有进行任何其他的内存顺序限制，所以它和 <strong>store 2 toX</strong> 之间的顺序是不确定的，但是可以肯定的是，它一定在<strong>store 3 to X</strong> 之前，所以<code>assert!(x == 1 || x == 2);</code> 是永远成立的。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241111160041436.png" alt="spawn-happens-before-join" style="zoom:33%;" /></p><p>到这里，相信不少读者已经能够理解为什么需要内存顺序这个东西了，核心问题就是在于<strong>store 2 to X</strong> 和 <strong>load from X</strong>的执行顺序是否会影响我们的业务逻辑，如果不会，那么我们可以指定最松散的内存顺序要求，如果会，那么我们就要利用指定合适的内存顺序来使得其按照我们的预期顺序进行执行，从而保证业务逻的正确。</p><h2 id="rust-内存顺序">Rust 内存顺序</h2><p>Rust 支持五种内存顺序（Ordering），从最松散到最严格依次为：</p><table><thead><tr class="header"><th>内存顺序</th><th>说明</th><th>保证</th><th>适用场景</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>Relaxed</td><td>最宽松的内存顺序</td><td>- 仅保证操作的原子性<br>- 不提供任何同步保证<br>- 不建立happens-before 关系</td><td>- 简单计数器<br>- 性能要求极高且确定不需要同步<br>-已通过其他方式确保同步</td><td><code>counter.fetch_add(1, Ordering::Relaxed)</code></td></tr><tr class="even"><td>Release</td><td>用于存储操作</td><td>- 之前的内存访问不会被重排到此操作之后<br>- 与 Acquire配对使用可建立 happens-before 关系</td><td>- 生产者-消费者模式<br>- 发布共享数据<br>- 初始化完成标志</td><td><code>data.store(42, Ordering::Release)</code></td></tr><tr class="odd"><td>Acquire</td><td>用于加载操作</td><td>- 之后的内存访问不会被重排到此操作之前<br>- 与 Release配对使用可建立 happens-before 关系</td><td>- 生产者-消费者模式<br>- 获取共享数据<br>- 检查初始化标志</td><td><code>data.load(Ordering::Acquire)</code></td></tr><tr class="even"><td>AcqRel</td><td>同时包含 Acquire 和 Release 语义</td><td>- 结合了 Acquire 和 Release 的所有保证<br>- 用于读改写操作</td><td>- 需要双向同步的原子操作<br>- 锁的实现<br>- 复杂的同步原语</td><td><code>value.fetch_add(1, Ordering::AcqRel)</code></td></tr><tr class="odd"><td>SeqCst</td><td>最严格的内存顺序</td><td>- 包含 AcqRel 的所有保证<br>- 所有线程看到的所有 SeqCst操作顺序一致<br>- 提供全局的顺序一致性</td><td>- 需要严格的全局顺序<br>- 不确定使用哪种顺序时<br>-对性能要求不高的场景</td><td><code>flag.store(true, Ordering::SeqCst)</code></td></tr></tbody></table><p>在 C++ 中，其实还有另外一种内存顺序 <code>Consume</code>，它是<code>Acquire</code> 的一个更弱的版本：</p><ul><li><p><strong>Acquire</strong>:保证后续的所有读写操作不会重排到这个操作前面</p></li><li><p><strong>Consume</strong>:只保证后续与这个操作结果相关的读写操作不会重排到这个操作前面</p></li></ul><p>理论上，Consume 在某些架构上可以提供比 Acquire更好的性能，因为它只需要对数据依赖的操作进行同步。</p><p>然而，由于以下原因，Rust 选择不支持 Consume 顺序：</p><ol type="1"><li><strong>实现复杂性</strong>：很多编译器实现者发现正确实现 Consume语义非常困难。</li><li><strong>性能收益不确定</strong>：在实践中，大多数编译器都将 Consume视为 Acquire 来处理。</li><li><strong>标准困惑</strong>：C++ 标准委员会也承认当前的 Consume语义定义存在问题，正在考虑重新设计。</li></ol><div class="note note-info">            <p>选择建议：</p><ol type="1"><li><strong>不确定选择哪种顺序时</strong>：<ul><li>使用 SeqCst（最安全但性能最低）</li><li>或咨询有经验的开发者</li></ul></li><li><strong>性能优化时</strong>：<ul><li>先使用 SeqCst 开发</li><li>在性能测试后，根据需要降低到 Release/Acquire</li><li>只有在确实需要时才使用 Relaxed</li></ul></li><li><strong>常见组合</strong>：<ul><li>Release 写 + Acquire 读：最常见的生产者-消费者模式</li><li>AcqRel：用于原子的读改写操作</li><li>Relaxed：用于简单的计数器场景</li></ul></li></ol>          </div><p>下面我们来对每种内存顺序进行举例阐述。</p><h3 id="relaxed">Relaxed</h3><p><code>Relaxed</code>是最宽松的内存顺序，它只保证了原子操作在并发下的安全性，但不保证执行顺序。</p><p>考虑如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> X: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">5</span>, Relaxed);<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">10</span>, Relaxed); <br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">b</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;a&#125; &#123;b&#125; &#123;c&#125; &#123;d&#125;&quot;</span>);  <span class="hljs-comment">// 这个输出不一定</span><br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(a);<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(b);<br>    &#125;);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, X.<span class="hljs-title function_ invoke__">load</span>(Relaxed)); <span class="hljs-comment">// 最终结果一定是 15</span><br>&#125;<br></code></pre></td></tr></table></figure><p>基于我们上面提到的 <code>sequenced-before</code> 规则，我们可以确定<code>a</code> 和 <code>b</code> 两个线程内的<code>happens-before</code> 规则，但是二者之间的<code>happens-before</code> 是无法确定的，但是我们可以确定最后的结果是<code>15</code>。下图展示了上述代码的执行顺序示意图：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241111164259913.png" alt="relaxed-ordering" style="zoom:50%;" /></p><p>虽然两个线程之间的 <code>happens-before</code>是无法确定的，但是我们可以确定 <code>X</code>的变化顺序：0→5→15。所以线程 <code>b</code> 输出<code>0 0 0 0</code>、<code>0 0 5 15</code> 和 <code>0 15 15 15</code>都是可能的，而永远不可能输出 <code>0 5 0 15</code> 或<code>0 0 10 15</code> 类似的结果。</p><p>但是如果是这样子的话，就不一定了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> X: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a1</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">5</span>, Relaxed);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a2</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">10</span>, Relaxed); <br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">b</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;a&#125; &#123;b&#125; &#123;c&#125; &#123;d&#125;&quot;</span>);  <span class="hljs-comment">// 这个输出不一定</span><br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(a1);<br>      s.<span class="hljs-title function_ invoke__">apawn</span>(a2);<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(b);<br>    &#125;);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, X.<span class="hljs-title function_ invoke__">load</span>(Relaxed)); <span class="hljs-comment">// 最终结果一定是 15</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子，<code>X</code> 的变化顺序可以是 0→5→15，也可以是0→10→15，这取决于哪个 <code>fetch_add</code> 先被执行。</p><p>再举个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> DATA: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        <span class="hljs-comment">// 线程 A - 写入者</span><br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">123</span>, Ordering::Relaxed);     <span class="hljs-comment">// ① 准备数据</span><br>            READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Relaxed);   <span class="hljs-comment">// ② 发出数据就绪信号</span><br>        &#125;);<br><br>        <span class="hljs-comment">// 线程 B - 读取者</span><br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed) &#123;  <span class="hljs-comment">// ③ 等待数据就绪信号</span><br>                thread::<span class="hljs-title function_ invoke__">yield_now</span>();<br>            &#125;<br>            <span class="hljs-built_in">assert_eq!</span>(DATA.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed), <span class="hljs-number">123</span>); <span class="hljs-comment">// ④ 获取数据，这里断言一定成功吗？</span><br>        &#125;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子中，线程 A 执行了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">123</span>, Ordering::Relaxed);     <span class="hljs-comment">// 准备数据</span><br>READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Relaxed);   <span class="hljs-comment">// 发出数据就绪信号</span><br></code></pre></td></tr></table></figure><p>这是 2 个没有依赖关系的原子操作，且使用的是 <code>Relaxed</code>内存顺序，所以对于线程 B 来说，这 2个操作的顺序是不确定的。所以是很可能在<code>READY.load(Ordering::Relaxed)</code> 返回 <code>true</code>的时候，<code>DATA.load(Ordering::Relaxed)</code> 依旧还是<code>0</code>。</p><p>那如何确保这个断言一定成功呢？那就需要“升级”一下了~ 这个时候就轮到<code>Release</code> 和 <code>Acquire</code> 的出场了。</p><h3 id="release-acquire">Release &amp; Acquire</h3><p><code>Release</code> 和 <code>Acquire</code>一般成对出现，它们共同建立了线程间的同步关系：</p><ul><li><code>Release</code>:作用于写操作（store），确保该操作之前的所有内存访问不会被重排到这个Release 操作之后。</li><li><code>Acquire</code>:作用于读操作（load），确保该操作之后的所有内存访问不会被重排到这个Acquire 操作之前。</li></ul><p>当一个线程通过 <code>Acquire</code> 读取到另一个线程通过<code>Release</code> 写入的值时，会建立一个 happens-before关系：<strong><font color="orange">线程 A 中 Release写入之前的所有内存写操作，对于线程 B 中 Acquire读取之后的所有内存读操作都是可见的</font></strong>。</p><p>修改一下上面的例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> DATA: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">123</span>, Ordering::Relaxed);   <br>            READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Release);   <span class="hljs-comment">// 这里改为 release</span><br>        &#125;);<br><br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire) &#123;  <span class="hljs-comment">// 这里改为 acquire</span><br>                thread::<span class="hljs-title function_ invoke__">yield_now</span>();<br>            &#125;<br>            <span class="hljs-built_in">assert_eq!</span>(DATA.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed), <span class="hljs-number">123</span>); <span class="hljs-comment">// 必定成功</span><br>        &#125;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241111165714772.png" alt="release-acquire-ordering" style="zoom:50%;" /></p><p>如上图所示，在这个例子中：</p><ol type="1"><li>Release-Acquire 同步确保了 <code>READY</code> 的写入和读取之间建立了happens-before 关系</li><li>由于 <code>DATA</code> 的写入在 <code>READY</code> 的 Release写入之前，而 <code>DATA</code> 的读取在 <code>READY</code> 的 Acquire读取之后</li><li>因此可以保证线程 B 一定能看到线程 A 写入的值 123</li></ol><p>更进一步，我们通过观察，可以发现 <code>DATA</code> 都没必要使用<code>Atomic</code> 类型，因为由 <code>READY</code> 建议的<code>happens-before</code> 规则已经能保证对 <code>DATA</code>的读写不可能并发执行了。不过因为 Rust的类型系统并不允许跨线程进行非原子类型的读写操作，所以这里我们需要使用<code>unsafe</code>才能使编译通过，但通过我们之前的分析，我们可以确保下面这段代码是安全的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> DATA: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-comment">// Safety: 此时没有其他线程访问 DATA，</span><br>        <span class="hljs-comment">// 因为我们还没有设置 READY 标志</span><br>        <span class="hljs-keyword">unsafe</span> &#123; DATA = <span class="hljs-number">123</span> &#125;;<br>        READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Release); <span class="hljs-comment">// 在这个存储操作之前的所有内存操作 ..</span><br>    &#125;);<br>    <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Acquire) &#123; <span class="hljs-comment">// .. 在这个加载操作返回 true 后都是可见的</span><br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">100</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// Safety: 没有线程会修改 DATA，因为 READY 已经被设置</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; DATA &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <h3 id="释放序列release-sequence">释放序列（Release Sequence）</h3><p>我们再来看一段代码示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;sync::atomic::AtomicU8, thread&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> DATA: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i64</span>&gt; = <span class="hljs-built_in">vec!</span>[];<br><span class="hljs-keyword">static</span> FLAG: AtomicU8 = AtomicU8::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread_1</span>() &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        DATA.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">42</span>);<br>    &#125;<br>    FLAG.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, std::sync::atomic::Ordering::Release);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread_2</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">expected</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// memory_order_relaxed is okay because this is an RMW,</span><br>    <span class="hljs-comment">// and RMWs (with any ordering) following a release form a release sequence</span><br>    <span class="hljs-keyword">while</span> FLAG<br>        .<span class="hljs-title function_ invoke__">compare_exchange</span>(<br>            expected,<br>            <span class="hljs-number">2</span>,<br>            std::sync::atomic::Ordering::Relaxed,<br>            std::sync::atomic::Ordering::Relaxed,<br>        )<br>        .<span class="hljs-title function_ invoke__">is_err</span>()<br>    &#123;<br>        expected = <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread_3</span>() &#123;<br>    <span class="hljs-keyword">while</span> FLAG.<span class="hljs-title function_ invoke__">load</span>(std::sync::atomic::Ordering::Acquire) &lt; <span class="hljs-number">2</span> &#123;&#125;<br>    <span class="hljs-comment">// if we read the value 2 from the atomic flag, we see 42 in the vector</span><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(DATA[<span class="hljs-number">0</span>], <span class="hljs-number">42</span>); <span class="hljs-comment">// will never fire</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(thread_1);<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(thread_2);<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(thread_3);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是参考 <ahref="https://en.cppreference.com/w/cpp/atomic/memory_order">cppreference</a>而翻译成 Rust 代码的，在上述代码中，即使 <code>thread_2</code>中我们使用的是 <code>Relaxed</code>， 这段代码中的<code>assert_eq!(DATA[0], 42)</code>也是一定成功的。为什么呢？这涉及到一个重要的概念——<strong>释放序列（ReleaseSequence）</strong>：</p><ul><li>当一个 <code>release</code>操作后面跟着一系列的原子<code>"读-修改-写"(RMW)</code>操作时，这些操作会形成一个释放序列。</li><li>在这个序列中，后续的 RMW 操作<strong>不需要</strong>使用 release 或acquire 语义也能保证同步。</li></ul><p>在这段代码中：当 <code>thread_2</code> 的 <code>RMW</code>操作成功的时候，说明 <code>FLAG</code> 是 <code>1</code>，即<code>thread_1</code> 已经执行了 <code>release</code>操作，这个时候：</p><ol type="1"><li><code>thread_1</code> 的 <code>release</code> 操作建立了同步点</li><li><code>thread_2</code> 的 <code>RMW</code>操作自动成为释放序列的一部分</li><li>当 <code>thread_3</code> 通过 <code>acquire</code> 看到值 2时，它能看到整个释放序列的所有修改。</li><li>因此能保证看到 <code>DATA</code> 中的 42。</li></ol><p>所以在这种场景下使用 <code>relaxed</code> 既安全又高效，因为：</p><ul><li>它是释放序列的一部分</li><li>不需要额外的同步开销</li><li>仍然能保证正确的内存顺序</li></ul><p>为什么这样设计呢？</p><ul><li><strong>原子性保证</strong>：RMW操作本身就是原子的，不会产生数据竞争</li><li><strong>连续性</strong>：每个 RMW操作都直接或间接地基于前一个操作的结果</li><li><strong>因果关系</strong>：形成了一个清晰的修改链条</li><li><strong>性能考虑</strong>：中间的 RMW 操作不需要额外的同步开销</li></ul>          </div><h3 id="sequentially-consistent">Sequentially Consistent</h3><p><code>SeqCst</code> 是最严格的内存顺序，它包括获取<code>release</code> 和 <code>acquire</code>的所有保证，还保证了全局一致的操作顺序。简单理解就是，你代码的顺序是怎么样，实际的执行顺序就是什么样。</p><p>我们来看一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::Ordering::SeqCst;<br><br><span class="hljs-keyword">static</span> A: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">static</span> B: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> S: <span class="hljs-type">String</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        A.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, SeqCst);<br>        <span class="hljs-keyword">if</span> !B.<span class="hljs-title function_ invoke__">load</span>(SeqCst) &#123;<br>            <span class="hljs-keyword">unsafe</span> &#123; S.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&#x27;!&#x27;</span>) &#125;;<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        B.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, SeqCst);<br>        <span class="hljs-keyword">if</span> !A.<span class="hljs-title function_ invoke__">load</span>(SeqCst) &#123;<br>            <span class="hljs-keyword">unsafe</span> &#123; S.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&#x27;!&#x27;</span>) &#125;;<br>        &#125;<br>    &#125;);<br><br>    a.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    b.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，两个线程都是希望将自己的原子变量设置为<code>true</code>，从而阻止另外一个线程对 <code>S</code> 进行<code>push</code> 操作，其实就类似于锁。因为这里使用了<code>SeqCst</code>，所以代码的执行顺序是跟代码编写顺序是一致的，那么就可能出现以下3 种执行情况：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241112113535084.png"alt="seqcst-memory-order" /><figcaption aria-hidden="true">seqcst-memory-order</figcaption></figure><p>即：同一时刻，<strong>最多</strong>只可能有一个线程会对<code>S</code> 进行操作。</p><h1 id="内存屏障">内存屏障</h1><p>除了内存顺序（MemoryOrder），还有另外一种方式可以控制程序的执行顺序，就是内存屏障（MemoryBarrier）。内存屏障是一种底层的同步原语，它能强制处理器按照特定的顺序执行内存操作。内存屏障通过阻止或限制指令重排序，来确保内存操作的可见性和顺序性。</p><h2 id="基本概念">基本概念</h2><p>内存屏障主要分为以下几种类型：</p><ol type="1"><li><strong>Load Barrier（读屏障）</strong><ul><li>确保在屏障之前的所有读操作都执行完成</li><li>防止后续读操作被重排到屏障之前</li><li>对应 Acquire 语义</li></ul></li><li><strong>Store Barrier（写屏障）</strong><ul><li>确保在屏障之前的所有写操作都执行完成</li><li>防止后续写操作被重排到屏障之前</li><li>对应 Release 语义</li></ul></li><li><strong>Full Barrier（全屏障）</strong><ul><li>同时包含读屏障和写屏障的功能</li><li>防止任何内存操作的重排序</li><li>对应 SeqCst 语义</li></ul></li></ol><p>即下面这 2 种实现方式是等价的：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241112123652784.png" alt="fench" style="zoom:50%;" /></p><p>所以到这里，我们可以更好地理解<strong>为什么 <code>release</code>是阻止其前面的内存访问越过它，而 <code>acquire</code>是阻止其后面的内存访问越过它了</strong>。因为有个 <code>fence</code>在前面或后面拦着！</p><p>但是一般来说，下面的写法相比上面的写法会有一丢丢的性能损失，因为这会增加一些额外的处理指令。那<code>fence</code> 的用武之地是什么呢？</p><ol type="1"><li>可以同时对多个原子操作进行 <code>fench</code>；</li><li>可以根据条件判断，选择是否进行 <code>fench</code>。</li></ol><p>举个例子：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241112125023036.png" alt="fence-multi-atomics" style="zoom:50%;" /></p><p>这个例子的关键点是：</p><ol type="1"><li>如果线程 2 中的任何一个 load 操作观察到了线程 1 中对应的 store操作的值：<ul><li>比如 A.load() 读到了值 1，或</li><li>B.load() 读到了值 2，或</li><li>C.load() 读到了值 3</li></ul></li><li>那么：线程 1 中的 release fence 就会 happens-before 线程 2 中的acquire fence。这意味着线程 1 中 release fence 之前的所有内存操作对线程2 中 acquire fence 之后的操作都是可见的。</li></ol><p>这展示了内存屏障的一个重要优势：<strong>一个屏障可以同时为多个原子操作建立同步关系，而不需要在每个原子操作上都使用Release/Acquire 内存序。这在某些场景下可能会更高效。</strong></p><p>用更通俗的话说：这就像在线程 1 设置了一个"检查点"（releasefence），在线程 2 也设置了一个"检查点"（acquire fence），只要线程 2看到了线程 1 在其检查点之后做的任何一个改动，那么线程 1检查点之前的所有操作对线程 2 的检查点之后都是可见的。</p><h2 id="硬件实现">硬件实现</h2><p>不同的处理器架构实现内存屏障的方式不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; x86/x64<br>MFENCE  ; 全屏障<br>LFENCE  ; 读屏障<br>SFENCE  ; 写屏障<br><br>; ARM<br>DMB     ; 数据内存屏障<br>DSB     ; 数据同步屏障<br>ISB     ; 指令同步屏障<br></code></pre></td></tr></table></figure><h2 id="与内存顺序的关系">与内存顺序的关系</h2><p>Rust 的内存顺序实际上是通过内存屏障来实现的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Release 写入会插入 Store Barrier</span><br>atomic.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">42</span>, Ordering::Release);  <span class="hljs-comment">// 编译器会在此处插入 Store Barrier</span><br><br><span class="hljs-comment">// Acquire 读取会插入 Load Barrier</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = atomic.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire);  <span class="hljs-comment">// 编译器会在此处插入 Load Barrier</span><br><br><span class="hljs-comment">// SeqCst 操作会插入 Full Barrier</span><br>atomic.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">42</span>, Ordering::SeqCst);  <span class="hljs-comment">// 编译器会在此处插入 Full Barrier</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>注意：直接使用内存屏障是非常底层的操作，通常我们应该使用 Rust提供的高级抽象（如原子类型和它们的内存顺序）来实现同步。内存屏障的知识主要用于理解这些高级抽象的工作原理。</p>          </div><h1 id="go-atomic">Go Atomic</h1><p>熟悉 Go 语言的读者应该会意识到在使用 Go语言的原子类型的时候，好像都没见过 Memory Order 这个东西，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>data := atomic.Int64&#123;&#125;<br>data.Add(<span class="hljs-number">1</span>)<br>data.And(<span class="hljs-number">2</span>)<br>data.Or(<span class="hljs-number">3</span>)<br>data.Swap(<span class="hljs-number">4</span>)<br>data.Store(<span class="hljs-number">5</span>)<br>data.Load()<br>data.CompareAndSwap(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <ahref="https://github.com/golang/go/blob/release-branch.go1.23/src/sync/atomic/doc.go">atomic/doc.go</a>源码中我们可以看到这段话：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The load and store operations, implemented by the LoadT and StoreT</span><br><span class="hljs-comment">// functions, are the atomic equivalents of &quot;return *addr&quot; and</span><br><span class="hljs-comment">// &quot;*addr = val&quot;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// In the terminology of [the Go memory model], if the effect of</span><br><span class="hljs-comment">// an atomic operation A is observed by atomic operation B,</span><br><span class="hljs-comment">// then A “synchronizes before” B.</span><br><span class="hljs-comment">// Additionally, all the atomic operations executed in a program</span><br><span class="hljs-comment">// behave as though executed in some sequentially consistent order.</span><br><span class="hljs-comment">// This definition provides the same semantics as</span><br><span class="hljs-comment">// C++&#x27;s sequentially consistent atomics and Java&#x27;s volatile variables.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// [the Go memory model]: https://go.dev/ref/mem</span><br></code></pre></td></tr></table></figure><p>Go语言设计者认为让程序员选择内存序会增加复杂性和出错的可能，所以为了程序的简单性和可预测性，直接就<strong>使用了最安全的<code>Seq-Cst</code> 内存顺序</strong>了。</p><p><a href="https://go.dev/ref/mem">the Go memory model</a>中还提了一句：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">If you must read the rest of this document to understand the behavior of your program, you are being too clever.<br>Don&#x27;t be clever.<br></code></pre></td></tr></table></figure><p>这也呼应了 Go 的设计理念：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Share memory by communicating; don&#x27;t communicate by sharing memory.<br></code></pre></td></tr></table></figure><p>所以总结一下：</p><ol type="1"><li>Go 的原子操作采用了最强的顺序一致性内存序；</li><li>这是一个有意识的设计选择，为了简单性和可预测性；</li><li>如果你需要更细粒度的内存序控制，那么 Go 可能不是最佳选择；</li><li>Go 更推荐使用 channels 和其他同步原语来进行并发控制。</li></ol><h1 id="参考">参考</h1><ul><li><a href="https://marabos.nl/atomics/memory-ordering.html">RustAtomics And Lock</a></li><li><ahref="https://mp.weixin.qq.com/s/t5_Up2YZEZt1NLbvgYz9FQ">聊一聊内存模型与内存序</a></li><li><ahref="https://en.cppreference.com/w/cpp/atomic/memory_order">cppreference</a></li><li><a href="https://go.dev/ref/mem">the Go memory model</a></li></ul>]]></content>
    
    
    <summary type="html">本文深入探讨了 Rust 中的原子操作和内存顺序模型。从硬件层面的原子操作实现原理出发,详细介绍了 Rust 提供的各种原子类型及其操作,并重点阐述了内存顺序(Memory Ordering)的概念、分类及其在并发编程中的应用。通过大量示例代码和图解,帮助读者全面理解 Rust 的内存模型和并发安全机制。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 底层原理" scheme="https://hedon.top/categories/Rust/Rust-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="内存顺序" scheme="https://hedon.top/tags/%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F/"/>
    
    <category term="内存屏障" scheme="https://hedon.top/tags/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    
    <category term="并发控制" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
    <category term="Atomic" scheme="https://hedon.top/tags/Atomic/"/>
    
    <category term="Happens-Before" scheme="https://hedon.top/tags/Happens-Before/"/>
    
  </entry>
  
  <entry>
    <title>KCP 源码分析与原理总结</title>
    <link href="https://hedon.top/2024/06/12/kcp/"/>
    <id>https://hedon.top/2024/06/12/kcp/</id>
    <published>2024-06-12T03:08:02.000Z</published>
    <updated>2024-11-29T09:14:37.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>本文很大部分参考了 <ahref="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP协议的原理和实现</a>，非常感谢该文作者的讲解。本文再此基础上，加入了一些笔者的思考和分析图示，以期更好地理解KCP 的底层原理。</p><h1 id="结论先行">结论先行</h1><p>KCP 是一个快速可靠协议，能以比 TCP 浪费 10%-20%的带宽的代价，换取平均延迟降低30%-40%，且最大延迟降低三倍的传输效果。</p><p>TCP 是为流量设计的（每秒内可以传输多少 KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以 10%-20%带宽浪费的代价换取了比 TCP 快 30%-40% 的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而 KCP是水流湍急的小激流。</p><h2 id="kcp-增加的带宽在哪里增加的速度又在哪里">KCP增加的带宽在哪里？增加的速度又在哪里？</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612111337839.png"alt="为什么 KCP 能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%？" /><figcaption aria-hidden="true">为什么 KCP 能以比 TCP 浪费 10%-20%的带宽的代价，换取平均延迟降低 30%-40%？</figcaption></figure><h2 id="kcp-核心特性">KCP 核心特性</h2><p><strong>快速重传</strong>： KCP支持快速重传机制，不像 TCP那样依赖超时重传。KCP可以根据接收方返回的确认信息快速判断哪些数据包已经丢失，并迅速进行重传。</p><p><strong>选择性确认（Selective Acknowledgment, SACK）</strong>： KCP支持SACK，这允许接收端告知发送端哪些包已经收到，从而仅重传未被确认接收的数据包，减少不必要的重传。</p><p><strong>无连接操作</strong>： 基于 UDP 的实现使得 KCP在传输数据前不需要像 TCP那样进行三次握手建立连接，这减少了初始的延迟，并使其能在连接性较差的网络环境下更加灵活和快速。</p><p><strong>拥塞控制</strong>： KCP 实现了类似 TCP的拥塞控制算法，但更为简化，能够快速适应网络条件的变化，如带宽波动和丢包。</p><p><strong>流量控制</strong>： KCP允许调整发送和接收的窗口大小，使得发送方可以根据接收方的处理能力和网络条件调整数据发送速率，优化网络利用率和减少拥塞。</p><p><strong>可配置的传输策略</strong>： KCP允许用户根据应用需求调整内部参数，如传输间隔、窗口大小等，以达到最优的传输效率和延迟。</p><p><strong>前向错误校正（Forward Error Correction, FEC）</strong>： KCP还可以结合使用 FEC技术，通过发送额外的冗余数据来恢复丢失的包，进一步提高在高丢包环境下的数据传输可靠性。</p><h2 id="为什么-tcp-做不到-kcp-这样">为什么 TCP 做不到 KCP 这样？</h2><p>TCP作为一种成熟且广泛使用的传输协议，在设计上注重可靠性和通用性，因此在拥塞控制和流量控制方面相对保守，以确保在各种网络条件下都能稳定运行。然而，这些设计上的保守性也导致了TCP 在某些情况下的灵活性和自适应性不如 KCP。</p><table><thead><tr class="header"><th>特性类别</th><th>协议</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>拥塞控制机制</td><td>TCP</td><td>固定算法（慢启动、拥塞避免等），保守的调整策略（指数和线性增长）</td></tr><tr class="even"><td></td><td>KCP</td><td>灵活算法，动态调整策略，快速调整窗口大小</td></tr><tr class="odd"><td>重传机制的延迟</td><td>TCP</td><td>固定重传间隔（RTO），多次确认触发重传，需要主动开启选择性重传（SACK）</td></tr><tr class="even"><td></td><td>KCP</td><td>快速重传，选择性重传，减少重传延迟</td></tr><tr class="odd"><td>流量控制</td><td>TCP</td><td>固定流量控制（依赖接收窗口和发送窗口），通用性设计</td></tr><tr class="even"><td></td><td>KCP</td><td>自适应流量控制，应用层反馈调整发送窗口和重传策略</td></tr><tr class="odd"><td>应用场景</td><td>TCP</td><td>广泛应用于各种网络环境，标准化要求高</td></tr><tr class="even"><td></td><td>KCP</td><td>优化特定场景（如高丢包率和高延迟网络），灵活实现</td></tr></tbody></table><h3 id="拥塞控制机制的固定性">1. 拥塞控制机制的固定性</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定算法</strong>：TCP 的拥塞控制算法，如慢启动（SlowStart）、拥塞避免（Congestion Avoidance）、快速重传（FastRetransmit）和快速恢复（FastRecovery），在设计时考虑了广泛的兼容性和可靠性。这些算法虽然有效，但其调整机制相对固定，响应速度较慢。</li><li><strong>保守的调整策略</strong>：TCP的拥塞控制算法采用了保守的调整策略，例如指数增长和线性增长，这在高丢包率或高延迟网络中，可能会导致拥塞窗口（cwnd）增长速度较慢，影响传输效率。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>灵活算法</strong>：KCP的拥塞控制机制更为灵活，可以根据实时网络状况进行快速调整。例如，KCP的快速重传和选择性重传机制，使其能更快速地响应网络丢包情况。</li><li><strong>动态调整策略</strong>：KCP的拥塞窗口调整更为灵活，可以根据网络状况快速增加或减少窗口大小，提高传输效率。</li></ul><h3 id="重传机制的延迟">2. 重传机制的延迟</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定重传间隔</strong>：TCP使用固定的重传超时（RTO），并随着每次重传逐渐增加（指数回退），这种保守的重传机制在高延迟和高丢包率网络中可能导致重传延迟较长。</li><li><strong>多次确认触发重传</strong>：TCP 的快速重传需要等待三个重复的ACK 才能触发，这在丢包率较高的情况下，可能会导致较长的延迟。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>快速重传</strong>：KCP在检测到丢包后立即进行重传，而不需要等待多个重复的ACK，这显著减少了重传延迟。</li><li><strong>选择性重传</strong>：KCP只重传丢失的数据包，而不是所有未确认的数据包，减少了不必要的重传开销。（TCP其实也支持选择性重传 SACK）</li></ul><h3 id="流量控制的灵活性">3. 流量控制的灵活性</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定流量控制</strong>：TCP的流量控制主要依赖于接收窗口（rwnd）和发送窗口（swnd），在处理突发流量或变化较大的网络条件时，调整速度较慢。</li><li><strong>通用性设计</strong>：TCP作为一种通用协议，其设计必须兼顾各种网络环境，因此在流量控制上相对保守，以确保在任何环境下都能稳定运行。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>自适应流量控制</strong>：KCP的流量控制机制可以根据实际应用需求进行更细粒度的调整。例如，KCP可以根据延迟抖动、丢包率等动态参数调整发送速率，确保在不同网络条件下都能保持高效传输。</li><li><strong>应用层反馈</strong>：KCP可以根据应用层的实时反馈，动态调整发送窗口和重传策略，进一步优化传输效率。</li></ul><h3 id="应用场景的差异">4. 应用场景的差异</h3><p><strong>TCP</strong>：</p><ul><li><strong>广泛应用</strong>：TCP设计用于广泛的网络环境，包括稳定的有线网络和不稳定的无线网络，因此其机制必须足够通用和保守，保证在各种情况下的可靠性。</li><li><strong>标准化要求</strong>：作为互联网的基础协议，TCP的各项机制经过严格标准化，任何修改都需要广泛测试和验证，以确保不会影响现有网络的稳定性。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>特定优化</strong>：KCP设计初衷是优化特定场景下的传输性能，特别是高丢包率和高延迟网络，因此在设计上更加灵活，能够根据实时网络状况进行调整。</li><li><strong>灵活实现</strong>：KCP可以根据具体应用需求进行优化，例如在实时通信和在线游戏等场景中，灵活的流量控制和快速重传机制显著提升了传输效率。</li></ul><h3 id="结论">结论</h3><p>虽然 TCP在拥塞控制和流量控制方面具备基本的动态调整能力，但其保守的设计和标准化要求使得其在高丢包率和高延迟网络中的适应性和灵活性不如KCP。KCP通过灵活的拥塞控制、快速重传和自适应流量控制机制，能够更有效地应对不同网络条件下的传输需求，提供更高效的传输性能。</p><h2 id="kcp-一定比-tcp-快吗">KCP 一定比 TCP 快吗？</h2><p><font color="red">不一定</font>。KCP 并不一定在所有情况下都比 TCP快。虽然 KCP在某些特定网络环境（如高丢包率和高延迟的网络）中表现更优异，但在某些情况下，TCP可能更合适。</p><h3 id="网络环境">1. 网络环境</h3><p><strong>高丢包率和高延迟网络</strong>：</p><ul><li><strong>KCP</strong>：KCP通过快速重传和选择性重传机制，以及动态调整的窗口和重传间隔，能够更好地应对高丢包率和高延迟网络，减少传输延迟，提高传输效率。</li><li><strong>TCP</strong>：TCP的重传机制和保守的拥塞控制在这种环境中可能导致较高的延迟和较低的带宽利用率。</li></ul><p><strong>低丢包率和低延迟网络</strong>：</p><ul><li><strong>KCP</strong>：在稳定的低丢包率和低延迟网络中，KCP的频繁重传和控制报文可能会导致额外的带宽开销，未必有明显的性能优势。</li><li><strong>TCP</strong>：TCP在这种环境中表现稳定，且由于其带宽开销较小，可能比 KCP 更高效。</li></ul><h3 id="带宽利用率">2. 带宽利用率</h3><p><strong>带宽充足的网络</strong>：</p><ul><li><strong>KCP</strong>：KCP由于其频繁的重传和控制报文，可能会占用更多的带宽，但如果带宽充足，这种开销对整体性能影响较小，且其低延迟优势可能更明显。</li><li><strong>TCP</strong>：TCP的带宽利用率较高，适合带宽充足的环境。</li></ul><p><strong>带宽受限的网络</strong>：</p><ul><li><strong>KCP</strong>：KCP的额外带宽开销在带宽受限的网络中可能会显著影响整体传输效率。</li><li><strong>TCP</strong>：TCP的较低带宽开销使其在带宽受限的环境中更有优势。</li></ul><h3 id="应用场景">3. 应用场景</h3><p><strong>实时应用</strong>（如在线游戏、视频会议）：</p><ul><li><strong>KCP</strong>：KCP的低延迟和快速响应能力使其非常适合实时应用，在这些场景中，传输的及时性比带宽利用率更重要。</li><li><strong>TCP</strong>：TCP 在这些场景中的表现可能不如KCP，特别是在高丢包率和高延迟的网络中。</li></ul><p><strong>非实时应用</strong>（如文件传输、网页浏览）：</p><ul><li><strong>KCP</strong>：KCP 在这些场景中可能不如 TCP高效，特别是在网络稳定且带宽有限的情况下。</li><li><strong>TCP</strong>：TCP的可靠性和高带宽利用率使其非常适合非实时应用。</li></ul><h3 id="实现和配置">4. 实现和配置</h3><p><strong>实现复杂性</strong>：</p><ul><li><strong>KCP</strong>：实现和配置 KCP 可能比 TCP更复杂，需要根据具体应用和网络环境进行优化和调整。</li><li><strong>TCP</strong>：TCP是一个成熟的协议，系统和库的支持较好，配置和使用相对简单。</li></ul><h3 id="总结">总结</h3><p>KCP 在某些特定环境和应用场景中确实比 TCP更快，尤其是高丢包率和高延迟的网络环境，以及对低延迟要求较高的实时应用。但在网络稳定、带宽有限或非实时应用场景中，TCP可能表现更好。因此，选择使用 KCP 还是 TCP应根据具体的网络条件和应用需求进行权衡。</p><h1 id="前置准备">前置准备</h1><p>笔者不想那么快就贴出大段大段的代码进行分析，这可能会使读者不知所云。为了更好地阐述KCP的底层原理，笔者的设想是先对原理部分进行概要总结，然后再带着这些结论去分析源码，进一步填充里面的边角细节。</p><p>但是呢，为了更好地理解 KCP的原理，又不得不对涉及源码的一些重要设计，为了避免在原理分析阶段，对源码进行过多的涉及，笔者决定添加这单独的一章内容，对KCP 的“接口设计”、“报文段”、“KCP控制块”以及“队列和缓冲区”先进行简要概述，以辅助读者更好地理解后续的内容。</p><h2 id="接口设计">接口设计</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612171839051.png"alt="KCP 工作简约图" /><figcaption aria-hidden="true">KCP 工作简约图</figcaption></figure><p>在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h">kcp.h</a>文件中，定义了 KCP 最核心的几个接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个新的 KCP 控制对象</span><br>ikcpcb* <span class="hljs-title function_">ikcp_create</span><span class="hljs-params">(IUINT32 conv, <span class="hljs-type">void</span> *user)</span>;<br><br><span class="hljs-comment">// 释放一个 KCP 控制对象。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_release</span><span class="hljs-params">(ikcpcb *kcp)</span>;<br><br><span class="hljs-comment">// 设置 KCP 的输出回调函数，这个回调函数在 KCP 需要发送数据时被调用。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_setoutput</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">int</span> (*output)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> len, </span><br><span class="hljs-params">ikcpcb *kcp, <span class="hljs-type">void</span> *user))</span>;<br><br><span class="hljs-comment">// 从 KCP 的接收队列中接收数据，用于上层从 KCP 中读取数据。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_recv</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> len)</span>;<br><br><span class="hljs-comment">// 向 KCP 的发送队列中添加数据，用于上层向 KCP 发送数据，KCP 会管理这些数据并负责其可靠传输。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_send</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> len)</span>;<br><br><span class="hljs-comment">// 更新 KCP 的内部状态，通常需要定期调用。</span><br><span class="hljs-comment">// 这个函数负责处理 KCP 的超时、重传等操作，需要在一定的时间间隔内反复调用（通常每 10-100 毫秒）。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_update</span><span class="hljs-params">(ikcpcb *kcp, IUINT32 current)</span>;<br><br><span class="hljs-comment">// 判断是否要调用 ikcp_update</span><br>IUINT32 <span class="hljs-title function_">ikcp_check</span><span class="hljs-params">(<span class="hljs-type">const</span> ikcpcb *kcp, IUINT32 current)</span>;<br><br><span class="hljs-comment">// 处理接收到的低层数据包（例如 UDP 包）。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_input</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">long</span> size)</span>;<br><br><span class="hljs-comment">// 将缓冲区可以发送的包发送出去，会在 ikcp_update 中被调用。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_flush</span><span class="hljs-params">(ikcpcb *kcp)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>ikcp_create</code>:</p><ul><li><code>conv</code>:会话标识符，用于标识两个端点之间的连接。这个标识符在两个通信端点之间必须一致。</li><li><code>user</code>: 用户数据指针，可以传递任意用户数据，这个数据在KCP 的 <code>output</code> 回调中会被传递回去。</li><li><strong>返回值</strong>: 一个指向新创建的 KCP控制块（<code>ikcpcb</code>）的指针。</li></ul></li><li><p><code>ikcp_release</code>: 释放一个 KCP 控制对象。</p></li><li><p><code>ikcp_setoutput</code>: 设置 KCP 的输出回调函数。</p><ul><li><p><code>output</code>: 输出回调函数指针。这个回调函数在 KCP需要发送数据时被调用。</p><ul><li><code>buf</code>: 要发送的数据缓冲区。</li><li><code>len</code>: 数据长度。</li><li><code>kcp</code>: 当前的 KCP 对象。</li><li><code>user</code>: 用户数据。</li></ul><p>通过这个回调，KCP 可以将要发送的数据传递给下层的网络层，比如 UDP套接字。</p></li></ul></li><li><p><code>ikcp_recv</code>: 从 KCP 的接收队列中接收数据。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>buffer</code>: 用户提供的缓冲区，用于存储接收到的数据。</li><li><code>len</code>: 缓冲区的长度。</li><li><strong>返回值</strong>:成功接收的数据大小；如果没有数据可接收，返回负值（例如，EAGAIN）。</li></ul><p>这个函数用于上层从 KCP 中读取数据。</p></li><li><p><code>ikcp_send</code>: 向 KCP 的发送队列中添加数据。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>buffer</code>: 要发送的数据缓冲区。</li><li><code>len</code>: 数据的长度。</li><li><strong>返回值</strong>:成功发送的数据大小；如果发送失败，返回负值。</li></ul><p>这个函数用于上层向 KCP 发送数据，KCP会管理这些数据并负责其可靠传输。</p></li><li><p><code>ikcp_update</code>: 更新 KCP的内部状态，通常需要定期调用。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>current</code>: 当前的时间戳（以毫秒为单位）。</li></ul><p>这个函数负责处理 KCP的超时、重传等操作，需要在一定的时间间隔内反复调用（通常每 10-100毫秒）。</p></li><li><p><code>ikcp_input</code>: 处理接收到的低层数据包（例如 UDP包）。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>data</code>: 收到的数据缓冲区。</li><li><code>size</code>: 数据的长度。</li><li><strong>返回值</strong>:成功处理的数据大小；如果处理失败，返回负值。</li></ul></li><li><p><code>ikcp_flush</code>: 刷新待发送的数据。</p></li></ul><p>其中最重要的是这 4 个：</p><ul><li><code>ikcp_send</code>: 将数据放在发送队列中等待发送。</li><li><code>ikcp_recv</code>: 从接收队列中读取数据。</li><li><code>ikcp_input</code>:读取下层协议输入数据，解析报文段，如果是数据，就将数据放入接收缓冲区，如果是ACK，就在发送缓冲区中标记对应的报文段已送达。</li><li><code>ikcp_flush</code>:调用输出回调将发送缓冲区的数据发送出去。</li></ul><p>这里就先简要介绍到这里，后面在源码分析篇章再对这些接口进行详细分析。</p><h2 id="报文段">报文段</h2><p>KCP 的报文段大小为 24 字节，结构如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612172557464.png" alt="KCP 报文段" style="zoom: 33%;" /></p><p>每个字段的含义如下：</p><ul><li><code>conv</code>: 连接标识</li><li><code>cmd</code>：报文类型</li><li><code>frg</code>：分片数量，表示随后还有多少个报文属于同一个包</li><li><code>wnd</code>：发送方剩余接收窗口的大小</li><li><code>ts</code>：时间戳</li><li><code>sn</code>：报文编号</li><li><code>una</code>：发送方的接收缓冲区中最小还未收到的报文段的编号，也就是说，比它小的报文段都已全部接收</li><li><code>len</code>：数据段长度</li><li><code>data</code>：数据段，只有数据报文会有这个字段</li></ul><p>其中 <code>cmd</code> 共有 4 种报文类型：</p><ul><li>数据报文：IKCP_CMD_PUSH</li><li>确认报文：IKCP_CMD_ACK</li><li>窗口探测报文：IKCP_CMD_WASK 询问对端剩余接收窗口的大小</li><li>窗口通知报文：IKCP_CMD_WINS 通知对端剩余接收窗口的大小</li></ul><p>在 KCP 中，报文段结构定义在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h">kcp.h</a>文件中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPSEG</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">node</span>;</span><br>IUINT32 conv;<br>IUINT32 cmd;<br>IUINT32 frg;<br>IUINT32 wnd;<br>IUINT32 ts;<br>IUINT32 sn;<br>IUINT32 una;<br>IUINT32 len;<br>IUINT32 resendts;<br>IUINT32 rto;<br>IUINT32 fastack;<br>IUINT32 xmit;<br><span class="hljs-type">char</span> data[<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>IKCPSEG</code> 结构还多出了几个字段，这是为了支持 KCP协议的可靠性和效率：</p><ul><li><code>resendts</code>:记录报文的下次重传时间，用于实现重传机制。如果报文在一定时间内没有被确认收到，就会在这个时间戳之后被重新发送。</li><li><code>rto</code>: 表示当前报文的重传超时时间（RTT的估计值）。用于计算每个报文的重传时间，如果超过 <code>rto</code>时间没有收到 ACK，会触发重传。</li><li><code>fastack</code>:快速重传计数，记录该报文被跳过的次数。如果一个报文的 ACK连续接收到多个对同一报文的确认，而不是新的报文，会增加这个计数，用于实现快速重传机制。</li><li><code>xmit</code>:记录报文已经被发送的次数。用于统计一个报文的重传次数，帮助判断传输的可靠性。如果操作<code>dead_link</code> 次，则会判断为连接失效，KCP 会断开连接。</li><li><code>node</code>: 链表节点，用于将多个 <code>IKCPSEG</code>结构体链接在一起。KCP 的队列和缓冲区都是循环双链表结构。</li></ul><p>这些字段共同作用，帮助 KCP 实现以下功能：</p><ul><li><strong>可靠性</strong>：通过 <code>sn</code>、<code>una</code> 和<code>ack</code> 确保数据包按顺序接收和重传。</li><li><strong>流量控制</strong>：通过 <code>wnd</code>控制数据流量，避免接收方过载。</li><li><strong>高效传输</strong>：通过 <code>resendts</code> 和<code>rto</code> 进行超时和重传控制，<code>fastack</code>提供快速重传机制。</li><li><strong>灵活管理</strong>：使用链表节点 <code>node</code>组织数据，便于内部管理。</li></ul><h2 id="kcp-控制块-ikcpcb">KCP 控制块 ikcpcb</h2><p>上面我们提到的 <code>ikcp_create</code> 和 <code>ikcp_release</code>就是对 KCP 控制块 <code>ikcpcb</code> 的创建和释放，每个 KCP连接都对应一个 KCP 控制块。它定义在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h#L343">kcp.h</a>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPCB</span></span><br><span class="hljs-class">&#123;</span><br>IUINT32 conv, mtu, mss, state;<br>IUINT32 snd_una, snd_nxt, rcv_nxt;<br>IUINT32 ts_recent, ts_lastack, ssthresh;<br>IINT32 rx_rttval, rx_srtt, rx_rto, rx_minrto;<br>IUINT32 snd_wnd, rcv_wnd, rmt_wnd, cwnd, probe;<br>IUINT32 current, interval, ts_flush, xmit;<br>IUINT32 nrcv_buf, nsnd_buf;<br>IUINT32 nrcv_que, nsnd_que;<br>IUINT32 nodelay, updated;<br>IUINT32 ts_probe, probe_wait;<br>IUINT32 dead_link, incr;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_buf</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_buf</span>;</span><br>IUINT32 *acklist;<br>IUINT32 ackcount;<br>IUINT32 ackblock;<br><span class="hljs-type">void</span> *user;<br><span class="hljs-type">char</span> *buffer;<br><span class="hljs-type">int</span> fastresend;<br><span class="hljs-type">int</span> fastlimit;<br><span class="hljs-type">int</span> nocwnd, stream;<br><span class="hljs-type">int</span> logmask;<br><span class="hljs-type">int</span> (*output)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> len, <span class="hljs-keyword">struct</span> IKCPCB *kcp, <span class="hljs-type">void</span> *user);<br><span class="hljs-type">void</span> (*writelog)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-built_in">log</span>, <span class="hljs-keyword">struct</span> IKCPCB *kcp, <span class="hljs-type">void</span> *user);<br>&#125;;<br></code></pre></td></tr></table></figure><p>字段的含义如下，读者可在后续分析过程回过来查阅：</p><table><thead><tr class="header"><th>字段名</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>conv</code></td><td>连接标识符，用于识别一个特定的会话。</td></tr><tr class="even"><td><code>mtu</code></td><td>最大传输单元（Maximum TransmissionUnit），表示网络层传输数据包的最大字节数。</td></tr><tr class="odd"><td><code>mss</code></td><td>最大报文段长度（Maximum SegmentSize），表示应用层传输数据的最大字节数。</td></tr><tr class="even"><td><code>state</code></td><td>连接状态，标识当前的传输状态。</td></tr><tr class="odd"><td><code>snd_una</code></td><td>未确认的发送序号，表示最早未确认的包的序号。</td></tr><tr class="even"><td><code>snd_nxt</code></td><td>下一个发送序号，表示即将发送的包的序号。</td></tr><tr class="odd"><td><code>rcv_nxt</code></td><td>下一个接收序号，表示期望接收的下一个包的序号。</td></tr><tr class="even"><td><code>ts_recent</code></td><td>最近的时间戳，用于延迟测量。</td></tr><tr class="odd"><td><code>ts_lastack</code></td><td>最近的确认时间戳，用于 RTT 计算。</td></tr><tr class="even"><td><code>ssthresh</code></td><td>拥塞避免的慢启动阈值。</td></tr><tr class="odd"><td><code>rx_rttval</code></td><td>RTT 的偏差，用于计算 RTT 的波动。</td></tr><tr class="even"><td><code>rx_srtt</code></td><td>平滑的 RTT 值，用于计算平均 RTT。</td></tr><tr class="odd"><td><code>rx_rto</code></td><td>重新传输超时时间，根据 RTT 动态调整。</td></tr><tr class="even"><td><code>rx_minrto</code></td><td>最小的重新传输超时时间。</td></tr><tr class="odd"><td><code>snd_wnd</code></td><td>发送窗口大小，控制发送流量的窗口。</td></tr><tr class="even"><td><code>rcv_wnd</code></td><td>接收窗口大小，控制接收流量的窗口。</td></tr><tr class="odd"><td><code>rmt_wnd</code></td><td>远端窗口大小，表示对方接收窗口的大小。</td></tr><tr class="even"><td><code>cwnd</code></td><td>拥塞窗口大小，控制发送流量的窗口，用于拥塞控制。</td></tr><tr class="odd"><td><code>probe</code></td><td>探测标志，表示是否需要进行窗口探测。</td></tr><tr class="even"><td><code>current</code></td><td>当前的时间戳。</td></tr><tr class="odd"><td><code>interval</code></td><td>刷新间隔时间，表示定期刷新 KCP 状态的间隔。</td></tr><tr class="even"><td><code>ts_flush</code></td><td>下次刷新时间戳，用于确定何时执行下一次状态刷新。</td></tr><tr class="odd"><td><code>xmit</code></td><td>发送次数，表示数据包重传的次数。</td></tr><tr class="even"><td><code>nrcv_buf</code></td><td>接收缓冲区的数据包数量。</td></tr><tr class="odd"><td><code>nsnd_buf</code></td><td>发送缓冲区的数据包数量。</td></tr><tr class="even"><td><code>nrcv_que</code></td><td>接收队列中的数据包数量。</td></tr><tr class="odd"><td><code>nsnd_que</code></td><td>发送队列中的数据包数量。</td></tr><tr class="even"><td><code>nodelay</code></td><td>延迟模式标志，表示是否启用无延迟模式。</td></tr><tr class="odd"><td><code>updated</code></td><td>更新标志，表示是否需要更新 KCP 状态。</td></tr><tr class="even"><td><code>ts_probe</code></td><td>下次探测时间戳，用于窗口探测。</td></tr><tr class="odd"><td><code>probe_wait</code></td><td>探测等待时间，表示等待多长时间后进行下一次窗口探测。</td></tr><tr class="even"><td><code>dead_link</code></td><td>死链标志，表示连接是否已经失效。</td></tr><tr class="odd"><td><code>incr</code></td><td>增量，用于控制流量的增加速率。</td></tr><tr class="even"><td><code>snd_queue</code></td><td>发送队列，用于存储待发送的数据包。</td></tr><tr class="odd"><td><code>rcv_queue</code></td><td>接收队列，用于存储待处理的数据包。</td></tr><tr class="even"><td><code>snd_buf</code></td><td>发送缓冲区，用于存储已经发送但未确认的数据包。</td></tr><tr class="odd"><td><code>rcv_buf</code></td><td>接收缓冲区，用于存储已经接收到但未处理的数据包。</td></tr><tr class="even"><td><code>acklist</code></td><td>确认列表，用于存储待发送的确认序号。</td></tr><tr class="odd"><td><code>ackcount</code></td><td>确认计数，表示确认列表中的条目数量。</td></tr><tr class="even"><td><code>ackblock</code></td><td>确认块大小，表示确认列表的内存分配大小。</td></tr><tr class="odd"><td><code>user</code></td><td>用户数据指针，用于存储用户自定义的数据。</td></tr><tr class="even"><td><code>buffer</code></td><td>缓冲区，用于临时存储发送的数据。</td></tr><tr class="odd"><td><code>fastresend</code></td><td>快速重传标志，表示启用快速重传功能。</td></tr><tr class="even"><td><code>fastlimit</code></td><td>快速重传限制，表示在一个 RTT 内允许的最大重传次数。</td></tr><tr class="odd"><td><code>nocwnd</code></td><td>无拥塞窗口控制标志，表示是否禁用拥塞窗口控制。</td></tr><tr class="even"><td><code>stream</code></td><td>流模式标志，表示是否启用流模式。</td></tr><tr class="odd"><td><code>logmask</code></td><td>日志掩码，用于控制日志输出的级别。</td></tr><tr class="even"><td><code>output</code></td><td>发送数据回调函数，用于发送数据。</td></tr><tr class="odd"><td><code>writelog</code></td><td>日志回调函数，用于输出日志。</td></tr></tbody></table><h2 id="队列和缓冲区">队列和缓冲区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPCB</span></span><br><span class="hljs-class">&#123;</span><br>  ...<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_buf</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_buf</span>;</span><br>  ...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">prev</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>KCP中队列和缓冲区都是循环双链表，链表由宏实现，笔者并不擅长，所以本文就不探讨该链表的实现了，有数据结构基础的笔者应该很好理解这一块。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612175626865.png"alt="队列和缓冲区的实现：循环双链表" /><figcaptionaria-hidden="true">队列和缓冲区的实现：循环双链表</figcaption></figure><p>队列和缓冲区是 KCP最核心的部分，它们的作用流程大概如下图所示，读者可以自行阅读尝试理解，后续我们会进行详细的分析。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612175950432.png"alt="KCP 队列和缓冲区作用流程" /><figcaption aria-hidden="true">KCP 队列和缓冲区作用流程</figcaption></figure><h1 id="原理分析">原理分析</h1><p>这一节我们详细讨论 KCP 的整个 ARQ流程。首先我们会对整体流程进行简要概述，然后详细讨论滑动窗口中的发送和接收过程，接着讨论超时重传和快速重传，在这之后我们会将KCP 和 TCP 的重传策略进行简单对比，最后介绍一下拥塞控制策略。</p><h2 id="整体流程">1. 整体流程</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612192523848.png"alt="KCP 全流程" /><figcaption aria-hidden="true">KCP 全流程</figcaption></figure><p>KCP 的全流程如上图所示：</p><ol type="1"><li>发送方调用 <code>ikcp_send</code>将发送数据，这个时候会创建报文段实例，并放入 <code>snd_queue</code>发送队列中。</li><li>KCP 会定时调用 <code>ikcp_update</code> 判断是否要调用<code>ikcp_flush</code>。</li><li>调用 <code>ikcp_flush</code> 时会将合适的报文段放入<code>snd_buf</code> 缓冲区中，具体包括：<ol type="1"><li>发送 ACK 列表中所有 ACK；</li><li>根据是否需要发送窗口探测和通知报文，需要则发；</li><li>根据发送窗口大小，将适量的报文段从 <code>snd_queue</code> 移入<code>snd_buf</code> 中；</li><li>发送 <code>snd_buf</code>中的报文，包括<strong>新加入的</strong>、<strong>RTO 内未收到ACK</strong> 的和 <strong>ACK 失序若干次</strong>的；</li><li>根据丢包情况计算 <code>ssthresh</code> 和 <code>cwnd</code>。</li></ol></li><li>发送的时候会调用由 <code>ikcp_setoutput</code>设置的回调函数，将数据发送到对端。</li><li>接收方收到数据后，会调用 <code>ikcp_input</code>，将数据放入<code>rcv_buf</code> 缓冲区，具体包括：<ol type="1"><li>根据所有报文的 una 将相应的报文标记为已送达；</li><li>如果是 ACK，就将相应的报文标记为已送达；</li><li>如果是数据报文，就将它放入 <code>rcv_buf</code>，然后将<code>rcv_buf</code> 中顺序正确的报文移入 <code>rcv_queue</code>接收队列中，接着将相关信息插入 ACK 列表，在稍后的<code>ikcp_flush</code> 中会发送相应的 ACK；</li><li>如果是窗口探测报文，就标记“需要发送窗口通知”，在稍后的<code>ikcp_flush</code> 中会发送窗口通知报文；</li><li>包括窗口通知报文在内的所有报文都有 wnd 字段，据此更新 rmt_wnd；</li><li>根据 ACK 失序情况决定是否进行快速重传；</li><li>计算 cwnd。</li></ol></li><li>调用 <code>ikcp_recv</code> 从 <code>rcv_queue</code>中接收数据。</li></ol><h2 id="滑动窗口">2. 滑动窗口</h2><p>发送缓冲区 <code>snd_buf</code> 和接收缓冲区 <code>rcv_buf</code>中活动的报文都是在滑动窗口之中的。这对于我们理解 KCP的发送和接收流程非常重要，所有我们先从滑动窗口开始介绍。</p><p>滑动窗口实际是一个抽象的概念,不能简单地认为它是缓冲区的一部分，准确的说，滑动窗口是由队列加缓冲区共同组成的。</p><h3 id="发送">2.1 发送</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612193023604.png"alt="发送窗口" /><figcaption aria-hidden="true">发送窗口</figcaption></figure><p><code>snd_una</code> 和 <code>snd_nxt</code>会努力往<strong>右</strong>移动：</p><ol type="1"><li><code>ikcp_flush</code> 时，会从 <code>snd_queue</code>中取出报文插入到 <code>snd_nxt</code> 的位置上；</li><li>如果<code>snd_nxt - snd_una &gt;= cwnd</code>，则不允许新的报文插入；</li><li>当 <code>snd_una</code> 的 ACK 报文到达时，<code>snd_una</code>就会右移到第一个没有收到 ACK 报文的位置；</li></ol><p>发送窗口中未确认到达的报文何时重传？</p><ul><li>报文在一个 RTO 时间内仍未确认到达，就会重传。报文 RTO 初始值是rx_rto ，会持续增长，速率支持配置。</li></ul><h3 id="接收">2.2 接收</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612193238859.png"alt="接收窗口" /><figcaption aria-hidden="true">接收窗口</figcaption></figure><ol type="1"><li>每收到一个数据报文, 都会根据它的编号将它插入到 <code>rcv_buf</code>对应的位置中；</li><li>接着检查 <code>rcv_nxt</code> 能否向右移动,只有当报文的顺序正确且连续才能移动；</li><li>在上图的例子中由于 4 号报文的缺失, <code>rcv_nxt</code> 只能处于 4号位置等待，5, 6 号报文也不能移动到 <code>rcv_queue</code> 中；</li><li>等到 4 号报文到达后，才能将 4, 5, 6 号报文一并移动到<code>rcv_queue</code> 中，同时 <code>rcv_nxt</code> 会右移到 7号位置。</li></ol><h3 id="案例分析">2.3 案例分析</h3><p>我们举个简单的例子演示整个 ARQ的流程。下图中实线箭头表示数据报文，虚线箭头表示 ACK。</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/kcp_5.svg"alt="KCP ARQ 流程" /><figcaption aria-hidden="true">KCP ARQ 流程</figcaption></figure><p>① t1 时刻发送方发送 1 号报文, 1 号报文放入发送缓冲区中, snd_una 指向1, snd_nxt 指向 2.</p><p>② t2 至 t3 时刻发送方依次发送 2 至 3 号报文, snd_nxt 依次后移.</p><p>③ 1 号报文丢包.</p><p>④ t4, t5 时刻接收方收到 3 号和 2 号报文, 放入 rcv_buf 中; 随后回复 3号和 2 号 ACK. 此时由于 1 号报文缺失, rcv_nxt 始终指向 1.</p><p>⑤ 3 号 ACK 丢包.</p><p>⑥ t7 时刻发送方收到 2 号 ACK, 将 2 号报文标记为已送达. 此时由于 3 号ACK 丢包, 3 号报文未标记为已送达. 由于 1 号报文未确认送达, snd_una亦指向 1.</p><p>⑦ t8 时刻 1 号报文超时, 重传.</p><p>⑧ t9 时刻接收方收到 1 号报文, 放入 rcv_buf 中; 这时 1, 2, 3号报文顺序正确, rcv_nxt 右移到 4 号位置. 接收方回复 1 号 ACK, 同时带上una = 4.</p><p>⑨ t10 时刻发送方收到 1 号 ACK, 将 1 号报文标记为已送达. 同时 una 表明1, 2, 3 号报文均已送达, 因此也将 3 号报文标记为已送达. snd_una 移动到4.</p><h2 id="超时重传">3. 超时重传</h2><p>超时重传是当发送的数据包在预定时间内未被确认时，重新发送该数据包的机制。在KCP 中，这个时间由重新传输超时（RTO）决定。KCP 计算 RTO 初始值的方法是TCP 的标准方法, 规定在 <ahref="https://www.rfc-editor.org/rfc/rfc6298.html">RFC 6298</a> 中。</p><p>这里还是贴出源码讲比较直观：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_update_ack</span><span class="hljs-params">(ikcpcb *kcp, IINT32 rtt)</span><br>&#123;<br>IINT32 rto = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (kcp-&gt;rx_srtt == <span class="hljs-number">0</span>) &#123;<br>kcp-&gt;rx_srtt = rtt;<br>kcp-&gt;rx_rttval = rtt / <span class="hljs-number">2</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">long</span> delta = rtt - kcp-&gt;rx_srtt;<br><span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>) delta = -delta;<br>kcp-&gt;rx_rttval = (<span class="hljs-number">3</span> * kcp-&gt;rx_rttval + delta) / <span class="hljs-number">4</span>;<br>kcp-&gt;rx_srtt = (<span class="hljs-number">7</span> * kcp-&gt;rx_srtt + rtt) / <span class="hljs-number">8</span>;<br><span class="hljs-keyword">if</span> (kcp-&gt;rx_srtt &lt; <span class="hljs-number">1</span>) kcp-&gt;rx_srtt = <span class="hljs-number">1</span>;<br>&#125;<br>rto = kcp-&gt;rx_srtt + _imax_(kcp-&gt;interval, <span class="hljs-number">4</span> * kcp-&gt;rx_rttval);<br>kcp-&gt;rx_rto = _ibound_(kcp-&gt;rx_minrto, rto, IKCP_RTO_MAX);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个计算过程笔者就不做详细介绍了，代码里面的公式读者可以尝试自行画图进行理解，这里就不花大篇幅画公式了，下面我尝试以更通俗易懂的话语解释RTO，只需要理解它在做什么，为什么这么做，就可以了，个人觉得对公式的细节可以暂且忽略。</p><h3 id="rto-计算目的">3.1 RTO 计算目的</h3><p>KCP 的 RTO计算是为了确定在多长时间内未收到确认（ACK）时，应该重新发送数据包。这段时间被称为重传超时时间（RTO）。计算RTO的目的是在网络条件变化的情况下，既能快速响应数据丢失，也能避免不必要的重传，从而保持高效的传输。</p><h3 id="rto-计算涉及的变量解释">3.2 RTO 计算涉及的变量解释</h3><p><strong>RTT 和 SRTT 的概念:</strong></p><ul><li>RTT（Round-Trip Time）:是从发送一个数据包到收到其确认（ACK）所花的时间。</li><li>SRTT（Smoothed RTT）: 是 RTT 的加权平均值，它代表了 RTT的一个更稳定的估计值。SRTT 的目的是减少 RTT 的短期波动对 RTO的影响。</li></ul><p><strong>RTT 变化值（RTTvariance）</strong>：网络传输时间并不总是固定的，有时会因为网络拥塞或其他原因出现波动。我们通过计算RTT 变化值（RTT variance）来估计这种波动的大小。</p><p><strong>为什么需要 SRTT 和 RTT 变化值：</strong></p><ul><li>SRTT 给我们一个平均的 RTT 估计值。</li><li>RTT 变化值告诉我们网络的波动性。如果波动很大，我们希望 RTO更大，以免因为短暂的网络延迟就触发不必要的重传。</li></ul><h3 id="rto-计算步骤">3.3 RTO 计算步骤</h3><p><strong>1. 初始化</strong>：初次计算时，我们没有历史 RTT值，所以直接用第一次测量的 RTT 来初始化 SRTT，并将 RTT 变化值设为 RTT的一半。</p><p><strong>2. 更新 SRTT 和 RTT 变化值</strong>:</p><ul><li>每次我们测量新的 RTT，就用它来更新 SRTT 和 RTT 变化值。</li><li>更新 SRTT：我们不直接替换旧的SRTT，而是用一个平滑的方式（即加权平均），使得 SRTT 逐渐靠近新RTT，但又不会剧烈变化。</li><li>更新 RTT 变化值：计算新的 RTT 与 SRTT 的差值，用这个差值来更新 RTT变化值，使其反映当前网络波动的大小。</li></ul><p><strong>3. 计算 RTO</strong>:</p><ul><li>用 SRTT 加上四倍的 RTT 变化值来计算 RTO，这样可以确保 RTO足够长，能涵盖大部分的网络波动。</li><li>我们还要确保 RTO 不小于一个最小值（<code>rx_minrto</code>），以防止RTO过小导致频繁重传；也不能大于一个最大值（<code>IKCP_RTO_MAX</code>），以防止RTO 过大影响响应速度。</li></ul><h3 id="rto-计算效果">4. RTO 计算效果</h3><ul><li><strong>稳定的传输</strong>: SRTT 提供了一个稳定的平均 RTT估计，使得 RTO 能适应网络的长期变化。</li><li><strong>适应网络波动</strong>: RTT 变化值使得 RTO能够应对网络的短期波动，减少因短暂延迟而导致的重传。</li><li><strong>快速响应</strong>: RTO设置合理后，能够在数据丢失时快速重传，保持传输的高效和及时性。</li></ul><p>通过这样的计算方式，KCP能够在不同的网络条件下，自动调整重传策略，从而在保证数据可靠性的同时，保持较高的传输效率。</p><h2 id="快速重传">4. 快速重传</h2><p>在网络传输中，数据包可能会由于网络拥塞、丢包等原因而丢失。超时重传依赖于重传超时时间（RTO）来判断是否需要重传，这可能会导致响应延迟。而快速重传通过检测重复的确认包（ACK）来快速判断数据包的丢失，并立即触发重传，显著缩短了数据丢失的恢复时间。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612200038895.png"alt="KCP 快速重传" /><figcaption aria-hidden="true">KCP 快速重传</figcaption></figure><h3 id="何时快速重传">4.1 何时快速重传？</h3><ul><li>每个报文的 <code>fastack</code> 记录了它检测到 ACK 失序的次数，每当KCP 收到一个编号为 sn 的 ACK 时，就会检查 snd_buf 中编号小于 sn且未确认送达的报文，并将其 <code>fastack</code> 加 1。</li><li>可以通过配置 <code>fastresend</code>指定失序多少次就执行快速重传。</li><li>每次调用 ikcp_flush 都会重传 snd_buf 中<code>fastask &gt;= fastresend</code> 的报文。</li></ul><h3 id="无限快速重传吗">4.2 无限快速重传吗？</h3><ul><li>每个报文的 <code>xmit</code> 记录它被传输的次数，可以配置<code>fastlimit</code> 规定传输次数小于 <code>fastlimit</code>的报文才能执行快速重传。</li></ul><h2 id="比较-tcp-的超时重传和快速重传">5. 比较 TCP的超时重传和快速重传</h2><p>TCP 也实现了类似的机制，但在复杂性和应用场景上有所不同。</p><h3 id="tcp-的超时重传">5.1 TCP 的超时重传</h3><p><strong>1. RTT 估算</strong>:</p><ul><li><p>TCP 通过接收确认包来估算 RTT，并使用 RTT 的变化范围来计算RTO。</p></li><li><p>TCP 使用 Jacobson/Karels 算法进行 RTT 估算和 RTO 计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// SRTT and RTTVAR calculation</span><br>RTTVAR = (<span class="hljs-number">1</span> - β) * RTTVAR + β * |RTTsample - SRTT|<br>SRTT = (<span class="hljs-number">1</span> - α) * SRTT + α * RTTsample<br>RTO = SRTT + <span class="hljs-number">4</span> * RTTVAR<br></code></pre></td></tr></table></figure><p>其中，SRTT 是平滑的 RTT，RTTVAR 是 RTT 的变化范围，α 和 β是权重因子。</p></li></ul><p><strong>2. 重传策略</strong>:</p><ul><li>如果在 RTO 时间内未收到 ACK，TCP 会重传未确认的数据包。</li><li>每次重传，RTO 值会按照指数增长（指数退避算法）。</li></ul><p><strong>3. 拥塞控制</strong>:</p><ul><li>TCP使用复杂的拥塞控制机制，如慢启动、拥塞避免等，来调整发送窗口和传输速率。</li></ul><h3 id="tcp-的快速重传">5.2 TCP 的快速重传</h3><ul><li>当接收到三个重复的 ACK 时，TCP 会立即重传丢失的数据包，而不等待 RTO超时。</li><li>快速重传后，TCP进入快速恢复状态，调整拥塞窗口，避免拥塞窗口过度收缩。</li></ul><h3 id="比较分析">5.3 比较分析</h3><table><thead><tr class="header"><th>特性</th><th>KCP</th><th>TCP</th></tr></thead><tbody><tr class="odd"><td><strong>RTT 估算</strong></td><td>基于加权移动平均，较为简单</td><td>使用 Jacobson/Karels 算法，复杂但精确</td></tr><tr class="even"><td><strong>RTO 计算</strong></td><td>简化的计算公式</td><td>基于 RTT 的复杂计算</td></tr><tr class="odd"><td><strong>重传机制</strong></td><td>超时重传和快速重传</td><td>超时重传和快速重传</td></tr><tr class="even"><td><strong>拥塞控制</strong></td><td>简单的拥塞控制，适合低延迟应用</td><td>复杂的拥塞控制，适合广泛的传输场景</td></tr><tr class="odd"><td><strong>适用场景</strong></td><td>实时应用，如游戏、视频会议</td><td>通用应用，如文件传输、HTTP</td></tr><tr class="even"><td><strong>实现复杂度</strong></td><td>较为简单，易于理解和实现</td><td>复杂，需处理更多的网络状态和控制</td></tr><tr class="odd"><td><strong>可靠性</strong></td><td>依赖于用户自定义的重传和控制策略</td><td>内置可靠性和流控制机制</td></tr><tr class="even"><td><strong>响应速度</strong></td><td>高效快速，适用于低延迟和高吞吐量场景</td><td>可靠但响应速度较慢，适合稳定传输场景</td></tr></tbody></table><p>KCP 和 TCP 都提供了可靠的传输机制，但它们适用于不同的应用场景。KCP设计简单，适合对延迟敏感的实时应用，而 TCP拥有完善的拥塞控制和可靠性机制，适合广泛的网络应用。</p><h2 id="拥塞控制">6. 拥塞控制</h2><p>拥塞控制是网络传输协议中的一个重要机制，用于防止发送过多的数据包导致网络拥塞。在KCP中，拥塞控制相对简单，主要通过发送窗口（<code>snd_wnd</code>）和拥塞窗口（<code>cwnd</code>）来管理数据发送速率。</p><h3 id="三种策略">6.1 三种策略</h3><p>KCP 有 3 种拥塞控制的策略：</p><ul><li>慢启动（slow start）</li><li>拥塞避免（congestion avoidance）</li><li>快速恢复（fast recovery）</li></ul><p><strong>慢启动</strong>：先将 cwnd 设置为 1，随后平均每经过一个 RTT时间，<code>cwnd = cwnd * 2</code>，直到阈值 <code>ssthresh</code>。</p><p><strong>拥塞避免</strong>：cwnd 到 <code>ssthresh</code> 后，cwnd呈<strong>线性</strong>增长。</p><p>当慢启动或者拥塞避免造成 <strong>丢包</strong>后，就采取相应的退让策略：</p><ol type="1"><li><code>fastack &gt;= fastresend</code> -&gt; 发生快速重传：将<code>ssthresh = cwnd / 2</code>，<code>cwnd = ssthresh + fastresend</code>进入<strong>快恢复</strong>。</li><li><code>current &gt;= resentts</code> -&gt;超时重传：<code>ssthresh = ssthresh / 2</code>，<code>cwnd = 1</code>，进入<strong>慢启动</strong>。</li></ol><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/kcp_7.svg"alt="拥塞控制中 cwnd 和 ssthresh 的变化情况" /><figcaption aria-hidden="true">拥塞控制中 cwnd 和 ssthresh的变化情况</figcaption></figure><h3 id="核心概念">6.2 核心概念</h3><p>KCP 的拥塞控制基于以下几个核心概念：</p><ul><li><strong>发送窗口(<code>snd_wnd</code>)</strong>：表示发送端在未收到接收端确认之前，允许发送的数据包的数量。它类似于TCP 中的发送窗口，控制了数据流的速率。</li><li><strong>接收窗口(<code>rcv_wnd</code>)</strong>：表示接收端能够处理的最大数据包数量。发送端通过接收端的窗口大小来调整自己的发送速率。</li><li><strong>远端窗口(<code>rmt_wnd</code>)</strong>：表示接收端的窗口大小，发送端会根据这个值调整自己的发送窗口，以避免发送的数据超出接收端的处理能力。</li><li><strong>拥塞窗口(<code>cwnd</code>)</strong>：用于控制传输中的数据包数量。它基于网络的拥塞情况动态调整，以避免网络拥塞。</li><li><strong>慢启动阈值(<code>ssthresh</code>)</strong>：用于确定拥塞控制的模式。当<code>cwnd</code> 小于 <code>ssthresh</code> 时，KCP处于慢启动模式，否则进入拥塞避免模式。</li></ul><h3 id="窗口探测window-probing">6.3 窗口探测（Window Probing）</h3><p>在某些情况下，接收端的窗口可能会被关闭（即 <code>rmt_wnd</code> 为0），这意味着接收端无法接收任何新的数据。为了应对这种情况，KCP实现了窗口探测机制：</p><ul><li>当 <code>rmt_wnd</code> 为 0 时，KCP不会立即停止发送数据，而是会定期发送一个探测包，以检测接收端窗口是否已经打开。</li><li>这个探测包会触发接收端返回一个ACK，其中包含最新的接收窗口大小信息。</li></ul><h3 id="调节和配置">6.4 调节和配置</h3><p>KCP的拥塞控制机制提供了一些配置参数，用户可以通过调整这些参数来优化传输性能：</p><ul><li><strong><code>snd_wnd</code></strong>:发送窗口大小，用户可以根据应用的需求调整该值，以控制数据发送的最大量。</li><li><strong><code>rcv_wnd</code></strong>:接收窗口大小，表示接收端能够处理的最大数据包数量。</li><li><strong><code>ssthresh</code></strong>:慢启动阈值，初始值通常设置为较大的一个常量，用户可以根据网络情况调整。</li><li><strong><code>cwnd</code></strong>: 拥塞窗口大小，初始值通常设置为1，随传输情况动态调整。</li></ul><h2 id="比较-tcp-的拥塞控制">7. 比较 TCP 的拥塞控制</h2><h3 id="四个阶段">7.1 四个阶段</h3><p>TCP 拥塞控制有四个关键阶段</p><p><strong>慢启动（Slow Start）</strong>：</p><ul><li><strong>目的</strong>：快速探测网络的可用带宽。</li><li><strong>机制</strong>：当一个连接刚建立或者从丢包恢复时，<code>cwnd</code>（拥塞窗口）从一个较小的值（通常是1 个 MSS，即最大报文段大小）开始，并以指数增长的方式增加。</li><li><strong>过程</strong>：每次收到一个 ACK，<code>cwnd</code> 增加一个MSS，使得 <code>cwnd</code> 每 RTT 增加一倍，直到 <code>cwnd</code>达到慢启动阈值（<code>ssthresh</code>）。</li></ul><p><strong>拥塞避免（Congestion Avoidance）</strong>:</p><ul><li><strong>目的</strong>：逐步探测网络的最大容量，并避免拥塞。</li><li><strong>机制</strong>：当 <code>cwnd</code> 达到或超过<code>ssthresh</code> 时，TCP 进入拥塞避免阶段，此时 <code>cwnd</code>以线性增长的方式增加。</li><li><strong>过程</strong>：每个 RTT，<code>cwnd</code> 增加<code>1/cwnd</code> 个MSS，这种增长方式较为保守，旨在防止过度发送导致的拥塞。</li></ul><p><strong>快速重传（Fast Retransmit）</strong>:</p><ul><li><strong>目的</strong>：快速响应丢包，提高传输效率。</li><li><strong>机制</strong>：当发送端收到三个重复的 ACK时，立即重传被确认丢失的数据包，而不等待 RTO 超时。</li><li><strong>过程</strong>：快速重传的目的是迅速恢复丢失的数据包，从而减少因丢包导致的等待时间。</li></ul><p><strong>快速恢复（Fast Recovery）</strong>:</p><ul><li><strong>目的</strong>：在拥塞后快速恢复到适当的传输速率。</li><li><strong>机制</strong>：在快速重传后，TCP不会直接进入慢启动，而是保持 <code>cwnd</code>的一部分，以较快的速度恢复到拥塞避免状态。</li><li><strong>过程</strong>：将 <code>ssthresh</code> 设置为当前<code>cwnd</code> 的一半，<code>cwnd</code> 被临时减小，然后在接收新 ACK时快速增加 <code>cwnd</code>，直到恢复到 <code>ssthresh</code>为止。</li></ul><h3 id="比较分析-1">7.2 比较分析</h3><table><thead><tr class="header"><th>特性</th><th>TCP</th><th>KCP</th></tr></thead><tbody><tr class="odd"><td><strong>实现复杂度</strong></td><td>复杂，包含多个阶段和算法</td><td>简单，主要通过窗口大小控制</td></tr><tr class="even"><td><strong>拥塞检测</strong></td><td>通过 RTT 估算和 ACK 检测丢包</td><td>主要通过 ACK 和窗口大小检测丢包</td></tr><tr class="odd"><td><strong>响应速度</strong></td><td>响应相对较慢，适合稳定传输</td><td>响应较快，适合实时性高的传输</td></tr><tr class="even"><td><strong>适应性</strong></td><td>能适应广泛的网络条件</td><td>适应性较好，但更适合低延迟网络</td></tr><tr class="odd"><td><strong>配置灵活性</strong></td><td>较为固定，依赖于系统配置和优化</td><td>提供更多的配置选项，用户可根据需求调整</td></tr><tr class="even"><td><strong>应用场景</strong></td><td>适用于各种需要可靠传输的应用</td><td>适用于实时性要求高的应用，如游戏和视频会议</td></tr><tr class="odd"><td><strong>窗口调整</strong></td><td>慢启动、拥塞避免、快速重传、快速恢复等机制</td><td>主要通过发送窗口和拥塞窗口调整</td></tr><tr class="even"><td><strong>丢包响应</strong></td><td>丢包时通过减小 <code>cwnd</code> 和 <code>ssthresh</code>来调整</td><td>丢包时迅速调整 <code>cwnd</code> 和重传</td></tr><tr class="odd"><td><strong>拥塞控制策略</strong></td><td>慢启动、拥塞避免、快速重传、快速恢复等多种策略</td><td>主要通过调整 <code>cwnd</code> 和 <code>ssthresh</code>进行简单控制</td></tr><tr class="even"><td><strong>优点</strong></td><td>稳定可靠、机制全面、应用广泛</td><td>实现简单、响应快、灵活性高、适合实时应用</td></tr><tr class="odd"><td><strong>缺点</strong></td><td>复杂、响应慢、初始阶段保守</td><td>无法应对更加复杂的网络状况、应用场景有限</td></tr></tbody></table><p>TCP 和 KCP 都有各自的拥塞控制机制，适用于不同的应用场景。TCP提供了复杂而全面的拥塞控制，适合于各种网络条件下的可靠传输，而 KCP提供了简单高效的控制机制，适合于低延迟和高响应速度的实时应用。选择使用哪种协议取决于具体的应用需求和网络环境。</p><h1 id="源码分析">源码分析</h1><h2 id="核心数据结构">1. 核心数据结构</h2><h3 id="ikcpseg-报文段结构">1.1 IKCPSEG 报文段结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPSEG</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">node</span>;</span>  <span class="hljs-comment">// 链表节点</span><br>    IUINT32 conv;     <span class="hljs-comment">// 会话ID</span><br>    IUINT32 cmd;      <span class="hljs-comment">// 命令类型</span><br>    IUINT32 frg;      <span class="hljs-comment">// 分片序号</span><br>    IUINT32 wnd;      <span class="hljs-comment">// 窗口大小</span><br>    IUINT32 ts;       <span class="hljs-comment">// 时间戳</span><br>    IUINT32 sn;       <span class="hljs-comment">// 序列号</span><br>    IUINT32 una;      <span class="hljs-comment">// 待接收的下一个包序号</span><br>    IUINT32 len;      <span class="hljs-comment">// 数据长度</span><br>    IUINT32 resendts; <span class="hljs-comment">// 重传时间戳</span><br>    IUINT32 rto;      <span class="hljs-comment">// 超时重传时间</span><br>    IUINT32 fastack;  <span class="hljs-comment">// 快速重传计数器</span><br>    IUINT32 xmit;     <span class="hljs-comment">// 传输次数</span><br>    <span class="hljs-type">char</span> data[<span class="hljs-number">1</span>];     <span class="hljs-comment">// 数据</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="ikcpcb-控制块">1.2 IKCPCB 控制块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPCB</span> &#123;</span><br>    <span class="hljs-comment">// === 基础配置 ===</span><br>    IUINT32 conv;          <span class="hljs-comment">// 会话ID，用于标识一个会话</span><br>    IUINT32 mtu;          <span class="hljs-comment">// 最大传输单元，默认1400字节</span><br>    IUINT32 mss;          <span class="hljs-comment">// 最大报文段大小，默认mtu-24字节</span><br>    IUINT32 state;        <span class="hljs-comment">// 连接状态，0=正常，-1=断开</span><br>    <br>    <span class="hljs-comment">// === 发送和接收序号 ===</span><br>    IUINT32 snd_una;      <span class="hljs-comment">// 第一个未确认的包序号</span><br>    IUINT32 snd_nxt;      <span class="hljs-comment">// 下一个待发送的包序号</span><br>    IUINT32 rcv_nxt;      <span class="hljs-comment">// 待接收的下一个包序号</span><br>    <br>    <span class="hljs-comment">// === 时间戳相关 ===</span><br>    IUINT32 ts_recent;    <span class="hljs-comment">// 最近一次收到包的时间戳</span><br>    IUINT32 ts_lastack;   <span class="hljs-comment">// 最近一次收到ACK的时间戳</span><br>    IUINT32 ssthresh;     <span class="hljs-comment">// 慢启动阈值，默认为IKCP_THRESH_INIT(2)</span><br>    <br>    <span class="hljs-comment">// === RTT相关 ===</span><br>    IINT32 rx_rttval;     <span class="hljs-comment">// RTT的变化量</span><br>    IINT32 rx_srtt;       <span class="hljs-comment">// 平滑后的RTT</span><br>    IINT32 rx_rto;        <span class="hljs-comment">// 超时重传时间，初始为IKCP_RTO_DEF(200ms)</span><br>    IINT32 rx_minrto;     <span class="hljs-comment">// 最小重传超时时间，默认为IKCP_RTO_MIN(100ms)</span><br>    <br>    <span class="hljs-comment">// === 窗口相关 ===</span><br>    IUINT32 snd_wnd;      <span class="hljs-comment">// 发送窗口大小，默认32</span><br>    IUINT32 rcv_wnd;      <span class="hljs-comment">// 接收窗口大小，默认128</span><br>    IUINT32 rmt_wnd;      <span class="hljs-comment">// 远端窗口大小，默认128</span><br>    IUINT32 cwnd;         <span class="hljs-comment">// 拥塞窗口大小，初始为0</span><br>    IUINT32 probe;        <span class="hljs-comment">// 探测标志，用于窗口探测</span><br>    <br>    <span class="hljs-comment">// === 时间相关 ===</span><br>    IUINT32 current;      <span class="hljs-comment">// 当前时间</span><br>    IUINT32 interval;     <span class="hljs-comment">// 内部更新时间间隔，默认100ms</span><br>    IUINT32 ts_flush;     <span class="hljs-comment">// 下次刷新时间</span><br>    IUINT32 xmit;         <span class="hljs-comment">// 总重传次数</span><br>    <br>    <span class="hljs-comment">// === 队列计数器 ===</span><br>    IUINT32 nrcv_buf;     <span class="hljs-comment">// 接收缓存中的包数量</span><br>    IUINT32 nsnd_buf;     <span class="hljs-comment">// 发送缓存中的包数量</span><br>    IUINT32 nrcv_que;     <span class="hljs-comment">// 接收队列中的包数量</span><br>    IUINT32 nsnd_que;     <span class="hljs-comment">// 发送队列中的包数量</span><br>    <br>    <span class="hljs-comment">// === 配置标志 ===</span><br>    IUINT32 nodelay;      <span class="hljs-comment">// 是否启用nodelay模式，0=不启用</span><br>    IUINT32 updated;      <span class="hljs-comment">// 是否调用过update</span><br>    <br>    <span class="hljs-comment">// === 探测相关 ===</span><br>    IUINT32 ts_probe;     <span class="hljs-comment">// 下次探测时间</span><br>    IUINT32 probe_wait;   <span class="hljs-comment">// 探测等待时间</span><br>    <br>    <span class="hljs-comment">// === 链路控制 ===</span><br>    IUINT32 dead_link;    <span class="hljs-comment">// 最大重传次数，默认为IKCP_DEADLINK(20)</span><br>    IUINT32 incr;         <span class="hljs-comment">// 可发送的最大数据量</span><br>    <br>    <span class="hljs-comment">// === 数据队列 ===</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_queue</span>;</span>  <span class="hljs-comment">// 发送队列</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_queue</span>;</span>  <span class="hljs-comment">// 接收队列</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_buf</span>;</span>    <span class="hljs-comment">// 发送缓存</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_buf</span>;</span>    <span class="hljs-comment">// 接收缓存</span><br>    <br>    <span class="hljs-comment">// === ACK相关 ===</span><br>    IUINT32 *acklist;     <span class="hljs-comment">// ACK列表</span><br>    IUINT32 ackcount;     <span class="hljs-comment">// ACK数量</span><br>    IUINT32 ackblock;     <span class="hljs-comment">// ACK列表大小</span><br>    <br>    <span class="hljs-comment">// === 用户相关 ===</span><br>    <span class="hljs-type">void</span> *user;           <span class="hljs-comment">// 用户数据指针</span><br>    <span class="hljs-type">char</span> *buffer;         <span class="hljs-comment">// 临时缓存</span><br>    <br>    <span class="hljs-comment">// === 快速重传相关 ===</span><br>    <span class="hljs-type">int</span> fastresend;       <span class="hljs-comment">// 触发快速重传的重复ACK个数</span><br>    <span class="hljs-type">int</span> fastlimit;        <span class="hljs-comment">// 快速重传次数限制，默认IKCP_FASTACK_LIMIT(5)</span><br>    <br>    <span class="hljs-comment">// === 其他配置 ===</span><br>    <span class="hljs-type">int</span> nocwnd;          <span class="hljs-comment">// 是否关闭拥塞控制，0=不关闭</span><br>    <span class="hljs-type">int</span> stream;          <span class="hljs-comment">// 是否为流模式，0=消息模式(默认)，1=流模式</span><br>    <span class="hljs-type">int</span> logmask;        <span class="hljs-comment">// 日志掩码，控制日志输出级别</span><br>    <br>    <span class="hljs-comment">// === 回调函数 ===</span><br>    <span class="hljs-comment">// 数据输出回调，用于发送数据</span><br>    <span class="hljs-type">int</span> (*output)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> len, <span class="hljs-keyword">struct</span> IKCPCB *kcp, <span class="hljs-type">void</span> *user);<br>    <span class="hljs-comment">// 日志输出回调</span><br>    <span class="hljs-type">void</span> (*writelog)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-built_in">log</span>, <span class="hljs-keyword">struct</span> IKCPCB *kcp, <span class="hljs-type">void</span> *user);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个结构体可以大致分为几个主要部分：</p><ul><li>基础配置：包含基本的会话标识和传输单元大小设置</li><li>序号追踪：用于追踪发送和接收的包序号</li><li>时间管理：包含各种时间戳和定时器</li><li>窗口控制：实现流量控制和拥塞控制</li><li>队列管理：管理数据的发送和接收</li><li>ACK处理：处理确认包</li><li>配置选项：各种功能开关和参数设置</li><li>回调函数：用于数据输出和日志记录</li></ul><h2 id="核心函数">2. 核心函数</h2><p>在进入具体的核心函数分析之前，需要先点明 2 点，<code>kcp</code>的实现者期望其尽可能地简单和减少依赖，所以数据的输出甚至是当前时间都是由使用者来设置的，即<code>kcp</code> 本身是不依赖于机器时钟的。具体体现在下面 2 个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//---------------------------------------------------------------------</span><br><span class="hljs-comment">// set output callback, which will be invoked by kcp</span><br><span class="hljs-comment">//---------------------------------------------------------------------</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_setoutput</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">int</span> (*output)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> len,</span><br><span class="hljs-params">ikcpcb *kcp, <span class="hljs-type">void</span> *user))</span><br>&#123;<br>kcp-&gt;output = output;<br>&#125;<br><br><span class="hljs-comment">//---------------------------------------------------------------------</span><br><span class="hljs-comment">// update state (call it repeatedly, every 10ms-100ms), or you can ask </span><br><span class="hljs-comment">// ikcp_check when to call it again (without ikcp_input/_send calling).</span><br><span class="hljs-comment">// &#x27;current&#x27; - current timestamp in millisec. </span><br><span class="hljs-comment">//---------------------------------------------------------------------</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_update</span><span class="hljs-params">(ikcpcb *kcp, IUINT32 current)</span><br>&#123;<br>  ...  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ikcp_send-发送数据">2.1 ikcp_send 发送数据</h3><p><code>ikcp_send</code>是应用层接口，负责将用户数据分片并加入到发送队列（<code>snd_queue</code>）。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241129154115523.png"alt="ikcp_send" /><figcaption aria-hidden="true">ikcp_send</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//---------------------------------------------------------------------</span><br><span class="hljs-comment">// user/upper level send, returns below zero for error</span><br><span class="hljs-comment">//---------------------------------------------------------------------</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_send</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> len)</span><br>&#123;<br>IKCPSEG *seg;<br><span class="hljs-type">int</span> count, i;<br><span class="hljs-type">int</span> sent = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// mtu: 最大传输单元</span><br><span class="hljs-comment">// mss: 最大报文段大小</span><br><span class="hljs-comment">// mss = mtu - 包头长度(24)</span><br>assert(kcp-&gt;mss &gt; <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// append to previous segment in streaming mode (if possible)</span><br><span class="hljs-comment">// 如果是流模式，则将数据追加到前一个分段中（如果可能）</span><br><span class="hljs-keyword">if</span> (kcp-&gt;stream != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 如果当前发送队列不为空，且前一个分段未满，则将数据追加到前一个分段中</span><br><span class="hljs-keyword">if</span> (!iqueue_is_empty(&amp;kcp-&gt;snd_queue)) &#123;<br>IKCPSEG *old = iqueue_entry(kcp-&gt;snd_queue.prev, IKCPSEG, node);<br><span class="hljs-keyword">if</span> (old-&gt;len &lt; kcp-&gt;mss) &#123;<br><span class="hljs-type">int</span> capacity = kcp-&gt;mss - old-&gt;len;<br><span class="hljs-type">int</span> extend = (len &lt; capacity)? len : capacity;<br>seg = ikcp_segment_new(kcp, old-&gt;len + extend);<br>assert(seg);<br><span class="hljs-keyword">if</span> (seg == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>&#125;<br><span class="hljs-comment">// 将新的 seg-&gt;node 放入 snd_queue 中等待发送</span><br>iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;snd_queue);<br><span class="hljs-comment">// 把上一个报文的数据拷贝过来</span><br><span class="hljs-built_in">memcpy</span>(seg-&gt;data, old-&gt;data, old-&gt;len);<br><span class="hljs-keyword">if</span> (buffer) &#123;<br><span class="hljs-built_in">memcpy</span>(seg-&gt;data + old-&gt;len, buffer, extend);<br>buffer += extend;<br>&#125;<br>seg-&gt;len = old-&gt;len + extend;<br>seg-&gt;frg = <span class="hljs-number">0</span>;<br>len -= extend;<br>iqueue_del_init(&amp;old-&gt;node);<br><span class="hljs-comment">// 释放之前老数据的 kcp node</span><br>ikcp_segment_delete(kcp, old);<br>sent = extend;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> sent;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 1. 非流模式，不追加到上一个报文后面</span><br><span class="hljs-comment">// 2. 流模式，但是上一个报文已满，则创建新的报文</span><br><br><span class="hljs-comment">// 计算需要的报文数量，kcp 会对数据进行分段传输</span><br><span class="hljs-keyword">if</span> (len &lt;= (<span class="hljs-type">int</span>)kcp-&gt;mss) count = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> count = (len + kcp-&gt;mss - <span class="hljs-number">1</span>) / kcp-&gt;mss;<br><br><span class="hljs-comment">// 接收窗口位置不够，则暂停发送</span><br><span class="hljs-keyword">if</span> (count &gt;= (<span class="hljs-type">int</span>)IKCP_WND_RCV) &#123;<br><span class="hljs-keyword">if</span> (kcp-&gt;stream != <span class="hljs-number">0</span> &amp;&amp; sent &gt; <span class="hljs-number">0</span>) <br><span class="hljs-keyword">return</span> sent;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) count = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 发送所有的报文段</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br><span class="hljs-type">int</span> size = len &gt; (<span class="hljs-type">int</span>)kcp-&gt;mss ? (<span class="hljs-type">int</span>)kcp-&gt;mss : len;<br>seg = ikcp_segment_new(kcp, size);<br>assert(seg);<br><span class="hljs-keyword">if</span> (seg == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (buffer &amp;&amp; len &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">memcpy</span>(seg-&gt;data, buffer, size);<br>&#125;<br>seg-&gt;len = size;<br>seg-&gt;frg = (kcp-&gt;stream == <span class="hljs-number">0</span>)? (count - i - <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;<br>iqueue_init(&amp;seg-&gt;node);<br><br><span class="hljs-comment">// 将报文段放入 snd_queue 中</span><br>iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;snd_queue);<br>kcp-&gt;nsnd_que++;<br><span class="hljs-keyword">if</span> (buffer) &#123;<br>buffer += size;<br>&#125;<br>len -= size;<br>sent += size;<br>&#125;<br><br><span class="hljs-keyword">return</span> sent;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ikcp_input-接收数据">2.2 ikcp_input 接收数据</h3><p><code>ikcp_input</code> 负责处理从网络接收到的原始 KCP数据包，它会处理协议层面的数据，包括ACK、窗口控制等协议信息，并将接收到的数据放入 KCP的内部接收缓冲区（<code>rcv_buf</code> 和 <code>rcv_queue</code>）。</p><h3 id="ikcp_recv-获取数据">2.3 ikcp_recv 获取数据</h3><p><code>ikcp_recv</code>是应用层函数，供上层应用调用以获取完整的消息数据，它从 KCP的接收队列(rcv_queue)中读取已经排序好的数据，处理分片重组，确保返回完整的消息。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241129163431276.png"alt="ikcp_recv" /><figcaption aria-hidden="true">ikcp_recv</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//---------------------------------------------------------------------</span><br><span class="hljs-comment">// user/upper level recv: returns size, returns below zero for EAGAIN</span><br><span class="hljs-comment">// 从 rcv_queue 中获取数据</span><br><span class="hljs-comment">//---------------------------------------------------------------------</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_recv</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> len)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> *<span class="hljs-title">p</span>;</span><br><span class="hljs-type">int</span> ispeek = (len &lt; <span class="hljs-number">0</span>)? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> peeksize;<br><span class="hljs-type">int</span> recover = <span class="hljs-number">0</span>;<br>IKCPSEG *seg;<br>assert(kcp);<br><br><span class="hljs-comment">// 如果 rcv_queue 为空，则直接返回</span><br><span class="hljs-keyword">if</span> (iqueue_is_empty(&amp;kcp-&gt;rcv_queue))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 如果 len &lt; 0，则说明是 peek 操作，准备只查看数据</span><br><span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) len = -len;<br><br><span class="hljs-comment">// 计算 rcv_queue 中数据的大小</span><br>peeksize = ikcp_peeksize(kcp);<br><br><span class="hljs-comment">// 无法获得大小，返回 -2</span><br><span class="hljs-keyword">if</span> (peeksize &lt; <span class="hljs-number">0</span>) <br><span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br><br><span class="hljs-comment">// 数据过大，返回 -3</span><br><span class="hljs-keyword">if</span> (peeksize &gt; len) <br><span class="hljs-keyword">return</span> <span class="hljs-number">-3</span>;<br><br><span class="hljs-comment">// nrcv_que: rcv_queue 的长度</span><br><span class="hljs-comment">// rcv_wnd: 接收窗口的大小</span><br><span class="hljs-comment">// 如果 nrcv_que &gt;= rcv_wnd，则需要进行快恢复</span><br><span class="hljs-comment">// 因为 nrcv_que &gt;= rcv_wnd，说明接收窗口已经满了，</span><br><span class="hljs-comment">// 这个时候需要发送 IKCP_CMD_WINS 告诉发送方窗口大小，</span><br><span class="hljs-comment">// 这个时候发送方需要进行快恢复，减小数据传输，以尽快释放接收窗口</span><br><span class="hljs-keyword">if</span> (kcp-&gt;nrcv_que &gt;= kcp-&gt;rcv_wnd)<br>recover = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// merge fragment</span><br><span class="hljs-comment">// 将多个片段合并成一个完整的片段</span><br><span class="hljs-comment">// 合并后，将合并后的片段从 rcv_queue 中删除</span><br><span class="hljs-keyword">for</span> (len = <span class="hljs-number">0</span>, p = kcp-&gt;rcv_queue.next; p != &amp;kcp-&gt;rcv_queue; ) &#123;<br><span class="hljs-type">int</span> fragment;<br>seg = iqueue_entry(p, IKCPSEG, node);<br>p = p-&gt;next;<br><br><span class="hljs-keyword">if</span> (buffer) &#123;<br><span class="hljs-built_in">memcpy</span>(buffer, seg-&gt;data, seg-&gt;len);<br>buffer += seg-&gt;len;<br>&#125;<br><br>len += seg-&gt;len;<br>fragment = seg-&gt;frg;<br><br><span class="hljs-keyword">if</span> (ikcp_canlog(kcp, IKCP_LOG_RECV)) &#123;<br>ikcp_log(kcp, IKCP_LOG_RECV, <span class="hljs-string">&quot;recv sn=%lu&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)seg-&gt;sn);<br>&#125;<br><br><span class="hljs-keyword">if</span> (ispeek == <span class="hljs-number">0</span>) &#123;<br>iqueue_del(&amp;seg-&gt;node);<br>ikcp_segment_delete(kcp, seg);<br>kcp-&gt;nrcv_que--;<br>&#125;<br><br><span class="hljs-keyword">if</span> (fragment == <span class="hljs-number">0</span>) <br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>assert(len == peeksize);<br><br><span class="hljs-comment">// move available data from rcv_buf -&gt; rcv_queue</span><br><span class="hljs-comment">// 尝试将 rcv_buf 中编号连续的数据，移动到 rcv_queue 中</span><br><span class="hljs-comment">// 移动后，将移动的数据从 rcv_buf 中删除</span><br><span class="hljs-keyword">while</span> (! iqueue_is_empty(&amp;kcp-&gt;rcv_buf)) &#123;<br>seg = iqueue_entry(kcp-&gt;rcv_buf.next, IKCPSEG, node);<br><span class="hljs-keyword">if</span> (seg-&gt;sn == kcp-&gt;rcv_nxt &amp;&amp; kcp-&gt;nrcv_que &lt; kcp-&gt;rcv_wnd) &#123;<br>iqueue_del(&amp;seg-&gt;node);<br>kcp-&gt;nrcv_buf--;<br>iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;rcv_queue);<br>kcp-&gt;nrcv_que++;<br>kcp-&gt;rcv_nxt++;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 快恢复</span><br><span class="hljs-keyword">if</span> (kcp-&gt;nrcv_que &lt; kcp-&gt;rcv_wnd &amp;&amp; recover) &#123;<br><span class="hljs-comment">// 在ikcp_flush 中返回 IKCP_CMD_WINS </span><br><span class="hljs-comment">// 通知本段窗口大小给对端</span><br>kcp-&gt;probe |= IKCP_ASK_TELL;<br>&#125;<br><br><span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ikcp_update-定时时钟">2.4 ikcp_update 定时时钟</h3><p>前面我们看了 <code>ikcp_send</code> 、<code>ikcp_input</code> 和<code>ikcp_recv</code>三个核心流程的函数，其中的一些细节，你可以回到本文前面的「原理分析」再对照源码仔细阅读。</p><p>在前面的原理分析中，我们提到，为了提高传输和处理数据的效率，<code>kcp</code>设计了队列和缓冲区，同时为了实现可靠性，<code>kcp</code> 也提供了<code>ACK</code>和重试、拥塞控制等机制，这些事情都是周期定时去处理的。这里是由<code>ikcp_update</code> 函数去处理的。</p><p><code>ikcp_update</code> 是 KCP 的定时器函数，负责以固定间隔调用<code>ikcp_flush</code> 处理数据发送和协议更新，是 KCP的"心跳"机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//---------------------------------------------------------------------</span><br><span class="hljs-comment">// update state (call it repeatedly, every 10ms-100ms), or you can ask </span><br><span class="hljs-comment">// ikcp_check when to call it again (without ikcp_input/_send calling).</span><br><span class="hljs-comment">// &#x27;current&#x27; - current timestamp in millisec. </span><br><span class="hljs-comment">//---------------------------------------------------------------------</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_update</span><span class="hljs-params">(ikcpcb *kcp, IUINT32 current)</span><br>&#123;<br>IINT32 slap;<br><br>kcp-&gt;current = current;<br><br><span class="hljs-keyword">if</span> (kcp-&gt;updated == <span class="hljs-number">0</span>) &#123;<br>kcp-&gt;updated = <span class="hljs-number">1</span>;<br>kcp-&gt;ts_flush = kcp-&gt;current;<br>&#125;<br><br><span class="hljs-comment">// 计算间隔</span><br>slap = _itimediff(kcp-&gt;current, kcp-&gt;ts_flush);<br><br><span class="hljs-keyword">if</span> (slap &gt;= <span class="hljs-number">10000</span> || slap &lt; <span class="hljs-number">-10000</span>) &#123;<br>kcp-&gt;ts_flush = kcp-&gt;current;<br>slap = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 达到调用间隔，则执行 ikcp_flush 进行接收数据或发送数据</span><br><span class="hljs-keyword">if</span> (slap &gt;= <span class="hljs-number">0</span>) &#123;<br>kcp-&gt;ts_flush += kcp-&gt;interval;<br><span class="hljs-keyword">if</span> (_itimediff(kcp-&gt;current, kcp-&gt;ts_flush) &gt;= <span class="hljs-number">0</span>) &#123;<br>kcp-&gt;ts_flush = kcp-&gt;current + kcp-&gt;interval;<br>&#125;<br>ikcp_flush(kcp);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数很简单，根据注释所说，通常情况下会每 <code>10ms~100ms</code>执行一次，然后核心是去调用 <code>ikcp_flush</code>函数，所有的逻辑都在里面。</p><h3 id="ikcp_flush-定时处理">2.5 ikcp_flush 定时处理</h3><p>如上所述，<code>ikcp_flush</code> 是 KCP的核心发送函数，负责将发送队列 <code>snd_queue</code>中的数据移入发送缓存 <code>snd_buf</code> 并通过 <code>output</code>回调发送出去，同时处理 ACK发送、快速重传、超时重传和窗口探测等协议细节。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241129170905325.png"alt="ikcp_flush" /><figcaption aria-hidden="true">ikcp_flush</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_flush</span><span class="hljs-params">(ikcpcb *kcp)</span><br>&#123;<br>IUINT32 current = kcp-&gt;current;<span class="hljs-comment">// 当前时间</span><br><span class="hljs-type">char</span> *buffer = kcp-&gt;buffer;<span class="hljs-comment">// 临时缓冲区</span><br><span class="hljs-type">char</span> *ptr = buffer;<br><span class="hljs-type">int</span> count, size, i;<br>IUINT32 resent, cwnd;<br>IUINT32 rtomin;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> *<span class="hljs-title">p</span>;</span><br><span class="hljs-type">int</span> change = <span class="hljs-number">0</span>;<span class="hljs-comment">// 是否执行过快速重传</span><br><span class="hljs-type">int</span> lost = <span class="hljs-number">0</span>;<span class="hljs-comment">// 是否执行过超时重传</span><br>IKCPSEG seg;<br><br><span class="hljs-comment">// 检查是否已调用 ikcp_update</span><br><span class="hljs-keyword">if</span> (kcp-&gt;updated == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">// 初始化一个段用于构建各种控制包</span><br>seg.conv = kcp-&gt;conv;  <span class="hljs-comment">// 连接标识</span><br>seg.cmd = IKCP_CMD_ACK;<span class="hljs-comment">// 报文类型：IKCP_CMD_ACK 表示确认报文</span><br>seg.frg = <span class="hljs-number">0</span>;<span class="hljs-comment">// 分片数量，表示随后还有多少个报文属于同一个包</span><br>seg.wnd = ikcp_wnd_unused(kcp);<span class="hljs-comment">// 发送方剩余接收窗口的大小</span><br>seg.una = kcp-&gt;rcv_nxt;<span class="hljs-comment">// 发送方的接收缓冲区中最小还未收到的报文段的编号，也就是说，编号比它小的报文段都已全部接收</span><br>seg.len = <span class="hljs-number">0</span>;<span class="hljs-comment">// 数据段长度</span><br>seg.sn = <span class="hljs-number">0</span>;<span class="hljs-comment">// 报文编号</span><br>seg.ts = <span class="hljs-number">0</span>;<span class="hljs-comment">// 时间戳</span><br><br><span class="hljs-comment">// flush acknowledges</span><br><span class="hljs-comment">// ① 发送 ACK 队列中的所有 ACK</span><br>count = kcp-&gt;ackcount;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>size = (<span class="hljs-type">int</span>)(ptr - buffer);<br><span class="hljs-comment">// buffer 中累计的数据将要超过 mtu 的时候</span><br><span class="hljs-comment">// 就调用 ikcp_output 将数据发送出去</span><br><span class="hljs-keyword">if</span> (size + (<span class="hljs-type">int</span>)IKCP_OVERHEAD &gt; (<span class="hljs-type">int</span>)kcp-&gt;mtu) &#123;<br>ikcp_output(kcp, buffer, size);<br>ptr = buffer;<br>&#125;<br><span class="hljs-comment">// 从 ACK 列表中取出 sn(报文编号)和 ts(时间戳)</span><br>ikcp_ack_get(kcp, i, &amp;seg.sn, &amp;seg.ts);<br><span class="hljs-comment">// 将 ACK 报文写入 buffer</span><br>ptr = ikcp_encode_seg(ptr, &amp;seg);<br>&#125;<br><span class="hljs-comment">// ② ACK 队列已清空</span><br>kcp-&gt;ackcount = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// probe window size (if remote window size equals zero)</span><br><span class="hljs-comment">// 对端剩余接收窗口大小为 0，则意味着可能需要发送窗口探测报文：IKCP_CMD_WASK</span><br><span class="hljs-keyword">if</span> (kcp-&gt;rmt_wnd == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 根据 ts_probe 和 probe_wait 确定当前时刻是否需要发送探测报文</span><br><span class="hljs-comment">// probe_wait: 等待发送探测报文的时间，IKCP_PROBE_INIT=7s, IKCP_PROBE_LIMIT=</span><br><span class="hljs-keyword">if</span> (kcp-&gt;probe_wait == <span class="hljs-number">0</span>) &#123;<br>kcp-&gt;probe_wait = IKCP_PROBE_INIT; <span class="hljs-comment">// 7s 后去发探测报文</span><br>kcp-&gt;ts_probe = kcp-&gt;current + kcp-&gt;probe_wait;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (_itimediff(kcp-&gt;current, kcp-&gt;ts_probe) &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (kcp-&gt;probe_wait &lt; IKCP_PROBE_INIT) <br>kcp-&gt;probe_wait = IKCP_PROBE_INIT;<br>kcp-&gt;probe_wait += kcp-&gt;probe_wait / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (kcp-&gt;probe_wait &gt; IKCP_PROBE_LIMIT)<br>kcp-&gt;probe_wait = IKCP_PROBE_LIMIT;<br>kcp-&gt;ts_probe = kcp-&gt;current + kcp-&gt;probe_wait;<br>kcp-&gt;probe |= IKCP_ASK_SEND; <span class="hljs-comment">// 设置是否需要去发送 IKCP_ASK_SEND</span><br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>kcp-&gt;ts_probe = <span class="hljs-number">0</span>;<br>kcp-&gt;probe_wait = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// flush window probing commands</span><br><span class="hljs-comment">// ③ 如果需要，则发送窗口探测报文：IKCP_CMD_WASK</span><br><span class="hljs-keyword">if</span> (kcp-&gt;probe &amp; IKCP_ASK_SEND) &#123;<br>seg.cmd = IKCP_CMD_WASK;<br>size = (<span class="hljs-type">int</span>)(ptr - buffer);<br><span class="hljs-keyword">if</span> (size + (<span class="hljs-type">int</span>)IKCP_OVERHEAD &gt; (<span class="hljs-type">int</span>)kcp-&gt;mtu) &#123;<br>ikcp_output(kcp, buffer, size);<br>ptr = buffer;<br>&#125;<br>ptr = ikcp_encode_seg(ptr, &amp;seg);<br>&#125;<br><br><span class="hljs-comment">// flush window probing commands</span><br><span class="hljs-comment">// ④ 如果需要，则发送窗口通知报文：IKCP_CMD_WINS</span><br><span class="hljs-keyword">if</span> (kcp-&gt;probe &amp; IKCP_ASK_TELL) &#123;<br>seg.cmd = IKCP_CMD_WINS;<br>size = (<span class="hljs-type">int</span>)(ptr - buffer);<br><span class="hljs-keyword">if</span> (size + (<span class="hljs-type">int</span>)IKCP_OVERHEAD &gt; (<span class="hljs-type">int</span>)kcp-&gt;mtu) &#123;<br>ikcp_output(kcp, buffer, size);<br>ptr = buffer;<br>&#125;<br>ptr = ikcp_encode_seg(ptr, &amp;seg);<br>&#125;<br><br>kcp-&gt;probe = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// calculate window size</span><br><span class="hljs-comment">// ⑤ 计算当前窗口大小</span><br>cwnd = _imin_(kcp-&gt;snd_wnd, kcp-&gt;rmt_wnd);<br><span class="hljs-keyword">if</span> (kcp-&gt;nocwnd == <span class="hljs-number">0</span>) cwnd = _imin_(kcp-&gt;cwnd, cwnd);<br><br><span class="hljs-comment">// move data from snd_queue to snd_buf</span><br><span class="hljs-comment">// 5.1 如果符合发送的条件，则创建新的 newseg 并放入 snd_buf 的尾部</span><br><span class="hljs-keyword">while</span> (_itimediff(kcp-&gt;snd_nxt, kcp-&gt;snd_una + cwnd) &lt; <span class="hljs-number">0</span>) &#123;<br>IKCPSEG *newseg;<br><span class="hljs-keyword">if</span> (iqueue_is_empty(&amp;kcp-&gt;snd_queue)) <span class="hljs-keyword">break</span>;<br><br>newseg = iqueue_entry(kcp-&gt;snd_queue.next, IKCPSEG, node);<br><br>iqueue_del(&amp;newseg-&gt;node);<br>iqueue_add_tail(&amp;newseg-&gt;node, &amp;kcp-&gt;snd_buf);<br>kcp-&gt;nsnd_que--;<br>kcp-&gt;nsnd_buf++;<br><br>newseg-&gt;conv = kcp-&gt;conv;<br>newseg-&gt;cmd = IKCP_CMD_PUSH;<br>newseg-&gt;wnd = seg.wnd;<br>newseg-&gt;ts = current;<br>newseg-&gt;sn = kcp-&gt;snd_nxt++;<br>newseg-&gt;una = kcp-&gt;rcv_nxt;<br>newseg-&gt;resendts = current;<br>newseg-&gt;rto = kcp-&gt;rx_rto;<br>newseg-&gt;fastack = <span class="hljs-number">0</span>;<br>newseg-&gt;xmit = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// calculate resent</span><br><span class="hljs-comment">// 失序多少次就快速重传。如果 fastresend 大于 0，则取其值；否则，设为最大值 0xffffffff。</span><br>resent = (kcp-&gt;fastresend &gt; <span class="hljs-number">0</span>)? (IUINT32)kcp-&gt;fastresend : <span class="hljs-number">0xffffffff</span>;  <br><span class="hljs-comment">// 最小超时重传时间。如果 nodelay 为 0，则为 rx_rto 的八分之一，否则为 0。</span><br>rtomin = (kcp-&gt;nodelay == <span class="hljs-number">0</span>)? (kcp-&gt;rx_rto &gt;&gt; <span class="hljs-number">3</span>) : <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// flush data segments</span><br><span class="hljs-keyword">for</span> (p = kcp-&gt;snd_buf.next; p != &amp;kcp-&gt;snd_buf; p = p-&gt;next) &#123;<br><span class="hljs-comment">// 从 snd_buf 取出一个报文</span><br>IKCPSEG *segment = iqueue_entry(p, IKCPSEG, node);<br><span class="hljs-type">int</span> needsend = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 条件1：第一次发送的报文，直接发送</span><br><span class="hljs-keyword">if</span> (segment-&gt;xmit == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//  该报文的 xmit 传输次数</span><br>needsend = <span class="hljs-number">1</span>;<br>segment-&gt;xmit++;<br>segment-&gt;rto = kcp-&gt;rx_rto;<br>segment-&gt;resendts = current + segment-&gt;rto + rtomin;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_itimediff(current, segment-&gt;resendts) &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 条件2：且重传时间到了，则重传</span><br>needsend = <span class="hljs-number">1</span>;<br>segment-&gt;xmit++;<br>kcp-&gt;xmit++;<br><span class="hljs-keyword">if</span> (kcp-&gt;nodelay == <span class="hljs-number">0</span>) &#123;<br>segment-&gt;rto += _imax_(segment-&gt;rto, (IUINT32)kcp-&gt;rx_rto);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>IINT32 step = (kcp-&gt;nodelay &lt; <span class="hljs-number">2</span>)? <br>((IINT32)(segment-&gt;rto)) : kcp-&gt;rx_rto;<br>segment-&gt;rto += step / <span class="hljs-number">2</span>;<br>&#125;<br>segment-&gt;resendts = current + segment-&gt;rto;<br>lost = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (segment-&gt;fastack &gt;= resent) &#123;<br><span class="hljs-comment">// 条件3：达到快速重传次数，则重传</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>)segment-&gt;xmit &lt;= kcp-&gt;fastlimit || <br>kcp-&gt;fastlimit &lt;= <span class="hljs-number">0</span>) &#123;<br>needsend = <span class="hljs-number">1</span>;<br>segment-&gt;xmit++;<br>segment-&gt;fastack = <span class="hljs-number">0</span>;<br>segment-&gt;resendts = current + segment-&gt;rto;<br>change++;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (needsend) &#123;<br><span class="hljs-type">int</span> need;<br>segment-&gt;ts = current;<br>segment-&gt;wnd = seg.wnd;<br>segment-&gt;una = kcp-&gt;rcv_nxt;<br><br>size = (<span class="hljs-type">int</span>)(ptr - buffer);<br>need = IKCP_OVERHEAD + segment-&gt;len;<br><br><span class="hljs-keyword">if</span> (size + need &gt; (<span class="hljs-type">int</span>)kcp-&gt;mtu) &#123;<br>ikcp_output(kcp, buffer, size);<br>ptr = buffer;<br>&#125;<br><br>ptr = ikcp_encode_seg(ptr, segment);<br><br><span class="hljs-keyword">if</span> (segment-&gt;len &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">memcpy</span>(ptr, segment-&gt;data, segment-&gt;len);<br>ptr += segment-&gt;len;<br>&#125;<br><br><span class="hljs-comment">// 如果某个数据包的重传次数超过阈值，则标记连接断开。</span><br><span class="hljs-keyword">if</span> (segment-&gt;xmit &gt;= kcp-&gt;dead_link) &#123;<br>kcp-&gt;state = (IUINT32)<span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// flash remain segments</span><br>size = (<span class="hljs-type">int</span>)(ptr - buffer);<br><span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>ikcp_output(kcp, buffer, size);<br>&#125;<br><br><span class="hljs-comment">// update ssthresh</span><br><span class="hljs-comment">// 1. 如果发生了快速重传，让 ssthresh 减半，进入快恢复</span><br><span class="hljs-keyword">if</span> (change) &#123;<br>IUINT32 inflight = kcp-&gt;snd_nxt - kcp-&gt;snd_una;<br>kcp-&gt;ssthresh = inflight / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (kcp-&gt;ssthresh &lt; IKCP_THRESH_MIN)<br>kcp-&gt;ssthresh = IKCP_THRESH_MIN;<br>kcp-&gt;cwnd = kcp-&gt;ssthresh + resent;<br>kcp-&gt;incr = kcp-&gt;cwnd * kcp-&gt;mss;<br>&#125;<br><br><span class="hljs-comment">// 2. 如果发生了超时重传，则让 ssthresh 减半，然后 cwnd = 1，进入慢启动</span><br><span class="hljs-keyword">if</span> (lost) &#123;<br>kcp-&gt;ssthresh = cwnd / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (kcp-&gt;ssthresh &lt; IKCP_THRESH_MIN)<br>kcp-&gt;ssthresh = IKCP_THRESH_MIN;<br>kcp-&gt;cwnd = <span class="hljs-number">1</span>;<br>kcp-&gt;incr = kcp-&gt;mss;<br>&#125;<br><br><span class="hljs-comment">// 兜底，cwnd 至少为 1</span><br><span class="hljs-keyword">if</span> (kcp-&gt;cwnd &lt; <span class="hljs-number">1</span>) &#123;<br>kcp-&gt;cwnd = <span class="hljs-number">1</span>;<br>kcp-&gt;incr = kcp-&gt;mss;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://github.com/skywind3000/kcp">KCP repo</a></li><li><a href="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP协议的原理和实现</a></li></ul>]]></content>
    
    
    <summary type="html">本文将详细介绍游戏开发中场景的网络协议 KCP 的底层原理，并提供源码分析。文中包含大量的图示和原理总结，以帮助读者更好地理解 KCP 协议的工作原理。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="KCP" scheme="https://hedon.top/tags/KCP/"/>
    
    <category term="TCP" scheme="https://hedon.top/tags/TCP/"/>
    
    <category term="网络" scheme="https://hedon.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨SSE(Server-Sent Events)</title>
    <link href="https://hedon.top/2024/06/06/rust-action-sse/"/>
    <id>https://hedon.top/2024/06/06/rust-action-sse/</id>
    <published>2024-06-06T13:30:51.000Z</published>
    <updated>2024-06-11T06:17:34.968Z</updated>
    
    <content type="html"><![CDATA[<p>📌 SSE（Server-SentEvents）是一种允许服务器向客户端浏览器推送信息的技术。它是 HTML5的一部分，专门用于建立一个单向的从服务器到客户端的通信连接。SSE的使用场景非常广泛，包括实时消息推送、实时通知更新等。</p><h1 id="sse-的本质">SSE 的本质</h1><p>严格地说，<ahref="https://en.wikipedia.org/wiki/HTTP">HTTP</a>无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息（streaming）。</p><p>也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。本质上，这种通信就是以流信息的方式，完成一次用时很长的下载。</p><p>SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 HTTP协议，目前除了 IE/Edge，其他浏览器都支持。</p><h1 id="特点">特点</h1><ol type="1"><li><strong>持续连接</strong>：与传统的 HTTP 请求不同，SSE保持连接开放，服务器可以随时发送消息。</li><li><strong>文本数据流</strong>：SSE主要传输文本数据，这些数据以特定的格式流式传输，使得每条消息都是简单的文本格式。</li><li><strong>内置重连机制</strong>：浏览器会自动处理连接中断和重连，包括在重连请求中发送最后接收的事件ID，以便服务器从正确的位置恢复发送事件。</li><li><strong>简单的客户端处理</strong>：在浏览器中，使用 JavaScript 的<code>EventSource</code> 接口处理 SSE非常简单，只需几行代码即可监听服务器发来的事件。</li></ol><h1 id="工作原理">工作原理</h1><ol type="1"><li><strong>建立连接</strong>：客户端通过创建一个<code>EventSource</code> 对象请求特定的 URL 来启动 SSE连接。这个请求是一个标准的 HTTP请求，但会要求服务器以特定方式响应。</li><li><strong>服务器响应</strong>：服务器响应必须设置<code>Content-Type</code> 为<code>text/event-stream</code>，然后保持连接打开。</li><li><strong>发送消息</strong>：服务器可以通过持续发送数据格式为特定事件流的消息来推送更新。每个消息包括一个可选的事件类型、数据和一个可选的ID。<ul><li><strong>数据</strong>：实际的消息内容，以 <code>data:</code>开头，多行数据以双换行符 <code>\n\n</code> 结束。</li><li><strong>事件类型</strong>：允许客户端根据事件类型来监听，以<code>event:</code> 开头。</li><li><strong>ID</strong>：如果连接中断，客户端将发送包含上次接收的最后一个ID的<code>Last-Event-ID</code> 头，以便服务器从断点继续发送数据。</li></ul></li></ol><h1 id="实战">实战</h1><h2 id="客户端">客户端</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>SSE Test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Server-Sent Events Test<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;events&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 确保这里的URL匹配你的服务器地址和端口</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&#x27;http://localhost:8000/events&#x27;</span>);</span><br><span class="language-javascript">    eventSource.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;New event:&#x27;</span>, event.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;events&#x27;</span>).<span class="hljs-property">innerHTML</span> += event.<span class="hljs-property">data</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="rust-服务端">Rust 服务端</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/20240606213652.gif"alt="Rust 实现演示" /><figcaption aria-hidden="true">Rust 实现演示</figcaption></figure><p>依赖：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-attr">anyhow</span> = <span class="hljs-string">&quot;1.0.86&quot;</span><br><span class="hljs-attr">axum</span> = &#123; version = <span class="hljs-string">&quot;0.7.5&quot;</span> &#125;<br><span class="hljs-attr">chrono</span> = <span class="hljs-string">&quot;0.4.38&quot;</span><br><span class="hljs-attr">futures-core</span> = <span class="hljs-string">&quot;0.3.30&quot;</span><br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1.38.0&quot;</span>, features = [<span class="hljs-string">&quot;macros&quot;</span>, <span class="hljs-string">&quot;rt-multi-thread&quot;</span>, ] &#125;<br><span class="hljs-attr">tokio-stream</span> = <span class="hljs-string">&quot;0.1.15&quot;</span><br><span class="hljs-attr">tower-http</span> = &#123; version = <span class="hljs-string">&quot;0.5.2&quot;</span>, features = [<span class="hljs-string">&quot;cors&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">use</span> axum::&#123;<br>    response::&#123;sse::Event, Sse&#125;,<br>    routing::get,<br>    Router,<br>&#125;;<br><span class="hljs-keyword">use</span> tokio::&#123;net::TcpListener, time::interval&#125;;<br><span class="hljs-keyword">use</span> tokio_stream::&#123;wrappers::IntervalStream, StreamExt&#125;;<br><span class="hljs-keyword">use</span> tower_http::cors::&#123;Any, CorsLayer&#125;;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cors</span> = CorsLayer::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">allow_headers</span>(Any)<br>        .<span class="hljs-title function_ invoke__">allow_origin</span>(Any)<br>        .<span class="hljs-title function_ invoke__">allow_headers</span>(Any)<br>        .<span class="hljs-title function_ invoke__">allow_credentials</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;0.0.0.0:8000&quot;</span>).<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Router::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/events&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(sse_handler)).<span class="hljs-title function_ invoke__">layer</span>(cors);<br>    axum::<span class="hljs-title function_ invoke__">serve</span>(listener, app).<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sse_handler</span>() <span class="hljs-punctuation">-&gt;</span> Sse&lt;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">futures_core</span>::Stream&lt;Item = <span class="hljs-type">Result</span>&lt;Event, axum::Error&gt;&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">interval</span> = <span class="hljs-title function_ invoke__">interval</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = IntervalStream::<span class="hljs-title function_ invoke__">new</span>(interval).<span class="hljs-title function_ invoke__">map</span>(|_| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">data</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;\n\n&quot;</span>, chrono::Local::<span class="hljs-title function_ invoke__">now</span>().<span class="hljs-title function_ invoke__">to_rfc2822</span>());<br>        <span class="hljs-title function_ invoke__">Ok</span>(Event::<span class="hljs-title function_ invoke__">default</span>().<span class="hljs-title function_ invoke__">data</span>(data))<br>    &#125;);<br><br>    Sse::<span class="hljs-title function_ invoke__">new</span>(stream)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="go-服务端">Go 服务端</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/20240606195749.gif"alt="Go 实现演示" /><figcaption aria-hidden="true">Go 实现演示</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sseHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 设置头部信息，确保允许跨域，并且告诉浏览器这是一个事件流</span><br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/event-stream&quot;</span>)<br>w.Header().Set(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>)<br>w.Header().Set(<span class="hljs-string">&quot;Connection&quot;</span>, <span class="hljs-string">&quot;keep-alive&quot;</span>)<br>w.Header().Set(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)<br><br><span class="hljs-comment">// 不断发送消息</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 生成服务器时间，并发送给客户端</span><br>now := time.Now()<br><span class="hljs-comment">// 生成消息，格式为 data: &#123;content&#125; \n\n</span><br>msg := fmt.Sprintf(<span class="hljs-string">&quot;data: %s\n\n&quot;</span>, now.Format(time.DateTime))<br><span class="hljs-comment">// 发送消息</span><br><span class="hljs-keyword">if</span> _, err := fmt.Fprintf(w, msg); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;write error:&quot;</span>, err)<br><span class="hljs-keyword">break</span><br>&#125;<br><br><span class="hljs-comment">// 刷新响应缓冲，确保即时发送</span><br>flusher, ok := w.(http.Flusher)<br><span class="hljs-keyword">if</span> !ok &#123;<br>log.Println(<span class="hljs-string">&quot;Streaming unsupported!&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br>flusher.Flush()<br><br><span class="hljs-comment">// 每秒发送一次</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/events&quot;</span>, sseHandler)<br>log.Println(<span class="hljs-string">&quot;Server started on port 8000...&quot;</span>)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文详细介绍了 SSE 的工作原理，并通过示例代码展示了如何使用 Go 和 Rust 实现一个简单的 SSE 服务端，展示了在实际项目中应用 SSE 的方法。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="SSE" scheme="https://hedon.top/tags/SSE/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨通过实现 json! 掌握声明宏</title>
    <link href="https://hedon.top/2024/05/28/rust-action-macro-json/"/>
    <id>https://hedon.top/2024/05/28/rust-action-macro-json/</id>
    <published>2024-05-28T07:37:23.000Z</published>
    <updated>2024-05-28T07:42:52.811Z</updated>
    
    <content type="html"><![CDATA[<p>在 Rust编程语言中，宏是一种强大的工具，可以用于在编译时生成代码。<code>json!</code>是一个在 Rust 中广泛使用的宏，它允许我们在 Rust 代码中方便地创建 JSON数据。</p><p>声明宏（declarative macros）是 Rust 中的一种宏，它们使用<code>macro_rules!</code> 关键字定义。</p><p>本文将参考《Rust 程序设计（第二版）》，通过实现 <code>json!</code>宏，深入理解声明宏的工作原理。</p><h1 id="结论先行">结论先行</h1><p>本文我们将构建一个 <code>json!</code> 宏，它支持我们以字符串 JSON风格的语法来编写 Json 值。如下面这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">students</span> = json![<br>&#123;<br><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Hedon Wang&quot;</span>,<br><span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">2022</span>,<br><span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Software engineering&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jun Lei&quot;</span>,<br><span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">1991</span>,<br><span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Computor science&quot;</span><br>&#125;<br>]<br></code></pre></td></tr></table></figure><blockquote><p><a href="#完整代码">完整代码</a></p></blockquote><h1 id="实现-json">实现 <code>json!</code></h1><h2 id="定义-json-enum">定义 Json enum</h2><p>首先我们需要思考一下 Json 结构是什么样子的？主要是以下 3 种模式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Wuhan University&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hubwi Wuhan&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;john&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-literal"><span class="hljs-keyword">null</span></span><br></code></pre></td></tr></table></figure><p>为此我们定义一个 Json 结构的枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone, PartialEq, Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Json</span> &#123;<br>    Null,<br>    <span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-type">bool</span>),<br>    <span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">String</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-type">Vec</span>&lt;Json&gt;),<br>    <span class="hljs-title function_ invoke__">Object</span>(HashMap&lt;<span class="hljs-type">String</span>, Json&gt;),<br>&#125;<br></code></pre></td></tr></table></figure><p>你应该可以感到非常奇妙，使用一个这么简单的枚举，居然就可以表示所有的Json 结构了。遗憾的是，现在这个结构编写 Json 值的语法相当冗长。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">people</span> = Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>    (<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hedon&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>    (<span class="hljs-string">&quot;age&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">10.0</span>)),<br>    (<span class="hljs-string">&quot;is_student&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)),<br>    (<br>        <span class="hljs-string">&quot;detail&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            (<span class="hljs-string">&quot;address&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;beijing&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>            (<span class="hljs-string">&quot;phone&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()))<br>        ]))<br>    )<br>]))<br></code></pre></td></tr></table></figure><p>我们期望可以以下面这种方式来声明 Json变量，这看起来就清爽许多了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">students</span> = json!([<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jim Blandy&quot;</span>,<br>        <span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">1926</span>,<br>        <span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Tibetan throat singing&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jason Orendorff&quot;</span>,<br>        <span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">1702</span>,<br>        <span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Knots&quot;</span><br>    &#125;<br>]);<br></code></pre></td></tr></table></figure><h2 id="猜想-json">猜想 <code>json!</code></h2><p>我们可以预见 Json 宏内部将会有多条规则，因为 JSON数据有多种类型：对象、数组、数值等。事实上，我们可以合理地猜测每种 JSON类型都将有一条规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null)    =&gt; &#123; Json::Null &#125;;<br>    ([ ... ]) =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Array</span>(...) &#125;;<br>    (&#123; ... &#125;) =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Object</span>(...) &#125;;<br>    (???)     =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Boolean</span>(...) &#125;;<br>    (???)     =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Number</span>(...) &#125;;<br>    (???)     =&gt; &#123; Json::<span class="hljs-title function_ invoke__">String</span>(...) &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而这不太正确，因为宏模式无法区分最后 3种情况，稍后我们会讨论如何处理。至于前 3种情况，显然它们是以不同的语法标记开始的，所以这几种情况比较好处理。</p><h2 id="实现-null">实现 Null</h2><p>我们先从最简单的 <code>Null</code> 分支开始，先编写如下测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_null_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(null);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::Null);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要通过上述测试用例非常简单，我们只需要在 <code>macro_rules!</code>支持中匹配这种情况即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>#[macro_export]</code> 注解是 Rust中的一个属性，用于指示这个宏应该被导出到调用者的作用域中，这样其他模块也可以使用它。</li><li><code>macro_rules!</code>宏定义了一个自定义的宏。在这里，它创建了一个名为 <code>json</code>的宏，用于生成 JSON 数据。</li><li>宏定义中 <code>(null)</code> 是匹配模式。这意味着当你调用<code>json!</code> 宏并传递 <code>null</code>作为参数时，将会触发这个规则。</li><li><code>=&gt;</code>符号用于指示匹配模式后的代码块。在这里，它指定了当匹配<code>(null)</code> 时应该生成的代码块。</li><li><code>Json::Null</code> 是一个 JSON 类型的枚举值，表示 JSON 中的null 值。这个宏的目的是将传入的 <code>null</code> 转换为<code>Json::Null</code>。</li></ul><h2 id="实现-booleannumberstring">实现 Boolean/Number/String</h2><p>我们先准备如下测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_boolean_number_string_json</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察分析，它们其实都是同一种模式：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240528114725679.png"alt="Boolean/Number/String 分析" /><figcaption aria-hidden="true">Boolean/Number/String 分析</figcaption></figure><p>现在需要解决的问题就是，如何将这 3 种模式进行统一，这样在<code>macro_rules!</code> 中才可以统一匹配模式并进行代码生成。</p><p>这里我们其实需要做的就是将 <code>bool</code>、<code>f64</code> 和<code>&amp;str</code> 转为对应的 <code>Json</code>类型。那就需要用到标准库中的 <code>From</code> trait 了。</p><p>做法很简单，我们实现如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">Boolean</span>(value)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;&amp;<span class="hljs-type">str</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">String</span>(value.<span class="hljs-title function_ invoke__">to_string</span>())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">f64</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">Number</span>(value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后完善我们的 <code>json!</code>，目前的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们使用 <code>$value</code>作 为变量来承接匹配到的元素，其类型为<code>tt</code> ，表示任意的语法标记树。具体可以参考：<ahref="#片段类型">片段类型</a>。</p><p>这时运行上述测试用例，是没有问题的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">PASS [   0.004s] json-macro tests::test_boolean_number_string_json<br>PASS [   0.004s] json-macro tests::test_null_json<br></code></pre></td></tr></table></figure><p>美中不足的是，JSON 结构中的数字类型，其实不一定是 f64，也可以是i32、u32、f32 或其他的数字类型，如果我们要为这全部的数字类型都实现到Json 的 <code>From</code> trait，那就多冗余。</p><p>这个时候我们又可以实现一个宏，用于快速生成<code>impl From&lt;T&gt; for Json</code>。这个实现比较简单，本文就不赘述了，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> impl_from_for_primitives &#123;<br>    (  $( $<span class="hljs-keyword">type</span>: ty ) * ) =&gt; &#123;<br>        $(<br>            <span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;$<span class="hljs-keyword">type</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>                <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: $<span class="hljs-keyword">type</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>                    Json::<span class="hljs-title function_ invoke__">Number</span>(value <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>)<br>                &#125;<br>            &#125;<br>        )*<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们只需要用下面这一行代码，就可以为所有的数字类型实现<code>From</code> trait 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">impl_from_for_primitives!(<span class="hljs-type">u8</span> <span class="hljs-type">u16</span> <span class="hljs-type">u32</span> <span class="hljs-type">u64</span> <span class="hljs-type">i8</span> <span class="hljs-type">i16</span> <span class="hljs-type">i32</span> <span class="hljs-type">i64</span> <span class="hljs-type">f32</span> <span class="hljs-type">f64</span> <span class="hljs-type">isize</span> <span class="hljs-type">usize</span>);<br></code></pre></td></tr></table></figure><p>记得这个时候你要删除上面手动实现的<code>impl From&lt;f64&gt; for Json</code>，不然会有 impl 冲突错误。</p><p>再次运行测试，也是可以通过的。</p><h2 id="实现-array">实现 Array</h2><p>准备如下测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_json</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!([<span class="hljs-number">1</span>, null, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-literal">true</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        json,<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<br>            Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>),<br>            Json::Null,<br>            Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>            Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)<br>        ])<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>要匹配<code>[1, null, "string", true]</code>这个模式，笔者的分析过程如下：</p><ol type="1"><li>首先是外面的两个中括号 <code>[</code> 和 <code>]</code> ；</li><li>再往里，是一个重复匹配的模式，以 <code>,</code> 分割，可以匹配 0到任意多个元素，所以是 <code>$(  ,*)</code> ，具体可以参考：<ahref="#重复模式">重复模式</a>；</li><li>最里面就是第 2 步要匹配的元素了，我们先用 <code>$element</code>作为变量来承接每一个元素，其类型为 <code>tt</code>，表示任意的语法标记树。</li></ol><p>分析完匹配的表达式后，我们就可以得到：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">([ $( $element:tt ), * ]) =&gt; &#123; <span class="hljs-comment">/* TODO */</span> &#125;<br></code></pre></td></tr></table></figure><p>我们要生成的代码长这个样子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust">Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<br>    Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>),<br>    Json::Null,<br>    Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>    Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)<br>])<br></code></pre></td></tr></table></figure><p>其实就是一个 <code>vec!</code>，然后里面每个元素都是一个<code>Json</code>，如此递归下去。</p><p>即可以得到代码生成部分的逻辑为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[$(json!($element)),* ])<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240528134133088.png"alt="Json::Array 宏分析" /><figcaption aria-hidden="true">Json::Array 宏分析</figcaption></figure><p>综上，我们实现的代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ([ $( $element: tt),* ]) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[ $( json!($element)), * ])<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试用例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">PASS [   0.003s] json-macro tests::test_null_json<br>PASS [   0.003s] json-macro tests::test_boolean_number_string_json<br>PASS [   0.004s] json-macro tests::test_array_json<br></code></pre></td></tr></table></figure><h2 id="实现-object">实现 Object</h2><p>写好如下测试用例，这次我们顺带把 Null、Boolean、Number 和 String带上了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_object_json</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(&#123;<br>        <span class="hljs-string">&quot;null&quot;</span>: null,<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hedon&quot;</span>,<br>        <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&quot;is_student&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;detail&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;beijing&quot;</span>,<br>            <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span><br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        json,<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            (<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hedon&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>            (<span class="hljs-string">&quot;age&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">10.0</span>)),<br>            (<span class="hljs-string">&quot;is_student&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)),<br>            (<br>                <span class="hljs-string">&quot;detail&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>                Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>                    (<span class="hljs-string">&quot;address&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;beijing&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>                    (<span class="hljs-string">&quot;phone&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()))<br>                ]))<br>            )<br>        ]))<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>对比预期的 <code>json!</code> 宏内容和展开后的代码：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240528133040062.png"alt="Json::Object 宏分析" /><figcaption aria-hidden="true">Json::Object 宏分析</figcaption></figure><p>完善我们的 <code>macro_rules! json</code> ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ([ $( $element: tt),* ]) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[ $( json!($element)), * ])<br>    &#125;;<br>    (&#123; $( $key:tt : $value:tt ),* &#125;) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            $(<br>                ( $key.<span class="hljs-title function_ invoke__">to_string</span>(), json!($value) )<br>            ), *<br>        ]))<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试用例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">PASS [   0.004s] json-macro tests::test_object_json<br>PASS [   0.005s] json-macro tests::test_array_json<br>PASS [   0.004s] json-macro tests::test_null_json<br>PASS [   0.005s] json-macro tests::test_boolean_number_string_json<br></code></pre></td></tr></table></figure><p>至此，我们就完成了 <code>json!</code> 宏的构建了！完整源码可见：<ahref="https://www.notion.so/e90c161d8e3743b2a4f788e3d7b75181?pvs=21">完整代码</a></p><p>Peace! Enjoy coding~</p><h1 id="附录">附录</h1><h2 id="重复模式">重复模式</h2><p>在 <ahref="https://www.notion.so/Array-c914526ab9474ccd9cb92c7eb17225b6?pvs=21">实现Array</a> 中，我们匹配了这样一个模式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">([ $( $element:tt ), * ]) =&gt; &#123; <span class="hljs-comment">/* TODO */</span> &#125;<br></code></pre></td></tr></table></figure><p>其中 <code>$($element:tt), *)</code>就是一个重复模式，其可以进一步抽象为 <code>$( ... ),*</code> ，表示匹配0 次或多次，以 <code>,</code> 分隔。</p><p>Rust 支持以下全部重复模式：</p><table><thead><tr class="header"><th>模式</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>$( … ) *</td><td>匹配 0 次或多次，没有分隔符</td></tr><tr class="even"><td>$( … ), *</td><td>匹配 0 次或多次，以逗号分隔</td></tr><tr class="odd"><td>$( … ); *</td><td>匹配 0 次或多次，以分号分隔</td></tr><tr class="even"><td>$( … ) +</td><td>匹配 1 次或多次，没有分隔符</td></tr><tr class="odd"><td>$( … ), +</td><td>匹配 1 次或多次，以逗号分隔</td></tr><tr class="even"><td>$( … ); +</td><td>匹配 1 次或多次，以分号分隔</td></tr><tr class="odd"><td>$( … ) ?</td><td>匹配 0 次或 1 次，没有分隔符</td></tr></tbody></table><p>即：</p><ul><li><code>*</code> 表示 0 次或多次</li><li><code>+</code> 表示 1 次或多次</li><li><code>?</code> 表示 0 次或 1 次</li><li>可在上述 3 者之前加入分隔符</li></ul><h2 id="片段类型">片段类型</h2><p>在 <a href="#实现-array">实现 Array</a>中，我们匹配了这样一个模式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">([ $( $element:tt ), * ]) =&gt; &#123; <span class="hljs-comment">/* TODO */</span> &#125;<br></code></pre></td></tr></table></figure><p>这里我们将 <code>$element</code> 指定为 <code>tt</code>，这个<code>tt</code> 就是宏中的一种片段类型。</p><p><code>tt</code> 能匹配单个语法标记树，包含：</p><ul><li>一对括号，如 <code>(..)</code>、<code>[..]</code>、或<code>&#123;..&#125;</code> ，以及位于其中的所有内容，包括嵌套的语法标记树。</li><li>单独的非括号语法标记，比如 <code>1926</code> 或 <code>Knots</code>。</li></ul><p>所以为了匹配任意类型的 <code>Json</code> ，我们选择了 <code>tt</code>作为 <code>$element</code> 的片段类型。</p><p><code>macro_rules!</code> 支持的片段类型如下所示：</p><table><thead><tr class="header"><th>片段类型</th><th>匹配（带例子）</th><th>后面可以跟 ······</th></tr></thead><tbody><tr class="odd"><td>expr</td><td>表达式：2 + 2, "udon", x.len()</td><td>=&gt;,;</td></tr><tr class="even"><td>stmt</td><td>表达式或声明，不包括任何尾随分号（很难用，请尝试使用 expr 或block）</td><td>=&gt;,;</td></tr><tr class="odd"><td>ty</td><td>类型：String, Vec<u8>, (&amp;str, bool), dyn Read + Send</td><td>=&gt;,; =</td></tr><tr class="even"><td>path</td><td>路径：ferns, ::std::sync::mpsc</td><td>=&gt;,; =</td></tr><tr class="odd"><td>pat</td><td>模式：_, Some(ref x)</td><td>=&gt;,=</td></tr><tr class="even"><td>item</td><td>语法项：struct Point { x: f64, y: f64 }, mod ferns;</td><td>任意</td></tr><tr class="odd"><td>block</td><td>块：{ s += "ok"; true }</td><td>任意</td></tr><tr class="even"><td>meta</td><td>属性的主体：inline, derive(Copy, Clone), doc="3D models."</td><td>任意</td></tr><tr class="odd"><td>literal</td><td>字面量值：1024, "Hello, world!", 1_000_000f64</td><td>任意</td></tr><tr class="even"><td>lifetime</td><td>生命周期：'a, 'item, 'static</td><td>任意</td></tr><tr class="odd"><td>vis</td><td>可见性说明符：pub, pub(crate), pub(in module::submodule)</td><td>任意</td></tr><tr class="even"><td>ident</td><td>标识符：std, Json, longish_variable_name</td><td>任意</td></tr><tr class="odd"><td>tt</td><td>语法标记树：;, &gt;=, {}, [0 1 (+ 0 1)]</td><td>任意</td></tr></tbody></table><h2 id="完整代码">完整代码</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-meta">#[derive(Debug, Clone, PartialEq)]</span><br><span class="hljs-meta">#[allow(unused)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Json</span> &#123;<br>    Null,<br>    <span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-type">bool</span>),<br>    <span class="hljs-title function_ invoke__">String</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-type">Vec</span>&lt;Json&gt;),<br>    <span class="hljs-title function_ invoke__">Object</span>(HashMap&lt;<span class="hljs-type">String</span>, Json&gt;),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">Boolean</span>(value)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;&amp;<span class="hljs-type">str</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">String</span>(value.<span class="hljs-title function_ invoke__">to_string</span>())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">String</span>(value)<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> impl_from_for_primitives &#123;<br>    (  $( $<span class="hljs-keyword">type</span>: ty ) * ) =&gt; &#123;<br>        $(<br>            <span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;$<span class="hljs-keyword">type</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>                <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: $<span class="hljs-keyword">type</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>                    Json::<span class="hljs-title function_ invoke__">Number</span>(value <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>)<br>                &#125;<br>            &#125;<br>        )*<br>    &#125;<br>&#125;<br><br>impl_from_for_primitives!(<span class="hljs-type">u8</span> <span class="hljs-type">u16</span> <span class="hljs-type">u32</span> <span class="hljs-type">u64</span> <span class="hljs-type">i8</span> <span class="hljs-type">i16</span> <span class="hljs-type">i32</span> <span class="hljs-type">i64</span> <span class="hljs-type">f32</span> <span class="hljs-type">f64</span> <span class="hljs-type">isize</span> <span class="hljs-type">usize</span>);<br><br><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ([ $( $element: tt),* ]) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[ $( json!($element)), * ])<br>    &#125;;<br>    (&#123; $( $key:tt : $value:tt ),* &#125;) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            $(<br>                ( $key.<span class="hljs-title function_ invoke__">to_string</span>(), json!($value) )<br>            ), *<br>        ]))<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_null_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(null);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::Null);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_boolean_number_string_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-literal">true</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>));<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-number">1.0</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>));<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()));<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_object_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(&#123;<br>            <span class="hljs-string">&quot;null&quot;</span>: null,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hedon&quot;</span>,<br>            <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">10</span>,<br>            <span class="hljs-string">&quot;is_student&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-string">&quot;detail&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;beijing&quot;</span>,<br>                <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-built_in">assert_eq!</span>(<br>            json,<br>            Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>                (<span class="hljs-string">&quot;null&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::Null),<br>                (<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hedon&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>                (<span class="hljs-string">&quot;age&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">10.0</span>)),<br>                (<span class="hljs-string">&quot;is_student&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)),<br>                (<br>                    <span class="hljs-string">&quot;detail&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>                    Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>                        (<span class="hljs-string">&quot;address&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;beijing&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>                        (<span class="hljs-string">&quot;phone&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()))<br>                    ]))<br>                )<br>            ]))<br>        )<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!([<span class="hljs-number">1</span>, null, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-literal">true</span>]);<br>        <span class="hljs-built_in">assert_eq!</span>(<br>            json,<br>            Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<br>                Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>),<br>                Json::Null,<br>                Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>                Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)<br>            ])<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文分步展示了实现 json! 宏的过程，包括定义 Json 枚举和不同类型的匹配规则。通过这个过程，读者可以掌握声明宏的基本概念和实现方法。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="宏" scheme="https://hedon.top/tags/%E5%AE%8F/"/>
    
    <category term="元编程" scheme="https://hedon.top/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>xgo 原理探索</title>
    <link href="https://hedon.top/2024/05/23/go-xgo-explore/"/>
    <id>https://hedon.top/2024/05/23/go-xgo-explore/</id>
    <published>2024-05-23T13:15:10.000Z</published>
    <updated>2024-05-27T11:44:43.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go-单测-mock-方案">Go 单测 mock 方案</h1><table><thead><tr class="header"><th>Mock 方法</th><th>原理</th><th>依赖</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>接口 Mock</td><td>为依赖项定义接口，并提供接口的 Mock 实现。</td><td>需要定义接口和 Mock 实现。</td><td>灵活，遵循 Go 的类型系统；易于替换实现。</td><td>需要更多的样板代码来定义接口和 Mock 实现。</td></tr><tr class="even"><td>Monkey Patching（bouk/moneky）</td><td>直接修改函数指针的内存地址来实现对函数的替换。</td><td>内存保护；汇编代码。</td><td>强大，可以 Mock 任何函数，甚至第三方库的函数。</td><td>复杂，容易出错；线程不安全；依赖系统指令集。</td></tr></tbody></table><h1 id="boukmonkey-弊端">bouk/monkey 弊端</h1><blockquote><p><a href="https://github.com/bouk/monkey">bouk/monkey</a> 🐒</p></blockquote><p>monkey 的核心功能是能够在运行时替换某个函数的实现。</p><p><strong>原理：</strong></p><ol type="1"><li><strong>函数指针替换</strong>：在 Go语言中，函数的地址存储在内存中。bouk/monkey通过直接修改函数指针的内存地址来实现对函数的替换。</li><li><strong>汇编代码</strong>：使用了汇编代码来实现对函数入口的跳转。这些汇编代码会在函数被调用时，将执行流重定向到新的函数实现。</li><li><strong>内存保护</strong>：为了修改内存中的函数指针，bouk/monkey需要临时修改内存页面的保护属性（例如，将页面设为可写）。在修改完毕后，它会恢复原来的保护属性。</li><li><strong>反射与 unsafe 包</strong>：利用 Go 的反射机制和 unsafe包，bouk/monkey 可以获取并操作函数的底层实现细节。</li></ol><p><strong>实现步骤：</strong></p><ol type="1"><li><strong>保存原函数</strong>：在替换函数之前，bouk/monkey会保存原始函数的指针，以便在需要时恢复或调用原始函数。</li><li><strong>生成跳转代码</strong>：bouk/monkey生成一段汇编跳转代码，这段代码会在函数调用时，将执行流跳转到新的函数实现。</li><li><strong>修改函数指针</strong>：使用 unsafe 包，bouk/monkey修改目标函数的入口地址，指向生成的跳转代码。</li><li><strong>恢复内存保护</strong>：在完成上述修改后，恢复内存页面的保护属性。</li></ol><p><strong>有以下几个弊端：</strong></p><ol type="1"><li>如果启用了内联，Monkey有时无法修补函数。尝试在禁用内联的情况下运行测试，例如:<code>go test -gcflags=-l</code>。同样的命令行参数也可以用于构建。</li><li>Monkey不能在一些面向安全的操作系统上工作，这些操作系统不允许同时写入和执行内存页。目前的方法并没有真正可靠的解决方案。</li><li>线程不安全的。</li><li>依赖指令集。</li></ol><h1 id="先看-xgo-怎么用">先看 xgo 怎么用</h1><blockquote><p><a href="https://github.com/xhd2015/xgo">xgo</a> 😈</p></blockquote><p>代码结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">.<br>├── greet.<span class="hljs-keyword">go</span><br>└── greet_test.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>现在在 <code>greet.go</code> 中有一个函数 <code>greet</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>在真实的生产环境中，<code>greet</code>可能要复杂得多，它可能会依赖各种第三方API，也可能会依赖数据库等多种外部组件。所以在测试的时候，我们希望对其进行<strong>mock</strong>，使其返回一个固定的值，便于我们撰写单元测试。</p><p><code>xgo</code> 参考了 <code>go-monkey</code> 的思想，但是不从<strong>修改指令</strong> 这个途径入手，而是另辟蹊径，从<strong>代码重写</strong> 的角度实现了 <strong>mock</strong>的能力。</p><p>为了使用 <code>xgo</code>，我们需要先安装 <code>xgo</code>这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install github.com/xhd2015/xgo/cmd/xgo@latest<br></code></pre></td></tr></table></figure><p>同时在我们的项目中需要引入 <code>xgo</code> 依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get <span class="hljs-string">&quot;github.com/xhd2015/xgo/runtime/mock&quot;</span><br></code></pre></td></tr></table></figure><p>我们编写的 <code>greet_test.go</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> xgo_use<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/xhd2015/xgo/runtime/mock&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestOriginGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMockGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.Patch(greet, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在 <code>TestMockGreet</code> 这个单元测试中，我们将<code>greet</code> 进行了 mock，返回 <code>"mock " + s</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mock.Patch(greet, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br></code></pre></td></tr></table></figure><p>为了使用 <code>xgo</code>的能力，我们在执行单元测试的时候，需要运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xgo <span class="hljs-built_in">test</span> -v ./<br></code></pre></td></tr></table></figure><p>输出大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  xgo-use git:(master) xgo <span class="hljs-built_in">test</span> -v ./<br>xgo is taking a <span class="hljs-keyword">while</span> to setup, please <span class="hljs-built_in">wait</span>...<br>=== RUN   TestOriginGreet<br>--- PASS: TestOriginGreet (0.00s)<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>PASS<br>ok      xgo-explore/xgo-use     (cached)<br></code></pre></td></tr></table></figure><h1 id="xgo-的核心原理">xgo 的核心原理</h1><p><code>xgo</code> 的核心原理是利用 <code>go build -toolexec</code>的能力。</p><p>运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">help</span> build<br></code></pre></td></tr></table></figure><p>找到 <code>toolexec</code> 的相关说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">-toolexec <span class="hljs-string">&#x27;cmd args&#x27;</span><br>        a program to use to invoke toolchain programs like vet and asm.<br>        For example, instead of running asm, the go <span class="hljs-built_in">command</span> will run<br>        <span class="hljs-string">&#x27;cmd args /path/to/asm &lt;arguments for asm&gt;&#x27;</span>.<br>        The TOOLEXEC_IMPORTPATH environment variable will be <span class="hljs-built_in">set</span>,<br>        matching <span class="hljs-string">&#x27;go list -f &#123;&#123;.ImportPath&#125;&#125;&#x27;</span> <span class="hljs-keyword">for</span> the package being built.<br></code></pre></td></tr></table></figure><p>一言以蔽之：<code>-toolexec</code> 允许对 go 工具链进行拦截，包括<code>vet</code>、<code>asm</code>、<code>compile</code> 和<code>link</code>。</p><p>这种技术也被称为：插桩（stubbing）、增强（instrumentation）和代码重写（rewriting）。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Km9eLWtYFJMiFYP0uC-B29J__5mGvLlSsrD52hWgS_S2nOGSx9PnMybHuqcQljAtTUr5QVVqaHGyyAEwqVPowhPqJvAZHLALdQpj6gzHzb60NLLe91tX87_sAerIGq2mwYMVdBcptglQpJ0QkfmDC-ZHoQ=s2048.png"alt="-toolexec 示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）" /><figcaption aria-hidden="true">-toolexec示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）</figcaption></figure><p>基于上述分析，<code>xgo</code> 提出了 <strong>代码重写</strong>的思路，实现了 <strong>在编译过程中插入拦截器代码</strong> 的功能：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240523164815047.png"alt="xgo 在 go build 中的作用位置（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）" /><figcaption aria-hidden="true">xgo 在 go build中的作用位置（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）</figcaption></figure><p>所以上述我们的 <code>greet.go</code> 文件中的源代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>经过 <code>xgo</code> 编译后最终实际编译的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;runtime&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (r0 <span class="hljs-type">string</span>) &#123;<br>  stop, post := runtime.__xgo_trap(Greet, &amp;s, &amp;r0)<br>  <span class="hljs-keyword">if</span> stop &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">defer</span> post()<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/5e020865-fd1d-49d3-be72-7ee2233a3c5f.png"alt="greet 函数重写变化示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）" /><figcaption aria-hidden="true">greet函数重写变化示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）</figcaption></figure><p>如图所示，一旦函数被调用，它的控制流首先转移到<code>Trap</code>，然后一系列拦截器将根据其目的检查当前调用是否应该被Mock、修改、记录或停止。</p><p>如果 <code>greet</code> 注册了 mock 函数，那么就会在<code>__xgo_trap</code> 中调用 mock 的函数，并将返回值设置到<code>r0</code> 上进行返回，而跳过原始的执行逻辑。</p><h1 id="第-1-步死代码实现">第 1 步：死代码实现</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  01-deadcode git:(master) tree<br>.<br>├── greet.go<br>├── greet_test.go<br>└── mock.go<br></code></pre></td></tr></table></figure><p>我们先从最简单的实现开始，采用侵入性代码实现 <code>xgo</code>的核心功能，这里我们还用不到 <code>-toolexec</code>。</p><p>代码结构如上所示，在 <code>mock.go</code> 中，我们有如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mockFuncs = sync.Map&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterMockFunc</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>, fun <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>mockFuncs.Store(funcName, fun)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>mockFuncs</code>: 用于承载函数与 mock 函数的对应关系，其中 key为函数名称，value 为 mock 函数。我们使用 <code>sync.Map</code>来保证并发安全。</li><li><code>RegisterMockFunc</code> 用于为指定的 funcName 注册 mock函数。</li></ul><p>在 <code>greet.go</code> 中，我们有一个 <code>Greet</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们要对其支持 mock，那么需要修改其实现为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fun, ok := mockFuncs.Load(<span class="hljs-string">&quot;Greet&quot;</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>f, ok := fun.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br><span class="hljs-keyword">return</span> f(s)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>在修改后的代码中，我们先判断是否存在 mock 函数，如果存在，则执行 mock函数，否则执行原始逻辑。</p><p>现在我们在 <code>greet_test.go</code> 中编写测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMockGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestOriginGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 单独执行 TestMockGreet</span><br>➜  01-deadcode git:(master) ✗ go <span class="hljs-built_in">test</span> -v -run TestMockGreet<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>PASS<br>ok      xgo-explore/01-deadcode 0.103s<br><br><span class="hljs-comment"># 单独执行 TestOriginGreet</span><br>➜  01-deadcode git:(master) ✗ go <span class="hljs-built_in">test</span> -v -run TestOriginGreet<br>=== RUN   TestOriginGreet<br>--- PASS: TestOriginGreet (0.00s)<br>PASS<br>ok      xgo-explore/01-deadcode 0.102s<br><br><span class="hljs-comment"># 一起执行</span><br>➜  01-deadcode git:(master) ✗ go <span class="hljs-built_in">test</span> -v -run $Test$<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>=== RUN   TestOriginGreet<br>    greet_test.go:20: Greet() = <span class="hljs-string">&quot;mock world&quot;</span>; want <span class="hljs-string">&quot;hello world&quot;</span><br>--- FAIL: TestOriginGreet (0.00s)<br>FAIL<br><span class="hljs-built_in">exit</span> status 1<br>FAIL    xgo-explore/01-deadcode 0.102s<br></code></pre></td></tr></table></figure><p>我们会发现单独执行都是 ok 的，不过一起执行的话<code>TestOriginGreet</code> 就失败了，这是因为先执行了<code>TestMockGreet</code>，这个时候已经往 <code>mockFunc</code>中注册了 mock 函数了，所以 <code>TessOriginGreet</code>就执行失败了。</p><p>这里需要在协程层面上做 mock 隔离，<code>xgo</code>的思路是在编译时注入 <code>getg()</code>函数来获取当前协程信息从而实现在注册 mock函数时进行协程隔离。本文将聚焦在 <code>xgo</code> 的核心原理<strong>代码重写</strong> 上，故暂时不考虑这一块。</p><p>Ok，那么短短几行代码，我们就将 <code>xgo</code>的最核心思想给展示出来了。可以看到，<code>xgo</code>的核心思想是往源代码中加入 <strong>合法的 Go代码</strong>，所以不涉及指令重写，故而只要你的机器能执行 Go程序，天然就支持 mock功能，这就天然达到了架构无关的兼容性了。同时我们也使用了<code>sync.Map</code> 来保证了并发安全。</p><h1 id="第-2-步死代码拦截器">第 2 步：死代码拦截器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  02-deadcode-interceptor git:(master) tree<br>.<br>├── greet.go<br>├── greet_test.go<br>└── mock.go<br></code></pre></td></tr></table></figure><p>在第 1 步中，这段代码我觉得有点冗长了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">fun, ok := mockFuncs.Load(<span class="hljs-string">&quot;Greet&quot;</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>  f, ok := fun.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<br>  <span class="hljs-keyword">if</span> ok &#123;<br>    <span class="hljs-keyword">return</span> f(s)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考 <code>xgo</code> 的函数签名，我们对其进行优化，在<code>mock.go</code> 中加入一个 <strong>丐版拦截器</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// mock.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InterceptMock</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>, arg <span class="hljs-type">string</span>, result *<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>fn, ok := mockFuncs.Load(funcName)<br><span class="hljs-keyword">if</span> ok &#123;<br>f, ok := fn.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>*result = f(arg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对应 <code>greet.go</code> 中 <code>Greet</code> 函数就修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>这看起来就清爽多了。再次执行测试代码，一样是可以通过的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  02-deadcode-interceptor git:(master) go <span class="hljs-built_in">test</span> -v -run TestOriginGreet<br>=== RUN   TestOriginGreet<br>--- PASS: TestOriginGreet (0.00s)<br>PASS<br>ok      xgo-explore/02-deadcode-interceptor     0.331s<br><br>➜  02-deadcode-interceptor git:(master) go <span class="hljs-built_in">test</span> -v -run TestMockGreet<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>PASS<br>ok      xgo-explore/02-deadcode-interceptor     0.103s<br></code></pre></td></tr></table></figure><h1 id="第-3-步toolexec-初探">第 3 步：toolexec 初探</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>这里 <code>mock.go</code> 没有任何变化。我们期望使用<code>-toolexec</code> 来修改源代码，以实现 mock无源代码侵入的特性，所以我们在 <code>greet.to</code> 中将<code>Greet</code> 函数恢复为只关注实际功能的样子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>同时为了更好地测试使用 <code>-toolexec</code>编译后的运行结果，这里将 <code>greet_test.go</code> 删除了并新增了<code>main.go</code> 文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>那么 <code>-toolexec</code> 要执行的命令怎么实现呢？在 Google 搜索<strong>go toolexec</strong> 你会看到官方给出的一个案例：<ahref="https://go.dev/src/cmd/go/testdata/script/toolexec.txt">toolexec.txt</a>。</p><p>核心部分在最下面，参考这个示例，我们来实现自己的<code>toolexec</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p cmd/mytool<br><span class="hljs-built_in">touch</span> cmd/mytool/mytool.go<br></code></pre></td></tr></table></figure><p>在<code>mytool.go</code>中，我们先写这么点代码，看一下会输出什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tool, args := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>:]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;-V=full&quot;</span> &#123;<br><span class="hljs-comment">// don&#x27;t do anything to infuence the version full output.</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;tool: %s\n&quot;</span>, tool)<br>fmt.Printf(<span class="hljs-string">&quot;args: %v\n&quot;</span>, args)<br>&#125;<br>  <span class="hljs-comment">// 继续执行之前的命令</span><br>cmd := exec.Command(tool, args...)<br>cmd.Stdout = os.Stdout<br>cmd.Stderr = os.Stderr<br><br><span class="hljs-keyword">if</span> err := cmd.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;run command error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们企图输出执行的工具 <code>tool</code> 及传给它的参数<code>args</code>。由于 <code>-V=full</code>的作用是在终端输出版本信息，所以我们要跳过它，避免产生干扰。输出日志后，我们暂且先继续执行原始的命令，不对编译过程做其他的干扰。</p><p>Ok，现在就来看看这个 <code>-toolexec</code> 到底做了什么，在<code>03-toolexec-static</code> 目录下执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清除缓存，一直使用最新的编译结果</span><br>go clean -cache -modcache -i -r<br><span class="hljs-comment"># 编译 mytool</span><br>go build ./cmd/mytool<br><span class="hljs-comment"># 编译业务程序</span><br>go build -toolexec=./mytool -o main<br></code></pre></td></tr></table></figure><p>因为这几个命令经常会用到，所以我们可以将其封装到<code>script.sh</code> 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> script.sh<br><span class="hljs-built_in">chmod</span> +x script.sh<br></code></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>go clean -cache -modcache -i -r<br>go build ./cmd/mytool<br>go build -toolexec=./mytool -o main<br></code></pre></td></tr></table></figure><p>执行上述命令后，可以看到以下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ./script.sh<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/compile<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/_pkg_.a -trimpath <span class="hljs-variable">$WORK</span>/b001=&gt; -p main -lang=go1.22 -complete -buildid PcS9clqF_ny_Ds5N0i_s/PcS9clqF_ny_Ds5N0i_s -goversion go1.22.3 -c=4 -shared -nolocalimports -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg -pack ./greet.go ./main.go ./mock.go]<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/link<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/exe/a.out -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg.link -buildmode=pie -buildid=KgnnCoU_6enHkOm-T62Z/PcS9clqF_ny_Ds5N0i_s/H80dtgGZw1L8mTtVqJBf/KgnnCoU_6enHkOm-T62Z -extld=cc <span class="hljs-variable">$WORK</span>/b001/_pkg_.a]<br></code></pre></td></tr></table></figure><p>可以看到执行了 <code>compile</code> 和 <code>link</code>两个工具，<code>compile</code> 是编译过程，将生成 <code>&#123;&#125;.out</code>文件，而 <code>link</code> 是将多个 <code>&#123;&#125;.out</code>文件链接成一个可执行文件。这是很经典的编译过程，如果对 Go语言的编译过程感兴趣，也可以参考官方的 <ahref="https://github.com/golang/go/tree/release-branch.go1.22/src/cmd/compile">GoCompile Readme</a>，或者笔者撰写的 <ahref="https://hedon.top/2023/11/29/go-compilation/">Go1.21.0程序编译过程</a>。</p><p>这里我们需要重点关注的是 <code>compile</code>命令，它是负责编译源代码的，涉及到的源代码文件会通过<code>-pack ./greet.go ./main.go ./mock.go</code> 传递给<code>compile</code> 命令。</p><p>结合 <code>-toolexec</code> 的帮助信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">-toolexec <span class="hljs-string">&#x27;cmd args&#x27;</span><br>        a program to use to invoke toolchain programs like vet and asm.<br>        For example, instead of running asm, the go <span class="hljs-built_in">command</span> will run<br>        <span class="hljs-string">&#x27;cmd args /path/to/asm &lt;arguments for asm&gt;&#x27;</span>.<br>        The TOOLEXEC_IMPORTPATH environment variable will be <span class="hljs-built_in">set</span>,<br>        matching <span class="hljs-string">&#x27;go list -f &#123;&#123;.ImportPath&#125;&#125;&#x27;</span> <span class="hljs-keyword">for</span> the package being built.<br></code></pre></td></tr></table></figure><p>我们只需要在执行 <code>compile</code> 命令之前，在<code>cmd args</code> 这个环节，进行 <strong>代码重写</strong>就可以实现我们想要的功能了。</p><p>我们现在是要对 <code>greet.go</code> 里面的 <code>Greet</code>函数进行重写，先看看之前的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>重写后的代码应该跟我们之前 <strong>第 2 步</strong> 是一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br> <span class="hljs-keyword">return</span> res<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有 n多种方式可以做到，现在笔者决定使用最暴力的方式，直接临时创建一个包含这段代码的文件<code>tmp.go</code>，并替换掉传给 <code>compile</code> 的参数，即将<code>-pack ./greet.go ./main.go ./mock.go</code> 替换为<code>-pack tmp.go ./main.go ./mock.go</code></p><p>综上，<code>cmd/mytool/mytool/go</code> 实现的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tool, args := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>:]<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;-V=full&quot;</span> &#123;<br><span class="hljs-comment">// don&#x27;t do anything to infuence the version full output.</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> filepath.Base(tool) == <span class="hljs-string">&quot;compile&quot;</span> &#123;<br>index := findGreetFile(args)<br><span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">-1</span> &#123;<br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><span class="hljs-keyword">defer</span> os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br>_, _ = f.WriteString(newCode)<br>args[index] = <span class="hljs-string">&quot;tmp.go&quot;</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;tool: %s\n&quot;</span>, tool)<br>fmt.Printf(<span class="hljs-string">&quot;args: %v\n&quot;</span>, args)<br>&#125;<br><span class="hljs-comment">// 继续执行之前的命令</span><br>cmd := exec.Command(tool, args...)<br>cmd.Stdout = os.Stdout<br>cmd.Stderr = os.Stderr<br><br><span class="hljs-keyword">if</span> err := cmd.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;run command error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findGreetFile</span><span class="hljs-params">(args []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br><span class="hljs-keyword">if</span> strings.Contains(arg, <span class="hljs-string">&quot;greet.go&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-keyword">var</span> newCode = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func Greet(s string) (res string) &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;Greet&quot;, s, &amp;res) &#123;</span><br><span class="hljs-string"> return res</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">return &quot;hello &quot; + s</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这里我先使用 <code>findGreetFile</code> 来查找 <code>greet.go</code>文件所处的参数位置，如果找到了，则生成新的 <code>tmp.go</code>文件，并替换参数，最后在 本次 <code>compile</code> 命令执行完毕后，删除<code>tmp.go</code>，“毁尸灭迹”。</p><p>执行 <code>./script.sh</code> 重新编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ✗ ./script.sh<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/compile<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/_pkg_.a -trimpath <span class="hljs-variable">$WORK</span>/b001=&gt; -p main -lang=go1.22 -complete -buildid PcS9clqF_ny_Ds5N0i_s/PcS9clqF_ny_Ds5N0i_s -goversion go1.22.3 -c=4 -shared -nolocalimports -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg -pack tmp.go ./main.go ./mock.go]<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/link<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/exe/a.out -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg.link -buildmode=pie -buildid=KgnnCoU_6enHkOm-T62Z/PcS9clqF_ny_Ds5N0i_s/H80dtgGZw1L8mTtVqJBf/KgnnCoU_6enHkOm-T62Z -extld=cc <span class="hljs-variable">$WORK</span>/b001/_pkg_.a]<br></code></pre></td></tr></table></figure><p>输出的结果中可以看到已经将 <code>compile</code> 的参数替换为<code>-pack tmp.go ./main.go ./mock.go</code> 了。</p><p>现在我们来执行生成的程序文件，可以看到是执行成功的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ✗ ./main<br>2024/05/23 17:53:52 run successfully<br></code></pre></td></tr></table></figure><p>如果我们不使用 <code>-toolexec</code>，是执行不成功的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ✗ go clean -cache -modcache -i -r<br>➜  03-toolexec-static git:(master) ✗ go build -o main<br>➜  03-toolexec-static git:(master) ✗ ./main<br>2024/05/23 17:54:33 Greet() = <span class="hljs-string">&quot;hello world&quot;</span>; want <span class="hljs-string">&quot;mock world&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第-4-步使用-ast-在函数前插入代码">第 4 步：使用 AST在函数前插入代码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  04-toolexec-ast git:(master) ✗ tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>暴力替换源代码文件的方式可能是不太优雅哈，假如我们的<code>greet.go</code> 内容改成下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet2</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 2 &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想对 <code>Greet2</code> 也进行<strong>代码重写</strong>，那就需要修改前面 <code>newCode</code>字段的内容，而且它是写死的，确实不太优雅。现在我们正式来面对这件事，对比修改后的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br> <span class="hljs-keyword">return</span> res<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是在每个函数前加上这么一段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>了解过编译原理的读者应该可以想到，我们可以通过操作源代码的 AST结构，往函数的开头插入这段代码即可。如果我们先不考虑参数和返回值的话，那这段代码我们需要替换的地方就是函数名称了，所以它的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;$&#123;funcName&#125;&quot;</span>, s, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们需要用到几个标准库工具：</p><ul><li><code>go/ast</code>: 包定义了 Go编程语言的抽象语法树（AST），核心有以下几种类型：<ul><li><code>File</code>: 表示一个 Go 源文件。</li><li><code>Decl</code>:表示一个声明，包括函数声明、变量声明、类型声明等。</li><li><code>Stmt</code>: 表示一个语句。</li><li><code>Expr</code>: 表示一个表达式。</li></ul></li><li><code>go/token</code>: 定义了处理 Go源代码的词法元素的基础设施，包括位置、标记和标识符等。这个包提供了用于管理源代码位置的信息，可以帮助定位代码中的特定部分。</li><li><code>go/parser</code>: 将一个 <code>.go</code> 文件以解析成 AST结构。</li><li><code>go/printer</code>: 提供了将 AST 格式化并输出为 Go源码的功能</li></ul><p>修改后的 <code>cmd/mytool/mytool.go</code> 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tool, args := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>:]<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;-V=full&quot;</span> &#123;<br><span class="hljs-comment">// don&#x27;t do anything to infuence the version full output.</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> filepath.Base(tool) == <span class="hljs-string">&quot;compile&quot;</span> &#123;<br>index := findGreetFile(args)<br><span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">-1</span> &#123;<br>filename := args[index]<br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()<br><span class="hljs-keyword">defer</span> os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(insertCode(filename))<br>args[index] = <span class="hljs-string">&quot;tmp.go&quot;</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;tool: %s\n&quot;</span>, tool)<br>fmt.Printf(<span class="hljs-string">&quot;args: %v\n&quot;</span>, args)<br>&#125;<br><span class="hljs-comment">// 继续执行之前的命令</span><br>cmd := exec.Command(tool, args...)<br>cmd.Stdout = os.Stdout<br>cmd.Stderr = os.Stderr<br><br><span class="hljs-keyword">if</span> err := cmd.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;run command error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findGreetFile</span><span class="hljs-params">(args []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br><span class="hljs-keyword">if</span> strings.Contains(arg, <span class="hljs-string">&quot;greet.go&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertCode</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fset := token.NewFileSet()<br>fast, err := parser.ParseFile(fset, filename, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse file error: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, decl := <span class="hljs-keyword">range</span> fast.Decls &#123;<br>fun, ok := decl.(*ast.FuncDecl)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>f, err := os.Create(<span class="hljs-string">&quot;tmp2.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp2.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(fmt.Sprintf(newCodeFormat, fun.Name.Name))<br>f.Close()<br><br>tmpFset := token.NewFileSet()<br>tmpF, err := parser.ParseFile(tmpFset, <span class="hljs-string">&quot;tmp2.go&quot;</span>, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse tmp2.go error: %v\n&quot;</span>, err)<br>&#125;<br>fun.Body.List = <span class="hljs-built_in">append</span>(tmpF.Decls[<span class="hljs-number">0</span>].(*ast.FuncDecl).Body.List, fun.Body.List...)<br>os.Remove(<span class="hljs-string">&quot;tmp2.go&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>printer.Fprint(&amp;buf, fset, fast)<br><br>fmt.Println(buf.String())<br><br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, s, &amp;res) &#123;</span><br><span class="hljs-string"> return res</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>核心的修改在于 <code>insertCode</code> 函数：</p><ol type="1"><li><p>使用 <code>parser.ParseFile</code> 将源代码文件解析成 AST结构；</p></li><li><p>遍历 AST 结构，找到所有的声明（Decl）结构，并使用<code>decl(.ast.FuncDecl)</code> 找到所有的函数；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">FuncDecl <span class="hljs-keyword">struct</span> &#123;<br>  Doc  *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span><br>  Recv *FieldList    <span class="hljs-comment">// receiver (methods); or nil (functions)</span><br>  Name *Ident        <span class="hljs-comment">// function/method name</span><br>  Type *FuncType     <span class="hljs-comment">// function signature: type and value parameters, results, and position of &quot;func&quot; keyword</span><br>  Body *BlockStmt    <span class="hljs-comment">// function body; or nil for external (non-Go) function</span><br>&#125;<br><br>BlockStmt <span class="hljs-keyword">struct</span> &#123;<br>  Lbrace token.Pos <span class="hljs-comment">// position of &quot;&#123;&quot;</span><br>  List   []Stmt<br>  Rbrace token.Pos <span class="hljs-comment">// position of &quot;&#125;&quot;, if any (may be absent due to syntax error)</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查看 <code>ast.FuncDecl</code> 的结构后，可以得出下一步就是往<code>FuncDecl.Body.List</code> 列表前面插入一些<code>Stmt</code>；</p></li><li><p>笔者没找到类似 <code>parseStmt</code>方法，所以取了个巧，我定义了一段代码的 <code>format</code>，里面的<code>%s</code> 会使用 <code>fun.Name.Name</code>获取函数名并进行替换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, s, &amp;res) &#123;</span><br><span class="hljs-string"> return res</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure></li><li><p>创建一个临时文件 <code>tmp2.go</code>并写入格式化后的代码，然后再次调用 <code>parser.ParseFile</code>得到解析这段代码的抽象语法树结构 <code>tmpF</code> 了；</p></li><li><p>然后通过 <code>tmpF.Decls[0].(*ast.FuncDecl).Body.List</code>就可以得到 <code>TmpFunc</code> 中的语句 <code>Stmt</code> 了；</p></li><li><p>将其加在源代码函数的前面即可：<code>fun.Body.List = append(tmpF.Decls[0].(*ast.FuncDecl).Body.List, fun.Body.List...)</code>；</p></li><li><p>然后再使用 <code>go/printer</code> 将修改后的 AST输出为新文件内容。</p></li></ol><p>通过上述步骤，我们就可以为 <code>greet.go</code>中的每个函数前面都插入打桩代码了。</p><p>修改 <code>main.go</code> 里面的内容，加入对 <code>Greet2</code>的测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s<br>&#125;)<br>res = Greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet2() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 2 successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>输出应该还是跟之前是一样的，我们运行生成的可执行函数，得到如下结果那就说明我们又成功进了一步了~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  04-toolexec-ast git:(master) ✗ ./main<br>2024/05/23 20:03:22 run greet 1 successfully<br>2024/05/23 20:03:22 run greet 2 successfully<br></code></pre></td></tr></table></figure><h1 id="第-5-步使用-reflect-反射动态获取参数和返回值名称">第 5 步：使用reflect 反射动态获取参数和返回值名称</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  05-toolexec-general git:(master) ✗ tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>接下来我们来处理函数签名中的参数和返回值部分，我们的样板代码中，写死了参数的名称和返回值的名称，现在我们需要来动态获取函数参数的名称和返回值的名称，如果返回值没有名称，那我们还需要手动设置名称。</p><p>我们将 <code>greet.to</code> 修改为以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet2</span><span class="hljs-params">(s2 <span class="hljs-type">string</span>)</span></span> (res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 2 &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet3</span><span class="hljs-params">(s3 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 3 &quot;</span> + s3<br>&#125;<br></code></pre></td></tr></table></figure><p>函数的信息当然都在前面获得的 <code>ast.FuncDecl</code>结构中，再次观察其结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">FuncDecl <span class="hljs-keyword">struct</span> &#123;<br>Doc  *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span><br>Recv *FieldList    <span class="hljs-comment">// receiver (methods); or nil (functions)</span><br>Name *Ident        <span class="hljs-comment">// function/method name</span><br>Type *FuncType     <span class="hljs-comment">// function signature: type and value parameters, results, and position of &quot;func&quot; keyword</span><br>Body *BlockStmt    <span class="hljs-comment">// function body; or nil for external (non-Go) function</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过注释就可以知道 <code>Type</code>字段就包含了参数和返回值的相关信息，查看 <code>FuncType</code>结构，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">FuncType <span class="hljs-keyword">struct</span> &#123;<br>  Func       token.Pos  <span class="hljs-comment">// position of &quot;func&quot; keyword (token.NoPos if there is no &quot;func&quot;)</span><br>  TypeParams *FieldList <span class="hljs-comment">// type parameters; or nil</span><br>  Params     *FieldList <span class="hljs-comment">// (incoming) parameters; non-nil</span><br>  Results    *FieldList <span class="hljs-comment">// (outgoing) results; or nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Params</code>：函数参数</li><li><code>Results</code>：函数返回值</li></ul><p>查看 <code>FieldList</code> 结构，可知参数列表和返回值列表都在相应的<code>List</code> 字段中，而其中的 <code>Names</code>字段就是参数的名称了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FieldList <span class="hljs-keyword">struct</span> &#123;<br>Opening token.Pos <span class="hljs-comment">// position of opening parenthesis/brace/bracket, if any</span><br>List    []*Field  <span class="hljs-comment">// field list; or nil</span><br>Closing token.Pos <span class="hljs-comment">// position of closing parenthesis/brace/bracket, if any</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Field <span class="hljs-keyword">struct</span> &#123;<br>Doc     *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span><br>Names   []*Ident      <span class="hljs-comment">// field/method/(type) parameter names; or nil</span><br>Type    Expr          <span class="hljs-comment">// field/method/parameter type; or nil</span><br>Tag     *BasicLit     <span class="hljs-comment">// field tag; or nil</span><br>Comment *CommentGroup <span class="hljs-comment">// line comments; or nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>补充一下，这里为什么 <code>Names</code> 类型是 <code>[]*Ident</code>呢？因为函数有以下的命名方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (r1, r1 <span class="hljs-type">string</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>那么在当下，只有 1 个参数和只有 1 个返回值的情况下，我们就可以通过<code>fun.Type.Params.List[0].Names[0].Name</code>来获取参数名称，也可以通过 <code>fun.Type.Results.List[0].Names</code>来获取返回值名称，如果返回值没有名称，那我们就为其设置名称<code>__xgo_res_1</code> 并写回源 AST结构。这样就都有名称，就很好处理了。</p><p>经上分析， <code>cmd/mytool/mytool.go</code> 中我们只需要修改<code>insertCode</code> 部分，修改的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertCode</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fset := token.NewFileSet()<br>fast, err := parser.ParseFile(fset, filename, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse file error: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, decl := <span class="hljs-keyword">range</span> fast.Decls &#123;<br>fun, ok := decl.(*ast.FuncDecl)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(newCode(fun))<br>f.Close()<br><br>tmpFset := token.NewFileSet()<br>tmpF, err := parser.ParseFile(tmpFset, <span class="hljs-string">&quot;tmp.go&quot;</span>, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>fun.Body.List = <span class="hljs-built_in">append</span>(tmpF.Decls[<span class="hljs-number">0</span>].(*ast.FuncDecl).Body.List, fun.Body.List...)<br>os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>printer.Fprint(&amp;buf, fset, fast)<br><br>fmt.Println(buf.String())<br><br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCode</span><span class="hljs-params">(fun *ast.FuncDecl)</span></span> <span class="hljs-type">string</span> &#123;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[s] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[res] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[s2] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[res2] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[s3] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 函数名称</span><br>funcName := fun.Name.Name<br><br><span class="hljs-comment">// 参数列表</span><br>argName := fun.Type.Params.List[<span class="hljs-number">0</span>].Names[<span class="hljs-number">0</span>].Name<br><br><span class="hljs-comment">// 返回值列表</span><br>resNames := fun.Type.Results.List[<span class="hljs-number">0</span>].Names<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(resNames) == <span class="hljs-number">0</span> &#123;<br>resNames = <span class="hljs-built_in">append</span>(resNames, &amp;ast.Ident&#123;Name: <span class="hljs-string">&quot;_xgo_res_1&quot;</span>&#125;)<br>fun.Type.Results.List[<span class="hljs-number">0</span>].Names = resNames<br>&#125;<br>resName := resNames[<span class="hljs-number">0</span>].Name<br><span class="hljs-keyword">return</span> fmt.Sprintf(newCodeFormat, funcName, argName, resName, resName)<br>&#125;<br><br><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, %s, &amp;%s) &#123;</span><br><span class="hljs-string"> return %s</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>现在我们就可以动态获取参数名称和返回值名称了。</p><p>修改我们的 <code>main.go</code>，以测试所有的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s<br>&#125;)<br>res = Greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet2() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 2 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 3 &quot;</span> + s<br>&#125;)<br>res = Greet3(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 3 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet3() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 3 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 3 successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行编译脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>执行编译产生的可执行程序，输出如下就说明我们又成功进了一大步~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  05-toolexec-general git:(master) ✗ ./main<br>2024/05/23 20:15:08 run greet 1 successfully<br>2024/05/23 20:15:08 run greet 2 successfully<br>2024/05/23 20:15:08 run greet 3 successfully<br></code></pre></td></tr></table></figure><h1 id="第-6-步支持多参数和多返回值">第 6 步：支持多参数和多返回值</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  06-toolexec-multi git:(master) ✗ tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>本文的最后一步，我们来面对一下多参数和多返回值的问题。假设我们又如下函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair1</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候我们 <strong>代码重写</strong>后应该长什么样子呢？可以是下面这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair1</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Pair1&quot;</span>, s1, s2, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>按照这个思路，下面这个函数呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>那就是这样的？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Pair2&quot;</span>, s1, s2, &amp;res1, &amp;res2) &#123;<br><span class="hljs-keyword">return</span> res1, res2<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>这种思路当然也能实现，换一种更优雅的思路呢？既然是一个列表，那么就可以用切片来承载，也就是可以是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Pair2&quot;</span>, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;s1, s2&#125;, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&amp;res1, &amp;res2&#125;) &#123;<br><span class="hljs-keyword">return</span> res1, res2<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>那我们就可以抽象出插入代码的模板了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;$&#123;funcName&#125;&quot;</span>, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;$&#123;paramList&#125;&#125;, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;$&#123;returnListWith&amp;&#125;&#125;) &#123;<br>  <span class="hljs-keyword">return</span> $&#123;returnListWithout&amp;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了实现这个，我们需要先修改一下 <code>mock.go</code> 中的<code>InterceptMock</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InterceptMock</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>, args []<span class="hljs-keyword">interface</span>&#123;&#125;, results []<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>mockFn, ok := mockFuncs.Load(funcName)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><br>in := <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-built_in">len</span>(args))<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br>in[i] = reflect.ValueOf(arg)<br>&#125;<br><br>  mockFnValue := reflect.ValueOf(mockFn)<br>out := mockFnValue.Call(in)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(out) != <span class="hljs-built_in">len</span>(results) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;mock function return value number is not equal to results number&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> i, result := <span class="hljs-keyword">range</span> results &#123;<br>reflect.ValueOf(result).Elem().Set(out[i])<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器的具体实现如下：</p><ol type="1"><li>判断是否注册了 mock 函数，没有则直接返回；</li><li>将所有参数都放到 <code>[]refect.Value</code> 中；</li><li>通过反射 <code>refect.ValueOf</code> 获取 mockFn 的值；</li><li>调用 <code>mockFnValue.Call()</code>来执行函数，并返回结果列表；</li><li>遍历传进来的返回值引用列表，调用<code>reflect.ValueOf(result).Elem().Set(out[i])</code>将返回值设置回去。</li></ol><p>现在我们来修改我们的 <code>-toolexec</code> 工具，来根据函数的 AST结构，获取参数列表和返回值列表，生成代插入的模板代码，并将其插入到每个函数的开头。这次在<code>cmd/mytool/mytool.go</code> 中，我们只需修改 <code>newCode</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertCode</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fset := token.NewFileSet()<br>fast, err := parser.ParseFile(fset, filename, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse file error: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, decl := <span class="hljs-keyword">range</span> fast.Decls &#123;<br>fun, ok := decl.(*ast.FuncDecl)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(newCode(fun))<br>f.Close()<br><br>tmpFset := token.NewFileSet()<br>tmpF, err := parser.ParseFile(tmpFset, <span class="hljs-string">&quot;tmp.go&quot;</span>, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>fun.Body.List = <span class="hljs-built_in">append</span>(tmpF.Decls[<span class="hljs-number">0</span>].(*ast.FuncDecl).Body.List, fun.Body.List...)<br>os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>printer.Fprint(&amp;buf, fset, fast)<br><br>fmt.Println(buf.String())<br><br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCode</span><span class="hljs-params">(fun *ast.FuncDecl)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// 函数名称</span><br>funcName := fun.Name.Name<br><br><span class="hljs-comment">// 参数列表</span><br>args := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> fun.Type.Params.List &#123;<br><span class="hljs-keyword">for</span> _, name := <span class="hljs-keyword">range</span> arg.Names &#123;<br>args = <span class="hljs-built_in">append</span>(args, name.Name)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 返回值列表</span><br>returns := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>returnRefs := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>returnNames := fun.Type.Results.List[<span class="hljs-number">0</span>].Names<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(returnNames) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; fun.Type.Results.NumFields(); i++ &#123;<br>fun.Type.Results.List[<span class="hljs-number">0</span>].Names = <span class="hljs-built_in">append</span>(fun.Type.Results.List[<span class="hljs-number">0</span>].Names,<br>&amp;ast.Ident&#123;Name: fmt.Sprintf(<span class="hljs-string">&quot;_xgo_res_%d&quot;</span>, i+<span class="hljs-number">1</span>)&#125;)<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> _, re := <span class="hljs-keyword">range</span> fun.Type.Results.List[<span class="hljs-number">0</span>].Names &#123;<br>returns = <span class="hljs-built_in">append</span>(returns, re.Name)<br>returnRefs = <span class="hljs-built_in">append</span>(returnRefs, <span class="hljs-string">&quot;&amp;&quot;</span>+re.Name)<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(newCodeFormat,<br>funcName,<br>strings.Join(args, <span class="hljs-string">&quot;,&quot;</span>),<br>strings.Join(returnRefs, <span class="hljs-string">&quot;,&quot;</span>),<br>strings.Join(returns, <span class="hljs-string">&quot;,&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, []interface&#123;&#125;&#123;%s&#125;, []interface&#123;&#125;&#123;%s&#125;) &#123;</span><br><span class="hljs-string">return %s</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>思路跟之前第 5步大同小异，不过是用遍历的方式来支持多个参数和多个返回值罢了。</p><p>现在我们为 <code>greet.go</code> 添加更多的测试函数，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet2</span><span class="hljs-params">(s2 <span class="hljs-type">string</span>)</span></span> (res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 2 &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet3</span><span class="hljs-params">(s3 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 3 &quot;</span> + s3<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair1</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Other</span><span class="hljs-params">(i <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, f <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;int: %d, string: %s, float: %f&quot;</span>, i, s, f)<br>&#125;<br></code></pre></td></tr></table></figure><p>为了测试，我们再次修改 <code>main.go</code>，使其覆盖所有的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Other&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, f <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;mock %d %s %.2f&quot;</span>, i, s, f)<br>&#125;)<br>res := Other(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">3.14</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 1 hello 3.14&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Other() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 1 hello 3.14&quot;</span>)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;run other successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Pair1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;)<br>res = Pair1(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 1 hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Pair1() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 1 hello world&quot;</span>)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;run pair1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Pair2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s1, <span class="hljs-string">&quot;mock 2 &quot;</span> + s2<br>&#125;)<br>res1, res2 := Pair2(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res1 != <span class="hljs-string">&quot;mock 2 hello&quot;</span> || res2 != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Pair2() = %q, %q; want %q, %q&quot;</span>, res1, res2, <span class="hljs-string">&quot;mock 2 hello&quot;</span>, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;run pair2 successfully&quot;</span>)<br><br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s<br>&#125;)<br>res = Greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet2() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 2 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 3 &quot;</span> + s<br>&#125;)<br>res = Greet3(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 3 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet3() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 3 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 3 successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>编译代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>执行生成的可执行程序，如果有以下输出，那我们就又成功进了一大大步了~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  06-toolexec-multi git:(master) ✗ ./main<br>2024/05/23 20:31:10 run other successfully<br>2024/05/23 20:31:10 run pair1 successfully<br>2024/05/23 20:31:10 run pair2 successfully<br>2024/05/23 20:31:10 run greet 1 successfully<br>2024/05/23 20:31:10 run greet 2 successfully<br>2024/05/23 20:31:10 run greet 3 successfully<br></code></pre></td></tr></table></figure><h1 id="更进一步">更进一步</h1><p>通过上面 6 个简单的小阶段，我们就已经把 <code>xgo</code>最最核心的功能给实现了，在一些小场景下还勉强能用？🤡</p><p>我们来看看包含测试代码和样例函数，总共用了多少代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  06-toolexec-multi git:(master) ✗ tokei .<br>===============================================================================<br> Language            Files        Lines         Code     Comments       Blanks<br>===============================================================================<br> Go                      4          281          224           11           46<br> Shell                   1            5            3            1            1<br>===============================================================================<br> Total                   5          286          227           12           47<br>===============================================================================<br></code></pre></td></tr></table></figure><p>短短 <strong>224</strong> 行代码，这是一个非常了不起的成就！</p><p>当然，优秀的读者肯定可以发现我们这个 <strong>丐版 xgo</strong>有太多的不足和缺陷了。这是必然的，我们来看看 <code>xgo</code> 截止<code>1.0.37</code> 版本，总共有多少行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">➜  xgo git:(master) tokei .<br>===============================================================================<br> Language            Files        Lines         Code     Comments       Blanks<br>===============================================================================<br> BASH                    <span class="hljs-number">1</span>          <span class="hljs-number">104</span>           <span class="hljs-number">81</span>           <span class="hljs-number">11</span>           <span class="hljs-number">12</span><br> CSS                     <span class="hljs-number">1</span>          <span class="hljs-number">153</span>          <span class="hljs-number">118</span>            <span class="hljs-number">5</span>           <span class="hljs-number">30</span><br> Go                    <span class="hljs-number">369</span>        <span class="hljs-number">33232</span>        <span class="hljs-number">26836</span>         <span class="hljs-number">2588</span>         <span class="hljs-number">3808</span><br> JavaScript              <span class="hljs-number">1</span>          <span class="hljs-number">170</span>          <span class="hljs-number">146</span>           <span class="hljs-number">10</span>           <span class="hljs-number">14</span><br> JSON                    <span class="hljs-number">2</span>          <span class="hljs-number">435</span>          <span class="hljs-number">435</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> PowerShell              <span class="hljs-number">1</span>           <span class="hljs-number">28</span>           <span class="hljs-number">16</span>            <span class="hljs-number">3</span>            <span class="hljs-number">9</span><br> Shell                   <span class="hljs-number">3</span>          <span class="hljs-number">288</span>          <span class="hljs-number">251</span>            <span class="hljs-number">4</span>           <span class="hljs-number">33</span><br> SVG                     <span class="hljs-number">1</span>           <span class="hljs-number">41</span>           <span class="hljs-number">41</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> Plain Text              <span class="hljs-number">7</span>          <span class="hljs-number">192</span>            <span class="hljs-number">0</span>          <span class="hljs-number">174</span>           <span class="hljs-number">18</span><br>-------------------------------------------------------------------------------<br> HTML                    <span class="hljs-number">1</span>           <span class="hljs-number">19</span>           <span class="hljs-number">16</span>            <span class="hljs-number">3</span>            <span class="hljs-number">0</span><br> |- JavaScript           <span class="hljs-number">1</span>            <span class="hljs-number">6</span>            <span class="hljs-number">6</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> (Total)                             <span class="hljs-number">25</span>           <span class="hljs-number">22</span>            <span class="hljs-number">3</span>            <span class="hljs-number">0</span><br>-------------------------------------------------------------------------------<br> Markdown               <span class="hljs-number">17</span>         <span class="hljs-number">1455</span>            <span class="hljs-number">0</span>         <span class="hljs-number">1083</span>          <span class="hljs-number">372</span><br> |- Go                   <span class="hljs-number">8</span>          <span class="hljs-number">820</span>          <span class="hljs-number">635</span>           <span class="hljs-number">72</span>          <span class="hljs-number">113</span><br> |- JSON                 <span class="hljs-number">1</span>           <span class="hljs-number">80</span>           <span class="hljs-number">80</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> (Total)                           <span class="hljs-number">2355</span>          <span class="hljs-number">715</span>         <span class="hljs-number">1155</span>          <span class="hljs-number">485</span><br>===============================================================================<br> Total                 <span class="hljs-number">404</span>        <span class="hljs-number">36117</span>        <span class="hljs-number">27940</span>         <span class="hljs-number">3881</span>         <span class="hljs-number">4296</span><br>===============================================================================<br></code></pre></td></tr></table></figure><p>光 Go 代码就有 <strong>26836</strong> 行了。所以可知 <code>xgo</code>的作者是做了很多的付出和努力的。不过我们用了不到百分之一的代码量，就将<code>xgo</code>最核心的原理展示得淋漓尽致了，感兴趣的读者可以进一步阅读<code>xgo</code> 的源码，可以进一步探索如何抽象出更通用更简洁更易扩展的interceptor，如何支持协程隔离，如何优化依赖管理，以及如何实现其他的trace、coverage 功能。再次为 <code>xgo</code> 打 call 👏！</p><h1 id="参考">参考</h1><ul><li><a href="https://github.com/xhd2015/xgo">xgo repo</a></li><li><ahref="https://docs.google.com/presentation/d/1U5yTdrUjnManxztzsMPGBAePrE3HvJcDtRjV6h3HelA/edit#slide=id.g2705943ae25_0_50">xgo:基于代码重写实现 Monkey Patch 和 Trace</a></li><li><ahref="https://github.com/golang/go/tree/release-branch.go1.22/src/cmd/compile">gocompile README</a></li><li><ahref="https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/">xgo:在 go 中使用-toolexec 实现猴子补丁</a></li></ul>]]></content>
    
    
    <summary type="html">xgo 是一个通过代码重写来实现 mock、trace 和 coverage 功能的单元测试框架。本文将探讨 xgo 最核心的底层原理 -toolexec，并通过 6 个简单的小阶段，一步步实现一个丐版 xgo，进一步展示 xgo 的设计理念。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="开源项目" scheme="https://hedon.top/categories/Go/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="开源项目" scheme="https://hedon.top/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>xgo 使用经验</title>
    <link href="https://hedon.top/2024/05/21/go-xgo-use/"/>
    <id>https://hedon.top/2024/05/21/go-xgo-use/</id>
    <published>2024-05-21T08:32:51.000Z</published>
    <updated>2024-05-21T11:58:06.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="patch">Patch</h1><h2 id="mock-函数">mock 函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPatchFunc</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.Patch(greet, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br><br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced mock world got %s&quot;</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mock-变量">mock 变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> value = <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> value + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPatchVar</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.Patch(&amp;value, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span><br>&#125;)<br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced mock world got %s&quot;</span>, res)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPatchVarByName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.PatchByName(<span class="hljs-string">&quot;learn-xgo/api&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span><br>&#125;)<br>res := greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced mock world got %s&quot;</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="mock">Mock</h1><blockquote><p>因此，当函数含有未导出类型时，<code>Patch</code>无法使用，此时可以使用 <code>Mock</code>。</p></blockquote><h2 id="mockbyname">MockByName</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// learn-xgo/funcs/funcs.go</span><br><span class="hljs-keyword">package</span> funcs<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CallUnexportedFunc</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> unexportedFunc(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unexportedFunc</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;origin unexported func, your msg is &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// learn-xgo/api/mock_test.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMockByName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.MockByName(<span class="hljs-string">&quot;learn-xgo/funcs&quot;</span>, <span class="hljs-string">&quot;unexportedFunc&quot;</span>,<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, fn *core.FuncInfo, args core.Object, results core.Object)</span></span> <span class="hljs-type">error</span> &#123;<br>results.GetFieldIndex(<span class="hljs-number">0</span>).Set(<span class="hljs-string">&quot;mock funcs &quot;</span> + args.GetFieldIndex(<span class="hljs-number">0</span>).Value().(<span class="hljs-type">string</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><br>msg := funcs.CallUnexportedFunc(<span class="hljs-string">&quot;hedon&quot;</span>)<br><span class="hljs-keyword">if</span> msg != <span class="hljs-string">&quot;mock funcs hedon&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced `mock funcs hedon` got %s&quot;</span>, msg)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">x</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="开源项目" scheme="https://hedon.top/categories/Go/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="开源项目" scheme="https://hedon.top/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 负载均衡挑战及解决思路</title>
    <link href="https://hedon.top/2024/05/20/kafka-load-balance/"/>
    <id>https://hedon.top/2024/05/20/kafka-load-balance/</id>
    <published>2024-05-20T02:37:10.000Z</published>
    <updated>2024-05-20T08:15:56.804Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自 Agoda Engineering，介绍了在实际应用中，如何应对 Kafka负载均衡所遇到的各种挑战，并提出相应的解决思路。本文简要阐述了 Kafka的并行性机制、常用的分区策略以及在实际操作中遇到的异构硬件、不均匀工作负载等问题。通过深入分析这些挑战，并提供具体的解决方案，本文旨在帮助读者更好地理解和应用Kafka 的负载均衡技术，从而提高系统的整体性能和稳定性。</p><p>以下大部分内容翻译自原文 <ahref="https://medium.com/agoda-engineering/how-we-solve-load-balancing-challenges-in-apache-kafka-8cd88fdad02b">how-we-solve-load-balancing-challenges-in-apache-kafka</a>，并已获得原作者同意。</p><h1 id="思维导图">思维导图</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Kafka%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"alt="Kafka 负载均衡解决方案" /><figcaption aria-hidden="true">Kafka 负载均衡解决方案</figcaption></figure><h1 id="kafka-并行性">Kafka 并行性</h1><p>Kafka通过分区来实现并行性，如下图所示，生产者（Producer）产生的消息会按照一定的分区策略分配到多个分区（Partition）中，消费组中的每个消费者会分别负责消费其中的若干个分区。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*ixosAmhBDsyBBhoS.png"alt="Kafka 分区演示" /><figcaption aria-hidden="true">Kafka 分区演示</figcaption></figure><p>分区策略：</p><ul><li>轮询（Round Robin）：默认情况下，Kafka使用轮询策略将消息均匀地分配到所有分区。</li><li>哈希（Key Hashing）：如果消息有分区键，Kafka会对键进行哈希计算，将消息分配到特定的分区。</li><li>自定义分区策略：开发者可以实现自定义的分区器（Partitioner）逻辑，以满足特定需求。</li></ul><p>如果要使用轮询或者哈希策略来达到“负载均衡”的目的，那么需要满足以下 2个假设：</p><ol type="1"><li>消费者拥有相同的处理能力，</li><li>消息的工作量相等。</li></ol><p>然而，在实践中，这些假设往往不成立。</p><h1 id="现实挑战">现实挑战</h1><h2 id="异构硬件">1. 异构硬件</h2><p>不同代的服务器硬件性能不同，导致处理速率存在差异。例如，使用不同代硬件进行处理的基准显示性能存在显着差异：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1*B6svY0ZjYVy-uJ7ZA18Jtg.png"alt="不同服务器处理速率差异举例" /><figcaption aria-hidden="true">不同服务器处理速率差异举例</figcaption></figure><h2 id="每条-kafka-消息的工作负载不均匀">2. 每条 Kafka消息的工作负载不均匀</h2><p>下图显示了在一个时间窗口内到达的 12条消息。在这里，生产者向该主题中的六个分区中的每一个发布两条消息。因此，每个worker 消耗来自 2 个分区的数据，这意味着每个 worker 需要处理 4条消息。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*VwPda5gNsHRL2tJV.png"alt="使用循环分区器和循环分配器来分发消息的先前供应系统的演示。每个 worker 都分配有相同数量的消息。" /><figcaptionaria-hidden="true">使用循环分区器和循环分配器来分发消息的先前供应系统的演示。每个worker 都分配有相同数量的消息。</figcaption></figure><p>不同的消息可能需要不同的处理步骤集。例如，处理消息可能涉及调用第三方HTTP端点，并且不同的响应大小或延迟可能会影响处理速率。此外，对于涉及数据库操作的应用程序，其数据库查询的延迟可能会根据查询参数而波动，从而导致处理速率发生变化。</p><h2 id="过度配置问题">3. 过度配置问题</h2><p>由于工作负载和处理效率不同，为了达到系统吞吐量的需求，可能会出现过度配置问题，从而导致资源浪费。</p><p>假设我们的高吞吐量和低吞吐量的处理速率分别为 20 msg/s 和 10msg/s（根据表 1中的数据进行简化）。使用两个较快的处理器和一个较慢的处理器，我们预计总容量为20+20+10 = 50条消息/秒。但是，当保持消息的循环分配时，我们无法达到此容量。下图显示了如果流量持续达到每秒50 条消息时会发生什么情况。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*P-Qa3gyPgXtIeZMx.png"alt="如果传入流量保持在 50 条消息/秒，则慢速处理器无法处理总体消息 1/3 的负载，从而导致累积延迟。为了避免高延迟，向该系统添加了额外的资源以维持处理。" /><figcaption aria-hidden="true">如果传入流量保持在 50条消息/秒，则慢速处理器无法处理总体消息 1/3的负载，从而导致累积延迟。为了避免高延迟，向该系统添加了额外的资源以维持处理。</figcaption></figure><p>从这个例子中我们可以看到，我们的处理器服务一次最多只能接受 30条消息，以防止滞后并确保及时传递更新。</p><p>在这种情况下，要实际每秒处理 50 条消息，我们必须总共扩展到 5台机器，以保证及时处理所有消息。由于这种不适当的分配逻辑（66.7％的过度配置），我们会向该系统过度配置额外的两台机器。</p><p>为了每秒处理 50条消息，我们需要扩展到五台机器以确保及时处理所有消息。由于这种不适当的分配逻辑（66.7%的过度配置），这会导致向该系统过度配置两台额外的机器。</p><h1 id="静态解决方案">静态解决方案</h1><h2 id="在相同的-pod机器上部署">1. 在相同的 Pod（机器）上部署</h2><p>考虑控制服务部署中使用的硬件类型以缓解问题。如果您在虚拟机上部署服务并拥有充足的资源和性能相同的硬件，则此方法是可行的。</p><p>然而，由于成本效益和灵活性下降，在私有云环境中通常不建议采用这种策略，主要是因为同时升级所有现有硬件可能具有挑战性。如果它非常适合您的情况，则可以使用<ahref="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/">Kubernetes关联性将 Pod 分配给某些类型的节点。</a></p><h2 id="加权负载均衡">2. 加权负载均衡</h2><p>如果容量是可预测的并且大部分时间保持静态，则为不同的消费者分配不同的权重可以帮助最大限度地利用可用资源。例如，在为表现较好的消费者赋予更高的权重后，我们可以将更多流量路由给这些消费者。</p><h1 id="动态解决方案">动态解决方案</h1><p>虽然我们可以估计消息的容量和工作负载来设计静态规则来确定加权负载平衡策略，但由于以下几个因素，这种方法在实际生产环境中可能并不总是可行：</p><ul><li>消息的工作负载并不统一，这使得估计机器容量变得困难。</li><li>依赖关系（例如网络和第三方连接）不稳定，有时会导致实际处理中的容量发生变化。</li><li>该系统经常添加新功能，增加额外的维护工作以保持权重更新。</li></ul><p>为了解决这些问题，我们可以动态监控每个分区中的当前滞后并根据当前流量状况做出相应响应。</p><p>有 2 种思路：</p><ol type="1"><li><strong>生产者角度</strong>：使用自定义算法根据滞后的消息数量来确定每个分区的流量，这种生产者称为滞后感知生产者（Lag-awareProducer）。</li><li><strong>消费者角度</strong>：这些消费者旨在监控当前滞后的消息数量，并可以在必要时取消订阅以触发负载重新平衡。通常，可以采用自定义的重新平衡策略来调整分区分配。这种消费者称为滞后感知消费者（Lag-awareComsumer）。</li></ol><h2 id="从生产者角度出发">1. 从生产者角度出发</h2><p>如此图所示，生产者可以使用自定义算法根据滞后确定每个分区的流量。为了减少对Kafka代理的调用次数，系统可以维护一个内部延迟缓存，而不是在发布每条消息之前调用Kafka 代理。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*Mg1lxKzMTy7LRAXT.png"alt="在此示例中，分区 4 和 6 的延迟比其他分区高得多。应减少从内部生产者发送到这些分区的流量。" /><figcaption aria-hidden="true">在此示例中，分区 4 和 6的延迟比其他分区高得多。应减少从内部生产者发送到这些分区的流量。</figcaption></figure><p>使用滞后数据，定制的算法被设计为向经历高滞后的分区发布更少的流量，向低滞后的分区发布更多流量，以平衡每个分区上的工作负载。当滞后平衡且稳定时，此方法应确保消息的均匀分布。</p><p>不适用情况：</p><ol type="1"><li><strong>纯消费者应用程序</strong>：您的应用程序不控制消息生成。</li><li><strong>多个消费者组：</strong>当生成的消息被多个消费者组消费时，生产者可能会为其他消费者组产生不必要的倾斜负载，因为滞后只是特定于一个消费者组的信息。</li></ol><h3 id="相同队列长度算法">相同队列长度算法</h3><p>该算法将每个分区滞后视为处理的队列大小。获取滞后信息后，它会发布适当数量的消息以填充短队列。此方法更适合由于异构硬件而导致的倾斜滞后分布，其中高性能Pod（机器）在大多数情况下能够更快地处理。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*zp-S1Y_GbIzbjCX4.png"alt="相同队列长度算法的演示。最初，不同队列的长度不同。该算法尝试生成不同数量的消息，以在所有队列中实现相同的队列长度。这里，队列长度和 Kafka lag 是同一个概念，代表尚未处理的消息数量" /><figcaptionaria-hidden="true">相同队列长度算法的演示。最初，不同队列的长度不同。该算法尝试生成不同数量的消息，以在所有队列中实现相同的队列长度。这里，队列长度和Kafka lag 是同一个概念，代表尚未处理的消息数量</figcaption></figure><h3 id="异常值检测算法">异常值检测算法</h3><p>该算法利用统计方法来确定所有分区的上离群值，并暂时停止那些慢速离群值的发布过程。在原文章中，针对Agoda 的特定需求，他们提出了 IQR（四分位距）和STD（标准差）异常值检测算法。算法流程图如下所示。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*pjkj5kF6aFcWwBwU.png"alt="异常值检查算法流程" /><figcaption aria-hidden="true">异常值检查算法流程</figcaption></figure><ul><li><strong>慢速分区：</strong>（已关闭）由于存在延迟，这些分区的消息生成已停止。</li><li><strong>好的分区</strong>：（打开）照常发布并均匀分发到所有好的分区。</li><li><strong>OK分区：</strong>（观察/半开放）为了提高性能不佳的机器的性能，当系统尝试将慢速分区提升为良好分区时，会添加一个观察期。通过仅生成一小部分消息并进行观察，可以将该观察阶段优化为“半开放”状态。当滞后获取间隔相对较长时，半开放是有益的，因为它可以防止消费者延迟等待传入消息而更新的滞后数据尚未查询的情况。</li></ul><h2 id="从消费者角度出发">2. 从消费者角度出发</h2><p>这里 Adoga提出的思路是：<strong>遇到高延迟的实例可以主动取消订阅主题以触发重新平衡。在重新平衡期间，可以使用自定义的分配器来平衡所有消费者实例之间的分区。</strong></p><p>触发重新平衡的成本非常昂贵，因为急切的重新平衡会停止消费者组中的所有处理。Kafka2.4中引入的<ahref="https://www.confluent.io/blog/incremental-cooperative-rebalancing-in-kafka/">增量协作再平衡协议</a>已经最大限度地减少了性能影响，允许更频繁的再平衡以更好地分配每个分区上的负载。</p><p>为了增强重新分配的灵活性，分区的数量应该大于 worker的数量。这一比率应根据应用程序而有所不同，并假设一个工作线程至少可以处理来自一个分区的负载以避免饥饿。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*68P7QtdFGeIzwZSs.png"alt="在此示例中，工作程序 3 在速度较慢的硬件上运行，导致分区 5 和 6 出现更高的延迟。因此，工作程序 3 可能会主动取消订阅主题以触发重新平衡并更有效地重新分配分区。在此示例中，应实现自定义分配器以根据机器指标和滞后信息重新分配分区。" /><figcaption aria-hidden="true">在此示例中，工作程序 3在速度较慢的硬件上运行，导致分区 5 和 6 出现更高的延迟。因此，工作程序 3可能会主动取消订阅主题以触发重新平衡并更有效地重新分配分区。在此示例中，应实现自定义分配器以根据机器指标和滞后信息重新分配分区。</figcaption></figure><h1 id="总结">总结</h1><p>本文从 Kafka 并行性的一般实现出发，探讨了 Kafka实现负载均衡在现实实践中可能遇到的各种挑战，并从静态调整和动态调整两个方面给出了解决思路，特别注重讨论了动态调整策略，并分别从生产者和消费者的角度提出了解决方案。</p><p>总之，通过在 Kafka中实现负载均衡，可以有效地将工作负载分配到可用资源之间，从而显著提高服务性能。具体的算法和策略需要根据实际情况进行选择和调整。</p>]]></content>
    
    
    <summary type="html">本文转载自 Agoda Enginnering, 介绍了 Kafka 负载均衡的实际应用过程中的负载均衡挑战及解决思路。</summary>
    
    
    
    <category term="Kafka" scheme="https://hedon.top/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://hedon.top/tags/Kafka/"/>
    
    <category term="中间件" scheme="https://hedon.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="消息队列" scheme="https://hedon.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>学习记录：用 Go 自制解释器 Monkey</title>
    <link href="https://hedon.top/2024/05/12/monkey-language/"/>
    <id>https://hedon.top/2024/05/12/monkey-language/</id>
    <published>2024-05-11T19:44:15.000Z</published>
    <updated>2024-05-20T02:36:16.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="词法分析">词法分析</h1><p>TDD：测试驱动开发</p><p>先写测试用例，再进行词法分析逻辑的完善。</p><h1 id="语法分析">语法分析</h1><p>递归下降语法分析伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go">function parseProgram() &#123;<br>    program = newProgramASTNode()<br>    advanceTokens()<br>    <span class="hljs-keyword">for</span> (currentToken() != EOF_TOKEN) &#123;<br>        statement = null<br>        <span class="hljs-keyword">if</span> (currentToken() == LET_TOKEN) &#123;<br>            statement = parseLetStatement()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken() == RETURN_TOKEN) &#123;<br>            statement = parseReturnStatement()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken() == IF_TOKEN) &#123;<br>            statement = parseIfStatement()<br>        &#125;<br>        <span class="hljs-keyword">if</span> (statement != null) &#123;<br>            program.Statements.push(statement)<br>        &#125;<br>        advanceTokens()<br>    &#125;<br>    <span class="hljs-keyword">return</span> program<br>&#125;<br>function parseLetStatement() &#123;<br>    advanceTokens()<br>    identifier = parseIdentifier()<br>    advanceTokens()<br>    <span class="hljs-keyword">if</span> currentToken() != EQUAL_TOKEN &#123;<br>        parseError(<span class="hljs-string">&quot;no equal sign!&quot;</span>)<br>        <span class="hljs-keyword">return</span> null<br>    &#125;<br>    advanceTokens()<br>    value = parseExpression()<br>    variableStatement = newVariableStatementASTNode()<br>    variableStatement.identifier = identifier<br>    variableStatement.value = value<br>    <span class="hljs-keyword">return</span> variableStatement<br>&#125;<br>function parseIdentifier() &#123;<br>    identifier = newIdentifierASTNode()<br>    identifier.token = currentToken()<br>    <span class="hljs-keyword">return</span> identifier<br>&#125;<br>function parseExpression() &#123;<br>    <span class="hljs-keyword">if</span> (currentToken() == INTEGER_TOKEN) &#123;<br>        <span class="hljs-keyword">if</span> (nextToken() == PLUS_TOKEN) &#123;<br>            <span class="hljs-keyword">return</span> parseOperatorExpression()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextToken() == SEMICOLON_TOKEN) &#123;<br>            <span class="hljs-keyword">return</span> parseIntegerLiteral()<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken() == LEFT_PAREN) &#123;<br>        <span class="hljs-keyword">return</span> parseGroupedExpression()<br>    &#125;<br><span class="hljs-comment">// [...]</span><br>&#125;<br>function parseOperatorExpression() &#123;<br>    operatorExpression = newOperatorExpression()<br>    operatorExpression.left = parseIntegerLiteral()<br>    operatorExpression.operator = currentToken()<br>    operatorExpression.right = parseExpression()<br>    <span class="hljs-keyword">return</span> operatorExpression()<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512042659060.png"alt="递归下降分析法" /><figcaption aria-hidden="true">递归下降分析法</figcaption></figure><h2 id="let-x5">let x=5</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512035446100.png"alt="let stmt AST structure" /><figcaption aria-hidden="true">let stmt AST structure</figcaption></figure><h2 id="return-5">return 5</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512045650041.png"alt="return stmt AST structue" /><figcaption aria-hidden="true">return stmt AST structue</figcaption></figure><h2 id="普拉特解析">普拉特解析</h2>]]></content>
    
    
    <summary type="html">本文主要是记录笔者在学习《用 Go 自制解释器 Monkey》过程中涉及的重要设计理念和思考。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="Go 实战" scheme="https://hedon.top/categories/Go/Go-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="编译原理" scheme="https://hedon.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>时间处理基础：Rust 的 chrono 库教程</title>
    <link href="https://hedon.top/2024/05/11/rust-crate-chrono/"/>
    <id>https://hedon.top/2024/05/11/rust-crate-chrono/</id>
    <published>2024-05-11T15:52:55.000Z</published>
    <updated>2024-05-20T02:36:16.099Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中，我们经常有对时间和日期处理的需求。不论是日历应用、日程安排、还是时间戳记录，准确的时间数据处理都是必不可少的。Rust社区提供的 <code>chrono</code> 库以其强大的功能和灵活的接口，在 Rust开发者中广受欢迎。本文将简单介绍 <code>chrono</code>库，展示如何利用它来精确处理和转换时间和日期，帮助你在任何 Rust项目中都能高效地管理时间。</p><h1 id="版本">版本</h1><ul><li><code>chrono</code>: 0.4.38</li></ul><h1 id="结论先行">结论先行</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512010241356.png"alt="chrono 各种时间类型转换图" /><figcaption aria-hidden="true">chrono 各种时间类型转换图</figcaption></figure><h1 id="时间相关概念">时间相关概念</h1><table><thead><tr class="header"><th>概念</th><th>理解</th></tr></thead><tbody><tr class="odd"><td>UNIX 时间戳（UNIX Timestamp）</td><td>也称为 POSIX 时间或 Epoch 时间，是自 1970 年 1 月 1 日（UTC时区）以来经过的秒数，不计入闰秒。这是一种非常通用的时间表示方法，在编程中广泛使用，因为它可以简化时间差的计算。</td></tr><tr class="even"><td>UTC（协调世界时）</td><td>全称为协调世界时（Coordinated UniversalTime），是目前国际上广泛采用的时间标准。它基本上与格林威治平均时（GMT）相同，但在技术上更加精确，因为它使用原子钟来保持时间准确。世界各地的时间都是以UTC 为基础，加上或减去一定的小时数来定义的。</td></tr><tr class="odd"><td>时区（Time Zone）</td><td>时区是地球上划分的标准时间区域。由于地球自西向东旋转，每向东移动一定角度，当地的太阳时间就会相应地提前。世界被分成了24个时区，每个时区通常相差一小时。时区允许地区内的人们能在大致相同的时间内，经历类似的日夜更替模式。</td></tr><tr class="even"><td>UTC+8</td><td>UTC+8 是 UTC 时间加上 8小时的时间区。中国大陆就是位于这个时区。例如，当 UTC 时间为 00:00时，UTC+8 的时间就是 08:00。</td></tr></tbody></table><h1 id="chrono-关键类型">chrono 关键类型</h1><table><thead><tr class="header"><th>类型</th><th>含义</th><th>适用场景</th></tr></thead><tbody><tr class="odd"><td>DateTime&lt;Tz&gt;</td><td>一个带有时区的日期和时间类型，其中 <code>Tz</code> 是实现了<code>TimeZone</code> 特质的类型，如 <code>Utc</code> 和<code>Local</code> 。这意味着 <code>DateTime</code>考虑了时区的影响，可以表示全球任意地点的精确时间。</td><td>广泛用于需要考虑时区转换的场景，如存储用户的本地时间或在不同地区之间转换时间。</td></tr><tr class="even"><td>NaiveDateTime</td><td>一个“天真的”日期和时间，即不包含任何时区信息的日期和时间。这种类型仅仅表示一个日历日期和一天中的时间，而没有任何关于地理或政治时区的数据。</td><td>对于一些时区不重要的场景非常有用，比如记录电影的发行日期或历史事件的日期。</td></tr><tr class="odd"><td>NaiveDate</td><td>仅表示一个日历日期，不包括时间或时区信息。</td><td>它用于处理只需要日期而不关心具体时间的场景，如生日、节日等。</td></tr><tr class="even"><td>NaiveTime</td><td>是一个只表示一天中时间的类型，它不包含日期或时区信息。</td><td>这个类型适用于需要处理具体某个时间点（如开会时间、日常活动的开始时间）但不需要日期数据的情景。</td></tr></tbody></table><h1 id="chrono-时区类型">chrono 时区类型</h1><p><code>chrono</code>支持多种时区类型，方便进行全球时间的转换和计算：</p><ul><li><strong><code>Utc</code></strong>: 用于处理协调世界时。</li><li><strong><code>Local</code></strong>:代表服务器或用户的本地时区。</li><li><strong><code>FixedOffset</code></strong>:允许定义任意的小时和分钟偏移量，适合固定偏移的时间计算。</li></ul><h1 id="常用功能">常用功能</h1><h2 id="获取当前时间">获取当前时间</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span>: DateTime&lt;Local&gt; = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">utc_datetime</span>: DateTime&lt;Utc&gt; = Utc::<span class="hljs-title function_ invoke__">now</span>();<br></code></pre></td></tr></table></figure><h2 id="datetime-转-string">DateTime 转 String</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">to_rfc2822</span>()); <span class="hljs-comment">// Sun, 12 May 2024 00:15:55 +0800</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">to_rfc3339</span>()); <span class="hljs-comment">// 2024-05-12T00:15:55.325058+08:00</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">to_string</span>()); <span class="hljs-comment">// 2024-05-12 00:15:55.325058 +08:00</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.format(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)) <span class="hljs-comment">// 2024-05-12 00:15:55</span><br></code></pre></td></tr></table></figure><h2 id="string-转-datetime">String 转 DateTime</h2><p>字符串带时区信息，使用<code>DateTime::parse_from_str(s, f)</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">format_withzone</span> = <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">datetime_withzone_str</span> = <span class="hljs-string">&quot;2024-01-01 00:00:00 +08:00&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span> =<br>    DateTime::<span class="hljs-title function_ invoke__">parse_from_str</span>(&amp;datetime_withzone_str, &amp;format_withzone).<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><p>字符串无时区信息，使用<code>NaiveDateTime::parse_from_str(s, f)</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">format</span> = <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">datetime_str</span> = <span class="hljs-string">&quot;2024-01-01 00:00:00&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span> = NaiveDateTime::<span class="hljs-title function_ invoke__">parse_from_str</span>(&amp;datetime_str, &amp;format)<br>    .<span class="hljs-title function_ invoke__">unwrap</span>()<br>    .<span class="hljs-title function_ invoke__">and_local_timezone</span>(Local) <span class="hljs-comment">// 转为带时区的 DateTime</span><br>    .<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><h2 id="datetime-转-timestamp">DateTime 转 timestamp</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span> = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;seconds: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp</span>()); <span class="hljs-comment">// 1715444324</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;millis: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp_millis</span>()); <span class="hljs-comment">// 1715444338610</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;micros: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp_micros</span>()); <span class="hljs-comment">// 1715444338610873</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;nacos: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp_nanos_opt</span>().<span class="hljs-title function_ invoke__">unwrap</span>()); <span class="hljs-comment">// 1715444338610873000</span><br></code></pre></td></tr></table></figure><h2 id="timestamp-转-datetime">timestamp 转 DateTime</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">utc_datetime</span>: DateTime&lt;Utc&gt; = DateTime::<span class="hljs-title function_ invoke__">from_timestamp</span>(<span class="hljs-number">1704139200</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// 默认是 Utc</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span>: DateTime&lt;Local&gt; = DateTime::<span class="hljs-title function_ invoke__">from_timestamp</span>(<span class="hljs-number">1704139200</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">into</span>(); <span class="hljs-comment">// 使用 into() 转为 Local</span><br></code></pre></td></tr></table></figure><h2 id="时区转换">时区转换</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> chrono::&#123;DateTime, FixedOffset, Utc&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">utc_date_time</span>: DateTime&lt;Utc&gt; = Utc::<span class="hljs-title function_ invoke__">now</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">fixed_offset</span> = FixedOffset::<span class="hljs-title function_ invoke__">east</span>(<span class="hljs-number">8</span> * <span class="hljs-number">3600</span>); <span class="hljs-comment">// 转为 utc+8 东八区</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">local_date_time</span> = utc_date_time.<span class="hljs-title function_ invoke__">with_timezone</span>(&amp;fixed_offset);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Local time in UTC+8: &#123;&#125;&quot;</span>, local_date_time);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间计算">时间计算</h2><p>时间加减：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> chrono::&#123;Duration, Local&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">now</span> = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">yesterday</span> = now - Duration::<span class="hljs-title function_ invoke__">hours</span>(<span class="hljs-number">24</span>);<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512002330526.png"alt="chrono time duration methods" /><figcaption aria-hidden="true">chrono time duration methods</figcaption></figure><p>时间间隔：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> chrono::&#123;Duration, Local&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">now</span> = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">yesterday</span> = now - Duration::<span class="hljs-title function_ invoke__">hours</span>(<span class="hljs-number">24</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">hour_interval</span> = (now - yesterday).<span class="hljs-title function_ invoke__">num_hours</span>();<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512002106738.png"alt="chrono time interval methods" /><figcaption aria-hidden="true">chrono time interval methods</figcaption></figure><h1 id="总结">总结</h1><p>通过本文的详细介绍和实用示例，我们了解了如何使用 Rust 的<code>chrono</code> 库来精确处理时间和日期。<code>chrono</code>不仅支持复杂的时区计算和全球时间管理，还提供了方便的日期时间解析和格式化工具，以及灵活的时间运算功能。掌握了这些技能后，你将能够在任何需要精确时间数据处理的Rust 应用中，提供稳定和高效的解决方案。</p><p>时间是每个程序的基石，而 <code>chrono</code>就是那把能够操纵时间的魔杖。</p><p>希望本文能对你有帮助，peace! enjoy coding~</p><blockquote><p>参考：</p><ul><li><a href="https://docs.rs/chrono/latest/chrono/">chronocrate</a></li><li><ahref="https://blog.stackademic.com/rust-working-with-date-and-time-30e003cd59e8">rust-working-with-date-and-time</a></li></ul><p>作图：</p><ul><li>https://excalidraw.com/</li></ul></blockquote>]]></content>
    
    
    <summary type="html">本文全面的指南深入介绍了如何在 Rust 中使用 chrono 库来精确处理和转换时间与日期。从基本概念到高级功能，本文提供了实用的代码示例和详尽的解释，帮助你在任何 Rust 项目中高效管理时间。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 常用库" scheme="https://hedon.top/categories/Rust/Rust-%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>epoll</title>
    <link href="https://hedon.top/2024/04/28/epoll/"/>
    <id>https://hedon.top/2024/04/28/epoll/</id>
    <published>2024-04-28T12:27:29.000Z</published>
    <updated>2024-05-20T02:36:16.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><code>epoll</code> 是一种 I/O多路复用技术，主要用于高性能的网络服务器中，特别是在处理大量并发连接时。它是Linux 特有的，自 Linux 内核 2.5.44版本引入，并在后续版本中不断优化。<code>epoll</code>能够帮助服务器高效地管理数以千计的客户端连接，是 <code>select</code> 和<code>poll</code> 方法的现代替代品。</p><p>本文不对 <code>epoll</code>的源码进行分析，仅做原理上的总结，方便快速查阅回顾。各大论坛很多大佬都对<code>epoll</code>的源码进行了详尽的分析，感兴趣的读者可以看「参考」篇章。</p><h1 id="主要特点">主要特点</h1><ol type="1"><li><strong>效率高</strong>: 相较于 <code>select</code> 和<code>poll</code>，<code>epoll</code>可以更高效地处理大量的并发连接。<code>select</code> 和 <code>poll</code>的效率随着监视的文件描述符数量增加而线性下降，而 <code>epoll</code>则不会因为监视的文件描述符数量增加而显著降低效率。</li><li><strong>扩展性好</strong>: <code>epoll</code>使用一种称为事件通知的机制，只会处理那些真正发生了事件的文件描述符。这意味着系统不必重新检查所有文件描述符，从而大大减少了不必要的CPU 开销。</li><li><strong>支持边缘触发和水平触发</strong>: <code>epoll</code> 支持<code>Edge Triggered</code> 和水平触发 <code>Level Triggered</code>两种模式。边缘触发模式只在文件描述符状态改变时才通知应用程序，适用于非阻塞I/O；而水平触发模式则在有事件可读或可写时都会通知应用程序，更容易使用但效率略低。</li></ol><h1 id="结论先行">结论先行</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240429121302958.png"alt="epoll flow chart" /><figcaption aria-hidden="true">epoll flow chart</figcaption></figure><h1 id="工作原理">工作原理</h1><p><code>epoll</code> 的工作可以分为三个主要步骤：</p><ol type="1"><li><strong>创建 epoll 实例</strong>: 使用 <code>epoll_create</code>函数创建一个 <code>epoll</code> 实例。</li><li><strong>添加/修改/删除文件描述符</strong>: 使用<code>epoll_ctl</code> 函数将新的文件描述符添加到 <code>epoll</code>实例中，或者修改、删除已存在的文件描述符。这些操作与文件描述符的数量无关，因此执行速度非常快。</li><li><strong>等待事件发生</strong>: 使用 <code>epoll_wait</code>函数等待事件的发生。这个函数可以同时监控多个文件描述符，当指定的文件描述符上发生了注册的事件时，函数返回，并告知哪些文件描述符上发生了事件。</li></ol><h1 id="et-lt">ET &amp; LT</h1><p>在 <code>epoll</code> 中，边缘触发（ET, EdgeTriggered）和水平触发（LT, LevelTriggered）是两种不同的事件通知方式，它们定义了操作系统如何通知应用程序文件描述符上的I/O 事件。</p><p>这两种模式的主要区别在于何时以及如何多次通知应用程序关于某个文件描述符的事件。</p><h2 id="水平触发level-triggered">水平触发（Level Triggered）</h2><ul><li><strong>定义</strong>: 在水平触发模式下，只要文件描述符上有未处理的I/O 事件存在，<code>epoll_wait</code>就会通知应用程序。这意味着，如果数据可读取但未被完全读取，<code>epoll_wait</code>会在下次调用时再次返回该文件描述符。</li><li><strong>行为</strong>:这种模式更容易编程，因为应用程序可以不用担心在一个操作中处理所有数据。如果数据还在，<code>epoll_wait</code>会继续通知你。</li><li><strong>适用场景</strong>:更适合那些简单的应用或者对实时性要求不是非常高的应用，因为它简化了处理逻辑。</li></ul><h2 id="边缘触发edge-triggered">边缘触发（Edge Triggered）</h2><ul><li><strong>定义</strong>:在边缘触发模式下，只有状态变化时（例如从无数据到有数据），<code>epoll_wait</code>才会通知应用程序。一旦通知了应用程序某事件发生，除非有新的数据到达或状态再次发生变化，否则不会再次通知应用程序该事件。</li><li><strong>行为</strong>:这要求应用程序必须立即处理所有事件，因为之后不会再收到关于这些事件的通知。这意味着应用程序必须循环读取或写入，直到数据被完全处理完，以确保不遗漏任何事件。</li><li><strong>适用场景</strong>:适合需要高性能的场景，因为它减少了事件处理的次数，但要求程序必须更加小心地管理I/O 操作。</li></ul><h2 id="比较和选择">比较和选择</h2><ul><li><strong>性能</strong>:边缘触发通常提供更高的性能，因为它减少了系统调用的次数和不必要的事件处理。</li><li><strong>编程复杂性</strong>:边缘触发模式编程比水平触发复杂，因为需要确保每次事件被彻底处理，并且更容易遇到如“惊群效应”（多个进程或线程被同一个事件唤醒）等问题。</li><li><strong>可靠性</strong>:水平触发因为其简单的行为模式，在可靠性处理上更为直接和容易。</li></ul><p>通常，选择哪种模式取决于应用的具体需求、预期的负载以及开发者对事件处理逻辑的控制程度。高性能服务器通常选择边缘触发模式，以最大化其效率，而简单的或者低负载应用可能会更倾向于使用水平触发，以简化开发和调试过程。</p><h1 id="数据结构">数据结构</h1><p><code>epoll</code> 使用 2种关键的数据结构来维护和跟踪文件描述符（FD）和事件：</p><ol type="1"><li><strong>红黑树（Red-Black Tree）</strong>:用于存储所有注册的文件描述符及其事件。红黑树是一种自平衡二叉搜索树，能够在对数时间内完成插入、删除和查找操作，这使得管理大量文件描述符变得高效。</li><li><strong>就绪列表（Ready List）</strong>:当事件发生（如可读、可写等）并被内核检测到时，相应的 FD会被添加到一个就绪列表中。这个列表仅包含实际有事件发生的文件描述符，从而减少了<code>epoll_wait</code> 调用的处理时间。</li></ol><h1 id="工作细节">工作细节</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/epoll_principle.jpg"alt="epoll data structure" /><figcaption aria-hidden="true">epoll data structure</figcaption></figure><ol type="1"><li>通过调用 <code>epoll_create()</code> 函数创建并初始化一个<code>eventpoll</code> 对象。</li><li>通过调用 <code>epoll_ctl()</code> 函数把被监听的文件句柄 (如 socket句柄) 封装成 <code>epitem</code> 对象并且添加到 <code>eventpoll</code>对象的红黑树中进行管理。</li><li>通过调用 <code>epoll_wait()</code>函数等待被监听的文件状态发生改变。</li><li>当被监听的文件状态发生改变时（如 socket接收到数据），会把文件句柄对应 <code>epitem</code> 对象添加到<code>eventpoll</code> 对象的就绪队列 <code>rdllist</code>中。并且把就绪队列的文件列表复制到 <code>epoll_wait()</code> 函数的<code>events</code> 参数中。</li><li>唤醒调用 <code>epoll_wait()</code> 函数被阻塞（睡眠）的进程。</li></ol><h1 id="事件监听">事件监听</h1><p>内核中的事件监听和回调机制是通过高效的事件驱动模型实现的，而不是简单的循环检查（如在用户空间中的轮询）。这种机制利用了现代操作系统的中断和回调系统，以及针对异步事件的优化处理策略。</p><p>以下是这个过程的详细解释：</p><h2 id="中断和中断处理">1. 中断和中断处理</h2><p>在硬件层面，大多数 I/O 操作（如网络通信、磁盘I/O）都是通过中断驱动的。当一个 I/O设备准备好数据或需要服务时，它会产生一个中断信号，这个信号被发送到CPU。CPU 响应中断，并执行一个预定的中断处理程序（Interrupt ServiceRoutine, ISR），该程序是由设备的驱动程序提供的。</p><h2 id="事件和回调">2. 事件和回调</h2><p>在 ISR中，与设备相关的事件（例如网络包的接收、硬盘读取完成）会被检测到，并且可以在此阶段调用特定的回调函数。这些回调函数是在设备驱动或相关的内核模块中定义的，用来通知内核其他部分或者相关的进程有关事件的发生。</p><h2 id="文件描述符的回调机制">3. 文件描述符的回调机制</h2><p>对于 <code>epoll</code> 等 I/O多路复用技术，内核为每个文件描述符维护了一个事件处理机制。当文件描述符被创建时，相关的设备或资源会注册一组回调函数，这些函数会在特定的操作（如读、写、错误）上被触发。例如，一个网络套接字可能会在数据到达时触发一个“可读”事件的回调。</p><h2 id="epoll-的事件绑定">4. <code>epoll</code> 的事件绑定</h2><p>当一个文件描述符被加入到 <code>epoll</code>监听队列中，<code>epoll</code>会利用这些回调来获得事件通知。<code>epoll</code>操作相关的代码会将一个额外的回调函数绑定到这些文件描述符上。当文件描述符的状态改变时（如数据可读），这个回调函数将被触发，然后它会将相应的文件描述符标记为“就绪”，并放入<code>epoll</code> 的就绪队列。</p><h2 id="事件通知和唤醒">5. 事件通知和唤醒</h2><p>当 <code>epoll_wait</code>被调用且有事件就绪时，内核会检查就绪队列，并将这些事件传递给等待的进程。如果没有事件就绪，进程将被挂起直到有事件发生。事件的发生会触发内核调度程序唤醒相应的进程。</p><h2 id="效率和性能">6. 效率和性能</h2><p>这种基于中断的事件通知机制意味着内核不需要不断循环检查每个文件描述符的状态，从而极大地提高了效率。事件只有在实际发生时才被处理，且处理通常是由硬件中断直接触发的，这使得整个系统更加响应快速，减少了无效的CPU 使用。</p><p>这种设计使得 Linux 内核在处理大量并发 I/O操作时能够保持高效和稳定，适合构建高性能的网络服务和应用。</p><h1 id="中断">中断</h1><p>中断机制是计算机硬件和操作系统核心功能之一，它允许外设或硬件异步地通知CPU 需要处理某些事件。中断机制的实现并不依赖于类似于 <code>for</code>循环的轮询检查，而是建立在更为直接和高效的硬件和处理器架构支持之上。</p><p>当 CPU接收到中断信号时，它是通过一套内建于硬件的协调机制来识别和响应中断的。这个过程涉及硬件电路设计、处理器架构和操作系统的中断管理功能。</p><p>以下是 CPU 如何知道有中断发生，并且如何处理这一中断的详细步骤：</p><h2 id="中断信号的检测和响应">中断信号的检测和响应</h2><ol type="1"><li><p><strong>中断请求线（IRQ）</strong>：外部设备通过连接到处理器的一个特定的硬件线路（IRQ）发送中断信号。这个线路直接与处理器内的中断控制单元（InterruptController）相连。</p></li><li><p><strong>中断控制器</strong>：大多数现代计算机系统使用一个或多个中断控制器来管理中断信号。中断控制器的任务是接收来自各种外部设备的中断请求，并将这些请求优先级排序后发送给CPU。</p></li><li><p><strong>中断向量</strong>：当中断控制器接收到一个中断信号后，它会根据中断源确定一个中断向量。这个向量是一个数字，指向中断向量表中对应的入口，该入口包含了处理该中断的中断服务例程（ISR）的地址。</p></li></ol><h2 id="cpu-如何处理中断">CPU 如何处理中断</h2><ol type="1"><li><p><strong>当前指令的完成</strong>：当 CPU接收到中断控制器发出的中断信号时，它首先会完成当前执行的指令。这是为了保证程序的状态能够正确保存，从而在中断处理完毕后可以无缝地恢复执行。</p></li><li><p><strong>保存上下文</strong>：一旦当前指令执行完毕，CPU会自动保存当前的程序状态，包括程序计数器（PC）、寄存器和其他必要的状态信息。这些信息通常被推送到当前的栈上。</p></li><li><p><strong>跳转到 ISR</strong>：CPU使用中断向量来访问中断向量表，找到与中断号对应的中断服务例程（ISR）的地址，并跳转到该地址开始执行ISR。这个过程是自动的，由处理器的内部机制控制。</p></li><li><p><strong>执行ISR</strong>：中断服务例程会执行必要的操作来处理中断，比如读取数据缓冲区、清除设备状态或发送信号等。</p></li><li><p><strong>恢复上下文并返回</strong>：一旦 ISR执行完成，处理器会从栈上恢复之前保存的程序状态，并将控制权返回到被中断的程序，继续执行。</p></li></ol><h2 id="硬件支持">硬件支持</h2><p>这一过程大量依赖于处理器的硬件支持，如中断向量表通常是固定在处理器的特定内存地址上的。此外，现代处理器如x86架构还提供了更高级的功能，比如支持多重中断控制器和高级可编程中断控制器（APIC）等。</p><p>这种基于硬件的中断响应机制允许 CPU快速有效地处理各种外部事件，确保系统的响应性和稳定性。</p><h1 id="参考">参考</h1><ul><li><ahref="https://blog.csdn.net/zhangyanfei01/article/details/114959103">图解| 深入揭秘 epoll 是如何实现 IO 多路复用的！</a></li><li><ahref="https://blog.csdn.net/zhpCSDN921011/article/details/125580548">一图总结epoll 的总体工作流程</a></li><li><ahref="https://thetechsolo.wordpress.com/2016/02/29/scalable-io-events-vs-multithreading-based/">scalable-io-events-vs-multithreading-based</a></li><li><ahref="https://github.com/liexusong/linux-source-code-analyze/blob/master/epoll-principle.md">Epoll实现原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/667412830">网络编程之 epoll源码深度剖析</a></li></ul>]]></content>
    
    
    <summary type="html">本文总结了高性能网络服务器中大量使用的 I/O 多路复用技术 epoll，涵盖工作原理、数据结构、事件监听和中断等相关内容。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="epoll" scheme="https://hedon.top/tags/epoll/"/>
    
    <category term="网络编程" scheme="https://hedon.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="非阻塞 I/0" scheme="https://hedon.top/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E-I-0/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨并发构建倒排索引</title>
    <link href="https://hedon.top/2024/04/23/rust-action-inverted-index-concurrency/"/>
    <id>https://hedon.top/2024/04/23/rust-action-inverted-index-concurrency/</id>
    <published>2024-04-23T15:13:27.000Z</published>
    <updated>2024-04-28T12:27:13.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>继上篇 <ahref="https://hedon.top/2024/04/15/rust-action-inverted-index-demo/">Rust实战丨倒排索引</a>，本篇我们将参考《Rust程序设计（第二版）》中并发编程篇章来实现高并发构建倒排索引。</p><p>本篇主要分为以下几个部分：</p><ol type="1"><li>功能展示：展示我们最终实现的 2个工具的效果（构建索引、搜索功能）</li><li>阅读源码：阅读书中源码的实现，理清大体思路。</li><li>构建索引：实战构建索引的每个具体环节，并对核心逻辑进行解释和阐述缘由。</li><li>搜索功能：这是书中未曾提供的功能，笔者根据自身理解，对齐上篇提供的功能，实现了一个搜索功能。</li></ol><p>能学到：</p><ul><li>Rust 各种迭代器的使用</li><li>Rust 文件常用操作</li><li>Rust 字符串常用操作</li><li>Rust channel 实战</li><li>Rust 并发编程</li><li>多路合并文件实际应用</li><li>使用 <code>byteorder</code> 进行位操作</li><li>使用 <code>clap</code> 进行 CLI 开发</li><li>终端高亮输出</li><li>深入理解倒排索引高性能的核心细节</li></ul><h1 id="阅读建议">阅读建议</h1><p>本篇内容较为冗长，涉及到的细节讲解可能比较啰嗦，推荐<strong>直接阅读源码，然后对不理解的地方再来本篇对应的章节进行阅读</strong>。</p><p>完成源码位于：https://github.com/hedon-rust-road/inverted-index-concurrency</p><h1 id="版本声明">版本声明</h1><ul><li>Rust: 1.76</li><li>byteordrr: 1.5.0</li><li>clap: 4.5.0</li><li>运行环境：macbookPro Apple M2 Max</li></ul><h1 id="功能展示">功能展示</h1><h2 id="create.rs">create.rs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: create [OPTIONS] &lt;FILENAMES&gt;...<br><br>Arguments:<br>  &lt;FILENAMES&gt;...<br><br>Options:<br>  -s, --single-threaded  Default <span class="hljs-literal">false</span><br>  -h, --<span class="hljs-built_in">help</span>             Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>指定文件目录，构建索引，可以使用 <code>-s</code>使用单线程构建，默认使用并发构建。</p><p>执行示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  inverted-index-concurrency git:(master) ✗ cargo run --bin create ./texts<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.08s<br>     Running `/Users/wangjiahan/rust-target/debug/create ./texts`<br>indexed document 0:<span class="hljs-string">&quot;./texts/text1.txt&quot;</span>, 22 bytes, 5 words<br>indexed document 1:<span class="hljs-string">&quot;./texts/text3.txt&quot;</span>, 27 bytes, 5 words<br>indexed document 2:<span class="hljs-string">&quot;./texts/text2.txt&quot;</span>, 39 bytes, 6 words<br>word count: 16<br>351 bytes main, 736 bytes total<br>wrote file <span class="hljs-string">&quot;./tmp00000001.dat&quot;</span><br></code></pre></td></tr></table></figure><h2 id="search.rs">search.rs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: search --index-file &lt;INDEX_FILE&gt; --term &lt;TERM&gt;<br><br>Options:<br>  -i, --index-file &lt;INDEX_FILE&gt;  Specify index file path<br>  -t, --term &lt;TERM&gt;              Specify search term<br>  -h, --<span class="hljs-built_in">help</span>                     Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>指定索引文件和搜索词来进行搜索。</p><p>执行示例如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423201406903.png"alt="search.rs 执行示例" /><figcaption aria-hidden="true">search.rs 执行示例</figcaption></figure><h1 id="阅读源码">阅读源码</h1><blockquote><p>书中的源码位于：<ahref="https://github.com/ProgrammingRust/fingertips/tree/master">fingertips</a></p></blockquote><p>第一部分我们先来阅读源码，书中展示了这样一张图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image00882.jpeg"alt="索引构建器管道，其中箭头表示通过通道将值从一个线程发送到另一个线程（未展示磁盘 I/O）" /><figcaptionaria-hidden="true">索引构建器管道，其中箭头表示通过通道将值从一个线程发送到另一个线程（未展示磁盘I/O）</figcaption></figure><p>从这张图我们大概可以猜想本案例中构建并发索引的过程可能是：</p><ol type="1"><li>读取文件内容；</li><li>根据文件内容构建索引；</li><li>多个索引进行合并；</li><li>将索引写入文件；</li><li>多个索引文件进行合并。</li></ol><p>按照这个思路的指引，我们打开源码，从 <code>main.rs</code> 的<code>main()</code> 出发：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">single_threaded</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">filenames</span> = <span class="hljs-built_in">vec!</span>[];<br><br>  <span class="hljs-comment">// 命令行参数解析</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ap</span> = ArgumentParser::<span class="hljs-title function_ invoke__">new</span>();<br>        ap.<span class="hljs-title function_ invoke__">set_description</span>(<span class="hljs-string">&quot;Make an inverted index for searching documents.&quot;</span>);<br>        ap.<span class="hljs-title function_ invoke__">refer</span>(&amp;<span class="hljs-keyword">mut</span> single_threaded).<span class="hljs-title function_ invoke__">add_option</span>(<br>            &amp;[<span class="hljs-string">&quot;-1&quot;</span>, <span class="hljs-string">&quot;--single-threaded&quot;</span>],<br>            StoreTrue,<br>            <span class="hljs-string">&quot;Do all the work on a single thread.&quot;</span>,<br>        );<br>        ap.<span class="hljs-title function_ invoke__">refer</span>(&amp;<span class="hljs-keyword">mut</span> filenames).<span class="hljs-title function_ invoke__">add_argument</span>(<br>            <span class="hljs-string">&quot;filenames&quot;</span>,<br>            Collect,<br>            <span class="hljs-string">&quot;Names of files/directories to index. \</span><br><span class="hljs-string">                           For directories, all .txt files immediately \</span><br><span class="hljs-string">                           under the directory are indexed.&quot;</span>,<br>        );<br>        ap.<span class="hljs-title function_ invoke__">parse_args_or_exit</span>();<br>    &#125;<br><br>  <span class="hljs-comment">// 构建索引</span><br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">run</span>(filenames, single_threaded) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(()) =&gt; &#123;&#125;<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error: &#123;&#125;&quot;</span>, err),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>解析命令行参数，这里使用 <code>argparse</code> 这个比较古老的 crate来解析，现在一般是使用 <code>clap</code>。<ul><li><code>single_threaded:</code> 是否使用单线程，默认是多线程。</li><li><code>filenames</code>: 指定的文本文件或目录。</li></ul></li><li><code>run</code> 函数执行构建索引。</li></ol><p>看一下 <code>run</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Generate an index for a bunch of text files.</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(filenames: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;, single_threaded: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">output_dir</span> = PathBuf::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">documents</span> = <span class="hljs-title function_ invoke__">expand_filename_arguments</span>(filenames)?;<br><br>    <span class="hljs-keyword">if</span> single_threaded &#123;<br>        <span class="hljs-title function_ invoke__">run_single_threaded</span>(documents, output_dir)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">run_pipeline</span>(documents, output_dir)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>单线程：run_single_threaded</li><li>多线程：run_pipeline</li></ul><p>先从简单看，单线程，忽略掉源码中定义的特殊数据结构，可以发现跟我们上篇介绍的简单版倒排索引思路基本是一致的，只不过本案例中数据是从文件中读，最后又会将索引写入到文件中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_single_threaded</span>(documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">accumulated_index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">merge</span> = FileMerge::<span class="hljs-title function_ invoke__">new</span>(&amp;output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp_dir</span> = TmpDir::<span class="hljs-title function_ invoke__">new</span>(&amp;output_dir);<br><br>    <span class="hljs-comment">// 迭代每个文本文件</span><br>    <span class="hljs-keyword">for</span> (doc_id, filename) <span class="hljs-keyword">in</span> documents.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>      <span class="hljs-comment">// 打开文件，并将内容读取到 `text` 上</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(filename)?;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>        f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> text)?;<br><br>        <span class="hljs-comment">// 构建索引</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_single_document</span>(doc_id, text);<br>        accumulated_index.<span class="hljs-title function_ invoke__">merge</span>(index);<br>        <span class="hljs-keyword">if</span> accumulated_index.<span class="hljs-title function_ invoke__">is_large</span>() &#123;<br>            <span class="hljs-comment">// 当索引足够大的时候，将其写到文件中</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(accumulated_index, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>            merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>            accumulated_index = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将最后一个索引写入到文件中</span><br>    <span class="hljs-keyword">if</span> !accumulated_index.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(accumulated_index, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>        merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>    &#125;<br>    merge.<span class="hljs-title function_ invoke__">finish</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看本文的重头戏，多线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_pipeline</span>(documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// 将构建索引分为 5 个过程</span><br>    <span class="hljs-keyword">let</span> (texts, h1) = <span class="hljs-title function_ invoke__">start_file_reader_thread</span>(documents);<br>    <span class="hljs-keyword">let</span> (pints, h2) = <span class="hljs-title function_ invoke__">start_file_indexing_thread</span>(texts);<br>    <span class="hljs-keyword">let</span> (gallons, h3) = <span class="hljs-title function_ invoke__">start_in_memory_merge_thread</span>(pints);<br>    <span class="hljs-keyword">let</span> (files, h4) = <span class="hljs-title function_ invoke__">start_index_writer_thread</span>(gallons, &amp;output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">merge_index_files</span>(files, &amp;output_dir);<br><br>    <span class="hljs-comment">// 等待所有线程执行完毕</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = h1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h3.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = h4.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    r1?;<br>    r4?;<br>    result<br>&#125;<br></code></pre></td></tr></table></figure><p>首先将索引构建分成 5 个阶段：</p><p><strong>1. start_file_reader_thread</strong></p><p>就是从文件中读取文本信息，并将其扔进<code>Receiver&lt;String&gt;</code> channel 中，传到下一个阶段。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_reader_thread</span>(<br>    documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;<span class="hljs-type">String</span>&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">filename</span> <span class="hljs-keyword">in</span> documents &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(filename)?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>          <span class="hljs-comment">// 读取文件内容</span><br>            f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> text)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(text).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. start_file_indexing_thread</strong></p><p>从第 1 步传过来的文本信息中调用<code>InMemoryIndex::from_single_document</code> 构建索引。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_indexing_thread</span>(<br>    texts: Receiver&lt;<span class="hljs-type">String</span>&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> (doc_id, text) <span class="hljs-keyword">in</span> texts.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>          <span class="hljs-comment">// 构建索引</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_single_document</span>(doc_id, text);<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. start_in_memory_merge_thread</strong></p><p>将第 2 步构建的单一索引进行合并，并将合并后的索引传到下一个阶段。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_in_memory_merge_thread</span>(<br>    file_indexes: Receiver&lt;InMemoryIndex&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">accumulated_index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">fi</span> <span class="hljs-keyword">in</span> file_indexes &#123;<br>          <span class="hljs-comment">// 将索引进行合并</span><br>            accumulated_index.<span class="hljs-title function_ invoke__">merge</span>(fi);<br>            <span class="hljs-keyword">if</span> accumulated_index.<span class="hljs-title function_ invoke__">is_large</span>() &#123;<br>              <span class="hljs-comment">// 如果索引大小到达阈值，则传到下一阶段</span><br>                <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                accumulated_index = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !accumulated_index.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index);<br>        &#125;<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. start_index_writer_thread</strong></p><p>将第 3 步传来的内存索引写入到临时文件中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_index_writer_thread</span>(<br>    big_indexes: Receiver&lt;InMemoryIndex&gt;,<br>    output_dir: &amp;Path,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;PathBuf&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp_dir</span> = TmpDir::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">index</span> <span class="hljs-keyword">in</span> big_indexes &#123;<br>          <span class="hljs-comment">// 将索引写入临时文件中</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(index, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(file).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5. merge_index_files</strong></p><p>将临时文件进行合并，生成最终的索引文件。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_index_files</span>(files: Receiver&lt;PathBuf&gt;, output_dir: &amp;Path) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">merge</span> = FileMerge::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">file</span> <span class="hljs-keyword">in</span> files &#123;<br>        merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>    &#125;<br>    merge.<span class="hljs-title function_ invoke__">finish</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>这 5 个步骤跟书中给出的示意图基本一致，我们再来看<code>run_pipeline</code> 是如何合并并行的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 join() 等待所有线程完成</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = h1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>h2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>h3.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = h4.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br><span class="hljs-comment">// 阶段 2 和阶段 3 都是纯内存操作，不会有错误</span><br><span class="hljs-comment">// 阶段 1 是读文件，阶段 4 是写文件，所以有可能会报错</span><br>r1?;<br>r4?;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240416001044618.png"alt="run_pipeline 示意图" /><figcaption aria-hidden="true">run_pipeline 示意图</figcaption></figure><p>源码阅读部分差不多就到这了，大的思想架构你应该都能 Get到了，其中每个数据结构的具体实现细节，我们在后面的实战中进行拆解。</p><h1 id="构建索引">构建索引</h1><h2 id="代码结构">代码结构</h2><p>书中源码代码结构如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  fingertips git:(master) ✗ tree<br>.<br>├── Cargo<span class="hljs-selector-class">.lock</span><br>├── Cargo<span class="hljs-selector-class">.toml</span><br>├── LICENSE-MIT<br>├── README<span class="hljs-selector-class">.md</span><br>├── <span class="hljs-attribute">src</span><br>│   ├── index<span class="hljs-selector-class">.rs</span><br>│   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.rs</span><br>│   ├── merge<span class="hljs-selector-class">.rs</span><br>│   ├── read<span class="hljs-selector-class">.rs</span><br>│   ├── tmp<span class="hljs-selector-class">.rs</span><br>│   └── write.rs<br></code></pre></td></tr></table></figure><p>书中给出的源码并没有实现使用构建好的索引文件进行搜索的功能，笔者将在此基础上实现该功能，所以对代码结构进行了简单的调整：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  inverted_index git:(master) ✗ tree<br>.<br>├── Cargo<span class="hljs-selector-class">.lock</span><br>├── Cargo<span class="hljs-selector-class">.toml</span><br>├── index<span class="hljs-selector-class">.bat</span><br>├── <span class="hljs-attribute">src</span><br>│   ├── bin<br>│   │   ├── create<span class="hljs-selector-class">.rs</span><br>│   │   └── search<span class="hljs-selector-class">.rs</span><br>│   ├── index<span class="hljs-selector-class">.rs</span><br>│   ├── lib<span class="hljs-selector-class">.rs</span><br>│   ├── merge<span class="hljs-selector-class">.rs</span><br>│   ├── read<span class="hljs-selector-class">.rs</span><br>│   ├── tmp<span class="hljs-selector-class">.rs</span><br>│   └── write<span class="hljs-selector-class">.rs</span><br>└── texts<br>    ├── text1<span class="hljs-selector-class">.txt</span><br>    ├── text2<span class="hljs-selector-class">.txt</span><br>    └── text3.txt<br></code></pre></td></tr></table></figure><p>可以看到我将核心代码从 <code>bin</code> 改成了 <code>lib</code>，这是为了支持我后面要实现的两个 <code>bin</code>:</p><ul><li><code>create</code>: 构建索引，基本上就是源代码中的<code>main.rs</code></li><li><code>search</code>: 基于生成的索引文件实现搜索功能</li></ul><p><code>texts</code> 是我提供的文本文件样例。</p><p><code>src</code> 目录中的代码阅读顺序及功能划分如下：</p><ul><li><code>index</code>: 定义了内存索引数据结构InMemoryIndex，实现了从文件内容中构建内存索引的基本逻辑，也实现了从索引文件重建内存索引的功能。</li><li><code>tmp</code>: 定义了临时目录数据结构TmpDir，用于存放临时索引文件。</li><li><code>write</code>: 定义了索引文件写入器 IndexFileWriter，实现了将InMemoryIndex 写入文件中的逻辑。</li><li><code>merge</code>: 定义了文件合并器 FileMerge，用于合并 TmpDir的所有索引文件。</li><li><code>read</code>: 定义了索引文件读取器IndexFileWrite，实现了解析索引文件的逻辑。</li></ul><h2 id="项目准备">项目准备</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new --lib inverted_index_concurrency<br></code></pre></td></tr></table></figure><p>Cargo.toml</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;inverted-index-concurrency&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><span class="hljs-attr">license</span> = <span class="hljs-string">&quot;mit&quot;</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">&quot;hedon&quot;</span>]<br><span class="hljs-attr">description</span> = <span class="hljs-string">&quot;a tool to concurrently build an inverted index.&quot;</span><br><br><span class="hljs-section">[[bin]]</span><br><span class="hljs-attr">name</span>=<span class="hljs-string">&quot;create&quot;</span><br><span class="hljs-attr">path</span>=<span class="hljs-string">&quot;src/bin/create.rs&quot;</span><br><br><span class="hljs-section">[[bin]]</span><br><span class="hljs-attr">name</span>=<span class="hljs-string">&quot;search&quot;</span><br><span class="hljs-attr">path</span>=<span class="hljs-string">&quot;src/bin/search.rs&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">byteorder</span> = <span class="hljs-string">&quot;1.5.0&quot;</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.4&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><h2 id="lib.rs">lib.rs</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> index;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> merge;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> read;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> tmp;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> write;<br></code></pre></td></tr></table></figure><p>在 <code>lib.rs</code> 中我们将这 5 个 mod 公开出去，这样就可以给<code>bin</code> 目录中的 <code>crate.rs</code> 和<code>search.rs</code> 使用了。</p><h2 id="index.rs">index.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/index.rs">index.rs</a></p></blockquote><p>第一部分是内存索引的构建。</p><h3 id="tokenize">tokenize</h3><p>我们先定义一个分词函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tokenize</span>(text: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;(&amp;<span class="hljs-type">str</span>, <span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>)&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">res</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">token_start</span> = <span class="hljs-literal">None</span>;<br>    <span class="hljs-keyword">for</span> (idx, ch) <span class="hljs-keyword">in</span> text.<span class="hljs-title function_ invoke__">char_indices</span>() &#123;<br>        <span class="hljs-keyword">match</span> (ch.<span class="hljs-title function_ invoke__">is_alphanumeric</span>(), token_start) &#123;<br>            (<span class="hljs-literal">true</span>, <span class="hljs-literal">None</span>) =&gt; token_start = <span class="hljs-title function_ invoke__">Some</span>(idx),  <span class="hljs-comment">// 每个单词的开始</span><br>            (<span class="hljs-literal">false</span>, <span class="hljs-title function_ invoke__">Some</span>(start)) =&gt; &#123;  <span class="hljs-comment">// 每个单词的结尾</span><br>                res.<span class="hljs-title function_ invoke__">push</span>((&amp;text[start..idx], start, idx - <span class="hljs-number">1</span>));<br>                token_start = <span class="hljs-literal">None</span><br>            &#125;<br>            _ =&gt; &#123;&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(start) = token_start &#123;<br>        res.<span class="hljs-title function_ invoke__">push</span>((&amp;text[start..], start, text.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>))<br>    &#125;<br>    res<br>&#125;<br></code></pre></td></tr></table></figure><p>这个分词函数跟书中源码提供的不一样，为了实现文本高亮，我们需要记录每个分词在原文本中的起始位置和结束位置。它的核心逻辑如下：</p><ol type="1"><li><p>通过 <code>char_indices()</code> 获取 <code>text</code>的字符迭代器，这是一种懒加载的方法，避免一次性将所有 char加载到内存中。</p></li><li><p>匹配 <code>(ch.is_alphanumeric(), token_start)</code>：</p><ul><li>如果是 <code>(true, None)</code>则表示这是一个单词的开始，我们纪录其开始的位置<code>Some(idx)</code>；</li><li>如果是 <code>(false, Some(idx))</code>则表示这是一个单词的结束，我们将其加入到 <code>res</code>中，并记录起始位置和结束位置。</li><li>其他情况，不做处理，要么是非法字符，要么是处于单词中间。</li></ul><p>从这个简单的理解中，你应该可以感受到 Rust 中 match pattern的强大和便捷了，666 👍🏻</p></li></ol><h3 id="struct-inmemoryindex">struct: InMemoryIndex</h3><p>在 <code>index.rs</code> 中，我们定义了三个数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">InMemoryIndex</span> &#123;<br>    <span class="hljs-keyword">pub</span> word_count: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> terms: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;Hit&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> docs: HashMap&lt;<span class="hljs-type">usize</span>, Document&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Document</span> &#123;<br>    <span class="hljs-keyword">pub</span> id: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> path: PathBuf,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Hit</span> = <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;;<br></code></pre></td></tr></table></figure><ul><li><p><code>Document</code>: 文档封装。</p><ul><li><code>id</code>: 文档 id，唯一标识符。</li><li><code>path</code>: 源文件路径。</li></ul></li><li><p><code>Hit</code>:它是一个字节数组，我们按照小端序进行存储，它的存储结构如下：</p><ul><li>[0..3] 存储一个 <code>HITS_SEPERATOR = -1</code>，表示一个<code>Hit</code> 的开始。</li><li>[4..7] 存储一个 u32 的 <code>document_id</code>。</li><li>后面每 8 个 u8 会存在一个 u32 的 <code>start_pos</code> 和一个 u32的 <code>end_pos</code>。</li></ul></li><li><p><code>InMemoryIndex</code>: 内存索引。</p><ul><li><code>word_count</code>:包含的单词（word/term）个数，记录它是为了判断索引是否过大，以便对索引进行分片存储。</li><li><code>terms</code>: 存储 word 到 Hits 的映射，每个 <code>word</code>是一个搜索项。</li><li><code>docs</code>: 存储了 document_id到文档的映射，用于查询原始文档信息。</li></ul></li></ul><p>接下来我们来为 <code>InMemoryIndex</code>实现一系列方法，因为我们期望使用小端序存储 <code>Hit</code>中的数据，所以我们需要引入 <code>byteorder</code> 这个 crate:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add byteorder<br></code></pre></td></tr></table></figure><p>具体实现可参考源码，核心逻辑是 <code>from_single_document</code> 和<code>merge</code>。</p><h3 id="from_single_document">from_single_document</h3><p><strong>from_single_document</strong>的核心逻辑在这一段，它其实跟我们之前实现的简易版倒排索引很相似：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> (token, start_pos, end_pos) <span class="hljs-keyword">in</span> tokens.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hits</span> = index.terms.<span class="hljs-title function_ invoke__">entry</span>(token.<span class="hljs-title function_ invoke__">to_string</span>()).<span class="hljs-title function_ invoke__">or_insert_with</span>(|| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hits</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span>);<br>        hits.write_i32::&lt;LittleEndian&gt;(<span class="hljs-keyword">Self</span>::HITS_SEPERATOR)<br>            .<span class="hljs-title function_ invoke__">unwrap</span>();<br>        hits.write_u32::&lt;LittleEndian&gt;(document_id).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-built_in">vec!</span>[hits]<br>    &#125;);<br><br>    hits[<span class="hljs-number">0</span>].write_u32::&lt;LittleEndian&gt;(*start_pos <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    hits[<span class="hljs-number">0</span>].write_u32::&lt;LittleEndian&gt;(*end_pos <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    index.word_count += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>遍历每个 <code>token</code> 和它在文本中的位置。</li><li>对于每个 <code>token</code>，尝试在索引的 <code>map</code>中查找一个现有的条目。如果不存在，则创建一个新的 <code>Hit</code>记录，并初始化它：<ul><li>创建一个新的 <code>Hit</code> 向量，预留 24字节的容量，这是因为至少要存储 1 个分隔符、1 个 document_id、1 个start_pos 和 1 个 end_pos。</li><li>首先写入 <code>HITS_SEPERATOR</code> 和<code>document_id</code>（使用小端序）。</li></ul></li><li>向对应的 <code>Hit</code> 向量中添加当前单词的位置。</li><li>累加处理的单词总数到 <code>index.word_count</code>。</li></ul><p>这里给个示例，希望可以帮助你理解 <code>InMemoryIndex</code>的内存结构：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">InMemoryIndex</span><br><span class="hljs-string">│</span><br><span class="hljs-string">├──</span> <span class="hljs-attr">word_count:</span> <span class="hljs-string">usize</span><br><span class="hljs-string">│</span><br><span class="hljs-string">├──</span> <span class="hljs-attr">terms:</span> <span class="hljs-string">HashMap&lt;String,</span> <span class="hljs-string">Vec&lt;Hit&gt;&gt;</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span><br><span class="hljs-string">│</span>   <span class="hljs-string">├──</span> <span class="hljs-attr">Key:</span> <span class="hljs-string">&quot;example&quot;</span> <span class="hljs-string">(String)</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Vec&lt;Hit&gt;</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span>       <span class="hljs-string">├──</span> [<span class="hljs-string">HITS_SEPERATOR</span>, <span class="hljs-attr">Document ID:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">Positions:</span> [<span class="hljs-number">10</span>, <span class="hljs-number">19</span>, <span class="hljs-number">30</span>, <span class="hljs-number">39</span>]] <span class="hljs-string">(Hit)</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span>       <span class="hljs-string">└──</span> [<span class="hljs-string">HITS_SEPERATOR</span>, <span class="hljs-attr">Document ID:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">Positions:</span> [<span class="hljs-number">15</span>, <span class="hljs-number">25</span>]] <span class="hljs-string">(Hit)</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span><br><span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-attr">Key:</span> <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-string">│</span>       <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Vec&lt;Hit&gt;</span><br><span class="hljs-string">│</span>           <span class="hljs-string">└──</span> [<span class="hljs-string">HITS_SEPERATOR</span>, <span class="hljs-attr">Document ID:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">Positions:</span> [<span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">50</span>, <span class="hljs-number">69</span>]] <span class="hljs-string">(Hit)</span><br><span class="hljs-string">│</span><br><span class="hljs-string">└──</span> <span class="hljs-attr">docs:</span> <span class="hljs-string">HashMap&lt;u32,</span> <span class="hljs-string">Document&gt;</span><br>    <span class="hljs-string">├──</span> <span class="hljs-attr">Key:</span> <span class="hljs-number">1</span> <span class="hljs-string">(u32)</span><br>    <span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Document</span> &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;path/to/file1.txt&quot;</span>&#125;<br>    <span class="hljs-string">└──</span> <span class="hljs-attr">Key:</span> <span class="hljs-number">2</span><br>        <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Document</span> &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;path/to/file2.txt&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="merge">merge</h3><p><strong>merge</strong> 是用于合并多个<code>InMemoryIndex</code>，起到批处理的目的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, other: InMemoryIndex) &#123;<br>    <span class="hljs-keyword">for</span> (term, hits) <span class="hljs-keyword">in</span> other.terms &#123;<br>        <span class="hljs-keyword">self</span>.terms.<span class="hljs-title function_ invoke__">entry</span>(term).<span class="hljs-title function_ invoke__">or_default</span>().<span class="hljs-title function_ invoke__">extend</span>(hits)<br>    &#125;<br>    <span class="hljs-keyword">self</span>.word_count += other.word_count;<br>    <span class="hljs-keyword">self</span>.docs.<span class="hljs-title function_ invoke__">extend</span>(other.docs);<br>&#125;<br></code></pre></td></tr></table></figure><p>实现完了 <code>InMemoryIndex</code> 后，我们就可以先来完成<code>create.rs</code> 的 <code>run_pipeline</code> 的前 3个阶段了。</p><h3 id="step1-start_file_reader_thread">step1:start_file_reader_thread</h3><ol type="1"><li>读取文件信息：我们需要在独立的线程中依次打开给定的文件列表，并将文件内容读取到一个String 中，并利用 channel 传送出去。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_reader_thread</span>(<br>    documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;(PathBuf, <span class="hljs-type">String</span>)&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handler</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">filename</span> <span class="hljs-keyword">in</span> documents &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(filename.<span class="hljs-title function_ invoke__">clone</span>())?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>            f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> text)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>((filename, text)).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br><br>    (receiver, handler)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="step2-start_file_indexing_thread">step2:start_file_indexing_thread</h3><ol start="2" type="1"><li>构建索引：通过 channel 从第 1 阶段中获取文档文本信息，通过from_single_document 构建索引 InMemoryIndex 后，将索引通过 channel传送出去。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_indexing_thread</span>(<br>    docs: Receiver&lt;(PathBuf, <span class="hljs-type">String</span>)&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handler</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> (doc_id, (path, text)) <span class="hljs-keyword">in</span> docs.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_single_document</span>(doc_id <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>, path, text);<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    (receiver, handler)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="step3-start_in_memory_merge_thread">step3:start_in_memory_merge_thread</h3><ol start="3" type="1"><li>合并索引：通过 channel 从第 2 阶段中获得构建的 InMemoryIndex并将其合并成大索引，然后通过 channel 传送出去。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_in_memory_merge_thread</span>(<br>    indexes: Receiver&lt;InMemoryIndex&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">accumulated_index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> indexes &#123;<br>            accumulated_index.<span class="hljs-title function_ invoke__">merge</span>(i);<br>            <span class="hljs-keyword">if</span> accumulated_index.<span class="hljs-title function_ invoke__">is_large</span>() &#123;<br>                <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                accumulated_index = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !accumulated_index.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index);<br>        &#125;<br>    &#125;);<br><br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><big><strong>补充：为什么采用这种“复杂”的方式来存储数据呢？可否使用JSON 或者 Protobuf 呢？</strong></big></p><p>选择如何组织和存储数据，特别是在实现一个搜索引擎或数据库索引时，是一个关键决策，这会直接影响到程序的性能、可维护性以及扩展性。在这些情况下，使用像<code>byteorder</code> 这样的低级数据格式存储索引信息可能比使用 JSON 或Protobuf 等高级格式更有优势。</p><p>读写速度：</p><ul><li><strong>二进制格式</strong>：直接操作二进制格式通常比解析文本或半结构化的数据格式（如JSON）要快，因为它减少了解析时间和内存使用。在二进制格式中，数据通常是紧密打包的，没有额外的格式标记（如JSON 中的花括号和逗号），这减少了磁盘 I/O 需求。</li><li><strong>文本/半结构化格式</strong>：例如JSON，每次读取时都需要解析文本，转换数据类型，这会增加 CPU的负担，尤其是在大规模数据处理时。</li></ul><p>空间效率：</p><ul><li><strong>二进制格式</strong>：使用最少的字节表示数据，例如使用定长的整数存储文档ID 和位置索引，不仅节省空间，还能提高缓存利用率。</li><li><strong>文本/半结构化格式</strong>：文本格式需要存储额外的字符来标识数据（例如引号和键名），这增加了存储需求。</li></ul><p>适用场景：</p><ul><li><strong>二进制格式</strong>：非常适合需要高性能和大数据处理的后端系统，如搜索引擎和数据库索引。这种格式可以有效地支持快速的数据读取和写入，特别是在资源受限的环境中（如嵌入式系统或低延迟应用）。</li><li><strong>JSON/Protobuf</strong>：更适合需要跨平台兼容性和易于调试的应用场景。例如，在Web 应用中使用 JSON 作为数据交换格式，可以简化前后端的集成和测试。</li></ul>          </div><h2 id="tmp.rs">tmp.rs</h2><p>完成内存索引的构建后，我们需要将构建过程中产生的大索引先临时落盘，后面再进行合并。为了临时存储这些数据文件，我们需要将他们放在一个临时目录中，为此，我们定义了<code>TmpDir</code> 数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TmpDir</span> &#123;<br>    dir: PathBuf,<br>    n: <span class="hljs-type">usize</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>dir</code>: 目录</li><li><code>n</code>: 自增器，用于区分临时文件命名</li></ul><p>接下来为 <code>TmpDir</code> 实现 2 个方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">TmpDir</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>&lt;P: <span class="hljs-built_in">AsRef</span>&lt;Path&gt;&gt;(dir: P) <span class="hljs-punctuation">-&gt;</span> TmpDir &#123;<br>        TmpDir &#123;<br>            dir: dir.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">to_owned</span>(),<br>            n: <span class="hljs-number">1</span>,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">create</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;(PathBuf, BufWriter&lt;File&gt;)&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">r</span>#<span class="hljs-keyword">try</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">filename</span> = <span class="hljs-keyword">self</span><br>                .dir<br>                .<span class="hljs-title function_ invoke__">join</span>(PathBuf::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;tmp&#123;:08x&#125;.dat&quot;</span>, <span class="hljs-keyword">self</span>.n)));<br>            <span class="hljs-keyword">self</span>.n += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">match</span> fs::OpenOptions::<span class="hljs-title function_ invoke__">new</span>()<br>                .<span class="hljs-title function_ invoke__">write</span>(<span class="hljs-literal">true</span>)<br>                .<span class="hljs-title function_ invoke__">create_new</span>(<span class="hljs-literal">true</span>)<br>                .<span class="hljs-title function_ invoke__">open</span>(&amp;filename)<br>            &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(f) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>((filename, BufWriter::<span class="hljs-title function_ invoke__">new</span>(f))),<br>                <span class="hljs-title function_ invoke__">Err</span>(exc) =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> r#<span class="hljs-keyword">try</span> &lt; <span class="hljs-number">999</span> &amp;&amp; exc.<span class="hljs-title function_ invoke__">kind</span>() == io::ErrorKind::AlreadyExists &#123;<br>                        <span class="hljs-comment">// keep going</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(exc);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            r#<span class="hljs-keyword">try</span> += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>new</strong> 方法是 <code>TmpDir</code>的构造函数，其中我们将 <code>n</code> 设置为 1，即文件名从 1开始生成。<code>dir.as_ref().to_owned()</code>接受一个可能是任何类型的路径，将其标准化为一个 <code>Path</code>类型的引用，然后再复制这个引用，创建一个完全独立的、拥有所有权的<code>PathBuf</code> 对象，</p><p><strong>create</strong> 方法是在 <code>TmpDir</code>目录下创建一个临时文件。</p><h2 id="write.rs">write.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/write.rs">write.rs</a></p></blockquote><p>准备好内存索引和临时文件，那我们就需要实现将内存索引写入到文件中的功能了。</p><h3 id="struct-inmemoryindex-1">struct: InMemoryIndex</h3><p>我们先来分析一下如何将 <code>InMemoryIndex</code> 落盘。首先<code>InMemoryIndex</code> 的结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">InMemoryIndex</span> &#123;<br>    <span class="hljs-keyword">pub</span> word_count: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> terms: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;Hit&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> docs: HashMap&lt;<span class="hljs-type">u32</span>, Document&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Document</span> &#123;<br>    <span class="hljs-keyword">pub</span> id: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> path: PathBuf,<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>word_count</code>不需要存储，我们可以计算出来。那我们就需要存储索引 <code>map</code>和文档原数据 <code>docs</code>。为了能精确定位到各个数据，我们需要：</p><p>terms:</p><ul><li>写入 Vec&lt;Hit&gt;</li></ul><p>docs:</p><ul><li>写入 docs 中的每个 Document<ul><li>写入 id</li><li>写入 path 大小</li><li>写入 path</li></ul></li></ul><p>而为了快速定位到每个 term 和 doc的位置，我们需要下面几个值，这几个值将组合起来辅助我们快速定位 terms 或docs，我们后面会将其称为 <strong>Entry</strong>，它包含以下几个值：</p><ul><li><code>term</code>: 索引单词。为了统一，如果 <code>term</code>为空，则表示当前表示的是 doc，否则为 terms。</li><li><code>df</code>: term 的出现次数。为了统一，如果 <code>df</code> 为0，则表示当前表示的是 doc，否则为 terms。</li><li><code>offset</code>: 对应的 terms 或 docs 在文件中的偏移。</li><li><code>nbytes</code>: 对应的 terms 或 docs 的总长度。</li></ul><p>所以文件的内存结构大概如下：</p><table><thead><tr class="header"><th>文件区域</th><th>描述</th><th>指向内容</th></tr></thead><tbody><tr class="odd"><td>头部 （8 字节）</td><td>包含一个指向目录表开始位置的偏移量。</td><td>header</td></tr><tr class="even"><td>主条目</td><td>这些条目按顺序紧密存储，没有额外的元数据。这部分包含实际的数据条目。</td><td>terms + docs</td></tr><tr class="odd"><td>目录表</td><td>存储在文件的最后，包括每个条目的术语信息、文档频率、偏移和大小。</td><td>entries</td></tr></tbody></table><p>示意图如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423194529529.png"alt="索引文件内存结构示意图" /><figcaption aria-hidden="true">索引文件内存结构示意图</figcaption></figure><p>为此我们定义了 <code>IndexFileWriter</code>，它专门用于将<code>InMemoryIndex</code> 写入到临时文件中，定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// A structure to manage writing to an index file efficiently.</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IndexFileWriter</span> &#123;<br>    offset: <span class="hljs-type">u64</span>,<br>    writer: BufWriter&lt;File&gt;,<br>    contents_buf: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>offset</code>: 用于追踪文件中当前的写入位置。</li><li><code>writer</code>:一个缓冲写入器，它包装了一个文件，用于输出操作。</li><li><code>contents_buf</code>:一个向量，用来存储内容条目，在全部写入文件之前暂存在这个缓冲区。</li></ul><p>接下来我们为 <code>IndexFileWriter</code> 实现几个方法：</p><ul><li><code>new</code>:这是一个构造函数，它初始化文件并设置初始偏移量。在文件的开始处写入一个占位符作为头部，这个头部最终会存储主数据区的大小。</li><li><code>write_document</code>:用于将一个文档以二进制格式写入到文件中，同时更新偏移量。</li><li><code>write_main</code>:这个方法接受一段数据，并将它写入文件中，同时更新偏移量。</li><li><code>write_contents_entry</code>: 将一个内容 Entry追加到内部的缓冲区中。Entry包括一个术语、文档频率、术语数据的起始偏移和大小，它用于快速定位 terms或 docs。</li><li><code>finish</code>:完成文件写入过程，将内部缓冲区的内容写入文件，并更新文件头部的主数据大小。</li></ul><h3 id="new">new</h3><p>我们先来看构造方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(<span class="hljs-keyword">mut</span> f: BufWriter&lt;File&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;IndexFileWriter&gt; &#123;<br>    <span class="hljs-keyword">const</span> HEADER_SIZE: <span class="hljs-type">u64</span> = <span class="hljs-number">8</span>;<br>    f.write_u64::&lt;LittleEndian&gt;(<span class="hljs-number">0</span>)?; <span class="hljs-comment">// content start</span><br>    <span class="hljs-title function_ invoke__">Ok</span>(IndexFileWriter &#123;<br>        offset: HEADER_SIZE,<br>        writer: f,<br>        contents_buf: <span class="hljs-built_in">vec!</span>[],<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>new</strong> 分为以下几步：</p><ol type="1"><li><strong>定义头部大小</strong>：<code>const HEADER_SIZE: u64 = 8;</code>：定义一个常量<code>HEADER_SIZE</code>，其值为 8字节，这表示文件头部的大小。这个头部将用于后续在文件的开始处写入主数据区的起始位置。</li><li><strong>写入头部占位符</strong>：<code>f.write_u64::&lt;LittleEndian&gt;(0)?;</code>：在文件的开始处写入一个8字节的占位符，这个值是以小端字节序（<code>LittleEndian</code>）存储的。初始时这里写入的是0，意味着“主数据区的起始位置未知”，这个值在后续的 <code>finish</code>函数中会被更新。</li><li><strong>返回一个新的 IndexFileWriter实例</strong>：<code>Ok(IndexFileWriter &#123; offset: HEADER_SIZE, writer: f, contents_buf: vec![], &#125;)</code>：构造并返回一个<code>IndexFileWriter</code> 实例。这个实例的 <code>offset</code>字段被初始化为 <code>HEADER_SIZE</code>（8字节），表示实际数据将从文件的第 17 个字节开始写入。<code>writer</code>字段就是传入的文件写入器，<code>contents_buf</code>是一个新的空向量，用于临时存储内容条目数据。</li></ol><div class="note note-info">            <p><big><strong>为什么这样设计？</strong></big></p><p>这个实现方式有几个设计上的考虑：</p><ol type="1"><li><strong>预留头部空间</strong>：通过在文件开始处预留 8字节空间来存储主数据区的大小，这样做可以在数据写入完成后，方便地回填这个信息。这是文件格式设计中常见的做法，允许读取者快速定位主数据区和内容索引区。</li><li><strong>使用小端字节序</strong>：小端字节序是一种在二进制文件中常用的字节序，尤其是在Windows平台下。使用小端字节序可以提高文件的兼容性，并且对于多数处理器架构来说，小端字节序的读写操作更为高效。</li><li><strong>灵活的数据写入</strong>：通过将 <code>writer</code> 和<code>contents_buf</code>组合使用，这个结构体可以灵活地处理不同的数据写入需求。<code>writer</code>直接写入文件，适合连续大块数据的写入；而 <code>contents_buf</code>用于聚集多个小片段的数据，可以在最后统一写入，减少磁盘操作次数。</li></ol><p>总的来说，这个构造函数的实现为高效和灵活的文件写操作提供了良好的基础，同时通过合理的错误处理和数据组织方式，确保了程序的健壮性和高性能。</p>          </div><h3 id="write_main">write_main</h3><p>Hit 本身就是一个 Vec&lt;u8&gt;， 将其写入文件很简单，调用<code>write_all</code>，即可，我们为其封装 <code>write_main</code>方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_main</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">write_all</span>(buf)?;<br>    <span class="hljs-keyword">self</span>.offset += buf.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="write_document">write_document</h3><p>为了将 Docuemnt本以二进制结构写入到文件中，我们需要拆分成几个部分：</p><ol type="1"><li>文件 id</li><li>文件路径大小</li><li>文件路径</li></ol><p>为此我们为 <code>IndexFileWriter</code> 封装了<code>write_document</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_document</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, doc: &amp;Document) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.writer.write_u32::&lt;LittleEndian&gt;(doc.id)?;<br>    <span class="hljs-keyword">self</span>.writer<br>        .write_u64::&lt;LittleEndian&gt;(doc.path.<span class="hljs-title function_ invoke__">as_os_str</span>().<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>)?;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">write_all</span>(doc.path.<span class="hljs-title function_ invoke__">as_os_str</span>().<span class="hljs-title function_ invoke__">as_bytes</span>())?;<br>    <span class="hljs-keyword">self</span>.offset += <span class="hljs-number">4</span> + <span class="hljs-number">8</span> + doc.path.<span class="hljs-title function_ invoke__">as_os_str</span>().<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="write_contents_entry">write_contents_entry</h3><p>Entry的数据量一般较小，我们会先写入缓冲中，后面再一次性刷盘，为此我们为<code>IndexFileWriter</code> 封装了<code>write_contents_entry</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Appends a content entry to the internal buffer.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// # Arguments</span><br><span class="hljs-comment">/// * `term` - The term associated with the entry</span><br><span class="hljs-comment">/// * `df` - Document frequency for the term</span><br><span class="hljs-comment">/// * `offset` - Offset where the term data starts in the file</span><br><span class="hljs-comment">/// * `nbytes` - Number of bytes of the term data</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_contents_entry</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, term: <span class="hljs-type">String</span>, df: <span class="hljs-type">u32</span>, offset: <span class="hljs-type">u64</span>, nbytes: <span class="hljs-type">u64</span>) &#123;<br>    <span class="hljs-keyword">self</span>.contents_buf.write_u64::&lt;LittleEndian&gt;(offset).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf.write_u64::&lt;LittleEndian&gt;(nbytes).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf.write_u32::&lt;LittleEndian&gt;(df).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = term.<span class="hljs-title function_ invoke__">bytes</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf<br>        .write_u32::&lt;LittleEndian&gt;(bytes.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>)<br>        .<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf.<span class="hljs-title function_ invoke__">extend</span>(bytes);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="finish">finish</h3><p>刷盘的过程我们封装在 <code>finish</code> 中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">finish</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contents_start</span> = <span class="hljs-keyword">self</span>.offset;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">write_all</span>(&amp;<span class="hljs-keyword">self</span>.contents_buf)?;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">seek</span>(SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(<span class="hljs-number">0</span>))?;<br>    <span class="hljs-keyword">self</span>.writer.write_u64::&lt;LittleEndian&gt;(contents_start)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="write_index_to_tmp_file">write_index_to_tmp_file</h3><p>综合下来，我们就可以实现最核心的函数<code>write_index_to_tmp_file</code> 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_index_to_tmp_file</span>(index: InMemoryIndex, tmp_dir: &amp;<span class="hljs-keyword">mut</span> TmpDir) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;PathBuf&gt; &#123;<br>    <span class="hljs-keyword">let</span> (filename, f) = tmp_dir.<span class="hljs-title function_ invoke__">create</span>()?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">writer</span> = IndexFileWriter::<span class="hljs-title function_ invoke__">new</span>(f)?;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index_as_vec</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = index.terms.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    index_as_vec.<span class="hljs-title function_ invoke__">sort_by</span>(|(a, _), (b, _)| a.<span class="hljs-title function_ invoke__">cmp</span>(b));<br><br>    <span class="hljs-keyword">for</span> (term, hits) <span class="hljs-keyword">in</span> index_as_vec &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">df</span> = hits.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span> = writer.offset;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">buffer</span> <span class="hljs-keyword">in</span> hits &#123;<br>            writer.<span class="hljs-title function_ invoke__">write_main</span>(&amp;buffer)?;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stop</span> = writer.offset;<br>        writer.<span class="hljs-title function_ invoke__">write_contents_entry</span>(term, df, start, stop - start);<br>    &#125;<br><br>    <span class="hljs-comment">// if term == &quot;&quot; &amp;&amp; df == 0 &#123; type = document &#125;</span><br>    <span class="hljs-keyword">for</span> (_, doc) <span class="hljs-keyword">in</span> index.docs &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span> = writer.offset;<br>        writer.<span class="hljs-title function_ invoke__">write_document</span>(&amp;doc)?;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stop</span> = writer.offset;<br>        writer.<span class="hljs-title function_ invoke__">write_contents_entry</span>(<span class="hljs-string">&quot;&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">0</span>, start, stop - start)<br>    &#125;<br><br>    writer.<span class="hljs-title function_ invoke__">finish</span>()?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;wrote file &#123;:?&#125;&quot;</span>, filename);<br>    <span class="hljs-title function_ invoke__">Ok</span>(filename)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>我们在临时目录中创建一个临时文件，并初始化 IndexFileWriter；</li><li>将索引的 <code>terms</code> 转换成一个向量并按照键排序；</li><li>对于每个<code>term</code>，计算文档频率（<code>df</code>），记录开始和结束位置，然后调用<code>write_main</code> 方法将数据写入文件，然后使用<code>write_contents_entry</code> 方法写入 <code>Entry</code>的元数据到目录表；</li><li>对于 <code>index.docs</code>中的每个文档，计算起止位置，并使用一个特殊的条目（空字符串作为条目名和 0作为文档频率）标记在文件中；</li><li>最后我们使用 <code>finish</code> 将缓存中所有的 <code>Entry</code>刷盘，并设置 <code>entries</code> 的起始位置。</li></ol><p>文件的内存结构如上面给出的图一样，这里我们可以再看一次：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423194529529-20240423195227516.png"alt="索引文件内存结构示意图" /><figcaption aria-hidden="true">索引文件内存结构示意图</figcaption></figure><h3 id="step4-start_index_writer_thread">step4:start_index_writer_thread</h3><p>实现了将内存索引写入到文件的功能后，我们就可以继续在<code>create.rs</code> 中实现下一个流程了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_index_writer_thread</span>(<br>    big_indexes: Receiver&lt;InMemoryIndex&gt;,<br>    output_dir: &amp;Path,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;PathBuf&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp_dir</span> = TmpDir::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> big_indexes &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;word count: &#123;&#125;&quot;</span>, i.word_count);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(i, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(file).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br><br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>start_index_writer_thread</code>流程中，我们将构建好的内存索引一个个写入到文件中，并将生成的文件句柄传入下一个流程。</p><h2 id="merge.rs">merge.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/merge.rs">merge.rs</a></p></blockquote><p>前面 <code>start_index_writer_thread</code> 是将一个个<code>InMemoryIndex</code> 写入到 <code>TmpDir</code>临时目录中。现在我们要将这些临时文件合并成一个最终的索引文件，以优化查询效率和节省存储空间。</p><h3 id="srtuct-filemerge">srtuct: FileMerge</h3><p>我们定义一下结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">FileMerge</span> &#123;<br>    output_dir: PathBuf,<br>    tmp_dir: TmpDir,<br>    stacks: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;PathBuf&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>output_dir</code>: 用于存储最终合并文件的输出目录。</li><li><code>tmp_dir</code>: 前面 <code>tmp.rs</code>定义的结构，用于管理合并过程中产生的临时文件。</li><li><code>stacks</code>:这是一个二维向量，每个内部向量代表一个合并“层”，存储了该层待合并的文件路径。</li></ul><p>关于 <code>stacks</code>，再多说两点：</p><ul><li><strong>多级合并策略</strong>: <code>FileMerge</code>使用一个多层合并策略，这种策略在处理大量文件时尤为有效。基本思想是，当一层的文件数量达到一个预设的阈值（<code>NSTREAMS</code>）时，这些文件会被合并成一个新的文件，新文件则被推送到上一层。这种层级式的处理方式可以显著减少最终合并步骤需要处理的文件数量，从而优化性能。</li><li><strong>动态扩展</strong>：使用<code>Vec&lt;Vec&lt;PathBuf&gt;&gt;</code>允许动态地添加新的合并层，这在处理不确定数量的文件时非常有用。向量的灵活性意味着无需预先知道将处理多少文件，它可以根据实际需要进行扩展。</li></ul><p>接下来我们会为 <code>FileMerge</code> 实现 2 个方法：</p><ul><li><code>add_file</code>:添加一个文件到合并栈中，并使用多级合并策略进行合并。</li><li><code>finish</code>: 执行最后的合并操作，生成最终的索引文件，输出到<code>output_dir</code> 中。</li></ul><h3 id="add_file">add_file</h3><p>首先我们来看<code>add_file</code>，它的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_file</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, <span class="hljs-keyword">mut</span> file: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><span class="hljs-comment">// 从第一层开始检查</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">level</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 使用循环来处理文件的添加和可能的合并。</span><br>    <span class="hljs-keyword">loop</span> &#123;<br><br>      <span class="hljs-comment">// 如果当前的 level （层级）不存在于 stacks 中，</span><br>        <span class="hljs-comment">// 就在 stacks 中添加一个新的空向量。</span><br>        <span class="hljs-comment">// 这是为了存放该层级的文件。</span><br>        <span class="hljs-keyword">if</span> level == <span class="hljs-keyword">self</span>.stacks.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-keyword">self</span>.stacks.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-built_in">vec!</span>[]);<br>        &#125;<br><br>        <span class="hljs-comment">// 将当前的文件添加到对应层级的向量中。</span><br>        <span class="hljs-keyword">self</span>.stacks[level].<span class="hljs-title function_ invoke__">push</span>(file);<br><br>        <span class="hljs-comment">// 如果这个级别的堆栈已满，就合并这个级别的文件。</span><br>      <span class="hljs-comment">// 如果没满，则不进行合并，直接退出。</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.stacks[level].<span class="hljs-title function_ invoke__">len</span>() &lt; NSTREAMS &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建一个新文件来存储合并结果，并更新堆栈。</span><br>        <span class="hljs-keyword">let</span> (filename, out) = <span class="hljs-keyword">self</span>.tmp_dir.<span class="hljs-title function_ invoke__">create</span>()?;<br><br>        <span class="hljs-comment">// 初始化一个空的 to_merge 向量，</span><br>      <span class="hljs-comment">// 然后使用 mem::swap 交换当前层级的文件列表和这个空向量，</span><br>        <span class="hljs-comment">// 这样 to_merge 向量就包含了需要合并的文件，</span><br>        <span class="hljs-comment">// 而当前层级变为空，可以用来存放新的合并文件。</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">to_merge</span> = <span class="hljs-built_in">vec!</span>[];<br>        mem::<span class="hljs-title function_ invoke__">swap</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.stacks[level], &amp;<span class="hljs-keyword">mut</span> to_merge);<br><br>        <span class="hljs-comment">// 调用 merge_streams 函数将 to_merge 中的文件合并到新创建的文件中。</span><br>        <span class="hljs-title function_ invoke__">merge_streams</span>(to_merge, out)?;<br><br>        <span class="hljs-comment">// 将合并后得到的新文件路径赋值给 file 变量，用于下一轮循环。</span><br>        file = filename;<br>        <span class="hljs-comment">// level 加一，表示移动到下一个层级。</span><br>        level += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法通过层级的方式管理文件合并，每个层级可以有多个文件，但数量上限为<code>NSTREAMS</code>。如果某层满了，就将该层的文件合并成一个新文件，并将这个新文件移动到上一层继续参与合并。这种设计有效地将多个文件逐步合并成一个文件，同时控制内存和I/O 资源的使用。</p><p>其中 <code>merge_streams</code>就是具体的合并过程，它的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_streams</span>(files: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, out: BufWriter&lt;File&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>  <span class="hljs-comment">// 从索引文件中构建 IndexFileReader 列表</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">streams</span>: <span class="hljs-type">Vec</span>&lt;IndexFileReader&gt; = files<br>        .<span class="hljs-title function_ invoke__">into_iter</span>()<br>        .<span class="hljs-title function_ invoke__">map</span>(|p| IndexFileReader::<span class="hljs-title function_ invoke__">open_and_delete</span>(p, <span class="hljs-literal">true</span>))<br>        .collect::&lt;io::<span class="hljs-type">Result</span>&lt;_&gt;&gt;()?;<br><br>  <span class="hljs-comment">// 针对输出文件生成一个 IndexFileWriter 用于写入索引信息</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">output</span> = IndexFileWriter::<span class="hljs-title function_ invoke__">new</span>(out)?;<br>  <span class="hljs-comment">// 用于记录当前写入的位置（或者数据偏移量）。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">point</span>: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 记录还有数据未处理的文件流数量，用 peek() 方法检查。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = streams.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|s| s.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">is_some</span>()).<span class="hljs-title function_ invoke__">count</span>();<br><br>  <span class="hljs-comment">// 只要 count 大于0，表示还有文件未完全处理，就继续循环。</span><br>    <span class="hljs-keyword">while</span> count &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">term</span> = <span class="hljs-literal">None</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">nbytes</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">df</span> = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 这段代码通过遍历每个文件流，使用 peek() 方法预览每个文件的当前数据条目</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> &amp;streams &#123;<br>            <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">peek</span>() &#123;<br>                <span class="hljs-literal">None</span> =&gt; &#123;&#125;<br>                <span class="hljs-title function_ invoke__">Some</span>(entry) =&gt; &#123;<br>                  <span class="hljs-comment">// term 是空的，则说明这是表示 doc 的 entry。</span><br>                  <span class="hljs-comment">// 直接退出 for 循环，因为 doc 的 entry 没有顺序且唯一，不会进行累加。</span><br>                    <span class="hljs-keyword">if</span> entry.term.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                        term = <span class="hljs-title function_ invoke__">Some</span>(entry.term.<span class="hljs-title function_ invoke__">clone</span>());<br>                        nbytes = entry.nbytes;<br>                        df = entry.df;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                  <span class="hljs-comment">// term 不是空的，则说明这是表示 terms 的 entry。</span><br>                    <span class="hljs-comment">// 选择词条最小的一个（字典序），并且累加其出现的频次和字节大小。</span><br>                    <span class="hljs-comment">// 这是多路归并的核心，确保输出文件是有序的。</span><br>                    <span class="hljs-keyword">if</span> term.<span class="hljs-title function_ invoke__">is_none</span>() || entry.term &lt; *term.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>() &#123;<br>                        term = <span class="hljs-title function_ invoke__">Some</span>(entry.term.<span class="hljs-title function_ invoke__">clone</span>());<br>                        nbytes = entry.nbytes;<br>                        df = entry.df<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> entry.term == *term.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>() &#123;<br>                        nbytes += entry.nbytes;<br>                        df += entry.df<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">term</span> = term.<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;bug in algorithm&quot;</span>);<br><br>      <span class="hljs-comment">// 对于每个文件流，如果当前数据条目与选择的 term 相同，</span><br>        <span class="hljs-comment">// 则将该条目写入输出文件，并更新该流的读取位置。</span><br>      <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> streams &#123;<br>            <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">is_at</span>(&amp;term) &#123;<br>                s.<span class="hljs-title function_ invoke__">move_entry_to</span>(&amp;<span class="hljs-keyword">mut</span> output)?;<br>                <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>                    count -= <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> term.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        output.<span class="hljs-title function_ invoke__">write_contents_entry</span>(term, df, point, nbytes);<br>        point += nbytes<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到了一个新的结构<code>IndexFileReader</code>，它是索引文件的读取器，我们将在<code>read.rs</code> 中实现它。这里先不展开，你只需要知道：</p><ul><li><code>IndexFileReader::open_and_delete(p, true)</code>:打开一个索引文件，并根据传入的参数判断是否要删除这个文件，在合并过程中，因为都是临时文件，所以我们会指定为删除文件。但是在后面从索引文件中重建<code>InMemoryIndex</code> 的时候，我们不希望删除原始的索引文件。</li><li><code>s.peek()</code>: 查看下一个 Entry，它的返回值是Option&lt;Entry&gt;。</li><li><code>s.move_entry_to(&amp;mut output)</code>: 将<code>s.peek()</code> 指向的 Entry 写入到 output 文件中，并移动到一下Entry。</li></ul><p>总结下来，这个函数实现多路归并的核心部分，它将多个索引文件合并成一个单一的有序文件。</p><h3 id="finish-1">finish</h3><p>我们再来看 <code>FileMerge</code> 的另外一个方法<code>finish</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">finish</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><br>    <span class="hljs-comment">// 初始化一个临时向量 tmp，用来暂存需要合并的文件路径。</span><br>    <span class="hljs-comment">// 这个向量的容量设置为 NSTREAMS，这是预先定义的常量，表示一次可以合并的最大文件数。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(NSTREAMS);<br><br>    <span class="hljs-comment">// 方法遍历 self.stacks 中的每个堆栈。每个堆栈代表一个合并层级，包含若干待合并的文件。</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stack</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.stacks &#123;<br>        <span class="hljs-comment">// 对于每个堆栈，方法使用 .into_iter().rev() 迭代器反向遍历文件，</span><br>      <span class="hljs-comment">// 以确保按正确的顺序处理（先进后出）。</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">file</span> <span class="hljs-keyword">in</span> stack.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>            <span class="hljs-comment">// 将文件逐个添加到 tmp 向量中。</span><br>            tmp.<span class="hljs-title function_ invoke__">push</span>(file);<br>            <span class="hljs-comment">// 当 tmp 的长度达到 NSTREAMS 时，</span><br>          <span class="hljs-comment">// 调用 merge_reversed 函数进行合并。</span><br>            <span class="hljs-keyword">if</span> tmp.<span class="hljs-title function_ invoke__">len</span>() == NSTREAMS &#123;<br>                <span class="hljs-title function_ invoke__">merge_reversed</span>(&amp;<span class="hljs-keyword">mut</span> tmp, &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.tmp_dir)?;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">// 对于剩余文件进行最终的合并。</span><br>    <span class="hljs-keyword">if</span> tmp.<span class="hljs-title function_ invoke__">len</span>() &gt; <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-title function_ invoke__">merge_reversed</span>(&amp;<span class="hljs-keyword">mut</span> tmp, &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.tmp_dir)?;<br>    &#125;<br><br>  <span class="hljs-comment">// 最后应该只有一个最终文件</span><br>    <span class="hljs-built_in">assert!</span>(tmp.<span class="hljs-title function_ invoke__">len</span>() == <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">match</span> tmp.<span class="hljs-title function_ invoke__">pop</span>() &#123;<br>      <span class="hljs-comment">// 对文件进行重命名</span><br>        <span class="hljs-title function_ invoke__">Some</span>(last_file) =&gt; fs::<span class="hljs-title function_ invoke__">rename</span>(last_file, <span class="hljs-keyword">self</span>.output_dir.<span class="hljs-title function_ invoke__">join</span>(MERGED_FILENAME)),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-title function_ invoke__">Err</span>(io::Error::<span class="hljs-title function_ invoke__">new</span>(<br>            io::ErrorKind::Other,<br>            <span class="hljs-string">&quot;no ducuments were parsed or none contained any words&quot;</span>,<br>        )),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到了另外一个函数 <code>merge_reversed</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_reversed</span>(filenames: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, tmp_dir: &amp;<span class="hljs-keyword">mut</span> TmpDir) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    filenames.<span class="hljs-title function_ invoke__">reverse</span>();<br>    <span class="hljs-keyword">let</span> (merge_filename, out) = tmp_dir.<span class="hljs-title function_ invoke__">create</span>()?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">to_merge</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(NSTREAMS);<br>    mem::<span class="hljs-title function_ invoke__">swap</span>(filenames, &amp;<span class="hljs-keyword">mut</span> to_merge);<br>    <span class="hljs-title function_ invoke__">merge_streams</span>(to_merge, out)?;<br>    filenames.<span class="hljs-title function_ invoke__">push</span>(merge_filename);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>它其实就是将 <code>filenames</code> 翻转，清空并将内容转移到<code>to_merge</code>，然后调用 <code>merge_streams</code>合并，并将合并后的文件重新放回被清空的<code>filenames</code>，也就是我们在 <code>finish</code> 中声明的<code>tmp</code> 变量。</p><div class="note note-info">            <p><big><strong>为什么这里需要翻转 filenames？</strong></big></p><p>假设 NSTREAMS = 3，我们执行 <code>add_file</code>，从<code>file1</code> 到 <code>file8</code>，那么过程如下：</p><table><thead><tr class="header"><th>Action</th><th>Stack 0</th><th>Stack 1</th><th>Notes</th></tr></thead><tbody><tr class="odd"><td>Add file1</td><td>file1</td><td></td><td></td></tr><tr class="even"><td>Add file2</td><td>file1, file2</td><td></td><td></td></tr><tr class="odd"><td>Add file3</td><td>file1, file2, file3</td><td></td><td></td></tr><tr class="even"><td>Merge S1</td><td>(empty)</td><td>merge1</td><td><code>merge1</code> is the result of merging file1-file3</td></tr><tr class="odd"><td>Add file4</td><td>file4</td><td>merge1</td><td></td></tr><tr class="even"><td>Add file5</td><td>file4, file5</td><td>merge1</td><td></td></tr><tr class="odd"><td>Add file6</td><td>file4, file5, file6</td><td>merge1</td><td></td></tr><tr class="even"><td>Merge S2</td><td>(empty)</td><td>merge1, merge2</td><td><code>merge2</code> is the result of merging file4-file6</td></tr><tr class="odd"><td>Add file7</td><td>file7</td><td>merge1, merge2</td><td></td></tr><tr class="even"><td>Add file8</td><td>file7, file8</td><td>merge1, merge2</td><td>Trigger merge because 8 files are reached</td></tr></tbody></table><p>最后我们获得的结果是：</p><table><thead><tr class="header"><th>stack0</th><th>stack1</th></tr></thead><tbody><tr class="odd"><td>file7, file8</td><td>merge1, merge2</td></tr></tbody></table><p>按照文件的添加顺序，我们期望在 <code>finish</code>中合并的顺序应该是：merge1, merge2, file7, file8。所以我们遍历<code>stacks</code> 的时候，从第 1 层开始遍历的话，我们就需要反向遍历<code>rev()</code>，这个时候我们组成的 <code>tmp</code> 就是：file8,file7, merge2, merge1。最后我们传入 <code>merge_reversed</code>的时候，再进行 <code>reverse()</code>，就可以获得我们期望的顺序 merge1,merge2, file7, file8。</p>          </div><p>回过头来，我们总结一下<code>finish</code>：这个方法通过多级合并的方式，逐层处理并最终合并所有文件到一个文件。这个方法确保在多个文件频繁合并的环境中，能有效地管理和减少临时存储使用，并保持合并操作的效率。通过最后的重命名操作，它还处理了文件的最终存放，确保合并结果的正确性和可用性。</p><p>实现了 <code>merge.rs</code> 的相关内容，我们就可以来实现<code>create.rs</code> 中的最后一步了。</p><h3 id="step5-merge_index_files">step5: merge_index_files</h3><p>我们将第 4 阶段构建的临时文件合并成一个最终的索引文件并输出到<code>output_dir</code> 目录中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_index_files</span>(files: Receiver&lt;PathBuf&gt;, output_dir: &amp;Path) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">merge</span> = FileMerge::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">file</span> <span class="hljs-keyword">in</span> files &#123;<br>        merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>    &#125;<br>    merge.<span class="hljs-title function_ invoke__">finish</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="run_pipeline">run_pipeline</h3><p>至此，我们就完成了并发构建倒排索引的 5个步骤了，对其进行组织，就可以实现我们的并发构建函数<code>run_pipeline</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_pipeline</span>(documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// Launch all five stages of the pipeline.</span><br>    <span class="hljs-keyword">let</span> (texts, h1) = <span class="hljs-title function_ invoke__">start_file_reader_thread</span>(documents);<br>    <span class="hljs-keyword">let</span> (pints, h2) = <span class="hljs-title function_ invoke__">start_file_indexing_thread</span>(texts);<br>    <span class="hljs-keyword">let</span> (gallons, h3) = <span class="hljs-title function_ invoke__">start_in_memory_merge_thread</span>(pints);<br>    <span class="hljs-keyword">let</span> (files, h4) = <span class="hljs-title function_ invoke__">start_index_writer_thread</span>(gallons, &amp;output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">merge_index_files</span>(files, &amp;output_dir);<br><br>    <span class="hljs-comment">// Wait for threads to finish, holding on to any errors that they encounter.</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = h1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h3.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = h4.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// Return the first error encountered, if any.</span><br>    <span class="hljs-comment">// (As it happens, h2 and h3 can&#x27;t fail: those threads</span><br>    <span class="hljs-comment">// are pure in-memory data processing.)</span><br>    r1?;<br>    r4?;<br>    result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="read.rs">read.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/read.rs">read.rs</a></p></blockquote><p>在 <code>merge.rs</code> 中，我们还剩最后一个结构没有解析，那就是<code>IndexFileReader</code>，它是索引文件的读取器。</p><h3 id="struct-indexfilereader">struct: IndexFileReader</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IndexFileReader</span> &#123;<br>    <span class="hljs-keyword">pub</span> terms_docs: BufReader&lt;File&gt;,<br>    entries: BufReader&lt;File&gt;,<br>    next: <span class="hljs-type">Option</span>&lt;Entry&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">pub</span> term: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> df: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> offset: <span class="hljs-type">u64</span>,<br>    <span class="hljs-keyword">pub</span> nbytes: <span class="hljs-type">u64</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 <code>IndexFileReader</code> 结构体中定义两个<code>BufReader&lt;File&gt;</code>，这是为了有效管理和操作索引文件中的不同数据段。具体来说，这种设计使得代码能够更加灵活和高效地处理索引文件中的“主数据区”和“内容表区”。</p><p>即用来分别处理下图的 <code>terms&amp;doc</code> 和<code>entries</code> 两个区域：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423194529529-20240423195227516.png"alt="索引文件内存结构示意图" /><figcaption aria-hidden="true">索引文件内存结构示意图</figcaption></figure><p>这有几个好处：</p><ul><li><strong>独立的文件指针</strong>：每个<code>BufReader&lt;File&gt;</code>维护自己的文件读取位置（文件指针）。这意味着读取或搜索内容表时，不会影响主数据区的文件指针，反之亦然。这样可以避免频繁地重新定位文件指针，提高文件操作的效率。</li><li><strong>缓冲读取</strong>：<code>BufReader</code>提供了缓冲读取功能，可以减少直接对硬盘的读取次数，从而优化读取性能。对于需要频繁读取小块数据的索引操作，使用缓冲读取可以显著提高效率。</li><li><strong>并行操作</strong>：在多线程环境中，可能需要同时读取主数据区和内容表区。使用两个独立的<code>BufReader</code>实例可以简化并行读取的管理，每个读取操作都可以在不干扰另一个操作的情况下独立进行。</li></ul><p><code>Entry</code> 就是我们在 <code>write.rs</code> 中<code>write_contents_entry</code> 时传入的参数，这里我们将其封装成一个struct，再次回顾下这几个字段的含义：</p><ul><li><code>term</code>: 索引单词。为了统一，如果 <code>term</code>为空，则表示当前表示的是 doc，否则为 terms。</li><li><code>df</code>: term 的出现次数。为了统一，如果 <code>df</code> 为0，则表示当前表示的是 doc，否则为 terms。</li><li><code>offset</code>: 对应的 terms 或 docs 在文件中的偏移。</li><li><code>nbytes</code>: 对应的 terms 或 docs 的总长度。</li></ul><h3 id="read_entry">read_entry</h3><p>这里我们重点解释一下 <code>read_entry</code>方法，其他的都比较简单，请在源码中查找。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_entry</span>(f: &amp;<span class="hljs-keyword">mut</span> BufReader&lt;File&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">Option</span>&lt;Entry&gt;&gt; &#123;<br>  <span class="hljs-comment">// 获取偏移值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">offset</span> = <span class="hljs-keyword">match</span> f.read_u64::&lt;LittleEndian&gt;() &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(value) =&gt; value,<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> err.<span class="hljs-title function_ invoke__">kind</span>() == io::ErrorKind::UnexpectedEof &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-literal">None</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(err);<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>  <span class="hljs-comment">// 读取 nbytes</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">nbytes</span> = f.read_u64::&lt;LittleEndian&gt;()?;<br>  <span class="hljs-comment">// 读取 df</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">df</span> = f.read_u32::&lt;LittleEndian&gt;()?;<br>  <span class="hljs-comment">// 读取 term_len，并初始化一块内存 bytes 用来读取完整的 term</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">term_len</span> = f.read_u32::&lt;LittleEndian&gt;()? <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">bytes</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; term_len];<br>    f.<span class="hljs-title function_ invoke__">read_exact</span>(&amp;<span class="hljs-keyword">mut</span> bytes)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">term</span> = <span class="hljs-keyword">match</span> <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(bytes) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(s) =&gt; s,<br>        <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(io::Error::<span class="hljs-title function_ invoke__">new</span>(io::ErrorKind::Other, <span class="hljs-string">&quot;unicode fail&quot;</span>)),<br>    &#125;;<br><br>  <span class="hljs-comment">// 返回构建的 Entry</span><br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">Some</span>(Entry &#123;<br>        term,<br>        df,<br>        offset,<br>        nbytes,<br>    &#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>结合下面这张图，很容易理解 <code>read_entry</code> 就是前面<code>write_contents_entry</code> 的逆向过程。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423224035544.png"alt="entries 区域布局，每个 entry 紧贴排布" /><figcaption aria-hidden="true">entries 区域布局，每个 entry紧贴排布</figcaption></figure><h2 id="create.rs-1">create.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/bin/create.rs">create.rs</a></p></blockquote><p>至此，我们就分析完并发构建索引的整个过程了，在 <code>create.rs</code>中，我们使用 <code>clap</code> 命令解析框架来构建一个 CLI工具用以支持构建索引，我们同时支持单线程构建和并发构建，具体可看完整源码。</p><p>如果对 <code>clap</code> 不熟悉的读者，可参考：<ahref="https://hedon.top/2024/03/02/rust-crate-clap/">深入探索 Rust 的clap 库：命令行解析的艺术</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Opts</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, default_value_t = false, help = <span class="hljs-string">&quot;Default false&quot;</span>)]</span><br>    single_threaded: <span class="hljs-type">bool</span>,<br><br>    <span class="hljs-meta">#[arg(required = true)]</span><br>    filenames: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">opts</span> = Opts::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">run</span>(opts.filenames, opts.single_threaded) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(()) =&gt; &#123;&#125;<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error: &#123;&#125;&quot;</span>, err),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="搜索功能">搜索功能</h1><p>在《Rust程序设计（第二版）》中，作者并没有实现搜索功能，笔者对其进行扩展，目标是对标我们前篇所构建的<ahref="https://hedon.top/2024/04/15/rust-action-inverted-index-demo/">Rust实战丨倒排索引</a>。这个搜索功能，会根据现有的索引文件重建内存索引<code>InMemoryIndex</code>，支持指定 <code>term</code>进行搜索，并将包含这个 <code>term</code>的文件在响应的位置中进行高亮显示并输出到终端。</p><h2 id="search.rs-1">search.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/bin/search.rs">search.rs</a></p></blockquote><p>程序入口如下所示，比较简单，就不赘述了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Opts</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, required = true, help = <span class="hljs-string">&quot;Specify index file path&quot;</span>)]</span><br>    index_file: <span class="hljs-type">String</span>,<br>    <span class="hljs-meta">#[arg(short, long, required = true, help = <span class="hljs-string">&quot;Specify search term&quot;</span>)]</span><br>    term: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">opts</span> = Opts::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_index_file</span>(opts.index_file)?;<br>    index.<span class="hljs-title function_ invoke__">search</span>(&amp;opts.term)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有 2 个核心逻辑：</p><ul><li><code>InMemoryIndex::from_index_file</code>:根据索引文件重建内存索引。</li><li><code>index.search(term)</code>: 搜索。</li></ul><h2 id="index.rs-1">index.rs</h2><p>我们在 <code>index.rs</code> 中为 <code>InMemoryIndex</code> 实现上述2 个方法。</p><h3 id="from_index_file">from_index_file</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_index_file</span>&lt;P: <span class="hljs-built_in">AsRef</span>&lt;Path&gt;&gt;(filename: P) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;InMemoryIndex&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br><br>  <span class="hljs-comment">// 获取 IndexFileReader</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">reader</span> = IndexFileReader::<span class="hljs-title function_ invoke__">open_and_delete</span>(filename, <span class="hljs-literal">false</span>)?;<br><br>  <span class="hljs-comment">// 依次解析每个 Entry</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(entry) = reader.<span class="hljs-title function_ invoke__">iter_next_entry</span>() &#123;<br>        <span class="hljs-keyword">if</span> entry.term.<span class="hljs-title function_ invoke__">is_empty</span>() &amp;&amp; entry.df == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 当前 Entry 指向的是一个 Document。</span><br>          <span class="hljs-comment">// 通过 terms_docs 读取 Document 所在位置并进行解析。</span><br>            reader.terms_docs.<span class="hljs-title function_ invoke__">seek</span>(io::SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(entry.offset))?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">doc_id</span> = reader.terms_docs.read_u32::&lt;LittleEndian&gt;()?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">path_len</span> = reader.terms_docs.read_u64::&lt;LittleEndian&gt;()?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">path</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0u8</span>; path_len <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];<br>            reader.terms_docs.<span class="hljs-title function_ invoke__">read_exact</span>(&amp;<span class="hljs-keyword">mut</span> path)?;<br>            index.docs.<span class="hljs-title function_ invoke__">insert</span>(<br>                doc_id,<br>                Document &#123;<br>                    id: doc_id,<br>                    path: <span class="hljs-title function_ invoke__">vec_to_pathbuf</span>(path),<br>                &#125;,<br>            );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当前 Entry 指向的是一个 terms。</span><br>          <span class="hljs-comment">// 通过 terms_docs 读取 terms 所在位置并进行解析。</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hits</span> = <span class="hljs-built_in">vec!</span>[];<br>            reader.terms_docs.<span class="hljs-title function_ invoke__">seek</span>(io::SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(entry.offset))?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">data</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0u8</span>; entry.nbytes <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];<br>            reader.terms_docs.<span class="hljs-title function_ invoke__">read_exact</span>(&amp;<span class="hljs-keyword">mut</span> data)?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cursor</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(data);<br><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = entry.df;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">has_hit</span> = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">quit</span> = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; !quit &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hit</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span>); <span class="hljs-comment">// cannot use vec![0;12]</span><br>                <span class="hljs-keyword">loop</span> &#123;<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(item) = cursor.read_i32::&lt;LittleEndian&gt;() &#123;<br>                        <span class="hljs-comment">// the start of next hit</span><br>                        <span class="hljs-keyword">if</span> item == <span class="hljs-keyword">Self</span>::HITS_SEPERATOR &amp;&amp; has_hit &#123;<br>                            hits.<span class="hljs-title function_ invoke__">push</span>(hit);<br>                            i -= <span class="hljs-number">1</span>;<br>                            index.word_count -= <span class="hljs-number">2</span>;<br>                            hit = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span>);<br>                        &#125;<br>                        has_hit = <span class="hljs-literal">true</span>;<br>                        hit.write_u32::&lt;LittleEndian&gt;(item <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>                        index.word_count += <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        quit = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">if</span> !hit.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                            hits.<span class="hljs-title function_ invoke__">push</span>(hit);<br>                            index.word_count -= <span class="hljs-number">2</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            index.terms.<span class="hljs-title function_ invoke__">insert</span>(entry.term, hits);<br>        &#125;<br>    &#125;<br>    index.word_count /= <span class="hljs-number">2</span>;<br>    <span class="hljs-title function_ invoke__">Ok</span>(index)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="search">search</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">self</span>, term: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>  <span class="hljs-comment">// 获取 term 出现的位置</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span>: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;&gt;&gt; = <span class="hljs-keyword">self</span>.terms.<span class="hljs-title function_ invoke__">get</span>(term);<br>    <span class="hljs-keyword">if</span> m.<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;can not found &#123;&#125; in all documents&quot;</span>, term);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(());<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hits</span> = m.<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>  <span class="hljs-comment">// 遍历每个出现的位置</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">hit</span> <span class="hljs-keyword">in</span> hits &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cursor</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(hit);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = cursor.read_i32::&lt;LittleEndian&gt;().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>      <span class="hljs-comment">// 获取文档原始信息</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">document_id</span> = cursor.read_u32::&lt;LittleEndian&gt;().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">doc</span> = <span class="hljs-keyword">self</span>.docs.<span class="hljs-title function_ invoke__">get</span>(&amp;document_id);<br>        <span class="hljs-keyword">if</span> doc.<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;cannot found document &#123;&#125;&quot;</span>, document_id);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">doc</span> = doc.<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>      <span class="hljs-comment">// hits 存储的内容：[HITS_SEPERATOR, document_id, start_pos1, end_pos1, ...]</span><br>      <span class="hljs-comment">// 解析 term 出现在 doc 中的每个位置</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">poss</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(hits.<span class="hljs-title function_ invoke__">len</span>() / <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">pos</span> = TokenPos::<span class="hljs-title function_ invoke__">default</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">has_pos</span> = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(p) = cursor.read_u32::&lt;LittleEndian&gt;() &#123;<br>            <span class="hljs-keyword">if</span> !has_pos &#123;<br>                pos.start_pos = p;<br>                has_pos = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pos.end_pos = p;<br>                poss.<span class="hljs-title function_ invoke__">push</span>(pos);<br>                pos = TokenPos::<span class="hljs-title function_ invoke__">default</span>();<br>                has_pos = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>      <span class="hljs-comment">// 对每个出现的位置进行高亮处理</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">highlight_file</span>(doc.path.<span class="hljs-title function_ invoke__">clone</span>(), &amp;<span class="hljs-keyword">mut</span> poss)?;<br>      <span class="hljs-comment">// 输出高亮后的结果</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;\n&#123;:?&#125;: \n&#123;&#125;&quot;</span>, doc.path, result);<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>至此，我们就实现了高并发构建索引和根据索引进行搜索的功能，本篇某些部分可能比较复杂，篇幅也比较冗长，笔者在阅读书中原实现的时候，也是获益颇丰，想不到一个简单的倒排索引竟涉及这么多的处理细节。也希望本篇文章能对感兴趣的读者有些许帮助。</p><p>peace! enjoy coding~</p><h1 id="绘图工具">绘图工具</h1><ul><li><ahref="https://link.zhihu.com/?target=https%3A//excalidraw.com/">https://excalidraw.com/</a></li></ul><h1 id="参考资料">参考资料</h1><ul><li><ahref="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Inverted_index">维基百科·倒排索引</a></li><li><ahref="https://link.zhihu.com/?target=https%3A//book.douban.com/subject/36547630/">Rust程序设计（第二版）</a></li></ul>]]></content>
    
    
    <summary type="html">本文详细阐述了使用 Rust channel 并发构建倒排索引的详细过程。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="倒排索引" scheme="https://hedon.top/tags/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="通道" scheme="https://hedon.top/tags/%E9%80%9A%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨倒排索引</title>
    <link href="https://hedon.top/2024/04/15/rust-action-inverted-index-demo/"/>
    <id>https://hedon.top/2024/04/15/rust-action-inverted-index-demo/</id>
    <published>2024-04-15T02:24:17.000Z</published>
    <updated>2024-04-23T04:57:27.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>倒排索引（InvertedIndex）是一种索引数据结构，用于存储某个单词（词项）在一组文档中的所有出现情况的映射。它是搜索引擎执行快速全文搜索的核心技术，也广泛用于数据库中进行文本搜索。我们熟知的ElasticSearch 最核心底层原理便就是倒排索引。</p><p>倒排索引的基本原理是<strong>将文档中的词汇进行反转，形成倒排列表</strong>。在倒排列表中，每个词汇都对应一个文档标识符的列表，这些标识符指明了该词汇出现在哪些文档中。通过查询倒排列表，可以快速地找到包含特定词汇的文档。</p><p>本文将使用 Rust语言来实现一个简单的倒排索引，包括倒排索引的构建和搜索过程。在下一篇文章中，笔者会基于《Rust程序设计（第二版）》并发编程篇章，解读该书作者是如何基于 Rust通道实现更优秀、更高性能的倒排索引。</p><h1 id="可以学到">可以学到</h1><ol type="1"><li>倒排索引的原理、优势和使用</li><li>常用 crate：<code>colored</code>、<code>regex</code></li><li>Rust HashMap</li><li>Rust 迭代器</li></ol><h1 id="开发思路">开发思路</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240414112337590.png"alt="倒排索引构建过程" /><figcaption aria-hidden="true">倒排索引构建过程</figcaption></figure><p>一个简单的倒排索引开发思路大概如上图所示：</p><ol type="1"><li>读取文档</li><li>分词</li><li>构建每个词到每个文档的映射</li></ol><h1 id="开发过程">开发过程</h1><blockquote><p>完整源码位于：<ahref="https://github.com/hedon-rust-road/inverted-index">inverted_index</a>。</p></blockquote><h2 id="最终效果">最终效果</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index</span> = InvertedIndex::<span class="hljs-title function_ invoke__">new</span>();<br>    index.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Rust is safe and fast.&quot;</span>);<br>    index.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Rust is a systems programming language.&quot;</span>);<br>    index.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Programming in Rust is fun.&quot;</span>);<br><br>    <span class="hljs-comment">// query &quot;Rust&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">results</span> = index.<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;Rust&quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">result</span> <span class="hljs-keyword">in</span> results &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-comment">// query &quot;Programming&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">results</span> = index.<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;Programming&quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">result</span> <span class="hljs-keyword">in</span> results &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo run<br></code></pre></td></tr></table></figure><p>输出：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240414122848805.png"alt="inverted index 输出示例" /><figcaption aria-hidden="true">inverted index 输出示例</figcaption></figure><h2 id="版本声明">版本声明</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;inverted_index&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">colored</span> = <span class="hljs-string">&quot;2.1.0&quot;</span><br><span class="hljs-attr">regex</span> = <span class="hljs-string">&quot;1.10.4&quot;</span><br></code></pre></td></tr></table></figure><h2 id="项目准备">项目准备</h2><p>首先我们创建项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new inverted_index<br></code></pre></td></tr></table></figure><p>准备依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add regex<br>cargo add colored<br></code></pre></td></tr></table></figure><ul><li>colored:终端高亮，后面我们将实现搜索词的高亮显示，使结果更美观。</li><li>regex: 正则库，用于实现不区分大小写替换匹配到的搜索词。</li></ul><h2 id="实现过程">实现过程</h2><p>首先我们定义两个数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Document</span> &#123;<br>    id: <span class="hljs-type">usize</span>,<br>    content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>    indexes: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt;&gt;,<br>    documents: HashMap&lt;<span class="hljs-type">usize</span>, Document&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> InvertedIndex &#123;<br>        InvertedIndex &#123;<br>            indexes: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>            documents: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Document: 封装原始文档</li><li>IndexedIndex: 我们将构建的倒排索引</li></ul><p>接下来我们要实现 2 个辅助函数，一个是<code>tokenize</code>，用于将原始的文档信息拆分成独立的词（word/term），另一个是<code>hightlight</code>，用于将匹配到的文本进行替换，使其在中断可以以<font color="purple">紫色</font>输出。</p><p><code>tokenize</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tokenize</span>(text: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-type">str</span>&gt; &#123;<br>    text.<span class="hljs-title function_ invoke__">split</span>(|ch: <span class="hljs-type">char</span>| !ch.<span class="hljs-title function_ invoke__">is_alphanumeric</span>())<br>        .<span class="hljs-title function_ invoke__">filter</span>(|c| !c.<span class="hljs-title function_ invoke__">is_empty</span>())<br>        .<span class="hljs-title function_ invoke__">collect</span>()<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tokenize_test</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        <span class="hljs-title function_ invoke__">tokenize</span>(<span class="hljs-string">&quot;This is\nhedon&#x27;s tokenize function.&quot;</span>),<br>        <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;This&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;hedon&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;tokenize&quot;</span>, <span class="hljs-string">&quot;function&quot;</span>]<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>highlight</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">highlight</span>(term: &amp;<span class="hljs-type">str</span>, content: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">regex</span> = Regex::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-built_in">format!</span>(<span class="hljs-string">r&quot;(?i)&#123;&#125;&quot;</span>, term)).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">highlighted_content</span> = regex<br>        .<span class="hljs-title function_ invoke__">replace_all</span>(content, |caps: &amp;regex::Captures| &#123;<br>            caps[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">purple</span>().<span class="hljs-title function_ invoke__">to_string</span>()<br>        &#125;)<br>        .<span class="hljs-title function_ invoke__">to_string</span>();<br>    highlighted_content<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">highlight_test</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        <span class="hljs-title function_ invoke__">highlight</span>(<span class="hljs-string">&quot;programming&quot;</span>, <span class="hljs-string">&quot;I like programming with Rust Programming&quot;</span>),<br>        <span class="hljs-string">&quot;I like \u&#123;1b&#125;[35mprogramming\u&#123;1b&#125;[0m with Rust \u&#123;1b&#125;[35mProgramming\u&#123;1b&#125;[0m&quot;</span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以为 <code>InvertedIndex</code> 实现构建索引的方法<code>add</code>了，它会接收原始文档，对其进行分词，并将记录每个分词和文档 id的映射。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, doc_id: <span class="hljs-type">usize</span>, content: &amp;<span class="hljs-type">str</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">content_lowercase</span> = content.<span class="hljs-title function_ invoke__">to_lowercase</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">words</span> = <span class="hljs-title function_ invoke__">tokenize</span>(&amp;content_lowercase);<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> words &#123;<br>            <span class="hljs-keyword">self</span>.indexes<br>                .<span class="hljs-title function_ invoke__">entry</span>(word.<span class="hljs-title function_ invoke__">to_string</span>())<br>                .<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-built_in">vec!</span>[])<br>                .<span class="hljs-title function_ invoke__">push</span>(doc_id)<br>        &#125;<br><br>        <span class="hljs-keyword">self</span>.documents.<span class="hljs-title function_ invoke__">insert</span>(<br>            doc_id,<br>            Document &#123;<br>                id: doc_id,<br>                content: content.<span class="hljs-title function_ invoke__">to_string</span>(),<br>            &#125;,<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们再实现对应的根据分词 <code>term</code>搜索原始文档的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">query</span>(&amp;<span class="hljs-keyword">self</span>, term: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">term_lowercase</span> = term.<span class="hljs-title function_ invoke__">to_lowercase</span>();<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(doc_ids) = <span class="hljs-keyword">self</span>.indexes.<span class="hljs-title function_ invoke__">get</span>(&amp;term_lowercase) &#123;<br>            doc_ids<br>                .<span class="hljs-title function_ invoke__">iter</span>()<br>                .<span class="hljs-title function_ invoke__">filter_map</span>(|doc_id| &#123;<br>                    <span class="hljs-keyword">self</span>.documents<br>                        .<span class="hljs-title function_ invoke__">get</span>(doc_id)<br>                        .<span class="hljs-title function_ invoke__">map</span>(|doc| <span class="hljs-title function_ invoke__">highlight</span>(&amp;term_lowercase, &amp;doc.content))<br>                &#125;)<br>                .<span class="hljs-title function_ invoke__">collect</span>()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一个简单的倒排索引构建和搜索功能就完成了，具体的执行效果你可以回到前面的「最终效果」进行查阅。</p><h1 id="总结预告">总结预告</h1><p>本文实现的倒排索引虽然非常简单，但是也基本体现了倒排索引的最核心思想和应用方式了。在《Rust程序设计（第二版）》的并发编程篇章中，该书提出了使用通道 channel来并发构建倒排索引，同时给出了更加丰富和优雅的实现。在下篇文章中，笔者将阅读这部分的源码，解析并重现当中的实战过程，并进行适当扩展。</p><p>peace! enjoy coding~</p><h1 id="绘图工具">绘图工具</h1><ul><li>https://excalidraw.com/</li></ul><h1 id="参考资料">参考资料</h1><ul><li><ahref="https://en.wikipedia.org/wiki/Inverted_index">维基百科·倒排索引</a></li><li><a href="https://book.douban.com/subject/36547630/">Rust程序设计（第二版）</a></li></ul>]]></content>
    
    
    <summary type="html">本文将使用 Rust 实现一个简单的倒排索引。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="倒排索引" scheme="https://hedon.top/tags/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Go 语言的 defer 机制</title>
    <link href="https://hedon.top/2024/03/28/go-defer/"/>
    <id>https://hedon.top/2024/03/28/go-defer/</id>
    <published>2024-03-28T12:34:50.000Z</published>
    <updated>2024-04-14T02:23:53.351Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言以其简洁的语法和强大的并发支持而闻名。在这些特性中，<code>defer</code>语句是 Go语言提供的一项独特功能，它允许我们推迟函数的执行直到包含它的函数即将返回。这个简单而强大的机制不仅可以帮助我们处理资源释放和错误处理，还能让代码更加简洁和安全。本文将深入浅出地介绍<code>defer</code>的工作原理，探究其背后的机制，并通过丰富的案例来展示它的实际应用。</p><p>笔者本来以为 Go 语言的 <code>defer</code>其实东西不多，就是类似于“栈”的操作罢了，无非就是用于释放资源、后进先出而已。但是最近在阅读完《深入理解Go 语言》、《Go 底层原理剖析》和《Go 语言设计与实现》中关于<code>defer</code>的篇章。发现其中隐含的道道和坑还是比较有意思的，特此整理这篇文章，希望能对Go <code>defer</code> 原理感兴趣的读者带来一些帮助。</p><p>本文具体会包含以下内容：</p><ul><li><strong><code>defer</code> 机制简介</strong>：介绍<code>defer</code> 关键字的基本概念和它在 Go 语言中的作用。</li><li><strong><code>defer</code> 的工作原理</strong>：深入探讨<code>defer</code> 在函数执行结束时如何工作的细节。</li><li><strong><code>defer</code> 的执行顺序</strong>：解释<code>defer</code> 语句是如何按照后进先出（LIFO）的顺序执行的。</li><li><strong>参数预计算和值传递</strong>：讨论 <code>defer</code>语句中参数是如何被预先计算和传递的。</li><li><strong>环境变量和闭包</strong>：探讨 <code>defer</code>如何与闭包一起工作，以及如何捕获和影响环境变量。</li><li><strong><code>defer</code> 与错误处理</strong>：说明如何利用<code>defer</code> 和 <code>recover</code> 进行错误处理和异常捕获。</li><li><strong><code>defer</code> 的实现细节</strong>：深入分析<code>defer</code>的不同实现策略，包括堆上分配、栈上分配和开放编码。</li></ul><h1 id="版本声明">版本声明</h1><ul><li>Go1.22</li></ul><h1 id="思维导图">思维导图</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Go%20defer.png"alt="Go defer" /><figcaption aria-hidden="true">Go defer</figcaption></figure><h1 id="核心要点">核心要点</h1><p>对于后面将要分析的各种各样的情况，在分析的时候只要遵循以下几个核心点，基本上就不会跑偏：</p><ol type="1"><li>延迟执行：在函数结束时执行，包括正常返回或遭遇 panic。</li><li>栈式执行顺序：后定义的 <code>defer</code> 先执行（LIFO）。</li><li>参数预计算：<code>defer</code> 语句定义时即计算并固定参数值。</li><li>值传递原则：<code>defer</code> 拷贝参数，使用定义时的值。</li><li>环境变量捕获：在 <code>defer</code>中可以跟一个闭包，闭包可以捕获环境变量，当然这包括具名返回值。</li></ol><p>特别说明的是，虽然我们通常将 <code>defer</code>想象为使用栈进行管理，但是实际实现上，<code>defer</code>并不都是存放在栈上的，我们后面会具体分析到。这种实现细节通常对于编写正确的Go代码并不重要，但了解这一点对于深入理解语言内部机制可能是有帮助的。</p><h1 id="基本用法">基本用法</h1><p>在 Go 语言中，<code>defer</code>语句通常用于确保一个函数调用在程序执行结束时发生，常见的用例包括文件关闭、锁释放、资源回收等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    f, err := os.Open(filename)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-comment">// 确保文件在函数返回时关闭</span><br>    <span class="hljs-keyword">defer</span> f.Close()<br><br>    <span class="hljs-comment">// ... 处理文件 ...</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>defer f.Close()</code> 保证了无论<code>readFile</code>函数如何返回（正常返回或发生错误），<code>f.Close()</code>都会被调用，从而避免了资源泄露。</p><h1 id="执行顺序">执行顺序</h1><p><code>defer</code>的执行顺序是先进后出，即“栈”操作。这里借用刘丹冰老师的一张图来演示这个过程：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1651037338287-fd17c81d-a1ad-4bc7-ae7e-eec8a264af5f.jpeg"alt="Go defer 执行顺序" /><figcaption aria-hidden="true">Go defer 执行顺序</figcaption></figure><p>我们可以通过以下代码进行验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func1...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func2...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func3...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> func1()<br><span class="hljs-keyword">defer</span> func2()<br><span class="hljs-keyword">defer</span> func3()<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">func3</span></span>...<br><span class="hljs-function"><span class="hljs-title">func2</span></span>...<br><span class="hljs-function"><span class="hljs-title">func1</span></span>...<br></code></pre></td></tr></table></figure><h1 id="参数求值与陷阱">参数求值与陷阱</h1><p>关于 <code>defer</code>参数这一块，是一个比较容易出错的地方。我们先来看一个例子，你可以分析下它的输出会是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printI</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;printI i:&quot;</span>, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">10</span><br><span class="hljs-keyword">defer</span> printI(i * <span class="hljs-number">10</span>)<br>i = i + <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;main i:&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure><p>按照我们之前总结的核心点：<strong>参数预计算：<code>defer</code>语句定义时即计算并固定参数值</strong>。具体来说，在把 <code>defer</code>压入“栈”时，会同时压入<strong>函数地址</strong>和<strong>函数形参</strong>，也就是会在这个时候就把参数先算好。所以在执行到第7 行代码的时候，就会把 <code>i*10</code> 算好，然后同<code>printI</code> 一同压入到延迟执行栈中。</p><p>所以最后的结果就是：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">i</span>: <span class="hljs-number">11</span><br><span class="hljs-selector-tag">printI</span> <span class="hljs-selector-tag">i</span>: <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>关于<strong>参数值传递</strong>，笔者这里再举两个例子进行比较，体会后你应该就理解了。</p><p>第一个例子中，<code>defer</code>后面参数是指针，本质上<strong>值传递</strong>，但是拷贝的是指针，所以在<code>defer</code> 中修改的东西，最后会反馈到指针指向的对象，所以对<code>testUser</code> 的返回值是有影响的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span>&#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testUser</span><span class="hljs-params">()</span></span> *User &#123;<br>user := &amp;User&#123;&#125;<br>user.name = <span class="hljs-string">&quot;name-1&quot;</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u *User)</span></span> &#123;<br>u.name = <span class="hljs-string">&quot;name-defer&quot;</span><br>&#125;(user)<br><br>user.name = <span class="hljs-string">&quot;name-2&quot;</span><br><span class="hljs-keyword">return</span> user<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>user := testUser()<br>fmt.Println(user)<br>&#125;<br><span class="hljs-comment">// &amp;&#123;name-defer&#125;</span><br></code></pre></td></tr></table></figure><p>第二个例子中，我们传入的就是结构体示例本身了，因为值传递，即拷贝了一份新的<code>user</code>，所以闭包内的修改对外面是不产生影响的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testUser</span><span class="hljs-params">()</span></span> User &#123;<br>user := User&#123;&#125;<br>user.name = <span class="hljs-string">&quot;name-1&quot;</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u User)</span></span> &#123;<br>u.name = <span class="hljs-string">&quot;name-defer&quot;</span><br>&#125;(user)<br><br>user.name = <span class="hljs-string">&quot;name-2&quot;</span><br><span class="hljs-keyword">return</span> user<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>user := testUser()<br>fmt.Println(user)<br>&#125;<br><span class="hljs-comment">// &#123;name-2&#125;</span><br></code></pre></td></tr></table></figure><h1 id="环境变量捕获">环境变量捕获</h1><p>将上面的一个例子进行简单修改，会输出什么呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printI</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;printI i:&quot;</span>, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">10</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>printI(i * <span class="hljs-number">10</span>)<br>&#125;()<br>i = i + <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;main i:&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候其实没有参数，所以会直接将下面闭包压入延迟栈中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  printI(i * <span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>而闭包是可以捕获环境变量的，所以在 <code>main</code> return后，<code>defer</code> 可以捕获到 <code>i</code> 的值，为更新后的<code>i+1</code>，最后再进行 <code>printI(i * 10)</code>。</p><p>所以输出结果是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">main i: <span class="hljs-number">11</span><br>printI i: <span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>所以说，<code>defer</code>后面的闭包，是可以捕获环境变量的，如果这个变量是返回值的话，那么理所应当也是可以对其产生作用的，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getI</span><span class="hljs-params">()</span></span> (i <span class="hljs-type">int</span>) &#123;<br>i = <span class="hljs-number">1</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i *= <span class="hljs-number">10</span><br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(getI())<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，<code>getI</code> 的返回值是有名字的<code>i</code>，<code>getI</code> 执行了<code>return 20</code>，其实就是将 <code>i</code> 设置为<code>20</code>，所以在执行到 <code>defer</code> 闭包的时候，捕获到了<code>i=20</code>，并将其进行了修改。所以最终输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h1 id="错误处理与-defer">错误处理与 defer</h1><p>我们都知道 Go 程序中遇到 <code>panic</code>就会中断后面的执行流程直接返回，这个时候我们可以在 <code>defer</code>中结合 <code>recover</code> 来捕获这个<code>panic</code>，从而保护程序不崩溃。</p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panicAndRecover</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;函数中正常流程&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;出现异常&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;panic 后的语句永远执行不到&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>panicAndRecover()<br>fmt.Println(<span class="hljs-string">&quot;正常回到 main&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 函数中正常流程</span><br><span class="hljs-comment">// 出现异常</span><br><span class="hljs-comment">// 正常回到 main</span><br></code></pre></td></tr></table></figure><p>更进一步，如果我们在 <code>defer</code> 中也有 <code>panic</code>呢？请思考下列代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panicAndRecover</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;第 1 个入栈的 defer&quot;</span>)<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;最终捕获的 panic:&quot;</span>, err)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;第 2 个入栈的 defer&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;第 2 个入栈的 defer 发生 panic&quot;</span>)<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;panicAndRecover 函数中正常流程&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panicAndRecover 出现异常&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;panic 后的语句永远执行不到&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>panicAndRecover()<br>fmt.Println(<span class="hljs-string">&quot;正常回到 main&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们在 <code>panicAndRecover</code> 强行抛出<code>panic</code>，由于 <code>defer</code> 先进后出，所以我们会先执行第2 个 <code>defer</code>，其中也发生了 <code>panic</code>，我们在第 1 个<code>defer</code> 中对 <code>panic</code> 进行<code>recover</code>，最终的现象是只捕获到了后面抛出的<code>panic</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">panicAndRecover 函数中正常流程<br>第 <span class="hljs-number">2</span> 个入栈的 <span class="hljs-keyword">defer</span><br>第 <span class="hljs-number">1</span> 个入栈的 <span class="hljs-keyword">defer</span><br>最终捕获的 <span class="hljs-built_in">panic</span>: 第 <span class="hljs-number">2</span> 个入栈的 <span class="hljs-keyword">defer</span> 发生 <span class="hljs-built_in">panic</span><br>正常回到 main<br></code></pre></td></tr></table></figure><p>这是为什么呢？</p><p>在 Go 语言中，<code>panic</code> 函数实际上是创建了一个<code>panic</code> 对象，并抛出这个对象。</p><p>当一个 <code>panic</code> 发生并开始向上传播时，Go 运行时会检查每个<code>defer</code>。如果 <code>defer</code> 中包含 <code>recover</code>调用，并且它被执行，那么 <code>recover</code> 会捕获当前的<code>panic</code>，并且防止它继续向上传播。如果 <code>defer</code>中再次发生 <code>panic</code>，那么原来的 <code>panic</code> 就不会被<code>recover</code> 捕获，因为 <code>defer</code>函数已经退出了。在这种情况下，新的 <code>panic</code>会导致程序崩溃，因为没有更多的 <code>defer</code> 函数去<code>recover</code> 这个新的 <code>panic</code>。</p><p>这说明了 Go 程序中不允许同时有多个活跃的 <code>panic</code>存在，这个设计确保了在任何给定的时刻，只有一个 <code>panic</code>能够被处理。这样做有几个原因：</p><ol type="1"><li><strong>简化错误处理：</strong> 如果同时存在多个<code>panic</code>，就会变得非常复杂去确定如何处理它们，尤其是在它们之间存在依赖关系的时候。一个<code>panic</code>应该表示一个不可恢复的错误，如果有多个这样的错误同时存在，程序的状态可能会变得非常不确定。</li><li><strong>保持一致性：</strong> <code>panic</code>通常表示程序中出现了严重错误，可能会破坏程序的一致性或安全性。如果允许多个<code>panic</code> 同时存在，就很难保证程序状态的一致性，因为不同的<code>panic</code> 可能需要回退不同的操作。</li><li><strong>避免资源泄漏：</strong> <code>defer</code>语句用于确保资源被释放，例如文件和锁。如果在处理一个 <code>panic</code>的过程中，又发生了另一个 <code>panic</code>，可能会导致<code>defer</code> 语句中剩余的清理代码无法执行，从而引起资源泄漏。</li><li><strong>控制流程清晰：</strong> <code>panic</code> 和<code>recover</code> 的设计使得错误的控制流程清晰且可预测。一旦一个<code>panic</code> 被 <code>recover</code>捕获，程序可以选择是否继续执行，或者是通过重新 <code>panic</code>来终止程序。这种决策过程在多个 <code>panic</code>情况下会变得复杂且难以管理。</li></ol><p>因此，在 Go 的设计中，不允许同时存在多个活跃的<code>panic</code>。一旦发生 <code>panic</code>，它必须被<code>recover</code>处理，否则程序将会终止。这确保了错误处理的清晰性和程序的稳定性。</p><h1 id="defer-放在哪">defer 放在哪</h1><p><code>defer</code> 实际上不一定是放在栈上的，截止Go1.22，<code>defer</code> 其实用 3 种分配策略：</p><ul><li>堆上分配</li><li>栈上分配</li><li>开放编码</li></ul><h2 id="执行机制">执行机制</h2><p>在 <ahref="https://github.com/golang/go/blob/release-branch.go1.22/src/cmd/compile/internal/ssagen/ssa.go">ssa.go</a>文件中，我们可以找到 <code>state.stmt()</code>，这个函数是负责在 Go程序编译过程中中间代码生成阶段时对不同语句的处理过程，其中对于<code>ODEFER</code> 即 <code>defer</code> 语句的处理逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// stmt converts the statement n to SSA and adds it to s.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *state)</span></span> stmt(n ir.Node) &#123;<br>s.stmtList(n.Init())<br><span class="hljs-keyword">switch</span> n.Op() &#123;<br><span class="hljs-keyword">case</span> ir.ODEFER:<br>      n := n.(*ir.GoDeferStmt)<br>      <span class="hljs-keyword">if</span> base.Debug.Defer &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">var</span> defertype <span class="hljs-type">string</span><br>        <span class="hljs-keyword">if</span> s.hasOpenDefers &#123;<br>          defertype = <span class="hljs-string">&quot;open-coded&quot;</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n.Esc() == ir.EscNever &#123;<br>          defertype = <span class="hljs-string">&quot;stack-allocated&quot;</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          defertype = <span class="hljs-string">&quot;heap-allocated&quot;</span><br>        &#125;<br>        base.WarnfAt(n.Pos(), <span class="hljs-string">&quot;%s defer&quot;</span>, defertype)<br>      &#125;<br>...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，总共有 3 种分配策略：</p><ul><li><strong>open-coded</strong>: s.hasOpenDefers == true</li><li><strong>stack-allocated</strong>: n.Esc() == ir.EscNever</li><li><strong>heap-allocated</strong>: 默认</li></ul><p>默认是堆分配，在 Go1.13以前，也只有堆分配这一种策略，不过该实现的性能较差。Go 语言在 1.13中引入栈上分配的结构体，<ahref="https://go-review.googlesource.com/c/go/+/171758">减少了 30%的额外开销</a>，并在 1.14 中引入了基于开放编码的<code>defer</code>，使得该关键字的额外开销<ahref="https://go-review.googlesource.com/c/go/+/190098/6">几乎可以忽略不计</a>。</p><p>本文中不对具体的分配机制进行分析，这一块会比较复杂，笔者本身也不是很感兴趣，便决定对此不过分深究，感兴趣的读者推荐详细阅读《Go语言设计与实现》中关于 <code>defer</code>关键字的分析：https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/。</p><p>本文只讨论什么情况下会使用什么分配策略。由于堆分配是默认的，我们就不作分析了，具体来看看<code>s.hasOpenDefers == true</code> 和<code>n.Esc() == ir.EscNever</code> 什么时候会成立。</p><h2 id="栈上分配">栈上分配</h2><p>我们先来看栈上分配，要满足栈上分配，则需要满足<code>n.Esc() == ir.EscNever</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>EscUnknown = <span class="hljs-literal">iota</span><br>EscNone    <span class="hljs-comment">// Does not escape to heap, result, or parameters.</span><br>EscHeap    <span class="hljs-comment">// Reachable from the heap</span><br>EscNever   <span class="hljs-comment">// By construction will not escape.</span><br>)<br></code></pre></td></tr></table></figure><p>当 <code>n</code> 的逃逸分析结果是 <code>ir.EscNever</code>，则表明该<code>defer</code>语句从不逃逸（不会在函数调用结束后仍然被引用），这种情况下<code>defer</code> 将被分配到栈上（stack-allocated）。否则，如果<code>defer</code> 逃逸了，就会被分配到堆上（heap-allocated）。</p><p>那 <code>defer</code> 语句什么时候会逃逸呢？</p><blockquote><p>在 Go中，一个变量的逃逸意味着它的生命周期超出了当前函数的范围。在函数内定义的变量通常分配在栈上，而在堆上分配内存需要更复杂的管理。在一些情况下，编译器可能会选择将变量分配在堆上，这种情况下我们称之为逃逸。</p></blockquote><p>对于 <code>defer</code> 语句，如果它引用了函数外的变量，这个<code>defer</code> 就会逃逸。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(x) <span class="hljs-comment">// 这里引用了外部变量 x</span><br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>defer</code> 函数内部引用了 <code>x</code>这个外部变量，因此 <code>defer</code> 语句需要确保 <code>x</code> 在<code>defer</code> 函数执行时仍然有效。为了满足这个条件，编译器可能会将<code>x</code> 分配在堆上，而不是栈上。</p><h2 id="开放编码">开放编码</h2><p>先给结论，在开发过程中，要使用开放编码策略，你只需要关注以下 4点即可：</p><ol type="1"><li>函数的 <code>defer</code> 数量不能超过 8 个；</li><li>函数的 <code>defer</code> 关键字不能在循环中执行；</li><li>函数的 <code>defer</code> 中不能发生逃逸；</li><li>函数的 <code>return</code> 语句与 <code>defer</code>语句的乘积小于或者等于 15 个；</li></ol><hr /><p>Ok，下面是具体的分析过程。</p><p>借助 Goland 的能力，将鼠标光标放在 <code>s.hasOpenDefers</code>上，按住 <strong>Command</strong>加点击鼠标，可以看到该属性的使用情况：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328133312845-20240328202233278.png"alt="s.hasOpenDefers" /><figcaption aria-hidden="true">s.hasOpenDefers</figcaption></figure><p>可以看到该属性的判断逻辑都在 <ahref="https://github.com/golang/go/blob/release-branch.go1.22/src/cmd/compile/internal/ssagen/ssa.go">ssa.go</a>文件中的 <code>buildssa()</code>函数中。去掉一些无关的代码，核心逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// buildssa builds an SSA function for fn.</span><br><span class="hljs-comment">// worker indicates which of the backend workers is doing the processing.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildssa</span><span class="hljs-params">(fn *ir.Func, worker <span class="hljs-type">int</span>)</span></span> *ssa.Func &#123;<br>...<br>  <span class="hljs-comment">// ①</span><br>s.hasOpenDefers = base.Flag.N == <span class="hljs-number">0</span> &amp;&amp; s.hasdefer &amp;&amp; !s.curfn.OpenCodedDeferDisallowed()<br><span class="hljs-keyword">switch</span> &#123;<br>  <span class="hljs-comment">// ②</span><br><span class="hljs-keyword">case</span> base.Debug.NoOpenDefer != <span class="hljs-number">0</span>:<br>s.hasOpenDefers = <span class="hljs-literal">false</span><br><span class="hljs-keyword">case</span> s.hasOpenDefers &amp;&amp; (base.Ctxt.Flag_shared || base.Ctxt.Flag_dynlink) &amp;&amp; base.Ctxt.Arch.Name == <span class="hljs-string">&quot;386&quot;</span>:<br>    <span class="hljs-comment">// ③</span><br><span class="hljs-comment">// Don&#x27;t support open-coded defers for 386 ONLY when using shared</span><br><span class="hljs-comment">// libraries, because there is extra code (added by rewriteToUseGot())</span><br><span class="hljs-comment">// preceding the deferreturn/ret code that we don&#x27;t track correctly.</span><br>s.hasOpenDefers = <span class="hljs-literal">false</span><br>&#125;<br>  <span class="hljs-comment">// ④</span><br><span class="hljs-keyword">if</span> s.hasOpenDefers &amp;&amp; <span class="hljs-built_in">len</span>(s.curfn.Exit) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Skip doing open defers if there is any extra exit code (likely</span><br><span class="hljs-comment">// race detection), since we will not generate that code in the</span><br><span class="hljs-comment">// case of the extra deferreturn/ret segment.</span><br>s.hasOpenDefers = <span class="hljs-literal">false</span><br>&#125;<br>  <span class="hljs-comment">// ⑤</span><br><span class="hljs-keyword">if</span> s.hasOpenDefers &#123;<br><span class="hljs-comment">// Similarly, skip if there are any heap-allocated result</span><br><span class="hljs-comment">// parameters that need to be copied back to their stack slots.</span><br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> s.curfn.Type().Results().FieldSlice() &#123;<br><span class="hljs-keyword">if</span> !f.Nname.(*ir.Name).OnStack() &#123;<br>s.hasOpenDefers = <span class="hljs-literal">false</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br>  <span class="hljs-comment">// ⑥</span><br><span class="hljs-keyword">if</span> s.hasOpenDefers &amp;&amp;<br>s.curfn.NumReturns*s.curfn.NumDefers &gt; <span class="hljs-number">15</span> &#123;<br><span class="hljs-comment">// Since we are generating defer calls at every exit for</span><br><span class="hljs-comment">// open-coded defers, skip doing open-coded defers if there are</span><br><span class="hljs-comment">// too many returns (especially if there are multiple defers).</span><br><span class="hljs-comment">// Open-coded defers are most important for improving performance</span><br><span class="hljs-comment">// for smaller functions (which don&#x27;t have many returns).</span><br>s.hasOpenDefers = <span class="hljs-literal">false</span><br>&#125;<br>  ...<br><span class="hljs-keyword">return</span> s.f<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到总共有 6个条件，我已在注释中进行标注，我们来进行逐一分析：</p><h3 id="base.flag.n-0-s.hasdefer-s.curfn.opencodeddeferdisallowed">①base.Flag.N == 0 &amp;&amp; s.hasdefer &amp;&amp;!s.curfn.OpenCodedDeferDisallowed()</h3><blockquote><p>如果<code>base.Flag.N</code> 等于 0且当前函数有延迟调用且没有禁止开放式延迟，那么设置<code>s.hasOpenDefers</code>为<code>true</code>。</p></blockquote><p>在 Go编译器中，<code>-N</code>标志通常用于禁用优化。在这段代码中，如果<code>base.Flag.N</code>等于0，意味着没有禁用优化，因此编译器可能会尝试使用更高级的优化技术，比如开放式延迟（open-codeddefers）。</p><p><code>OpenCodedDeferDisallowed()</code>即禁用开放编码，它的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> funcOpenCodedDeferDisallowed <span class="hljs-comment">// can&#x27;t do open-coded defers</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Func)</span></span> OpenCodedDeferDisallowed() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> f.flags&amp;funcOpenCodedDeferDisallowed != <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p>按住 Command 后点击 <code>funcOpenCodedDeferDisallowed</code>可以看到只有 <code>funcOpenCodedDeferDisallowed(b)</code>可以修改它的值。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328140733594.png"alt="funcOpenCodedDeferDisallowed" /><figcaption aria-hidden="true">funcOpenCodedDeferDisallowed</figcaption></figure><p>我们来看看哪个地方会调用<code>funcOpenCodedDeferDisallowed()</code>，并将<code>funcOpenCodedDeferDisallowed</code> 设置为 <code>true</code>：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328140859879.png"alt="将 funcOpenCodedDeferDisallowed 设置为 true 的地方" /><figcaption aria-hidden="true">将 funcOpenCodedDeferDisallowed 设置为true 的地方</figcaption></figure><p>调用它的地方在 <ahref="https://github.com/golang/go/blob/release-branch.go1.22/src/cmd/compile/internal/walk/stmt.go">stmt.go</a>文件中的 <code>walkStmt()</code> 函数，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The max number of defers in a function using open-coded defers. We enforce this</span><br><span class="hljs-comment">// limit because the deferBits bitmask is currently a single byte (to minimize code size)</span><br><span class="hljs-keyword">const</span> maxOpenDefers = <span class="hljs-number">8</span><br><br><span class="hljs-comment">// The result of walkStmt MUST be assigned back to n, e.g.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//n.Left = walkStmt(n.Left)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkStmt</span><span class="hljs-params">(n ir.Node)</span></span> ir.Node &#123;<br>  ...<br><span class="hljs-keyword">switch</span> n.Op() &#123;<br>    ...<br>    <span class="hljs-keyword">case</span> ir.ODEFER:<br>      n := n.(*ir.GoDeferStmt)<br>      ir.CurFunc.SetHasDefer(<span class="hljs-literal">true</span>)<br>      ir.CurFunc.NumDefers++<br>      <span class="hljs-keyword">if</span> ir.CurFunc.NumDefers &gt; maxOpenDefers &#123;<br>        <span class="hljs-comment">// Don&#x27;t allow open-coded defers if there are more than</span><br>        <span class="hljs-comment">// 8 defers in the function, since we use a single</span><br>        <span class="hljs-comment">// byte to record active defers.</span><br>        ir.CurFunc.SetOpenCodedDeferDisallowed(<span class="hljs-literal">true</span>)<br>      &#125;<br>      <span class="hljs-keyword">if</span> n.Esc() != ir.EscNever &#123;<br>        <span class="hljs-comment">// If n.Esc is not EscNever, then this defer occurs in a loop,</span><br>        <span class="hljs-comment">// so open-coded defers cannot be used in this function.</span><br>        ir.CurFunc.SetOpenCodedDeferDisallowed(<span class="hljs-literal">true</span>)<br>      &#125;<br>      <span class="hljs-keyword">fallthrough</span><br>    ...<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>第一点是：当前函数中 <code>defer</code> 个数超过 8的话，则禁用开放编码。</p><p>第二点是当 <code>n.Esc() != ir.EscNever</code>使，就禁用开放编码。这个要求跟前面分析的“栈上分配”要求是一样的。</p><p>这里再补充一点：什么时候 <code>n.Esc()</code> 会被设置为<code>ir.EscNever</code> 呢？</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328192005520.png"alt="n.SetEsc(ir.EscNever)" /><figcaption aria-hidden="true">n.SetEsc(ir.EscNever)</figcaption></figure><p>这里面核心点是第一个，它对应的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *escape)</span></span> goDeferStmt(n *ir.GoDeferStmt) &#123;<br>k := e.heapHole()<br><span class="hljs-keyword">if</span> n.Op() == ir.ODEFER &amp;&amp; e.loopDepth == <span class="hljs-number">1</span> &#123;<br>...<br>n.SetEsc(ir.EscNever)<br>&#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>e.loopDepth == 1</code> 时就设置，换言之，<code>defer</code>不在循环中的时候，才允许开放编码。</p><p>总而言之，第 ① 个条件约束了要采用<code>open-coded 开放编码</code>策略的 3 个条件：</p><ol type="1"><li>函数中 <code>defer</code> 个数不能超过 <strong>8</strong>；</li><li><code>defer</code> 不能在循环中；</li><li><code>defer</code> 不能发生逃逸。</li></ol><h3 id="base.debug.noopendefer-0">② base.Debug.NoOpenDefer != 0</h3><blockquote><p>如果<code>base.Debug.NoOpenDefer</code>不为0，那么禁用开放式延迟。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">NoOpenDefer           <span class="hljs-type">int</span>    <span class="hljs-string">`help:&quot;disable open-coded defers&quot; concurrent:&quot;ok&quot;`</span><br></code></pre></td></tr></table></figure><h3id="base.ctxt.flag_shared-base.ctxt.flag_dynlink-base.ctxt.arch.name-386">③(base.Ctxt.Flag_shared || base.Ctxt.Flag_dynlink) &amp;&amp;base.Ctxt.Arch.Name == "386"</h3><blockquote><p>如果当前架构是<code>386</code>，并且使用共享库或动态链接，那么不支持开放式延迟，因为存在一些额外的代码（由<code>rewriteToUseGot()</code>添加）可能无法正确追踪。</p></blockquote><h3 id="lens.curfn.exit">④ len(s.curfn.Exit)</h3><blockquote><p>如果存在任何额外的退出代码（比如可能是竞态检测相关的代码），则跳过开放式延迟。</p></blockquote><h3 id="f.nname.ir.name.onstack">⑤ !f.Nname.(*ir.Name).OnStack()</h3><blockquote><p>如果有任何堆分配的结果参数需要复制回它们的栈槽，也跳过开放式延迟。</p></blockquote><h3 id="s.curfn.numreturnss.curfn.numdefers-15">⑥s.curfn.NumReturns*s.curfn.NumDefers &gt; 15</h3><blockquote><p>如果函数的返回数乘以延迟调用数大于<strong>15</strong>，考虑到每个退出点都要生成延迟调用，并且开放式延迟对于小函数（没有多个返回）的性能提升最为重要，所以在这种情况下也不使用开放式延迟。</p></blockquote><h2 id="堆上分配">堆上分配</h2><p>当不满足开放编码和栈上分配的时候，默认就是堆上分配（heap-allocated），性能最差，这里不做分析。</p><hr /><p>以上就是本文关于 Go 语言中 <code>defer</code> 关键字的具体分析，HappyCoding! Peace~</p><h1 id="参考">参考</h1><ul><li><a href="https://book.douban.com/subject/36403287/">深入理解 Go语言</a></li><li><a href="https://book.douban.com/subject/35556889/">Go语言底层原理剖析</a></li><li><ahref="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/">Go语言设计与实现</a></li><li>ChatGPT4</li></ul>]]></content>
    
    
    <summary type="html">本文将深入浅出地介绍 defer 的工作原理，探究其背后的机制，并通过丰富的案例来展示它的实际应用。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>深入 Go 语言核心：结构体的全方位解析</title>
    <link href="https://hedon.top/2024/03/09/go-struct/"/>
    <id>https://hedon.top/2024/03/09/go-struct/</id>
    <published>2024-03-09T08:59:34.000Z</published>
    <updated>2024-06-13T03:22:59.050Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言，作为一种高效、静态类型的编程语言，自其问世以来便以其并发处理能力和简洁的语法结构广受开发者欢迎。虽然Go不是传统意义上的面向对象语言，它却以独特的方式支持面向对象编程的核心概念，其中结构体扮演了非常关键的角色。</p><p>结构体在 Go语言中是一种复合数据类型，允许我们将不同类型的数据聚合到一起。它不仅提高了数据管理的效率和逻辑清晰度，还是Go语言中实现面向对象编程思想如封装、组合等概念的基石。了解和掌握结构体的使用，对于深入理解Go 语言的特性和编写高效、可维护的 Go 代码至关重要。</p><p>本文将带您全面深入地探索 Go语言中结构体的各个方面，从基本定义、初始化和使用，到高级特性如结构体的组合、方法定义、内存对齐等，每一个细节都将一一展开。无论您是Go语言的新手，还是有一定经验的开发者，相信本文都能为您提供有价值的见解和帮助。让我们一起探索Go结构体的奥秘，揭开其背后的原理，优化我们的代码结构，提升编程效率。</p><h1 id="版本声明">版本声明</h1><ul><li>Go 1.22.1</li><li>gopkg.in/yaml.v3 v3.0.1</li><li>os: m2max</li></ul><h1 id="全文概览">全文概览</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/go-struct.png"alt="Go 语言结构体" /><figcaption aria-hidden="true">Go 语言结构体</figcaption></figure><h1 id="结构体的基本使用">1. 结构体的基本使用</h1><h2 id="定义结构体">1.1 定义结构体</h2><p>结构体类型的定义形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>  Field T1,<br>  Field T2,<br>  ....<br>  FieldN Tn,<br>&#125;<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  Name <span class="hljs-type">string</span><br>  Age <span class="hljs-type">int</span><br>  ExtraInfo <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体内部，也可以内嵌<strong>匿名结构体</strong>，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>  Age <span class="hljs-type">int</span><br>  School <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Address <span class="hljs-type">string</span><br>    Phone <span class="hljs-type">string</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但是！注意，如果 Person 中包含了 Person 呢？</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>person  Person<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会报错：不允许引用自身。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./main.go:5:6: invalid recursive <span class="hljs-built_in">type</span>: Person refers to itself<br></code></pre></td></tr></table></figure><p>这是因为 Go语言在编译时需要知道每个类型的确切大小，以便正确地分配内存。但在这个定义中，因为<code>Person</code> 包含自身，编译器无法确定 <code>Person</code>的大小，因此会报错。</p><p>如果你需要在一个结构体中引用相同类型的数据，你应该使用指针。指针的大小是固定的，因此编译器可以确定结构体的大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  person *Person<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化结构体">1.2 初始化结构体</h2><p>假设我们有以下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name      <span class="hljs-type">string</span><br>Age       <span class="hljs-type">int</span><br>ExtraInfo <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以有以下几种初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 逐个字段赋值，顺序不重要，也可以只赋值部分字段</span><br>person1 := Person&#123;<br>  Age:       <span class="hljs-number">18</span>,<br>  Name:      <span class="hljs-string">&quot;hedon&quot;</span>,<br>  ExtraInfo: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;),<br>&#125;<br>fmt.Println(person1) <span class="hljs-comment">// &#123;hedon 18 map[]&#125;</span><br><br><span class="hljs-comment">// 可以不指定字段，严格按照顺序</span><br>person2 := Person&#123;<span class="hljs-string">&quot;hedon2&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)&#125;<br>fmt.Println(person2) <span class="hljs-comment">// &#123;hedon2 19 map[]&#125;</span><br><br><span class="hljs-comment">// 默认初始化，则结构体中的每个字段都会被默认赋予其对应类型的“零值”</span><br><span class="hljs-keyword">var</span> person3 Person<br>fmt.Println(person3)                  <span class="hljs-comment">// &#123; 0 map[]&#125;</span><br>fmt.Println(person3.ExtraInfo == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 也可以使用 new() 或 &amp; 来初始化并返回指针</span><br>person3 := <span class="hljs-built_in">new</span>(Person)<br>fmt.Println(person3)  <span class="hljs-comment">// &amp;&#123; 0 map[]&#125;</span><br></code></pre></td></tr></table></figure><h2 id="空结构体">1.3 空结构体</h2><p>有一种特殊的结构体，它一个字段都没有，我们称之为“空结构体”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>空结构体非常特殊，它不占据任何空间！你可以自己验证一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;the size of empty:&quot;</span>, unsafe.Sizeof(Empty&#123;&#125;)) <span class="hljs-comment">// the size of empty: 0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而且，所有空结构体的地址都一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">type</span> Empty1 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>e := Empty&#123;&#125;<br>e1 := Empty1&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;the address of empty: %p\n&quot;</span>, &amp;e) <span class="hljs-comment">// the address of empty: 0x10460f520</span><br>fmt.Printf(<span class="hljs-string">&quot;the address of empty1: %p\n&quot;</span>, &amp;e1)  <span class="hljs-comment">// the address of empty1: 0x10460f520</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为 Go 语言为所有大小为 0 的变量都指向了同一个值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// base address for all 0-byte allocations</span><br><span class="hljs-keyword">var</span> zerobase <span class="hljs-type">uintptr</span><br></code></pre></td></tr></table></figure><p>好处就是减少了内存的浪费。典型的用法就是我们可以使用 map 来实现Set，这样就只花费了存储键的空间，而值不占用任何空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="访问和修改结构体">1.4 访问和修改结构体</h2><ul><li>结构体属性的可见性跟 Go包的可见性规则一样：大写对包外可见，小写仅包内可见。</li><li>使用 <code>.</code> 访问和修改结构体中的属性。</li><li>Go语言中只有“<strong>值传递</strong>”，所以如果你要将结构体示例传入一个func 进行修改，则需要传入其引用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>UpdatePersonName(p)<br>fmt.Println(<span class="hljs-string">&quot;1:&quot;</span>, p)<br>UpdatePersonNameWithRef(&amp;p)<br>fmt.Println(<span class="hljs-string">&quot;2:&quot;</span>, p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdatePersonName</span><span class="hljs-params">(p Person)</span></span> &#123;<br>p.Name = <span class="hljs-string">&quot;hedon-1&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdatePersonNameWithRef</span><span class="hljs-params">(p *Person)</span></span> &#123;<br>p.Name = <span class="hljs-string">&quot;hedon-2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">1: &#123;hedon 18&#125;<br>2: &#123;hedon-2 18&#125;<br></code></pre></td></tr></table></figure><h1 id="结构体的高级特性">2. 结构体的高级特性</h1><h2 id="结构体组合">2.1 结构体组合</h2><p>在 Go语言中，倡导的是“组合优于继承”的哲学，即倡导使用组合而不是继承来实现代码的复用。该理念鼓励开发者通过组合和接口来构建灵活、可维护的代码，而不是依赖于更严格、更易出错的继承关系。这种方式促进了代码的解耦，增强了代码的灵活性和可重用性，同时也使得代码更加清晰和易于理解。</p><p>在 Go中，组合是通过将一个或多个类型（通常是结构体）嵌入到另一个结构体中来实现的。这使得嵌入的类型的方法被“提升”到包含它的结构体中，允许你调用这些方法就像它们是外部结构体的一部分一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    Power <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Engine)</span></span> Start() &#123;<br>    <span class="hljs-comment">// 启动引擎的逻辑</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Car <span class="hljs-keyword">struct</span> &#123;<br>    Engine <span class="hljs-comment">// 通过组合的方式嵌入 Engine</span><br>&#125;<br><br><span class="hljs-comment">// 现在 Car 可以直接调用 Start 方法</span><br>car := Car&#123;Engine&#123;Power: <span class="hljs-number">100</span>&#125;&#125;<br>car.Start() <span class="hljs-comment">// 调用的是 Engine 的 Start 方法</span><br></code></pre></td></tr></table></figure><h2 id="结构体的方法">2.2 结构体的方法</h2><p>假设我们定义了一个结构体 Person：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Go 中，你可以为结构体的值或指针实现特定的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>  p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *Person)</span></span> SetName(name <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>  p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>这两者最核心的区别是：<strong>当你为结构体的指针类型定义方法时，该方法会在原始结构体实例上操作。这意味着方法内部对结构体的任何修改都会影响到原始结构体。</strong></p><p>所以这两段代码的输出是不一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(p.Name)   <span class="hljs-comment">// name_name</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(p.Name)  <span class="hljs-comment">// hedon</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这里我想再补充两个小点。请先思考一下下面这两段代码是否可以编译通过？如果可以输出是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;person name after set:&quot;</span>, p.Name)<br><br>pt := reflect.TypeOf(p)<br>fmt.Println(<span class="hljs-string">&quot;the number of person&#x27;s method: &quot;</span>, pt.NumMethod())<br><br>p2 := &amp;Person&#123;&#125;<br>pt = reflect.TypeOf(p2)<br>fmt.Println(<span class="hljs-string">&quot;the number of &amp;person&#x27;s method: &quot;</span>, pt.NumMethod())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;person name after set:&quot;</span>, p.Name)<br><br>pt := reflect.TypeOf(p)<br>fmt.Println(<span class="hljs-string">&quot;the number of person&#x27;s method: &quot;</span>, pt.NumMethod())<br><br>p2 := &amp;Person&#123;&#125;<br>pt = reflect.TypeOf(p2)<br>fmt.Println(<span class="hljs-string">&quot;the number of &amp;person&#x27;s method: &quot;</span>, pt.NumMethod())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显这两段代码的唯一区别就是，第一段代码我们是为<code>*Person</code> 实现了 <code>SetName</code>方法，而第二段代码我们是为 <code>Person</code> 实现了<code>SetName</code> 方法。两段代码我们都打印了调用 <code>SetName</code>后 <code>p.name</code> 的值，以及利用方式分别获取 <code>Person</code> 和<code>*Person</code> 实现的方法个数。</p><p>第一段代码的输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">person name after set: new<span class="hljs-built_in">_</span>name<br>the number of person&#x27;s method:  0<br>the number of <span class="hljs-built_in">&amp;</span>person&#x27;s method:  1<br></code></pre></td></tr></table></figure><p>第二段代码的输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">person name after set: hedon<br>the number of person&#x27;s method:  1<br>the number of <span class="hljs-built_in">&amp;</span>person&#x27;s method:  1<br></code></pre></td></tr></table></figure><p>这里我们可以得出 2 个结论：</p><p><strong>① 结构体的修改依赖于方法接收器的类型</strong>：</p><ul><li>当方法的接收器为值类型（<code>Person</code>）时，对结构体的修改不会影响原始结构体实例，因为方法作用于结构体的副本上。</li><li>当方法的接收器为指针类型（<code>*Person</code>）时，对结构体的修改会影响原始结构体实例，因为方法作用于结构体的引用上。</li></ul><p><strong>② 方法集依赖于接收器的类型</strong>：</p><ul><li>为值类型（<code>Person</code>）实现的方法，既属于值类型也属于指针类型（<code>*Person</code>）的方法集。</li><li>为指针类型（<code>*Person</code>）实现的方法，只属于指针类型的方法集。</li></ul><p>对于 ②，我们可以通过 Plan9 汇编代码一探究竟。</p><p>我们为第一段代码执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -gcflags -S main.go<br></code></pre></td></tr></table></figure><p>在输出的最上面，可以看到只有<code>main.(*Person).GetName</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"># command-line-arguments<br>main.main STEXT size=<span class="hljs-number">128</span> args=<span class="hljs-number">0x0</span> locals=<span class="hljs-number">0x48</span> funcid=<span class="hljs-number">0x0</span> align=<span class="hljs-number">0x0</span><br>        ...<br>main.(*Person).GetName STEXT size=<span class="hljs-number">16</span> args=<span class="hljs-number">0x8</span> locals=<span class="hljs-number">0x0</span> funcid=<span class="hljs-number">0x0</span> align=<span class="hljs-number">0x0</span> leaf<br>       ...<br></code></pre></td></tr></table></figure><p>我们再来为第二段代码执行相同的命令。可以在输出的最上面，看到不仅有<code>main.Person.GetName</code>，还可以发现编译器自动帮我们生成了<code>main.(*Person).GetName</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># command-line-arguments</span><br>main.main STEXT size=480 args=0x0 locals=0xe8 funcid=0x0 align=0x0<br>...<br>main.Person.SetName STEXT size=16 args=0x28 locals=0x0 funcid=0x0 align=0x0 leaf<br>   ...<br>main.(*Person).SetName STEXT dupok size=128 args=0x18 locals=0x8 funcid=0x16 align=0x0<br>...<br></code></pre></td></tr></table></figure><p>对于 ②，笔者其实有一个不太理解的地方，比如下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := &amp;Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;person name after set:&quot;</span>, p.Name) <span class="hljs-comment">// hedon</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>p</code> 是引用类型，下面实现的是<code>Person.SetName</code>，按照我们上面的结论，编译器会自动帮我们实现<code>(*Person).SetName</code>。按照这种思路，输出 <code>new_name</code>也是解释得通的。因为既然我们声明的是一个引用类型，那么 <code>p</code>完全可以去调用自动生成的<code>(*Person).SetName</code>。但是最终的结果还是输出<code>hedon</code>，所以这里编译器自动帮我们将 <code>p</code>进行解引用，然后调用了 <code>Person.SetName</code>。</p><p>这是比较困扰笔者的一个地方，欢迎评论区讨论~</p><p>可能编译器还是更希望对于开发者来说“所见即所得”，既然开发者实现的是<code>Person.SetName</code>，那么对于开发者来说，应该就是希望不影响原始结构体的值，所以编译器还是选择遵循这种“意愿”，不乱操作。</p><h2 id="结构体比较">2.3 结构体比较</h2><p>Go 允许直接比较两个结构体实例，但有一定的限制：</p><ol type="1"><li><strong>可比较性</strong>：只有当结构体中的所有字段都是可比较的时，结构体才是可比较的。基本数据类型（如int、string 等）是可比较的，但切片、映射、函数等类型不可比较。</li><li><strong>相等性检测</strong>：当两个结构体的对应字段都相等时，这两个结构体被认为是相等的。可以使用<code>==</code> 和 <code>!=</code> 操作符来进行比较。</li></ol><p>下面这段示例，<code>p3==p4</code> 返回了<code>true</code>，这符合我们上面总结的结论。<code>p1==p2</code> 返回了<code>false</code>，因为这其实不是结构体之间的比较了，这是指针的比较了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">p1 := &amp;Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>p2 := &amp;Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>fmt.Println(p1 == p2) <span class="hljs-comment">// false</span><br>p3 := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>p4 := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>fmt.Println(p3 == p4) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>结构体的比较只支持 <code>==</code> 和 <code>!=</code>，不支持<code>&lt;</code> 和 <code>&gt;</code> 等其他运算符的比较。而 Go语言又不支持比较符重载。所以如果你要比较两个结构体的大小，那么只能自行封装类型<code>compare</code>的函数。在这我们排序结构体数组或切片的时候，经常使用到，比如我们希望按<code>Age</code> 字段从小到大排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Slice(persons, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">return</span> persons[i].Age &lt; persons[j].Age<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="结构体复制">2.4 结构体复制</h2><p>在 Go中，结构体也是值类型，这意味着当它们被赋值给新的变量或作为函数参数传递时，实际上是进行了一次深拷贝：</p><ol type="1"><li><strong>值复制</strong>：当将一个结构体赋值给一个新变量时，新变量会获得原始结构体的一个副本，它们在内存中占有不同的位置。</li><li><strong>独立性</strong>：因为是深拷贝，所以原始结构体和副本结构体是完全独立的；修改其中一个不会影响另一个。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">int</span><br>&#125;<br><br>original := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><span class="hljs-built_in">copy</span> := original<br><span class="hljs-built_in">copy</span>.X = <span class="hljs-number">3</span><br><br>fmt.Println(original) <span class="hljs-comment">// &#123;1, 2&#125;</span><br>fmt.Println(<span class="hljs-built_in">copy</span>)     <span class="hljs-comment">// &#123;3, 2&#125;</span><br></code></pre></td></tr></table></figure><h1 id="结构体与接口">3. 结构体与接口</h1><p>在 Go语言中，如果一个类型实现了接口中所有的方法，则这个类型就实现了该接口。关于接口部分的知识点，比如接口定义、多态和断言等，本文就不赘述了。</p><p>在这里我主要想从另外一个角度继续来验证前面我们总结的：<strong>为值类型（<code>Person</code>）实现的方法，既属于值类型也属于指针类型（<code>*Person</code>）的方法集</strong>。</p><p>请看这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">interface</span> &#123;<br>GetName() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Man <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m Man)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> m.Name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintPersonName</span><span class="hljs-params">(p Person)</span></span> &#123;<br>fmt.Println(p.GetName())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m1 := Man&#123;Name: <span class="hljs-string">&quot;hedon1&quot;</span>&#125;<br>PrintPersonName(m1)<br>m2 := &amp;Man&#123;Name: <span class="hljs-string">&quot;hedon2&quot;</span>&#125;<br>PrintPersonName(m2)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码我们定义了 <code>Person</code> 接口，它只有一个方法<code>GetName</code>。然后我们定义了一个结构体<code>Man</code>，并为它的值类型实现了 <code>Person</code>接口。通过我们上面的结论，这里 <code>Man</code> 和 <code>*Man</code>其实都实现了 <code>Person</code>接口，所以上面的代码是可以编译通过的。</p><p>如果改成为指针类型实现接口呢？你可以试一下~</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Man)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> m.Name<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="泛型结构体">4. 泛型结构体</h1><p>Go 语言在其 1.18版本中引入了泛型支持，这包括了对泛型结构体的支持。通过使用泛型，你可以创建更灵活和可重用的数据结构和函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Container[T any] <span class="hljs-keyword">struct</span> &#123;<br>items []T<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 Go 语言用 <code>[]</code> 来实现泛型，而不像其他语言一样用<code>&lt;&gt;</code>，真是喜欢搞特殊啊 🤡，又丑又容易跟 map 和 slice混淆。</p><h1 id="结构体的标签tag">5. 结构体的标签（Tag）</h1><p>在结构体字段后面，我们可以用 <strong>``</strong>来指定标签，这允许我们对结构体定制化一些常用操作，最经典的就是序列化与反序列化。</p><h2 id="序列化与反序列化">5.1 序列化与反序列化</h2><p>对于常见的数据结构，如<code>json</code>、<code>yaml</code>、<code>xml</code> 或<code>toml</code>，我们都可以通过在结构体中指定标签，然后使用对应解析库进行序列化和反序列化。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>bs, _ := json.Marshal(p) <span class="hljs-comment">// 序列化</span><br>fmt.Println(<span class="hljs-type">string</span>(bs))  <span class="hljs-comment">// &#123;&quot;name&quot;:&quot;hedon&quot;,&quot;age&quot;:18&#125;</span><br>newP := Person&#123;&#125;<br>_ = json.Unmarshal(bs, &amp;newP) <span class="hljs-comment">// 反序列化</span><br>fmt.Println(newP)             <span class="hljs-comment">// &#123;hedon 18&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在笔者的实践过程中，在结构体组合的场景下，不同数据格式的解析会有一些小差别，这在实战过程中你需要重点关注和验证。比如<code>json</code> 和 <code>yaml</code> 就会有一些不同。</p><p>比如说我这里定义了下面 2 个结构体，其中 <code>Person</code> 组合了<code>School</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot; yaml:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot; yaml:&quot;age&quot;`</span><br>School<br>&#125;<br><br><span class="hljs-keyword">type</span> School <span class="hljs-keyword">struct</span> &#123;<br>SchoolName    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;school_name&quot; yaml:&quot;school_name&quot;`</span><br>SchoolAddress <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;school_address&quot; json:&quot;school_address&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它们都加上了 <code>json</code> 和 <code>yaml</code> 标签，对于<code>json</code> 类型，你可以用标准库的 <code>encoding/json</code>来进行序列化和反序列化，而 <code>yaml</code> 你可以使用第三方库：<ahref="https://github.com/go-yaml/yaml">go-yaml</a>。</p><p>先来看系列化结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>, School: School&#123;SchoolName: <span class="hljs-string">&quot;nb_school&quot;</span>, SchoolAddress: <span class="hljs-string">&quot;a_good_school_place&quot;</span>&#125;&#125;<br>bs, _ := json.Marshal(p)<br>fmt.Println(<span class="hljs-string">&quot;json:\n&quot;</span>, <span class="hljs-type">string</span>(bs))<br>bs, _ = yaml.Marshal(p)<br>fmt.Println(<span class="hljs-string">&quot;yaml:\n&quot;</span>, <span class="hljs-type">string</span>(bs))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">json:<br> &#123;&quot;name&quot;:&quot;hedon&quot;,&quot;age&quot;:18,&quot;school<span class="hljs-built_in">_</span>name&quot;:&quot;nb<span class="hljs-built_in">_</span>school&quot;,&quot;school<span class="hljs-built_in">_</span>address&quot;:&quot;a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>school<span class="hljs-built_in">_</span>place&quot;&#125;<br>yaml:<br> name: hedon<br> age: 18<br> school:<br>    school<span class="hljs-built_in">_</span>name: nb<span class="hljs-built_in">_</span>school<br>    school<span class="hljs-built_in">_</span>address: a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>school<span class="hljs-built_in">_</span>place<br></code></pre></td></tr></table></figure><p>通过观察你可以发现哈，在 <code>json</code> 中，组合的时候（没有给School 加标签）直接将 <code>School</code> 平铺在 <code>Person</code>中，所以在序列化的结果中，找不到 <code>"school": &#123;&#125;</code>。而在<code>yaml</code> 中，并不是直接平铺的。</p><p>这个区别在你解析配置文件的时候尤其重要，如果不注意，那么可能会导致配置解析失败。</p><p>我准备了 4 个配置文件，分别是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// person1.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon_json&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;school_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nb_json_school&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;school_address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_good_place_in_json&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># person1.yaml</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;hedon_yaml&quot;</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">school:</span><br>  <span class="hljs-attr">school_name:</span> <span class="hljs-string">&quot;nb_yaml_school&quot;</span><br>  <span class="hljs-attr">school_address:</span> <span class="hljs-string">&quot;a_good_price_in_yaml&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// person2.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon_json&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nb_json_school&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school_address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_good_place_in_json&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># person2.yaml</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;hedon_yaml&quot;</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">school_name:</span> <span class="hljs-string">&quot;nb_yaml_school&quot;</span><br><span class="hljs-attr">school_address:</span> <span class="hljs-string">&quot;a_good_price_in_yaml&quot;</span><br></code></pre></td></tr></table></figure><p>解析代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filenames := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;person1.json&quot;</span>, <span class="hljs-string">&quot;person1.yaml&quot;</span>, <span class="hljs-string">&quot;person2.json&quot;</span>, <span class="hljs-string">&quot;person2.yaml&quot;</span>&#125;<br><span class="hljs-keyword">for</span> i, fn := <span class="hljs-keyword">range</span> filenames &#123;<br>bs := readFileIntoBytes(fn)<br>p := Person&#123;&#125;<br><span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>_ = json.Unmarshal(bs, &amp;p)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>_ = yaml.Unmarshal(bs, &amp;p)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s -&gt; %v\n&quot;</span>, fn, p)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFileIntoBytes</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>f, err := os.Open(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>bs, _ := io.ReadAll(f)<br><span class="hljs-keyword">return</span> bs<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">person1.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123; &#125;&#125;<br>person1.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123;nb<span class="hljs-built_in">_</span>yaml<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>price<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>yaml&#125;&#125;<br>person2.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123;nb<span class="hljs-built_in">_</span>json<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>place<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>json&#125;&#125;<br>person2.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123; &#125;&#125;<br></code></pre></td></tr></table></figure><p>如果给 <code>School</code> 字段加上 <code>json tag</code>的话，结果又是不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot; yaml:&quot;name&quot;`</span><br>Age    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot; yaml:&quot;age&quot;`</span><br>School <span class="hljs-string">`json:&quot;school&quot; yaml:&quot;school&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">person1.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123;nb<span class="hljs-built_in">_</span>json<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>place<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>json&#125;&#125;<br>person1.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123;nb<span class="hljs-built_in">_</span>yaml<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>price<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>yaml&#125;&#125;<br>person2.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123; &#125;&#125;<br>person2.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123; &#125;&#125;<br></code></pre></td></tr></table></figure><p>可以看到受影响的只有 <code>json</code>。</p><p>到这里我们可以总结：<strong>在组合场景下，如果不明确指定<code>tag</code>，<code>yaml</code> 解析期望字段是嵌套的，而<code>json</code> 解析期望字段是平铺的</strong>。</p><h2 id="自定义-tag">5.2 自定义 Tag</h2><p>在 Go中，你可以为结构体字段定义任意的标签。这些标签在编译时会被存储，并且可以在运行时通过反射（reflection）来访问。</p><p>假设我们定义一个名为 <code>check</code>的标签，它用于我们对结构体字段的检查，假设我们这个标签支持以下功能：</p><ul><li><code>check:"strnoempty"</code>: 字符串不可以为空。</li></ul><p>假如加入 <code>check</code> 标签的 <code>Person</code>结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`check:&quot;strnoempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来为 <code>check</code> 实现解析函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckPerson</span><span class="hljs-params">(p Person)</span></span> <span class="hljs-type">error</span> &#123;<br>pt := reflect.TypeOf(p)<br>pv := reflect.ValueOf(p)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; pt.NumField(); i++ &#123;<br>field := pt.Field(i)<br>tagValue := field.Tag.Get(<span class="hljs-string">&quot;check&quot;</span>)<br><span class="hljs-keyword">if</span> tagValue == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> field.Type.Kind() == reflect.String &amp;&amp; tagValue == <span class="hljs-string">&quot;strnoempty&quot;</span> &#123;<br><span class="hljs-keyword">if</span> err := checkStrNoEmpty(field.Name, pv.Field(i).Interface()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkStrNoEmpty</span><span class="hljs-params">(fieldName <span class="hljs-type">string</span>, v any)</span></span> <span class="hljs-type">error</span> &#123;<br>s, ok := v.(<span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%v is not string&quot;</span>, v)<br>&#125;<br><span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;[check] %s should not be empty&quot;</span>, fieldName)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p1 := Person&#123;&#125;<br>p2 := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>fmt.Println(CheckPerson(p1)) <span class="hljs-comment">// [check] Name should not be empty</span><br>fmt.Println(CheckPerson(p2)) <span class="hljs-comment">// &lt;nil&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结构体内存对齐">6. 结构体内存对齐</h1><p>在本小节中，我们将探讨 Go 语言结构体的内存结构和对齐策略。</p><h2 id="问题引出">6.1 问题引出</h2><p>思考下面这段代码的输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num2 <span class="hljs-type">int8</span><br>num1 <span class="hljs-type">int16</span><br>flag <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S2 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int8</span><br>flag <span class="hljs-type">bool</span><br>num2 <span class="hljs-type">int16</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(unsafe.Sizeof(S1&#123;&#125;))<br>fmt.Println(unsafe.Sizeof(S2&#123;&#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么仅是字段顺序不同，<code>S1&#123;&#125;</code> 和 <code>S2&#123;&#125;</code>的大小就不一样了？</p><p>我们可以写个简单的程序来输出 <code>S1</code> 和 <code>S2</code>的内存结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := S1&#123;&#125;<br>s2 := S2&#123;&#125;<br>fmt.Print(<span class="hljs-string">&quot;s1: &quot;</span>)<br>printMemory(s1)<br>fmt.Print(<span class="hljs-string">&quot;s2: &quot;</span>)<br>printMemory(s2)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMemory</span><span class="hljs-params">(a any)</span></span> &#123;<br>t := reflect.TypeOf(a)<br>mem := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>(t.Size()))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>field := t.Field(i)<br>offset := <span class="hljs-type">int</span>(field.Offset)<br>size := <span class="hljs-type">int</span>(field.Type.Size())<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; size; j++ &#123;<br>mem[j+offset] = i + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>fmt.Println(mem)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s1: [<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span>]<br>s2: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>其中 <code>1</code>、<code>2</code>、<code>3</code>分别替代结构体中的第 1/2/3 个字段所占用的内存。这里可以看到<code>s1</code> 的长度是 6 字节，而 <code>s2</code> 是 4 字节。这里<code>s1</code> 比 <code>s2</code> 多出的 2 个字节就是这两个填充的<code>0</code>。这而 2个字节的填充，就是为了<strong>内存对齐</strong>。</p><h2 id="内存对齐">6.2 内存对齐</h2><p>如上分析，<code>s1</code> 的内存结构如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310154903219.png"alt="s1 内存结构" /><figcaption aria-hidden="true">s1 内存结构</figcaption></figure><p>如果没有内存对齐呢？<code>s1</code> 的结构可能如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310155353882.png"alt="没有内存对齐的 s1 内存结构" /><figcaption aria-hidden="true">没有内存对齐的 s1 内存结构</figcaption></figure><p>如果是 16 位系统的话，那么没有内存对齐的情况下，要访问<code>s1.num2</code> 字段，就需要跨过 2个系统字长的内存，效率就低了。具体来说，内存对齐是计算机内存分配的一种优化方式，用于确保数据结构的存储按照特定的字节边界对齐。这种对齐是为了提高计算机处理数据的效率。</p><h2 id="对齐系数">6.3 对齐系数</h2><ul><li>对齐系数：变量的内存地址必须被对齐系数整除。</li><li><code>unsafe.Alignof()</code>: 可以查看值在内存中的对齐系数。</li></ul><h2 id="基本类型对齐">6.4 基本类型对齐</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;bool size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">bool</span>(<span class="hljs-literal">true</span>)), unsafe.Alignof(<span class="hljs-type">bool</span>(<span class="hljs-literal">true</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;byte size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">byte</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">byte</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int8 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int8</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int8</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int16 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int16</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int16</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int32 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int64 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int64</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int64</span>(<span class="hljs-number">0</span>)))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">bool</span> size: <span class="hljs-number">1</span>, align: <span class="hljs-number">1</span><br><span class="hljs-type">byte</span> size: <span class="hljs-number">1</span>, align: <span class="hljs-number">1</span><br><span class="hljs-type">int8</span> size: <span class="hljs-number">1</span>, align: <span class="hljs-number">1</span><br><span class="hljs-type">int16</span> size: <span class="hljs-number">2</span>, align: <span class="hljs-number">2</span><br><span class="hljs-type">int32</span> size: <span class="hljs-number">4</span>, align: <span class="hljs-number">4</span><br><span class="hljs-type">int64</span> size: <span class="hljs-number">8</span>, align: <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>结论：基本类型的对齐系数跟它的长度一致。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310160412598.png"alt="基本类型内存对齐" /><figcaption aria-hidden="true">基本类型内存对齐</figcaption></figure><h2 id="结构体内部对齐">6.5 结构体内部对齐</h2><p>结构体内存对齐分为内部对齐和结构体之间对齐。</p><p>我们先来看结构体内部对齐：</p><ul><li>指的是结构体内部成员的相对位置（偏移量）；</li><li>每个成员的偏移量是 <strong>自身大小</strong> 和<strong>对齐系数</strong> 的较小值的倍数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br>  a <span class="hljs-type">bool</span><br>  b <span class="hljs-type">string</span><br>  c <span class="hljs-type">int16</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假如我们定义了上面的结构体 <code>Demo</code>，如果在 64位系统上（字长为 8 字节）通过上面的规则，可以判断出：（单位为字节）</p><ul><li>a: size=1, align=1</li><li>b: size=16, align=8</li><li>c: size=2, align=2</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310163126556.png"alt="Demo 内存结构" /><figcaption aria-hidden="true">Demo 内存结构</figcaption></figure><p>当然我们也可以通过程序输出来验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">bool</span>   <span class="hljs-comment">// size=1, align=1</span><br>b <span class="hljs-type">string</span> <span class="hljs-comment">// size=16, align=8</span><br>c <span class="hljs-type">int16</span>  <span class="hljs-comment">// size=2, align=2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>d := Demo&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(d.a), unsafe.Alignof(d.a))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(d.b), unsafe.Alignof(d.b))<br>fmt.Printf(<span class="hljs-string">&quot;c: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(d.c), unsafe.Alignof(d.c))<br>printMemory(d)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMemory</span><span class="hljs-params">(a any)</span></span> &#123;<br>t := reflect.TypeOf(a)<br>mem := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>(t.Size()))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>field := t.Field(i)<br>offset := <span class="hljs-type">int</span>(field.Offset)<br>size := <span class="hljs-type">int</span>(field.Type.Size())<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; size; j++ &#123;<br>mem[j+offset] = i + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>fmt.Println(mem)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>c: size=<span class="hljs-number">2</span>, align=<span class="hljs-number">2</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="结构体长度填充">6.6 结构体长度填充</h2><p>上面 Demo 结构体最后还填了 6 个字节的 0，这就是结构体长度填充：</p><ul><li>结构体通过填充长度，来对齐系统字长。</li><li>结构体长度是 <strong>最大成员长度</strong> 和<strong>系统字长</strong> 较小值的整数倍。</li></ul><p>我的系统环境是 m2max，系统字长是 8 字节，Demo 最大成员长度是<code>b string</code>，即 16 个字节，所以 <code>Demo</code> 的长度应该是<code>8</code> 的倍数，所以最后填充了 6 个字节的 0。</p><h2 id="结构体之间对齐">6.7 结构体之间对齐</h2><ul><li>结构体之间对齐，是为了确定结构体的第一个成员变量的内存地址，以让后面的成员地址都合法。</li><li>结构体的对齐系数是 <strong>其成员的最大对齐系数</strong>；</li></ul><h2 id="空结构体对齐">6.8 空结构体对齐</h2><p>前面我们专门讨论了空结构体<code>struct&#123;&#125;</code>，它们的内存地址统一指向<code>zerobase</code>，而且内存长度为0。这也导致了它的内存对齐规则，有一些不同。具体可以分为以下 4个情况。</p><h3 id="空结构体单独存在">6.8.1 空结构体单独存在</h3><p>空结构体单独存在时，其内存地址为<code>zerobase</code>，不额外分配内存。</p><h3 id="空结构体在结构体最前">6.8.2 空结构体在结构体最前</h3><p>空结构体是结构体第一个字段时，它的地址跟结构体本身及结构体第 2个字段一样，不占据内存空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestEmpty <span class="hljs-keyword">struct</span> &#123;<br>empty <span class="hljs-keyword">struct</span>&#123;&#125;<br>a     <span class="hljs-type">bool</span><br>b     <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>te := TestEmpty&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;address of te: %p\n&quot;</span>, &amp;te)<br>fmt.Printf(<span class="hljs-string">&quot;address of te.empty: %p\n&quot;</span>, &amp;(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;address of te.a: %p\n&quot;</span>, &amp;(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;empty: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.empty), unsafe.Alignof(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.a), unsafe.Alignof(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.b), unsafe.Alignof(te.b))<br>printMemory(te)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">address of te: <span class="hljs-number">0x140000ba000</span><br>address of te.empty: <span class="hljs-number">0x140000ba000</span><br>address of te.a: <span class="hljs-number">0x140000ba000</span><br>empty: size=<span class="hljs-number">0</span>, align=<span class="hljs-number">1</span><br>a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>[<span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="空结构体在结构体中间">6.8.3 空结构体在结构体中间</h3><p>空结构体出现在结构体中时，地址跟随前一个变量。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310165025700.png"alt="空结构体在结构体中间内存对齐" /><figcaption aria-hidden="true">空结构体在结构体中间内存对齐</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestEmpty <span class="hljs-keyword">struct</span> &#123;<br>a     <span class="hljs-type">bool</span><br>empty <span class="hljs-keyword">struct</span>&#123;&#125;<br>b     <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>te := TestEmpty&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;address of te: %p\n&quot;</span>, &amp;te)<br>fmt.Printf(<span class="hljs-string">&quot;address of te.a: %p\n&quot;</span>, &amp;(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;address of te.empty: %p\n&quot;</span>, &amp;(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.a), unsafe.Alignof(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;empty: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.empty), unsafe.Alignof(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.b), unsafe.Alignof(te.b))<br>printMemory(te)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">address of te: <span class="hljs-number">0x14000128000</span><br>address of te.a: <span class="hljs-number">0x14000128000</span><br>address of te.empty: <span class="hljs-number">0x14000128001</span><br>a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>empty: size=<span class="hljs-number">0</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="空结构体在结构体最后">6.8.4 空结构体在结构体最后</h3><p>空结构体出现在结构体最后，如果开启了一个新的系统字长，则需要补零，防止与其他结构体混用地址。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310164933867.png"alt="空结构体在结构体最后内存对齐" /><figcaption aria-hidden="true">空结构体在结构体最后内存对齐</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestEmpty <span class="hljs-keyword">struct</span> &#123;<br>a     <span class="hljs-type">bool</span><br>b     <span class="hljs-type">string</span><br>empty <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>te := TestEmpty&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;address of te: %p\n&quot;</span>, &amp;te)<br>fmt.Printf(<span class="hljs-string">&quot;address of te.a: %p\n&quot;</span>, &amp;(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;address of te.empty: %p\n&quot;</span>, &amp;(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.a), unsafe.Alignof(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.b), unsafe.Alignof(te.b))<br>fmt.Printf(<span class="hljs-string">&quot;empty: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.empty), unsafe.Alignof(te.empty))<br>printMemory(te)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">address of te: <span class="hljs-number">0x1400006a020</span><br>address of te.a: <span class="hljs-number">0x1400006a020</span><br>address of te.empty: <span class="hljs-number">0x1400006a038</span><br>a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>empty: size=<span class="hljs-number">0</span>, align=<span class="hljs-number">1</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="使用-fieldalignment--fix-工具优化结构体内存对齐">6.9 使用fieldalignment -fix 工具优化结构体内存对齐</h2><p>还记得我们最开始提出的问题吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num2 <span class="hljs-type">int8</span><br>num1 <span class="hljs-type">int16</span><br>flag <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S2 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int8</span><br>flag <span class="hljs-type">bool</span><br>num2 <span class="hljs-type">int16</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(unsafe.Sizeof(S1&#123;&#125;))<br>fmt.Println(unsafe.Sizeof(S2&#123;&#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p><code>S1</code> 和 <code>S2</code> 提供的程序功能是一样的，但是<code>S1</code> 却比 <code>S2</code>花费了更多的内存空间。所以有时候我们可以通过仅仅调整结构体内部字段的顺序就减少不少的内存空间消耗。在这个时候<code>fieldalignment</code> 可以帮助我们自动检测并优化。</p><p>你可以运行下面命令安装 <code>fieldalignment</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest<br></code></pre></td></tr></table></figure><p>然后在项目根目录下运行下面命令，对我们的代码进行检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go vet -vettool=$(<span class="hljs-built_in">which</span> fieldalignment) ./...<br></code></pre></td></tr></table></figure><p>这里会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./main.go:9:9: struct of size 6 could be 4<br></code></pre></td></tr></table></figure><p>这个时候可以执行 <code>fieldalignment -fix 目录|文件</code>，它会自动帮我们的代码进行修复，但是<strong>强烈建议你在运行之前，备份你的代码，因为注释会被删除！</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fieldalignment -fix ./...<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">/Users/hedon/GolandProjects/learn-<span class="hljs-keyword">go</span>-<span class="hljs-keyword">struct</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>:<span class="hljs-number">9</span>: <span class="hljs-keyword">struct</span> of size <span class="hljs-number">6</span> could be <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>这个时候 <code>S1</code> 已经被优化好了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int16</span><br>num2 <span class="hljs-type">int8</span><br>flag <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文将带您全面深入地探索 Go 语言中结构体的各个方面，从基本定义、初始化和使用，到高级特性如结构体的组合、方法定义、内存对齐等。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨HTTPie</title>
    <link href="https://hedon.top/2024/03/06/rust-action-httpie/"/>
    <id>https://hedon.top/2024/03/06/rust-action-httpie/</id>
    <published>2024-03-06T14:22:02.000Z</published>
    <updated>2024-03-27T11:38:28.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>之前学习过《陈天·Rust 编程第一课 - 04｜get hands dirty：来写个实用的CLI 小工具》，学的时候迷迷糊糊。后来在系统学习完 Rust后，重新回过头来看这个实战小案例，基本上都能掌握，并且有了一些新的理解。所以我决定以一个Rust 初学者的角度，并以最新版本的 Rust（1.7.6）和clap（4.5.1）来重新实现这个案例，期望能对 Rust感兴趣的初学者提供一些帮助。</p><p>本文将实现的应用叫 HTTPie，HTTPie 是一个用 Python 编写的命令行 HTTP客户端，其目标是使 CLI 与 web 服务的交互尽可能愉快。它被设计为一个<code>curl</code> 和 <code>wget</code>的替代品，提供易于使用的界面和一些用户友好的功能，如 JSON支持、语法高亮和插件。它对于测试、调试和通常与 HTTP 服务器或 RESTful API进行交云的开发人员来说非常有用。</p><p>HTTPie 的一些关键特性包括：</p><ol type="1"><li><strong>JSON 支持</strong>：默认情况下，HTTPie 会自动发送JSON，并且可以轻松地通过命令行发送 JSON 请求体。</li><li><strong>语法高亮</strong>：它会为 HTTP响应输出提供语法高亮显示，使得结果更加易于阅读。</li><li><strong>插件</strong>：HTTPie 支持插件，允许扩展其核心功能。</li><li><strong>表单和文件上传</strong>：可以很容易地通过表单上传文件。</li><li><strong>自定义 HTTP 方法和头部</strong>：可以发送任何 HTTP方法的请求，自定义请求头部。</li><li><strong>HTTPS、代理和身份验证支持</strong>：支持 HTTPS请求、使用代理以及多种 HTTP 身份验证机制。</li><li><strong>流式上传和下载</strong>：支持大文件的流式上传和下载。</li><li><strong>会话支持</strong>：可以保存和重用常用的请求和集合。</li></ol><p>本文我们将实现其中的 <code>1</code>、<code>2</code> 和<code>5</code>。我们会支持发送 GET 和 POST 请求，其中 POST支持设置请求头和 JSON 数据。</p><p>在本文中，你可以学习到：</p><ul><li>如何用 <code>clap</code> 解析命令行参数。</li><li>如何用 <code>tokio</code> 进行异步编程。</li><li>如何用 <code>reqwest</code> 发送 HTTP 请求。</li><li>如何用 <code>colored</code> 在终端输出带颜色的内容。</li><li>如何用 <code>jsonxf</code> 美化 json 字符串。</li><li>如何用 <code>anyhow</code> 配合 <code>?</code> 进行错误传播。</li><li>如何使用 <code>HTTPie</code> 来进行 HTTP 接口测试。</li></ul><p>在进行实际开发之前，推荐你先了解一下：</p><ul><li><a href="https://hedon.top/2024/03/02/rust-crate-reqwest/">Rustreqwest 简明教程</a></li><li><a href="https://hedon.top/2024/03/05/rust-crate-anyhow/">Rustanyhow 简明教程</a></li><li><a href="https://hedon.top/2024/03/02/rust-crate-clap/">深入探索Rust 的 clap 库：命令行解析的艺术</a></li></ul><p>本文完整代码：<ahref="https://github.com/hedon954/httpie">hedon954/httpie</a></p><h1 id="开发思路">开发思路</h1><h2 id="http-协议">HTTP 协议</h2><p>回顾一下 HTTP 协议的请求体和响应体结构。</p><p>请求结构：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240303131157545.png"alt="http request structure" /><figcaption aria-hidden="true">http request structure</figcaption></figure><p>响应结构：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240303131123618.png"alt="http response structure" /><figcaption aria-hidden="true">http response structure</figcaption></figure><h2 id="命令分析">命令分析</h2><p>在本文中，我们就实现 HTTPie cli 官方的这个<ahref="https://github.com/httpie/cli?tab=readme-ov-file#examples">示例</a>：即允许指定请求方法、携带headers 和 json 数据发送请求。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240303131445159.png"alt="HTTPie 官方示例" /><figcaption aria-hidden="true">HTTPie 官方示例</figcaption></figure><p>我们来拆解一下，这个命令可以分为以下几个部分：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">httpie &lt;METHOD&gt; &lt;URL&gt; [headers | params]...<br></code></pre></td></tr></table></figure><ul><li><code>&lt;METHOD&gt;</code>: 请求方法，本案例中，我们仅支持 GET 和POST。</li><li><code>&lt;URL&gt;</code>: 请求地址。</li><li><code>&lt;HEADERS&gt;</code>: 请求头，格式为<code>h1:v1</code>。</li><li><code>&lt;PARAMS&gt;</code>: 请求参数，格式为<code>k1=v1</code>，最终以 json 结构发送。</li></ul><h2 id="效果展示">效果展示</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  httpie git:(master) ✗ ./Httpie --<span class="hljs-built_in">help</span>                                              <br>Usage: Httpie &lt;COMMAND&gt;<br><br>Commands:<br>  get   <br>  post  <br>  <span class="hljs-built_in">help</span>  Print this message or the <span class="hljs-built_in">help</span> of the given subcommand(s)<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br></code></pre></td></tr></table></figure><p>其中 post 子命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: Httpie post &lt;URL&gt; &lt;BODY&gt;...<br><br>Arguments:<br>  &lt;URL&gt;      Specify the url you wanna request to<br>  &lt;BODY&gt;...  Set the request body. Examples: headers: header1:value1 params: key1=value1<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>  Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>请求示例：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240305225846224.png"alt="httpie response demo" /><figcaption aria-hidden="true">httpie response demo</figcaption></figure><h2 id="思路梳理">思路梳理</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240306223319742.png"alt="httpie 开发思路梳理" /><figcaption aria-hidden="true">httpie 开发思路梳理</figcaption></figure><p><strong>第 1 步：解析命令行参数</strong></p><p>本案例中 httpie 支持 2 个子命令：</p><ul><li>get 支持 url 参数</li><li>post 支持 url、body 参数，因为其中 headers 和 params是变长的，我们统一用 <code>Vec&lt;String&gt;</code> 类型的 body来接收，然后用 <code>:</code> 和 <code>=</code> 来区分它们。</li></ul><p><strong>第 2 步：发送请求</strong></p><ol type="1"><li>使用 reqwest 创建 http client；</li><li>设置 url；</li><li>设置 method；</li><li>设置 headers；</li><li>设置 params；</li><li>发送请求；</li><li>获取响应体。</li></ol><p><strong>第 3 步：打印响应</strong></p><ol type="1"><li>打印 http version 和 status，并使用 colored 赋予蓝色；</li><li>打印 response headers，并使用 colored 赋予绿色；</li><li>确定 content-type，如果是 json，我们就用 jsonxf 美化 json 串并使用colored 赋予蓝绿色输出，如果是其他类型，这里我们就输出原文即可。</li></ol><h1 id="实战过程">实战过程</h1><h2 id="创建项目">1. 创建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new httpie<br></code></pre></td></tr></table></figure><h2 id="添加依赖">2. 添加依赖</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;httpie&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">anyhow</span> = <span class="hljs-string">&quot;1.0.80&quot;</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.1&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;<br><span class="hljs-attr">colored</span> = <span class="hljs-string">&quot;2.1.0&quot;</span><br><span class="hljs-attr">jsonxf</span> = <span class="hljs-string">&quot;1.1.1&quot;</span><br><span class="hljs-attr">mime</span> = <span class="hljs-string">&quot;0.3.17&quot;</span><br><span class="hljs-attr">reqwest</span> = &#123; version = <span class="hljs-string">&quot;0.11.24&quot;</span>, features = [<span class="hljs-string">&quot;json&quot;</span>] &#125;<br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1.36.0&quot;</span>, features = [<span class="hljs-string">&quot;rt&quot;</span>, <span class="hljs-string">&quot;rt-multi-thread&quot;</span>, <span class="hljs-string">&quot;macros&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><ul><li><code>anyhow</code>: 用于简化异常处理。</li><li><code>clap</code>: 解析命令行参数。</li><li><code>colored</code>: 为终端输出内容赋予颜色。</li><li><code>jsonxf</code>: 美化 json 串。</li><li><code>mime</code>: 提供了各种 Media Type 的类型封装。</li><li><code>reqwest</code>: http 客户端。</li><li><code>tokio</code>: 异步库，本案例种我们使用 reqwest的异步功能。</li></ul><h2 id="完整源码">3. 完整源码</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// src/main.rs  为减小篇幅，省略了单元测试，读者可自行补充。</span><br><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">use</span> reqwest::&#123;Client, header, Response&#125;;<br><span class="hljs-keyword">use</span> std::<span class="hljs-type">str</span>::FromStr;<br><span class="hljs-keyword">use</span> anyhow::anyhow;<br><span class="hljs-keyword">use</span> clap::&#123;Args, Parser, Subcommand&#125;;<br><span class="hljs-keyword">use</span> colored::Colorize;<br><span class="hljs-keyword">use</span> mime::Mime;<br><span class="hljs-keyword">use</span> reqwest::header::&#123;HeaderMap, HeaderName, HeaderValue&#125;;<br><span class="hljs-keyword">use</span> reqwest::Url;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Httpie</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    methods: Method,<br>&#125;<br><br><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-title function_ invoke__">Get</span>(Get),<br>    <span class="hljs-title function_ invoke__">Post</span>(Post)<br>&#125;<br><br><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Get</span> &#123;<br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-comment">/// Specify the url you wanna request to.</span><br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-comment">/// Set the request body.</span><br>    <span class="hljs-comment">/// Examples:</span><br>    <span class="hljs-comment">///     headers:</span><br>    <span class="hljs-comment">///         header1:value1</span><br>    <span class="hljs-comment">///     params:</span><br>    <span class="hljs-comment">///         key1=value1</span><br>    <span class="hljs-meta">#[arg(required = true, value_parser = parse_kv_pairs)]</span><br>    body: <span class="hljs-type">Vec</span>&lt;KvPair&gt;<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    k: <span class="hljs-type">String</span>,<br>    v: <span class="hljs-type">String</span>,<br>    t: KvPairType,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug,Clone)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">KvPairType</span> &#123;<br>    Header,<br>    Param,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">FromStr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Err</span> = anyhow::Error;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_str</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::<span class="hljs-literal">Err</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pair_type</span>: KvPairType;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">split_char</span> = <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">contains</span>(<span class="hljs-string">&#x27;:&#x27;</span>) &#123;<br>            pair_type = KvPairType::Header;<br>            <span class="hljs-string">&#x27;:&#x27;</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pair_type = KvPairType::Param;<br>            <span class="hljs-string">&#x27;=&#x27;</span><br>        &#125;;<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">split</span> = s.<span class="hljs-title function_ invoke__">split</span>(split_char);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">err</span> = || anyhow!(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;failed to parse pairs &#123;&#125;&quot;</span>,s));<br>        <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-keyword">Self</span> &#123;<br>            k: (split.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">ok_or_else</span>(err)?).<span class="hljs-title function_ invoke__">to_string</span>(),<br>            v: (split.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">ok_or_else</span>(err)?).<span class="hljs-title function_ invoke__">to_string</span>(),<br>            t: pair_type,<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_url</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_url</span>: Url = s.<span class="hljs-title function_ invoke__">parse</span>()?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">into</span>())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_kv_pairs</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;KvPair&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">parse</span>()?)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(client: Client, args: &amp;Get) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">resp</span> = client.<span class="hljs-title function_ invoke__">get</span>(&amp;args.url).<span class="hljs-title function_ invoke__">send</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">print_resp</span>(resp).<span class="hljs-keyword">await</span>?)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">post</span>(client: Client, args: &amp;Post) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">body</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">header_map</span> = HeaderMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">pair</span> <span class="hljs-keyword">in</span> args.body.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">match</span> pair.t &#123;<br>            KvPairType::Param =&gt;  &#123;body.<span class="hljs-title function_ invoke__">insert</span>(&amp;pair.k, &amp;pair.v);&#125;<br>            KvPairType::Header =&gt; &#123;<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(name) = HeaderName::<span class="hljs-title function_ invoke__">from_str</span>(pair.k.<span class="hljs-title function_ invoke__">as_str</span>()) &#123;<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(value) = HeaderValue::<span class="hljs-title function_ invoke__">from_str</span>(pair.v.<span class="hljs-title function_ invoke__">as_str</span>()) &#123;<br>                        header_map.<span class="hljs-title function_ invoke__">insert</span>(name,value);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Invalid header value for key: &#123;&#125;&quot;</span>, pair.v);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Invalid header key: &#123;&#125;&quot;</span>, pair.k);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">resp</span> = client.<span class="hljs-title function_ invoke__">post</span>(&amp;args.url)<br>        .<span class="hljs-title function_ invoke__">headers</span>(header_map)<br>        .<span class="hljs-title function_ invoke__">json</span>(&amp;body).<span class="hljs-title function_ invoke__">send</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">print_resp</span>(resp).<span class="hljs-keyword">await</span>?)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_resp</span>(resp: Response) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-title function_ invoke__">print_status</span>(&amp;resp);<br>    <span class="hljs-title function_ invoke__">print_headers</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mime</span> = <span class="hljs-title function_ invoke__">get_content_type</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = resp.<span class="hljs-title function_ invoke__">text</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">print_body</span>(mime, &amp;body);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_status</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">status</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;:?&#125; &#123;&#125;&quot;</span>, resp.<span class="hljs-title function_ invoke__">version</span>(), resp.<span class="hljs-title function_ invoke__">status</span>()).<span class="hljs-title function_ invoke__">blue</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>, status);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_headers</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">for</span> (k,v) <span class="hljs-keyword">in</span> resp.<span class="hljs-title function_ invoke__">headers</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, k.<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">green</span>(), v);<br>    &#125;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_body</span>(mime: <span class="hljs-type">Option</span>&lt;Mime&gt;, resp: &amp;<span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-keyword">match</span> mime &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(v) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> v == mime::APPLICATION_JSON &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, jsonxf::<span class="hljs-title function_ invoke__">pretty_print</span>(resp).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">cyan</span>())<br>            &#125;<br>        &#125;<br>        _ =&gt; <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, resp),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_content_type</span>(resp: &amp;Response) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Mime&gt; &#123;<br>    resp.<span class="hljs-title function_ invoke__">headers</span>()<br>        .<span class="hljs-title function_ invoke__">get</span>(header::CONTENT_TYPE)<br>        .<span class="hljs-title function_ invoke__">map</span>(|v|v.<span class="hljs-title function_ invoke__">to_str</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>())<br>&#125;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt;&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">httpie</span> = Httpie::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">match</span> httpie.methods &#123;<br>        Method::<span class="hljs-title function_ invoke__">Get</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">get</span>(client, args).<span class="hljs-keyword">await</span>?,<br>        Method::<span class="hljs-title function_ invoke__">Post</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">post</span>(client, args).<span class="hljs-keyword">await</span>?,<br>    &#125;;<br>    <span class="hljs-title function_ invoke__">Ok</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，即使算上 <code>use</code> 部分，总代码也不过160行左右，Rust 的 <code>clap</code> 库在 CLI 开发上确实 yyds！</p><p>接下来我们来一一拆解这部分的代码，其中关于 <code>clap</code>的部分我不会过多展开，刚兴趣的读者可以参阅：<ahref="https://hedon.top/2024/03/02/rust-crate-clap/">深入探索 Rust 的clap 库：命令行解析的艺术</a>。</p><h3 id="命令行解析">3.1 命令行解析</h3><p>我们先从 <code>main()</code> 开始：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt;&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">httpie</span> = Httpie::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">match</span> httpie.methods &#123;<br>        Method::<span class="hljs-title function_ invoke__">Get</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">get</span>(client, args).<span class="hljs-keyword">await</span>?,<br>        Method::<span class="hljs-title function_ invoke__">Post</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">post</span>(client, args).<span class="hljs-keyword">await</span>?,<br>    &#125;;<br>    <span class="hljs-title function_ invoke__">Ok</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望使用 <code>clap</code> 的异步功能，所以使用了<code>async</code> 关键字，同时加上了 <code>tokio</code> 提供的属性宏<code>#[tokio::main]</code>，用于设置异步环境。为了能够使用<code>?</code> 快速传播错误，我们设置返回值为<code>anyhow::Result&lt;()&gt;</code>，本项目中我们不对错误进行过多处理，所以这种方式可以大大简化我们的错误处理过程。</p><p><code>main()</code> 中我们使用 <code>Httpie::parse()</code>解析命令行中的参数，使用 <code>Client::new()</code> 创建一个 httpclient，根据解析到的命令行参数，我们匹配子命令<code>methods</code>，分别调用 <code>get()</code> 和 <code>post()</code>来发送 GET 和 POST 请求。</p><p><code>Httpie</code> 的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Httpie</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    methods: Method,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Parser)]</code> 是一个过程宏（proceduralmacro），用于自动为结构体实现 <code>clap::Parser</code>trait。这使得该结构体可以用来解析命令行参数。</p><p>在 <code>Httpie</code> 中我们定义了子命令 <code>Method</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-title function_ invoke__">Get</span>(Get),<br>    <span class="hljs-title function_ invoke__">Post</span>(Post)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Subcommand)]</code>属性宏会自动为枚举派生一些代码，以便它可以作为子命令来解析命令行参数。目前支持<code>Get</code> 和 <code>Post</code> 两个子命令，它们分别接收<code>Get</code> 和 <code>Post</code> 参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Get</span> &#123;<br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br>  <br>    <span class="hljs-meta">#[arg(value_parser = parse_kv_pairs)]</span><br>    body: <span class="hljs-type">Vec</span>&lt;KvPair&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Args)]</code> 属性宏表明当前 struct 是命令的参数，其中<code>Get</code> 仅支持 <code>url</code> 参数，<code>Post</code> 支持<code>url</code> 和 <code>body</code> 参数。</p><p><code>url</code> 参数我们使用 <code>parse_url</code>函数来进行解析：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest::Url;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_url</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_url</span>: Url = s.<span class="hljs-title function_ invoke__">parse</span>()?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">into</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>reqwest::Url</code> 已经实现了 <code>FromStr</code>trait，所以这里我们可以直接调用 <code>s.parse()</code> 来解析<code>url</code>。</p><p>而 <code>body</code>，因为我们期望 CLI 使用起来像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">httpie url header1:value1 param1=v1<br></code></pre></td></tr></table></figure><p><code>body</code> 就是 <code>header1:value1 param1=v1</code>，一对 kv就代表着一个 header 或者 param，用 <code>:</code> 和 <code>=</code>来区分。因为 kv 对的个数的变长的，所以我们使用<code>Vec&lt;KvPair&gt;</code> 来接收 <code>body</code> 这个参数，并使用<code>parse_kv_pairs</code> 来解析 kv 对。</p><p><code>KvPair</code> 是我们自定义的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    k: <span class="hljs-type">String</span>,<br>    v: <span class="hljs-type">String</span>,<br>    t: KvPairType,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug,Clone)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">KvPairType</span> &#123;<br>    Header,<br>    Param,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>parse_kv_pairs</code> 的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_kv_pairs</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;KvPair&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">parse</span>()?)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，你可以在 <code>parse_kv_pairs()</code> 函数中，对<code>s</code> 进行解析并返回<code>anyhow::Result&lt;KvPair&gt;</code>。不过，更优雅，更统一的方式是什么呢？就是像<code>reqwest::Url</code> 一样，为 <code>KvPair</code> 实现<code>FromStr</code> trait，这样就可以直接调用 <code>s.parse()</code>来进行解析了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">FromStr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Err</span> = anyhow::Error;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_str</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::<span class="hljs-literal">Err</span>&gt; &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发送请求">3.2 发送请求</h3><p>参数解析完，就到了发送请求的地方了，这里使用 <code>reqwest</code>crate 就非常方便了，这里就不赘述了，具体可以参考：<ahref="https://hedon.top/2024/03/02/rust-crate-reqwest/">Rust reqwest简明教程</a>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(client: Client, args: &amp;Get) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123; ... &#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">post</span>(client: Client, args: &amp;Post) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="打印响应">3.3 打印响应</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240305225846224.png"alt="httpie response demo" /><figcaption aria-hidden="true">httpie response demo</figcaption></figure><p>响应分为 3 个部分：</p><ul><li>print_status()</li><li>print_headers()</li><li>print_body()</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_resp</span>(resp: Response) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-title function_ invoke__">print_status</span>(&amp;resp);<br>    <span class="hljs-title function_ invoke__">print_headers</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mime</span> = <span class="hljs-title function_ invoke__">get_content_type</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = resp.<span class="hljs-title function_ invoke__">text</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">print_body</span>(mime, &amp;body);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p><code>print_status()</code> 比较简单，就是打印 HTTP版本和响应状态码，然后我们使用 <code>colored</code> crate 的<code>blue()</code> 使其在终端以<font color="blue">蓝色</font>输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_status</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">status</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;:?&#125; &#123;&#125;&quot;</span>, resp.<span class="hljs-title function_ invoke__">version</span>(), resp.<span class="hljs-title function_ invoke__">status</span>()).<span class="hljs-title function_ invoke__">blue</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>, status);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>print_headers()</code> 中，我们使用 <code>green()</code> 使header_name 在终端以<font color="green">绿色</font>输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_headers</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">for</span> (k,v) <span class="hljs-keyword">in</span> resp.<span class="hljs-title function_ invoke__">headers</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, k.<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">green</span>(), v);<br>    &#125;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>响应体的格式（Media Type）有很多，本案例中我们仅支持<code>application/json</code>，所以在 <code>print_body()</code>之前，我们需要先读取 response header 中的 content-type：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_content_type</span>(resp: &amp;Response) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Mime&gt; &#123;<br>    resp.<span class="hljs-title function_ invoke__">headers</span>()<br>        .<span class="hljs-title function_ invoke__">get</span>(header::CONTENT_TYPE)<br>        .<span class="hljs-title function_ invoke__">map</span>(|v|v.<span class="hljs-title function_ invoke__">to_str</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>print_resp()</code> 中，对于<code>application/json</code>，我们使用 <code>jsonxf</code> crate对进行美化，并使用 <code>cyan()</code>使其在终端以<font color="cyan">蓝绿色</font>输出。对于其他类型，我们姑且照原文输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_body</span>(mime: <span class="hljs-type">Option</span>&lt;Mime&gt;, resp: &amp;<span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-keyword">match</span> mime &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(v) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> v == mime::APPLICATION_JSON &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, jsonxf::<span class="hljs-title function_ invoke__">pretty_print</span>(resp).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">cyan</span>())<br>            &#125;<br>        &#125;<br>        _ =&gt; <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, resp),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>在本文中，我们深入探讨了如何使用 Rust 语言来实现一个类似于 HTTPie的命令行工具。这个过程包括了对 HTTP 协议的理解、命令行参数的解析、HTTP客户端的创建和请求发送，以及对响应的处理和展示。通过本文，读者不仅能够获得一个实用的命令行工具，还能够学习到如何使用Rust 的库来构建实际的应用程序，包括<code>clap</code>、<code>reqwest</code>、<code>tokio</code> 和<code>colored</code> 等。此外，文章也说明了在 Rust中进行异步编程和错误处理的一些常见模式。尽管示例代码的错误处理较为简单，但它提供了一个良好的起点，开发者可以在此基础上进行扩展和改进，以适应更复杂的应用场景。</p>]]></content>
    
    
    <summary type="html">我们深入探讨了如何使用 Rust 语言来实现一个类似于 HTTPie 的命令行工具。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
</feed>
