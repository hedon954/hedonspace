<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HedonSpace</title>
  
  <subtitle>君子求诸己，律己则安。</subtitle>
  <link href="https://hedon.top/atom.xml" rel="self"/>
  
  <link href="https://hedon.top/"/>
  <updated>2025-03-04T04:22:36.787Z</updated>
  <id>https://hedon.top/</id>
  
  <author>
    <name>Hedon Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>直播系统推拉流原理</title>
    <link href="https://hedon.top/2025/03/04/live-stream-push-pull/"/>
    <id>https://hedon.top/2025/03/04/live-stream-push-pull/</id>
    <published>2025-03-04T03:34:09.000Z</published>
    <updated>2025-03-04T04:22:36.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直播系统推拉流原理概述">直播系统推拉流原理概述</h1><p>直播系统的核心功能是实现主播端视频采集后的实时传输，以及观众端的实时观看。整个过程主要包含：推流、服务器处理、拉流三个环节。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250304121833913.png"alt="直播系统架构" /><figcaption aria-hidden="true">直播系统架构</figcaption></figure><h2 id="核心概念解析">核心概念解析</h2><h3 id="推流push">1. 推流（Push）</h3><p>推流是指主播端将视频数据传输到服务器的过程。主要使用<code>RTMP</code> 协议（Real Time Messaging Protocol）。</p><p>比如可能有如下推流 URL 的生成逻辑： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generatePushUrl</span><span class="params">(String pushDomain, String pushKey, String appName, String streamName, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pushUrl</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 推流域名未开启鉴权功能的情况下</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(pushKey)) &#123;</span><br><span class="line">        pushUrl = <span class="string">&quot;rtmp://&quot;</span> + pushDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000L</span> + expireTime;</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringToMd5</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;-&quot;</span> + Long.toString(timeStamp) + <span class="string">&quot;-0-0-&quot;</span> + pushKey;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authKey</span> <span class="operator">=</span> md5(stringToMd5);</span><br><span class="line">        pushUrl = <span class="string">&quot;rtmp://&quot;</span> + pushDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;?auth_key=&quot;</span> + Long.toString(timeStamp) + <span class="string">&quot;-0-0-&quot;</span> + authKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pushUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>推流地址的组成部分： - rtmp:// - 协议 - pushDomain - 推流域名 -appName - 应用名称 - streamName - 流名称 - auth_key -鉴权参数（可选）</p><h3 id="拉流pull">2. 拉流（Pull）</h3><p>拉流是观众观看直播的过程。支持多种协议： - RTMP：延迟低（1-3秒） -HTTP-FLV：延迟适中（2-5秒） - HLS(m3u8)：延迟较高（5-30秒）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FLV 格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generalPullUrlFlv</span><span class="params">(String pullDomain, String pullKey, String appName, String streamName, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(pullKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://&quot;</span> + pullDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;.flv&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 鉴权逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HLS 格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generalPullUrlHls</span><span class="params">(String pullDomain, String pullKey, String appName, String streamName, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(pullKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://&quot;</span> + pullDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;.m3u8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 鉴权逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直播流程">直播流程</h2><ol type="1"><li><strong>主播开播</strong>：<ul><li>系统生成唯一的 streamId</li><li>生成带鉴权的推流地址</li><li>主播端推流软件（如 OBS）开始推流</li></ul></li><li><strong>服务器处理</strong>：<ul><li>流媒体服务器接收推流</li><li>进行转码、录制等处理</li><li>将流分发到 CDN 节点</li></ul></li><li><strong>观众观看</strong>：<ul><li>获取对应格式的拉流地址</li><li>通过播放器拉取直播流</li><li>实现实时观看</li></ul></li></ol><h2 id="实现建议">实现建议</h2><ol type="1"><li><strong>选择合适的流媒体服务器</strong>：<ul><li>商业云服务：阿里云直播、腾讯云直播</li><li>开源方案：SRS、Nginx-RTMP</li></ul></li><li><strong>根据业务场景选择协议</strong>：<ul><li>普通直播：HTTP-FLV</li><li>低延迟场景：RTMP</li><li>移动端兼容性要求高：HLS</li></ul></li><li><strong>关注关键指标</strong>：<ul><li>延迟控制</li><li>卡顿率</li><li>首屏时间</li><li>带宽成本</li></ul></li><li><strong>安全鉴权：</strong><ul><li>防盗链机制</li></ul></li></ol>]]></content>
    
    
    <summary type="html">本文介绍了直播系统推拉流的基本原理，包括推流和拉流的过程、协议选择、关键指标等。</summary>
    
    
    
    <category term="解决方案" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="直播系统" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="直播系统" scheme="https://hedon.top/tags/%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>网络数据包的完整旅程：从发送到接收的全过程</title>
    <link href="https://hedon.top/2025/03/01/net-data-journey/"/>
    <id>https://hedon.top/2025/03/01/net-data-journey/</id>
    <published>2025-03-01T04:58:37.000Z</published>
    <updated>2025-03-03T13:59:29.408Z</updated>
    
    <content type="html"><![CDATA[<p>不知道你是否曾经好奇你发出的一个网络请求，最终是怎么到达对端，并将你想要的信息返回给你的。本文将通过一个HTTP请求与响应，从一个比较宏观的角度来梳理下一个数据包在网络中的旅途，旨在帮助笔者和各位读者建立起对计算机网络模型一个比较全面的认知。</p><blockquote><p>本文参考极客时间《网络架构实战课（谢友鹏）》，再根据笔者的知识面、按照个人理解，补充更多丰富具体的内容。</p></blockquote><h1 id="实战">实战</h1><p>好，那我们直接开始，我们先使用 <code>curl</code> 来发起一个 HTTP请求，看看这过程中发生了什么：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /dev/null -v https://example.com</span><br></pre></td></tr></table></figure><p>在笔者的 mac 机器上，这行命令的输出如下：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301131247066.png" data-fancybox="true" alt="curl https//example.com 结果分析" style="width: 100%; height: auto;"></p><p>当我们发起请求时，首先会对 <code>example.com</code>进行域名解析，分别尝试解析到它的 <code>IPv6</code> 和<code>IPv4</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* IPv6: (none)</span><br><span class="line">* IPv4: 23.215.0.138, 96.7.128.198, 23.192.228.80, 23.192.228.84, 23.215.0.136, 96.7.128.175</span><br></pre></td></tr></table></figure><p>因为我们使用的是 <code>https</code> 协议，所以会尝试跟这些地址的<code>443</code> 端口建立 <code>TCP</code> 连接，（如果是<code>https</code> 则跟 <code>80</code> 端口），并进行<code>TLS 握手验证</code>，如果成功了，则会建立 <code>TCP</code>连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Trying <span class="number">23.215</span><span class="number">.0</span><span class="number">.138</span>:<span class="number">443.</span>..</span><br><span class="line">...[TLS handshake]</span><br><span class="line">* Connected to example.com (<span class="number">23.215</span><span class="number">.0</span><span class="number">.138</span>) port <span class="number">443</span></span><br></pre></td></tr></table></figure><p>建立连接后，就开始发送 <code>HTTP</code> 请求，这里使用的是 HTTP2协议。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* using HTTP/2</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0* [HTTP/2] [1] OPENED stream <span class="keyword">for</span> https://example.com/</span><br><span class="line">* [HTTP/2] [1] [:method: GET]</span><br><span class="line">* [HTTP/2] [1] [:scheme: https]</span><br><span class="line">* [HTTP/2] [1] [:authority: example.com]</span><br><span class="line">* [HTTP/2] [1] [:path: /]</span><br><span class="line">* [HTTP/2] [1] [user-agent: curl/8.10.1]</span><br><span class="line">* [HTTP/2] [1] [accept: */*]</span><br><span class="line">&#125; [5 bytes data]</span><br><span class="line">&gt; GET / HTTP/2</span><br><span class="line">&gt; Host: example.com</span><br><span class="line">&gt; User-Agent: curl/8.10.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">* Request completely sent off</span><br></pre></td></tr></table></figure><p>最后，服务器返回了 HTTP 200 OK 的响应。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123; [5 bytes data]</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):</span><br><span class="line">&#123; [265 bytes data]</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):</span><br><span class="line">&#123; [265 bytes data]</span><br><span class="line">&lt; HTTP/2 200</span><br><span class="line">&lt; content-type: text/html</span><br><span class="line">&lt; etag: <span class="string">&quot;84238dfc8092e5d9c0dac8ef93371a07:1736799080.121134&quot;</span></span><br><span class="line">&lt; last-modified: Mon, 13 Jan 2025 20:11:20 GMT</span><br><span class="line">&lt; cache-control: max-age=1374</span><br><span class="line">&lt; <span class="built_in">date</span>: Sat, 01 Mar 2025 05:01:03 GMT</span><br><span class="line">&lt; alt-svc: h3=<span class="string">&quot;:443&quot;</span>; ma=93600,h3-29=<span class="string">&quot;:443&quot;</span>; ma=93600,quic=<span class="string">&quot;:443&quot;</span>; ma=93600; v=<span class="string">&quot;43&quot;</span></span><br><span class="line">&lt; content-length: 1256</span><br><span class="line">&lt;</span><br><span class="line">&#125; [5 bytes data]</span><br><span class="line">100  1256  100  1256    0     0   1172      0  0:00:01  0:00:01 --:--:--  1172</span><br><span class="line">* Connection <span class="comment">#0 to host example.com left intact</span></span><br></pre></td></tr></table></figure><p>要进一步了解网络数据包的细节，我们可以通过抓包工具进行分析。你可以使用<code>tcpdump</code> 抓取与 example.com 的通信数据包。</p><p>运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump host example.com -w example.com.pcap</span><br></pre></td></tr></table></figure><p>然后再另外一个命令行窗口再次发送请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /dev/null -v https://example.com</span><br></pre></td></tr></table></figure><p>回到 <code>tcpdump</code> 的窗口并结束监听，我们就会得到<code>example.com.pcap</code> 的抓包文件，可以通过<code>Wireshark</code> 软件打开该文件：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301133015523.png"alt="tcpdump 分析结果" /><figcaption aria-hidden="true">tcpdump 分析结果</figcaption></figure><h1 id="网络分层">网络分层</h1><p>通过上述实验，我们可以清晰看到网络是分层的，主流的分层模型有 OSI七层模型和 TCP/IP 四层模型，它们的对应关系及常见的协议如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/OSI-vs-TCP.png"alt="OSI-vs-TCP/IP" /><figcaption aria-hidden="true">OSI-vs-TCP/IP</figcaption></figure><p>我们在 Wireshark上方随便选择一个数据包，使用鼠标点击下方左侧的每一层，可以在右侧看到对应的层级数据。从链路层到应用层，每一层的数据都是对下一层的进一步封装。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301134103404.png"alt="数据包封装" /><figcaption aria-hidden="true">数据包封装</figcaption></figure><p>在发送方，用户程序需要传输的数据会经过逐层封装。首先添加应用层的 HTTPHeader，然后是传输层的 TCP Header，接着是网络层的 IPHeader，最后在链路层添加以太网帧的帧头和帧尾，包括源 MAC 地址、目的 MAC地址等链路层信息，最终形成网络中传输的完整数据包。</p><p>在接收方，数据包会按相反的顺序逐层解封装。接收设备从链路层开始解析数据，依次解读网络层、传输层和应用层的信息，最后将数据传递给接收方的应用程序。</p><p>如下图所示：</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/cn1.png"alt="数据包封装 &amp; 解析" /><figcaption aria-hidden="true">数据包封装 &amp; 解析</figcaption></figure><p>我们在 Wireshark中点开下面的每一层，可以看到如下信息，我在图标注了最重要的几个信息：<imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301135433547.png"alt="网络数据包关键信息" /></p><h1 id="网络之旅">网络之旅</h1><p>经过上述实验，我们可以做个小总结：</p><p>通过上述实验，我们可以清晰理解数据包的传输过程：</p><ul><li>HTTP请求是网络通信的应用层内容，它需要通过各层网络协议的封装才能实现端到端传输。</li><li>从发送方角度，数据传输遵循一个明确的逻辑顺序：首先将域名（example.com）解析为IP 地址，然后基于该 IP 地址和目标端口（443）建立 TCP 连接，接着找到目标IP 的 MAC 地址，最终由网卡将完整封装的数据包发送到网络中。</li><li>从接收方角度，服务器处理数据包的过程是一个自下而上的解封装过程：数据链路层接收到的帧包含源MAC 地址，网络层解析出 IPv4 地址和协议类型，传输层识别出 TCP协议和源端口号，最终在应用层获取并处理 HTTP请求数据。服务器根据这些信息构建响应，并按相反顺序封装返回给客户端。</li></ul><p>这种分层处理机制确保了网络通信的灵活性和可靠性，每层只需关注自己的职责，共同完成端到端的数据传输任务。</p><p>好，那么这里就有 2 个最关键的问题：</p><ol type="1"><li>如何通过域名获得 IP 地址？</li><li>如何通过 IP 地址获取 MAC 地址？</li></ol><h2 id="dns-解析">DNS 解析</h2><p>DNS（Domain NameSystem，域名系统）是互联网的一项核心服务，它允许我们使用易记的域名（如<code>example.com</code>）而不是数字 IP 地址（如<code>93.184.216.34</code>）来访问网站。</p><p>当你在浏览器中输入一个域名时，DNS 解析按以下步骤进行：</p><ol type="1"><li><p><strong>浏览器缓存检查</strong>：浏览器首先检查自己的缓存，看是否已经存储了该域名对应的IP 地址。</p></li><li><p><strong>操作系统缓存检查</strong>：如果浏览器缓存中没有，系统会检查操作系统的DNS 缓存（如 Windows 的 DNS Client 服务）。</p></li><li><p><strong>路由器缓存检查</strong>：若系统缓存中也没有，请求会被发送到你的路由器，它也维护着一个DNS 缓存。</p></li><li><p><strong>ISP DNS服务器查询</strong>：如果以上缓存都未命中，请求会被发送到你的ISP（互联网服务提供商）的 DNS 服务器。</p></li><li><p><strong>递归查询</strong>：ISP 的 DNS 服务器会执行递归查询：</p><ul><li>首先查询根域名服务器（Root DNS Server）</li><li>根服务器会引导到顶级域名服务器（TLD DNS Server，如 .com, .net, .org等）</li><li>顶级域名服务器会引导到权威域名服务器（Authoritative DNSServer）</li><li>权威服务器会返回该域名的 IP 地址</li></ul></li><li><p><strong>结果返回与缓存</strong>：一旦获取到 IP地址，它会被沿着查询路径返回，并在各个层级上缓存一段时间（由 TTL值决定）。</p></li></ol><p>你可以使用以下工具查询 DNS 信息：</p><ul><li><strong>nslookup</strong>：<code>nslookup example.com</code></li><li><strong>dig</strong>：<code>dig example.com</code></li><li><strong>host</strong>：<code>host example.com</code></li></ul><p>这些工具可以帮助你了解域名的解析过程和结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ host example.com</span><br><span class="line">example.com has address 23.215.0.138</span><br><span class="line">example.com has address 23.192.228.84</span><br><span class="line">example.com has address 23.215.0.136</span><br><span class="line">example.com has address 23.192.228.80</span><br><span class="line">example.com has address 96.7.128.175</span><br><span class="line">example.com has address 96.7.128.198</span><br><span class="line">example.com has IPv6 address 2600:1408:ec00:36::1736:7f31</span><br><span class="line">example.com has IPv6 address 2600:1406:3a00:21::173e:2e65</span><br><span class="line">example.com has IPv6 address 2600:1406:3a00:21::173e:2e66</span><br><span class="line">example.com has IPv6 address 2600:1406:bc00:53::b81e:94c8</span><br><span class="line">example.com has IPv6 address 2600:1406:bc00:53::b81e:94ce</span><br><span class="line">example.com has IPv6 address 2600:1408:ec00:36::1736:7f24</span><br><span class="line">example.com mail is handled by 0 .</span><br></pre></td></tr></table></figure><p>通过 DNS 解析将域名转换为 IP地址后，网络通信的下一步就是确定如何将数据包发送到目标 IP地址，这就需要用到 ARP 协议来获取目标设备的 MAC 地址。</p><h2 id="穿越客户端局域网">穿越客户端局域网</h2><p><strong>当我们发送一个网络请求时，数据包如何找到离开家庭/办公网络的"出口"？</strong></p><p>数据包首先需要解决的是"该往哪走"的问题：</p><ol type="1"><li><p><strong>问题：我需要直接联系目标设备还是找个"中介"？</strong></p><p>解决方案：子网判断</p><ul><li>设备会比较目标 IP 与自己的 IP 和子网掩码</li><li>就像判断收件人是不是住在同一个小区</li></ul></li><li><p><strong>问题：如何找到同一网络中的设备？</strong></p><p>解决方案：ARP 协议</p><ul><li>类似于小区广播："谁是 202 号房的？请告诉我你的门牌号！"</li><li>目标设备回应自己的 MAC 地址（设备的"身份证号"）</li></ul></li><li><p><strong>问题：目标在远方，如何离开本地网络？</strong></p><p>解决方案：默认网关</p><ul><li>就像不认识远方收件人的地址，先交给小区门卫（路由器）</li><li>数据包头上标注最终目的地 IP，但先送到网关的 MAC 地址</li></ul></li><li><p><strong>问题：数据如何在本地网络中转发？</strong></p><p>解决方案：交换机的 MAC 地址表</p><ul><li>交换机就像小区内的快递员，记住了每家每户的门牌号</li><li>它查表后将包裹精确送到对应的门口，不会打扰其他住户</li></ul></li></ol><p>简单来说，数据包在本地网络中的旅程就像是快递先确认收件人是否在同一小区，如果是，直接送达；如果不是，则交给小区出口的保安，由他负责进一步转发。</p><h2 id="穿越公网">穿越公网</h2><p><strong>数据包离开了本地网络，如何在茫茫互联网中找到遥远的目标服务器？</strong></p><p>数据包在互联网上的旅程就像一次跨国旅行：</p><ol type="1"><li><p><strong>问题：如何从私人区域进入公共世界？</strong></p><p>解决方案：NAT（网络地址转换）</p><ul><li><p>就像多人共用一个护照出国，本地设备共享一个公网 IP</p></li><li><p>路由器会记住谁发了什么请求，回程时能送回正确的设备</p></li></ul></li><li><p><strong>问题：互联网如此庞大复杂，谁来管理这些网络？</strong></p><p>解决方案：自治系统（Autonomous System, AS）</p><ul><li><p>AS 就像互联网世界的"国家"或"独立王国"</p></li><li><p>每个 AS 由单一技术管理机构控制（如ISP、大企业或教育机构）</p></li><li><p>你的数据包首先进入你的 ISP 所在的 AS，然后可能穿越多个AS</p></li><li><p>每个 AS 有唯一的 AS 号（ASN），如 AS7018(AT&amp;T) 或AS8075(Microsoft)</p></li></ul></li><li><p><strong>问题：这些"网络王国"如何相互通信和合作？</strong></p><p>解决方案：BGP 协议(边界网关协议)</p><ul><li><p>BGP 是 AS 之间的"外交语言"，用于宣告路由信息</p></li><li><p>它告诉其他 AS："通过我可以到达这些网络"</p></li><li><p>路由器根据 BGP 信息，决定数据包应该经过哪些 AS</p></li></ul></li><li><p><strong>问题：如何决定数据包在 AS 内部该走哪条路？</strong></p><p>解决方案：内部路由协议</p><ul><li><p>AS 内部使用 OSPF 或 IS-IS 等协议来找到最佳路径</p></li><li><p>路由器像城市中的交通指挥，根据"路况"决定下一个方向</p></li></ul></li><li><p><strong>问题：不同运营商之间如何连接？</strong></p><p>解决方案：互联网交换中心（IXP）</p><ul><li><p>就像不同航空公司在大型枢纽机场交换乘客</p></li><li><p>数据包在 IXP 从一个 AS “转机”到另一个 AS</p></li><li><p>这减少了路径长度，提高了传输效率</p></li></ul></li><li><p><strong>问题：我能知道我的数据经过了哪些地方吗？</strong></p><p>解决方案：路径追踪工具</p><ul><li><p>traceroute/tracert 就像给数据包装上 GPS</p></li><li><p>你可以看到数据包穿越的不同 AS 和路由器</p></li></ul></li></ol><p>互联网就像一个巨大的全球快递网络，你的数据包可能穿越多个国家、经过海底电缆，由不同的运营商接力传递，最终到达目的地的网络。</p><h2 id="穿越服务端局域网">穿越服务端局域网</h2><p><strong>数据包到达目标所在网络后，如何找到并到达最终的服务器？</strong></p><p>数据包抵达目的地网络，就像国际快递到达目标城市，还需要最后一段"本地配送"：</p><ol type="1"><li><p><strong>问题：如何确保只有合法请求能进入网络？</strong></p><p>解决方案：防火墙和安全策略</p><ul><li>就像机场海关，检查入境者是否符合入境条件</li><li>只有合法的数据包才能通过安全检查</li></ul></li><li><p><strong>问题：大型网站如何处理海量请求？</strong></p><p>解决方案：负载均衡</p><ul><li>像大型医院的分诊台，将病人分配到不同的医生处</li><li>根据服务器负载、用户位置等因素智能分发请求</li></ul></li><li><p><strong>问题：如何在数据中心复杂环境中找到目标服务器？</strong></p><p>解决方案：内部路由与最后一跳 ARP</p><ul><li>数据中心内部有自己的"地图"和"道路系统"</li><li>最后一个路由器会通过 ARP 找到服务器的具体位置</li></ul></li><li><p><strong>问题：现代云环境中，服务器可能是虚拟的，怎么处理？</strong></p><p>解决方案：虚拟网络</p><ul><li>物理服务器上可能运行多个虚拟机或容器</li><li>虚拟交换机将数据包准确送达虚拟环境中的目标应用</li></ul></li></ol><p>这就像国际快递最后的“最后一公里”配送 -从目的地城市的分拣中心，经过层层筛选，最终送到收件人手中。</p><h2 id="总结">总结</h2><p>网络请求就像一封国际信件的旅程：</p><ol type="1"><li><p>本地投递：从你家出发，判断收件人是否在同小区。如不在，交给小区出口的门卫（网关）。</p></li><li><p>国际运输：</p><ul><li>先经过你所在“国家”（你 ISP 的 AS）的海关（NAT）</li><li>然后可能穿越多个“国家”（不同的 AS）</li><li>各国海关（路由器）通过“国际条约”（BGP）决定包裹走向</li><li>有时通过“国际中转站”（IXP）快速转运到其他“国家”</li></ul></li><li><p>目的地配送：</p><ul><li><p>通过目的地“海关”（防火墙）入境检查</p></li><li><p>经过“分拣中心”（负载均衡器）分配处理人员</p></li><li><p>最终通过“本地快递员”（内部路由和交换）送达收件人手中</p></li></ul></li></ol><p>数据包就这样完成了客户端设备到服务器的全程旅行，然后服务器的响应再沿着类似的路径返回到客户端设备，完成整个请求-响应循环。</p><h1 id="参考">参考</h1><ul><li><p><ahref="https://time.geekbang.org/column/article/846257">极客时间《网络架构实战课》</a></p></li><li><p><ahref="https://www.geeksforgeeks.org/difference-between-osi-model-and-tcp-ip-model/">DifferenceBetween OSI Model and TCP/IP Model</a></p></li></ul>]]></content>
    
    
    <summary type="html">通过一个 HTTP 请求与响应，深入探索背后的网络通信机制，从 DNS 解析、TCP 连接到数据封装与传输，全面解析数据包如何穿越局域网与公网到达目标服务器。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>解决方案丨游戏后端中的 Push-ACK 机制设计与内存优化</title>
    <link href="https://hedon.top/2025/02/27/solution-push-ack/"/>
    <id>https://hedon.top/2025/02/27/solution-push-ack/</id>
    <published>2025-02-27T12:31:45.000Z</published>
    <updated>2025-03-03T11:53:53.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言">引言</h2><p>在现代在线游戏开发中，服务器与客户端之间实时、可靠的通信机制是游戏体验的基石。作为一名游戏后端开发者，我曾经遇到过这样的场景：更新了一个公会系统的新功能，服务器需要向成千上万个在线玩家推送公会状态变更。短短几小时后，服务器内存使用率飙升至90%，系统告警不断。问题出在哪里？Push消息的可靠性机制实现不当导致了内存泄漏。</p><p>本文将深入探讨游戏后端中 Push-ACK机制的设计与实现，特别关注如何避免内存暴涨问题，分享我在多个大型游戏项目中积累的经验与教训。</p><h2 id="背景为什么需要应用层的-ack-机制">背景：为什么需要应用层的 ACK机制？</h2><p>TCP协议确实提供了可靠的数据传输保证，包括数据包的序列号、校验和、超时重传等机制。那么，为什么我们还需要在应用层实现额外的ACK 机制呢？</p><h3 id="tcp-可靠性的边界">TCP 可靠性的边界</h3><p>TCP只能保证<strong>数据被送达到客户端的网络栈</strong>，但无法保证：</p><ol type="1"><li>数据被客户端应用程序正确处理</li><li>处理过程中没有出现异常</li><li>客户端的业务逻辑正确执行</li></ol><p>想象这样一个场景：服务器向玩家推送了一条"获得稀有装备"的消息，TCP确保了数据送达客户端，但如果客户端在处理这个消息时崩溃了呢？对于游戏这类状态敏感的应用，我们需要知道消息是否被<strong>成功处理</strong>，而不仅仅是<strong>成功传输</strong>。</p><h3 id="业务可靠性需求">业务可靠性需求</h3><p>实际游戏开发中，不同类型的消息有不同的可靠性需求：</p><table><thead><tr class="header"><th>消息类型</th><th>示例</th><th>可靠性需求</th></tr></thead><tbody><tr class="odd"><td>关键状态变更</td><td>道具获取、货币变化</td><td>极高（必须确认处理）</td></tr><tr class="even"><td>游戏进程通知</td><td>任务更新、成就解锁</td><td>高（需要确认）</td></tr><tr class="odd"><td>实时位置同步</td><td>玩家位置、NPC 移动</td><td>中（新数据可覆盖旧数据）</td></tr><tr class="even"><td>环境信息</td><td>天气变化、背景音乐</td><td>低（可接受偶尔丢失）</td></tr></tbody></table><h2 id="设计通用的-push-ack-机制">设计通用的 Push-ACK 机制</h2><p>一个完善的 Push-ACK机制需要考虑以下几个方面：消息唯一标识、优先级分级、超时重试、批量确认和失败处理。下面是基于Go 语言的设计实现：</p><h3 id="核心数据结构">核心数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Message 表示服务器推送的消息</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    MsgID        <span class="type">string</span>      <span class="string">`json:&quot;msg_id&quot;`</span>        <span class="comment">// 唯一消息标识</span></span><br><span class="line">    MsgType      <span class="type">string</span>      <span class="string">`json:&quot;msg_type&quot;`</span>      <span class="comment">// 消息类型</span></span><br><span class="line">    Timestamp    <span class="type">int64</span>       <span class="string">`json:&quot;timestamp&quot;`</span>     <span class="comment">// 发送时间戳</span></span><br><span class="line">    Priority     <span class="type">int</span>         <span class="string">`json:&quot;priority&quot;`</span>      <span class="comment">// 优先级：1-高，2-中，3-低</span></span><br><span class="line">    Payload      <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;payload&quot;`</span>       <span class="comment">// 消息内容</span></span><br><span class="line">    RequiresAck  <span class="type">bool</span>        <span class="string">`json:&quot;requires_ack&quot;`</span>  <span class="comment">// 是否需要确认</span></span><br><span class="line">    Expiration   <span class="type">int64</span>       <span class="string">`json:&quot;expiration&quot;`</span>    <span class="comment">// 过期时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AckMessage 表示客户端的确认消息</span></span><br><span class="line"><span class="keyword">type</span> AckMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">    AckID            <span class="type">string</span>  <span class="string">`json:&quot;ack_id&quot;`</span>           <span class="comment">// 对应原消息ID</span></span><br><span class="line">    Status           <span class="type">string</span>  <span class="string">`json:&quot;status&quot;`</span>           <span class="comment">// 状态：success/failed/partial</span></span><br><span class="line">    ClientTimestamp  <span class="type">int64</span>   <span class="string">`json:&quot;client_timestamp&quot;`</span> <span class="comment">// 客户端处理时间</span></span><br><span class="line">    ErrorCode        <span class="type">int</span>     <span class="string">`json:&quot;error_code&quot;`</span>       <span class="comment">// 错误码</span></span><br><span class="line">    ErrorMessage     <span class="type">string</span>  <span class="string">`json:&quot;error_message&quot;`</span>    <span class="comment">// 错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BatchAckMessage 表示批量确认消息</span></span><br><span class="line"><span class="keyword">type</span> BatchAckMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">    BatchAck        <span class="type">bool</span>     <span class="string">`json:&quot;batch_ack&quot;`</span>       <span class="comment">// 批量确认标志</span></span><br><span class="line">    AckIDs          []<span class="type">string</span> <span class="string">`json:&quot;ack_ids&quot;`</span>         <span class="comment">// 消息ID列表</span></span><br><span class="line">    Status          <span class="type">string</span>   <span class="string">`json:&quot;status&quot;`</span>          <span class="comment">// 状态</span></span><br><span class="line">    ClientTimestamp <span class="type">int64</span>    <span class="string">`json:&quot;client_timestamp&quot;`</span><span class="comment">// 确认时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PendingMessageInfo 表示等待确认的消息信息</span></span><br><span class="line"><span class="keyword">type</span> PendingMessageInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    ClientID    <span class="type">string</span>      <span class="comment">// 客户端ID</span></span><br><span class="line">    Message     *Message    <span class="comment">// 原始消息</span></span><br><span class="line">    SentTime    <span class="type">int64</span>       <span class="comment">// 发送时间</span></span><br><span class="line">    RetryCount  <span class="type">int</span>         <span class="comment">// 重试次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器端-push-管理器实现">服务器端 Push 管理器实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PushManager 负责管理推送消息和确认</span></span><br><span class="line"><span class="keyword">type</span> PushManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    pendingMessages    <span class="keyword">map</span>[<span class="type">string</span>]*PendingMessageInfo  <span class="comment">// 等待确认的消息</span></span><br><span class="line">    clientMessageCount <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>                  <span class="comment">// 每个客户端的消息数量</span></span><br><span class="line">    ackTimeout         <span class="type">int64</span>                           <span class="comment">// 确认超时时间(秒)</span></span><br><span class="line">    maxRetries         <span class="type">int</span>                             <span class="comment">// 最大重试次数</span></span><br><span class="line">    maxPendingPerClient <span class="type">int</span>                            <span class="comment">// 每客户端最大消息数</span></span><br><span class="line">    maxMessageAge      <span class="type">int64</span>                           <span class="comment">// 消息最大生存时间(秒)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存监控相关</span></span><br><span class="line">    memoryThresholdMB  <span class="type">int64</span>                           <span class="comment">// 内存阈值(MB)</span></span><br><span class="line">    criticalThresholdMB <span class="type">int64</span>                          <span class="comment">// 危险内存阈值(MB)</span></span><br><span class="line"></span><br><span class="line">    mutex              sync.RWMutex                    <span class="comment">// 保护并发访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网络接口（依赖外部实现）</span></span><br><span class="line">    networkLayer       NetworkInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPushManager 创建一个新的推送管理器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPushManager</span><span class="params">(networkLayer NetworkInterface)</span></span> *PushManager &#123;</span><br><span class="line">    pm := &amp;PushManager&#123;</span><br><span class="line">        pendingMessages:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*PendingMessageInfo),</span><br><span class="line">        clientMessageCount:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>),</span><br><span class="line">        ackTimeout:          <span class="number">10</span>,</span><br><span class="line">        maxRetries:          <span class="number">3</span>,</span><br><span class="line">        maxPendingPerClient: <span class="number">1000</span>,</span><br><span class="line">        maxMessageAge:       <span class="number">300</span>,</span><br><span class="line">        memoryThresholdMB:   <span class="number">1000</span>,  <span class="comment">// 1GB</span></span><br><span class="line">        criticalThresholdMB: <span class="number">1500</span>,  <span class="comment">// 1.5GB</span></span><br><span class="line">        networkLayer:        networkLayer,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动后台任务</span></span><br><span class="line">    <span class="keyword">go</span> pm.checkTimeoutsLoop()</span><br><span class="line">    <span class="keyword">go</span> pm.cleanupLoop()</span><br><span class="line">    <span class="keyword">go</span> pm.memoryMonitorLoop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushMessage 向客户端推送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> PushMessage(clientID <span class="type">string</span>, message *Message) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不需要确认，直接发送</span></span><br><span class="line">    <span class="keyword">if</span> !message.RequiresAck &#123;</span><br><span class="line">        <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查客户端消息数是否超限</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &gt;= pm.maxPendingPerClient &#123;</span><br><span class="line">        pm.handleQueueOverflow(clientID, message)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储待确认消息</span></span><br><span class="line">    pm.pendingMessages[message.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">        ClientID:    clientID,</span><br><span class="line">        Message:     message,</span><br><span class="line">        SentTime:    time.Now().Unix(),</span><br><span class="line">        RetryCount:  <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新客户端消息计数</span></span><br><span class="line">    pm.clientMessageCount[clientID]++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProcessAck 处理客户端的确认消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> ProcessAck(clientID <span class="type">string</span>, ack *AckMessage) <span class="type">bool</span> &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    info, exists := pm.pendingMessages[ack.AckID]</span><br><span class="line">    <span class="keyword">if</span> !exists || info.ClientID != clientID &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认成功，删除消息</span></span><br><span class="line">    <span class="built_in">delete</span>(pm.pendingMessages, ack.AckID)</span><br><span class="line">    pm.clientMessageCount[clientID]--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客户端没有待确认消息了，清理计数器</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProcessBatchAck 处理批量确认</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> ProcessBatchAck(clientID <span class="type">string</span>, batchAck *BatchAckMessage) <span class="type">int</span> &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    confirmedCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, ackID := <span class="keyword">range</span> batchAck.AckIDs &#123;</span><br><span class="line">        info, exists := pm.pendingMessages[ackID]</span><br><span class="line">        <span class="keyword">if</span> exists &amp;&amp; info.ClientID == clientID &#123;</span><br><span class="line">            <span class="built_in">delete</span>(pm.pendingMessages, ackID)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line">            confirmedCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客户端没有待确认消息了，清理计数器</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> confirmedCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台任务：超时检查与重试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> checkTimeoutsLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        pm.checkTimeouts()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时检查与重试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> checkTimeouts() &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    now := time.Now().Unix()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.pendingMessages &#123;</span><br><span class="line">        <span class="comment">// 检查是否超时</span></span><br><span class="line">        <span class="keyword">if</span> now - info.SentTime &gt; pm.ackTimeout &#123;</span><br><span class="line">            <span class="keyword">if</span> info.RetryCount &lt; pm.maxRetries &#123;</span><br><span class="line">                <span class="comment">// 增加重试次数</span></span><br><span class="line">                info.RetryCount++</span><br><span class="line">                info.SentTime = now</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新发送</span></span><br><span class="line">                pm.networkLayer.SendToClient(info.ClientID, info.Message)</span><br><span class="line">                log.Printf(<span class="string">&quot;Retrying message %s to client %s, attempt %d&quot;</span>,</span><br><span class="line">                          msgID, info.ClientID, info.RetryCount)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 超出最大重试次数，放弃并记录</span></span><br><span class="line">                log.Printf(<span class="string">&quot;Message %s to client %s failed after %d attempts&quot;</span>,</span><br><span class="line">                          msgID, info.ClientID, pm.maxRetries)</span><br><span class="line"></span><br><span class="line">                <span class="built_in">delete</span>(pm.pendingMessages, msgID)</span><br><span class="line">                pm.clientMessageCount[info.ClientID]--</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通知业务层处理失败</span></span><br><span class="line">                <span class="keyword">go</span> pm.notifyMessageFailed(info.ClientID, info.Message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决内存暴涨问题">解决内存暴涨问题</h2><p>在大型游戏中，服务器可能同时维护数十万甚至上百万个连接，如果每个连接都有数百条待确认消息，服务器内存很快就会爆满。以下是我在实践中总结的几种高效内存管理策略：</p><h3 id="周期性过期消息清理">1. 周期性过期消息清理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清理过期消息的后台循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> cleanupLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Minute)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        pm.cleanExpiredMessages()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理过期消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> cleanExpiredMessages() &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    now := time.Now().Unix()</span><br><span class="line">    expiredCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.pendingMessages &#123;</span><br><span class="line">        <span class="comment">// 检查消息是否过期</span></span><br><span class="line">        <span class="keyword">if</span> now - info.SentTime &gt; pm.maxMessageAge &#123;</span><br><span class="line">            <span class="built_in">delete</span>(pm.pendingMessages, msgID)</span><br><span class="line">            pm.clientMessageCount[info.ClientID]--</span><br><span class="line">            expiredCount++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">            log.Printf(<span class="string">&quot;Cleaned expired message %s to client %s (age: %d seconds)&quot;</span>,</span><br><span class="line">                      msgID, info.ClientID, now - info.SentTime)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> expiredCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Cleanup: Removed %d expired messages&quot;</span>, expiredCount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息压缩与合并">2. 消息压缩与合并</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompressMessage 压缩消息以减少内存占用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompressMessage</span><span class="params">(message *Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="comment">// 将消息转为JSON</span></span><br><span class="line">    jsonData, err := json.Marshal(message)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error marshaling message: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用gzip压缩</span></span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    writer := gzip.NewWriter(&amp;buf)</span><br><span class="line"></span><br><span class="line">    _, err = writer.Write(jsonData)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error compressing message: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := writer.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error closing gzip writer: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DecompressMessage 解压缩消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecompressMessage</span><span class="params">(compressed []<span class="type">byte</span>)</span></span> (*Message, <span class="type">error</span>) &#123;</span><br><span class="line">    reader, err := gzip.NewReader(bytes.NewReader(compressed))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;create gzip reader: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> reader.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(&amp;buf, reader); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;decompress data: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> message Message</span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(buf.Bytes(), &amp;message); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unmarshal json: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;message, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分级存储策略">3. 分级存储策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PushManager 增加分级存储功能</span></span><br><span class="line"><span class="keyword">type</span> PushManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ... 之前的字段 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存中存储高优先级消息</span></span><br><span class="line">    memoryPending     <span class="keyword">map</span>[<span class="type">string</span>]*PendingMessageInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis客户端，用于存储低优先级消息</span></span><br><span class="line">    redisClient      *redis.Client</span><br><span class="line">    redisKeyPrefix   <span class="type">string</span></span><br><span class="line">    redisExpiry      time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushMessage 分级存储版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> PushMessage(clientID <span class="type">string</span>, message *Message) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不需要确认，直接发送</span></span><br><span class="line">    <span class="keyword">if</span> !message.RequiresAck &#123;</span><br><span class="line">        <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查客户端消息数量限制</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &gt;= pm.maxPendingPerClient &#123;</span><br><span class="line">        pm.handleQueueOverflow(clientID, message)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm.clientMessageCount[clientID]++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据优先级选择存储位置</span></span><br><span class="line">    <span class="keyword">if</span> message.Priority &lt;= <span class="number">2</span> &#123; <span class="comment">// 高优先级和中优先级</span></span><br><span class="line">        <span class="comment">// 存入内存</span></span><br><span class="line">        pm.memoryPending[message.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">            ClientID:    clientID,</span><br><span class="line">            Message:     message,</span><br><span class="line">            SentTime:    time.Now().Unix(),</span><br><span class="line">            RetryCount:  <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 低优先级</span></span><br><span class="line">        <span class="comment">// 存入Redis</span></span><br><span class="line">        messageInfo := &amp;PendingMessageInfo&#123;</span><br><span class="line">            ClientID:    clientID,</span><br><span class="line">            Message:     message,</span><br><span class="line">            SentTime:    time.Now().Unix(),</span><br><span class="line">            RetryCount:  <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jsonData, err := json.Marshal(messageInfo)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error marshaling message: %v&quot;</span>, err)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        redisKey := pm.redisKeyPrefix + message.MsgID</span><br><span class="line">        err = pm.redisClient.Set(context.Background(), redisKey, jsonData, pm.redisExpiry).Err()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error storing message in Redis: %v&quot;</span>, err)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProcessAck 分级存储版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> ProcessAck(clientID <span class="type">string</span>, ack *AckMessage) <span class="type">bool</span> &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查内存中的消息</span></span><br><span class="line">    info, existsInMemory := pm.memoryPending[ack.AckID]</span><br><span class="line">    <span class="keyword">if</span> existsInMemory &amp;&amp; info.ClientID == clientID &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pm.memoryPending, ack.AckID)</span><br><span class="line">        pm.clientMessageCount[clientID]--</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再检查Redis中的消息</span></span><br><span class="line">    redisKey := pm.redisKeyPrefix + ack.AckID</span><br><span class="line">    exists, err := pm.redisClient.Exists(context.Background(), redisKey).Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error checking message in Redis: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> exists == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 获取消息以验证客户端ID</span></span><br><span class="line">        jsonData, err := pm.redisClient.Get(context.Background(), redisKey).Bytes()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error getting message from Redis: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> messageInfo PendingMessageInfo</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(jsonData, &amp;messageInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error unmarshaling message from Redis: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> messageInfo.ClientID == clientID &#123;</span><br><span class="line">            <span class="comment">// 从Redis删除并更新计数</span></span><br><span class="line">            pm.redisClient.Del(context.Background(), redisKey)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存自适应调整">4. 内存自适应调整</h3><p>内存自适应调整是我在实际项目中解决突发流量问题的关键策略。它能够根据当前系统负载动态调整消息处理参数，确保系统稳定性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存监控循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> memoryMonitorLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">10</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        memoryMB := pm.getMemoryUsageMB()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> memoryMB &gt; pm.criticalThresholdMB &#123;</span><br><span class="line">            <span class="comment">// 紧急情况，进行应急清理</span></span><br><span class="line">            pm.emergencyCleanup(memoryMB)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> memoryMB &gt; pm.memoryThresholdMB &#123;</span><br><span class="line">            <span class="comment">// 超过警戒线，调整参数</span></span><br><span class="line">            pm.adjustParameters(memoryMB)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前进程内存使用量（MB）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> getMemoryUsageMB() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> memStats runtime.MemStats</span><br><span class="line">    runtime.ReadMemStats(&amp;memStats)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(memStats.Alloc / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据内存使用情况调整参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> adjustParameters(currentMemoryMB <span class="type">int64</span>) &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算内存超出比例</span></span><br><span class="line">    excessRatio := <span class="type">float64</span>(currentMemoryMB - pm.memoryThresholdMB) / <span class="type">float64</span>(pm.memoryThresholdMB)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整每客户端最大消息数</span></span><br><span class="line">    newMaxPerClient := <span class="type">int</span>(<span class="type">float64</span>(pm.maxPendingPerClient) * (<span class="number">1</span> - excessRatio*<span class="number">0.5</span>))</span><br><span class="line">    <span class="keyword">if</span> newMaxPerClient &lt; <span class="number">100</span> &#123;</span><br><span class="line">        newMaxPerClient = <span class="number">100</span> <span class="comment">// 确保至少保留100条</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整消息最大生存时间</span></span><br><span class="line">    newMaxAge := <span class="type">int64</span>(<span class="type">float64</span>(pm.maxMessageAge) * (<span class="number">1</span> - excessRatio*<span class="number">0.5</span>))</span><br><span class="line">    <span class="keyword">if</span> newMaxAge &lt; <span class="number">60</span> &#123;</span><br><span class="line">        newMaxAge = <span class="number">60</span> <span class="comment">// 至少60秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新参数</span></span><br><span class="line">    pm.maxPendingPerClient = newMaxPerClient</span><br><span class="line">    pm.maxMessageAge = newMaxAge</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;Memory usage: %d MB, adjusted parameters: maxPending=%d, maxAge=%ds&quot;</span>,</span><br><span class="line">               currentMemoryMB, pm.maxPendingPerClient, pm.maxMessageAge)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一次清理</span></span><br><span class="line">    pm.cleanExpiredMessages()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧急清理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> emergencyCleanup(currentMemoryMB <span class="type">int64</span>) &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;CRITICAL: Memory usage at %d MB, performing emergency cleanup&quot;</span>, currentMemoryMB)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大幅降低参数</span></span><br><span class="line">    pm.maxPendingPerClient = <span class="number">100</span></span><br><span class="line">    pm.maxMessageAge = <span class="number">60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理低优先级消息</span></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.memoryPending &#123;</span><br><span class="line">        <span class="keyword">if</span> info.Message.Priority &gt; <span class="number">1</span> &#123; <span class="comment">// 只保留最高优先级</span></span><br><span class="line">            <span class="built_in">delete</span>(pm.memoryPending, msgID)</span><br><span class="line">            pm.clientMessageCount[info.ClientID]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;Emergency cleanup completed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列溢出处理策略">5. 队列溢出处理策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理队列溢出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> handleQueueOverflow(clientID <span class="type">string</span>, newMessage *Message) &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Queue overflow for client %s&quot;</span>, clientID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略1: 根据消息优先级决定是否替换现有消息</span></span><br><span class="line">    <span class="keyword">if</span> newMessage.Priority == <span class="number">1</span> &#123; <span class="comment">// 高优先级消息</span></span><br><span class="line">        <span class="comment">// 查找并替换该客户端的一条低优先级消息</span></span><br><span class="line">        <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.memoryPending &#123;</span><br><span class="line">            <span class="keyword">if</span> info.ClientID == clientID &amp;&amp; info.Message.Priority &gt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// 记录</span></span><br><span class="line">                log.Printf(<span class="string">&quot;Replacing low priority message %s with high priority message&quot;</span>, msgID)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 删除旧消息</span></span><br><span class="line">                <span class="built_in">delete</span>(pm.memoryPending, msgID)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加新消息</span></span><br><span class="line">                pm.memoryPending[newMessage.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">                    ClientID:    clientID,</span><br><span class="line">                    Message:     newMessage,</span><br><span class="line">                    SentTime:    time.Now().Unix(),</span><br><span class="line">                    RetryCount:  <span class="number">0</span>,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送新消息</span></span><br><span class="line">                pm.networkLayer.SendToClient(clientID, newMessage)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略2: 丢弃旧消息以腾出空间</span></span><br><span class="line">    <span class="comment">// 查找该客户端最旧的消息</span></span><br><span class="line">    <span class="keyword">var</span> oldestMsgID <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> oldestTime <span class="type">int64</span> = math.MaxInt64</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.memoryPending &#123;</span><br><span class="line">        <span class="keyword">if</span> info.ClientID == clientID &amp;&amp; info.SentTime &lt; oldestTime &#123;</span><br><span class="line">            oldestMsgID = msgID</span><br><span class="line">            oldestTime = info.SentTime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldestMsgID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Dropping oldest message %s for client %s&quot;</span>, oldestMsgID, clientID)</span><br><span class="line">        <span class="built_in">delete</span>(pm.memoryPending, oldestMsgID)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加新消息</span></span><br><span class="line">        pm.memoryPending[newMessage.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">            ClientID:    clientID,</span><br><span class="line">            Message:     newMessage,</span><br><span class="line">            SentTime:    time.Now().Unix(),</span><br><span class="line">            RetryCount:  <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送新消息</span></span><br><span class="line">        pm.networkLayer.SendToClient(clientID, newMessage)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 极端情况，无法找到可替换的消息</span></span><br><span class="line">        log.Printf(<span class="string">&quot;Cannot find message to replace for client %s&quot;</span>, clientID)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端实现">客户端实现</h2><p>客户端实现同样关键，特别是批量确认机制能显著减少网络流量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PushReceiver 客户端推送接收处理器</span></span><br><span class="line"><span class="keyword">type</span> PushReceiver <span class="keyword">struct</span> &#123;</span><br><span class="line">    connection        Connection          <span class="comment">// 网络连接接口</span></span><br><span class="line">    processedMsgIDs   <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>    <span class="comment">// 已处理消息ID及处理时间</span></span><br><span class="line">    pendingAcks       []<span class="type">string</span>            <span class="comment">// 待确认的消息ID</span></span><br><span class="line">    ackBatchSize      <span class="type">int</span>                 <span class="comment">// 批量确认大小</span></span><br><span class="line">    ackInterval       time.Duration       <span class="comment">// 批量确认间隔</span></span><br><span class="line">    messageHandlers   <span class="keyword">map</span>[<span class="type">string</span>]MessageHandler <span class="comment">// 消息处理函数</span></span><br><span class="line"></span><br><span class="line">    mutex             sync.Mutex          <span class="comment">// 保护并发访问</span></span><br><span class="line">    stopChan          <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;       <span class="comment">// 停止信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageHandler 消息处理函数类型</span></span><br><span class="line"><span class="keyword">type</span> MessageHandler <span class="function"><span class="keyword">func</span><span class="params">(payload <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPushReceiver 创建推送接收器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPushReceiver</span><span class="params">(conn Connection)</span></span> *PushReceiver &#123;</span><br><span class="line">    receiver := &amp;PushReceiver&#123;</span><br><span class="line">        connection:       conn,</span><br><span class="line">        processedMsgIDs:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>),</span><br><span class="line">        pendingAcks:      <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>),</span><br><span class="line">        ackBatchSize:     <span class="number">50</span>,</span><br><span class="line">        ackInterval:      time.Second,</span><br><span class="line">        messageHandlers:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]MessageHandler),</span><br><span class="line">        stopChan:         <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动批量确认任务</span></span><br><span class="line">    <span class="keyword">go</span> receiver.ackLoop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动过期消息ID清理任务</span></span><br><span class="line">    <span class="keyword">go</span> receiver.cleanupLoop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterHandler 注册消息处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> RegisterHandler(msgType <span class="type">string</span>, handler MessageHandler) &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    r.messageHandlers[msgType] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleMessage 处理收到的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> HandleMessage(message *Message) &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    msgID := message.MsgID</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已处理过该消息</span></span><br><span class="line">    <span class="keyword">if</span> _, exists := r.processedMsgIDs[msgID]; exists &#123;</span><br><span class="line">        <span class="comment">// 已处理过，再次发送确认</span></span><br><span class="line">        <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">            r.pendingAcks = <span class="built_in">append</span>(r.pendingAcks, msgID)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果积累的确认数量超过批量大小，立即发送</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(r.pendingAcks) &gt;= r.ackBatchSize &#123;</span><br><span class="line">                <span class="keyword">go</span> r.sendBatchAcks()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找处理函数</span></span><br><span class="line">    handler, exists := r.messageHandlers[message.MsgType]</span><br><span class="line">    <span class="keyword">if</span> !exists &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;No handler for message type: %s&quot;</span>, message.MsgType)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未知消息类型也需要确认</span></span><br><span class="line">        <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">            r.sendErrorAck(msgID, <span class="string">&quot;Unknown message type&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    err := handler(message.Payload)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error processing message %s: %v&quot;</span>, msgID, err)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">            r.sendErrorAck(msgID, err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录已处理的消息</span></span><br><span class="line">    r.processedMsgIDs[msgID] = time.Now().Unix()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要确认，加入待确认队列</span></span><br><span class="line">    <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">        r.pendingAcks = <span class="built_in">append</span>(r.pendingAcks, msgID)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果积累的确认数量超过批量大小，立即发送</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(r.pendingAcks) &gt;= r.ackBatchSize &#123;</span><br><span class="line">            <span class="keyword">go</span> r.sendBatchAcks()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送批量确认</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> sendBatchAcks() &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有待确认消息，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(r.pendingAcks) == <span class="number">0</span> &#123;</span><br><span class="line">        r.mutex.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制当前的待确认ID列表</span></span><br><span class="line">    ackIDs := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(r.pendingAcks))</span><br><span class="line">    <span class="built_in">copy</span>(ackIDs, r.pendingAcks)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空待确认列表</span></span><br><span class="line">    r.pendingAcks = r.pendingAcks[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建批量确认消息</span></span><br><span class="line">    batchAck := &amp;BatchAckMessage&#123;</span><br><span class="line">        BatchAck:        <span class="literal">true</span>,</span><br><span class="line">        AckIDs:          ackIDs,</span><br><span class="line">        Status:          <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        ClientTimestamp: time.Now().Unix(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送确认</span></span><br><span class="line">    r.connection.Send(batchAck)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送错误确认</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> sendErrorAck(msgID <span class="type">string</span>, errorMessage <span class="type">string</span>) &#123;</span><br><span class="line">    ack := &amp;AckMessage&#123;</span><br><span class="line">        AckID:           msgID,</span><br><span class="line">        Status:          <span class="string">&quot;failed&quot;</span>,</span><br><span class="line">        ClientTimestamp: time.Now().Unix(),</span><br><span class="line">        ErrorCode:       <span class="number">1001</span>,</span><br><span class="line">        ErrorMessage:    errorMessage,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.connection.Send(ack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量确认定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> ackLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(r.ackInterval)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            r.sendBatchAcks()</span><br><span class="line">        <span class="keyword">case</span> &lt;-r.stopChan:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理过期的已处理消息ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> cleanupLoop() &#123;</span><br><span class="line">    <span class="comment">// 每小时清理一次</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Hour)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            r.cleanupProcessedIDs()</span><br><span class="line">        <span class="keyword">case</span> &lt;-r.stopChan:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理过期的已处理消息ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> cleanupProcessedIDs() &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    now := time.Now().Unix()</span><br><span class="line">    expireTime := <span class="type">int64</span>(<span class="number">86400</span>) <span class="comment">// 24小时过期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, processTime := <span class="keyword">range</span> r.processedMsgIDs &#123;</span><br><span class="line">        <span class="keyword">if</span> now - processTime &gt; expireTime &#123;</span><br><span class="line">            <span class="built_in">delete</span>(r.processedMsgIDs, msgID)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭推送接收器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> Close() &#123;</span><br><span class="line">    <span class="comment">// 发送所有待确认消息</span></span><br><span class="line">    r.sendBatchAcks()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止所有后台任务</span></span><br><span class="line">    <span class="built_in">close</span>(r.stopChan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战经验与最佳实践">实战经验与最佳实践</h2><p>在多个千万用户级别的游戏项目实践中，我总结了以下几点 Push-ACK机制的最佳实践：</p><h3 id="消息分级是关键">1. 消息分级是关键</h3><p>不是所有消息都需要相同级别的可靠性保证。在一个 MMORPG项目中，我们将消息分为四级：</p><ul><li><strong>关键级</strong>：直接影响游戏平衡和经济的消息，如道具获取、货币变化</li><li><strong>重要级</strong>：影响游戏进程的消息，如任务更新、排行榜变动</li><li><strong>普通级</strong>：一般游戏状态信息，如其他玩家动作、环境变化</li><li><strong>低优先级</strong>：可以容忍丢失的背景信息，如聊天、天气效果</li></ul><p>高级别消息使用完整的 ACK 机制，低级别消息可以简化甚至取消 ACK需求，这样大大减轻了服务器内存压力。</p><h3 id="利用统计指标进行调优">2. 利用统计指标进行调优</h3><p>监控以下关键指标：</p><ul><li>ACK 响应时间分布</li><li>消息重试率</li><li>每客户端平均待确认消息数</li><li>内存使用增长曲线</li></ul><p>在一个足球经理类游戏中，通过这些指标我们发现，将 ACK 超时时间从 10秒调整到 5 秒，并将最大重试次数从 3 次增加到 5次，可以将消息最终确认率从 99.2%提高到 99.8%，同时减少了25%的内存使用。</p><h3 id="针对不同网络环境优化">3. 针对不同网络环境优化</h3><p>移动网络环境差异很大，针对不同网络条件动态调整策略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据网络条件调整参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> adjustForNetworkCondition(clientID <span class="type">string</span>, rtt time.Duration) &#123;</span><br><span class="line">    <span class="comment">// 网络条件良好</span></span><br><span class="line">    <span class="keyword">if</span> rtt &lt; <span class="number">100</span>*time.Millisecond &#123;</span><br><span class="line">        pm.clientTimeouts[clientID] = <span class="number">3</span> <span class="comment">// 3秒超时</span></span><br><span class="line">        pm.clientRetries[clientID] = <span class="number">2</span>  <span class="comment">// 2次重试</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> rtt &lt; <span class="number">300</span>*time.Millisecond &#123;</span><br><span class="line">        pm.clientTimeouts[clientID] = <span class="number">5</span> <span class="comment">// 5秒超时</span></span><br><span class="line">        pm.clientRetries[clientID] = <span class="number">3</span>  <span class="comment">// 3次重试</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pm.clientTimeouts[clientID] = <span class="number">10</span> <span class="comment">// 10秒超时</span></span><br><span class="line">        pm.clientRetries[clientID] = <span class="number">5</span>   <span class="comment">// 5次重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定期压力测试">4. 定期压力测试</h3><p>在一个大型开放世界游戏中，我们每月进行一次"混沌测试"，模拟极端情况：</p><ol type="1"><li>突发 50%客户端同时掉线然后重连</li><li>模拟网络延迟突然从 50ms 增加到 500ms</li><li>模拟 10%的确认消息丢失</li></ol><p>这种测试让我们发现了很多边缘情况，并建立了更健壮的防御机制。</p><h2 id="结论">结论</h2><p>一个设计良好的 Push-ACK机制是现代游戏服务器架构的核心组件。它确保了游戏状态的一致性，提升了玩家体验，同时也为运营团队提供了可靠的数据基础。最重要的是，它必须是高性能且资源友好的。</p><p>通过采用本文介绍的多级存储、自适应参数调整、消息优先级和过期策略等技术，我们可以构建一个既可靠又高效的推送确认系统，即使在面对数十万并发</p>]]></content>
    
    
    <summary type="html">本文介绍了游戏后端中的 Push-ACK 机制的设计与实现，特别关注如何避免内存暴涨问题，分享了在多个大型游戏项目中积累的经验与教训。</summary>
    
    
    
    <category term="解决方案" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="游戏后端" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%B8%B8%E6%88%8F%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="解决方案" scheme="https://hedon.top/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="游戏后端" scheme="https://hedon.top/tags/%E6%B8%B8%E6%88%8F%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Push-Ack" scheme="https://hedon.top/tags/Push-Ack/"/>
    
  </entry>
  
  <entry>
    <title>服务监控丨Prometheus 四大数据类型详解</title>
    <link href="https://hedon.top/2025/02/26/prometheus-data-type/"/>
    <id>https://hedon.top/2025/02/26/prometheus-data-type/</id>
    <published>2025-02-26T07:52:10.000Z</published>
    <updated>2025-03-03T11:53:59.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在微服务和云原生架构的世界中，一套强大的监控系统是保障服务稳定性的基石。Prometheus作为 CNCF的明星项目，凭借其简单高效的特性，已成为事实上的云原生监控标准。本文将深入剖析Prometheus 的四大数据类型及其 PromQL查询语言，帮助开发团队构建强大的可观测性系统。</p><h2 id="结论先行prometheus-四大数据类型速览">结论先行：Prometheus四大数据类型速览</h2><table style="width:100%;"><colgroup><col style="width: 12%" /><col style="width: 22%" /><col style="width: 19%" /><col style="width: 19%" /><col style="width: 26%" /></colgroup><thead><tr class="header"><th>特性</th><th>Counter</th><th>Gauge</th><th>Histogram</th><th>Summary</th></tr></thead><tbody><tr class="odd"><td><strong>定义</strong></td><td>只增不减的累积计数器</td><td>可增可减的瞬时值</td><td>观测值分布的分桶统计</td><td>客户端计算的分位数统计</td></tr><tr class="even"><td><strong>重置行为</strong></td><td>服务重启时归零</td><td>保持当前值</td><td>桶计数归零</td><td>计数归零</td></tr><tr class="odd"><td><strong>典型应用</strong></td><td>请求计数、错误数、流量统计</td><td>温度、内存使用、连接数</td><td>请求延迟、响应大小</td><td>请求延迟、队列等待时间</td></tr><tr class="even"><td><strong>数据点</strong></td><td>单一值</td><td>单一值</td><td>_bucket、_sum、count</td><td>{quantile="x"}、_sum、_count</td></tr><tr class="odd"><td><strong>查询重点</strong></td><td>rate()、increase()</td><td>直接使用、预测函数</td><td>histogram_quantile()</td><td>直接读取分位数</td></tr><tr class="even"><td><strong>分布式聚合</strong></td><td>可以（sum、rate）</td><td>可以（avg、max、min）</td><td>可以（百分位也可聚合）</td><td>有限（分位数不可聚合）</td></tr><tr class="odd"><td><strong>资源消耗</strong></td><td>低</td><td>低</td><td>中（依赖桶数量）</td><td>中（客户端计算）</td></tr></tbody></table><h2 id="一prometheus-核心数据类型详解">一、Prometheus核心数据类型详解</h2><h3 id="counter计数器持续增长的累积值">1.Counter（计数器）：持续增长的累积值</h3><p>Counter是最简单但也最常用的指标类型，代表一个只增不减的累积数值。每当事件发生，计数器增加；当监控目标重启时，计数器归零。</p><p><strong>适用场景</strong>：</p><ul><li>API 请求总数</li><li>错误发生次数</li><li>处理任务的数量</li><li>网络流量字节数</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的计数器</span></span><br><span class="line">requestCounter := prometheus.NewCounterVec(</span><br><span class="line">    prometheus.CounterOpts&#123;</span><br><span class="line">        Name: <span class="string">&quot;http_requests_total&quot;</span>,</span><br><span class="line">        Help: <span class="string">&quot;Total number of HTTP requests&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;method&quot;</span>, <span class="string">&quot;path&quot;</span>, <span class="string">&quot;status&quot;</span>&#125;, <span class="comment">// 定义标签维度</span></span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(requestCounter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用标签记录请求</span></span><br><span class="line">requestCounter.WithLabelValues(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>, <span class="string">&quot;200&quot;</span>).Inc()</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 每秒请求率（5分钟窗口）</span><br><span class="line">rate(http_requests_total&#123;status=&quot;200&quot;&#125;[5m])</span><br><span class="line"></span><br><span class="line"># 错误率计算</span><br><span class="line">sum(rate(http_requests_total&#123;status=~&quot;5..&quot;&#125;[5m])) / sum(rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># 1小时内的请求增量</span><br><span class="line">increase(http_requests_total[1h])</span><br></pre></td></tr></table></figure><p><strong>最佳实践</strong>：</p><ul><li>永远不要直接使用 Counter 的原始值，总是使用 <code>rate()</code> 或<code>increase()</code></li><li>使用有意义的标签进行多维度分析，但避免高基数标签</li><li>Counter 重置（如服务重启）会被 <code>rate()</code> 函数自动处理</li></ul><h3 id="gauge仪表盘可变的瞬时值">2. Gauge（仪表盘）：可变的瞬时值</h3><p>Gauge 表示一个可增可减的瞬时测量值，反映系统的当前状态。</p><p><strong>适用场景</strong>：</p><ul><li>内存使用量</li><li>CPU 使用率</li><li>当前活跃连接数</li><li>队列深度</li><li>温度等物理量</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的仪表盘</span></span><br><span class="line">memoryGauge := prometheus.NewGaugeVec(</span><br><span class="line">    prometheus.GaugeOpts&#123;</span><br><span class="line">        Name: <span class="string">&quot;app_memory_usage_bytes&quot;</span>,</span><br><span class="line">        Help: <span class="string">&quot;Current memory usage in bytes&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;component&quot;</span>, <span class="string">&quot;instance&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(memoryGauge)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前值</span></span><br><span class="line">memoryGauge.WithLabelValues(<span class="string">&quot;api-server&quot;</span>, <span class="string">&quot;instance-1&quot;</span>).Set(<span class="type">float64</span>(getCurrentMemoryUsage()))</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 直接使用当前值</span><br><span class="line">app_memory_usage_bytes&#123;component=&quot;api-server&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 统计聚合</span><br><span class="line">avg_over_time(app_memory_usage_bytes[1h])</span><br><span class="line">max_over_time(app_memory_usage_bytes[24h])</span><br><span class="line"></span><br><span class="line"># 趋势预测（线性回归）</span><br><span class="line">predict_linear(app_memory_usage_bytes[6h], 4 * 3600)</span><br><span class="line"></span><br><span class="line"># 计算变化率</span><br><span class="line">(app_memory_usage_bytes - app_memory_usage_bytes offset 1h) / app_memory_usage_bytes offset 1h</span><br></pre></td></tr></table></figure><p><strong>最佳实践</strong>：</p><ul><li>Gauge 可以直接使用其瞬时值，不需要像 Counter 那样使用 rate</li><li>对于容易波动的指标，考虑使用 <code>avg_over_time</code>平滑数据</li><li>利用 <code>predict_linear</code> 进行容量规划和趋势预测</li></ul><h3 id="histogram直方图观测值分布的分桶统计">3.Histogram（直方图）：观测值分布的分桶统计</h3><p>Histogram允许对观测值（如请求延迟）进行分布式统计，将数据分散到预定义的桶中，是分析性能分布的理想工具。</p><p><strong>自动生成的指标</strong>：</p><ul><li><code>&lt;metric&gt;_bucket&#123;le="&lt;upper bound&gt;"&#125;</code>:小于等于特定阈值的观测值计数</li><li><code>&lt;metric&gt;_sum</code>: 所有观测值的总和</li><li><code>&lt;metric&gt;_count</code>: 观测值总数</li></ul><p><strong>适用场景</strong>：</p><ul><li>请求延迟分布</li><li>响应大小分布</li><li>批处理任务执行时间</li><li>任何需要百分位数分析的场景</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的直方图</span></span><br><span class="line">durationHistogram := prometheus.NewHistogramVec(</span><br><span class="line">    prometheus.HistogramOpts&#123;</span><br><span class="line">        Name:    <span class="string">&quot;http_request_duration_seconds&quot;</span>,</span><br><span class="line">        Help:    <span class="string">&quot;HTTP request duration in seconds&quot;</span>,</span><br><span class="line">        Buckets: prometheus.ExponentialBuckets(<span class="number">0.001</span>, <span class="number">2</span>, <span class="number">10</span>), <span class="comment">// 从1ms开始指数增长</span></span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;method&quot;</span>, <span class="string">&quot;path&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(durationHistogram)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录请求延迟</span></span><br><span class="line">durationHistogram.WithLabelValues(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>).Observe(responseTime)</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 计算平均响应时间</span><br><span class="line">rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])</span><br><span class="line"></span><br><span class="line"># 计算P90延迟</span><br><span class="line">histogram_quantile(0.9, rate(http_request_duration_seconds_bucket[5m]))</span><br><span class="line"></span><br><span class="line"># 按API路径分析P95延迟</span><br><span class="line">histogram_quantile(0.95, sum by(path, le) (rate(http_request_duration_seconds_bucket[5m])))</span><br><span class="line"></span><br><span class="line"># 计算SLO：延迟小于100ms的请求比例</span><br><span class="line">sum(rate(http_request_duration_seconds_bucket&#123;le=&quot;0.1&quot;&#125;[5m])) / sum(rate(http_request_duration_seconds_count[5m]))</span><br></pre></td></tr></table></figure><p><strong>最佳实践</strong>：</p><ul><li>仔细设计桶边界，覆盖关键分位数区域</li><li>对于延迟指标，通常使用指数桶比线性桶更合理</li><li>利用 <code>histogram_quantile</code> 计算任意分位数</li><li>桶的数量会影响存储和性能，权衡精度和开销</li></ul><h3 id="summary摘要客户端计算的分位数统计">4.Summary（摘要）：客户端计算的分位数统计</h3><p>Summary 与 Histogram类似，但在客户端直接计算并存储分位数，无需服务器端计算。</p><p><strong>自动生成的指标</strong>：</p><ul><li><code>&lt;metric&gt;&#123;quantile="&lt;φ&gt;"&#125;</code>: φ 分位数的值</li><li><code>&lt;metric&gt;_sum</code>: 所有观测值的总和</li><li><code>&lt;metric&gt;_count</code>: 观测值总数</li></ul><p><strong>适用场景</strong>：</p><ul><li>需要高精度分位数的场景</li><li>客户端计算分位数更高效的情况</li><li>对服务器端聚合要求不高的场景</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的摘要</span></span><br><span class="line">durationSummary := prometheus.NewSummaryVec(</span><br><span class="line">    prometheus.SummaryOpts&#123;</span><br><span class="line">        Name:       <span class="string">&quot;http_request_duration_seconds_summary&quot;</span>,</span><br><span class="line">        Help:       <span class="string">&quot;HTTP request duration in seconds&quot;</span>,</span><br><span class="line">        Objectives: <span class="keyword">map</span>[<span class="type">float64</span>]<span class="type">float64</span>&#123;<span class="number">0.5</span>: <span class="number">0.05</span>, <span class="number">0.9</span>: <span class="number">0.01</span>, <span class="number">0.99</span>: <span class="number">0.001</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;method&quot;</span>, <span class="string">&quot;path&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(durationSummary)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录请求延迟</span></span><br><span class="line">durationSummary.WithLabelValues(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/api/login&quot;</span>).Observe(responseTime)</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 直接读取P99延迟</span><br><span class="line">http_request_duration_seconds_summary&#123;quantile=&quot;0.99&quot;, method=&quot;GET&quot;, path=&quot;/api/users&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 计算平均响应时间</span><br><span class="line">rate(http_request_duration_seconds_summary_sum[5m]) / rate(http_request_duration_seconds_summary_count[5m])</span><br><span class="line"></span><br><span class="line"># 每个服务的中位数延迟</span><br><span class="line">max by(service) (http_request_duration_seconds_summary&#123;quantile=&quot;0.5&quot;&#125;)</span><br></pre></td></tr></table></figure><p><strong>最佳实践与限制</strong>：</p><ul><li>Summary 预计算的分位数不能跨实例聚合（这是关键限制）</li><li>适用于分位数精度要求高且实例相对独立的场景</li><li>客户端计算分位数会增加应用资源消耗</li><li>分位数设置后不可更改，需提前规划好监控需求</li></ul><h2 id="二promql-查询语言精通">二、PromQL 查询语言精通</h2><p>PromQL 是 Prometheus的强大武器，掌握它能让我们精确提取所需的监控数据。</p><h3 id="基础查询与标签选择">1. 基础查询与标签选择</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 基本查询与精确匹配</span><br><span class="line">http_requests_total&#123;status=&quot;200&quot;, method=&quot;GET&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 正则表达式匹配</span><br><span class="line">http_requests_total&#123;path=~&quot;/api/v1/.+&quot;, method!=&quot;OPTIONS&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 范围查询（返回时间序列）</span><br><span class="line">http_requests_total&#123;status=&quot;500&quot;&#125;[5m]</span><br></pre></td></tr></table></figure><h3 id="操作符与函数">2. 操作符与函数</h3><p><strong>算术运算符</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 计算内存使用率百分比</span><br><span class="line">100 * (node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes</span><br></pre></td></tr></table></figure><p><strong>聚合函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 按服务和路径分组求和</span><br><span class="line">sum by(service, path) (rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># 丢弃instance标签求最大值</span><br><span class="line">max without(instance) (node_cpu_seconds_total)</span><br></pre></td></tr></table></figure><p><strong>瞬时向量函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 标签替换</span><br><span class="line">label_replace(up, &quot;host&quot;, &quot;$1&quot;, &quot;instance&quot;, &quot;(.*):.*&quot;)</span><br><span class="line"></span><br><span class="line"># 按标签分组取topk</span><br><span class="line">topk by(path) (5, http_request_duration_seconds_sum / http_request_duration_seconds_count)</span><br></pre></td></tr></table></figure><h3 id="复杂查询模式">3. 复杂查询模式</h3><p><strong>SLI/SLO 监控</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 服务可用性SLI</span><br><span class="line">sum(rate(http_requests_total&#123;status=~&quot;2..|3..&quot;&#125;[5m])) / sum(rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># 延迟SLO</span><br><span class="line">histogram_quantile(0.99, sum by(le) (rate(http_request_duration_seconds_bucket[5m]))) &lt; 0.3</span><br></pre></td></tr></table></figure><p><strong>异常检测</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 相对于历史同期的异常增长</span><br><span class="line">rate(http_requests_total[5m])</span><br><span class="line">  &gt; 2 * avg_over_time(rate(http_requests_total[5m])[1d:5m] offset 1d)</span><br></pre></td></tr></table></figure><p><strong>预测分析</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 磁盘空间预测</span><br><span class="line">predict_linear(node_filesystem_free_bytes&#123;mountpoint=&quot;/&quot;&#125;[6h], 7 * 24 * 3600) &lt; 10 * 1024 * 1024 * 1024</span><br></pre></td></tr></table></figure><h2 id="三实战应用场景">三、实战应用场景</h2><h3 id="服务健康度监控">1. 服务健康度监控</h3><p><strong>RED 方法实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Rate - 请求率</span><br><span class="line">sum by(service) (rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># Error - 错误率</span><br><span class="line">sum by(service) (rate(http_requests_total&#123;status=~&quot;5..&quot;&#125;[5m])) / sum by(service) (rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># Duration - P95延迟</span><br><span class="line">histogram_quantile(0.95, sum by(service, le) (rate(http_request_duration_seconds_bucket[5m])))</span><br></pre></td></tr></table></figure><p><strong>服务依赖健康度</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 数据库查询错误率</span><br><span class="line">sum(rate(database_query_errors_total[5m])) / sum(rate(database_queries_total[5m]))</span><br><span class="line"></span><br><span class="line"># 第三方API调用延迟</span><br><span class="line">histogram_quantile(0.99, sum by(api_name, le) (rate(api_request_duration_seconds_bucket[5m])))</span><br></pre></td></tr></table></figure><h3 id="性能瓶颈分析">2. 性能瓶颈分析</h3><p><strong>热点 API 发现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 延迟最高的10个接口</span><br><span class="line">topk(10,</span><br><span class="line">  histogram_quantile(0.95, sum by(method, path, le) (rate(http_request_duration_seconds_bucket[5m])))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 请求量最大的接口</span><br><span class="line">topk(10, sum by(method, path) (rate(http_requests_total[5m])))</span><br></pre></td></tr></table></figure><p><strong>数据库性能分析</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 平均查询时间趋势</span><br><span class="line">rate(db_query_duration_seconds_sum[5m]) / rate(db_query_duration_seconds_count[5m])</span><br><span class="line"></span><br><span class="line"># 慢查询比例</span><br><span class="line">sum(rate(db_query_duration_seconds_bucket&#123;le=&quot;+Inf&quot;&#125;[5m])) - sum(rate(db_query_duration_seconds_bucket&#123;le=&quot;0.1&quot;&#125;[5m])) / sum(rate(db_query_duration_seconds_bucket&#123;le=&quot;+Inf&quot;&#125;[5m]))</span><br></pre></td></tr></table></figure><h3 id="容量规划与告警">3. 容量规划与告警</h3><p><strong>资源预测</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># CPU使用率预测</span><br><span class="line">predict_linear(avg by(instance) (rate(node_cpu_seconds_total&#123;mode!=&quot;idle&quot;&#125;[6h])) [3d:], 7 * 24 * 3600) &gt; 0.85</span><br><span class="line"></span><br><span class="line"># 内存压力告警</span><br><span class="line">(node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes &gt; 0.9</span><br></pre></td></tr></table></figure><p><strong>流量容量规划</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 带宽使用预测</span><br><span class="line">predict_linear(rate(node_network_transmit_bytes_total[12h])[7d:], 30 * 24 * 3600)</span><br></pre></td></tr></table></figure><h2 id="四最佳实践与性能优化">四、最佳实践与性能优化</h2><h3 id="指标命名与标签设计">1. 指标命名与标签设计</h3><p><strong>命名规范</strong>：</p><ul><li>使用 snake_case</li><li>包含单位后缀（_bytes, _seconds, _total）</li><li>保持风格一致性</li></ul><p><strong>标签最佳实践</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合理设计标签维度</span></span><br><span class="line">apiLatency := prometheus.NewHistogramVec(</span><br><span class="line">    prometheus.HistogramOpts&#123;</span><br><span class="line">        Name:    <span class="string">&quot;api_request_duration_seconds&quot;</span>,</span><br><span class="line">        Help:    <span class="string">&quot;API request duration in seconds&quot;</span>,</span><br><span class="line">        Buckets: prometheus.ExponentialBuckets(<span class="number">0.001</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;service&quot;</span>, <span class="string">&quot;endpoint&quot;</span>, <span class="string">&quot;status_code&quot;</span>&#125;, <span class="comment">// 合理的低基数标签</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变标签使用ConstLabels</span></span><br><span class="line">prometheus.NewGaugeVec(</span><br><span class="line">    prometheus.GaugeOpts&#123;</span><br><span class="line">        Name:        <span class="string">&quot;service_info&quot;</span>,</span><br><span class="line">        Help:        <span class="string">&quot;Service information&quot;</span>,</span><br><span class="line">        ConstLabels: prometheus.Labels&#123;<span class="string">&quot;version&quot;</span>: <span class="string">&quot;v2.1.3&quot;</span>, <span class="string">&quot;environment&quot;</span>: <span class="string">&quot;production&quot;</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;instance&quot;</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="客户端性能优化">2. 客户端性能优化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存常用标签组合以提高性能</span></span><br><span class="line">getCounter := requestCounter.WithLabelValues(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>, <span class="string">&quot;200&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    getCounter.Inc() <span class="comment">// 重用标签组合，避免重复创建</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量更新方式</span></span><br><span class="line"><span class="keyword">var</span> rpcDurations = prometheus.NewSummaryVec(</span><br><span class="line">    prometheus.SummaryOpts&#123;</span><br><span class="line">        Name:       <span class="string">&quot;rpc_durations_seconds&quot;</span>,</span><br><span class="line">        Help:       <span class="string">&quot;RPC latency distributions.&quot;</span>,</span><br><span class="line">        Objectives: <span class="keyword">map</span>[<span class="type">float64</span>]<span class="type">float64</span>&#123;<span class="number">0.5</span>: <span class="number">0.05</span>, <span class="number">0.9</span>: <span class="number">0.01</span>, <span class="number">0.99</span>: <span class="number">0.001</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;service&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ObserveBatch</span><span class="params">(durations <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> service, duration := <span class="keyword">range</span> durations &#123;</span><br><span class="line">        rpcDurations.WithLabelValues(service).Observe(duration)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询优化">3. 查询优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 优化前：高基数查询</span><br><span class="line">sum(rate(http_requests_total&#123;path=~&quot;/api/.*&quot;&#125;[5m])) by (path, method, status)</span><br><span class="line"></span><br><span class="line"># 优化后：降低基数，按需聚合</span><br><span class="line">sum(rate(http_requests_total&#123;path=~&quot;/api/.*&quot;&#125;[5m])) by (method, status)</span><br><span class="line"></span><br><span class="line"># 优化聚合顺序（先聚合再求和）</span><br><span class="line">sum(</span><br><span class="line">  avg by(instance) (rate(node_cpu_seconds_total&#123;mode!=&quot;idle&quot;&#125;[5m]))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="五常见陷阱与解决方案">五、常见陷阱与解决方案</h2><h3 id="高基数问题">1. 高基数问题</h3><p><strong>问题</strong>：标签组合过多导致时间序列爆炸<strong>解决方案</strong>：</p><ul><li>限制标签基数，避免使用 UserID、SessionID 等作为标签</li><li>使用<code>label_replace</code>和正则表达式转换高基数标签</li><li>考虑使用 Exemplars 而非标签存储高基数数据</li></ul><h3 id="数据类型选择误区">2. 数据类型选择误区</h3><p><strong>Counter vs Gauge</strong>：请求数应使用 Counter 而非 Gauge<strong>Histogram vs Summary</strong>：需要聚合分析请使用Histogram，精确分位数可选 Summary</p><h3 id="查询性能问题">3. 查询性能问题</h3><p><strong>问题</strong>：复杂查询导致 Prometheus 高负载<strong>解决方案</strong>：</p><ul><li>使用记录规则预计算常用查询</li><li>合理设置 scrape 间隔，避免过度采集</li><li>对高请求量接口使用客户端聚合</li></ul><h2 id="总结与展望">总结与展望</h2><p>Prometheus 的四种数据类型各有所长：Counter 适合累积事件计数，Gauge适合瞬时状态测量，Histogram 适合分布统计和百分位分析，Summary适合客户端精确分位数计算。与之配合的 PromQL提供了强大的数据查询和分析能力，共同构成了完整的监控解决方案。</p><p>随着云原生技术的发展，Prometheus 生态也在不断壮大，与Grafana、Alertmanager、Thanos等工具集成，能够构建更完善的监控告警平台。在微服务架构中，结合RED（Rate、Error、Duration）和USE（Utilization、Saturation、Errors）方法论，可以构建全面的可观测性系统。</p><p>无论你是刚开始使用 Prometheus的新手，还是寻求优化监控系统的资深工程师，希望本文对你理解和应用Prometheus有所帮助。记住，好的监控不仅能及时发现问题，更能预测和防范问题，最终服务于业务可靠性和用户体验的提升。</p><hr /><p><em>参考资源:</em></p><ul><li>Prometheus 官方文档: https://prometheus.io/docs/</li><li>Google SRE 书籍:https://sre.google/sre-book/monitoring-distributed-systems/</li><li>Prometheus 实战: https://prometheusbook.com/</li></ul>]]></content>
    
    
    <summary type="html">本文介绍了 Prometheus 的四大数据类型及其 PromQL 查询语言，帮助开发团队构建强大的可观测性系统。</summary>
    
    
    
    <category term="服务监控" scheme="https://hedon.top/categories/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
    
    <category term="prometheus" scheme="https://hedon.top/tags/prometheus/"/>
    
    <category term="服务监控" scheme="https://hedon.top/tags/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨解密 QUIC/HTTP3：未来互联网的基石</title>
    <link href="https://hedon.top/2025/01/15/book-quic-http3/"/>
    <id>https://hedon.top/2025/01/15/book-quic-http3/</id>
    <published>2025-01-15T11:17:20.000Z</published>
    <updated>2025-03-03T11:54:10.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="quic-产生背景">1. QUIC 产生背景</h1><h2 id="常见网络协议">常见网络协议</h2><ul><li><code>UDP</code></li><li><code>TCP</code></li><li><code>SCTP</code>（Stream Control TransmissionProtocol）：用于电话网络。</li><li><code>KCP</code>：基于 UDP在应用层实现可靠性传输，牺牲带宽换取效率。</li><li><code>RTP</code>（Real-time Transport Protocol）：与 RTCP配合传输实时数据，如交互式音频和视频数据。<ul><li>RTCP：传输控制信息</li><li>RTP：传输实时数据</li></ul></li></ul><h2 id="tsl-版本演化">TSL 版本演化</h2><ul><li><p><code>SSLv2</code>：安全性低</p></li><li><p><code>SSLv3</code>：分为握手阶段和数据传输阶段。</p><ul><li>握手阶段完成对端点的认证和确定保护数据传输的密钥。</li><li>一旦确定了密钥，后面的数据传输和SSL协议过程都受到加密和完整性保护。</li></ul></li><li><p><code>TSL1.0</code>：基于 SSLv3，存在 CBC（Cipher BlockChaining，密文分组链接）加密和解密模式漏洞，使得主动攻击者可以观察到当前记录的IV（IntiallizationVector，初始化向量），猜测一个数据库，进行数据注入。</p></li><li><p><code>TSL1.1</code>：修复了 TSL1.0 的一些关键安全问题：</p><ul><li>BC 加密使用每条记录一个的显式IV；</li><li>为了防止 CBC 填充攻击，使用 bad_record_mac 错误码代替decryption_failed 回复填充错误；</li><li>支持传输参数的IANA（Internet Assigned NumbersAuthority，互联网数字分配机构）注册，增加了传输参数的灵活性；</li><li>改进了连接关闭过早情况下的连接恢复问题。</li></ul><p>有些加密算法还是存在安全漏洞，使用的 MD5 也不安全。</p></li><li><p><code>TSL1.2</code>：主要关注了架构灵活性和安全问题。</p><ul><li>架构：<ul><li>客户端可以指定自己支持的签名和 hash 算法列表；</li><li>支持非协议固定的算法；</li></ul></li><li>安全：<ul><li>增加了对 AEAD（Authenticated Encryption with Associated Data关联数据认证加密）的支持，可以在加密中认证没有加密部分的关键数据，甚至是不在报文中的关键数据，可以保护更大的范围。</li><li>规定必须实现密码套件 TLS_RSA_WITH_AES_128_CBC_SHA。</li><li>增加了 HMAC-SHA256 密码套件。</li><li>删除了包含已废弃算法的 IDEA 和 DES 密码套件。</li><li>对 EncryptedPreMasterSecret 版本号进行了更严格的检查。</li></ul></li></ul></li><li><p><code>TSL1.3</code>：除了增加安全性，重点改进了连接速度，首次连接发送数据最低可以1-RTT，恢复连接发送数据最低可以 0-RTT。</p><ul><li>安全：<ul><li>删除了所有被证明有问题的对称加密算法，只保留了 AEAD的加密套件。密码套件的概念也已经改变，将认证和密钥交换机制与加密算法和散列（用于密钥导出函数和握手消息认证码）分离。</li><li>删除 RSA 和静态 DH 密码套件，因为静态 RSA加密预主密钥的方式和使用静态 DH私钥都不能保证前向安全性，很容易泄露密钥。只保留能保证前向安全的密钥交换算法，如使用临时私钥的ECDHE（Elliptic Curve Diffie-Hellman Ephemeral，椭圆曲线 DH临时密钥交换算法）和 DHE（Diffie-Hellman Ephemeral, DH临时密钥交换算法）。</li><li>ServerHello 之后的消息都加密传输。</li><li>删除了压缩功能。之前版本的压缩功能由于存在被攻击的风险实际上很少使用，而且现代的压缩基本都在应用层实现，比如HTTP就自己实现的压缩。</li></ul></li></ul></li></ul><h2 id="http-版本演化">HTTP 版本演化</h2><ul><li><p><code>HTTP0.9</code>：仅支持简单的请求响应，只能访问<strong>简单的文本</strong>文档。</p></li><li><p><code>HTTP1.0</code>：HTTP1中引入了<strong>请求头和响应头</strong>，请求时可以指定 HTTP版本号、用户代理、接收类型等，响应可以指明响应状态、内容长度、内容类型等。</p></li><li><p><code>HTTP1.1</code>：增加了<strong>重用 TCP连接</strong>（keep-alive）的方法，默认保持连接，除非显式通知关闭连接[插图]。这样可以在一个TCP 连接上完成多个请求-响应，消除了 TCP 建立的延迟，也避免了新建立的 TCP连接的慢启动过程。</p><ul><li>HTTP1.1 在 HTTP 请求首部中增加了 Host 字段，用来支持共享 IP地址的虚拟主机服务器。</li><li>同时支持了更多的方法，如 PUT、PATCH、DELETE、OPTIONS。</li><li>引入分块传输支持动态内容。</li><li>引入了更多的缓存控制策略。</li><li>支持请求部分内容。</li></ul></li><li><p><code>HTTP2</code>：修改了 HTTP1.1的封装格式，增加了一个二进制分帧层。基于二进制分层，HTTP2 实现了 HTTP的<strong>多路复用</strong>。HTTP2为每个请求分配了一个流标识，服务器响应时带上相同的流标识，客户端就可以方便地将响应与请求关联起来，而不用依赖顺序，从而可以降低延迟和提高吞吐量。</p><ul><li>HTTP2 还增加了首部压缩 HPACK（Header Compression for HTTP2，HTTP2首部压缩算法）。</li><li>支持请求优先级。</li><li>支持服务器主动推送。</li><li>增加了 ALPN（Application-Layer ProtocolNegotiation，应用层协议协商）。</li><li>支持认证、加密和完整性保护，即 <code>HTTPS</code>。</li></ul><p>但多个请求或响应在同一个 TCP 上发送时，仍然受制于 TCP的队首阻塞问题。</p></li><li><p><code>HTTP3</code>：基于 <code>QUIC</code> 协议，底层使用 UDP实现，摆脱了 TCP 的队首阻塞问题。同时改进了 TCP中存在的一些其他问题，比如拥塞控制、协议僵化、启动慢、重连慢、安全弱等。</p><ul><li>实现了没有队首阻塞的并发。如果 QUIC丢了一个报文，仅仅影响对应流的交付，不会阻塞其他流。</li><li>与 TLS1.3 紧密合作，尽可能的加密。还增加了 QUIC报文的首部加密，除保证了报文安全性，提高了攻击门槛，还避免了协议僵化。</li><li>选择 UDP 作为底层实现。一方面避免了 TCP的首部阻塞，另一方面互联网中绝大部分的主机和中间件都是 TCP 和 UDP的天下，所以天然支持。</li><li>用户态实现。不依赖于内核，容易单独升级。</li><li>低延迟的建立。实现了首次最低 1-RTT发送应用数据，恢复连接时发送应用数据最低只需 0-RTT。</li><li>无缝的连接迁移。QUIC 的连接基于连接标识，改变 IP 或者 UDP端口号并不影响连接的识别，因此可以实现无缝的连接迁移。但是负载均衡就麻烦了。</li><li>改进的流量控制。</li><li>协议行为作为负载。</li></ul></li></ul><h1 id="quic-报文">2. QUIC 报文</h1><ul><li>长首部报文：用于建立 QUIC 连接和建立连接前发送应用数据。</li><li>短首部报文：用于在 QUIC 连接建立后发送应用数据和 QUIC协议内容。</li><li>无状态重置报文：当服务器丢失了连接状态但仍然收到该连接的数据包时，可以发送无状态重置报文通知客户端立即终止连接。</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250122195252117.png"alt="QUIC 报文类型" /><figcaption aria-hidden="true">QUIC 报文类型</figcaption></figure><p>初始报文：客户端使用初始报文来发起连接，服务器使用初始报文和握手报文回应客户端的请求。</p><p>0-RTT 报文：用于承载 QUIC连接之前想要发送的数据，一般用于恢复连接后立即发送数据。</p><p>握手报文：用来携带服务器和客户端的 TLS 加密握手信息和确认，载荷一般是CRYPTO 帧和 ACK 帧。</p><p>重试报文：是服务器用来验证客户端地址的报文，可以防止源地址欺骗。</p><blockquote><p>服务器使用重试报文通知客户端按照要求重新发送初始报文，在重试报文中携带重试令牌给客户端，并使用服务器选择的连接标识作为重试报文的源连接标识；客户端需要使用服务器指定的连接标识作为目的连接标识，携带服务器指定的重试令牌，构建新的初始报文，重新发送给服务器。</p></blockquote><p>版本协商报文：当服务器收到包含自己不支持的版本号的初始报文时，就会发送版本协商报文。客户端收到版本协商报文后需要在其中选择一个自己支持的版本号，重新以新版本号发送初始报文。</p><p>短首部报文：一般也叫作 1-RTT 报文，连接在协商出 1-RTT密钥后就可以发送短首部报文，用于携带应用数据。</p>]]></content>
    
    
    <summary type="html">整理阅读《解密 QUIC/HTTP3：未来互联网的基石》笔记。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="QUIC" scheme="https://hedon.top/tags/QUIC/"/>
    
    <category term="HTTP3" scheme="https://hedon.top/tags/HTTP3/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>匠心码道丨01 编写优质代码的十大黄金法则</title>
    <link href="https://hedon.top/2024/12/12/clean-code-10-rules/"/>
    <id>https://hedon.top/2024/12/12/clean-code-10-rules/</id>
    <published>2024-12-12T02:22:49.000Z</published>
    <updated>2025-03-03T11:54:14.961Z</updated>
    
    <content type="html"><![CDATA[<p>代码质量的优劣直接影响着项目的可维护性和团队的开发效率。一个经验丰富的开发者不仅要能实现功能，更要善于编写清晰易懂、结构合理的代码。本文将介绍10 条帮助你编写清晰、易维护且可扩展代码的重要规则。</p><h1 id="规则">规则</h1><h2 id="使用有意义的变量和函数名称">1. 使用有意义的变量和函数名称</h2><p>变量、函数和类的命名应该具有描述性和意义。你的代码应该能够清晰地表达其意图，而无需额外的注释来解释。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> api.<span class="title function_">get</span>();</span><br><span class="line"><span class="keyword">const</span> arr = users.<span class="title function_">filter</span>(<span class="function"><span class="params">u</span> =&gt;</span> u.<span class="property">a</span> === <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxRetries = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> currentDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> userResponse = <span class="keyword">await</span> api.<span class="title function_">getUserProfile</span>();</span><br><span class="line"><span class="keyword">const</span> activeUsers = users.<span class="title function_">filter</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">isActive</span> === <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p>有意义的命名能讲述代码的故事。读者应该能够仅通过名称就理解变量或函数的用途。</p><p>💡实践建议：</p><ul><li>使用动词前缀命名函数：<code>getUserProfile()</code>、<code>validateInput()</code>、<code>calculateTotal()</code></li><li>使用名词命名变量：<code>userCount</code>、<code>activeUsers</code>、<code>orderStatus</code></li><li>布尔值使用 is/has/should等前缀：<code>isValid</code>、<code>hasPermission</code>、<code>shouldUpdate</code></li></ul><h2 id="保持函数简短且专注">2. 保持函数简短且专注</h2><p>函数应该保持简短，并且只做一件事。函数承担的责任越多，测试、调试和理解起来就越困难。</p><p><strong>反面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_order</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="comment"># 多个责任：验证、定价、折扣、配送等</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">validate_order</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_total</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_discount</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>每个函数应该只有一个责任。如果你需要用"和"来描述函数的功能，那么这个函数可能做得太多了。</p><p>💡 最佳实践：</p><ul><li>函数建议保持在 20-30 行以内</li><li>如果超过 50 行，应该考虑拆分</li><li>一个函数最好不要超过 3 个参数</li></ul><h2 id="避免深层嵌套">3. 避免深层嵌套</h2><p>深层嵌套的循环和条件语句会使代码难以理解。通过使用提前返回、函数拆分或将大问题分解为小问题来使代码扁平化。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (user.<span class="title function_">isActive</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (order != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="title function_">processOrder</span>(order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span> || !user.<span class="title function_">isActive</span>()) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (order == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="title function_">processOrder</span>(order);</span><br></pre></td></tr></table></figure></p><p>提前返回可以减少读者的认知负担，使代码更简单、更容易理解。</p><h2 id="明智地使用注释">4. 明智地使用注释</h2><p>注释不应该解释代码做了什么；代码本身应该是自解释的。只在必要时使用注释来解释复杂逻辑背后的"原因"，而不是"是什么"。</p><p><strong>反面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置用户状态为激活</span></span><br><span class="line"><span class="variable">$user</span>-&gt;isActive = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录成功后将用户标记为激活状态</span></span><br><span class="line"><span class="variable">$user</span>-&gt;isActive = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>注释应该增加价值，解释特定实现背后的原因或解释复杂的业务逻辑。</p><h2 id="保持一致的格式">5. 保持一致的格式</h2><p>一致的代码格式使代码更容易阅读和导航。在项目中使用统一的缩进、间距和对齐方式。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a+b;&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>许多团队使用 Prettier 或 ESLint等工具来自动格式化并强制执行代码风格规则。</p><h2 id="不要重复自己dry-原则">6. 不要重复自己（DRY 原则）</h2><p>代码重复会导致不一致、bug 和不必要的复杂性。应用 DRY原则可以保持代码库精简，更易于维护。</p><p><strong>反面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$userType</span> == <span class="string">&quot;admin&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 复杂逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$userType</span> == <span class="string">&quot;superadmin&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 相同的复杂逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">userIsAdmin</span>(<span class="variable">$userType</span>)) &#123;</span><br><span class="line">    <span class="comment">// 复杂逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过将共同逻辑抽象到函数、类或工具中来避免代码重复。</p><h2 id="单一责任原则srp">7. 单一责任原则（SRP）</h2><p>每个类和函数应该只有一个改变的理由。遵循单一责任原则使代码模块化，更容易重构。</p><p><strong>反面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>承担太多责任的类更难维护。SRP 使代码更模块化，更容易测试。</p><h2 id="避免魔法数字和字符串">8. 避免魔法数字和字符串</h2><p>魔法数字（或字符串）是没有上下文或解释的硬编码值。使用常量或枚举代替，这样可以增加代码的清晰度。</p><p><strong>反面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">discount = <span class="number">0.05</span></span><br><span class="line"><span class="keyword">if</span> user.role == <span class="string">&quot;admin&quot;</span>:</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DISCOUNT_RATE = <span class="number">0.05</span></span><br><span class="line">ADMIN_ROLE = <span class="string">&quot;admin&quot;</span></span><br><span class="line">discount = DISCOUNT_RATE</span><br><span class="line"><span class="keyword">if</span> user.role == ADMIN_ROLE:</span><br></pre></td></tr></table></figure></p><p>常量为数字或字符串提供了含义，使代码更容易理解。</p><h2 id="编写测试">9. 编写测试</h2><p>单元测试和集成测试确保你的代码按预期工作，并且在进行更改时不会出错。编写测试使代码更可靠，长期更易于维护。</p><p><strong>反面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法没有测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// 逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProcessOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    <span class="comment">// 断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试应该成为你工作流程的一部分，确保代码无 BUG 且稳定。</p><h2 id="保持简单kiss-原则">10. 保持简单（KISS 原则）</h2><p>KISS（Keep It Simple,Stupid）原则提醒我们简单是关键。复杂的解决方案会导致混淆，更难维护。在面对决策时，选择最简单、最直接的方案来满足需求。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过度复杂的购物车商品总价计算</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateTotal</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> discount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复杂的折扣计算逻辑</span></span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;electronics&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.<span class="property">price</span> &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                discount += item.<span class="property">price</span> * <span class="number">0.1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">price</span> &gt; <span class="number">500</span>) &#123;</span><br><span class="line">                discount += item.<span class="property">price</span> * <span class="number">0.05</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;books&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.<span class="property">quantity</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                discount += item.<span class="property">price</span> * item.<span class="property">quantity</span> * <span class="number">0.15</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        total += item.<span class="property">price</span> * item.<span class="property">quantity</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total - discount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将复杂逻辑拆分成小函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateDiscount</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;electronics&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item.<span class="property">price</span> &gt; <span class="number">1000</span> ? <span class="number">0.1</span> : (item.<span class="property">price</span> &gt; <span class="number">500</span> ? <span class="number">0.05</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;books&#x27;</span> &amp;&amp; item.<span class="property">quantity</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateTotal</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> discount = <span class="title function_">calculateDiscount</span>(item);</span><br><span class="line">        <span class="keyword">const</span> itemTotal = item.<span class="property">price</span> * item.<span class="property">quantity</span>;</span><br><span class="line">        <span class="keyword">return</span> total + itemTotal * (<span class="number">1</span> - discount);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>💡 最佳实践：</p><ul><li>将复杂逻辑拆分成小的、容易理解的函数</li><li>避免在一个函数中处理过多的条件判断</li><li>使用清晰的命名来表达意图</li><li>保持函数的单一职责</li></ul><h1 id="总结">总结</h1><p>干净的代码对于可维护性、可读性和协作至关重要。遵循这 10条规则——使用有意义的命名、保持函数简短、避免魔法数字、编写测试等，将会带来更健壮、更易理解和更易扩展的代码库。编写代码不仅仅是要让它能工作，更要让其他人（包括未来的你）能够轻松理解和扩展。</p><h1 id="代码审查清单">代码审查清单</h1><p>在提交代码前，可以使用以下清单进行自查：</p><ul class="task-list"><li><label><inputtype="checkbox" />变量和函数名称是否具有描述性</label></li><li><label><input type="checkbox" />函数是否只做一件事</label></li><li><label><input type="checkbox" />是否存在重复代码</label></li><li><label><input type="checkbox" />是否有未使用的魔法数字</label></li><li><label><input type="checkbox" />是否编写了相应的测试</label></li><li><label><input type="checkbox" />代码格式是否统一</label></li><li><label><input type="checkbox" />注释是否有价值</label></li><li><label><input type="checkbox" />嵌套是否过深</label></li></ul><h1 id="参考">参考</h1><ul><li><ahref="https://www.thecodingdev.com/2024/09/top-10-clean-code-rules-every-developer.html?ref=dailydev">top-10-clean-code-rules-every-developer-should-follow</a></li></ul>]]></content>
    
    
    <summary type="html">详解编写整洁代码的十大原则，帮你写出更好的代码。</summary>
    
    
    
    <category term="匠心码道" scheme="https://hedon.top/categories/%E5%8C%A0%E5%BF%83%E7%A0%81%E9%81%93/"/>
    
    
    <category term="编程规范" scheme="https://hedon.top/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
    <category term="代码质量" scheme="https://hedon.top/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
    <category term="最佳实践" scheme="https://hedon.top/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>KCP 源码分析与原理总结</title>
    <link href="https://hedon.top/2024/12/01/kcp/"/>
    <id>https://hedon.top/2024/12/01/kcp/</id>
    <published>2024-12-01T02:08:02.000Z</published>
    <updated>2025-03-03T11:31:37.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>本文很大部分参考了 <ahref="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP协议的原理和实现</a>，非常感谢该文作者的讲解。本文再此基础上，加入了一些笔者的思考和分析图示，以期更好地理解KCP 的底层原理。</p><h1 id="结论先行">结论先行</h1><p>KCP 是一个快速可靠协议，能以比 TCP 浪费 10%-20%的带宽的代价，换取平均延迟降低30%-40%，且最大延迟降低三倍的传输效果。</p><p>TCP 是为流量设计的（每秒内可以传输多少 KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以 10%-20%带宽浪费的代价换取了比 TCP 快 30%-40% 的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而 KCP是水流湍急的小激流。</p><h2 id="kcp-增加的带宽在哪里增加的速度又在哪里">KCP增加的带宽在哪里？增加的速度又在哪里？</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612111337839.png"alt="为什么 KCP 能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%？" /><figcaption aria-hidden="true">为什么 KCP 能以比 TCP 浪费 10%-20%的带宽的代价，换取平均延迟降低 30%-40%？</figcaption></figure><h2 id="kcp-核心特性">KCP 核心特性</h2><p><strong>快速重传</strong>： KCP 支持快速重传机制，不像 TCP那样依赖超时重传。KCP可以根据接收方返回的确认信息快速判断哪些数据包已经丢失，并迅速进行重传。</p><p><strong>选择性确认（Selective Acknowledgment, SACK）</strong>： KCP支持SACK，这允许接收端告知发送端哪些包已经收到，从而仅重传未被确认接收的数据包，减少不必要的重传。</p><p><strong>无连接操作</strong>： 基于 UDP 的实现使得 KCP在传输数据前不需要像 TCP那样进行三次握手建立连接，这减少了初始的延迟，并使其能在连接性较差的网络环境下更加灵活和快速。</p><p><strong>拥塞控制</strong>： KCP 实现了类似 TCP的拥塞控制算法，但更为简化，能够快速适应网络条件的变化，如带宽波动和丢包。</p><p><strong>流量控制</strong>： KCP允许调整发送和接收的窗口大小，使得发送方可以根据接收方的处理能力和网络条件调整数据发送速率，优化网络利用率和减少拥塞。</p><p><strong>可配置的传输策略</strong>： KCP允许用户根据应用需求调整内部参数，如传输间隔、窗口大小等，以达到最优的传输效率和延迟。</p><p><strong>前向错误校正（Forward Error Correction, FEC）</strong>： KCP还可以结合使用 FEC技术，通过发送额外的冗余数据来恢复丢失的包，进一步提高在高丢包环境下的数据传输可靠性。</p><h2 id="为什么-tcp-做不到-kcp-这样">为什么 TCP 做不到 KCP 这样？</h2><p>TCP作为一种成熟且广泛使用的传输协议，在设计上注重可靠性和通用性，因此在拥塞控制和流量控制方面相对保守，以确保在各种网络条件下都能稳定运行。然而，这些设计上的保守性也导致了TCP 在某些情况下的灵活性和自适应性不如 KCP。</p><table><colgroup><col style="width: 16%" /><col style="width: 4%" /><col style="width: 79%" /></colgroup><thead><tr class="header"><th>特性类别</th><th>协议</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>拥塞控制机制</td><td>TCP</td><td>固定算法（慢启动、拥塞避免等），保守的调整策略（指数和线性增长）</td></tr><tr class="even"><td></td><td>KCP</td><td>灵活算法，动态调整策略，快速调整窗口大小</td></tr><tr class="odd"><td>重传机制的延迟</td><td>TCP</td><td>固定重传间隔（RTO），多次确认触发重传，需要主动开启选择性重传（SACK）</td></tr><tr class="even"><td></td><td>KCP</td><td>快速重传，选择性重传，减少重传延迟</td></tr><tr class="odd"><td>流量控制</td><td>TCP</td><td>固定流量控制（依赖接收窗口和发送窗口），通用性设计</td></tr><tr class="even"><td></td><td>KCP</td><td>自适应流量控制，应用层反馈调整发送窗口和重传策略</td></tr><tr class="odd"><td>应用场景</td><td>TCP</td><td>广泛应用于各种网络环境，标准化要求高</td></tr><tr class="even"><td></td><td>KCP</td><td>优化特定场景（如高丢包率和高延迟网络），灵活实现</td></tr></tbody></table><h3 id="拥塞控制机制的固定性">1. 拥塞控制机制的固定性</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定算法</strong>：TCP 的拥塞控制算法，如慢启动（SlowStart）、拥塞避免（Congestion Avoidance）、快速重传（FastRetransmit）和快速恢复（FastRecovery），在设计时考虑了广泛的兼容性和可靠性。这些算法虽然有效，但其调整机制相对固定，响应速度较慢。</li><li><strong>保守的调整策略</strong>：TCP的拥塞控制算法采用了保守的调整策略，例如指数增长和线性增长，这在高丢包率或高延迟网络中，可能会导致拥塞窗口（cwnd）增长速度较慢，影响传输效率。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>灵活算法</strong>：KCP的拥塞控制机制更为灵活，可以根据实时网络状况进行快速调整。例如，KCP的快速重传和选择性重传机制，使其能更快速地响应网络丢包情况。</li><li><strong>动态调整策略</strong>：KCP的拥塞窗口调整更为灵活，可以根据网络状况快速增加或减少窗口大小，提高传输效率。</li></ul><h3 id="重传机制的延迟">2. 重传机制的延迟</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定重传间隔</strong>：TCP使用固定的重传超时（RTO），并随着每次重传逐渐增加（指数回退），这种保守的重传机制在高延迟和高丢包率网络中可能导致重传延迟较长。</li><li><strong>多次确认触发重传</strong>：TCP 的快速重传需要等待三个重复的ACK 才能触发，这在丢包率较高的情况下，可能会导致较长的延迟。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>快速重传</strong>：KCP在检测到丢包后立即进行重传，而不需要等待多个重复的ACK，这显著减少了重传延迟。</li><li><strong>选择性重传</strong>：KCP只重传丢失的数据包，而不是所有未确认的数据包，减少了不必要的重传开销。（TCP其实也支持选择性重传 SACK）</li></ul><h3 id="流量控制的灵活性">3. 流量控制的灵活性</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定流量控制</strong>：TCP的流量控制主要依赖于接收窗口（rwnd）和发送窗口（swnd），在处理突发流量或变化较大的网络条件时，调整速度较慢。</li><li><strong>通用性设计</strong>：TCP作为一种通用协议，其设计必须兼顾各种网络环境，因此在流量控制上相对保守，以确保在任何环境下都能稳定运行。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>自适应流量控制</strong>：KCP的流量控制机制可以根据实际应用需求进行更细粒度的调整。例如，KCP可以根据延迟抖动、丢包率等动态参数调整发送速率，确保在不同网络条件下都能保持高效传输。</li><li><strong>应用层反馈</strong>：KCP可以根据应用层的实时反馈，动态调整发送窗口和重传策略，进一步优化传输效率。</li></ul><h3 id="应用场景的差异">4. 应用场景的差异</h3><p><strong>TCP</strong>：</p><ul><li><strong>广泛应用</strong>：TCP设计用于广泛的网络环境，包括稳定的有线网络和不稳定的无线网络，因此其机制必须足够通用和保守，保证在各种情况下的可靠性。</li><li><strong>标准化要求</strong>：作为互联网的基础协议，TCP的各项机制经过严格标准化，任何修改都需要广泛测试和验证，以确保不会影响现有网络的稳定性。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>特定优化</strong>：KCP设计初衷是优化特定场景下的传输性能，特别是高丢包率和高延迟网络，因此在设计上更加灵活，能够根据实时网络状况进行调整。</li><li><strong>灵活实现</strong>：KCP可以根据具体应用需求进行优化，例如在实时通信和在线游戏等场景中，灵活的流量控制和快速重传机制显著提升了传输效率。</li></ul><h3 id="结论">结论</h3><p>虽然 TCP在拥塞控制和流量控制方面具备基本的动态调整能力，但其保守的设计和标准化要求使得其在高丢包率和高延迟网络中的适应性和灵活性不如KCP。KCP通过灵活的拥塞控制、快速重传和自适应流量控制机制，能够更有效地应对不同网络条件下的传输需求，提供更高效的传输性能。</p><h2 id="kcp-一定比-tcp-快吗">KCP 一定比 TCP 快吗？</h2><p><font color="red">不一定</font>。KCP 并不一定在所有情况下都比 TCP快。虽然 KCP在某些特定网络环境（如高丢包率和高延迟的网络）中表现更优异，但在某些情况下，TCP可能更合适。</p><h3 id="网络环境">1. 网络环境</h3><p><strong>高丢包率和高延迟网络</strong>：</p><ul><li><strong>KCP</strong>：KCP通过快速重传和选择性重传机制，以及动态调整的窗口和重传间隔，能够更好地应对高丢包率和高延迟网络，减少传输延迟，提高传输效率。</li><li><strong>TCP</strong>：TCP的重传机制和保守的拥塞控制在这种环境中可能导致较高的延迟和较低的带宽利用率。</li></ul><p><strong>低丢包率和低延迟网络</strong>：</p><ul><li><strong>KCP</strong>：在稳定的低丢包率和低延迟网络中，KCP的频繁重传和控制报文可能会导致额外的带宽开销，未必有明显的性能优势。</li><li><strong>TCP</strong>：TCP在这种环境中表现稳定，且由于其带宽开销较小，可能比 KCP 更高效。</li></ul><h3 id="带宽利用率">2. 带宽利用率</h3><p><strong>带宽充足的网络</strong>：</p><ul><li><strong>KCP</strong>：KCP由于其频繁的重传和控制报文，可能会占用更多的带宽，但如果带宽充足，这种开销对整体性能影响较小，且其低延迟优势可能更明显。</li><li><strong>TCP</strong>：TCP的带宽利用率较高，适合带宽充足的环境。</li></ul><p><strong>带宽受限的网络</strong>：</p><ul><li><strong>KCP</strong>：KCP的额外带宽开销在带宽受限的网络中可能会显著影响整体传输效率。</li><li><strong>TCP</strong>：TCP的较低带宽开销使其在带宽受限的环境中更有优势。</li></ul><h3 id="应用场景">3. 应用场景</h3><p><strong>实时应用</strong>（如在线游戏、视频会议）：</p><ul><li><strong>KCP</strong>：KCP的低延迟和快速响应能力使其非常适合实时应用，在这些场景中，传输的及时性比带宽利用率更重要。</li><li><strong>TCP</strong>：TCP 在这些场景中的表现可能不如KCP，特别是在高丢包率和高延迟的网络中。</li></ul><p><strong>非实时应用</strong>（如文件传输、网页浏览）：</p><ul><li><strong>KCP</strong>：KCP 在这些场景中可能不如 TCP高效，特别是在网络稳定且带宽有限的情况下。</li><li><strong>TCP</strong>：TCP的可靠性和高带宽利用率使其非常适合非实时应用。</li></ul><h3 id="实现和配置">4. 实现和配置</h3><p><strong>实现复杂性</strong>：</p><ul><li><strong>KCP</strong>：实现和配置 KCP 可能比 TCP更复杂，需要根据具体应用和网络环境进行优化和调整。</li><li><strong>TCP</strong>：TCP是一个成熟的协议，系统和库的支持较好，配置和使用相对简单。</li></ul><h3 id="总结">总结</h3><p>KCP 在某些特定环境和应用场景中确实比 TCP更快，尤其是高丢包率和高延迟的网络环境，以及对低延迟要求较高的实时应用。但在网络稳定、带宽有限或非实时应用场景中，TCP可能表现更好。因此，选择使用 KCP 还是 TCP应根据具体的网络条件和应用需求进行权衡。</p><h1 id="前置准备">前置准备</h1><p>笔者不想那么快就贴出大段大段的代码进行分析，这可能会使读者不知所云。为了更好地阐述KCP的底层原理，笔者的设想是先对原理部分进行概要总结，然后再带着这些结论去分析源码，进一步填充里面的边角细节。</p><p>但是呢，为了更好地理解 KCP的原理，又不得不对涉及源码的一些重要设计，为了避免在原理分析阶段，对源码进行过多的涉及，笔者决定添加这单独的一章内容，对KCP 的“接口设计”、“报文段”、“KCP控制块”以及“队列和缓冲区”先进行简要概述，以辅助读者更好地理解后续的内容。</p><h2 id="接口设计">接口设计</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612171839051.png"alt="KCP 工作简约图" /><figcaption aria-hidden="true">KCP 工作简约图</figcaption></figure><p>在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h">kcp.h</a>文件中，定义了 KCP 最核心的几个接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 KCP 控制对象</span></span><br><span class="line">ikcpcb* <span class="title function_">ikcp_create</span><span class="params">(IUINT32 conv, <span class="type">void</span> *user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放一个 KCP 控制对象。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_release</span><span class="params">(ikcpcb *kcp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 KCP 的输出回调函数，这个回调函数在 KCP 需要发送数据时被调用。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_setoutput</span><span class="params">(ikcpcb *kcp, <span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">ikcpcb *kcp, <span class="type">void</span> *user))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 KCP 的接收队列中接收数据，用于上层从 KCP 中读取数据。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_recv</span><span class="params">(ikcpcb *kcp, <span class="type">char</span> *buffer, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 KCP 的发送队列中添加数据，用于上层向 KCP 发送数据，KCP 会管理这些数据并负责其可靠传输。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_send</span><span class="params">(ikcpcb *kcp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 KCP 的内部状态，通常需要定期调用。</span></span><br><span class="line"><span class="comment">// 这个函数负责处理 KCP 的超时、重传等操作，需要在一定的时间间隔内反复调用（通常每 10-100 毫秒）。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_update</span><span class="params">(ikcpcb *kcp, IUINT32 current)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否要调用 ikcp_update</span></span><br><span class="line">IUINT32 <span class="title function_">ikcp_check</span><span class="params">(<span class="type">const</span> ikcpcb *kcp, IUINT32 current)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收到的低层数据包（例如 UDP 包）。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_input</span><span class="params">(ikcpcb *kcp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">long</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将缓冲区可以发送的包发送出去，会在 ikcp_update 中被调用。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_flush</span><span class="params">(ikcpcb *kcp)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>ikcp_create</code>:</p><ul><li><code>conv</code>:会话标识符，用于标识两个端点之间的连接。这个标识符在两个通信端点之间必须一致。</li><li><code>user</code>: 用户数据指针，可以传递任意用户数据，这个数据在KCP 的 <code>output</code> 回调中会被传递回去。</li><li><strong>返回值</strong>: 一个指向新创建的 KCP控制块（<code>ikcpcb</code>）的指针。</li></ul></li><li><p><code>ikcp_release</code>: 释放一个 KCP 控制对象。</p></li><li><p><code>ikcp_setoutput</code>: 设置 KCP 的输出回调函数。</p><ul><li><p><code>output</code>: 输出回调函数指针。这个回调函数在 KCP需要发送数据时被调用。</p><ul><li><code>buf</code>: 要发送的数据缓冲区。</li><li><code>len</code>: 数据长度。</li><li><code>kcp</code>: 当前的 KCP 对象。</li><li><code>user</code>: 用户数据。</li></ul><p>通过这个回调，KCP 可以将要发送的数据传递给下层的网络层，比如 UDP套接字。</p></li></ul></li><li><p><code>ikcp_recv</code>: 从 KCP 的接收队列中接收数据。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>buffer</code>: 用户提供的缓冲区，用于存储接收到的数据。</li><li><code>len</code>: 缓冲区的长度。</li><li><strong>返回值</strong>:成功接收的数据大小；如果没有数据可接收，返回负值（例如，EAGAIN）。</li></ul><p>这个函数用于上层从 KCP 中读取数据。</p></li><li><p><code>ikcp_send</code>: 向 KCP 的发送队列中添加数据。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>buffer</code>: 要发送的数据缓冲区。</li><li><code>len</code>: 数据的长度。</li><li><strong>返回值</strong>:成功发送的数据大小；如果发送失败，返回负值。</li></ul><p>这个函数用于上层向 KCP 发送数据，KCP会管理这些数据并负责其可靠传输。</p></li><li><p><code>ikcp_update</code>: 更新 KCP的内部状态，通常需要定期调用。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>current</code>: 当前的时间戳（以毫秒为单位）。</li></ul><p>这个函数负责处理 KCP的超时、重传等操作，需要在一定的时间间隔内反复调用（通常每 10-100毫秒）。</p></li><li><p><code>ikcp_input</code>: 处理接收到的低层数据包（例如 UDP包）。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>data</code>: 收到的数据缓冲区。</li><li><code>size</code>: 数据的长度。</li><li><strong>返回值</strong>:成功处理的数据大小；如果处理失败，返回负值。</li></ul></li><li><p><code>ikcp_flush</code>: 刷新待发送的数据。</p></li></ul><p>其中最重要的是这 4 个：</p><ul><li><code>ikcp_send</code>: 将数据放在发送队列中等待发送。</li><li><code>ikcp_recv</code>: 从接收队列中读取数据。</li><li><code>ikcp_input</code>:读取下层协议输入数据，解析报文段，如果是数据，就将数据放入接收缓冲区，如果是ACK，就在发送缓冲区中标记对应的报文段已送达。</li><li><code>ikcp_flush</code>:调用输出回调将发送缓冲区的数据发送出去。</li></ul><p>这里就先简要介绍到这里，后面在源码分析篇章再对这些接口进行详细分析。</p><h2 id="报文段">报文段</h2><p>KCP 的报文段大小为 24 字节，结构如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612172557464.png" alt="KCP 报文段" style="zoom: 33%;" /></p><p>每个字段的含义如下：</p><ul><li><code>conv</code>: 连接标识</li><li><code>cmd</code>：报文类型</li><li><code>frg</code>：分片数量，表示随后还有多少个报文属于同一个包</li><li><code>wnd</code>：发送方剩余接收窗口的大小</li><li><code>ts</code>：时间戳</li><li><code>sn</code>：报文编号</li><li><code>una</code>：发送方的接收缓冲区中最小还未收到的报文段的编号，也就是说，比它小的报文段都已全部接收</li><li><code>len</code>：数据段长度</li><li><code>data</code>：数据段，只有数据报文会有这个字段</li></ul><p>其中 <code>cmd</code> 共有 4 种报文类型：</p><ul><li>数据报文：IKCP_CMD_PUSH</li><li>确认报文：IKCP_CMD_ACK</li><li>窗口探测报文：IKCP_CMD_WASK 询问对端剩余接收窗口的大小</li><li>窗口通知报文：IKCP_CMD_WINS 通知对端剩余接收窗口的大小</li></ul><p>在 KCP 中，报文段结构定义在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h">kcp.h</a>文件中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPSEG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">node</span>;</span></span><br><span class="line">IUINT32 conv;</span><br><span class="line">IUINT32 cmd;</span><br><span class="line">IUINT32 frg;</span><br><span class="line">IUINT32 wnd;</span><br><span class="line">IUINT32 ts;</span><br><span class="line">IUINT32 sn;</span><br><span class="line">IUINT32 una;</span><br><span class="line">IUINT32 len;</span><br><span class="line">IUINT32 resendts;</span><br><span class="line">IUINT32 rto;</span><br><span class="line">IUINT32 fastack;</span><br><span class="line">IUINT32 xmit;</span><br><span class="line"><span class="type">char</span> data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>IKCPSEG</code> 结构还多出了几个字段，这是为了支持 KCP协议的可靠性和效率：</p><ul><li><code>resendts</code>:记录报文的下次重传时间，用于实现重传机制。如果报文在一定时间内没有被确认收到，就会在这个时间戳之后被重新发送。</li><li><code>rto</code>: 表示当前报文的重传超时时间（RTT的估计值）。用于计算每个报文的重传时间，如果超过 <code>rto</code>时间没有收到 ACK，会触发重传。</li><li><code>fastack</code>:快速重传计数，记录该报文被跳过的次数。如果一个报文的 ACK连续接收到多个对同一报文的确认，而不是新的报文，会增加这个计数，用于实现快速重传机制。</li><li><code>xmit</code>:记录报文已经被发送的次数。用于统计一个报文的重传次数，帮助判断传输的可靠性。如果操作<code>dead_link</code> 次，则会判断为连接失效，KCP 会断开连接。</li><li><code>node</code>: 链表节点，用于将多个 <code>IKCPSEG</code>结构体链接在一起。KCP 的队列和缓冲区都是循环双链表结构。</li></ul><p>这些字段共同作用，帮助 KCP 实现以下功能：</p><ul><li><strong>可靠性</strong>：通过 <code>sn</code>、<code>una</code> 和<code>ack</code> 确保数据包按顺序接收和重传。</li><li><strong>流量控制</strong>：通过 <code>wnd</code>控制数据流量，避免接收方过载。</li><li><strong>高效传输</strong>：通过 <code>resendts</code> 和<code>rto</code> 进行超时和重传控制，<code>fastack</code>提供快速重传机制。</li><li><strong>灵活管理</strong>：使用链表节点 <code>node</code>组织数据，便于内部管理。</li></ul><h2 id="kcp-控制块-ikcpcb">KCP 控制块 ikcpcb</h2><p>上面我们提到的 <code>ikcp_create</code> 和 <code>ikcp_release</code>就是对 KCP 控制块 <code>ikcpcb</code> 的创建和释放，每个 KCP连接都对应一个 KCP 控制块。它定义在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h#L343">kcp.h</a>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPCB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">IUINT32 conv, mtu, mss, state;</span><br><span class="line">IUINT32 snd_una, snd_nxt, rcv_nxt;</span><br><span class="line">IUINT32 ts_recent, ts_lastack, ssthresh;</span><br><span class="line">IINT32 rx_rttval, rx_srtt, rx_rto, rx_minrto;</span><br><span class="line">IUINT32 snd_wnd, rcv_wnd, rmt_wnd, cwnd, probe;</span><br><span class="line">IUINT32 current, interval, ts_flush, xmit;</span><br><span class="line">IUINT32 nrcv_buf, nsnd_buf;</span><br><span class="line">IUINT32 nrcv_que, nsnd_que;</span><br><span class="line">IUINT32 nodelay, updated;</span><br><span class="line">IUINT32 ts_probe, probe_wait;</span><br><span class="line">IUINT32 dead_link, incr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_buf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_buf</span>;</span></span><br><span class="line">IUINT32 *acklist;</span><br><span class="line">IUINT32 ackcount;</span><br><span class="line">IUINT32 ackblock;</span><br><span class="line"><span class="type">void</span> *user;</span><br><span class="line"><span class="type">char</span> *buffer;</span><br><span class="line"><span class="type">int</span> fastresend;</span><br><span class="line"><span class="type">int</span> fastlimit;</span><br><span class="line"><span class="type">int</span> nocwnd, stream;</span><br><span class="line"><span class="type">int</span> logmask;</span><br><span class="line"><span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line"><span class="type">void</span> (*writelog)(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">log</span>, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字段的含义如下，读者可在后续分析过程回过来查阅：</p><table><colgroup><col style="width: 13%" /><col style="width: 86%" /></colgroup><thead><tr class="header"><th>字段名</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>conv</code></td><td>连接标识符，用于识别一个特定的会话。</td></tr><tr class="even"><td><code>mtu</code></td><td>最大传输单元（Maximum TransmissionUnit），表示网络层传输数据包的最大字节数。</td></tr><tr class="odd"><td><code>mss</code></td><td>最大报文段长度（Maximum SegmentSize），表示应用层传输数据的最大字节数。</td></tr><tr class="even"><td><code>state</code></td><td>连接状态，标识当前的传输状态。</td></tr><tr class="odd"><td><code>snd_una</code></td><td>未确认的发送序号，表示最早未确认的包的序号。</td></tr><tr class="even"><td><code>snd_nxt</code></td><td>下一个发送序号，表示即将发送的包的序号。</td></tr><tr class="odd"><td><code>rcv_nxt</code></td><td>下一个接收序号，表示期望接收的下一个包的序号。</td></tr><tr class="even"><td><code>ts_recent</code></td><td>最近的时间戳，用于延迟测量。</td></tr><tr class="odd"><td><code>ts_lastack</code></td><td>最近的确认时间戳，用于 RTT 计算。</td></tr><tr class="even"><td><code>ssthresh</code></td><td>拥塞避免的慢启动阈值。</td></tr><tr class="odd"><td><code>rx_rttval</code></td><td>RTT 的偏差，用于计算 RTT 的波动。</td></tr><tr class="even"><td><code>rx_srtt</code></td><td>平滑的 RTT 值，用于计算平均 RTT。</td></tr><tr class="odd"><td><code>rx_rto</code></td><td>重新传输超时时间，根据 RTT 动态调整。</td></tr><tr class="even"><td><code>rx_minrto</code></td><td>最小的重新传输超时时间。</td></tr><tr class="odd"><td><code>snd_wnd</code></td><td>发送窗口大小，控制发送流量的窗口。</td></tr><tr class="even"><td><code>rcv_wnd</code></td><td>接收窗口大小，控制接收流量的窗口。</td></tr><tr class="odd"><td><code>rmt_wnd</code></td><td>远端窗口大小，表示对方接收窗口的大小。</td></tr><tr class="even"><td><code>cwnd</code></td><td>拥塞窗口大小，控制发送流量的窗口，用于拥塞控制。</td></tr><tr class="odd"><td><code>probe</code></td><td>探测标志，表示是否需要进行窗口探测。</td></tr><tr class="even"><td><code>current</code></td><td>当前的时间戳。</td></tr><tr class="odd"><td><code>interval</code></td><td>刷新间隔时间，表示定期刷新 KCP 状态的间隔。</td></tr><tr class="even"><td><code>ts_flush</code></td><td>下次刷新时间戳，用于确定何时执行下一次状态刷新。</td></tr><tr class="odd"><td><code>xmit</code></td><td>发送次数，表示数据包重传的次数。</td></tr><tr class="even"><td><code>nrcv_buf</code></td><td>接收缓冲区的数据包数量。</td></tr><tr class="odd"><td><code>nsnd_buf</code></td><td>发送缓冲区的数据包数量。</td></tr><tr class="even"><td><code>nrcv_que</code></td><td>接收队列中的数据包数量。</td></tr><tr class="odd"><td><code>nsnd_que</code></td><td>发送队列中的数据包数量。</td></tr><tr class="even"><td><code>nodelay</code></td><td>延迟模式标志，表示是否启用无延迟模式。</td></tr><tr class="odd"><td><code>updated</code></td><td>更新标志，表示是否需要更新 KCP 状态。</td></tr><tr class="even"><td><code>ts_probe</code></td><td>下次探测时间戳，用于窗口探测。</td></tr><tr class="odd"><td><code>probe_wait</code></td><td>探测等待时间，表示等待多长时间后进行下一次窗口探测。</td></tr><tr class="even"><td><code>dead_link</code></td><td>死链标志，表示连接是否已经失效。</td></tr><tr class="odd"><td><code>incr</code></td><td>增量，用于控制流量的增加速率。</td></tr><tr class="even"><td><code>snd_queue</code></td><td>发送队列，用于存储待发送的数据包。</td></tr><tr class="odd"><td><code>rcv_queue</code></td><td>接收队列，用于存储待处理的数据包。</td></tr><tr class="even"><td><code>snd_buf</code></td><td>发送缓冲区，用于存储已经发送但未确认的数据包。</td></tr><tr class="odd"><td><code>rcv_buf</code></td><td>接收缓冲区，用于存储已经接收到但未处理的数据包。</td></tr><tr class="even"><td><code>acklist</code></td><td>确认列表，用于存储待发送的确认序号。</td></tr><tr class="odd"><td><code>ackcount</code></td><td>确认计数，表示确认列表中的条目数量。</td></tr><tr class="even"><td><code>ackblock</code></td><td>确认块大小，表示确认列表的内存分配大小。</td></tr><tr class="odd"><td><code>user</code></td><td>用户数据指针，用于存储用户自定义的数据。</td></tr><tr class="even"><td><code>buffer</code></td><td>缓冲区，用于临时存储发送的数据。</td></tr><tr class="odd"><td><code>fastresend</code></td><td>快速重传标志，表示启用快速重传功能。</td></tr><tr class="even"><td><code>fastlimit</code></td><td>快速重传限制，表示在一个 RTT 内允许的最大重传次数。</td></tr><tr class="odd"><td><code>nocwnd</code></td><td>无拥塞窗口控制标志，表示是否禁用拥塞窗口控制。</td></tr><tr class="even"><td><code>stream</code></td><td>流模式标志，表示是否启用流模式。</td></tr><tr class="odd"><td><code>logmask</code></td><td>日志掩码，用于控制日志输出的级别。</td></tr><tr class="even"><td><code>output</code></td><td>发送数据回调函数，用于发送数据。</td></tr><tr class="odd"><td><code>writelog</code></td><td>日志回调函数，用于输出日志。</td></tr></tbody></table><h2 id="队列和缓冲区">队列和缓冲区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPCB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_buf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_buf</span>;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>KCP中队列和缓冲区都是循环双链表，链表由宏实现，笔者并不擅长，所以本文就不探讨该链表的实现了，有数据结构基础的笔者应该很好理解这一块。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612175626865.png"alt="队列和缓冲区的实现：循环双链表" /><figcaptionaria-hidden="true">队列和缓冲区的实现：循环双链表</figcaption></figure><p>队列和缓冲区是 KCP最核心的部分，它们的作用流程大概如下图所示，读者可以自行阅读尝试理解，后续我们会进行详细的分析。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612175950432.png"alt="KCP 队列和缓冲区作用流程" /><figcaption aria-hidden="true">KCP 队列和缓冲区作用流程</figcaption></figure><h1 id="原理分析">原理分析</h1><p>这一节我们详细讨论 KCP 的整个 ARQ流程。首先我们会对整体流程进行简要概述，然后详细讨论滑动窗口中的发送和接收过程，接着讨论超时重传和快速重传，在这之后我们会将KCP 和 TCP 的重传策略进行简单对比，最后介绍一下拥塞控制策略。</p><h2 id="整体流程">1. 整体流程</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612192523848.png"alt="KCP 全流程" /><figcaption aria-hidden="true">KCP 全流程</figcaption></figure><p>KCP 的全流程如上图所示：</p><ol type="1"><li>发送方调用 <code>ikcp_send</code>将发送数据，这个时候会创建报文段实例，并放入 <code>snd_queue</code>发送队列中。</li><li>KCP 会定时调用 <code>ikcp_update</code> 判断是否要调用<code>ikcp_flush</code>。</li><li>调用 <code>ikcp_flush</code> 时会将合适的报文段放入<code>snd_buf</code> 缓冲区中，具体包括：<ol type="1"><li>发送 ACK 列表中所有 ACK；</li><li>根据是否需要发送窗口探测和通知报文，需要则发；</li><li>根据发送窗口大小，将适量的报文段从 <code>snd_queue</code> 移入<code>snd_buf</code> 中；</li><li>发送 <code>snd_buf</code>中的报文，包括<strong>新加入的</strong>、<strong>RTO 内未收到ACK</strong> 的和 <strong>ACK 失序若干次</strong>的；</li><li>根据丢包情况计算 <code>ssthresh</code> 和 <code>cwnd</code>。</li></ol></li><li>发送的时候会调用由 <code>ikcp_setoutput</code>设置的回调函数，将数据发送到对端。</li><li>接收方收到数据后，会调用 <code>ikcp_input</code>，将数据放入<code>rcv_buf</code> 缓冲区，具体包括：<ol type="1"><li>根据所有报文的 una 将相应的报文标记为已送达；</li><li>如果是 ACK，就将相应的报文标记为已送达；</li><li>如果是数据报文，就将它放入 <code>rcv_buf</code>，然后将<code>rcv_buf</code> 中顺序正确的报文移入 <code>rcv_queue</code>接收队列中，接着将相关信息插入 ACK 列表，在稍后的<code>ikcp_flush</code> 中会发送相应的 ACK；</li><li>如果是窗口探测报文，就标记“需要发送窗口通知”，在稍后的<code>ikcp_flush</code> 中会发送窗口通知报文；</li><li>包括窗口通知报文在内的所有报文都有 wnd 字段，据此更新 rmt_wnd；</li><li>根据 ACK 失序情况决定是否进行快速重传；</li><li>计算 cwnd。</li></ol></li><li>调用 <code>ikcp_recv</code> 从 <code>rcv_queue</code>中接收数据。</li></ol><h2 id="滑动窗口">2. 滑动窗口</h2><p>发送缓冲区 <code>snd_buf</code> 和接收缓冲区 <code>rcv_buf</code>中活动的报文都是在滑动窗口之中的。这对于我们理解 KCP的发送和接收流程非常重要，所有我们先从滑动窗口开始介绍。</p><p>滑动窗口实际是一个抽象的概念,不能简单地认为它是缓冲区的一部分，准确的说，滑动窗口是由队列加缓冲区共同组成的。</p><h3 id="发送">2.1 发送</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612193023604.png"alt="发送窗口" /><figcaption aria-hidden="true">发送窗口</figcaption></figure><p><code>snd_una</code> 和 <code>snd_nxt</code>会努力往<strong>右</strong>移动：</p><ol type="1"><li><code>ikcp_flush</code> 时，会从 <code>snd_queue</code>中取出报文插入到 <code>snd_nxt</code> 的位置上；</li><li>如果<code>snd_nxt - snd_una &gt;= cwnd</code>，则不允许新的报文插入；</li><li>当 <code>snd_una</code> 的 ACK 报文到达时，<code>snd_una</code>就会右移到第一个没有收到 ACK 报文的位置；</li></ol><p>发送窗口中未确认到达的报文何时重传？</p><ul><li>报文在一个 RTO 时间内仍未确认到达，就会重传。报文 RTO 初始值是rx_rto ，会持续增长，速率支持配置。</li></ul><h3 id="接收">2.2 接收</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612193238859.png"alt="接收窗口" /><figcaption aria-hidden="true">接收窗口</figcaption></figure><ol type="1"><li>每收到一个数据报文, 都会根据它的编号将它插入到 <code>rcv_buf</code>对应的位置中；</li><li>接着检查 <code>rcv_nxt</code> 能否向右移动,只有当报文的顺序正确且连续才能移动；</li><li>在上图的例子中由于 4 号报文的缺失, <code>rcv_nxt</code> 只能处于 4号位置等待，5, 6 号报文也不能移动到 <code>rcv_queue</code> 中；</li><li>等到 4 号报文到达后，才能将 4, 5, 6 号报文一并移动到<code>rcv_queue</code> 中，同时 <code>rcv_nxt</code> 会右移到 7号位置。</li></ol><h3 id="案例分析">2.3 案例分析</h3><p>我们举个简单的例子演示整个 ARQ的流程。下图中实线箭头表示数据报文，虚线箭头表示 ACK。</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/kcp_5.svg"alt="KCP ARQ 流程" /><figcaption aria-hidden="true">KCP ARQ 流程</figcaption></figure><p>① t1 时刻发送方发送 1 号报文, 1 号报文放入发送缓冲区中, snd_una 指向1, snd_nxt 指向 2.</p><p>② t2 至 t3 时刻发送方依次发送 2 至 3 号报文, snd_nxt 依次后移.</p><p>③ 1 号报文丢包.</p><p>④ t4, t5 时刻接收方收到 3 号和 2 号报文, 放入 rcv_buf 中; 随后回复 3号和 2 号 ACK. 此时由于 1 号报文缺失, rcv_nxt 始终指向 1.</p><p>⑤ 3 号 ACK 丢包.</p><p>⑥ t7 时刻发送方收到 2 号 ACK, 将 2 号报文标记为已送达. 此时由于 3 号ACK 丢包, 3 号报文未标记为已送达. 由于 1 号报文未确认送达, snd_una亦指向 1.</p><p>⑦ t8 时刻 1 号报文超时, 重传.</p><p>⑧ t9 时刻接收方收到 1 号报文, 放入 rcv_buf 中; 这时 1, 2, 3号报文顺序正确, rcv_nxt 右移到 4 号位置. 接收方回复 1 号 ACK, 同时带上una = 4.</p><p>⑨ t10 时刻发送方收到 1 号 ACK, 将 1 号报文标记为已送达. 同时 una 表明1, 2, 3 号报文均已送达, 因此也将 3 号报文标记为已送达. snd_una 移动到4.</p><h2 id="超时重传">3. 超时重传</h2><p>超时重传是当发送的数据包在预定时间内未被确认时，重新发送该数据包的机制。在KCP 中，这个时间由重新传输超时（RTO）决定。KCP 计算 RTO 初始值的方法是TCP 的标准方法, 规定在 <ahref="https://www.rfc-editor.org/rfc/rfc6298.html">RFC 6298</a> 中。</p><p>这里还是贴出源码讲比较直观：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ikcp_update_ack</span><span class="params">(ikcpcb *kcp, IINT32 rtt)</span></span><br><span class="line">&#123;</span><br><span class="line">IINT32 rto = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;rx_srtt == <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;rx_srtt = rtt;</span><br><span class="line">kcp-&gt;rx_rttval = rtt / <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">long</span> delta = rtt - kcp-&gt;rx_srtt;</span><br><span class="line"><span class="keyword">if</span> (delta &lt; <span class="number">0</span>) delta = -delta;</span><br><span class="line">kcp-&gt;rx_rttval = (<span class="number">3</span> * kcp-&gt;rx_rttval + delta) / <span class="number">4</span>;</span><br><span class="line">kcp-&gt;rx_srtt = (<span class="number">7</span> * kcp-&gt;rx_srtt + rtt) / <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;rx_srtt &lt; <span class="number">1</span>) kcp-&gt;rx_srtt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">rto = kcp-&gt;rx_srtt + _imax_(kcp-&gt;interval, <span class="number">4</span> * kcp-&gt;rx_rttval);</span><br><span class="line">kcp-&gt;rx_rto = _ibound_(kcp-&gt;rx_minrto, rto, IKCP_RTO_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个计算过程笔者就不做详细介绍了，代码里面的公式读者可以尝试自行画图进行理解，这里就不花大篇幅画公式了，下面我尝试以更通俗易懂的话语解释RTO，只需要理解它在做什么，为什么这么做，就可以了，个人觉得对公式的细节可以暂且忽略。</p><h3 id="rto-计算目的">3.1 RTO 计算目的</h3><p>KCP 的 RTO计算是为了确定在多长时间内未收到确认（ACK）时，应该重新发送数据包。这段时间被称为重传超时时间（RTO）。计算RTO的目的是在网络条件变化的情况下，既能快速响应数据丢失，也能避免不必要的重传，从而保持高效的传输。</p><h3 id="rto-计算涉及的变量解释">3.2 RTO 计算涉及的变量解释</h3><p><strong>RTT 和 SRTT 的概念:</strong></p><ul><li>RTT（Round-Trip Time）:是从发送一个数据包到收到其确认（ACK）所花的时间。</li><li>SRTT（Smoothed RTT）: 是 RTT 的加权平均值，它代表了 RTT的一个更稳定的估计值。SRTT 的目的是减少 RTT 的短期波动对 RTO的影响。</li></ul><p><strong>RTT 变化值（RTTvariance）</strong>：网络传输时间并不总是固定的，有时会因为网络拥塞或其他原因出现波动。我们通过计算RTT 变化值（RTT variance）来估计这种波动的大小。</p><p><strong>为什么需要 SRTT 和 RTT 变化值：</strong></p><ul><li>SRTT 给我们一个平均的 RTT 估计值。</li><li>RTT 变化值告诉我们网络的波动性。如果波动很大，我们希望 RTO更大，以免因为短暂的网络延迟就触发不必要的重传。</li></ul><h3 id="rto-计算步骤">3.3 RTO 计算步骤</h3><p><strong>1. 初始化</strong>：初次计算时，我们没有历史 RTT值，所以直接用第一次测量的 RTT 来初始化 SRTT，并将 RTT 变化值设为 RTT的一半。</p><p><strong>2. 更新 SRTT 和 RTT 变化值</strong>:</p><ul><li>每次我们测量新的 RTT，就用它来更新 SRTT 和 RTT 变化值。</li><li>更新 SRTT：我们不直接替换旧的SRTT，而是用一个平滑的方式（即加权平均），使得 SRTT 逐渐靠近新RTT，但又不会剧烈变化。</li><li>更新 RTT 变化值：计算新的 RTT 与 SRTT 的差值，用这个差值来更新 RTT变化值，使其反映当前网络波动的大小。</li></ul><p><strong>3. 计算 RTO</strong>:</p><ul><li>用 SRTT 加上四倍的 RTT 变化值来计算 RTO，这样可以确保 RTO足够长，能涵盖大部分的网络波动。</li><li>我们还要确保 RTO 不小于一个最小值（<code>rx_minrto</code>），以防止RTO过小导致频繁重传；也不能大于一个最大值（<code>IKCP_RTO_MAX</code>），以防止RTO 过大影响响应速度。</li></ul><h3 id="rto-计算效果">4. RTO 计算效果</h3><ul><li><strong>稳定的传输</strong>: SRTT 提供了一个稳定的平均 RTT估计，使得 RTO 能适应网络的长期变化。</li><li><strong>适应网络波动</strong>: RTT 变化值使得 RTO能够应对网络的短期波动，减少因短暂延迟而导致的重传。</li><li><strong>快速响应</strong>: RTO设置合理后，能够在数据丢失时快速重传，保持传输的高效和及时性。</li></ul><p>通过这样的计算方式，KCP能够在不同的网络条件下，自动调整重传策略，从而在保证数据可靠性的同时，保持较高的传输效率。</p><h2 id="快速重传">4. 快速重传</h2><p>在网络传输中，数据包可能会由于网络拥塞、丢包等原因而丢失。超时重传依赖于重传超时时间（RTO）来判断是否需要重传，这可能会导致响应延迟。而快速重传通过检测重复的确认包（ACK）来快速判断数据包的丢失，并立即触发重传，显著缩短了数据丢失的恢复时间。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612200038895.png"alt="KCP 快速重传" /><figcaption aria-hidden="true">KCP 快速重传</figcaption></figure><h3 id="何时快速重传">4.1 何时快速重传？</h3><ul><li>每个报文的 <code>fastack</code> 记录了它检测到 ACK 失序的次数，每当KCP 收到一个编号为 sn 的 ACK 时，就会检查 snd_buf 中编号小于 sn且未确认送达的报文，并将其 <code>fastack</code> 加 1。</li><li>可以通过配置 <code>fastresend</code>指定失序多少次就执行快速重传。</li><li>每次调用 ikcp_flush 都会重传 snd_buf 中<code>fastask &gt;= fastresend</code> 的报文。</li></ul><h3 id="无限快速重传吗">4.2 无限快速重传吗？</h3><ul><li>每个报文的 <code>xmit</code> 记录它被传输的次数，可以配置<code>fastlimit</code> 规定传输次数小于 <code>fastlimit</code>的报文才能执行快速重传。</li></ul><h2 id="比较-tcp-的超时重传和快速重传">5. 比较 TCP的超时重传和快速重传</h2><p>TCP 也实现了类似的机制，但在复杂性和应用场景上有所不同。</p><h3 id="tcp-的超时重传">5.1 TCP 的超时重传</h3><p><strong>1. RTT 估算</strong>:</p><ul><li><p>TCP 通过接收确认包来估算 RTT，并使用 RTT 的变化范围来计算RTO。</p></li><li><p>TCP 使用 Jacobson/Karels 算法进行 RTT 估算和 RTO 计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SRTT and RTTVAR calculation</span></span><br><span class="line">RTTVAR = (<span class="number">1</span> - β) * RTTVAR + β * |RTTsample - SRTT|</span><br><span class="line">SRTT = (<span class="number">1</span> - α) * SRTT + α * RTTsample</span><br><span class="line">RTO = SRTT + <span class="number">4</span> * RTTVAR</span><br></pre></td></tr></table></figure><p>其中，SRTT 是平滑的 RTT，RTTVAR 是 RTT 的变化范围，α 和 β是权重因子。</p></li></ul><p><strong>2. 重传策略</strong>:</p><ul><li>如果在 RTO 时间内未收到 ACK，TCP 会重传未确认的数据包。</li><li>每次重传，RTO 值会按照指数增长（指数退避算法）。</li></ul><p><strong>3. 拥塞控制</strong>:</p><ul><li>TCP使用复杂的拥塞控制机制，如慢启动、拥塞避免等，来调整发送窗口和传输速率。</li></ul><h3 id="tcp-的快速重传">5.2 TCP 的快速重传</h3><ul><li>当接收到三个重复的 ACK 时，TCP 会立即重传丢失的数据包，而不等待 RTO超时。</li><li>快速重传后，TCP进入快速恢复状态，调整拥塞窗口，避免拥塞窗口过度收缩。</li></ul><h3 id="比较分析">5.3 比较分析</h3><table><colgroup><col style="width: 16%" /><col style="width: 41%" /><col style="width: 42%" /></colgroup><thead><tr class="header"><th>特性</th><th>KCP</th><th>TCP</th></tr></thead><tbody><tr class="odd"><td><strong>RTT 估算</strong></td><td>基于加权移动平均，较为简单</td><td>使用 Jacobson/Karels 算法，复杂但精确</td></tr><tr class="even"><td><strong>RTO 计算</strong></td><td>简化的计算公式</td><td>基于 RTT 的复杂计算</td></tr><tr class="odd"><td><strong>重传机制</strong></td><td>超时重传和快速重传</td><td>超时重传和快速重传</td></tr><tr class="even"><td><strong>拥塞控制</strong></td><td>简单的拥塞控制，适合低延迟应用</td><td>复杂的拥塞控制，适合广泛的传输场景</td></tr><tr class="odd"><td><strong>适用场景</strong></td><td>实时应用，如游戏、视频会议</td><td>通用应用，如文件传输、HTTP</td></tr><tr class="even"><td><strong>实现复杂度</strong></td><td>较为简单，易于理解和实现</td><td>复杂，需处理更多的网络状态和控制</td></tr><tr class="odd"><td><strong>可靠性</strong></td><td>依赖于用户自定义的重传和控制策略</td><td>内置可靠性和流控制机制</td></tr><tr class="even"><td><strong>响应速度</strong></td><td>高效快速，适用于低延迟和高吞吐量场景</td><td>可靠但响应速度较慢，适合稳定传输场景</td></tr></tbody></table><p>KCP 和 TCP 都提供了可靠的传输机制，但它们适用于不同的应用场景。KCP设计简单，适合对延迟敏感的实时应用，而 TCP拥有完善的拥塞控制和可靠性机制，适合广泛的网络应用。</p><h2 id="拥塞控制">6. 拥塞控制</h2><p>拥塞控制是网络传输协议中的一个重要机制，用于防止发送过多的数据包导致网络拥塞。在KCP中，拥塞控制相对简单，主要通过发送窗口（<code>snd_wnd</code>）和拥塞窗口（<code>cwnd</code>）来管理数据发送速率。</p><h3 id="三种策略">6.1 三种策略</h3><p>KCP 有 3 种拥塞控制的策略：</p><ul><li>慢启动（slow start）</li><li>拥塞避免（congestion avoidance）</li><li>快速恢复（fast recovery）</li></ul><p><strong>慢启动</strong>：先将 cwnd 设置为 1，随后平均每经过一个 RTT时间，<code>cwnd = cwnd * 2</code>，直到阈值 <code>ssthresh</code>。</p><p><strong>拥塞避免</strong>：cwnd 到 <code>ssthresh</code> 后，cwnd呈<strong>线性</strong>增长。</p><p>当慢启动或者拥塞避免造成 <strong>丢包</strong>后，就采取相应的退让策略：</p><ol type="1"><li><code>fastack &gt;= fastresend</code> -&gt; 发生快速重传：将<code>ssthresh = cwnd / 2</code>，<code>cwnd = ssthresh + fastresend</code>进入<strong>快恢复</strong>。</li><li><code>current &gt;= resentts</code> -&gt;超时重传：<code>ssthresh = ssthresh / 2</code>，<code>cwnd = 1</code>，进入<strong>慢启动</strong>。</li></ol><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/kcp_7.svg"alt="拥塞控制中 cwnd 和 ssthresh 的变化情况" /><figcaption aria-hidden="true">拥塞控制中 cwnd 和 ssthresh的变化情况</figcaption></figure><h3 id="核心概念">6.2 核心概念</h3><p>KCP 的拥塞控制基于以下几个核心概念：</p><ul><li><strong>发送窗口(<code>snd_wnd</code>)</strong>：表示发送端在未收到接收端确认之前，允许发送的数据包的数量。它类似于TCP 中的发送窗口，控制了数据流的速率。</li><li><strong>接收窗口(<code>rcv_wnd</code>)</strong>：表示接收端能够处理的最大数据包数量。发送端通过接收端的窗口大小来调整自己的发送速率。</li><li><strong>远端窗口(<code>rmt_wnd</code>)</strong>：表示接收端的窗口大小，发送端会根据这个值调整自己的发送窗口，以避免发送的数据超出接收端的处理能力。</li><li><strong>拥塞窗口(<code>cwnd</code>)</strong>：用于控制传输中的数据包数量。它基于网络的拥塞情况动态调整，以避免网络拥塞。</li><li><strong>慢启动阈值(<code>ssthresh</code>)</strong>：用于确定拥塞控制的模式。当<code>cwnd</code> 小于 <code>ssthresh</code> 时，KCP处于慢启动模式，否则进入拥塞避免模式。</li></ul><h3 id="窗口探测window-probing">6.3 窗口探测（Window Probing）</h3><p>在某些情况下，接收端的窗口可能会被关闭（即 <code>rmt_wnd</code> 为0），这意味着接收端无法接收任何新的数据。为了应对这种情况，KCP实现了窗口探测机制：</p><ul><li>当 <code>rmt_wnd</code> 为 0 时，KCP不会立即停止发送数据，而是会定期发送一个探测包，以检测接收端窗口是否已经打开。</li><li>这个探测包会触发接收端返回一个ACK，其中包含最新的接收窗口大小信息。</li></ul><h3 id="调节和配置">6.4 调节和配置</h3><p>KCP的拥塞控制机制提供了一些配置参数，用户可以通过调整这些参数来优化传输性能：</p><ul><li><strong><code>snd_wnd</code></strong>:发送窗口大小，用户可以根据应用的需求调整该值，以控制数据发送的最大量。</li><li><strong><code>rcv_wnd</code></strong>:接收窗口大小，表示接收端能够处理的最大数据包数量。</li><li><strong><code>ssthresh</code></strong>:慢启动阈值，初始值通常设置为较大的一个常量，用户可以根据网络情况调整。</li><li><strong><code>cwnd</code></strong>: 拥塞窗口大小，初始值通常设置为1，随传输情况动态调整。</li></ul><h2 id="比较-tcp-的拥塞控制">7. 比较 TCP 的拥塞控制</h2><h3 id="四个阶段">7.1 四个阶段</h3><p>TCP 拥塞控制有四个关键阶段</p><p><strong>慢启动（Slow Start）</strong>：</p><ul><li><strong>目的</strong>：快速探测网络的可用带宽。</li><li><strong>机制</strong>：当一个连接刚建立或者从丢包恢复时，<code>cwnd</code>（拥塞窗口）从一个较小的值（通常是1 个 MSS，即最大报文段大小）开始，并以指数增长的方式增加。</li><li><strong>过程</strong>：每次收到一个 ACK，<code>cwnd</code> 增加一个MSS，使得 <code>cwnd</code> 每 RTT 增加一倍，直到 <code>cwnd</code>达到慢启动阈值（<code>ssthresh</code>）。</li></ul><p><strong>拥塞避免（Congestion Avoidance）</strong>:</p><ul><li><strong>目的</strong>：逐步探测网络的最大容量，并避免拥塞。</li><li><strong>机制</strong>：当 <code>cwnd</code> 达到或超过<code>ssthresh</code> 时，TCP 进入拥塞避免阶段，此时 <code>cwnd</code>以线性增长的方式增加。</li><li><strong>过程</strong>：每个 RTT，<code>cwnd</code> 增加<code>1/cwnd</code> 个MSS，这种增长方式较为保守，旨在防止过度发送导致的拥塞。</li></ul><p><strong>快速重传（Fast Retransmit）</strong>:</p><ul><li><strong>目的</strong>：快速响应丢包，提高传输效率。</li><li><strong>机制</strong>：当发送端收到三个重复的 ACK时，立即重传被确认丢失的数据包，而不等待 RTO 超时。</li><li><strong>过程</strong>：快速重传的目的是迅速恢复丢失的数据包，从而减少因丢包导致的等待时间。</li></ul><p><strong>快速恢复（Fast Recovery）</strong>:</p><ul><li><strong>目的</strong>：在拥塞后快速恢复到适当的传输速率。</li><li><strong>机制</strong>：在快速重传后，TCP不会直接进入慢启动，而是保持 <code>cwnd</code>的一部分，以较快的速度恢复到拥塞避免状态。</li><li><strong>过程</strong>：将 <code>ssthresh</code> 设置为当前<code>cwnd</code> 的一半，<code>cwnd</code> 被临时减小，然后在接收新 ACK时快速增加 <code>cwnd</code>，直到恢复到 <code>ssthresh</code>为止。</li></ul><h3 id="比较分析-1">7.2 比较分析</h3><table><colgroup><col style="width: 14%" /><col style="width: 42%" /><col style="width: 42%" /></colgroup><thead><tr class="header"><th>特性</th><th>TCP</th><th>KCP</th></tr></thead><tbody><tr class="odd"><td><strong>实现复杂度</strong></td><td>复杂，包含多个阶段和算法</td><td>简单，主要通过窗口大小控制</td></tr><tr class="even"><td><strong>拥塞检测</strong></td><td>通过 RTT 估算和 ACK 检测丢包</td><td>主要通过 ACK 和窗口大小检测丢包</td></tr><tr class="odd"><td><strong>响应速度</strong></td><td>响应相对较慢，适合稳定传输</td><td>响应较快，适合实时性高的传输</td></tr><tr class="even"><td><strong>适应性</strong></td><td>能适应广泛的网络条件</td><td>适应性较好，但更适合低延迟网络</td></tr><tr class="odd"><td><strong>配置灵活性</strong></td><td>较为固定，依赖于系统配置和优化</td><td>提供更多的配置选项，用户可根据需求调整</td></tr><tr class="even"><td><strong>应用场景</strong></td><td>适用于各种需要可靠传输的应用</td><td>适用于实时性要求高的应用，如游戏和视频会议</td></tr><tr class="odd"><td><strong>窗口调整</strong></td><td>慢启动、拥塞避免、快速重传、快速恢复等机制</td><td>主要通过发送窗口和拥塞窗口调整</td></tr><tr class="even"><td><strong>丢包响应</strong></td><td>丢包时通过减小 <code>cwnd</code> 和 <code>ssthresh</code>来调整</td><td>丢包时迅速调整 <code>cwnd</code> 和重传</td></tr><tr class="odd"><td><strong>拥塞控制策略</strong></td><td>慢启动、拥塞避免、快速重传、快速恢复等多种策略</td><td>主要通过调整 <code>cwnd</code> 和 <code>ssthresh</code>进行简单控制</td></tr><tr class="even"><td><strong>优点</strong></td><td>稳定可靠、机制全面、应用广泛</td><td>实现简单、响应快、灵活性高、适合实时应用</td></tr><tr class="odd"><td><strong>缺点</strong></td><td>复杂、响应慢、初始阶段保守</td><td>无法应对更加复杂的网络状况、应用场景有限</td></tr></tbody></table><p>TCP 和 KCP 都有各自的拥塞控制机制，适用于不同的应用场景。TCP提供了复杂而全面的拥塞控制，适合于各种网络条件下的可靠传输，而 KCP提供了简单高效的控制机制，适合于低延迟和高响应速度的实时应用。选择使用哪种协议取决于具体的应用需求和网络环境。</p><h1 id="源码分析">源码分析</h1><h2 id="核心数据结构">1. 核心数据结构</h2><h3 id="ikcpseg-报文段结构">1.1 IKCPSEG 报文段结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPSEG</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">node</span>;</span>  <span class="comment">// 链表节点</span></span><br><span class="line">    IUINT32 conv;     <span class="comment">// 会话ID</span></span><br><span class="line">    IUINT32 cmd;      <span class="comment">// 命令类型</span></span><br><span class="line">    IUINT32 frg;      <span class="comment">// 分片序号</span></span><br><span class="line">    IUINT32 wnd;      <span class="comment">// 窗口大小</span></span><br><span class="line">    IUINT32 ts;       <span class="comment">// 时间戳</span></span><br><span class="line">    IUINT32 sn;       <span class="comment">// 序列号</span></span><br><span class="line">    IUINT32 una;      <span class="comment">// 待接收的下一个包序号</span></span><br><span class="line">    IUINT32 len;      <span class="comment">// 数据长度</span></span><br><span class="line">    IUINT32 resendts; <span class="comment">// 重传时间戳</span></span><br><span class="line">    IUINT32 rto;      <span class="comment">// 超时重传时间</span></span><br><span class="line">    IUINT32 fastack;  <span class="comment">// 快速重传计数器</span></span><br><span class="line">    IUINT32 xmit;     <span class="comment">// 传输次数</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">1</span>];     <span class="comment">// 数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ikcpcb-控制块">1.2 IKCPCB 控制块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPCB</span> &#123;</span></span><br><span class="line">    <span class="comment">// === 基础配置 ===</span></span><br><span class="line">    IUINT32 conv;          <span class="comment">// 会话ID，用于标识一个会话</span></span><br><span class="line">    IUINT32 mtu;          <span class="comment">// 最大传输单元，默认1400字节</span></span><br><span class="line">    IUINT32 mss;          <span class="comment">// 最大报文段大小，默认mtu-24字节</span></span><br><span class="line">    IUINT32 state;        <span class="comment">// 连接状态，0=正常，-1=断开</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 发送和接收序号 ===</span></span><br><span class="line">    IUINT32 snd_una;      <span class="comment">// 第一个未确认的包序号</span></span><br><span class="line">    IUINT32 snd_nxt;      <span class="comment">// 下一个待发送的包序号</span></span><br><span class="line">    IUINT32 rcv_nxt;      <span class="comment">// 待接收的下一个包序号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 时间戳相关 ===</span></span><br><span class="line">    IUINT32 ts_recent;    <span class="comment">// 最近一次收到包的时间戳</span></span><br><span class="line">    IUINT32 ts_lastack;   <span class="comment">// 最近一次收到ACK的时间戳</span></span><br><span class="line">    IUINT32 ssthresh;     <span class="comment">// 慢启动阈值，默认为IKCP_THRESH_INIT(2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === RTT相关 ===</span></span><br><span class="line">    IINT32 rx_rttval;     <span class="comment">// RTT的变化量</span></span><br><span class="line">    IINT32 rx_srtt;       <span class="comment">// 平滑后的RTT</span></span><br><span class="line">    IINT32 rx_rto;        <span class="comment">// 超时重传时间，初始为IKCP_RTO_DEF(200ms)</span></span><br><span class="line">    IINT32 rx_minrto;     <span class="comment">// 最小重传超时时间，默认为IKCP_RTO_MIN(100ms)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 窗口相关 ===</span></span><br><span class="line">    IUINT32 snd_wnd;      <span class="comment">// 发送窗口大小，默认32</span></span><br><span class="line">    IUINT32 rcv_wnd;      <span class="comment">// 接收窗口大小，默认128</span></span><br><span class="line">    IUINT32 rmt_wnd;      <span class="comment">// 远端窗口大小，默认128</span></span><br><span class="line">    IUINT32 cwnd;         <span class="comment">// 拥塞窗口大小，初始为0</span></span><br><span class="line">    IUINT32 probe;        <span class="comment">// 探测标志，用于窗口探测</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 时间相关 ===</span></span><br><span class="line">    IUINT32 current;      <span class="comment">// 当前时间</span></span><br><span class="line">    IUINT32 interval;     <span class="comment">// 内部更新时间间隔，默认100ms</span></span><br><span class="line">    IUINT32 ts_flush;     <span class="comment">// 下次刷新时间</span></span><br><span class="line">    IUINT32 xmit;         <span class="comment">// 总重传次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 队列计数器 ===</span></span><br><span class="line">    IUINT32 nrcv_buf;     <span class="comment">// 接收缓存中的包数量</span></span><br><span class="line">    IUINT32 nsnd_buf;     <span class="comment">// 发送缓存中的包数量</span></span><br><span class="line">    IUINT32 nrcv_que;     <span class="comment">// 接收队列中的包数量</span></span><br><span class="line">    IUINT32 nsnd_que;     <span class="comment">// 发送队列中的包数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 配置标志 ===</span></span><br><span class="line">    IUINT32 nodelay;      <span class="comment">// 是否启用nodelay模式，0=不启用</span></span><br><span class="line">    IUINT32 updated;      <span class="comment">// 是否调用过update</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 探测相关 ===</span></span><br><span class="line">    IUINT32 ts_probe;     <span class="comment">// 下次探测时间</span></span><br><span class="line">    IUINT32 probe_wait;   <span class="comment">// 探测等待时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 链路控制 ===</span></span><br><span class="line">    IUINT32 dead_link;    <span class="comment">// 最大重传次数，默认为IKCP_DEADLINK(20)</span></span><br><span class="line">    IUINT32 incr;         <span class="comment">// 可发送的最大数据量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 数据队列 ===</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_queue</span>;</span>  <span class="comment">// 发送队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_queue</span>;</span>  <span class="comment">// 接收队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_buf</span>;</span>    <span class="comment">// 发送缓存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_buf</span>;</span>    <span class="comment">// 接收缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === ACK相关 ===</span></span><br><span class="line">    IUINT32 *acklist;     <span class="comment">// ACK列表</span></span><br><span class="line">    IUINT32 ackcount;     <span class="comment">// ACK数量</span></span><br><span class="line">    IUINT32 ackblock;     <span class="comment">// ACK列表大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 用户相关 ===</span></span><br><span class="line">    <span class="type">void</span> *user;           <span class="comment">// 用户数据指针</span></span><br><span class="line">    <span class="type">char</span> *buffer;         <span class="comment">// 临时缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 快速重传相关 ===</span></span><br><span class="line">    <span class="type">int</span> fastresend;       <span class="comment">// 触发快速重传的重复ACK个数</span></span><br><span class="line">    <span class="type">int</span> fastlimit;        <span class="comment">// 快速重传次数限制，默认IKCP_FASTACK_LIMIT(5)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 其他配置 ===</span></span><br><span class="line">    <span class="type">int</span> nocwnd;          <span class="comment">// 是否关闭拥塞控制，0=不关闭</span></span><br><span class="line">    <span class="type">int</span> stream;          <span class="comment">// 是否为流模式，0=消息模式(默认)，1=流模式</span></span><br><span class="line">    <span class="type">int</span> logmask;        <span class="comment">// 日志掩码，控制日志输出级别</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 回调函数 ===</span></span><br><span class="line">    <span class="comment">// 数据输出回调，用于发送数据</span></span><br><span class="line">    <span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line">    <span class="comment">// 日志输出回调</span></span><br><span class="line">    <span class="type">void</span> (*writelog)(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">log</span>, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体可以大致分为几个主要部分：</p><ul><li>基础配置：包含基本的会话标识和传输单元大小设置</li><li>序号追踪：用于追踪发送和接收的包序号</li><li>时间管理：包含各种时间戳和定时器</li><li>窗口控制：实现流量控制和拥塞控制</li><li>队列管理：管理数据的发送和接收</li><li>ACK 处理：处理确认包</li><li>配置选项：各种功能开关和参数设置</li><li>回调函数：用于数据输出和日志记录</li></ul><h2 id="核心函数">2. 核心函数</h2><p>在进入具体的核心函数分析之前，需要先点明 2 点，<code>kcp</code>的实现者期望其尽可能地简单和减少依赖，所以数据的输出甚至是当前时间都是由使用者来设置的，即<code>kcp</code> 本身是不依赖于机器时钟的。具体体现在下面 2 个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// set output callback, which will be invoked by kcp</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_setoutput</span><span class="params">(ikcpcb *kcp, <span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">ikcpcb *kcp, <span class="type">void</span> *user))</span></span><br><span class="line">&#123;</span><br><span class="line">kcp-&gt;output = output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// update state (call it repeatedly, every 10ms-100ms), or you can ask</span></span><br><span class="line"><span class="comment">// ikcp_check when to call it again (without ikcp_input/_send calling).</span></span><br><span class="line"><span class="comment">// &#x27;current&#x27; - current timestamp in millisec.</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_update</span><span class="params">(ikcpcb *kcp, IUINT32 current)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ikcp_send-发送数据">2.1 ikcp_send 发送数据</h3><p><code>ikcp_send</code>是应用层接口，负责将用户数据分片并加入到发送队列（<code>snd_queue</code>）。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241129154115523.png"alt="ikcp_send" /><figcaption aria-hidden="true">ikcp_send</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// user/upper level send, returns below zero for error</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_send</span><span class="params">(ikcpcb *kcp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">IKCPSEG *seg;</span><br><span class="line"><span class="type">int</span> count, i;</span><br><span class="line"><span class="type">int</span> sent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mtu: 最大传输单元</span></span><br><span class="line"><span class="comment">// mss: 最大报文段大小</span></span><br><span class="line"><span class="comment">// mss = mtu - 包头长度(24)</span></span><br><span class="line">assert(kcp-&gt;mss &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// append to previous segment in streaming mode (if possible)</span></span><br><span class="line"><span class="comment">// 如果是流模式，则将数据追加到前一个分段中（如果可能）</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;stream != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 如果当前发送队列不为空，且前一个分段未满，则将数据追加到前一个分段中</span></span><br><span class="line"><span class="keyword">if</span> (!iqueue_is_empty(&amp;kcp-&gt;snd_queue)) &#123;</span><br><span class="line">IKCPSEG *old = iqueue_entry(kcp-&gt;snd_queue.prev, IKCPSEG, node);</span><br><span class="line"><span class="keyword">if</span> (old-&gt;len &lt; kcp-&gt;mss) &#123;</span><br><span class="line"><span class="type">int</span> capacity = kcp-&gt;mss - old-&gt;len;</span><br><span class="line"><span class="type">int</span> extend = (len &lt; capacity)? len : capacity;</span><br><span class="line">seg = ikcp_segment_new(kcp, old-&gt;len + extend);</span><br><span class="line">assert(seg);</span><br><span class="line"><span class="keyword">if</span> (seg == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将新的 seg-&gt;node 放入 snd_queue 中等待发送</span></span><br><span class="line">iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;snd_queue);</span><br><span class="line"><span class="comment">// 把上一个报文的数据拷贝过来</span></span><br><span class="line"><span class="built_in">memcpy</span>(seg-&gt;data, old-&gt;data, old-&gt;len);</span><br><span class="line"><span class="keyword">if</span> (buffer) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(seg-&gt;data + old-&gt;len, buffer, extend);</span><br><span class="line">buffer += extend;</span><br><span class="line">&#125;</span><br><span class="line">seg-&gt;len = old-&gt;len + extend;</span><br><span class="line">seg-&gt;frg = <span class="number">0</span>;</span><br><span class="line">len -= extend;</span><br><span class="line">iqueue_del_init(&amp;old-&gt;node);</span><br><span class="line"><span class="comment">// 释放之前老数据的 kcp node</span></span><br><span class="line">ikcp_segment_delete(kcp, old);</span><br><span class="line">sent = extend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> sent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 非流模式，不追加到上一个报文后面</span></span><br><span class="line"><span class="comment">// 2. 流模式，但是上一个报文已满，则创建新的报文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算需要的报文数量，kcp 会对数据进行分段传输</span></span><br><span class="line"><span class="keyword">if</span> (len &lt;= (<span class="type">int</span>)kcp-&gt;mss) count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> count = (len + kcp-&gt;mss - <span class="number">1</span>) / kcp-&gt;mss;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收窗口位置不够，则暂停发送</span></span><br><span class="line"><span class="keyword">if</span> (count &gt;= (<span class="type">int</span>)IKCP_WND_RCV) &#123;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;stream != <span class="number">0</span> &amp;&amp; sent &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> sent;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送所有的报文段</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"><span class="type">int</span> size = len &gt; (<span class="type">int</span>)kcp-&gt;mss ? (<span class="type">int</span>)kcp-&gt;mss : len;</span><br><span class="line">seg = ikcp_segment_new(kcp, size);</span><br><span class="line">assert(seg);</span><br><span class="line"><span class="keyword">if</span> (seg == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (buffer &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(seg-&gt;data, buffer, size);</span><br><span class="line">&#125;</span><br><span class="line">seg-&gt;len = size;</span><br><span class="line">seg-&gt;frg = (kcp-&gt;stream == <span class="number">0</span>)? (count - i - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">iqueue_init(&amp;seg-&gt;node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将报文段放入 snd_queue 中</span></span><br><span class="line">iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;snd_queue);</span><br><span class="line">kcp-&gt;nsnd_que++;</span><br><span class="line"><span class="keyword">if</span> (buffer) &#123;</span><br><span class="line">buffer += size;</span><br><span class="line">&#125;</span><br><span class="line">len -= size;</span><br><span class="line">sent += size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ikcp_input-接收数据">2.2 ikcp_input 接收数据</h3><p><code>ikcp_input</code> 负责处理从网络接收到的原始 KCP数据包，它会处理协议层面的数据，包括ACK、窗口控制等协议信息，并将接收到的数据放入 KCP的内部接收缓冲区（<code>rcv_buf</code> 和 <code>rcv_queue</code>）。</p><h3 id="ikcp_recv-获取数据">2.3 ikcp_recv 获取数据</h3><p><code>ikcp_recv</code>是应用层函数，供上层应用调用以获取完整的消息数据，它从 KCP的接收队列(rcv_queue)中读取已经排序好的数据，处理分片重组，确保返回完整的消息。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241129163431276.png"alt="ikcp_recv" /><figcaption aria-hidden="true">ikcp_recv</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// user/upper level recv: returns size, returns below zero for EAGAIN</span></span><br><span class="line"><span class="comment">// 从 rcv_queue 中获取数据</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_recv</span><span class="params">(ikcpcb *kcp, <span class="type">char</span> *buffer, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="type">int</span> ispeek = (len &lt; <span class="number">0</span>)? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> peeksize;</span><br><span class="line"><span class="type">int</span> recover = <span class="number">0</span>;</span><br><span class="line">IKCPSEG *seg;</span><br><span class="line">assert(kcp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 rcv_queue 为空，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (iqueue_is_empty(&amp;kcp-&gt;rcv_queue))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 len &lt; 0，则说明是 peek 操作，准备只查看数据</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span>) len = -len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 rcv_queue 中数据的大小</span></span><br><span class="line">peeksize = ikcp_peeksize(kcp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法获得大小，返回 -2</span></span><br><span class="line"><span class="keyword">if</span> (peeksize &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据过大，返回 -3</span></span><br><span class="line"><span class="keyword">if</span> (peeksize &gt; len)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nrcv_que: rcv_queue 的长度</span></span><br><span class="line"><span class="comment">// rcv_wnd: 接收窗口的大小</span></span><br><span class="line"><span class="comment">// 如果 nrcv_que &gt;= rcv_wnd，则需要进行快恢复</span></span><br><span class="line"><span class="comment">// 因为 nrcv_que &gt;= rcv_wnd，说明接收窗口已经满了，</span></span><br><span class="line"><span class="comment">// 这个时候需要发送 IKCP_CMD_WINS 告诉发送方窗口大小，</span></span><br><span class="line"><span class="comment">// 这个时候发送方需要进行快恢复，减小数据传输，以尽快释放接收窗口</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;nrcv_que &gt;= kcp-&gt;rcv_wnd)</span><br><span class="line">recover = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge fragment</span></span><br><span class="line"><span class="comment">// 将多个片段合并成一个完整的片段</span></span><br><span class="line"><span class="comment">// 合并后，将合并后的片段从 rcv_queue 中删除</span></span><br><span class="line"><span class="keyword">for</span> (len = <span class="number">0</span>, p = kcp-&gt;rcv_queue.next; p != &amp;kcp-&gt;rcv_queue; ) &#123;</span><br><span class="line"><span class="type">int</span> fragment;</span><br><span class="line">seg = iqueue_entry(p, IKCPSEG, node);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buffer) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(buffer, seg-&gt;data, seg-&gt;len);</span><br><span class="line">buffer += seg-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">len += seg-&gt;len;</span><br><span class="line">fragment = seg-&gt;frg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ikcp_canlog(kcp, IKCP_LOG_RECV)) &#123;</span><br><span class="line">ikcp_log(kcp, IKCP_LOG_RECV, <span class="string">&quot;recv sn=%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)seg-&gt;sn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ispeek == <span class="number">0</span>) &#123;</span><br><span class="line">iqueue_del(&amp;seg-&gt;node);</span><br><span class="line">ikcp_segment_delete(kcp, seg);</span><br><span class="line">kcp-&gt;nrcv_que--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fragment == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(len == peeksize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// move available data from rcv_buf -&gt; rcv_queue</span></span><br><span class="line"><span class="comment">// 尝试将 rcv_buf 中编号连续的数据，移动到 rcv_queue 中</span></span><br><span class="line"><span class="comment">// 移动后，将移动的数据从 rcv_buf 中删除</span></span><br><span class="line"><span class="keyword">while</span> (! iqueue_is_empty(&amp;kcp-&gt;rcv_buf)) &#123;</span><br><span class="line">seg = iqueue_entry(kcp-&gt;rcv_buf.next, IKCPSEG, node);</span><br><span class="line"><span class="keyword">if</span> (seg-&gt;sn == kcp-&gt;rcv_nxt &amp;&amp; kcp-&gt;nrcv_que &lt; kcp-&gt;rcv_wnd) &#123;</span><br><span class="line">iqueue_del(&amp;seg-&gt;node);</span><br><span class="line">kcp-&gt;nrcv_buf--;</span><br><span class="line">iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;rcv_queue);</span><br><span class="line">kcp-&gt;nrcv_que++;</span><br><span class="line">kcp-&gt;rcv_nxt++;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快恢复</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;nrcv_que &lt; kcp-&gt;rcv_wnd &amp;&amp; recover) &#123;</span><br><span class="line"><span class="comment">// 在ikcp_flush 中返回 IKCP_CMD_WINS</span></span><br><span class="line"><span class="comment">// 通知本段窗口大小给对端</span></span><br><span class="line">kcp-&gt;probe |= IKCP_ASK_TELL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ikcp_update-定时时钟">2.4 ikcp_update 定时时钟</h3><p>前面我们看了 <code>ikcp_send</code> 、<code>ikcp_input</code> 和<code>ikcp_recv</code>三个核心流程的函数，其中的一些细节，你可以回到本文前面的「原理分析」再对照源码仔细阅读。</p><p>在前面的原理分析中，我们提到，为了提高传输和处理数据的效率，<code>kcp</code>设计了队列和缓冲区，同时为了实现可靠性，<code>kcp</code> 也提供了<code>ACK</code>和重试、拥塞控制等机制，这些事情都是周期定时去处理的。这里是由<code>ikcp_update</code> 函数去处理的。</p><p><code>ikcp_update</code> 是 KCP 的定时器函数，负责以固定间隔调用<code>ikcp_flush</code> 处理数据发送和协议更新，是 KCP的"心跳"机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// update state (call it repeatedly, every 10ms-100ms), or you can ask</span></span><br><span class="line"><span class="comment">// ikcp_check when to call it again (without ikcp_input/_send calling).</span></span><br><span class="line"><span class="comment">// &#x27;current&#x27; - current timestamp in millisec.</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_update</span><span class="params">(ikcpcb *kcp, IUINT32 current)</span></span><br><span class="line">&#123;</span><br><span class="line">IINT32 slap;</span><br><span class="line"></span><br><span class="line">kcp-&gt;current = current;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;updated == <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;updated = <span class="number">1</span>;</span><br><span class="line">kcp-&gt;ts_flush = kcp-&gt;current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算间隔</span></span><br><span class="line">slap = _itimediff(kcp-&gt;current, kcp-&gt;ts_flush);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slap &gt;= <span class="number">10000</span> || slap &lt; <span class="number">-10000</span>) &#123;</span><br><span class="line">kcp-&gt;ts_flush = kcp-&gt;current;</span><br><span class="line">slap = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 达到调用间隔，则执行 ikcp_flush 进行接收数据或发送数据</span></span><br><span class="line"><span class="keyword">if</span> (slap &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;ts_flush += kcp-&gt;interval;</span><br><span class="line"><span class="keyword">if</span> (_itimediff(kcp-&gt;current, kcp-&gt;ts_flush) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;ts_flush = kcp-&gt;current + kcp-&gt;interval;</span><br><span class="line">&#125;</span><br><span class="line">ikcp_flush(kcp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很简单，根据注释所说，通常情况下会每 <code>10ms~100ms</code>执行一次，然后核心是去调用 <code>ikcp_flush</code>函数，所有的逻辑都在里面。</p><h3 id="ikcp_flush-定时处理">2.5 ikcp_flush 定时处理</h3><p>如上所述，<code>ikcp_flush</code> 是 KCP的核心发送函数，负责将发送队列 <code>snd_queue</code>中的数据移入发送缓存 <code>snd_buf</code> 并通过 <code>output</code>回调发送出去，同时处理 ACK发送、快速重传、超时重传和窗口探测等协议细节。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241129170905325.png"alt="ikcp_flush" /><figcaption aria-hidden="true">ikcp_flush</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ikcp_flush</span><span class="params">(ikcpcb *kcp)</span></span><br><span class="line">&#123;</span><br><span class="line">IUINT32 current = kcp-&gt;current;<span class="comment">// 当前时间</span></span><br><span class="line"><span class="type">char</span> *buffer = kcp-&gt;buffer;<span class="comment">// 临时缓冲区</span></span><br><span class="line"><span class="type">char</span> *ptr = buffer;</span><br><span class="line"><span class="type">int</span> count, size, i;</span><br><span class="line">IUINT32 resent, cwnd;</span><br><span class="line">IUINT32 rtomin;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="type">int</span> change = <span class="number">0</span>;<span class="comment">// 是否执行过快速重传</span></span><br><span class="line"><span class="type">int</span> lost = <span class="number">0</span>;<span class="comment">// 是否执行过超时重传</span></span><br><span class="line">IKCPSEG seg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否已调用 ikcp_update</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;updated == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个段用于构建各种控制包</span></span><br><span class="line">seg.conv = kcp-&gt;conv;  <span class="comment">// 连接标识</span></span><br><span class="line">seg.cmd = IKCP_CMD_ACK;<span class="comment">// 报文类型：IKCP_CMD_ACK 表示确认报文</span></span><br><span class="line">seg.frg = <span class="number">0</span>;<span class="comment">// 分片数量，表示随后还有多少个报文属于同一个包</span></span><br><span class="line">seg.wnd = ikcp_wnd_unused(kcp);<span class="comment">// 发送方剩余接收窗口的大小</span></span><br><span class="line">seg.una = kcp-&gt;rcv_nxt;<span class="comment">// 发送方的接收缓冲区中最小还未收到的报文段的编号，也就是说，编号比它小的报文段都已全部接收</span></span><br><span class="line">seg.len = <span class="number">0</span>;<span class="comment">// 数据段长度</span></span><br><span class="line">seg.sn = <span class="number">0</span>;<span class="comment">// 报文编号</span></span><br><span class="line">seg.ts = <span class="number">0</span>;<span class="comment">// 时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// flush acknowledges</span></span><br><span class="line"><span class="comment">// ① 发送 ACK 队列中的所有 ACK</span></span><br><span class="line">count = kcp-&gt;ackcount;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line"><span class="comment">// buffer 中累计的数据将要超过 mtu 的时候</span></span><br><span class="line"><span class="comment">// 就调用 ikcp_output 将数据发送出去</span></span><br><span class="line"><span class="keyword">if</span> (size + (<span class="type">int</span>)IKCP_OVERHEAD &gt; (<span class="type">int</span>)kcp-&gt;mtu) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">ptr = buffer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 ACK 列表中取出 sn(报文编号)和 ts(时间戳)</span></span><br><span class="line">ikcp_ack_get(kcp, i, &amp;seg.sn, &amp;seg.ts);</span><br><span class="line"><span class="comment">// 将 ACK 报文写入 buffer</span></span><br><span class="line">ptr = ikcp_encode_seg(ptr, &amp;seg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ② ACK 队列已清空</span></span><br><span class="line">kcp-&gt;ackcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// probe window size (if remote window size equals zero)</span></span><br><span class="line"><span class="comment">// 对端剩余接收窗口大小为 0，则意味着可能需要发送窗口探测报文：IKCP_CMD_WASK</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;rmt_wnd == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 根据 ts_probe 和 probe_wait 确定当前时刻是否需要发送探测报文</span></span><br><span class="line"><span class="comment">// probe_wait: 等待发送探测报文的时间，IKCP_PROBE_INIT=7s, IKCP_PROBE_LIMIT=</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe_wait == <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;probe_wait = IKCP_PROBE_INIT; <span class="comment">// 7s 后去发探测报文</span></span><br><span class="line">kcp-&gt;ts_probe = kcp-&gt;current + kcp-&gt;probe_wait;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (_itimediff(kcp-&gt;current, kcp-&gt;ts_probe) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe_wait &lt; IKCP_PROBE_INIT)</span><br><span class="line">kcp-&gt;probe_wait = IKCP_PROBE_INIT;</span><br><span class="line">kcp-&gt;probe_wait += kcp-&gt;probe_wait / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe_wait &gt; IKCP_PROBE_LIMIT)</span><br><span class="line">kcp-&gt;probe_wait = IKCP_PROBE_LIMIT;</span><br><span class="line">kcp-&gt;ts_probe = kcp-&gt;current + kcp-&gt;probe_wait;</span><br><span class="line">kcp-&gt;probe |= IKCP_ASK_SEND; <span class="comment">// 设置是否需要去发送 IKCP_ASK_SEND</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kcp-&gt;ts_probe = <span class="number">0</span>;</span><br><span class="line">kcp-&gt;probe_wait = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flush window probing commands</span></span><br><span class="line"><span class="comment">// ③ 如果需要，则发送窗口探测报文：IKCP_CMD_WASK</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe &amp; IKCP_ASK_SEND) &#123;</span><br><span class="line">seg.cmd = IKCP_CMD_WASK;</span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line"><span class="keyword">if</span> (size + (<span class="type">int</span>)IKCP_OVERHEAD &gt; (<span class="type">int</span>)kcp-&gt;mtu) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">ptr = buffer;</span><br><span class="line">&#125;</span><br><span class="line">ptr = ikcp_encode_seg(ptr, &amp;seg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flush window probing commands</span></span><br><span class="line"><span class="comment">// ④ 如果需要，则发送窗口通知报文：IKCP_CMD_WINS</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe &amp; IKCP_ASK_TELL) &#123;</span><br><span class="line">seg.cmd = IKCP_CMD_WINS;</span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line"><span class="keyword">if</span> (size + (<span class="type">int</span>)IKCP_OVERHEAD &gt; (<span class="type">int</span>)kcp-&gt;mtu) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">ptr = buffer;</span><br><span class="line">&#125;</span><br><span class="line">ptr = ikcp_encode_seg(ptr, &amp;seg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kcp-&gt;probe = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate window size</span></span><br><span class="line"><span class="comment">// ⑤ 计算当前窗口大小</span></span><br><span class="line">cwnd = _imin_(kcp-&gt;snd_wnd, kcp-&gt;rmt_wnd);</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;nocwnd == <span class="number">0</span>) cwnd = _imin_(kcp-&gt;cwnd, cwnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// move data from snd_queue to snd_buf</span></span><br><span class="line"><span class="comment">// 5.1 如果符合发送的条件，则创建新的 newseg 并放入 snd_buf 的尾部</span></span><br><span class="line"><span class="keyword">while</span> (_itimediff(kcp-&gt;snd_nxt, kcp-&gt;snd_una + cwnd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">IKCPSEG *newseg;</span><br><span class="line"><span class="keyword">if</span> (iqueue_is_empty(&amp;kcp-&gt;snd_queue)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">newseg = iqueue_entry(kcp-&gt;snd_queue.next, IKCPSEG, node);</span><br><span class="line"></span><br><span class="line">iqueue_del(&amp;newseg-&gt;node);</span><br><span class="line">iqueue_add_tail(&amp;newseg-&gt;node, &amp;kcp-&gt;snd_buf);</span><br><span class="line">kcp-&gt;nsnd_que--;</span><br><span class="line">kcp-&gt;nsnd_buf++;</span><br><span class="line"></span><br><span class="line">newseg-&gt;conv = kcp-&gt;conv;</span><br><span class="line">newseg-&gt;cmd = IKCP_CMD_PUSH;</span><br><span class="line">newseg-&gt;wnd = seg.wnd;</span><br><span class="line">newseg-&gt;ts = current;</span><br><span class="line">newseg-&gt;sn = kcp-&gt;snd_nxt++;</span><br><span class="line">newseg-&gt;una = kcp-&gt;rcv_nxt;</span><br><span class="line">newseg-&gt;resendts = current;</span><br><span class="line">newseg-&gt;rto = kcp-&gt;rx_rto;</span><br><span class="line">newseg-&gt;fastack = <span class="number">0</span>;</span><br><span class="line">newseg-&gt;xmit = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate resent</span></span><br><span class="line"><span class="comment">// 失序多少次就快速重传。如果 fastresend 大于 0，则取其值；否则，设为最大值 0xffffffff。</span></span><br><span class="line">resent = (kcp-&gt;fastresend &gt; <span class="number">0</span>)? (IUINT32)kcp-&gt;fastresend : <span class="number">0xffffffff</span>;</span><br><span class="line"><span class="comment">// 最小超时重传时间。如果 nodelay 为 0，则为 rx_rto 的八分之一，否则为 0。</span></span><br><span class="line">rtomin = (kcp-&gt;nodelay == <span class="number">0</span>)? (kcp-&gt;rx_rto &gt;&gt; <span class="number">3</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flush data segments</span></span><br><span class="line"><span class="keyword">for</span> (p = kcp-&gt;snd_buf.next; p != &amp;kcp-&gt;snd_buf; p = p-&gt;next) &#123;</span><br><span class="line"><span class="comment">// 从 snd_buf 取出一个报文</span></span><br><span class="line">IKCPSEG *segment = iqueue_entry(p, IKCPSEG, node);</span><br><span class="line"><span class="type">int</span> needsend = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 条件1：第一次发送的报文，直接发送</span></span><br><span class="line"><span class="keyword">if</span> (segment-&gt;xmit == <span class="number">0</span>) &#123;   <span class="comment">//  该报文的 xmit 传输次数</span></span><br><span class="line">needsend = <span class="number">1</span>;</span><br><span class="line">segment-&gt;xmit++;</span><br><span class="line">segment-&gt;rto = kcp-&gt;rx_rto;</span><br><span class="line">segment-&gt;resendts = current + segment-&gt;rto + rtomin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_itimediff(current, segment-&gt;resendts) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 条件2：且重传时间到了，则重传</span></span><br><span class="line">needsend = <span class="number">1</span>;</span><br><span class="line">segment-&gt;xmit++;</span><br><span class="line">kcp-&gt;xmit++;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;nodelay == <span class="number">0</span>) &#123;</span><br><span class="line">segment-&gt;rto += _imax_(segment-&gt;rto, (IUINT32)kcp-&gt;rx_rto);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">IINT32 step = (kcp-&gt;nodelay &lt; <span class="number">2</span>)?</span><br><span class="line">((IINT32)(segment-&gt;rto)) : kcp-&gt;rx_rto;</span><br><span class="line">segment-&gt;rto += step / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">segment-&gt;resendts = current + segment-&gt;rto;</span><br><span class="line">lost = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (segment-&gt;fastack &gt;= resent) &#123;</span><br><span class="line"><span class="comment">// 条件3：达到快速重传次数，则重传</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)segment-&gt;xmit &lt;= kcp-&gt;fastlimit ||</span><br><span class="line">kcp-&gt;fastlimit &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">needsend = <span class="number">1</span>;</span><br><span class="line">segment-&gt;xmit++;</span><br><span class="line">segment-&gt;fastack = <span class="number">0</span>;</span><br><span class="line">segment-&gt;resendts = current + segment-&gt;rto;</span><br><span class="line">change++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needsend) &#123;</span><br><span class="line"><span class="type">int</span> need;</span><br><span class="line">segment-&gt;ts = current;</span><br><span class="line">segment-&gt;wnd = seg.wnd;</span><br><span class="line">segment-&gt;una = kcp-&gt;rcv_nxt;</span><br><span class="line"></span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line">need = IKCP_OVERHEAD + segment-&gt;len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size + need &gt; (<span class="type">int</span>)kcp-&gt;mtu) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">ptr = buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ptr = ikcp_encode_seg(ptr, segment);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (segment-&gt;len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(ptr, segment-&gt;data, segment-&gt;len);</span><br><span class="line">ptr += segment-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果某个数据包的重传次数超过阈值，则标记连接断开。</span></span><br><span class="line"><span class="keyword">if</span> (segment-&gt;xmit &gt;= kcp-&gt;dead_link) &#123;</span><br><span class="line">kcp-&gt;state = (IUINT32)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flash remain segments</span></span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update ssthresh</span></span><br><span class="line"><span class="comment">// 1. 如果发生了快速重传，让 ssthresh 减半，进入快恢复</span></span><br><span class="line"><span class="keyword">if</span> (change) &#123;</span><br><span class="line">IUINT32 inflight = kcp-&gt;snd_nxt - kcp-&gt;snd_una;</span><br><span class="line">kcp-&gt;ssthresh = inflight / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;ssthresh &lt; IKCP_THRESH_MIN)</span><br><span class="line">kcp-&gt;ssthresh = IKCP_THRESH_MIN;</span><br><span class="line">kcp-&gt;cwnd = kcp-&gt;ssthresh + resent;</span><br><span class="line">kcp-&gt;incr = kcp-&gt;cwnd * kcp-&gt;mss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果发生了超时重传，则让 ssthresh 减半，然后 cwnd = 1，进入慢启动</span></span><br><span class="line"><span class="keyword">if</span> (lost) &#123;</span><br><span class="line">kcp-&gt;ssthresh = cwnd / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;ssthresh &lt; IKCP_THRESH_MIN)</span><br><span class="line">kcp-&gt;ssthresh = IKCP_THRESH_MIN;</span><br><span class="line">kcp-&gt;cwnd = <span class="number">1</span>;</span><br><span class="line">kcp-&gt;incr = kcp-&gt;mss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兜底，cwnd 至少为 1</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;cwnd &lt; <span class="number">1</span>) &#123;</span><br><span class="line">kcp-&gt;cwnd = <span class="number">1</span>;</span><br><span class="line">kcp-&gt;incr = kcp-&gt;mss;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://github.com/skywind3000/kcp">KCP repo</a></li><li><a href="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP协议的原理和实现</a></li></ul>]]></content>
    
    
    <summary type="html">本文详细介绍了游戏开发中常用的网络协议 KCP 的底层原理和源码实现。通过大量图示和原理总结,帮助读者深入理解 KCP 协议的工作机制，包括其快速重传、选择性确认、流量控制等核心特性。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="KCP" scheme="https://hedon.top/tags/KCP/"/>
    
    <category term="TCP" scheme="https://hedon.top/tags/TCP/"/>
    
    <category term="网络" scheme="https://hedon.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Rust 训练营总结丨第三次入门 Rust</title>
    <link href="https://hedon.top/2024/11/26/rust-bootcamp/"/>
    <id>https://hedon.top/2024/11/26/rust-bootcamp/</id>
    <published>2024-11-26T11:10:08.000Z</published>
    <updated>2025-03-03T11:32:53.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起">缘起</h1><p>2023年我给自己定了很多个目标，最终的结果是每个都做了一些事情，但是没有一个是做得比较彻底的，印证了《孙子兵法》的那句：“无所不备，则无所不寡”。</p><p>在 2023.10.23 出于好奇，我订阅了《Rust语言从入门到实战》的专栏，跟着课程的更新节奏学习完了整个专栏。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Rust%E8%AF%AD%E8%A8%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E7%BB%93%E8%AF%BE%E8%AF%81%E4%B9%A6.png" alt="Rust语言从入门到实战结课证书" style="zoom:33%;" /></p><p>虽然我第一次入门 Rust 失败了，但也被 Rust的种种特性所吸引。我是个特别喜欢“痛苦前置”的人，而 Rust编译器"睚眦必报"的编译器检查正给予了我被虐的爽感，编译通过后程序的稳定运行也符合我追求成为一位“靠谱”工程师的愿景。</p><p>加之我的主力语言是Go，一门应用编程语言，所以我一直希望学习一门系统编程语言，以期将来有能力窥探一些底层的细节原理。C/C++太古老了，特性太多了，大神太多了，我怎么学都不可能赶得上别人，嘿嘿，学个新的，大家都没学过，这不就舒服了么。</p><p>后来极客时间决定开设《Rust 训练营》，讲师是<ahref="https://www.zhihu.com/people/tchen">陈天</a>老师，我去搜了关于陈天老师的一些资料，看了一些他写的文章和技术分享视频，甚至油管上还有他之前面试的视频。OK，这个人得到了我的认可，我想跟这样的人交个朋友，哪怕只是加个微信，至少我多了个口子，得以窥探精英阶层人士的生活一角。</p><p>结合 2023 年的教训，2024年年初我就给自己制定了一年的目标，只有一个，就是<strong>踏踏实实、完完整整学习完整个Rust 训练营，其他所有事情和目标，都要为其让步</strong>。</p><blockquote><p>其实是 2 个目标 hhh，另外一个目标是：完成人生的第一场半程马拉松。</p></blockquote><h1 id="筑基">筑基</h1><p>为了更好服务于《Rust 训练营》，在 1-4 月份，我花了差不多 3个多月的时间啃下了<ahref="https://book.douban.com/subject/36547630/">《Rust程序设计（第二版）》</a>，对整个 Rust的语言特性建立了更加完善的体系基础，也多奠定了一些基础，当然，这是我第二次入门Rust 失败。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241127172804063.png" alt="Rust 程序设计（第二版）阅读计划" style="zoom: 25%;" /></p><h1 id="修炼">修炼</h1><p>4 月 18 号开营，本来是预计 7月份结营的，不过陈天老师分享的欲望刹不住车，硬是“拖堂”到了 11 月 22号。事实上，这是有点难受的，一个事情拖太久，思维上很容易疲惫，懒惰也愈难克服。不过从消费者的角度，这是赚翻了，毕竟，学着学着，花呗的12 期无息分期也差不多要还完了。</p><p>所以，其实一个 1095 的程序员，在 4.20 到 11.22 是可以花 279 小时 54分钟学完 202 讲课程的。</p><blockquote><p>即使你将来不使用Rust，相信你学完这门课程后也能成为一位更好的软件工程师。 —— 陈天</p></blockquote><p>是的，在学习中，更多时候感受到的不仅仅是在学习Rust，而是在重学软件工程，我开始切身接触优秀的软件开发具备了哪些不可或缺的流程。为了效仿这些优秀的思想和实践，在实际工作中，今年我做了一些尝试：</p><ol type="1"><li>引入更丰富的 CI/CD流程，尽可能发挥机器的能力，让机器不厌其烦地做那些的重复劳动，而这些不起眼的重复劳动，却能以最小代码为我们排查出最多难以发现的“失误”BUG。</li><li>开始学习写单测，开始学习如何将代码写得能单测、易单测，学习着如何将那些不能单测的💩代码改造成可单测的代码，也将单测运行加入了CI/CD的流程中。在单测多次帮我揪出那些我意识不到的不小心改错的逻辑的时候，我才切身感受到单测的作用，也真正理解了“写单测并不会影响开发效率，如果影响了，那也是提高了开发效率”。幸运的是，截至目前（11.27），我已经连续2 次，在上千行代码的需求开发中，提测阶段和线上发布阶段，都是 0Bug，运气不错。</li><li>引入监控系统，在指标上，存储层、应用层、业务层和网关层进行分层监控，在开发时，从业务无关组件（<ahref="https://github.com/hedon954/goapm">goapm</a>），到业务相关通用组件，最后再到应用程序特定组件的分阶段分层次开发，开始学习着“先解决业务背后的领域问题，顺带解决业务问题”。</li><li>开始思考一些架构层面的东西，开始思考一些代码组织、接口契约、领域模块划分的问题，以期写出质量更好的代码。</li></ol><p>为了支撑上面这些事情，今年我又顺带读了一些书，我是个很少读书的人，因为我总觉得：“读书好慢”。而且我读书也确实很慢，主要是，很困😅。然而，当我回望来时路，一切却都在我的意料之外。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241127180300408.png"alt="hedon 2024 的书单" /><figcaption aria-hidden="true">hedon 2024 的书单</figcaption></figure><p>这个时候我才知道：</p><ul><li>慢就是快</li><li>少就是多</li></ul><h1 id="历劫">历劫</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241127161520649.png"alt="rust-road" /><figcaption aria-hidden="true">rust-road</figcaption></figure><p>这些书其实都不在我的计划之内，因为 2024 我只有一个目标：<strong>完成Rust训练营的学习</strong>。它们只不过是我完成既定计划之余的加餐罢了。</p><p>而幸好我只有一个目标，所以才能有更多时间和精力去应对跟随训练营学习中的一些困难：</p><ul><li>晚上 9 点下班，真累啊，休息下吧，真不想学了。</li><li>工作了一周，真累啊，周末要不就休息吧，真不想学了。</li><li>编译器报错好多啊，算了，要不直接 copy 现成的代码吧。</li><li>这知识点在讲啥啊，算了，先不懂装懂吧，后面还那么多课，先赶进度再说。</li><li>前端和客户端的知识，好像跟我没啥关系，算了，不听了，过过过。</li><li>单测我就不写了，浪费时间。</li><li>学完咯，感觉没啥好总结的，算了，下一个吧。</li><li>....</li></ul><p>运气不错，上述的 n 多种情况，至少在 50-70% 的时候，我能做到：</p><ul><li>学一下再说，累了再停。</li><li>下午出去玩，早上先学了再说。</li><li>算了，狠点，盲写，自己尝试解决一下，咦，也就那么回事。写完后再对比下，哦，其实这块没听懂。</li><li>弄懂再说，多听几遍课，重新看几遍书，再搜一些相关博客，哦，这个知识点是这个意思，读书百遍其义自见原来是这味？</li><li>算了，试试现在 LLM 是否如吹的那么牛，嗯，好像用 LLM来实现前端和客户端的基础功能还真可以，也没那么无聊嘛。</li><li>算了，先试着写下单测吧。哦，我的代码这么难测啊，哦，这行代码怎么就犯蠢了呢，哦，花不了多少时间嘛。</li><li>要不还是总结下吧，哦，原来这个地方是这个意思，哦，原来还讲到了这个点。</li></ul><p>所以这个时候我又知道了：</p><ul><li>慢就是快</li><li>少就是多</li></ul><h1 id="小成">小成</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">➜  hedon-rust-road ll</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  21 wangjiahan  staff   672B Nov 27 18:26 aicomm</span><br><span class="line">drwxr-xr-x  23 wangjiahan  staff   736B Sep 11 13:55 chat</span><br><span class="line">drwxr-xr-x  17 wangjiahan  staff   544B Sep 11 18:31 chatapp</span><br><span class="line">drwxr-xr-x  26 wangjiahan  staff   832B Nov 27 18:26 crm</span><br><span class="line">drwxr-xr-x  22 wangjiahan  staff   704B Nov 27 18:26 dino</span><br><span class="line">drwxr-xr-x  16 wangjiahan  staff   512B Nov 27 18:29 error-info</span><br><span class="line">drwxr-xr-x  18 wangjiahan  staff   576B Sep  4 19:00 hackernews</span><br><span class="line">drwxr-xr-x  22 wangjiahan  staff   704B Sep 12 15:54 hedon-bot</span><br><span class="line">drwxr-xr-x   9 wangjiahan  staff   288B Nov 27 18:29 httpie</span><br><span class="line">drwxr-xr-x  13 wangjiahan  staff   416B Aug 22 10:40 inverted-index-concurrency</span><br><span class="line">drwxr-xr-x   7 wangjiahan  staff   224B Nov 27 18:28 json-macro</span><br><span class="line">drwxr-xr-x  26 wangjiahan  staff   832B Sep  3 19:30 learn-ffi</span><br><span class="line">drwxr-xr-x   8 wangjiahan  staff   256B Nov 27 18:29 learn-proc-macro</span><br><span class="line">drwxr-xr-x   7 wangjiahan  staff   224B Nov 27 18:30 mandelbrot</span><br><span class="line">drwxr-xr-x  10 wangjiahan  staff   320B Aug 22 10:40 matrix-multi</span><br><span class="line">drwxr-xr-x   7 wangjiahan  staff   224B Nov 27 18:29 pest-parser-collection</span><br><span class="line">drwxr-xr-x  19 wangjiahan  staff   608B Nov 27 18:27 r-redis</span><br><span class="line">drwxr-xr-x  21 wangjiahan  staff   672B Aug 22 10:40 rcli</span><br><span class="line">drwxr-xr-x  17 wangjiahan  staff   544B Aug 22 10:40 simple-chat</span><br><span class="line">drwxr-xr-x  17 wangjiahan  staff   544B Aug 22 10:40 simple-shortener</span><br><span class="line">drwxr-xr-x  21 wangjiahan  staff   672B Aug 22 10:40 taotie</span><br><span class="line">drwxr-xr-x@ 18 wangjiahan  staff   576B Nov 27 15:38 thumbor</span><br><span class="line">drwxr-xr-x  19 wangjiahan  staff   608B Aug 29 10:56 winnow-parser-collection</span><br><span class="line">➜  hedon-rust-road tokei -t rust</span><br><span class="line">===============================================================================</span><br><span class="line"> Language            Files        Lines         Code     Comments       Blanks</span><br><span class="line">===============================================================================</span><br><span class="line"> Rust                  336        25451        21615          644         3192</span><br><span class="line"> |- Markdown            53          546            0          476           70</span><br><span class="line"> (Total)                          25997        21615         1120         3262</span><br><span class="line">===============================================================================</span><br><span class="line"> Total                 336        25451        21615          644         3192</span><br><span class="line">===============================================================================</span><br></pre></td></tr></table></figure><p>看老师画了那么多牛逼的图，要不“邯郸学步”模仿一下吧。故而又忍着“下一个吧”的念头，梳理了下这几个月到底做了些什么。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/8abb5b2a2f3020ca36f75087ae76a53c.PNG"alt="rcli" /><figcaption aria-hidden="true">rcli</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/4ac783c6adaa38a45853861753112e35.PNG"alt="r-redis" /><figcaption aria-hidden="true">r-redis</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/4bdd0cba75aa773c6f4e941cf5c5fe29.PNG"alt="macro-json" /><figcaption aria-hidden="true">macro-json</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/969e023d9003b3c28ea1c95a7c1d9388.PNG"alt="macro-error-info" /><figcaption aria-hidden="true">macro-error-info</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/f25b8a0f1c95ac306ecda6c4ff3954a3.PNG"alt="rust-ecosystem" /><figcaption aria-hidden="true">rust-ecosystem</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/d04da8bf3577f1d09b7fce647451a700.PNG"alt="crm" /><figcaption aria-hidden="true">crm</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/c85939619088cda8c9a763ba514d235e.PNG"alt="taotie" /><figcaption aria-hidden="true">taotie</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/2d3892c57b0742707c6ff3a1267f532a.PNG"alt="dino" /><figcaption aria-hidden="true">dino</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/874082e0f9f9410f342d875f8559bd15.PNG"alt="aicomm" /><figcaption aria-hidden="true">aicomm</figcaption></figure><h1 id="归元">归元</h1><ul><li>知是行之始，行是知之成。</li><li>遇事不决，可问春风。春风不语，既随本心。</li></ul><p>2025 见！</p>]]></content>
    
    
    <summary type="html">本文记录了我在 Rust 训练营的学习历程，也映射了我 2024 年全年的成长轨迹。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="总结" scheme="https://hedon.top/categories/Rust/%E6%80%BB%E7%BB%93/"/>
    
    <category term="2024" scheme="https://hedon.top/categories/Rust/%E6%80%BB%E7%BB%93/2024/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 负载均衡挑战及解决思路</title>
    <link href="https://hedon.top/2024/05/20/kafka-load-balance/"/>
    <id>https://hedon.top/2024/05/20/kafka-load-balance/</id>
    <published>2024-05-20T02:37:10.000Z</published>
    <updated>2025-03-03T11:31:28.079Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自 Agoda Engineering，介绍了在实际应用中，如何应对 Kafka负载均衡所遇到的各种挑战，并提出相应的解决思路。本文简要阐述了 Kafka的并行性机制、常用的分区策略以及在实际操作中遇到的异构硬件、不均匀工作负载等问题。通过深入分析这些挑战，并提供具体的解决方案，本文旨在帮助读者更好地理解和应用Kafka 的负载均衡技术，从而提高系统的整体性能和稳定性。</p><p>以下大部分内容翻译自原文 <ahref="https://medium.com/agoda-engineering/how-we-solve-load-balancing-challenges-in-apache-kafka-8cd88fdad02b">how-we-solve-load-balancing-challenges-in-apache-kafka</a>，并已获得原作者同意。</p><h1 id="思维导图">思维导图</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Kafka%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"alt="Kafka 负载均衡解决方案" /><figcaption aria-hidden="true">Kafka 负载均衡解决方案</figcaption></figure><h1 id="kafka-并行性">Kafka 并行性</h1><p>Kafka通过分区来实现并行性，如下图所示，生产者（Producer）产生的消息会按照一定的分区策略分配到多个分区（Partition）中，消费组中的每个消费者会分别负责消费其中的若干个分区。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*ixosAmhBDsyBBhoS.png"alt="Kafka 分区演示" /><figcaption aria-hidden="true">Kafka 分区演示</figcaption></figure><p>分区策略：</p><ul><li>轮询（Round Robin）：默认情况下，Kafka使用轮询策略将消息均匀地分配到所有分区。</li><li>哈希（Key Hashing）：如果消息有分区键，Kafka会对键进行哈希计算，将消息分配到特定的分区。</li><li>自定义分区策略：开发者可以实现自定义的分区器（Partitioner）逻辑，以满足特定需求。</li></ul><p>如果要使用轮询或者哈希策略来达到“负载均衡”的目的，那么需要满足以下 2个假设：</p><ol type="1"><li>消费者拥有相同的处理能力，</li><li>消息的工作量相等。</li></ol><p>然而，在实践中，这些假设往往不成立。</p><h1 id="现实挑战">现实挑战</h1><h2 id="异构硬件">1. 异构硬件</h2><p>不同代的服务器硬件性能不同，导致处理速率存在差异。例如，使用不同代硬件进行处理的基准显示性能存在显着差异：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1*B6svY0ZjYVy-uJ7ZA18Jtg.png"alt="不同服务器处理速率差异举例" /><figcaption aria-hidden="true">不同服务器处理速率差异举例</figcaption></figure><h2 id="每条-kafka-消息的工作负载不均匀">2. 每条 Kafka消息的工作负载不均匀</h2><p>下图显示了在一个时间窗口内到达的 12条消息。在这里，生产者向该主题中的六个分区中的每一个发布两条消息。因此，每个worker 消耗来自 2 个分区的数据，这意味着每个 worker 需要处理 4条消息。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*VwPda5gNsHRL2tJV.png"alt="使用循环分区器和循环分配器来分发消息的先前供应系统的演示。每个 worker 都分配有相同数量的消息。" /><figcaptionaria-hidden="true">使用循环分区器和循环分配器来分发消息的先前供应系统的演示。每个worker 都分配有相同数量的消息。</figcaption></figure><p>不同的消息可能需要不同的处理步骤集。例如，处理消息可能涉及调用第三方HTTP端点，并且不同的响应大小或延迟可能会影响处理速率。此外，对于涉及数据库操作的应用程序，其数据库查询的延迟可能会根据查询参数而波动，从而导致处理速率发生变化。</p><h2 id="过度配置问题">3. 过度配置问题</h2><p>由于工作负载和处理效率不同，为了达到系统吞吐量的需求，可能会出现过度配置问题，从而导致资源浪费。</p><p>假设我们的高吞吐量和低吞吐量的处理速率分别为 20 msg/s 和 10msg/s（根据表 1中的数据进行简化）。使用两个较快的处理器和一个较慢的处理器，我们预计总容量为20+20+10 = 50条消息/秒。但是，当保持消息的循环分配时，我们无法达到此容量。下图显示了如果流量持续达到每秒50 条消息时会发生什么情况。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*P-Qa3gyPgXtIeZMx.png"alt="如果传入流量保持在 50 条消息/秒，则慢速处理器无法处理总体消息 1/3 的负载，从而导致累积延迟。为了避免高延迟，向该系统添加了额外的资源以维持处理。" /><figcaption aria-hidden="true">如果传入流量保持在 50条消息/秒，则慢速处理器无法处理总体消息 1/3的负载，从而导致累积延迟。为了避免高延迟，向该系统添加了额外的资源以维持处理。</figcaption></figure><p>从这个例子中我们可以看到，我们的处理器服务一次最多只能接受 30条消息，以防止滞后并确保及时传递更新。</p><p>在这种情况下，要实际每秒处理 50 条消息，我们必须总共扩展到 5台机器，以保证及时处理所有消息。由于这种不适当的分配逻辑（66.7％的过度配置），我们会向该系统过度配置额外的两台机器。</p><p>为了每秒处理 50条消息，我们需要扩展到五台机器以确保及时处理所有消息。由于这种不适当的分配逻辑（66.7%的过度配置），这会导致向该系统过度配置两台额外的机器。</p><h1 id="静态解决方案">静态解决方案</h1><h2 id="在相同的-pod机器上部署">1. 在相同的 Pod（机器）上部署</h2><p>考虑控制服务部署中使用的硬件类型以缓解问题。如果您在虚拟机上部署服务并拥有充足的资源和性能相同的硬件，则此方法是可行的。</p><p>然而，由于成本效益和灵活性下降，在私有云环境中通常不建议采用这种策略，主要是因为同时升级所有现有硬件可能具有挑战性。如果它非常适合您的情况，则可以使用<ahref="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/">Kubernetes关联性将 Pod 分配给某些类型的节点。</a></p><h2 id="加权负载均衡">2. 加权负载均衡</h2><p>如果容量是可预测的并且大部分时间保持静态，则为不同的消费者分配不同的权重可以帮助最大限度地利用可用资源。例如，在为表现较好的消费者赋予更高的权重后，我们可以将更多流量路由给这些消费者。</p><h1 id="动态解决方案">动态解决方案</h1><p>虽然我们可以估计消息的容量和工作负载来设计静态规则来确定加权负载平衡策略，但由于以下几个因素，这种方法在实际生产环境中可能并不总是可行：</p><ul><li>消息的工作负载并不统一，这使得估计机器容量变得困难。</li><li>依赖关系（例如网络和第三方连接）不稳定，有时会导致实际处理中的容量发生变化。</li><li>该系统经常添加新功能，增加额外的维护工作以保持权重更新。</li></ul><p>为了解决这些问题，我们可以动态监控每个分区中的当前滞后并根据当前流量状况做出相应响应。</p><p>有 2 种思路：</p><ol type="1"><li><strong>生产者角度</strong>：使用自定义算法根据滞后的消息数量来确定每个分区的流量，这种生产者称为滞后感知生产者（Lag-awareProducer）。</li><li><strong>消费者角度</strong>：这些消费者旨在监控当前滞后的消息数量，并可以在必要时取消订阅以触发负载重新平衡。通常，可以采用自定义的重新平衡策略来调整分区分配。这种消费者称为滞后感知消费者（Lag-awareComsumer）。</li></ol><h2 id="从生产者角度出发">1. 从生产者角度出发</h2><p>如此图所示，生产者可以使用自定义算法根据滞后确定每个分区的流量。为了减少对Kafka代理的调用次数，系统可以维护一个内部延迟缓存，而不是在发布每条消息之前调用Kafka 代理。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*Mg1lxKzMTy7LRAXT.png"alt="在此示例中，分区 4 和 6 的延迟比其他分区高得多。应减少从内部生产者发送到这些分区的流量。" /><figcaption aria-hidden="true">在此示例中，分区 4 和 6的延迟比其他分区高得多。应减少从内部生产者发送到这些分区的流量。</figcaption></figure><p>使用滞后数据，定制的算法被设计为向经历高滞后的分区发布更少的流量，向低滞后的分区发布更多流量，以平衡每个分区上的工作负载。当滞后平衡且稳定时，此方法应确保消息的均匀分布。</p><p>不适用情况：</p><ol type="1"><li><strong>纯消费者应用程序</strong>：您的应用程序不控制消息生成。</li><li><strong>多个消费者组：</strong>当生成的消息被多个消费者组消费时，生产者可能会为其他消费者组产生不必要的倾斜负载，因为滞后只是特定于一个消费者组的信息。</li></ol><h3 id="相同队列长度算法">相同队列长度算法</h3><p>该算法将每个分区滞后视为处理的队列大小。获取滞后信息后，它会发布适当数量的消息以填充短队列。此方法更适合由于异构硬件而导致的倾斜滞后分布，其中高性能Pod（机器）在大多数情况下能够更快地处理。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*zp-S1Y_GbIzbjCX4.png"alt="相同队列长度算法的演示。最初，不同队列的长度不同。该算法尝试生成不同数量的消息，以在所有队列中实现相同的队列长度。这里，队列长度和 Kafka lag 是同一个概念，代表尚未处理的消息数量" /><figcaptionaria-hidden="true">相同队列长度算法的演示。最初，不同队列的长度不同。该算法尝试生成不同数量的消息，以在所有队列中实现相同的队列长度。这里，队列长度和Kafka lag 是同一个概念，代表尚未处理的消息数量</figcaption></figure><h3 id="异常值检测算法">异常值检测算法</h3><p>该算法利用统计方法来确定所有分区的上离群值，并暂时停止那些慢速离群值的发布过程。在原文章中，针对Agoda 的特定需求，他们提出了 IQR（四分位距）和STD（标准差）异常值检测算法。算法流程图如下所示。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*pjkj5kF6aFcWwBwU.png"alt="异常值检查算法流程" /><figcaption aria-hidden="true">异常值检查算法流程</figcaption></figure><ul><li><strong>慢速分区：</strong>（已关闭）由于存在延迟，这些分区的消息生成已停止。</li><li><strong>好的分区</strong>：（打开）照常发布并均匀分发到所有好的分区。</li><li><strong>OK分区：</strong>（观察/半开放）为了提高性能不佳的机器的性能，当系统尝试将慢速分区提升为良好分区时，会添加一个观察期。通过仅生成一小部分消息并进行观察，可以将该观察阶段优化为“半开放”状态。当滞后获取间隔相对较长时，半开放是有益的，因为它可以防止消费者延迟等待传入消息而更新的滞后数据尚未查询的情况。</li></ul><h2 id="从消费者角度出发">2. 从消费者角度出发</h2><p>这里 Adoga提出的思路是：<strong>遇到高延迟的实例可以主动取消订阅主题以触发重新平衡。在重新平衡期间，可以使用自定义的分配器来平衡所有消费者实例之间的分区。</strong></p><p>触发重新平衡的成本非常昂贵，因为急切的重新平衡会停止消费者组中的所有处理。Kafka2.4中引入的<ahref="https://www.confluent.io/blog/incremental-cooperative-rebalancing-in-kafka/">增量协作再平衡协议</a>已经最大限度地减少了性能影响，允许更频繁的再平衡以更好地分配每个分区上的负载。</p><p>为了增强重新分配的灵活性，分区的数量应该大于 worker的数量。这一比率应根据应用程序而有所不同，并假设一个工作线程至少可以处理来自一个分区的负载以避免饥饿。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*68P7QtdFGeIzwZSs.png"alt="在此示例中，工作程序 3 在速度较慢的硬件上运行，导致分区 5 和 6 出现更高的延迟。因此，工作程序 3 可能会主动取消订阅主题以触发重新平衡并更有效地重新分配分区。在此示例中，应实现自定义分配器以根据机器指标和滞后信息重新分配分区。" /><figcaption aria-hidden="true">在此示例中，工作程序 3在速度较慢的硬件上运行，导致分区 5 和 6 出现更高的延迟。因此，工作程序 3可能会主动取消订阅主题以触发重新平衡并更有效地重新分配分区。在此示例中，应实现自定义分配器以根据机器指标和滞后信息重新分配分区。</figcaption></figure><h1 id="总结">总结</h1><p>本文从 Kafka 并行性的一般实现出发，探讨了 Kafka实现负载均衡在现实实践中可能遇到的各种挑战，并从静态调整和动态调整两个方面给出了解决思路，特别注重讨论了动态调整策略，并分别从生产者和消费者的角度提出了解决方案。</p><p>总之，通过在 Kafka中实现负载均衡，可以有效地将工作负载分配到可用资源之间，从而显著提高服务性能。具体的算法和策略需要根据实际情况进行选择和调整。</p>]]></content>
    
    
    <summary type="html">本文转载自 Agoda Enginnering, 介绍了 Kafka 负载均衡的实际应用过程中的负载均衡挑战及解决思路。</summary>
    
    
    
    <category term="Kafka" scheme="https://hedon.top/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://hedon.top/tags/Kafka/"/>
    
    <category term="中间件" scheme="https://hedon.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="消息队列" scheme="https://hedon.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>学习记录：用 Go 自制解释器 Monkey</title>
    <link href="https://hedon.top/2024/05/12/monkey-language/"/>
    <id>https://hedon.top/2024/05/12/monkey-language/</id>
    <published>2024-05-11T19:44:15.000Z</published>
    <updated>2025-03-03T11:31:41.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="词法分析">词法分析</h1><p>TDD：测试驱动开发</p><p>先写测试用例，再进行词法分析逻辑的完善。</p><h1 id="语法分析">语法分析</h1><p>递归下降语法分析伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">function parseProgram() &#123;</span><br><span class="line">    program = newProgramASTNode()</span><br><span class="line">    advanceTokens()</span><br><span class="line">    <span class="keyword">for</span> (currentToken() != EOF_TOKEN) &#123;</span><br><span class="line">        statement = null</span><br><span class="line">        <span class="keyword">if</span> (currentToken() == LET_TOKEN) &#123;</span><br><span class="line">            statement = parseLetStatement()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentToken() == RETURN_TOKEN) &#123;</span><br><span class="line">            statement = parseReturnStatement()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentToken() == IF_TOKEN) &#123;</span><br><span class="line">            statement = parseIfStatement()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (statement != null) &#123;</span><br><span class="line">            program.Statements.push(statement)</span><br><span class="line">        &#125;</span><br><span class="line">        advanceTokens()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> program</span><br><span class="line">&#125;</span><br><span class="line">function parseLetStatement() &#123;</span><br><span class="line">    advanceTokens()</span><br><span class="line">    identifier = parseIdentifier()</span><br><span class="line">    advanceTokens()</span><br><span class="line">    <span class="keyword">if</span> currentToken() != EQUAL_TOKEN &#123;</span><br><span class="line">        parseError(<span class="string">&quot;no equal sign!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> null</span><br><span class="line">    &#125;</span><br><span class="line">    advanceTokens()</span><br><span class="line">    value = parseExpression()</span><br><span class="line">    variableStatement = newVariableStatementASTNode()</span><br><span class="line">    variableStatement.identifier = identifier</span><br><span class="line">    variableStatement.value = value</span><br><span class="line">    <span class="keyword">return</span> variableStatement</span><br><span class="line">&#125;</span><br><span class="line">function parseIdentifier() &#123;</span><br><span class="line">    identifier = newIdentifierASTNode()</span><br><span class="line">    identifier.token = currentToken()</span><br><span class="line">    <span class="keyword">return</span> identifier</span><br><span class="line">&#125;</span><br><span class="line">function parseExpression() &#123;</span><br><span class="line">    <span class="keyword">if</span> (currentToken() == INTEGER_TOKEN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextToken() == PLUS_TOKEN) &#123;</span><br><span class="line">            <span class="keyword">return</span> parseOperatorExpression()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextToken() == SEMICOLON_TOKEN) &#123;</span><br><span class="line">            <span class="keyword">return</span> parseIntegerLiteral()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentToken() == LEFT_PAREN) &#123;</span><br><span class="line">        <span class="keyword">return</span> parseGroupedExpression()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br><span class="line">function parseOperatorExpression() &#123;</span><br><span class="line">    operatorExpression = newOperatorExpression()</span><br><span class="line">    operatorExpression.left = parseIntegerLiteral()</span><br><span class="line">    operatorExpression.operator = currentToken()</span><br><span class="line">    operatorExpression.right = parseExpression()</span><br><span class="line">    <span class="keyword">return</span> operatorExpression()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512042659060.png"alt="递归下降分析法" /><figcaption aria-hidden="true">递归下降分析法</figcaption></figure><h2 id="let-x5">let x=5</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512035446100.png"alt="let stmt AST structure" /><figcaption aria-hidden="true">let stmt AST structure</figcaption></figure><h2 id="return-5">return 5</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512045650041.png"alt="return stmt AST structue" /><figcaption aria-hidden="true">return stmt AST structue</figcaption></figure><h2 id="普拉特解析">普拉特解析</h2>]]></content>
    
    
    <summary type="html">本文主要是记录笔者在学习《用 Go 自制解释器 Monkey》过程中涉及的重要设计理念和思考。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="Go 实战" scheme="https://hedon.top/categories/Go/Go-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="编译原理" scheme="https://hedon.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>epoll</title>
    <link href="https://hedon.top/2024/04/28/epoll/"/>
    <id>https://hedon.top/2024/04/28/epoll/</id>
    <published>2024-04-28T12:27:29.000Z</published>
    <updated>2025-03-03T11:30:33.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><code>epoll</code> 是一种 I/O多路复用技术，主要用于高性能的网络服务器中，特别是在处理大量并发连接时。它是Linux 特有的，自 Linux 内核 2.5.44版本引入，并在后续版本中不断优化。<code>epoll</code>能够帮助服务器高效地管理数以千计的客户端连接，是 <code>select</code> 和<code>poll</code> 方法的现代替代品。</p><p>本文不对 <code>epoll</code>的源码进行分析，仅做原理上的总结，方便快速查阅回顾。各大论坛很多大佬都对<code>epoll</code>的源码进行了详尽的分析，感兴趣的读者可以看「参考」篇章。</p><h1 id="主要特点">主要特点</h1><ol type="1"><li><strong>效率高</strong>: 相较于 <code>select</code> 和<code>poll</code>，<code>epoll</code>可以更高效地处理大量的并发连接。<code>select</code> 和 <code>poll</code>的效率随着监视的文件描述符数量增加而线性下降，而 <code>epoll</code>则不会因为监视的文件描述符数量增加而显著降低效率。</li><li><strong>扩展性好</strong>: <code>epoll</code>使用一种称为事件通知的机制，只会处理那些真正发生了事件的文件描述符。这意味着系统不必重新检查所有文件描述符，从而大大减少了不必要的CPU 开销。</li><li><strong>支持边缘触发和水平触发</strong>: <code>epoll</code> 支持<code>Edge Triggered</code> 和水平触发 <code>Level Triggered</code>两种模式。边缘触发模式只在文件描述符状态改变时才通知应用程序，适用于非阻塞I/O；而水平触发模式则在有事件可读或可写时都会通知应用程序，更容易使用但效率略低。</li></ol><h1 id="结论先行">结论先行</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240429121302958.png"alt="epoll flow chart" /><figcaption aria-hidden="true">epoll flow chart</figcaption></figure><h1 id="工作原理">工作原理</h1><p><code>epoll</code> 的工作可以分为三个主要步骤：</p><ol type="1"><li><strong>创建 epoll 实例</strong>: 使用 <code>epoll_create</code>函数创建一个 <code>epoll</code> 实例。</li><li><strong>添加/修改/删除文件描述符</strong>: 使用<code>epoll_ctl</code> 函数将新的文件描述符添加到 <code>epoll</code>实例中，或者修改、删除已存在的文件描述符。这些操作与文件描述符的数量无关，因此执行速度非常快。</li><li><strong>等待事件发生</strong>: 使用 <code>epoll_wait</code>函数等待事件的发生。这个函数可以同时监控多个文件描述符，当指定的文件描述符上发生了注册的事件时，函数返回，并告知哪些文件描述符上发生了事件。</li></ol><h1 id="et-lt">ET &amp; LT</h1><p>在 <code>epoll</code> 中，边缘触发（ET, EdgeTriggered）和水平触发（LT, LevelTriggered）是两种不同的事件通知方式，它们定义了操作系统如何通知应用程序文件描述符上的I/O 事件。</p><p>这两种模式的主要区别在于何时以及如何多次通知应用程序关于某个文件描述符的事件。</p><h2 id="水平触发level-triggered">水平触发（Level Triggered）</h2><ul><li><strong>定义</strong>: 在水平触发模式下，只要文件描述符上有未处理的I/O 事件存在，<code>epoll_wait</code>就会通知应用程序。这意味着，如果数据可读取但未被完全读取，<code>epoll_wait</code>会在下次调用时再次返回该文件描述符。</li><li><strong>行为</strong>:这种模式更容易编程，因为应用程序可以不用担心在一个操作中处理所有数据。如果数据还在，<code>epoll_wait</code>会继续通知你。</li><li><strong>适用场景</strong>:更适合那些简单的应用或者对实时性要求不是非常高的应用，因为它简化了处理逻辑。</li></ul><h2 id="边缘触发edge-triggered">边缘触发（Edge Triggered）</h2><ul><li><strong>定义</strong>:在边缘触发模式下，只有状态变化时（例如从无数据到有数据），<code>epoll_wait</code>才会通知应用程序。一旦通知了应用程序某事件发生，除非有新的数据到达或状态再次发生变化，否则不会再次通知应用程序该事件。</li><li><strong>行为</strong>:这要求应用程序必须立即处理所有事件，因为之后不会再收到关于这些事件的通知。这意味着应用程序必须循环读取或写入，直到数据被完全处理完，以确保不遗漏任何事件。</li><li><strong>适用场景</strong>:适合需要高性能的场景，因为它减少了事件处理的次数，但要求程序必须更加小心地管理I/O 操作。</li></ul><h2 id="比较和选择">比较和选择</h2><ul><li><strong>性能</strong>:边缘触发通常提供更高的性能，因为它减少了系统调用的次数和不必要的事件处理。</li><li><strong>编程复杂性</strong>:边缘触发模式编程比水平触发复杂，因为需要确保每次事件被彻底处理，并且更容易遇到如“惊群效应”（多个进程或线程被同一个事件唤醒）等问题。</li><li><strong>可靠性</strong>:水平触发因为其简单的行为模式，在可靠性处理上更为直接和容易。</li></ul><p>通常，选择哪种模式取决于应用的具体需求、预期的负载以及开发者对事件处理逻辑的控制程度。高性能服务器通常选择边缘触发模式，以最大化其效率，而简单的或者低负载应用可能会更倾向于使用水平触发，以简化开发和调试过程。</p><h1 id="数据结构">数据结构</h1><p><code>epoll</code> 使用 2种关键的数据结构来维护和跟踪文件描述符（FD）和事件：</p><ol type="1"><li><strong>红黑树（Red-Black Tree）</strong>:用于存储所有注册的文件描述符及其事件。红黑树是一种自平衡二叉搜索树，能够在对数时间内完成插入、删除和查找操作，这使得管理大量文件描述符变得高效。</li><li><strong>就绪列表（Ready List）</strong>:当事件发生（如可读、可写等）并被内核检测到时，相应的 FD会被添加到一个就绪列表中。这个列表仅包含实际有事件发生的文件描述符，从而减少了<code>epoll_wait</code> 调用的处理时间。</li></ol><h1 id="工作细节">工作细节</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/epoll_principle.jpg"alt="epoll data structure" /><figcaption aria-hidden="true">epoll data structure</figcaption></figure><ol type="1"><li>通过调用 <code>epoll_create()</code> 函数创建并初始化一个<code>eventpoll</code> 对象。</li><li>通过调用 <code>epoll_ctl()</code> 函数把被监听的文件句柄 (如 socket句柄) 封装成 <code>epitem</code> 对象并且添加到 <code>eventpoll</code>对象的红黑树中进行管理。</li><li>通过调用 <code>epoll_wait()</code>函数等待被监听的文件状态发生改变。</li><li>当被监听的文件状态发生改变时（如 socket接收到数据），会把文件句柄对应 <code>epitem</code> 对象添加到<code>eventpoll</code> 对象的就绪队列 <code>rdllist</code>中。并且把就绪队列的文件列表复制到 <code>epoll_wait()</code> 函数的<code>events</code> 参数中。</li><li>唤醒调用 <code>epoll_wait()</code> 函数被阻塞（睡眠）的进程。</li></ol><h1 id="事件监听">事件监听</h1><p>内核中的事件监听和回调机制是通过高效的事件驱动模型实现的，而不是简单的循环检查（如在用户空间中的轮询）。这种机制利用了现代操作系统的中断和回调系统，以及针对异步事件的优化处理策略。</p><p>以下是这个过程的详细解释：</p><h2 id="中断和中断处理">1. 中断和中断处理</h2><p>在硬件层面，大多数 I/O 操作（如网络通信、磁盘I/O）都是通过中断驱动的。当一个 I/O设备准备好数据或需要服务时，它会产生一个中断信号，这个信号被发送到CPU。CPU 响应中断，并执行一个预定的中断处理程序（Interrupt ServiceRoutine, ISR），该程序是由设备的驱动程序提供的。</p><h2 id="事件和回调">2. 事件和回调</h2><p>在 ISR中，与设备相关的事件（例如网络包的接收、硬盘读取完成）会被检测到，并且可以在此阶段调用特定的回调函数。这些回调函数是在设备驱动或相关的内核模块中定义的，用来通知内核其他部分或者相关的进程有关事件的发生。</p><h2 id="文件描述符的回调机制">3. 文件描述符的回调机制</h2><p>对于 <code>epoll</code> 等 I/O多路复用技术，内核为每个文件描述符维护了一个事件处理机制。当文件描述符被创建时，相关的设备或资源会注册一组回调函数，这些函数会在特定的操作（如读、写、错误）上被触发。例如，一个网络套接字可能会在数据到达时触发一个“可读”事件的回调。</p><h2 id="epoll-的事件绑定">4. <code>epoll</code> 的事件绑定</h2><p>当一个文件描述符被加入到 <code>epoll</code>监听队列中，<code>epoll</code>会利用这些回调来获得事件通知。<code>epoll</code>操作相关的代码会将一个额外的回调函数绑定到这些文件描述符上。当文件描述符的状态改变时（如数据可读），这个回调函数将被触发，然后它会将相应的文件描述符标记为“就绪”，并放入<code>epoll</code> 的就绪队列。</p><h2 id="事件通知和唤醒">5. 事件通知和唤醒</h2><p>当 <code>epoll_wait</code>被调用且有事件就绪时，内核会检查就绪队列，并将这些事件传递给等待的进程。如果没有事件就绪，进程将被挂起直到有事件发生。事件的发生会触发内核调度程序唤醒相应的进程。</p><h2 id="效率和性能">6. 效率和性能</h2><p>这种基于中断的事件通知机制意味着内核不需要不断循环检查每个文件描述符的状态，从而极大地提高了效率。事件只有在实际发生时才被处理，且处理通常是由硬件中断直接触发的，这使得整个系统更加响应快速，减少了无效的CPU 使用。</p><p>这种设计使得 Linux 内核在处理大量并发 I/O操作时能够保持高效和稳定，适合构建高性能的网络服务和应用。</p><h1 id="中断">中断</h1><p>中断机制是计算机硬件和操作系统核心功能之一，它允许外设或硬件异步地通知CPU 需要处理某些事件。中断机制的实现并不依赖于类似于 <code>for</code>循环的轮询检查，而是建立在更为直接和高效的硬件和处理器架构支持之上。</p><p>当 CPU接收到中断信号时，它是通过一套内建于硬件的协调机制来识别和响应中断的。这个过程涉及硬件电路设计、处理器架构和操作系统的中断管理功能。</p><p>以下是 CPU 如何知道有中断发生，并且如何处理这一中断的详细步骤：</p><h2 id="中断信号的检测和响应">中断信号的检测和响应</h2><ol type="1"><li><p><strong>中断请求线（IRQ）</strong>：外部设备通过连接到处理器的一个特定的硬件线路（IRQ）发送中断信号。这个线路直接与处理器内的中断控制单元（InterruptController）相连。</p></li><li><p><strong>中断控制器</strong>：大多数现代计算机系统使用一个或多个中断控制器来管理中断信号。中断控制器的任务是接收来自各种外部设备的中断请求，并将这些请求优先级排序后发送给CPU。</p></li><li><p><strong>中断向量</strong>：当中断控制器接收到一个中断信号后，它会根据中断源确定一个中断向量。这个向量是一个数字，指向中断向量表中对应的入口，该入口包含了处理该中断的中断服务例程（ISR）的地址。</p></li></ol><h2 id="cpu-如何处理中断">CPU 如何处理中断</h2><ol type="1"><li><p><strong>当前指令的完成</strong>：当 CPU接收到中断控制器发出的中断信号时，它首先会完成当前执行的指令。这是为了保证程序的状态能够正确保存，从而在中断处理完毕后可以无缝地恢复执行。</p></li><li><p><strong>保存上下文</strong>：一旦当前指令执行完毕，CPU会自动保存当前的程序状态，包括程序计数器（PC）、寄存器和其他必要的状态信息。这些信息通常被推送到当前的栈上。</p></li><li><p><strong>跳转到 ISR</strong>：CPU使用中断向量来访问中断向量表，找到与中断号对应的中断服务例程（ISR）的地址，并跳转到该地址开始执行ISR。这个过程是自动的，由处理器的内部机制控制。</p></li><li><p><strong>执行ISR</strong>：中断服务例程会执行必要的操作来处理中断，比如读取数据缓冲区、清除设备状态或发送信号等。</p></li><li><p><strong>恢复上下文并返回</strong>：一旦 ISR执行完成，处理器会从栈上恢复之前保存的程序状态，并将控制权返回到被中断的程序，继续执行。</p></li></ol><h2 id="硬件支持">硬件支持</h2><p>这一过程大量依赖于处理器的硬件支持，如中断向量表通常是固定在处理器的特定内存地址上的。此外，现代处理器如x86架构还提供了更高级的功能，比如支持多重中断控制器和高级可编程中断控制器（APIC）等。</p><p>这种基于硬件的中断响应机制允许 CPU快速有效地处理各种外部事件，确保系统的响应性和稳定性。</p><h1 id="参考">参考</h1><ul><li><ahref="https://blog.csdn.net/zhangyanfei01/article/details/114959103">图解| 深入揭秘 epoll 是如何实现 IO 多路复用的！</a></li><li><ahref="https://blog.csdn.net/zhpCSDN921011/article/details/125580548">一图总结epoll 的总体工作流程</a></li><li><ahref="https://thetechsolo.wordpress.com/2016/02/29/scalable-io-events-vs-multithreading-based/">scalable-io-events-vs-multithreading-based</a></li><li><ahref="https://github.com/liexusong/linux-source-code-analyze/blob/master/epoll-principle.md">Epoll实现原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/667412830">网络编程之 epoll源码深度剖析</a></li></ul>]]></content>
    
    
    <summary type="html">本文总结了高性能网络服务器中大量使用的 I/O 多路复用技术 epoll，涵盖工作原理、数据结构、事件监听和中断等相关内容。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="epoll" scheme="https://hedon.top/tags/epoll/"/>
    
    <category term="网络编程" scheme="https://hedon.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="非阻塞 I/0" scheme="https://hedon.top/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E-I-0/"/>
    
  </entry>
  
  <entry>
    <title>一文彻底掌握浮点数</title>
    <link href="https://hedon.top/2023/12/23/floating-point-number/"/>
    <id>https://hedon.top/2023/12/23/floating-point-number/</id>
    <published>2023-12-23T13:51:52.000Z</published>
    <updated>2025-03-03T11:30:38.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典问题">经典问题</h2><p>0.1 + 0.2 = ？</p><p>我们写个 Go 程序来测试一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f1 <span class="type">float64</span> = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">var</span> f2 <span class="type">float64</span> = <span class="number">0.2</span></span><br><span class="line">fmt.Println(f1+f2 == <span class="number">0.3</span>)</span><br><span class="line">fmt.Println(f1 + f2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line">0.30000000000000004</span><br></pre></td></tr></table></figure><p>如此违背 “常识”的结果，其实是因为当下计算机体系中小数的表示方式是浮点数，而计算机中对浮点数的表示并非百分百精确的，在表示和计算过程中都有可能会丢失精度。</p><p>这迫使必须深入理解浮点数在计算机中的存储方式及性质，才能正确处理关于数字的计算问题。</p><h2 id="结论先行">结论先行</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/IEEE-754%20%E6%B5%AE%E7%82%B9%E6%95%B0.jpg"alt="IEEE-754 浮点数" /><figcaption aria-hidden="true">IEEE-754 浮点数</figcaption></figure><h2 id="定点数">定点数</h2><p>要理解浮点数的第一步是考虑含有小数值的二进制数字。在这之前，我们来看看更加熟悉的十进制表示法：</p><p><span class="math display">\[d_md_{m-1} ··· d_1d_0 . d_{-1}d_{-2}··· d_{-n}\]</span></p><p>小数点 <code>.</code>左边是整数部分，右边是小数部分。其中每个十进制数 <code>di</code>的取值范围是 0~9。</p><p>如十进制的 <code>12.34</code> 即可以表示为：</p><p><span class="math display">\[1×10^1+2×10^0+3×10^{-1}+4×10^{-2}\]</span></p><p>那其实二进制也是一样的道理，只不过把其中的 <code>10</code> 换成<code>2</code>，而 <code>di</code> 的取值范围为 0~1。</p><p>如二进制的 <code>101.11</code> 可以表示为：</p><p><span class="math display">\[1×2^2+0×2^1+1×2^0+1×2^{-1}+1×2^{-2}\]</span></p><p>如果我们仅考虑有限长度的编码，那么十进制表示法不能准确表达像 1/3 和5/7这样的数。类似的，小数的二进制表示法只能表示那些能够被写成以下形式的数：</p><p><span class="math display">\[x × 2^y\]</span></p><p>其他的值就只能近似地表示。</p><p>定点数的整数部分是小数部分的位数是固定不变的，在位数有限的情况下，定点数的取值范围和精度都比较差。于是就有了IEEE-754 提出的浮点数表示法。</p><h2 id="浮点数">浮点数</h2><p>所谓“浮点数”（Floating-pointnumbers），即小数点可以“<strong>浮动</strong>”，即小数点的位置不是固定的，而是可以根据数值的大小和精度需求移动的。这种表示法允许在广泛的范围内表示数值，同时保持相对恒定的精度。</p><p>在计算机中，浮点数通常遵循 IEEE-754标准。这个标准定义了浮点数的存储和运算方式，确保了不同计算机系统之间的一致性。IEEE-754用以下形式来表示一个数：</p><p><span class="math display">\[V = (-1)^s×M×2^E\]</span></p><p>其中：</p><ul><li><strong>s 符号位（Sign bit）</strong>：表示数值的正负。</li><li><strong>M 尾数（Mantissa）</strong>：表示数值的有效数字。</li><li><strong>E 指数（Exponent）</strong>：决定小数点的位置。</li></ul><p>IEEE-754将浮点数的位表示划分成三个部分，分别对各个部分进行编码，对应上面公式右边的3 个字母：</p><ul><li>一个单独的符号位 <code>s</code> 直接编码符号 <code>s</code>。</li><li><span class="math inline">\(k\)</span> 位的阶码字段 <spanclass="math inline">\(exp=e_{k-1}\cdots e_1e_0\)</span> 编码阶码<code>E</code>。</li><li><span class="math inline">\(n\)</span> 位小数字段 <spanclass="math inline">\(frac=f_{n-1}\cdots f_1f_0\)</span> 编码尾数<code>M</code>，但是编码出来的值也依赖于阶码字段的值是否等于 0。</li></ul><p>在 IEEE-754 标准中，定义了两种精度的浮点数，分别是单精度浮点数（32位）和双精度浮点数（64 位）。</p><p>单精度：</p><ul><li>1 位符号位 s</li><li>8 位指数 exp</li><li>23 位尾数 frac</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224102703581.png"alt="单精度浮点数" /><figcaption aria-hidden="true">单精度浮点数</figcaption></figure><p>双精度：</p><ul><li>1 位符号位 s</li><li>11 位指数 exp</li><li>52 位尾数 frac</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224102756244.png"alt="双精度浮点数" /><figcaption aria-hidden="true">双精度浮点数</figcaption></figure><p>根据 <code>exp</code> 的值，浮点数又可以分成三类：</p><ol type="1"><li>规格化的</li><li>非规格化的</li><li>特殊的</li></ol><p>其中第三类“特殊的”又可以根据 <code>frac</code> 分成两类：</p><ol type="1"><li>无穷大</li><li>不是一个数 NaN（Not a Number）</li></ol><p>具体如下表所示：</p><table><thead><tr class="header"><th></th><th style="text-align: center;">exp</th><th style="text-align: center;">frac</th></tr></thead><tbody><tr class="odd"><td>规格化的</td><td style="text-align: center;">≠0 &amp; ≠ 255</td><td style="text-align: center;">f</td></tr><tr class="even"><td>非规格化的</td><td style="text-align: center;">0</td><td style="text-align: center;">f</td></tr><tr class="odd"><td>特殊的</td><td style="text-align: center;">1</td><td style="text-align: center;">f</td></tr><tr class="even"><td>- 无穷大</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr class="odd"><td>- NaN</td><td style="text-align: center;">1</td><td style="text-align: center;">≠0</td></tr></tbody></table><p>对于不同类型的浮点数，在计算公式 <spanclass="math inline">\(V=(-1)^s×M×2^E\)</span>中，<code>exp -&gt; E</code> 和 <code>frac -&gt; M</code>的方式有所不同。</p><p>下面我们来对这几种不同类型进行详细讨论，其中不乏有一些很有趣且充满智慧的设计理念。</p><h3 id="特殊值-special-values">特殊值 Special Values</h3><ul><li><strong>指数部分</strong>：全为 0。</li><li><strong>尾数部分</strong>：全为 0 则表示无穷大，不全为 0 则表示NaN。</li><li><strong>作用</strong>：特殊值用于表示那些无法用常规数值表示的情况，如无穷大、非数（NaN）等。这些值通常用于操作的错误或特殊情况的结果，如除以0、无效操作等。</li></ul><h3 id="规格化的值-normalize-values">规格化的值 Normalize Values</h3><ul><li><strong>指数部分</strong>：不全为 0 且不全为 1。</li><li><strong>尾数部分</strong>：可以是任意值。</li><li><strong>作用</strong>：用于表示大多数非零数值</li></ul><p>在规格化值中：</p><ul><li><span class="math inline">\(E=e-bias\)</span></li><li><span class="math inline">\(M=1+f\)</span></li></ul><p>其中 <code>e</code> 即为 <code>exp</code>，，<code>bias</code>是偏置量，它的值为 <span class="math inline">\(2^{k-1} -1\)</span>，其中<code>k</code> 为 <code>exp</code> 的位数，故：</p><ul><li>在单精度中，<spanclass="math inline">\(bias=2^{8-1}-1=2^7-1=128-1=127\)</span></li><li>在双精度中，<spanclass="math inline">\(bias=2^{11-1}-1=2^{10}-1=1024-1=1023\)</span></li></ul><p>其中 <code>f</code> 为 <code>frac</code> 表示的数，范围 <spanclass="math inline">\(0≤f&lt;1\)</span>。</p><p>所以一个规格化数，具体可以表示为：</p><p><span class="math display">\[V=(-1)^{sign}×1.frac×2^{(exp-bias)}\]</span></p><p>这里有 4 个问题：</p><ol type="1"><li>这个 <code>bias</code> 是什么？</li><li>为什么 <code>E</code> 要 <code>e</code> 去减掉一个<code>bias</code>？</li><li><code>bias</code> 的值是怎么定下的，如单精度为什么是 127，不是 126或 128？</li><li><code>M</code> 为什么需要 <code>f</code> 去加上一个<code>1</code>？</li></ol><p>下面我们来对这 4 个问题进行一一解答。</p><p><strong>第 1 个问题，这个 bias 是什么？</strong></p><blockquote><p><code>bias</code>是一个预设的偏移量，用于将指数部分的值偏移到全正数，从而简化处理。</p></blockquote><p><strong>第 2 个问题：为什么 E 要 e 去减去一个 bias？</strong></p><blockquote><p>先说结论：使用 bias（偏置指数，biasedexponent）可以允许浮点数以统一的方式表示，同时也使得浮点数的排序和比较变得简单。</p></blockquote><p>首先指数肯定得支持正负形式的出现，那么直接使用无符号整型来表示指数肯定是不行的，因为它无法表示负指数。暂时先抛开IEEE-754 定下的标准，我们可以尝试用补码来表示指数。</p><p>假设我们有两个 32 位的浮点数 <code>A</code> 和<code>B</code>，并且我们假设它们的指数部分使用 8 位二进制补码表示（这与IEEE-754 标准不同）。</p><ul><li><code>A</code>的二进制表示：<code>0 0000010 00000000000000000000000</code></li><li><code>B</code>的二进制表示：<code>0 1111110 00000000000000000000000</code></li></ul><p>在这里，第一位是符号位（0 表示正数），接下来的 8位是以补码形式表示的指数，剩下的 23 位是尾数。</p><p>我们想要比较这两个数的大小，需要怎么做呢？</p><p>我们先解析这 2 个数：</p><ul><li>符号位：对于 <code>A</code> 和 <code>B</code>，符号位都是0，表示这是两个正数。</li><li>指数部分（使用补码表示）<ul><li><code>A</code> 的指数为 <code>0000010</code>，解读为正数 +2。</li><li><code>B</code> 的指数为<code>1111110</code>，在补码表示中，这是一个负数。先加取反后加 1转换为正数 <code>00000010</code>，它表示 -2。</li></ul></li></ul><p>要比较这 2 个数：</p><ul><li>当我们比较 <code>A</code> 和 <code>B</code>时，首先需要考虑它们的指数。</li><li>指数 <code>A</code> 为 +2，而 <code>B</code> 为-2。即使它们的尾数部分相同（在这个例子中都是 0），<code>A</code>的实际值要大于<code>B</code>，因为正指数表示的数值范围远大于负指数。</li></ul><p>可以看出：使用补码表示指数增加了比较过程的复杂性，因为我们需要解读补码并考虑其正负。特别是在涉及到负指数的情况下，我们不能仅仅比较二进制表示的大小，而必须将补码转换为实际的数值，然后再进行比较。</p><p>现在回过头来看看 IEEE-754 的设计，假设我们有两个单精度（32 位）浮点数<code>A</code> 和 <code>B</code>：</p><ul><li><code>A</code>的二进制表示为：<code>0 10000010 00000000000000000000000</code></li><li><code>B</code>的二进制表示为：<code>0 01111110 00000000000000000000000</code></li></ul><p>解析这两个数：</p><ul><li><code>A</code>：符号位为 0（正数），指数部分为<code>10000010</code>（二进制，对应十进制的 130），尾数部分为全 0。</li><li><code>B</code>：符号位为 0（正数），指数部分为<code>01111110</code>（二进制，对应十进制的 126），尾数部分为全 0。</li></ul><p>计算实际指数值：单精度浮点数的偏置值 <code>bias</code> 为127，故：</p><ul><li><code>A</code> 的实际指数 <code>E = 130 - 127 = 3</code>。</li><li><code>B</code> 的实际指数 <code>E = 126 - 127 = -1</code>。</li></ul><p>比较这两个数：</p><ul><li>在减去 <code>bias</code>后，我们可以直接比较指数部分的二进制表示来确定数值的大小。</li><li>由于 <code>10000010</code>（130）大于<code>01111110</code>（126），因此我们可以直接得出 <code>A</code> 大于<code>B</code>，而无需考虑负指数的复杂表示问题。</li></ul><p>这个例子说明了通过减去偏置值，IEEE-754标准能够简化浮点数的比较和排序操作。偏置后的指数表示方法允许计算机以统一和高效的方式处理浮点数，无论它们的实际数值大小如何。</p><p><strong>第 3 个问题：bias 的值是怎么定下的，如单精度为什么是127，而不是 126 或 128？</strong></p><blockquote><p><code>bias</code>值的选择，是为了平衡正负指数的表示范围，并且充分利用指数部分的存储空间。</p></blockquote><p>以单精度为例，<code>exp</code> 占了 8 位，8位二进制可以表示的值的范围是 <spanclass="math inline">\([0,255]\)</span>。如果我们选择 127 作为<code>bias</code>，则存储的指数范围就是 <spanclass="math inline">\([-127,128]\)</span>。这样可以使得指数部分可以均匀地表示从负大数到正大数的范围（对称）。</p><p>在 IEEE-754 标准中，全 0 的指数表示为非规格化数或 0，而全 1的指数用于表示无穷大或 NaN）。选择 127 作为 <code>bias</code>可以在保留这些特殊值的同时，提供最大的有效指数范围。</p><p><strong>第 4 个问题：M 为什么需要 f 去加上一个 1？</strong></p><blockquote><p>在规格化数中隐含最高位 1是为了提高尾数部分的表示效率，从而增加精度。</p></blockquote><p>其实这跟科学计数法的很像的，为了确保浮点数表示的<strong>唯一性</strong>，IEEE-754规定规格化浮点数最高位一定是非零的。如果不规定最高位非零，同一个数可以有多种不同的浮点表示，例如，在二进制中<code>0.5</code> 可以表示为 <spanclass="math inline">\(1.0×2^{-1}\)</span>，也可以表示位 <spanclass="math inline">\(0.1×2^0\)</span> 或 <spanclass="math inline">\(0.01×2^1\)</span>等等。这种多重表示会使浮点运算变得复杂且低效。</p><p>那既然最高位总是 1，那就没必要显示存储了，还可以使尾数部分中多 1位的存储空间，从而允许存储更多的有效数字，以<strong>提高精度</strong>。</p><h3 id="非规格化的值-denormalized-values">非规格化的值 DenormalizedValues</h3><ul><li><strong>指数部分</strong>：全为 0。</li><li><strong>尾数部分</strong>：可以是任意值。</li><li><strong>作用</strong>：<ul><li>提供表示数值 0 的方法。因为规格化中 <spanclass="math inline">\(M≥1\)</span>，所以无法表示 0。</li><li>用于表示非常接近于 0的数值，这些数值太小，无法用规格化格式表示。它们填补了 0和最小规格化正数之间的间隙，提供了渐近于 0的连续表示，防止了所谓的“下溢”。</li></ul></li></ul><p>在非规格化值中：</p><ul><li><span class="math inline">\(E=1-bias\)</span></li><li><span class="math inline">\(M=f\)</span></li></ul><p>所以一个规格化数，具体可以表示为：</p><p><span class="math display">\[V=(-1)^{sign}×0.frac×2^{(1-bias)}\]</span></p><p>那这里又有 2 个问题了：</p><ol type="1"><li>为什么指数部分不是 <span class="math inline">\(0-bias\)</span> 而是<span class="math inline">\(1-bias\)</span>？</li><li>为什么 M 不需要隐含的 1 了？</li></ol><p><strong>第 1 个问题：为什么指数部分不是 0-bias 而是1-bias？</strong></p><blockquote><p>这是一个特殊的设计，旨在使非规格化数能够平滑地连接到规格化数的最小正值。</p></blockquote><p>最小的规格化数的指数为<code>1 - bias</code>。为了在数值上平滑地过渡到非规格化数，非规格化数的实际指数也被设定为<code>1 - bias</code>。这样，非规格化数就可以代表那些小于最小规格化正数的数值，而不会出现一个数值的“间隙”。</p><p><strong>第 2 个问题：为什么 M 不需要隐含的 1 了？</strong></p><blockquote><p>不包含隐含的 1 使得非规格化数能够在浮点数表示中填补 0和最小规格化数之间的空隙，提供对极小数值的连续表示。</p></blockquote><ul><li><strong>避免下溢</strong>：非规格化数通过允许尾数部分不以隐含的 1开始（而是以显式的 0开始），使得它们可以表示比最小规格化数还要小的数值。这对于避免数值下溢至0 非常重要，尤其是在累积了多次运算后的场合。</li><li><strong>精度牺牲</strong>：使用非规格化数的代价是牺牲了一些精度。由于没有隐含的最高位1，非规格化数的精度较低。但这是为了在非常小的数值范围内提供数值的连续性所做的必要妥协。</li></ul><h3 id="总结">总结</h3><p>规格化值、非规格化值和特殊值三种类型共同构成了 IEEE-754浮点数标准的完整表示体系，使得浮点数能够在计算机中有效低处理从非常小到非常大的数值范围，同时还能应对特殊的计算情况。</p><h3 id="举例">举例</h3><p>参考《深入理解计算机系统》，我们以 8 位浮点数为例，其中：</p><ul><li>1 位符号 s</li><li>4 位指数 exp</li><li>3 位尾数 frac</li></ul><p>可以算出 <spanclass="math inline">\(bias=2^{4-1}-1=2^3-1=8-1=7\)</span>。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/544558-20211104211145834-189368139.png"alt="8 位浮点数（≥0部分）" /><figcaption aria-hidden="true">8 位浮点数（≥0部分）</figcaption></figure><p>其中靠近 0 的是非规格化值：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224130157112.png"alt="8 位浮点数 - 非规格化值" /><figcaption aria-hidden="true">8 位浮点数 - 非规格化值</figcaption></figure><p>以 <code>0 0000 001</code> 为例：</p><p><span class="math display">\[V = (-1)^s×M×2^E \\= (-1)^s×0.frac×2^{1-bias} \\= (-1)^0×(0+(1/8))×2^{1-7} \\= 1×1/8×2^{-6} \\=2^{(-9)} \\= 1/512\]</span></p><p>再往下，就是规格化值：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224130849986.png"alt="8 位浮点数 - 规格化值" /><figcaption aria-hidden="true">8 位浮点数 - 规格化值</figcaption></figure><p>以 <code>0 0110 110</code> 为例：</p><p><span class="math display">\[V = (-1)^s×M×2^E \\= (-1)^s×1.frac×2^{e-bias} \\= (-1)^0×(1+6/8)×2^{6-7} \\=1×14/8×2^{-1} \\= 14/16 \\=7/8\]</span></p><h2 id="整型转为浮点型">整型转为浮点型</h2><p>下面以一个例子来直观感受一下一个整型是如何转为浮点型的。</p><p>现在我们有一个 int32 的整型<code>123</code>，我们希望将其转为单精度浮点型 <code>123.0</code>。</p><p><strong>1. 将整型用二进制表示出来</strong></p><p><span class="math display">\[12345_{(10)} = 1111011_{(2)}\]</span></p><p><strong>2. 规范化表示</strong></p><p><span class="math display">\[1111011= 1.111011×2^6\]</span></p><p><strong>3. 计算指数</strong></p><p><span class="math display">\[exp = 6 + 127 = 133_{(10)} = 10000101_{(2)}\]</span></p><p><strong>4. 确定尾数**</strong></p><p>这是个规范化值，所以 <code>1.frac</code> 的 <code>1</code>省略，又因为单精度浮点数 <code>frac</code> 占 23 位，所以我们需要在<code>111011</code> 后面再填 17 个 0，即：</p><p><span class="math display">\[frac = 111011 0000 0000 0000 0000 0\]</span></p><p><strong>5. 确定符号位</strong></p><p><span class="math display">\[s = 0_{(2)}\]</span></p><p><strong>6. 组合起来</strong></p><p><code>12345.0</code> =<code>0  10000101 11101100000000000000000</code></p><h2 id="浮点数舍入">浮点数舍入</h2><p>由于浮点数的表示具有固定的精度，在进行运算或表示时，经常会遇到无法精确表示的数值，这就需要采用舍入方法来近似表示这些数值。IEEE-754标准定义了几种不同的舍入模式，以适应不同的计算需求。</p><h3 id="舍入模式">舍入模式</h3><p><strong>最近舍入（Round to Nearest）</strong>:</p><ul><li>这是最常用的舍入模式，也是默认的模式。</li><li>规则是向最接近的可表示值舍入。如果精确结果位于两个可表示值的中点，通常舍入到最近的偶数（即尾数的最后一位为0）。</li><li>这种方法减少了累积误差，确保了在多次运算后的总体精度。</li></ul><p><strong>向零舍入（Round Toward Zero）</strong>:</p><ul><li>这种模式总是舍入到零的方向，即舍去小数部分。</li><li>对于正数，这相当于取下限，对于负数，相当于取上限。</li></ul><p><strong>向上舍入（Round Up）</strong>:</p><ul><li>无论正负，都向远离零的方向舍入。</li><li>对于正数，舍入后的值不小于原值；对于负数，舍入后的值不大于原值。</li></ul><p><strong>向下舍入（Round Down）</strong>:</p><ul><li>无论正负，都向接近零的方向舍入。</li><li>对于正数，舍入后的值不大于原值；对于负数，舍入后的值不小于原值。</li></ul><h3 id="舍入的影响">舍入的影响</h3><ul><li><strong>精度损失</strong>：由于固定的尾数位数，舍入可能导致精度的损失。</li><li><strong>舍入误差</strong>：舍入操作本身可能引入误差，这些误差在连续运算中可能会累积。</li><li><strong>选择合适的舍入模式</strong>：不同的舍入模式适合不同的应用场景。例如，金融计算可能更倾向于使用向零舍入，而科学计算通常使用最近舍入以减少累积误差。</li></ul><h3 id="实例">实例</h3><table><thead><tr class="header"><th>Mode</th><th style="text-align: center;">1.40</th><th style="text-align: center;">1.60</th><th style="text-align: center;">1.50</th><th style="text-align: center;">2.50</th><th style="text-align: center;">-1.50</th></tr></thead><tbody><tr class="odd"><td>最近舍入</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">-2</td></tr><tr class="even"><td>向零舍入</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">-1</td></tr><tr class="odd"><td>向上舍入</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">-1</td></tr><tr class="even"><td>向下舍入</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">-2</td></tr></tbody></table><h2 id="浮点数运算">浮点数运算</h2><p>因为浮点数本身就存在精度问题，所以浮点数运算在计算机中是一个近似过程，涉及到精确度的权衡、特殊值的处理、错误的传播，以及舍入规则的应用。</p><h3 id="浮点数加减">浮点数加减</h3><ol type="1"><li>浮点数加法和减法首先需要对操作数进行对齐，使得它们的指数相同。这可能涉及将尾数的二进制表示向右移位，可能导致精度损失。</li><li>然后执行加法或减法操作。</li><li>对结果进行规范化和舍入。</li></ol><p>注意，浮点数的加减法<strong>不满足</strong>结合律、交换律和分配律，这你简单分析下应该就可以理解了，这里不赘述了。</p><p>假设我们要在单精度浮点数格式下计算：</p><p><span class="math display">\[12.375 + 0.1 = ?\]</span></p><p><strong>第 1 步：转为二进制表示</strong></p><p>其中 12.375 我们可以用二进制精确表示：</p><p><span class="math display">\[12.375_{(10)} = 1100.011_{(2)}\]</span></p><p>而 0.1 就比较特殊了，用二进制表示的话它会无限循环。</p><blockquote><p>将十进制小数转换为二进制表示涉及到重复乘以 2的过程，并提取每次乘法后整数部分作为二进制位。这个过程是一个不断重复的过程，直到小数部分变为0 或开始循环。</p></blockquote><ol type="1"><li><p>取 <code>0.1</code> 的小数部分乘以 2（即<code>0.1 × 2 = 0.2</code>），整数部分是 <code>0</code>，小数部分是<code>0.2</code>。</p></li><li><p>再次取小数部分乘以 2（即 <code>0.2 × 2 = 0.4</code>），整数部分是<code>0</code>，小数部分是 <code>0.4</code>。</p></li><li><p>继续这个过程，我们得到以下序列：</p><p><code>0.4 × 2 = 0.8</code> → 整数部分 <code>0</code></p><p><code>0.8 × 2 = 1.6</code> → 整数部分 <code>1</code></p><p><code>0.6 × 2 = 1.2</code> → 整数部分 <code>1</code></p><p><code>0.2 × 2 = 0.4</code> → 整数部分 <code>0</code></p><p>…（循环开始）</p></li></ol><p>所以，<code>0.1</code> 的二进制表示开始为<code>0.0001100110011…</code>，并且这个模式会无限循环下去。</p><p><strong>第 2 步：规格化</strong></p><p>回顾一下这张图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224102703581.png"alt="单精度浮点数" /><figcaption aria-hidden="true">单精度浮点数</figcaption></figure><p>所以 12.375 规格化表示为：</p><ul><li>先规范化为 1.xxxx 形式： <span class="math inline">\(1100.011_{(2)}= 1.100011 × 2^3\)</span></li><li>指数为：<span class="math inline">\(3 + 127 = 130 =10000010_{(2)}\)</span></li><li>尾数为：<spanclass="math inline">\(10001100000000000000000（23\;位，右边补\;0）\)</span></li><li>汇总：<spanclass="math inline">\(0\;10000010\;10001100000000000000000\)</span></li></ul><p>而 0.1 由于无限循环，我们在单精度下只能保留 23位，并采用<strong>最近舍入</strong>，所以 0.1 规格化表示为：</p><ul><li>先规范为 1.xxxx 形式：<spanclass="math inline">\(0.00011001100110011001100(循环) =1.10011001100110011001100 × 2^-4\)</span></li><li>指数为：<span class="math inline">\(-4 + 127 = 123 =01111011_{(2)}\)</span></li><li>尾数为：<spanclass="math inline">\(10011001100110011001100\)</span></li><li>汇总：<spanclass="math inline">\(0\;01111011\;10011001100110011001100\)</span></li></ul><p><strong>第 3 步：对齐指数</strong></p><p>先把 2 个浮点表示放在一起，好对比：</p><ul><li><spanclass="math inline">\(0\;10000010\;10001100000000000000000\)</span></li><li><spanclass="math inline">\(0\;01111011\;10011001100110011001100\)</span></li></ul><p>将两个数的指数对齐，较小的指数增加，同时相应地调整尾数。</p><p>这里需要调整将 <code>0.1</code> 的指数从 <code>01111011</code> 调整到<code>10000010</code>，这里加了 <code>7</code>，所以 <code>0.1</code>的尾数 <code>1.10011001100110011001100</code>需要右移 <code>7</code>位，即：<code>0.00000011001100110011001</code>。</p><p><strong>第 4 步：相加</strong></p><p>现在两个数的指数相同了，我们可以直接把它们的尾数相加：</p><p><span class="math display">\[\;\;\;1.10001100000000000000000 \\+\;0.00000011001100110011001 \\=\;1.10001111001100110011001\]</span></p><p><strong>第 5 步：规范化结果</strong></p><p>这里无需规范化。</p><p><strong>第 6 步：舍入</strong></p><p>这里没有进位，不需要舍入。</p><p><strong>第 7 步：浮点化表示</strong></p><p><span class="math display">\[0\;10000010\;10001111001100110011001\]</span></p><p><strong>第 8 步：转为十进制</strong></p><p><span class="math display">\[V =(-1)^s×M×2^E \\= (-1)^s×1.frac×2^{e-bias} \\= 1.10001111001100110011001 × 2^3 \\= 1100.01111001100110011001_{(2)} \\= 12.47499942779541015625_{(10)} \\≈ 12.475_{(10)}\]</span></p><h3 id="浮点数乘法">浮点数乘法</h3><ol type="1"><li><strong>符号位计算</strong>：结果的符号由两个操作数的符号位决定。如果符号位相同（都是正数或都是负数），结果为正；如果符号位不同，结果为负。</li><li><strong>指数相加</strong>：两个数的指数相加，并减去偏置值（单精度浮点数中为127，双精度为 1023）。</li><li><strong>尾数相乘</strong>：两个数的尾数相乘。这里的尾数包括隐含的最高位1。</li><li><strong>结果规范化</strong>：如果乘法的结果需要规范化（即调整为<code>1.xxxx</code> 的形式），则相应调整指数。</li><li><strong>舍入处理</strong>：如果需要，对结果进行舍入以适应目标格式。</li><li><strong>检查溢出或下溢</strong>：如果指数超出了表示范围，则发生溢出（结果可能为无穷大或特殊值）；如果指数太小，发生下溢（结果可能为0 或非规格化数）。</li></ol><p>假设我们要在单精度浮点数格式下计算：</p><p><span class="math display">\[2.0 × 3.0 = ?\]</span></p><p><strong>第 1 步：转为二进制表示</strong></p><p><span class="math display">\[2.0_{(10)} = 1_{(2)} \\3.0_{(10)} = 11_{(2)}\]</span></p><p><strong>第 2 步：规范化</strong></p><p><span class="math display">\[1 = 1.0 × 2^0 \\11 = 1.1 × 2^1\]</span></p><p><strong>第 3 步：浮点化</strong></p><p><span class="math display">\[2.0 = 0\;00000001\;00000000000000000000000 \\3.0 = 0\;00000001\;10000000000000000000000\]</span></p><p><strong>第 4 步：乘法操作</strong></p><ul><li>符号位：正正得正：<span class="math inline">\(0_{(2)} × 0_{(2)} =0_{(2)}\)</span></li><li>指数相加并减去偏置值：<spanclass="math inline">\((127+1)+(127+1)-127=129\)</span></li><li>尾数相乘：<span class="math inline">\(1.0_{(2)}×1.1_{(2)} =1.1_{(2)}\)</span></li></ul><p><strong>第 5 步：规范化</strong></p><p>这里无需规范化。</p><p><strong>第 6 步：舍入</strong></p><p>这里无需舍入。</p><p><strong>第 7 步：浮点化结果</strong></p><p><span class="math display">\[0\;00000010\;10000000000000000000000\]</span></p><p><strong>第 8 步：转为十进制</strong></p><p><span class="math display">\[V = (-1)^s×1.frac×2^{(e-127)} \\= 0 × 1.1 × 2^2 \\= 110_{(2)} \\= 6.0_{(10)}\]</span></p><h3 id="浮点数除法">浮点数除法</h3><p>浮点数除法类似于乘法，但有一些不同：</p><ol type="1"><li><strong>符号位计算</strong>：与乘法类似，结果的符号由两个操作数的符号位决定。</li><li><strong>指数相减</strong>：被除数的指数减去除数的指数，再加上偏置值。</li><li><strong>尾数相除</strong>：被除数的尾数除以除数的尾数。</li><li><strong>结果规范化</strong>：如果必要，调整结果使其规范化。</li><li><strong>舍入处理</strong>：如果需要，对结果进行舍入。</li><li><strong>检查溢出或下溢</strong>：与乘法类似的检查。</li></ol><p>假设我们要在单精度浮点数格式下计算：</p><p><span class="math display">\[6.0 ÷ 3.0 =?\]</span></p><p><strong>第 1 步：转为二进制表示</strong></p><p><span class="math display">\[6.0_{(10)} = 110_{(2)} \\3.0_{(10)} = 11_{(2)}\]</span></p><p><strong>第 2 步：规范化</strong></p><p><span class="math display">\[6.0 = 110 = 1.10 × 2^2 \\3.0 = 11 = 1.1 × 2^1\]</span></p><p><strong>第 3 步：浮点化</strong></p><p><span class="math display">\[6.0 = 0\;00000020\;10000000000000000000000 \\3.0 = 0\;00000001\;10000000000000000000000\]</span></p><p><strong>第 4 步：除法操作</strong></p><ul><li>符号位：正正得正：<span class="math inline">\(0_{(2)} × 0_{(2)} =0_{(2)}\)</span></li><li>指数减并加上偏置值：<spanclass="math inline">\((127+2)-(127+1)+127=128\)</span></li><li>尾数相除：<span class="math inline">\(1.1_{(2)}×1.1_{(2)} =1.0_{(2)}\)</span></li></ul><p><strong>第 5 步：规范化</strong></p><p>这里无需规范化。</p><p><strong>第 6 步：舍入</strong></p><p>这里无需舍入。</p><p><strong>第 7 步：浮点化结果</strong></p><p><span class="math display">\[0\;00000001\;00000000000000000000000\]</span></p><p><strong>第 8 步：转为十进制</strong></p><p><span class="math display">\[V = (-1)^s×1.frac×2^{(e-127)} \\= 0 × 1.0 × 2^1 \\= 10_{(2)} \\= 2.0_{(10)}\]</span></p><h2 id="go-语言输出浮点数">Go 语言输出浮点数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> number <span class="type">float32</span> = <span class="number">12.375</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;浮点数：%f\n&quot;</span>, number)</span><br><span class="line">fmt.Printf(<span class="string">&quot;科学计数法：%e\n&quot;</span>, number)</span><br><span class="line">fmt.Printf(<span class="string">&quot;保留 2 位小数：%.2f\n&quot;</span>, number)</span><br><span class="line"></span><br><span class="line">bits := math.Float32bits(number)</span><br><span class="line">bitsStr := fmt.Sprintf(<span class="string">&quot;%.32b&quot;</span>, bits)</span><br><span class="line">fmt.Printf(<span class="string">&quot;输出32位浮点表示：%s %s %s\n&quot;</span>, bitsStr[:<span class="number">1</span>], bitsStr[<span class="number">1</span>:<span class="number">9</span>], bitsStr[<span class="number">9</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mathbig">math/big</h2><p>Go 语言的 <code>math/big</code>包提供了对大数的精确计算支持，这些大数的大小超出了标准整数类型（如<code>int64</code>）或浮点类型（如<code>float64</code>）的范围。这个包主要用于需要高精度计算的领域，如加密、科学计算等。</p><p>主要功能：</p><ul><li><strong>算术运算</strong>：支持基本的加、减、乘、除等算术运算。</li><li><strong>比较操作</strong>：可以比较两个大数的大小。</li><li><strong>位操作</strong>：对大整数进行位操作，如位移、与、或、异或等。</li><li><strong>解析和格式化</strong>：可以从字符串解析大数，也可以将大数格式化为字符串。</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := big.NewFloat(math.MaxFloat64)</span><br><span class="line">b := big.NewFloat(math.MaxFloat64)</span><br><span class="line">sum := big.NewFloat(<span class="number">0</span>)</span><br><span class="line">sum.Add(a, b)</span><br><span class="line">fmt.Println(<span class="string">&quot;a:&quot;</span>, a)</span><br><span class="line">fmt.Println(<span class="string">&quot;sum:&quot;</span>, sum)</span><br><span class="line">sum2 := big.NewFloat(<span class="number">0</span>).</span><br><span class="line">SetPrec(<span class="number">15</span>).        <span class="comment">// 设置精度，prec 越大，精度越高，计算越复杂</span></span><br><span class="line">SetMode(big.ToZero) <span class="comment">// 设置舍入策略</span></span><br><span class="line">sum2.Add(a, b)</span><br><span class="line">fmt.Println(<span class="string">&quot;sum2:&quot;</span>, sum2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a: 1.7976931348623157e+308</span></span><br><span class="line"><span class="comment">// sum: 3.5953862697246314e+308</span></span><br><span class="line"><span class="comment">// sum2: 3.5953e+308</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><strong>性能考虑</strong>：由于 <code>math/big</code>提供的是任意精度计算，其性能通常低于原生的固定大小数值类型。</li><li><strong>内存使用</strong>：大数运算可能会消耗更多的内存。</li><li><strong>方法链式调用</strong>：<code>math/big</code>的许多方法返回接收者本身，支持链式调用。</li></ul><h2 id="参考资料">参考资料</h2><ul><li><ahref="https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">IEEE-754</a></li><li>深入理解计算机系统</li><li>Go 语言底层原理剖析</li><li>https://www.bilibili.com/video/BV1zK4y1j7Cn</li><li>ChatGPT-4</li></ul>]]></content>
    
    
    <summary type="html">本文从一个经典问题 0.1+0.2 != 0.3 出发，详细介绍了 IEEE-754 标准下的浮点数表示方法，细致阐述了 3 种浮点数类型的表示逻辑，包括规格化值、非规格化值和特殊值。还介绍了浮点数舍入的 4 种模式，以及浮点数的基本运算。最后，本文结合 Go 语言给出了浮点数不同的输出方式的例子，以及简单介绍了 Go 语言中的 math/big 库在大数运算和精度更高的运算场景中的应用。本文包含大量实例和推演过程，希望能帮助读者彻底掌握浮点数。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机原理" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    <category term="浮点数" scheme="https://hedon.top/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 顺序消息实现</title>
    <link href="https://hedon.top/2023/11/23/kafka-ordered-msg/"/>
    <id>https://hedon.top/2023/11/23/kafka-ordered-msg/</id>
    <published>2023-11-23T15:42:34.000Z</published>
    <updated>2025-03-03T11:31:31.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><p>本文所有的讨论均在如下版本进行，其他版本可能会有所不同。</p><ul><li>Kafka: 3.6.0</li><li>Pulsar: 2.9.0</li><li>RabbitMQ 3.7.8</li><li>RocketMQ 5.0</li><li>Go1.21</li><li>github.com/segmentio/kafka-go v0.4.45</li></ul><h2 id="结论先行">结论先行</h2><p>Kafka只能保证单一分区内的顺序消息，无法保证多分区间的顺序消息。具体来说，要在Kafka 完全实现顺序消息，至少需要保证以下几个条件：</p><ol type="1"><li>同一生产者生产消息；</li><li>同步发送消息到 Kafka broker；</li><li>所有消息发布到同一个分区；</li><li>同一消费者同步按照顺序消费消息。</li></ol><p>而要满足第 3 点，常用的有 2 种思路：</p><ol type="1"><li>固定消息的 key，生产端采用 <code>key hash</code> 的方式写入broker；</li><li>自定义分区策略，要保证顺序的消息都写入到指定的分区。</li></ol><h2 id="消息队列中的顺序消息如何实现">消息队列中的顺序消息如何实现</h2><h3 id="顺序消息定义">顺序消息定义</h3><p>生产端发送出来的消息的顺序和消费端接收到消息的顺序是一样的。</p><h3 id="消息存储结构">消息存储结构</h3><p>一般来说，消息队列都是基于<strong>顺序存储结构</strong>来存储数据的，不需要B 树、B+树等复杂数据结构，利用文件的顺序读写，性能也很高。所以理想情况下，生产者按顺序发送消息，broker会按顺序存储消息，消费者再按顺序消费消息，那么天然就实现了我们要的<strong>顺序消息</strong>了，如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231124235214392.png"alt="消息队列顺序存储结构" /><figcaption aria-hidden="true">消息队列顺序存储结构</figcaption></figure><h3 id="基本条件">基本条件</h3><p>但是一般情况下，消息队列为了支持更高的并发和吞吐，大多数都有分区（partition）和消费者组（consumergroup）机制，而为了高可用，一般也会有副本（replica）机制，所以情况就复杂得多了，如下面几个例子，就会导致消息失序：</p><ol type="1"><li>多个生产者同时发送消息，那么到达 broker 的时间也是不确定的，所以broker 就无法保证落盘的顺序性了；</li><li>单个生产者，但是采用异步发送，因为异步线程是并发执行的，由 CPU进行调度，且有可能会因为发送失败而重试，所以也无法保证消息可以按照顺序到达broker，同理，消费者异步处理消息，也无法保证顺序性；</li><li>一个 topic有多个分区，那么即使是同一个生产者，由于分区策略，消息可能会被分发到多个分区中，消费者也就无法保证顺序性了。</li></ol><p>所以到这里，我们可以总结出实现顺序消息，至少需要满足以下 3 点：</p><ol type="1"><li>单一生产者同步发送；</li><li>单一分区；</li><li>单一消费者同步消费；</li></ol><p>第 1、3 点比较简单，Kafka 通过分区和 offset的方式保证了消息的顺序。每个分区都是一个有序的、不可变的消息序列，每个消息在分区中都有一个唯一的序数标识，称为<code>offset</code>。生产者在发送消息到分区时，Kafka会自动为消息分配一个 offset。消费者在读取消息时，会按照 offset的顺序来读取，从而保证了消息的顺序。</p><p>下面我们主要来谈一谈第 2 点。</p><h2 id="kafka-顺序消息的实现">Kafka 顺序消息的实现</h2><h3 id="写入消息的过程">写入消息的过程</h3><ol type="1"><li><strong>配置生产者</strong>：首先，你需要配置 Kafka生产者。这包括指定 Kafka集群的地址和端口，以及其他相关配置项，如消息序列化器、分区策略等。</li><li><strong>创建生产者实例</strong>：在应用程序中，你需要创建一个 Kafka生产者的实例。这个实例将用于与 Kafka 集群进行通信。</li><li><strong>序列化消息</strong>：在将消息发送到 Kafka集群之前，你需要将消息进行序列化。Kafka使用字节数组来表示消息的内容，因此你需要将消息对象序列化为字节数组。这通常涉及将消息对象转换为JSON、Avro、Protobuf 等格式。</li><li><strong>选择分区</strong>：Kafka的主题（topic）被分为多个分区（partition），每个分区都是有序且持久化的消息日志。当你发送消息时，你可以选择将消息发送到特定的分区，或者让Kafka 根据分区策略自动选择分区。</li><li><strong>发送消息</strong>：一旦消息被序列化并选择了目标分区，你可以使用Kafka 生产者的 <code>send()</code> 方法将消息发送到 Kafka集群。发送消息时，生产者会将消息发送到对应分区的 leader 副本。</li><li><strong>异步发送</strong>：Kafka生产者通常使用异步方式发送消息，这样可以提高吞吐量。生产者将消息添加到一个发送缓冲区（sendbuffer）中，并在后台线程中批量发送消息到 Kafka 集群。</li><li><strong>消息持久化</strong>：一旦消息被发送到 Kafka 集群的 leader副本，它将被持久化并复制到其他副本，以确保数据的高可靠性和冗余性。只有当消息被成功写入到指定数量的副本后，生产者才会收到确认（acknowledgement）。</li><li><strong>错误处理和重试</strong>：如果发送消息时发生错误，生产者可以根据配置进行错误处理和重试。你可以设置重试次数、重试间隔等参数来控制重试行为。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231125013322459.png"alt="Kafka 生产者组件 -《Kafka权威指南第2版》" /><figcaption aria-hidden="true">Kafka 生产者组件-《Kafka权威指南第2版》</figcaption></figure><h3 id="实现单一分区">实现单一分区</h3><p>再 Kafka 中，我们要实现将消息写入到同一个分区，有 3 种思路：</p><ul><li>配置 <code>num.partitions=1</code> 或者创建 topic 的时候指定只有 1个分区，但这会显著降低 Kafka 的吞吐量。</li><li><strong>固定消息的 key</strong>，然后采用 <strong>key hash</strong>的分区策略，这样就可以让所有消息都被分到同一个分区中。</li><li>实现并指定<strong>自定义分区策略</strong>，可以根据业务需求，将需要顺序消费的消息都分到固定一个分区中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下例子，所有使用&quot;same-key&quot;作为key的消息都会被发送到同一个Partition</span></span><br><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;same-key&quot;</span>, <span class="string">&quot;message&quot;</span>);</span><br><span class="line">producer.send(record);</span><br></pre></td></tr></table></figure><h3 id="重平衡带来的问题">重平衡带来的问题</h3><p>如果采用上述的第 2 种思路：<strong>固定消息 key，依靠 key hash分区策略，实现单一分区</strong>。在我们只有 1个消费者的情况下是没有问题的，但是如果我们使用的是消费者组，那么，在发生<strong>重平衡</strong>操作的时候，就可能会有问题了。</p><p>Kafka 的重平衡（Rebalance）是指 Kafka 消费者组（ConsumerGroup）中的消费者实例对分区的重新分配。这个过程主要发生在以下几种情况：</p><ol type="1"><li>消费者组中新的消费者加入。</li><li>消费者组中的消费者离开或者挂掉。</li><li>订阅的 Topic 的分区数发生变化。</li><li>消费者调用了 <code>#unsubscribe()</code> 或者<code>#subscribe()</code> 方法。</li></ol><p>重平衡的过程主要包括以下几个步骤：</p><ol type="1"><li><strong>Revoke</strong>：首先，Kafka会撤销消费者组中所有消费者当前持有的分区。</li><li><strong>Assignment</strong>：然后，Kafka会重新计算分区的分配情况，然后将分区分配给消费者。</li><li><strong>Resume</strong>：最后，消费者会开始消费新分配到的分区。</li></ol><p>重平衡的目的是为了保证消费者组中的消费者能够公平地消费 Topic的分区。通过重平衡，Kafka可以在消费者的数量发生变化时，动态地调整消费者对分区的分配，从而实现负载均衡。</p><p>然而，当发生重平衡时，分区可能会被重新分配给不同的消费者，这可能会影响消息的消费顺序。</p><p>举个例子：</p><ol type="1"><li>假设消费者 A 正在消费分区 P 的消息，它已经消费了消息 1，消息2，正在处理消息 3。</li><li>此时，发生了重平衡，分区 P 被重新分配给了消费者 B。</li><li>消费者 B 开始消费分区P，它会从上一次提交的偏移量（offset）开始消费。假设消费者 A 在处理消息 3时发生了故障，没有提交偏移量，那么消费者 B 会从消息 3 开始消费。</li><li>这样，消息 3 可能会被消费两次，而且如果消费者 B 处理消息 3的速度快于消费者A，那么消息 3 可能会在消息 2之后被处理，这就打破了消息的顺序性。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231125003222491.png"alt="重平衡导致消息失序" /><figcaption aria-hidden="true">重平衡导致消息失序</figcaption></figure><p>再举个例子：</p><ol type="1"><li>topic-A 本来只有 3 个分区，按照 key hash，key 为<code>same-key</code> 的消息应该都发到 第 2 个分区；</li><li>但是后来 topic-A 变成了 4 个分区，按照 key hash，key 为<code>same-key</code> 的消息可能就被发到第 3 个分区了；</li><li>这就无法做到单一分区，可能会导致消息失序。</li></ol><p>当然这个例子不是由重平衡直接引起的，但是这种情况也是有可能导致消息失序的。</p><h3 id="缓解重平衡的问题">缓解重平衡的问题</h3><ul><li><strong>避免动态改变分区数</strong>：在需要严格保持消息顺序的场景下，应避免动态地改变分区数。这意味着在设计Kafka 主题时，应提前规划好所需的分区数，以避免日后需要进行更改。</li><li><strong>使用单个分区</strong>：对于严格顺序要求的场景，可以考虑使用单分区主题。虽然这会限制吞吐量和并发性，但可以保证消息的全局顺序。</li><li><strong>使用其他策略保持顺序</strong>：在某些情况下，可以通过在应用层实现逻辑来保持顺序，比如在消息中包含顺序号或时间戳，并在消费时根据这些信息重建正确的顺序。</li><li><strong>使用静态成员功能</strong>：它允许消费者在断开和重新连接时保持其消费者组内的身份，这可以减少因短暂的网络问题或消费者重启导致的不必要的重平衡。</li></ul><p>上面这些措施，只能减少重平衡带来的问题，并无法根除，如果非要实现严格意义上的顺序消息，要么在消息中加入时间戳等标记，在业务层保证顺序消费，要么就只能采用<code>单一生产者同步发送 + 单一分区 +单一消费者同步消费</code>这种模式了。</p><h3 id="静态成员功能">静态成员功能</h3><p>Kafka 2.3.0 版本引入了一项新功能：静态成员（StaticMembership）。这个功能主要是为了减少由于消费者重平衡（rebalance）引起的开销和延迟。在传统的Kafka消费者组中，当新的消费者加入或离开消费者组时，会触发重平衡。这个过程可能会导致消息的处理延迟，并且在高吞吐量的场景下可能会对性能造成影响。静态成员功能旨在缓解这些问题。以下是它的一些关键点：</p><p>静态成员的工作原理：</p><ol type="1"><li><p><strong>静态成员标识</strong>：消费者在加入消费者组时可以提供一个静态成员标识（StaticMember ID）。这允许 Kafka Broker识别特定的消费者实例，而不是仅仅依赖于消费者组内的动态分配。</p></li><li><p><strong>重平衡优化</strong>：当使用静态成员功能时，如果一个已知的消费者由于某种原因（如网络问题）短暂断开后重新连接，Kafka不会立即触发重平衡。相反，Kafka会等待一个预设的超时期限（session.timeout.ms），在此期间如果消费者重新连接，它将保留原来的分区分配。</p></li><li><p><strong>减少重平衡次数</strong>：这大大减少了由于消费者崩溃和恢复、网络问题或维护操作引起的不必要的重平衡次数。</p></li></ol><p>使用静态成员的优点：</p><ol type="1"><li><p><strong>提高稳定性</strong>：减少重平衡可以提高消费者组的整体稳定性，尤其是在大型消费者组和高吞吐量的情况下。</p></li><li><p><strong>减少延迟</strong>：由于减少了重平衡的次数，可以减少因重平衡导致的消息处理延迟。</p></li><li><p><strong>持久的消费者分区分配</strong>：这使得消费者在分区分配上更加持久，有助于更好地管理和优化消息的消费。</p></li></ol><p>如何使用：</p><ul><li>要使用静态成员功能，需要在 Kafka 消费者的配置中设置<code>group.instance.id</code>。这个 ID应该是唯一的，并且在消费者重启或重新连接时保持不变。同时，还需要配置<code>session.timeout.ms</code>，以决定在触发重平衡之前消费者可以离线多长时间。</li></ul><p>注意事项：</p><ul><li>虽然静态成员功能可以减少重平衡的发生，但它不会完全消除重平衡。在消费者组成员的长期变化（如新消费者的加入或永久离开）时，仍然会发生重平衡。</li><li>需要合理设置<code>session.timeout.ms</code>，以避免消费者由于短暂的网络问题或其他原因的断开而过早触发重平衡。</li></ul><p>静态成员功能在处理大规模 Kafka应用时尤其有用，它提供了一种机制来优化消费者组的性能和稳定性。</p><h3 id="幂等性">幂等性</h3><p>Kafka 0.11版本后提供了幂等性生产者，这意味着即使生产者因为某些错误重试发送相同的消息，这些消息也只会被记录一次。这是通过给每一批发送到Kafka 的消息分配一个序列号实现的，broker使用这个序列号来删除重复发送的消息。使用幂等性生产者，可以减少重复消息的风险，这意味着即使在网络重试等情况下，消息的顺序也能得到更好的保证。因为重复消息不会被多次记录，所以不会破坏已有消息的顺序。</p><h2id="其他常见消息队列顺序消息的实现">其他常见消息队列顺序消息的实现</h2><h3 id="pulsar">Pulsar</h3><p>Pulsar 和 Kafka 一样，都是通过生产端按 Key Hash的方案将数据写入到同一个分区。</p><h3 id="rabbitmq">RabbitMQ</h3><p>RabbitMQ 在生产时没有生产分区分配的过程。它是通过<code>Exchange</code> 和 <code>Route Key</code>机制来实现顺序消息的。<code>Exchange</code> 会根据设置好的<code>Route Key</code> 将数据路由到不同的 <code>Queue</code>中存储。此时 <code>Route Key</code> 的作用和 Kafka 的消息的<code>Key</code> 是一样的。</p><h3 id="rocketmq">RocketMQ</h3><p>RocektMQ支持<code>消息组（MessageGroup）</code>的概念。在生产端指定消息组，则同一个消息组的消息就会被发送到同一个分区中。此时这个消息组起到的作用和Kakfa 的消息的 Key 是一样的。</p><h2 id="实战-kafka-实现顺序消息">实战 Kafka 实现顺序消息</h2><blockquote><p>代码仓库：https://github.com/hedon954/kafka-go-examples/tree/master/orderedmsg</p></blockquote><p>下面我们来写一写实战用例，更加直观地感受一下 Kafka顺序消息的实现细节。</p><p>首先我们在集群上创建一个 topic <code>ordered-msg-topic</code>，分区为<code>3</code> 个，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic ordered-msg-topic --partitions 3 --replication-factor 1</span><br></pre></td></tr></table></figure><p>搭建 Kafka 集群可以看这两篇：<ahref="https://hedon.top/2023/11/22/kakfa-cluster-deploy/">Kafka集群搭建(Zookeeper)</a>、<ahref="https://hedon.top/2023/11/22/kafka-kraft-deploy/">Kafka集群搭建(KRaft)</a>。</p><h3 id="单生产者单消费者">单生产者单消费者</h3><p>正常情况下，使用单一生产者同步发送和单一消费者同步发送，只要我们保证key 是固定的，则所有消息都会写到同一个分区，是可以实现顺序消息的。</p><p>代码目录如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├─config</span><br><span class="line">│      config.go<span class="comment"># 常量定义</span></span><br><span class="line">├─consumer</span><br><span class="line">│      consumer.go<span class="comment"># 消费者</span></span><br><span class="line">└─producer</span><br><span class="line">        producer.go<span class="comment"># 生产者</span></span><br></pre></td></tr></table></figure><p>首先我们先定义一些常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/segmentio/kafka-go&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">Topic      = <span class="string">&quot;ordered-msg-topic&quot;</span></span><br><span class="line">Brokers    = []<span class="type">string</span>&#123;<span class="string">&quot;kafka1.com:9092&quot;</span>, <span class="string">&quot;kafka2.com:9092&quot;</span>, <span class="string">&quot;kafka3.com:9092&quot;</span>&#125;</span><br><span class="line">Addr       = kafka.TCP(Brokers...)</span><br><span class="line">GroupId    = <span class="string">&quot;ordered-msg-group&quot;</span></span><br><span class="line">MessageKey = []<span class="type">byte</span>(<span class="string">&quot;message-key&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们先实现生产者端，主要是不断往 <code>ordered-msg-topic</code>中写入数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;kafka-go-examples/orderedmsg/config&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/segmentio/kafka-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProducer</span><span class="params">()</span></span> *kafka.Writer &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;kafka.Writer&#123;</span><br><span class="line">Addr:     config.Addr,</span><br><span class="line">Topic:    config.Topic,</span><br><span class="line">Balancer: &amp;kafka.Hash&#123;&#125;, <span class="comment">// 哈希分区</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMessages</span><span class="params">(count <span class="type">int</span>)</span></span> []kafka.Message &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]kafka.Message, count)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">res[i] = kafka.Message&#123;</span><br><span class="line">Key:   config.MessageKey,</span><br><span class="line">Value: []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;msg-%d&quot;</span>, i+<span class="number">1</span>)),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">producer := NewProducer()</span><br><span class="line">messages := NewMessages(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> err := producer.WriteMessages(context.Background(), messages...); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">_ = producer.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来实现消费者，目前我们就启动 1 个消费者：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;kafka-go-examples/orderedmsg/config&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/segmentio/kafka-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Consumer <span class="keyword">struct</span> &#123;</span><br><span class="line">Id <span class="type">string</span></span><br><span class="line">*kafka.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewConsumer 创建一个消费者，它属于 config.GroupId 这个消费者组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConsumer</span><span class="params">(id <span class="type">string</span>)</span></span> *Consumer &#123;</span><br><span class="line">c := &amp;Consumer&#123;</span><br><span class="line">Id: id,</span><br><span class="line">Reader: kafka.NewReader(kafka.ReaderConfig&#123;</span><br><span class="line">Brokers: config.Brokers,</span><br><span class="line">GroupID: config.GroupId,</span><br><span class="line">Topic:   config.Topic,</span><br><span class="line">Dialer: &amp;kafka.Dialer&#123;</span><br><span class="line">ClientID: id,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read 读取消息，intervalMs 用来控制消费者的消费速度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Consumer)</span></span> Read(intervalMs <span class="type">int</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s start read\n&quot;</span>, c.Id)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg, err := c.ReadMessage(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s read msg err: %v\n&quot;</span>, c.Id, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟消费速度</span></span><br><span class="line">time.Sleep(time.Millisecond * time.Duration(intervalMs))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s read msg: %s, time: %s\n&quot;</span>, c.Id, <span class="type">string</span>(msg.Value), time.Now().Format(<span class="string">&quot;03-04-05&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := NewConsumer(<span class="string">&quot;consumer-1&quot;</span>)</span><br><span class="line">c1.Read(<span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动生产者生产消息，然后启动消费者，观察控制台，不难看出这种情况下就是顺序消费：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">consumer-1 read msg: msg-10, time: 04:29:10</span><br><span class="line">consumer-1 read msg: msg-11, time: 04:29:11</span><br><span class="line">consumer-1 read msg: msg-12, time: 04:29:12</span><br><span class="line">consumer-1 read msg: msg-13, time: 04:29:13</span><br><span class="line">consumer-1 read msg: msg-14, time: 04:29:14</span><br><span class="line">consumer-1 read msg: msg-15, time: 04:29:15</span><br><span class="line">consumer-1 read msg: msg-16, time: 04:29:16</span><br></pre></td></tr></table></figure><h3 id="重平衡带来的问题-1">重平衡带来的问题</h3><p>我们先重建 topic，清楚掉之前的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --delete --topic ordered-msg-topic</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic ordered-msg-topic --partitions 3 --replication-factor 1</span><br></pre></td></tr></table></figure><p>下面我们来采用消费者组的形式消费消息，在这期间，我们不断往消费者组中新增消费者，使其发生重平衡，我们来观察下消息的消费情况。</p><p>修改消费者端的 main()：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 先启动 c1</span></span><br><span class="line">c1 := NewConsumer(<span class="string">&quot;consumer-1&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1.Read(<span class="number">500</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 秒后启动 c2</span></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c2 := NewConsumer(<span class="string">&quot;consumer-2&quot;</span>)</span><br><span class="line">c2.Read(<span class="number">300</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再 10 秒后启动 c3 和 c4</span></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c3 := NewConsumer(<span class="string">&quot;consumer-3&quot;</span>)</span><br><span class="line">c3.Read(<span class="number">100</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c4 := NewConsumer(<span class="string">&quot;consumer-4&quot;</span>)</span><br><span class="line">c4.Read(<span class="number">100</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动生产者重新生产数据，然后再启动消费者消费数据，观察控制台：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">consumer-1 start <span class="built_in">read</span></span><br><span class="line">consumer-1 <span class="built_in">read</span> msg: msg-1, time: 04:44:28</span><br><span class="line">consumer-1 <span class="built_in">read</span> msg: msg-2, time: 04:44:28</span><br><span class="line">consumer-1 <span class="built_in">read</span> msg: msg-3, time: 04:44:29<span class="comment"># consumer-1 按顺序消费</span></span><br><span class="line">consumer-2 start <span class="built_in">read</span>  <span class="comment"># consumer-2 进来</span></span><br><span class="line">consumer-1 <span class="built_in">read</span> msg: msg-4, time: 04:44:30</span><br><span class="line">consumer-1 <span class="built_in">read</span> msg: msg-5, time: 04:44:30</span><br><span class="line">consumer-1 <span class="built_in">read</span> msg: msg-6, time: 04:44:31      <span class="comment"># 这里相差了 6s，就是在进行重平衡</span></span><br><span class="line">consumer-2 <span class="built_in">read</span> msg: msg-7, time: 04:44:37      <span class="comment"># 重平衡后发现原来的分区给 consumer-2 消费了</span></span><br><span class="line">consumer-1 <span class="built_in">read</span> msg: msg-7, time: 04:44:37    <span class="comment"># 这里发生了重复消费</span></span><br><span class="line">consumer-2 <span class="built_in">read</span> msg: msg-8, time: 04:44:37</span><br><span class="line">consumer-2 <span class="built_in">read</span> msg: msg-9, time: 04:44:37</span><br><span class="line">consumer-2 <span class="built_in">read</span> msg: msg-10, time: 04:44:38</span><br><span class="line">consumer-2 <span class="built_in">read</span> msg: msg-11, time: 04:44:38</span><br><span class="line">consumer-2 <span class="built_in">read</span> msg: msg-12, time: 04:44:38</span><br><span class="line">consumer-2 <span class="built_in">read</span> msg: msg-13, time: 04:44:39</span><br><span class="line">consumer-2 <span class="built_in">read</span> msg: msg-14, time: 04:44:39</span><br><span class="line">consumer-2 <span class="built_in">read</span> msg: msg-15, time: 04:44:39      <span class="comment"># consumer-2 按顺序消息</span></span><br><span class="line">consumer-4 start <span class="built_in">read</span>   <span class="comment"># consumer-3 和 consumer-4 进来</span></span><br><span class="line">consumer-3 start <span class="built_in">read</span></span><br><span class="line">consumer-2 <span class="built_in">read</span> msg: msg-16, time: 04:44:40   </span><br><span class="line">consumer-4 <span class="built_in">read</span> msg: msg-17, time: 04:44:46      <span class="comment"># 这里发生重平衡</span></span><br><span class="line">consumer-4 <span class="built_in">read</span> msg: msg-18, time: 04:44:46      <span class="comment"># 重平衡后由 consumer-4 负责该分区</span></span><br><span class="line">consumer-2 <span class="built_in">read</span> msg: msg-17, time: 04:44:46      <span class="comment"># 这里由于 2 的速度比 4 慢很多，所以就乱序了，还重复消费</span></span><br><span class="line">consumer-4 <span class="built_in">read</span> msg: msg-19, time: 04:44:46</span><br><span class="line">consumer-4 <span class="built_in">read</span> msg: msg-20, time: 04:44:46</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>当我们采用消费者组的时候，由于重平衡机制的存在，单纯从 Kafka的角度来说是无法完全实现顺序消息的，只能通过静态成员功能、避免分区数量变化和减少消费者组成员数量变化等方式来尽可能减少重平衡的发生，进而尽可能维持消息的顺序性。</p><h2 id="参考">参考</h2><ul><li><a href="https://time.geekbang.com/column/intro/100552001">极客时间- 深入拆解消息队列 47 讲（许文强）</a></li><li><a href="https://www.qidian.com/book/1035938080/">《Kafka权威指南（第 2 版）》</a></li><li><ahref="https://pulsar.staged.apache.org/docs/zh-CN/next/concepts-messaging/#%E9%A1%BA%E5%BA%8F%E4%BF%9D%E8%AF%81">Pulsar官方文档-分区topic-顺序保证</a></li><li><ahref="https://rocketmq.apache.org/zh/docs/featureBehavior/03fifomessage">RocketMQ官方文档-功能特性-顺序消息</a></li><li><ahref="https://www.rabbitmq.com/tutorials/tutorial-two-go.html">RabbitMQ官方文档</a></li></ul>]]></content>
    
    
    <summary type="html">本文详细介绍了如何实现 Kafka 的顺序消息，同时给出了消息队列顺序消息的通用实现思路，并简单介绍了 RabbitMQ、RocketMQ 和 Pulsar 在顺序消息方面的实现思路。</summary>
    
    
    
    <category term="Kafka" scheme="https://hedon.top/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://hedon.top/tags/Kafka/"/>
    
    <category term="中间件" scheme="https://hedon.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="消息队列" scheme="https://hedon.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 集群部署（KRaft）</title>
    <link href="https://hedon.top/2023/11/22/kafka-kraft-deploy/"/>
    <id>https://hedon.top/2023/11/22/kafka-kraft-deploy/</id>
    <published>2023-11-22T13:52:31.000Z</published>
    <updated>2025-03-03T11:31:24.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><ul><li>Ubuntu 18.04.6</li><li>Kafka 3.6.0</li><li>JDK8</li></ul><h2 id="集群配置">集群配置</h2><table><colgroup><col style="width: 18%" /><col style="width: 18%" /><col style="width: 13%" /><col style="width: 22%" /><col style="width: 27%" /></colgroup><thead><tr class="header"><th style="text-align: center;">操作系统</th><th style="text-align: center;">ip</th><th style="text-align: center;">域名</th><th style="text-align: center;">Kafka Broker 端口</th><th style="text-align: center;">Kafka Controller 端口</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.131</td><td style="text-align: center;">kafka1.com</td><td style="text-align: center;">9092</td><td style="text-align: center;">9093</td></tr><tr class="even"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.132</td><td style="text-align: center;">kafka2.com</td><td style="text-align: center;">9092</td><td style="text-align: center;">9093</td></tr><tr class="odd"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.133</td><td style="text-align: center;">kafka3.com</td><td style="text-align: center;">9092</td><td style="text-align: center;">9093</td></tr></tbody></table><h2 id="安装-vim-curl">安装 vim, curl</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install vim</span><br><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure><h2 id="配置静态-ip-和-hosts">配置静态 ip 和 hosts</h2><p>为了使用域名，更加方便的进行配置，这里将虚拟机的 DHCP 改成了静态分配IP，所以需要手动设置一下每台机器 IP 地址，这里以<code>192.168.50.131</code> 为例。</p><ol type="1"><li><p>找到网络接口名称，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p>查找以 <code>ens</code> 或 <code>eth</code>开头的接口名称。例如，<code>ens33</code> 或 <code>eth0</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:~$ ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.50.133/24 brd 192.168.50.255 scope global dynamic noprefixroute ens33</span><br><span class="line">       valid_lft 1644sec preferred_lft 1644sec</span><br><span class="line">    inet6 fe80::c367:c7cc:3ad4:23b3/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>可以找到 <code>ens33</code>，其中 <code>inet 192.168.50.133/24</code>表示 IP 地址为 <code>192.168.50.133</code>，子网掩码为<code>/24</code>（等于 <code>255.255.255.0</code>）。</p><p>这个 IP 地址是 DHCP 动态分配的，说明宿主机分配给虚拟机的 IP 范围就在<code>192.168.50.xxx</code>，所以我们会将静态 IP配置在这个范围内。</p></li><li><p>获取网关地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route | grep default</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:~$ ip route | grep default</span><br><span class="line">default via 192.168.50.2 dev ens33 proto dhcp metric 100</span><br></pre></td></tr></table></figure><p>说明默认网关是 <code>192.168.50.2</code>，</p></li><li><p>编辑 <code>/etc/network/interfaces</code> 文件，配置静态 IP地址，内容如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto ens33</span><br><span class="line">iface ens33 inet static</span><br><span class="line">   address 192.168.50.131</span><br><span class="line">   netmask 255.255.255.0</span><br><span class="line">   gateway 192.168.50.2</span><br><span class="line">   dns-nameservers 8.8.8.8 8.8.4.4</span><br></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su reboot</span><br></pre></td></tr></table></figure></li><li><p>再次查看 ip 地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p>有以下输出便说明静态 IP 配置成功了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.50.131/24 brd 192.168.50.255 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fe82:9e69/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></li><li><p>配置域名</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p>追加内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.50.131 kafka1.com</span><br><span class="line">192.168.50.132 kafka2.com</span><br><span class="line">192.168.50.133 kafka3.com</span><br></pre></td></tr></table></figure></li><li><p>ping 一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:~$ ping kafka1.com</span><br><span class="line">PING kafka1.com (192.168.50.131) 56(84) bytes of data.</span><br><span class="line">64 bytes from kafka1.com (192.168.50.131): icmp_seq=1 ttl=64 time=0.024 ms</span><br><span class="line">64 bytes from kafka1.com (192.168.50.131): icmp_seq=2 ttl=64 time=0.021 ms</span><br><span class="line">64 bytes from kafka1.com (192.168.50.131): icmp_seq=3 ttl=64 time=0.029 ms</span><br><span class="line">^C</span><br><span class="line">--- kafka1.com ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2029ms</span><br><span class="line">rtt min/avg/max/mdev = 0.021/0.024/0.029/0.006 ms</span><br></pre></td></tr></table></figure></li><li><p>ping 一下百度，看看能不能访问外网</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:~$ ping baidu.com</span><br><span class="line">ping: baidu.com: Name or service not known</span><br></pre></td></tr></table></figure><p>如果这里可以访问，则直接跳过进入下一步，不可以的话，需要配置一下域名解析系统。</p></li><li><p>配置域名解析系统</p><p>Ubuntu 系统使用 <code>systemd-resolved</code> 服务来管理DNS，你可以在 <code>/etc/systemd/resolved.conf</code> 文件中进行 DNS配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/systemd/resolved.conf</span><br></pre></td></tr></table></figure><p>取消或添加 <code>DNS</code> 的注释，并修改为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Resolve]</span><br><span class="line">DNS=8.8.8.8 8.8.4.4</span><br></pre></td></tr></table></figure><p>重启启动 <code>systemd-resolved</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart systemd-resolved</span><br></pre></td></tr></table></figure><p>再尝试 ping 一下百度：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:~$ ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com (153.3.238.110) 56(84) bytes of data.</span><br><span class="line">64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=1 ttl=128 time=15.9 ms</span><br><span class="line">64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=2 ttl=128 time=15.9 ms</span><br><span class="line">64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=3 ttl=128 time=16.1 ms</span><br><span class="line">64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=4 ttl=128 time=15.3 ms</span><br><span class="line">^C</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 14104ms</span><br><span class="line">rtt min/avg/max/mdev = 15.368/15.850/16.145/0.291 ms</span><br></pre></td></tr></table></figure></li></ol><details class="tag-plugin colorful folding" color="blue" open><summary><p>补充说明：<code>/etc/network/interfaces</code> 文件的配置</p></summary><div class="body"><p>这是一个用于配置 Linux 系统上网络接口的文件。在这个示例中，我们为名为<code>ens33</code> 的网络接口配置了静态 IP地址和相关的网络设置。下面是各行的解释：</p><ol type="1"><li><p><code>auto ens33</code>: 这一行表示在系统启动时自动激活<code>ens33</code> 网络接口。<code>auto</code>关键字后面跟着接口名称。</p></li><li><p><code>iface ens33 inet static</code>: 这一行定义了<code>ens33</code> 网络接口的配置。<code>iface</code>关键字后面跟着接口名称，<code>inet</code> 表示我们正在配置 IPv4地址，<code>static</code> 表示我们要为接口分配一个静态 IP地址（而不是通过 DHCP 获得）。</p></li><li><p><code>address 192.168.50.131</code>: 这一行设置了网络接口的静态IP 地址。在这个例子中，我们为 <code>ens33</code> 接口分配了<code>192.168.50.131</code> IP 地址。</p><blockquote><p>IP 地址是 Internet协议（IP）用于在网络中唯一标识设备的数字标签。每个连接到网络的设备都需要一个唯一的IP 地址，以便其他设备可以找到并与之通信。IP 地址通常分为两种版本：IPv4和 IPv6。在此示例中，我们使用了一个 IPv4 地址。</p></blockquote></li><li><p><code>netmask 255.255.255.0</code>:这一行定义了子网掩码。在这个例子中，子网掩码是<code>255.255.255.0</code>，表示前三个字节（24位）是网络地址，最后一个字节（8 位）是主机地址。</p><blockquote><p>子网掩码用于划分 IP 地址的网络部分和主机部分。子网掩码与 IP地址进行按位与操作，从而得到网络地址。这有助于确定哪些 IP地址属于同一子网，以便正确地将数据包路由到目的地。子网划分有助于组织网络、提高安全性和管理性。</p></blockquote></li><li><p><code>gateway 192.168.50.2</code>:这一行设置了默认网关。在这个例子中，我们将默认网关设置为<code>192.168.50.2</code>。默认网关是用于将数据包发送到其他网络的路由器或设备的IP 地址。</p><blockquote><p>网关是一个充当网络中数据包传输的中继点的设备，通常是一个路由器。当一个设备需要将数据包发送到不同子网的另一个设备时，它会将数据包发送到网关。网关负责将数据包路由到正确的目的地。默认网关是设备用于将数据包发送到其他网络的首选网关。</p></blockquote></li><li><p><code>dns-nameservers 8.8.8.8 8.8.4.4</code>: 这一行指定了 DNS服务器的 IP 地址。在这个例子中，我们使用了谷歌的公共 DNS 服务器<code>8.8.8.8</code> 和 <code>8.8.4.4</code>。DNS服务器用于将主机名解析为 IP 地址。</p><blockquote><p>域名系统（DNS）是将人类可读的域名（例如 www.baidu.com）IP地址的系统。DNS服务器是负责执行此解析过程的服务器。当您在浏览器中输入一个网址时，计算机会向DNS 服务器查询该域名对应的 IP 地址，然后将请求发送到该 IP地址以获取网页内容。</p></blockquote></li></ol><p>配置文件中的这些设置将在系统启动时生效。要立即应用更改，您可以使用以下命令重启网络服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart networking</span><br></pre></td></tr></table></figure></div></details><h2 id="安装-jdk">安装 jdk</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure><p>验证 java8 是否已经安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>有以下类似输出的话则表明安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version <span class="string">&quot;1.8.0_362&quot;</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_362-8u372-ga~us1-0ubuntu1~18.04-b09)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.362-b09, mixed mode)</span><br></pre></td></tr></table></figure><h2 id="安装-kafka">安装 Kafka</h2><ol type="1"><li><p>下载并解压 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/kafka/3.6.0/kafka_2.13-3.6.0.tgz</span><br><span class="line">tar -zxvf kafka_2.13-3.6.0.tgz</span><br></pre></td></tr></table></figure></li><li><p>将解压缩后的文件夹移动到 <code>/opt</code> 目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> kafka_2.13-3.6.0 /opt/kafka-3.6.0</span><br></pre></td></tr></table></figure></li><li><p>使用 Kafka 提供的脚本生成一个 ClusterID</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KAFKA_CLUSTER_ID=<span class="string">&quot;<span class="subst">$(/opt/kafka-3.6.0/bin/kafka-storage.sh random-uuid)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>输出 ClusterID</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:/opt/kafka-3.6.0$ <span class="built_in">echo</span> <span class="variable">$KAFKA_CLUSTER_ID</span></span><br><span class="line">XiMRcbJ-QEO694L7sfDdBQ</span><br></pre></td></tr></table></figure><p>在其他节点上将 <code>KAFKA_CLUSTER_ID</code> 设置为上面的值：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KAFKA_CLUSTER_ID=XiMRcbJ-QEO694L7sfDdBQ</span><br></pre></td></tr></table></figure></li><li><p>备份配置文件，注意这里的配置文件是<code>config/kraft/server.properties</code>，在 <code>config</code>目录下的 <code>kraft</code> 目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /opt/kafka-3.6.0/config/kraft/server.properties /opt/kafka-3.6.0/config/kraft/server.properties.bak</span><br></pre></td></tr></table></figure></li><li><p>修改配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/kafka-3.6.0/config/kraft/server.properties</span><br></pre></td></tr></table></figure><p>主要修改内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 节点 ID，分别为 1，2，3</span></span><br><span class="line"><span class="attr">node.id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 日志目录</span></span><br><span class="line"><span class="attr">log.dirs</span>=<span class="string">/opt/kafka-3.6.0/kafka-combined-logs</span></span><br><span class="line"><span class="comment"># 可以成为控制器的节点和它们的端口</span></span><br><span class="line"><span class="attr">controller.quorum.voters</span>=<span class="string">1@kafka1.com:9093,2@kafka2.com:9093,3@kafka3.com:9093</span></span><br><span class="line"><span class="comment"># 定义 Kafka Broker 如何向外部公布它的地址。</span></span><br><span class="line"><span class="comment"># 这是 Kafka Broker 通知 Producer 和 Consumer 如何连接到自己的方式。</span></span><br><span class="line"><span class="comment"># 例如，如果你设置 advertised.listeners=PLAINTEXT://my.public.ip:9092，</span></span><br><span class="line"><span class="comment"># 那么 Kafka Broker 将告诉 Producer 和 Consumer 它的公共 IP 地址是 my.public.ip，并且它在 9092 端口上监听连接。</span></span><br><span class="line"><span class="comment"># 这里我们需要在 3 个节点分别设置对应的地址</span></span><br><span class="line"><span class="attr">advertised.listeners</span>=<span class="string">PLAINTEXT://kafka1.com:9092</span></span><br></pre></td></tr></table></figure></li><li><p>格式化日志目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka-3.6.0/bin/kafka-storage.sh format -t <span class="variable">$KAFKA_CLUSTER_ID</span> -c /opt/kafka-3.6.0/config/kraft/server.properties</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Formatting /opt/kafka-3.6.0/kraft-combined-logs with metadata.version 3.6-IV2.</span><br></pre></td></tr></table></figure></li><li><p>三个节点都启动 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka-3.6.0/bin/kafka-server-start.sh -daemon /opt/kafka-3.6.0/config/kraft/server.properties</span><br></pre></td></tr></table></figure></li><li><p>选择任意一个节点创建一个新 topic</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic <span class="built_in">test</span> --replication-factor 1 --partitions=2</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Created topic <span class="built_in">test</span>.</span><br></pre></td></tr></table></figure></li><li><p>在其他节点获取 <code>test</code> 这个 <code>topic</code>的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>可以看到关于 <code>test</code> 这个 <code>topic</code>的信息是可以获取到的，说明集群之前信息是互通的，集群搭建完毕。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Topic: <span class="built_in">test</span>TopicId: svJClTUpSFa9Z6FWDvkARgPartitionCount: 2ReplicationFactor: 1Configs: segment.bytes=1073741824</span><br><span class="line">Topic: <span class="built_in">test</span>Partition: 0Leader: 2Replicas: 2Isr: 2</span><br><span class="line">Topic: <span class="built_in">test</span>Partition: 1Leader: 3Replicas: 3Isr: 3</span><br></pre></td></tr></table></figure></li><li><p>随便选择一个节点，往 <code>test</code> 里面写入数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka-3.6.0/bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>输入数据后按回车即发送一条数据，可以随时按 <code>Ctrl + C</code>退出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:~/Downloads$ /opt/kafka-3.6.0/bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span></span><br><span class="line">&gt;msg1</span><br><span class="line">&gt;msg2</span><br><span class="line">&gt;msg 3</span><br><span class="line">&gt;^</span><br></pre></td></tr></table></figure></li><li><p>随便选择一个节点，启动消费者消费 <code>topic</code>中的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka-3.6.0/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:/opt/kafka-3.6.0$ /opt/kafka-3.6.0/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br><span class="line">msg1</span><br><span class="line">msg2</span><br><span class="line">msg 3</span><br><span class="line">^CProcessed a total of 3 messages</span><br></pre></td></tr></table></figure></li></ol><p>至此，Kafka 的 KRaft 版本集群就部署完毕了！</p><details class="tag-plugin colorful folding" color="blue" open><summary><p>补充说明 - KRaft 配置文件</p></summary><div class="body"><p>下面是 Kafka KRaft 版本配置文件每个配置项的解释：</p><table><colgroup><col style="width: 40%" /><col style="width: 60%" /></colgroup><thead><tr class="header"><th>配置项</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>process.roles</td><td>Kafka 服务器的角色，设置此项将 Kafka 置于 KRaft 模式。可能的值包括"broker" 和 "controller"。</td></tr><tr class="even"><td>node.id</td><td>与此实例关联的节点 ID。</td></tr><tr class="odd"><td>controller.quorum.voters</td><td>控制器选举的投票节点，格式为 <code>node-id@host:port</code>。</td></tr><tr class="even"><td>listeners</td><td>服务器监听的地址，格式为<code>listener_name://host_name:port</code>。</td></tr><tr class="odd"><td>inter.broker.listener.name</td><td>用于 broker 之间通信的监听器名称。</td></tr><tr class="even"><td>advertised.listeners</td><td>服务器向客户端宣告的监听器名称、主机名和端口。</td></tr><tr class="odd"><td>controller.listener.names</td><td>控制器使用的监听器名称列表。</td></tr><tr class="even"><td>listener.security.protocol.map</td><td>监听器名称到安全协议的映射。默认情况下，它们是相同的。</td></tr><tr class="odd"><td>num.network.threads</td><td>服务器用于从网络接收请求和向网络发送响应的线程数。</td></tr><tr class="even"><td>num.io.threads</td><td>服务器用于处理请求（可能包括磁盘 I/O）的线程数。</td></tr><tr class="odd"><td>socket.send.buffer.bytes</td><td>服务器用于发送数据的缓冲区大小。</td></tr><tr class="even"><td>socket.receive.buffer.bytes</td><td>服务器用于接收数据的缓冲区大小。</td></tr><tr class="odd"><td>socket.request.max.bytes</td><td>服务器接受的请求的最大大小（用于防止内存溢出）。</td></tr><tr class="even"><td>log.dirs</td><td>用于存储日志文件的目录列表。</td></tr><tr class="odd"><td>num.partitions</td><td>每个主题的默认日志分区数。</td></tr><tr class="even"><td>num.recovery.threads.per.data.dir</td><td>每个数据目录在启动时用于日志恢复和关闭时用于刷新的线程数。</td></tr><tr class="odd"><td>offsets.topic.replication.factor</td><td>内部主题 "__consumer_offsets" 和 "__transaction_state"的复制因子。</td></tr><tr class="even"><td>transaction.state.log.replication.factor</td><td>事务状态日志的复制因子。</td></tr><tr class="odd"><td>transaction.state.log.min.isr</td><td>事务状态日志的最小同步副本数。</td></tr><tr class="even"><td>log.flush.interval.messages</td><td>强制将数据刷新到磁盘之前接受的消息数。</td></tr><tr class="odd"><td>log.flush.interval.ms</td><td>消息在日志中停留的最大时间，超过这个时间就会强制刷新到磁盘。</td></tr><tr class="even"><td>log.retention.hours</td><td>由于年龄而使日志文件有资格被删除的最小年龄。</td></tr><tr class="odd"><td>log.retention.bytes</td><td>基于大小的日志保留策略。</td></tr><tr class="even"><td>log.segment.bytes</td><td>日志段文件的最大大小。</td></tr><tr class="odd"><td>log.retention.check.interval.ms</td><td>检查日志段是否可以根据保留策略被删除的间隔。</td></tr></tbody></table><p>请注意，这只是 Kafka 配置的一部分，Kafka 配置的完整列表可以在 <ahref="https://kafka.apache.org/36/documentation.html#configuration">Kafka的官方文档</a>中找到。</p></div></details>]]></content>
    
    
    <summary type="html">Kafka 在 3.3.1 版本发布了第一个可以在生产环境使用的 KRaft 版本，正式拜托了 Zookeeper。本文基于 Kafka 3.6.0 版本，详细介绍了 Kafka KRaft 版本的集群部署过程。</summary>
    
    
    
    <category term="Kafka" scheme="https://hedon.top/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://hedon.top/tags/Kafka/"/>
    
    <category term="部署" scheme="https://hedon.top/tags/%E9%83%A8%E7%BD%B2/"/>
    
    <category term="中间件" scheme="https://hedon.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="消息队列" scheme="https://hedon.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 集群部署</title>
    <link href="https://hedon.top/2023/11/22/kakfa-cluster-deploy/"/>
    <id>https://hedon.top/2023/11/22/kakfa-cluster-deploy/</id>
    <published>2023-11-21T16:28:59.000Z</published>
    <updated>2025-03-03T11:31:34.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><ul><li>Ubuntu 18.04.6</li><li>Zookeeper 3.5.9</li><li>Kafka 2.7.0</li><li>JDK8</li></ul><h2 id="集群配置">集群配置</h2><table><colgroup><col style="width: 22%" /><col style="width: 22%" /><col style="width: 16%" /><col style="width: 22%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th style="text-align: center;">操作系统</th><th style="text-align: center;">ip</th><th style="text-align: center;">域名</th><th style="text-align: center;">Zookeeper 端口</th><th style="text-align: center;">Kafka 端口</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.131</td><td style="text-align: center;">kafka1.com</td><td style="text-align: center;">2181</td><td style="text-align: center;">9092</td></tr><tr class="even"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.132</td><td style="text-align: center;">kafka2.com</td><td style="text-align: center;">2181</td><td style="text-align: center;">9092</td></tr><tr class="odd"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.133</td><td style="text-align: center;">kafka3.com</td><td style="text-align: center;">2181</td><td style="text-align: center;">9092</td></tr></tbody></table><h2 id="安装-vim-curl">安装 vim, curl</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install vim</span><br><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure><h2 id="配置静态-ip-和-hosts">配置静态 ip 和 hosts</h2><p>为了使用域名，更加方便的进行配置，这里将虚拟机的 DHCP 改成了静态分配IP，所以需要手动设置一下每台机器 IP 地址，这里以<code>192.168.50.131</code> 为例。</p><ol type="1"><li><p>找到网络接口名称，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p>查找以 <code>ens</code> 或 <code>eth</code>开头的接口名称。例如，<code>ens33</code> 或 <code>eth0</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:~$ ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.50.133/24 brd 192.168.50.255 scope global dynamic noprefixroute ens33</span><br><span class="line">       valid_lft 1644sec preferred_lft 1644sec</span><br><span class="line">    inet6 fe80::c367:c7cc:3ad4:23b3/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>可以找到 <code>ens33</code>，其中 <code>inet 192.168.50.133/24</code>表示 IP 地址为 <code>192.168.50.133</code>，子网掩码为<code>/24</code>（等于 <code>255.255.255.0</code>）。</p><p>这个 IP 地址是 DHCP 动态分配的，说明宿主机分配给虚拟机的 IP 范围就在<code>192.168.50.xxx</code>，所以我们会将静态 IP配置在这个范围内。</p></li><li><p>获取网关地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route | grep default</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:~$ ip route | grep default</span><br><span class="line">default via 192.168.50.2 dev ens33 proto dhcp metric 100</span><br></pre></td></tr></table></figure><p>说明默认网关是 <code>192.168.50.2</code>，</p></li><li><p>编辑 <code>/etc/network/interfaces</code> 文件，配置静态 IP地址，内容如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto ens33</span><br><span class="line">iface ens33 inet static</span><br><span class="line">address 192.168.50.131</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.50.2</span><br><span class="line">dns-nameservers 8.8.8.8 8.8.4.4</span><br></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su reboot</span><br></pre></td></tr></table></figure></li><li><p>再次查看 ip 地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p>有以下输出便说明静态 IP 配置成功了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.50.131/24 brd 192.168.50.255 scope global ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fe82:9e69/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></li><li><p>配置域名</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p>追加内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.50.131 kafka1.com</span><br><span class="line">192.168.50.132 kafka2.com</span><br><span class="line">192.168.50.133 kafka3.com</span><br></pre></td></tr></table></figure></li><li><p>ping 一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:~$ ping kafka1.com</span><br><span class="line">PING kafka1.com (192.168.50.131) 56(84) bytes of data.</span><br><span class="line">64 bytes from kafka1.com (192.168.50.131): icmp_seq=1 ttl=64 time=0.024 ms</span><br><span class="line">64 bytes from kafka1.com (192.168.50.131): icmp_seq=2 ttl=64 time=0.021 ms</span><br><span class="line">64 bytes from kafka1.com (192.168.50.131): icmp_seq=3 ttl=64 time=0.029 ms</span><br><span class="line">^C</span><br><span class="line">--- kafka1.com ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2029ms</span><br><span class="line">rtt min/avg/max/mdev = 0.021/0.024/0.029/0.006 ms</span><br></pre></td></tr></table></figure></li><li><p>ping 一下百度，看看能不能访问外网</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:~$ ping baidu.com</span><br><span class="line">ping: baidu.com: Name or service not known</span><br></pre></td></tr></table></figure><p>如果这里可以访问，则直接跳过进入下一步，不可以的话，需要配置一下域名解析系统。</p></li><li><p>配置域名解析系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/resolv.conf</span><br></pre></td></tr></table></figure><p>追加下面内容：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.4.4</span><br></pre></td></tr></table></figure><p>再尝试 ping 一下百度：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:~$ ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com (153.3.238.110) 56(84) bytes of data.</span><br><span class="line">64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=1 ttl=128 time=15.9 ms</span><br><span class="line">64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=2 ttl=128 time=15.9 ms</span><br><span class="line">64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=3 ttl=128 time=16.1 ms</span><br><span class="line">64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=4 ttl=128 time=15.3 ms</span><br><span class="line">^C</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 14104ms</span><br><span class="line">rtt min/avg/max/mdev = 15.368/15.850/16.145/0.291 ms</span><br></pre></td></tr></table></figure></li></ol><details class="tag-plugin colorful folding" color="blue" open><summary><p>补充说明：<code>/etc/network/interfaces</code> 文件的配置</p></summary><div class="body"><p>这是一个用于配置 Linux 系统上网络接口的文件。在这个示例中，我们为名为<code>ens33</code> 的网络接口配置了静态 IP地址和相关的网络设置。下面是各行的解释：</p><ol type="1"><li><p><code>auto ens33</code>: 这一行表示在系统启动时自动激活<code>ens33</code> 网络接口。<code>auto</code>关键字后面跟着接口名称。</p></li><li><p><code>iface ens33 inet static</code>: 这一行定义了<code>ens33</code> 网络接口的配置。<code>iface</code>关键字后面跟着接口名称，<code>inet</code> 表示我们正在配置 IPv4地址，<code>static</code> 表示我们要为接口分配一个静态 IP地址（而不是通过 DHCP 获得）。</p></li><li><p><code>address 192.168.50.131</code>: 这一行设置了网络接口的静态IP 地址。在这个例子中，我们为 <code>ens33</code> 接口分配了<code>192.168.50.131</code> IP 地址。</p><blockquote><p>IP 地址是 Internet协议（IP）用于在网络中唯一标识设备的数字标签。每个连接到网络的设备都需要一个唯一的IP 地址，以便其他设备可以找到并与之通信。IP 地址通常分为两种版本：IPv4和 IPv6。在此示例中，我们使用了一个 IPv4 地址。</p></blockquote></li><li><p><code>netmask 255.255.255.0</code>:这一行定义了子网掩码。在这个例子中，子网掩码是<code>255.255.255.0</code>，表示前三个字节（24位）是网络地址，最后一个字节（8 位）是主机地址。</p><blockquote><p>子网掩码用于划分 IP 地址的网络部分和主机部分。子网掩码与 IP地址进行按位与操作，从而得到网络地址。这有助于确定哪些 IP地址属于同一子网，以便正确地将数据包路由到目的地。子网划分有助于组织网络、提高安全性和管理性。</p></blockquote></li><li><p><code>gateway 192.168.50.2</code>:这一行设置了默认网关。在这个例子中，我们将默认网关设置为<code>192.168.50.2</code>。默认网关是用于将数据包发送到其他网络的路由器或设备的IP 地址。</p><blockquote><p>网关是一个充当网络中数据包传输的中继点的设备，通常是一个路由器。当一个设备需要将数据包发送到不同子网的另一个设备时，它会将数据包发送到网关。网关负责将数据包路由到正确的目的地。默认网关是设备用于将数据包发送到其他网络的首选网关。</p></blockquote></li><li><p><code>dns-nameservers 8.8.8.8 8.8.4.4</code>: 这一行指定了 DNS服务器的 IP 地址。在这个例子中，我们使用了谷歌的公共 DNS 服务器<code>8.8.8.8</code> 和 <code>8.8.4.4</code>。DNS服务器用于将主机名解析为 IP 地址。</p><blockquote><p>域名系统（DNS）是将人类可读的域名（例如 www.baidu.com）IP地址的系统。DNS服务器是负责执行此解析过程的服务器。当您在浏览器中输入一个网址时，计算机会向DNS 服务器查询该域名对应的 IP 地址，然后将请求发送到该 IP地址以获取网页内容。</p></blockquote></li></ol><p>配置文件中的这些设置将在系统启动时生效。要立即应用更改，您可以使用以下命令重启网络服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart networking</span><br></pre></td></tr></table></figure></div></details><h2 id="安装-jdk">安装 jdk</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure><p>验证 java8 是否已经安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>有以下类似输出的话则表明安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openjdk version <span class="string">&quot;1.8.0_362&quot;</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_362-8u372-ga~us1-0ubuntu1~18.04-b09)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.362-b09, mixed mode)</span><br></pre></td></tr></table></figure><h2 id="安装-zookeeper">安装 zookeeper</h2><p>在 Ubuntu 上，您可以通过以下步骤安装 Apache Zookeeper 3.5.9：</p><ol type="1"><li>下载 Apache Zookeeper 3.5.9 的二进制文件。使用以下命令下载并解压缩Zookeeper：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz</span><br><span class="line">tar -xzf apache-zookeeper-3.5.9-bin.tar.gz</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>将解压缩后的文件夹移动到 <code>/opt</code> 目录中：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> apache-zookeeper-3.5.9-bin /opt/zookeeper-3.5.9</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>在 <code>/opt/zookeeper-3.5.9</code> 目录中创建一个名为<code>data</code> 的文件夹，用于存储 Zookeeper 的数据：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /opt/zookeeper-3.5.9/data</span><br></pre></td></tr></table></figure><ol start="6" type="1"><li>在 <code>/opt/zookeeper-3.5.9/data</code> 下创建 myid文件并设置内容为 <code>1</code>，其他两台机器则为 <code>2</code> 和<code>3</code>：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 | sudo <span class="built_in">tee</span> /opt/zookeeper-3.5.9/data/myid</span><br></pre></td></tr></table></figure><ol start="7" type="1"><li>复制 Zookeeper 配置文件样本，并将其命名为<code>zoo.cfg</code>：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /opt/zookeeper-3.5.9/conf/zoo_sample.cfg /opt/zookeeper-3.5.9/conf/zoo.cfg</span><br></pre></td></tr></table></figure><ol start="8" type="1"><li>使用文本编辑器（例如 vim）编辑 <code>zoo.cfg</code> 文件：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /opt/zookeeper-3.5.9/conf/zoo.cfg</span><br></pre></td></tr></table></figure><ol start="9" type="1"><li>修改 <code>zoo.cfg</code> 文件：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># 设置数据存储目录</span></span><br><span class="line">dataDir=/opt/zookeeper-3.5.9/data</span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="comment"># 设置集群信息</span></span><br><span class="line">server.1=kafka1.com:2888:3888</span><br><span class="line">server.2=kafka2.com:2888:3888</span><br><span class="line">server.3=kafka3.com:2888:3888</span><br></pre></td></tr></table></figure><blockquote><p>在 Zookeeper 的配置文件中，<code>server.x=hostname:port1:port2</code>这种格式的配置项是用来设置 Zookeeper集群（集群模式下）的。其中，<code>x</code> 是服务器的ID，<code>hostname</code> 是服务器的主机名或 IP 地址，<code>port1</code>和 <code>port2</code> 是用于集群间通信的端口。</p><p>具体来说：</p><ul><li><p><code>port1（2888）</code>：这是服务器之间用于相互通信的端口。Zookeeper服务器使用这个端口进行 leader 选举以及同步 follower 和 leader之间的状态。</p></li><li><p><code>port2（3888）</code>：这个端口用于服务器之间的 leader选举。在 Zookeeper 集群启动或者在 leader 服务器崩溃后，follower服务器会通过这个端口进行新一轮的 leader 选举。</p></li></ul><p>这两个端口可以根据你的网络配置进行修改，但必须在所有的 Zookeeper服务器上保持一致。</p></blockquote><ol start="10" type="1"><li>三个节点都启动 Zookeeper 服务器：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/zookeeper/bin/zkServer.sh start</span><br></pre></td></tr></table></figure><p>可以连接到 Zookeeper 的端口上（默认是<code>2181</code>），通过发送四字命令 <code>srvr</code> 来验证 Zookeeper是否安装正确（部署集群的话需要把所有 Zookeeper 启动）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hedon@ubuntu:/opt/zookeeper-3.5.9$ telnet localhost 2181</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line">srvr</span><br><span class="line">Zookeeper version: 3.5.9-83df9301aa5c2a5d284a9940177808c01bc35cef, built on 01/06/2021 19:49 GMT</span><br><span class="line">Latency min/avg/max: 0/0/0</span><br><span class="line">Received: 1</span><br><span class="line">Sent: 0</span><br><span class="line">Connections: 1</span><br><span class="line">Outstanding: 0</span><br><span class="line">Zxid: 0x0</span><br><span class="line">Mode: standalone</span><br><span class="line">Node count: 5</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure><ol start="11" type="1"><li>要停止 Zookeeper 服务器，可以使用以下命令：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/zookeeper/bin/zkServer.sh stop</span><br></pre></td></tr></table></figure><h2 id="安装-kafka">安装 Kafka</h2><ol type="1"><li><p>下载并解压 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/kafka/2.7.0/kafka_2.13-2.7.0.tgz</span><br><span class="line">tar -zxvf kafka_2.13-2.7.0.tgz</span><br></pre></td></tr></table></figure></li><li><p>将解压缩后的文件夹移动到 <code>/opt</code> 目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> kafka_2.13-2.7.0 /opt/kafka-2.7.0</span><br></pre></td></tr></table></figure></li><li><p>创建日志目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /opt/kafka-2.7.0/kafka-logs</span><br></pre></td></tr></table></figure></li><li><p>备份 Kafka 默认配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /opt/kafka-2.7.0/config/server.properties /opt/kafka-2.7.0/config/server.properties.bak</span><br></pre></td></tr></table></figure></li><li><p>修改 Kafka 配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /opt/kafka-2.7.0/config/server.properties</span><br></pre></td></tr></table></figure><p>主要是修改下面几个配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群中每个 broker 的 id 必须唯一，这里分别为 1，2，3</span></span><br><span class="line"><span class="attr">broker.id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 日志目录</span></span><br><span class="line"><span class="attr">log.dirs</span>=<span class="string">/opt/kafka-2.7.0/kafka-logs</span></span><br><span class="line"><span class="comment"># 配置 Zookeeper</span></span><br><span class="line"><span class="attr">zookeeper.connect</span>=<span class="string">kafka1.com:2181,kafka2.com:2181,kafka3.com:2181</span></span><br><span class="line"><span class="comment"># 定义 Kafka Broker 在哪些网络地址上监听连接，下面配置表示在所有的 IP 地址上监听 9092 端口</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://:9092</span></span><br><span class="line"><span class="comment"># 定义 Kafka Broker 如何向外部公布它的地址。这是 Kafka Broker 通知 Producer 和 Consumer 如何连接到自己的方式。例如，如果你设置 advertised.listeners=PLAINTEXT://my.public.ip:9092，那么 Kafka Broker 将告诉 Producer 和 Consumer 它的公共 IP 地址是 my.public.ip，并且它在 9092 端口上监听连接。</span></span><br><span class="line"><span class="attr">advertised.listeners</span>=<span class="string">PLAINTEXT://kafka1.com:9092</span></span><br></pre></td></tr></table></figure></li><li><p>三个节点都启动 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka-2.7.0/bin/kafka-server-start.sh -daemon /opt/kafka-2.7.0/config/server.properties</span><br></pre></td></tr></table></figure></li><li><p>选择任意一个节点创建一个新 topic</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka-2.7.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic <span class="built_in">test</span> --replication-factor 1 --partitions=2</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Created topic <span class="built_in">test</span>.</span><br></pre></td></tr></table></figure></li><li><p>在其他节点获取 <code>test</code> 这个 <code>topic</code>的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka-2.7.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>可以看到关于 <code>test</code> 这个 <code>topic</code>的信息是可以获取到的，说明集群之前信息是互通的，集群搭建完毕。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Topic: <span class="built_in">test</span>PartitionCount: 2ReplicationFactor: 1Configs: segment.bytes=1073741824</span><br><span class="line">Topic: <span class="built_in">test</span>Partition: 0Leader: 1Replicas: 1Isr: 1</span><br><span class="line">Topic: <span class="built_in">test</span>Partition: 1Leader: 2Replicas: 2Isr: 2</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">本文总结了在 Ubuntu18.04 虚拟机上部署 Kafka 集群的具体过程。</summary>
    
    
    
    <category term="Kafka" scheme="https://hedon.top/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://hedon.top/tags/Kafka/"/>
    
    <category term="部署" scheme="https://hedon.top/tags/%E9%83%A8%E7%BD%B2/"/>
    
    <category term="中间件" scheme="https://hedon.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="消息队列" scheme="https://hedon.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Raft-Extended 论文翻译</title>
    <link href="https://hedon.top/2023/11/18/raft/"/>
    <id>https://hedon.top/2023/11/18/raft/</id>
    <published>2023-11-18T14:29:59.000Z</published>
    <updated>2025-03-03T11:31:54.383Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf</p></blockquote><h2 id="辨析">辨析</h2><p><strong>consensus</strong> vs <strong>consistency</strong></p><p>一致性（consistency）往往指分布式系统中多个副本对外呈现的数据的状态。如顺序一致性、线性一致性，描述了多个节点对数据状态的维护能力。</p><p>共识（consensus）则描述了分布式系统中多个节点之间，彼此对某个提案达成一致结果的过程。</p><p>因此，一致性描述的是<strong>结果</strong>，共识则是一种<strong>手段</strong>。</p><p>有的人会说一致性和共识实际上是一个问题的一体两面，某种程度上来说，共识方法确实可以看作是实现强一致性的一种方法。事实上在工业界有许多以共识算法作为核心组件的多副本状态机（ReplicatedStateMachine）实现，本质上利用了共识算法保证了所有副本的操作日志具有完全相同的顺序，从而实现了副本的一致性。但是，即使是在这样的场景下，讨论一个共识算法的一致性也是不合适的，因<strong>为整个分布式系统最终的一致性并不单单取决于共识算法，共识算法只是解决了其中一个问题。</strong></p><blockquote><p>参考：https://zhuanlan.zhihu.com/p/68743917</p></blockquote><h2 id="摘要">0. 摘要</h2><p>Raft 是用来管理复制日志（replicated log）的一致性协议。它跟multi-Paxos 作用相同，效率也相当。但是它的组织结构跟 Paxos不同，也是因为 Raft更简单的架构使得它更容易被理解，并且更容易在实际工程中得以实现。</p><p>为了让 Raft 更容易被理解，Raft将共识算法的关键性因素切分成几个部分，比如：</p><ul><li>leader election（领导者选举）</li><li>log replication（日志复制）</li><li>safety（安全性）</li></ul><p>并且 Raft实施了一种更强的共识性以便减少必须要考虑的状态（states）的数量。</p><p>用户研究表明，对于学生来说，Raft 相比于 Paxos 是更容易学习的。</p><p>Raft还包括一个用于解决<strong>变更集群成员问题</strong>的新机制，它使用重写多数来保证安全性。</p><h2 id="介绍">1. 介绍</h2><p>共识算法允许多台机器作为一个集群协同工作，并且在其中的某几台机器出故障时集群仍然能正常工作。正因为如此，共识算法在建立可靠的大规模软件系统方面发挥了重要作用。在过去十年中，Paxos[15,16] 主导了关于共识算法的讨论：大多数共识性的实现都是基于 Paxos或受其影响，Paxos 已经成为教授学生关于共识知识的主要工具。</p><p>比较遗憾的是，尽管很多人一直在努力尝试使 Paxos 更易懂，Paxos还是太难理解了。此外，Paxos的架构需要复杂的改变来支持实际系统。这导致的结果就是系统开发者和学生在学生和使用Paxos 过程中都很挣扎。</p><p>在我们自己与 Paxos斗争之后，我们开始着手寻找一个新的共识算法，希望可以为系统开发和教学提供更好的基础。我们的方法是不寻常的，因为我们的主要目标是可理解性：我们可以设计一个比Paxos 更适合用于实际工程实现并且更易懂的共识算法吗？</p><p>在该算法的设计中，重要的不仅是如何让算法起作用，还要清晰地知道该算法为什么会起作用。</p><p>这项工作的结果是一个称为 Raft 的共识性算法。在设计 Raft时，我们使用了特定的技术来提高它的可理解性，包括：</p><ul><li>分解（Raft 分离出三个关键点：leader election、logreplication、safety）</li><li>减少状态空间（相比于 Paxos，Raft降低了不确定性的程度和服务器之间的不一致）</li></ul><p>一项针对 2 所大学共 43 名学生的用户研究表明，Raft 比 Paxos更容易理解：在学习两种算法后，其中 33 名学生能够更好地回答 Raft的相关问题。</p><p>Raft 在许多方面类似于现有的公式算法（尤其是 Oki、Liskov 的Viewstamped Replication [29,22]），但它有几个新特性：</p><ul><li><strong>Strong leader（强领导性）</strong>：相比于其他算法，Raft使用了更强的领导形式。比如，日志条目只能从 leader 流向follower（集群中除 leader 外其他的服务器）。这在使 Raft更易懂的同时简化了日志复制的管理流程。</li><li><strong>Leader election（领导选举）</strong>：Raft使用随机计时器来进行领导选举。任何共识算法都需要心跳机制（heartbeats），Raft只需要在这个基础上，添加少量机制，就可以简单快速地解决冲突。</li><li><strong>Membership changes（成员变更）</strong>：Raft在更改集群中服务器集的机制中使用了一个 <strong>联合共识（jointconsensus）</strong> 的方法。在联合共识（jointconsensus）下，在集群配置的转换过程中，新旧两种配置大多数是重叠的，这使得集群在配置更改期间可以继续正常运行。</li></ul><p>我们认为 Raft 跟 Paxos以及其他共识算法相比是更优的，这不仅体现在教学方面，还体现在工程实现方面。</p><ul><li>它比其他算法更简单且更易于理解</li><li>它被描述得十分详细足以满足实际系统的需要</li><li>它有多个开源实现，并被多家公司使用</li><li>它的安全性已被正式规定和验证</li><li>它的效率与其他算法相当</li></ul><p>本文剩余部分：</p><table><thead><tr class="header"><th>所在节</th><th>内容</th></tr></thead><tbody><tr class="odd"><td>第 2 节</td><td>复制状态机问题（replicated state machine problem）</td></tr><tr class="even"><td>第 3 节</td><td>Paxos 的优缺点</td></tr><tr class="odd"><td>第 4 节</td><td>实现 Raft 易理解性的措施</td></tr><tr class="even"><td>第 5-8 节</td><td>Raft 共识性算法详细阐述</td></tr><tr class="odd"><td>第 9 节</td><td>评估 Raft</td></tr><tr class="even"><td>第 10 节</td><td>其他相关工作</td></tr></tbody></table><h2 id="复制状态机">2. 复制状态机</h2><p>共识算法一般都是在复制状态机 [37]的背景下实现的。在这种方法下，一组服务器在的状态机计算相同状态的相同副本，即使某些服务器崩溃，它们也可以继续运行。</p><p>复制状态机是用来解决分布式系统中的各种容错问题。比如说，具有单个leader 的大规模的系统，如 GFS [8]，HDFS [38] 和 RAMCloud [33]，他们通常都使用单独的复制状态机来管理 leader election 和保存 leader崩溃后重新选举所需的配置信息。像 Chubby [2] 和 ZooKeeper [11]都是复制状态机。</p><p>复制状态机通常都是使用日志复制（logreplication）来实现。如图1：每个服务器都保存着一份拥有一系列命令的日志，然后服务器上的状态机会按顺序执行日志中的命令。每一份日志中命令相同并且顺序也相同，因此每个状态机可以处理相同的命令序列。所以状态机是可确定的，每个状态机都执行相同的状态和相同的输出序列。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsmihlh9ptj322u0nsgpj.jpg"alt="image-20210719200404010" /><figcaption aria-hidden="true">image-20210719200404010</figcaption></figure><p>共识算法的主要工作就是保证复制日志（replicatedlog）的一致性。每台服务器上的共识模块接收来自客户端的命令，并将这些命令添加到其日志当中。它（指共识模块）与其他服务器上的共识模块进行通信，以确保每台服务器上最终以相同的顺序包含相同的命令，即使部分服务器崩溃了，这个条件也可以满足。一旦命令被正确复制，每台服务器上的状态机就会按日志顺序处理它们，并将输出返回给客户端。这样就形成了高可用的复制状态机。</p><p>适用于实际系统的共识算法通常都包含以下几点特征：</p><ul><li><p>它们确保在所有非拜占庭错误下的安全性，也就是从不返回一个错误的结果。（即使是网络延迟、分区、数据包丢失、数据包重复和数据包乱序）</p><blockquote><p><strong><ahref="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">拜占庭错误</a>：</strong></p><p>出现故障（crash 或fail-stop，即不响应）但不会伪造信息的情况称为“非拜占庭错误”。</p><p>伪造信息恶意响应的情况称为“拜占庭错误”，对应节点称为拜占庭节点。</p></blockquote></li><li><p>只要任何大多数（过半）服务器是可运行的，并且可以互相通信和与客户端通信，那么共识算法就可用。假设服务器崩溃了，一小段时间后，它们很可能会根据已经稳定存储的状态来进行恢复，并重新加入集群。</p></li><li><p>它们在保证日志一致性上不依赖于时序：错误的时钟和极端消息延迟在最坏的情况下会产生影响可用性的一系列问题。</p></li><li><p>在通常情况下，只要集群中大部分（过半）服务器已经响应了单轮远程过程调用（RPC），命令就可以被视为完成。少数（一半以下）慢服务器不会影响整个系统的性能。</p></li></ul><h2 id="paxos-存在的问题">3. Paxos 存在的问题</h2><p>在过去的十年间，Leslie Lamport 的 Paxos 协议 [15]几乎成为共识性（consensus）的同义词。它是课堂上被教授最多的共识协议，大多数共识性的实现也是以它为起点。Paxos首先定义了能在单个决策问题（例如单个复制日志条目）上达成共识的协议。我们将这个子集称为<em>signle-degree Paxos</em>。然后 Paxos组合该协议的多个实例去实现一系列决策，比如日志（<em>mutil-Paxos</em>）。Paxos保证了安全性和活性，它也支持改变集群中的成员，它的安全性也已经被论证了，并且大多数情况下都是高效的。</p><p>美中不足的是，Paxos 有两个严重的缺点：</p><ol type="1"><li><p><strong>Paxos 非常难理解</strong></p><p>众所周知，Paxos非常晦涩难懂，除非下了很大的功夫，很少有人能够成功理解它。因此，尽管目前已经有几个尝试希望将Paxos [16,20,21] 解释得通俗易懂一些，而且这些解释都集中在<code>single-decree Paxos</code>，但是它们还是很难懂。</p><p>在对 NSDI 2012 参会者的非正式调查中，我们发现很少人会喜欢Paxos，即使是经验丰富的研究人员。我们自己也一直在跟 Paxos作斗争，我们也无法完全理解整个 Paxos协议，直到阅读了几个更简单的描述和自己设计了替代 Paxos 的协议，我们才对Paxos 有了比较深刻的理解。但这个过程，花了将近一年。</p><p>我们推测 Paxos 这么晦涩难懂，主要是因为作者选择了<code>Single-decree Paxos</code>来作为基础。<code>Single-decree Paxso</code>非常搞人：它分为两个阶段，但是并没有对这两个阶段进行简单直观的说明，而且这两个阶段也不能分开了单独理解，所以使用者将就很难理解为什么该算法能起作用。<code>Multi-Paxos</code>的合成规则又增加了许多复杂性。我们相信，对多个决定（日志，并非单个日志条目）达成共识的总体问题可以用其他更直接和更明显的方式进行分解。</p></li><li><p><strong>Paxos 没有为实际实现提供一个良好的基础</strong></p><p>其中一个原因是没有广泛认同的针对 <code>Multi-Paxos</code>的算法。Lamport 的描述主要是针对 <code>signle-decree Paxos</code>的，他描述了针对 <code>multi-Paxos</code>的可能方法，但缺少了很多细节。</p><p>目前已经有人在尝试具体化和优化 Paxos，比如 [26]，[39] 和[13]，但是这些尝试都互不相同并且它们跟 Lamport 描述的也不尽相同。虽然像Chubby [4] 这样的系统已经实现了类Paxos（Paxos-like）算法，但是他们并没有透露出很多的实现细节。</p></li></ol><p>此外，Paxos 的架构对于构建实际系统来说其实是一个糟糕的设计，这是<code>single-decree Paxos</code>分解的另一个结果。举个例子，这对于独立选择地日志条目的集合，然后再将它们合并到顺序日志当中没有任何好处，这只会增加复杂性。围绕日志来设计系统是更加简单和高效的方法，其中新条目按受约束的顺序依次附加。另外一个问题是Paxos在其核心使用了<strong>对称对等方法</strong>（尽管它最终表明了这会被用作一种性能优化的弱领导模式）。这在只有一个决策的情况下是有意义的，但是尽管如此，还是很少有实际系统采用了这种方法。如果有一系列的决策需要制定，更简单和更快速的方法应该是首先选择一个leader，然后由 leader 去协调这些决策。</p><p>因此，按照 Paxos 来实现的实际系统往往跟 Paxos相差很大。几乎所有的实现都是从 Paxos开始，然后在实现的过程中发现了一系列的难题，在解决难题的过程中，开发出了跟Paxos 完全不一样的架构。这样既费时又容易出错，而且 Paxos本身的晦涩难懂又使得问题变得更加严重。Paxos公式可能是证明其正确性的一个很好的公式，但真正的实现与 Paxos又相差很大，这证明了它其实没有什么价值。下面来自 Chubby作者的评论非常典型：</p><blockquote><p>在 Paxos 算法描述和现实实现系统之间有着巨大的鸿沟... （如果一直按照Paxos 算法走下去），最终的系统往往会建立在一个还未被证明的协议之上。</p></blockquote><p>综合上述问题，我们觉得 Paxos在教学端和系统构建端都没有提供一个良好的基础。考虑到共识性在大规模软件系统中的重要性，我们决定去尝试一下看看能不能设计一个替代Paxos 并且具有更好特性的共识算法。Raft 就是这次实验的结果。</p><h2 id="为可理解性而设计">4. 为可理解性而设计</h2><p>在设计 Raft 算法过程中我们有几个目标：</p><ul><li>它必须为系统构建提供一个完整且实际的基础，这样才能大大减少开发者的工作</li><li>它必须在任何情况下都是安全的并且在典型的应用条件下是可用的，并且在正常情况下是高效的</li></ul><p>但是我们最重要的目标，也是我们遇到的最大的挑战：</p><ul><li>它必须具有易理解性，它必须保证能够被大多数人轻松地理解。而且它必须能够让人形成直观的认识，这样系统构建者才能在实现过程中对它进行不可避免的拓展。</li></ul><p>在设计 Raft算法的过程中，很多情况下我们需要在多个备选方案下做出抉择。在这种情况下，我们往往会基于可理解性来进行抉择：</p><ul><li>解释各个备选方案的难度有多大？例如，它的状态空间有多复杂？它是否具有难以理解的含义？</li><li>对于一个读者来说，完成理解这个方案和方案中的各种含义是否简单？</li></ul><p>我们意识到这一的分析具有高度的主观性。所以我们采取了两种通用的措施来解决这个问题。</p><ol type="1"><li>第一个措施就是众所周知的问题分解：只要有可能，我们就将问题划分成几个相对独立地解决、解释和理解的子问题。例如，Raft算法被我们划分成 leader 选举、日志复制、安全性和成员变更几个部分。</li><li>第二个措施是通过减少状态的数量来简化状态空间，尽可能地使系统变得更加连贯和尽可能地消除不确定性。很明显的一个例子就是，所有的日志都是不允许有空挡的，并且Raft限制了日志之间可能不一样的方式。尽管在大多数情况下我们都极力去消除不确定性，但是在某些情况下不确定性却可以提高可理解性。一个重要的例子就是随机化方法，它们虽然引入了不确定性，但是它们往往能够通过以类似的方式处理所有可能的选择来减少状态空间（随便选，没关系）。所有我们使用了随机化来简化Raft 中的 leader election 算法。</li></ol><h2 id="raft-共识算法">5. Raft 共识算法</h2><p>Raft 是一种用来管理第 2 节中提到的复制日志（replicatedlog）的算法。图 2 是该算法的浓缩，可以作为参考。图 3列举了该算法的一些关键特性。这两张图中的内容将会在后面的各个章节中逐一介绍。</p><p>Raft 在实现共识算法的过程中，首先选举一个 distinguishedleader，然后由该 leader 全权负责复制日志的一致性。Leader从客户端接收日志条目，然后将这些日志条目复制给其他服务器，并且在保证安全性的情况下通知其他服务器将日志条目应用到他们的状态机中。拥有一个leader 大大简化了对复制日志的管理流程。例如，leader可以在不跟其他服务器商议的情况下决定新的日志条目应该存放在日志的什么位置，并且数据都是从leader 流向其他服务器。当然了，一个 leader可能会崩溃，也可能与其他服务器断开连接，那么这个时候，Raft就会选举出一个新的 leader 出来。</p><p>通过选举一个 leader 的方式，Raft将共识问题分解成三个独立的子问题，这些问题将会在接下来的子章节中进行讨论：</p><ul><li><p><strong>Leader election（领导选举）</strong></p><p>一个 leader 倒下之后，一定会有一个新的 leader 站起来。</p></li><li><p><strong>Log replication（日志复制）</strong></p><p>leader必须接收来自客户端的日志条目然后复制到集群中的其他节点，并且强制其他节点的日志和自己的保持一致。</p></li><li><p><strong>Safety（安全性）</strong></p><p>Raft 中安全性的关键是图 3中状态机的安全性：只要有任何服务器节点将一个特定的日志条目应用到它的状态机中，那么其他服务器节点就不能在同一个日志索引位置上存储另外一条不同的指令。第5.4 节将会描述 Raft 如何保证这种特性，而且该解决方案在 5.2节描述的选举机制上还增加了额外的限制。</p></li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsar1v5rklj32300pc4bj.jpg"alt="image-20210709155333989" /><figcaption aria-hidden="true">image-20210709155333989</figcaption></figure><p>在展示了 Raft共识算法后，本章节将讨论可用性的一些问题以及时序在系统中的所用。</p><h3 id="raft-基础">5.1 Raft 基础</h3><p>一个 Raft 集群中包含若干个服务器节点，<font color="green"><strong>5个一个比较典型的数字，5 个服务器的集群可以容忍 2个节点的失效</strong></font>。在任何一个时刻，集群中的每一个节点都只可能是以下是三种身份之一：</p><ul><li>leader：它会处理所有来自客户端的请求（如果一个客户端和 follower通信，follower 会将请求重定向到 leader 上）</li><li>follower：它们被动的：它们不会发送任何请求，只是简单的响应来自leader 和 candidate 的请求</li><li>candidate：这是用来选举一个新的 leader的时候出现的一种临时状态，这将在第 5.2 节中详细描述</li></ul><p>在正常情况下，集群中只有一个 leader，然后剩下的节点都是 follower。图4展示了这些状态和它们之间的转换关系，这些转换关系将会在接下来进行讨论。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsap8d6ijjj322s0l47g5.jpg"alt="image-20210709145034498" /><figcaption aria-hidden="true">image-20210709145034498</figcaption></figure><p>如图 5 所示，Raft将时间划分成任意长度的任期（term）。每一段任期从一次选举开始，在这个时候会有一个或者多个candidate 尝试去成为 leader。如果某一个 candidate赢得了选举，那么它就会在任期剩下的时间里承担一个 leader的角色。在某些情况下，一次选举无法选出 leader，这个时候这个任期会以没有leader而结束。同时一个新的任期（包含一次新的选举）会很快重新开始。这是因为Raft 会保证在任意一个任期内，至多有一个 leader。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsapcmhhi4j31ym0ig78s.jpg"alt="image-20210709145441879" /><figcaption aria-hidden="true">image-20210709145441879</figcaption></figure><p>集群中不同的服务器观察到的任期转换的次数也许是不同的，在某些情况下，一个节点可能没有观察到leader 选举过程甚至是整个任期过程。</p><p>任期在 Raft 中还扮演着一个逻辑时钟（logicalclock）的角色，这使得服务器可以发现一些过期的信息，比如过时的leader。</p><p>每一个节点都存储着一个当前任期号（current termnumber），该任期号会随着时间<strong>单调递增</strong>。节点之间通信的时候会交换当前任期号，如果一个节点的当前任期号比其他节点小，那么它就将自己的任期号更新为较大的那个值。如果一个candidate 或者 leader 发现自己的任期号过期了，它就会立刻回到 follower状态。如果一个节点接收了一个带着过期的任期号的请求，那么它会拒绝这次请求。</p><p>Raft 算法中服务器节点之间采用 RPC进行通信，一般的共识算法都只需要两种类型的 RPC。</p><ul><li><strong>RequestVote RPCs（请求投票）</strong>：由 candidate在选举过程中发出（5.2 节中描述）</li><li><strong>AppendEntries RPCs（追加条目）</strong>：由 leader发出，用来做日志复制和提供心跳机制（5.3 节中描述）。</li></ul><p>在第 7 节中为了在节点之间传输快照（snapshot）增加了第三种RPC。当节点没有及时的收到 RPC的响应时，会进行重试，而且节点之间都是以并行（parallel）的方式发送 RPC请求，以此来获得最佳的性能。</p><h3 id="leader-election">5.2 Leader election</h3><p>Raft 采用一种心跳机制来触发 leader选举。当服务器启动的时候，他们都会称为 follower。一个服务器节点只要从candidate 或者 leader 那接收到有效的 RPC 就一直保持 follower的状态。Leader 会周期性地向所有的 follower 发起心跳来维持自己的 leader地位，所谓心跳，就是不包含日志条目的 AppendEntries RPC。如果一个follower 在一段时间内没有收到任何信息（这段时间我们称为<strong>选举超时election timeout</strong>），那么它就会假定目前集群中没有一个可用的leader，然后开启一次选举来选择一个新的 leader。</p><p>开始进行选举的时候，一个 follower 会自增当前任期号然后切换为candidate 状态。然后它会给自己投票，同时以并行的方式发送一个 RequestVoteRPCs 给集群中的其他服务器节点（企图得到它们的投票）。一个 candidate会一直保持当前状态直到以下的三件事之一发生（这些情况都会在下面的章节里分别讨论）：</p><ul><li>它赢得选举，成为了 leader</li><li>其他节点赢得了选择，那么它会变成 follower</li><li>一段时间之后没有任何节点在选举中胜出</li></ul><p>当一个 candidate获取集群中过半服务器节点针对同一任期的投票时，它就赢得了这次选举并成为新的leader。对于同一个任期，每一个服务器节点会按照<strong>先来先服务原则（first-come-first-served）</strong> 只投给一个candidate（在5.4节会在投票上增加额外的限制）。这种要求获得过半投票才能成为 leader的规则确保了最多只有一个 candidate 赢得此次选举（图 3中的选举安全性）。只要有一个 candidate 赢得选举，它就会成为leader。然后它就会向集群中其他节点发送心跳消息来确定自己的地位并阻止新的选举。</p><p>一个 candidate在等待其他节点给它投票的时候，它也有可能接收到另外一个自称为 leader的节点给它发过来的 AppendEntries RPC。</p><ul><li>如果这个 leader 的任期号（这个任期号会在这次 RPC中携带着）不小于这个 candidate 的当前任期号，那么这个 candidate就会觉得这个 leader 是合法的，然后将自己转变为 follower 状态。</li><li>如果这个 leader 的任期号小于这个 candidate 的当前任期号，那么这个candidate 就会拒绝这次 RPC，然后继续保持 candidate 状态。</li></ul><p>第三种可能的结果是 candidate既没有赢得选举也没有输。可以设想一下这么一个情况。所有的 follower同时变成 candidate，然后它们都将票投给自己，那这样就没有 candidate能得到超过半数的投票了，投票无果。当这种情况发生的时候，每个 candidate都会进行一次超时响应（timeout），然后通过自增任期号来开启一轮新的选举，并启动另一轮的 RequestVoteRPCs。然而，如果没有额外的措施，这种无结果的投票可能会无限重复下去。</p><p>为了解决上述问题，Raft 采用 <strong>随机选举超时时间（randomizedelection timeouts）</strong>来确保很少发生无果的投票，并且就算发生了也能很快地解决。<strong>为了防止选票一开始就被瓜分，选举超时时间是从一个固定的区间（比如，150-300ms）中随机选择。这样可以把服务器分散开来以确保在大多数情况下会只有一个服务器率先结束超时，那么这个时候，它就可以赢得选举并在其他服务器结束超时之前发送心跳</strong>（译者注：乘虚而入，不讲武德）。</p><p>同样的机制也可以被用来解决选票被瓜分（split votes）的情况。每个candidate在开始一轮选举之前会重置一个随机选举超时时间，然后一直等待直到结束超时状态。这样减少了在一次投票无果后再一次投票无果的可能性。9.3节展示了该方案能够快速地选出一个 leader。</p><p>选举的例子可以很好地展现可理解性是如何指导我们在多种备选设计方案中做出抉择的。在一开始，我们本打算使用一种等级系统（ranksystem）：每一个 candidate 被赋予一个一次的等级（rank），如果一个candidate 发现另外一个 candidate 有着更高的登记，那么它就会返回 follower状态，这样可以使高等级的 candidate更加容易地赢得下一轮选举。但是我们发现这种方法在可用性方面会有一些小问题：<strong>如果等级较高的服务器崩溃了，那么等级较低的服务器可能需要进入超时状态，然后重新成为一个candidate。如果这种操作出现得太快，那么它可能会重启进程去开启一轮新的选举。</strong>经过我们对该算法做出了多次的调整，我们最终还是认为随机重试的方法更加通俗易懂。</p><h3 id="log-replication">5.3 Log replication</h3><p>Leader一旦被选举出来，它就要开始为客户端的请求提供服务了。每一个客户端请求都包含一条将被复制状态机执行的命令。leader会以一个新条目的方式将该命令追加到自己的日志中，并且以同步的方式向集群中的其他节点发起AppendEntiresRPCs，让它们复制该条目。当条目被安全地复制（何为安全复制，后面会介绍）之后，leader会将该条目应用到自己的状态机中，状态机执行该指令，然后把执行的结果返回给客户端。如果follower 崩溃了或者运行缓慢，或者网络丢包，leader 会不断地重试AppendEntiries RPCs（即使已经对客户端作出了响应）直到所有的 follower都成功存储了所有的日志条目。</p><p>日志以图 6 展示的方式组织着。每条日志条目都存储着一条状态机指令和leader收到该指定时的任期号。日志条目中的任期号可以用来检测多个日志副本之间是否不一致，以此来保证图3中的某些性质。每个日志条目还有一个整数索引值来表明它在日志中的位置。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsasp7ss8gj32220ssjy9.jpg"alt="image-20210709165036190" /><figcaption aria-hidden="true">image-20210709165036190</figcaption></figure><p>那么问题就来了，<strong>leader什么时候会觉得把日志条目应用到状态机是安全的呢？</strong>这种日志条目被称为已提交的日志条目。Raft保证这种已提交的日志条目都是持久化的并且最终都会被所有可用的状态机执行。<strong>一旦创建该日志条目的 leader 将它复制到过半的节点上时（比如图 6中的条目 7），该日志条目就会被提交。</strong> 同时，leader日志中该日志条目之前的所有日志条目也都会被提交，包括由之前的其他 leader创建的日志条目。5.4 节会讨论在 leader变更之后应用该规则的一些细节，并证明这种提交的规则是安全的。leader会追踪它所知道的要提交的最高索引，并将该索引包含在未来的 AppendEntriesRPC 中（包括心跳），以便其他的节点可以发现这个索引。一旦一个 follower知道了一个日志条目被提交了。它就会将该日志条目按日志顺序应用到自己的状态机中。</p><p>我们设计 Raft日志机制来使得不同节点上的日志之间可以保持高水平的一致性。这么做不仅简化了系统的行为也使得系统更加可预测，同时该机制也是保证安全性的重要组成部分。Raft会一直维护着以下的特性，这些特性也同时构成了图 3 中的日志匹配特性（LogMatching Property）：</p><ul><li>如果不同日志中的两个条目有着相同的索引和任期值，那么它们就存储着相同的命令</li><li>如果不同日志中的两个条目有着相同的索引和任期值，那么他们之前的所有日志条目也都相同</li></ul><p>第一条特性源于这样一个事实，在给定的一个任期值和给定的一个日志索引中，一个leader最多创建一个日志条目，而且日志条目永远不会改变它们在日志中的位置。</p><p>第二条特性是由 AppendEntries RPC执行的一个简单的一致性检查所保证的。当 leader 发送一个 AppendEntries RPC的时候，leader会将前一个日志条目的索引位置和任期号包含在里面（紧邻最新的日志条目）。如果一个follower在它的日志中找不到包含相同索引位置和任期号的条目，那么它就会拒绝该新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性（LogMatchingProperty）的，然后一致性检查保证了日志扩展时的日志匹配特性。因此，当AppendEntries RPC 返回成功时，leader 就知道 follower的日志一定和自己相同（从第一个日志条目到最新条目）。</p><p>正常操作期间，leader 和 follower 的日志都是保持一致的，所以AppendEntries 的一致性检查从来不会失败。但是，如果 leader崩溃了，那么就有可能会造成日志处于不一致的状态，比如说老的 leader可能还没有完全复制它日志中的所有条目它就崩溃了。这些不一致的情况会在一系列的leader 和 follower 崩溃的情况下加剧。图 7 解释了什么情况下 follower的日志可能和新的 leader 的日志不同。follower 可能会确实一些在新 leader中有的日志条目，也有可能拥有一些新的 leader没有的日志条目，或者同时存在。缺失或多出日志条目的情况有可能会涉及到多个任期。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gse5vxj5sfj31se0u017c.jpg"alt="image-20210712144330139" /><figcaption aria-hidden="true">image-20210712144330139</figcaption></figure><p>在 Raft 算法中，leader 通过强制 follower 复制 leader日志来解决日志不一致的问题。也就是说，follower 中跟 leader冲突的日志条目会被 leader 的日志条目所覆盖。5.4节会证明通过增加一个限制，这种方式就可以保证安全性。</p><p>为了使 follower 的日志跟自己（leader）一致，leader必须找到两者达成一致的最大的日志条目索引，删除 follower日志中从那个索引之后的所有日志条目，并且将自己那个索引之后的所有日志条目发送给follower。所有的这些操作都发生在 AppendEntries RPCs的一致性检查的回复中。leader 维护着一个针对每一个 follower 的<strong>nextIndex</strong>，这个 nextIndex 代表的就是 leader 要发送给follower 的下一个日志条目的索引。<strong>当选出一个新的 leader 时，该leader 将所有的 nextIndex 的值都初始化为自己最后一个日志条目的 index 加1（图7 中的 11）</strong>。如果一个 follower 的日志跟 leader的是不一致的，那么下一次的 AppendEntries RPC的一致性检查就会失败。<strong>AppendEntries RPC 在被 follower拒绝之后，leader 对 nextIndex 进行减 1，然后重试 AppendEntries RPC。最终nextIndex 会在某个位置满足 leader 和 follower在该位置及之前的日志是一致的，此时，AppendEntries RPC 就会成功，将follower 跟 leader 冲突的日志条目全部删除然后追加 leader中的日志条目（需要的话）</strong>。一旦 AppendEntries RPC 成功，follower的日志就和 leader 的一致了，并且在该任期接下来的时间里都保持一致。</p><blockquote><p>如果需要的话，下面的协议可以用来优化被拒绝的 AppendEntries RPCs的个数。</p><p>比如说，当拒绝一个 AppendEntries RPC 的时候，follower可以包含冲突条目的任期号和自己存储的那个任期的第一个index。借助这些信息，leader 可以跳过那个任期内所有的日志条目来减少indexIndex。这样就变成了每个有冲突日志条目的任期只需要一个 AppendEntriesRPC，而不是每一个日志条目都需要一次 AppendEntires RPC。</p><p>在实践中，我们认为这种优化是没有必要的，因为失败不经常发生并且也不可能有很多不一致的日志条目。</p></blockquote><p>通过上述机制，leader在当权之后就不需要任何特殊的操作来使日志恢复到一致状态。leader只需进行正常的操作，然后日志就能在回复 AppendEntries RPC一致性检查的时候自动趋于一致。leader从来不会重写或者删除自己的日志条目（图3 中的 Leader Append-Only属性）。</p><p>上述这种日志复制机制展现了第 2 节中描述的 Raft算法的共识特性：只要过半的节点能正常运行，Raft就能接受、复制并处理新的日志条目。在通常情况下，一个新的条目可以在一轮RPC 中被复制给集群中过半的节点，并且单个运行缓慢的 follower并不会影响整个集群的性能。</p><blockquote><p>译者注：<strong>总结</strong></p><p>Leader 收到 Client 的写请求，向所有 Follower发起一个日志同步请求，得到集群内过半节点（包括 Leader自己）的响应，就推进 commitIndex，然后 apply 日志到状态机，再推进applyIndex，返回 Client 成功。</p><p>状态机同步分为两轮 RPC 广播：</p><ul><li>第一轮：同步日志 AppendEntries，得到过半节点回复，Leader状态机推进，返回 Client 成功。</li><li>第二轮：在下一次的 AppendEntries 中附带上一次的commitIndex，Follower 收到后，apply 日志条目到各自的状态机。</li></ul></blockquote><h3 id="safety">5.4 Safety</h3><p>前面的章节描述了 Raft 如何做 Leader Election 和 LogReplication。然而，到目前为止所讨论的机制并不能充分地保证每一个状态机会按相同的顺序执行相同的指令。比如说，一个follower 可能会进入不可用状态，在此期间，leader可能提交了若干的日志条目，然后这个 follower 可能被选举为新的 leader并且用新的日志条目去覆盖这些日志条目。这样就会造成不同的状态机执行不同的指令的情况。</p><p>本节通过对 Leader Election 增加一个限制来完善 Raft算法。这个限制保证了对于给定的任意任期号，该任期号对应的 leader都包含了之前各个任期所有被提交的日志条目（图3 中的 Leader Completeness性质）。有了这个限制，我们也可以使日志提交规则更加清晰。最后，我们会展示对于Leader Completeness性质的简要证明并且说该性质是如何保证状态机执行正确的行为的。</p><h4 id="选举限制">5.4.1 选举限制</h4><p>在任何基于 leader 的共识算法中，leader最终都必须存储所有已经提交的日志条目。在某些共识算法中，例如 ViewstampedReplication[22]，即使一个节点它一开始并没有包含所有已经提交的日志条目，它也有可能被选举为leader。这些算法包含一些额外的机制来识别丢失的日志条目并将它们传送给新的leader，这个机制要么发生在选举阶段，要么在选举完成之后很快进行。比较遗憾的是，这种方法会增加许多额外的机制，使得算法复杂性大大增加。Raft使用了一种更加简单的方法，它可以保证新 leader在当选时就包含了之前所有任期中已经提交的日志条目，根本就不需要再传送这些日志条目给新的leader。这就意味着<strong>日志条目的传送只有一个方向，那就是从 leader 到follower，leader 从来不会覆盖本地日志中已有的日志。</strong></p><p>Raft 采用投票的方式来保证一个 candidate只有拥有之前所有任期中已经提交的日志条目之后，才有可能赢得选举。一个candidate 如果想要被选为leader，那它就必须跟集群中超过半数的节点进行通信，这就意味这些节点中至少一个包含了所有已经提交的日志条目。如果candidate的日志至少跟过半的服务器节点一样新，那么它就一定包含了所有以及提交的日志条目，一旦有投票者自己的日志比candidate 的还新，那么这个投票者就会拒绝该投票，该 candidate也就不会赢得选举。</p><blockquote><p>所谓 “<strong>新</strong>” ：</p><p>Raft通过比较两份日志中的最后一条日志条目的索引和任期号来定义谁的日志更新。</p><ul><li>如果两份日志最后条目的任期号不同，那么任期号大的日志更新</li><li>如果两份日志最后条目的任期号相同，那么谁的日志更长，谁就更新</li></ul></blockquote><h4 id="提交之前任期内的日志条目">5.4.2 提交之前任期内的日志条目</h4><blockquote><p>译者注：注意！这一节「提交之前任期内的日志条目」这种操作 Raft的不允许的！本小节只是用来举一种错误情况！</p></blockquote><p>如 5.3节中提到的那样，一旦当前任期内的某个日志条目以及存储到过半的服务器节点上，leader就知道该日志可以被提交了。如果这个 leader在提交某个日志条目之前崩溃了，以后的 leader会尝试完成该日志条目的复制。然而，如果是之前任期内的某个日志条目已经存储到了过半的服务器节点上了，新任期内的leader 也无法立即断定该日志条目已经被提交了。图 8展示了一种情况：一个已经被存储到过半节点的老日志条目，仍然有可能会被未来的leader 覆盖掉。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gse88t4iicj31wc0u0ts1.jpg"alt="image-20210712160506841" /><figcaption aria-hidden="true">image-20210712160506841</figcaption></figure><blockquote><p>译者注：<strong>对图 8 的理解的补充</strong>。</p><p><font color="orange">参考：</font></p><ul><li><a href="https://zhuanlan.zhihu.com/p/369989974">知乎</a></li></ul><p><font color="orange">核心：</font></p><ul><li><strong>图 8 用来说明为什么 leader不能提交之前任期的日志，只能通过提交自己任期的日志，从而间接提交之前任期的日志。</strong></li></ul><p><font color="orange">分析：</font></p><ol type="1"><li>先按错误的情况，也就是 leader 提交之前任期的日志，那么上述的流程：<ol type="1"><li><ol type="a"><li>S1 是任期 2 的 leader，日志已经复制给了 S2，此时还没过半；</li></ol></li><li><ol start="2" type="a"><li>S1 崩溃，S5 获得了 S3、S4、S5 的投票成为leader，然后写了一个日志条目（index=2，term=3）；</li></ol></li><li><ol start="3" type="a"><li>S5 刚写完日志，还没来得及复制，就崩溃了，此时 S1 和 S2都可能当选，加入 S1 当选（currentTerm=4），此刻还没有新的请求进来，S1将日志条目（index=2，term=2）复制给了 S3，多数派达成，S1提交了这个日志条目（index=2，term=2），<strong>注意，该日志不是当前任期内的日志，我们在讨论错误的情况！</strong>然后请求进来，S1 写日志条目（index=3，term=4），然后 S1 崩溃。</li></ol></li><li>情况一：(d) S5 重启，因为 S5 最后的日志条目的任期号比 S2、S3大，所以 S5 可以赢得选举（currentTerm=5），S5将日志条目（index=2，item=3）复制给其他所有节点并提交， <strong>此时index=2 的日志条目被提交了两次！一次term=2，一次term=3，这是不被允许的，因为已经提交的日志条目是不能被覆盖的！</strong>✖️</li><li>情况二：(e) S1在崩溃之前将自己的日志条目（index=3，term=4）复制到了过半节点上，这种情况下，S5不可能选举成功。这是 S1 不发生故障，这是正确复制的情况。✔️</li></ol></li></ol><p>所以 <strong>「leader 可以提交之前任期的日志」</strong>这种操作是不允许的，我们需要加上约束： <strong>「leader只能提交自己任期的日志」</strong> 。</p><ol start="2" type="1"><li><p>加了约束之后，前面的 (a) 和 (b) 没有改变，从 (c) 开始：</p><ol type="1"><li><ol start="3" type="a"><li>S1 还是将日志条目（index=2，term=2）复制给其他节点，它复制给了S3，此时已经复制给了过半的节点了，但是<strong>由于 currentTerm=4，所以S1 还是不能提交该日志条目</strong>。如果 S1将日志条目（index=3，term=4）也复制给了过半的节点，S1是可以提交该日志条目的，那么这个时候，前面的日志条目（index=2，term=2）也会被间接提交，这就是(e) 所展示的情况。</li></ol></li><li><ol start="4" type="a"><li>S1 还是将日志条目（index=2，term=2）复制给其他节点，它复制给了S3，此时已经复制给了过半的节点了，但是<strong>由于 currentTerm=4，所以S1 还是不能提交该日志条目</strong>。但是这个时候，S1只是日志条目（index=3，term=4）写入自己的日志，还没来得及复制就崩溃了。然后S5重启并赢得了选举（currentTerm=5），然后将日志条目（index=2，term=3）复制给其他所有节点，现在index=2 的日志条目是没有提交过的，S5 能提交该日志吗？</li></ol><strong>不能！因为 leader不能提交之前任期的日志！只有等新的请求进来，超过半数节点复制了 1-3-5之后，term=3 的日志才能跟着 term=5 的日志一起被提交。</strong></li></ol></li></ol><p><font color="orange">延伸：</font></p><p>加了上述约束后，就不会出现同一个 index上的日志条目被重复提交的情况了，但是这又多出了另外一个问题了：<strong>如果一直没有新的请求进来，那么日志条目（index=2，term=3）岂不是就一直不能提交？那不就阻塞了吗？</strong></p><p>这里如果是 kv 数据库，问题就很明显了。假设 (c) 或 (d)中的日志条目（index=2）里的 Command 是 <code>Set("k", "1")</code>，S5当选 leader 后，客户端来查询 <code>Get("k")</code>，leader查到日志有记录但又不能回复 1给客户端（因为按照约束这条日志未提交），线性一致性要求不能返回陈旧的数据，leader迫切地需要知道这条日志到底能不能提交。</p><p>所以 Raft 论文提高了引入 <strong>no-op日志</strong>来解决这个问题，这个在 etcd 中有实现。</p><p><font color="orange">no-op 日志：</font></p><p>no-op 日志即只有 index 和 term 信息，command信息为空。也是要写到磁盘存储的。</p><p>具体流程是<strong>在 leader 刚选举成功的时候，立即追加一条 no-op日志，并立即复制到其它节点，no-op 日志一经提交，leader前面那些未提交的日志全部间接提交，问题就解决了。像上面的 kv 数据库，有了no-op 日志之后，Leader 就能快速响应客户端查询了。</strong></p><p>本质上，no-op 日志使 leader隐式地快速提交之前任期未提交的日志，确认当前<code>commitIndex</code>，这样系统才会快速对外正常工作。</p></blockquote><p>为了解决图 8 中描述的问题，Raft永远不会通过计算副本数目的方式来提交之前任期内的日志条目。只有 leader当期内的日志条目才通过计算副本数目的方式来提交。一旦当前任期内的某个日志条目以这种方式被提交（如图8 中的 e），那么由于日志匹配特性（LogMatching），之前的所有日志条目也会被间接地提交。在某些情况下，leader可以安全地断定一个老的日志条目已经被提交（例如，如果该条目已经被存储到每一个节点上了）。但是Raft 为了简化问题，采取了上述描述的更加保守的方法。</p><p>Raft 会在提交规则上增加额外的复杂性是因为当 leader复制之前任期内的日志条目时，这些日志条目都保留原来的任期号。在其他的共识算法中，如果一个新的leader 要重新复制之前任期里的日志时，它必须使用当前新的任期号。Raft的做法使得更加容易推导出日志条目，因为它们自始至终都使用同一个任期号。另外，和其他的算法相比，Raft中的新 leader只需要发送更少的日志条目（其他算法中必须在它们被提交之前发送更多的冗余日志条目来给它们重新编号）。</p><h4 id="安全性论证">5.4.3 安全性论证</h4><p>给出了完整的 Raft 算法后，我们现在可以更严格地来论证 leader完整性特性（Leader Completeness Property）（这一讨论基于 9.2节的安全性证明）。我们先假设 Leader Completeness Property是不满足的，然后再推出矛盾来。</p><p><strong>假设：</strong></p><p>假设任期 T 的 leader<sub>T</sub>在任期内提交了一个日志条目，但是该日志条目没有存在未来某些任期的 leader中，假设 U 是大于 T 的没有存储该日志条目的最小任期号，处在任期 U 的leader 称为 leader<sub>U</sub>。</p><p><strong>论证：</strong></p><ol type="1"><li><p>因为 leader从来不删除或重写自己的日志条目，所以如果一个已提交的日志要做到不存在未来的leader<sub>U</sub> 中的话，那么它只可能在 leader<sub>U</sub>选举的过程中被丢失。</p></li><li><p>leader<sub>T</sub>将该日志复制给了集群中过半的节点，leader<sub>U</sub>从集群中过半的节点得到了投票。因此，至少有一个节点（这里称它为voter）同时接收了来自 leader<sub>T</sub> 的日志条目并且给leader<sub>U</sub> 投票了。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsfipd3u1tj322c0j2wju.jpg"alt="image-20210713185232381" /><figcaption aria-hidden="true">image-20210713185232381</figcaption></figure></li><li><p>voter 必然在给 leader<sub>U</sub>投票之前就已经接收了这个已经提交的日志条目了。否则，它就会拒绝来自leader<sub>T</sub> 的 AppendEntries RPC 请求，因为如果它在给leader<sub>U</sub> 投票之后再接收条目的话，那么它的当前任期号会比 T大。</p><blockquote><p>译者注：因为要举行 Leader election的话需要开一轮新的任期，这个时候前一轮任期已经结束了。我们这里假设了 T&lt; U，上述所说的已提交日志条目是在任期 T 中的，如果 voter先投票的话，那么就说明它已经进入了任期 U 了，而 U &gt; T，voter是不可能接受 leader<sub>T</sub> 的 AppendEntries 请求的。</p></blockquote></li><li><p>而且，voter 在给 leader<sub>U</sub>投票的时候，它依旧保有该日志条目，因为任何 U、T 之间的 leader都包含该日志条目（因为我们前面假设了 U 是大于 T的没有存储该日志条目的最小任期号），而且 leader 从来不会删除条目，并且follower 只有再跟 leader 冲突的时候才会删除条目。</p></li><li><p>该投票者把自己的选票投给 leader<sub>U</sub>的时候，leader<sub>U</sub> 的日志至少跟 voter一样新（可以更新），这就导致了以下的两个矛盾之一了。</p></li><li><p><strong>第一个矛盾：</strong></p><p><strong>如果 voter 和 leader<sub>U</sub>最后一个日志条目的任期号相同的话，那么 leader<sub>U</sub> 的日志至少和voter 的一样长，所以 leader<sub>U</sub> 的日志一定包含 voter日志中的所有日志条目。 这是一个矛盾，因为 voter包含了该已提交的日志条目，所以 leader<sub>U</sub>必定也包含该日志条目，而前面我们假设了 leader<sub>U</sub>是不包含的，这就产生了矛盾。</strong></p></li><li><p><strong>第二个矛盾：</strong></p><p><strong>如果不是上面描述的情况的话，那么 leader<sub>U</sub>最后一个日志条目的任期号必然需要比 voter 的更大。此外，它还比 T要大，因为 voter 拥有在任期号为 T 提交的日志条目，所以 voter最后一个日志条目的任期号至少为 T。创建了 leader<sub>U</sub>的最后一个日志条目的之前的 leader一定已经包含了该已被提交的日志条目（因为我们上面假设了leader<sub>U</sub> 是第一个没有该日志条目的leader）。所以，根据日志匹配特性，leader<sub>U</sub>一定也包含了该已被提交的日志条目，这样也产生了矛盾</strong>。</p></li><li><p>上述讨论就证明了假设是不成立的。因此，所有比 T 大的任期的 leader一定包含了任期 T 中提交的所有日志条目。</p></li><li><p>日志匹配特性保证了未来的 leader也会包含被间接提交的日志条目，如图 8 (d) 中的索引 2。</p></li></ol><p>通过 leader 的完整性特性，我们就可以证明图 3中的状态机安全特性了，即如果某个节点已经将某个给定的索引处的日志条目应用到自己的状态机里了，那么其他的节点就不会在相同的索引处应用一个不同的日志条目。在一个节点应用一个日志条目到自己的状态机中时，它的日志和leader的日志从开始到该日志条目都是相同的，并且该日志条目必须被提交。现在考虑一个最小的任期号，在该任期中任意节点应用了一个给定的最小索引上面的日志条目，那么Log 的完整性特性就会保证该任期之后的所有 leader将存储相同的日志条目，因此在后面的任期中应用该索引上的日志条目的节点会应用相同的值。所以，状态机安全特性是可以得到保证的。</p><p>最后，因为 Raft要求服务器节点按照日志索引顺序应用日志条目，再加上状态机安全特性，这样就意味着我们可以保证所有的服务器都会按照相同的顺序应用相同的日志条目到自己的状态机中了。</p><h3 id="follower-和-candidate-崩溃">5.5 follower 和 candidate 崩溃</h3><p>到目前为止，我们只关注了 leader 崩溃的情况。follower 和 candidate崩溃后的处理方式要比 leader崩溃简单得多，而且它们的处理方式是相同的。如果一个 follower 或者candidate 崩溃的话，后面发送给它们的 RequestVote 和 AppendEntries RPCs都会失败。Raft通过无限重试来处理这种失败。如果崩溃的节点重启了，那么这些 RPC就会被成功地完成。如果一个节点在完成了一个RPC，但是还没来得及响应就崩溃了的话，那么在它重启之后它会再次收到同样的请求。Raft的 RPCs 都是幂等的，所以重复发送相同的 RPCs不会对系统造成危害。实际情况下，一个 follower 如果接收了一个AppendEntries请求，但是这个请求里面的这些日志条目在它日志中已经有了，它就会直接忽略这个新的请求中的这些日志条目。</p><blockquote><p>译者注：<strong>幂等</strong></p><p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现。</p></blockquote><h3 id="时序和可用性">5.6 时序和可用性</h3><p>Raft 中有一个要求就是 Raft的安全性不能依赖于时序（timing）：整个系统不能因为某些事件运行得比预期快一点或者慢一点就产生错误的结果。然而，可用性（即系统能够及时响应客户端的请求）不可避免的要依赖于时序。比如说，如果信息交换的时间比一般服务器崩溃所持续的时间还要长的话，那么candidate 可能等不到赢得选举了，而缺少了一个稳定的 leader，Raft将无法工作。</p><p>Raft 中时序最关键的地方就是 Leaderelection。只要整个系统满足下面的时间要求，Raft就可以选举并维持一个稳定的 leader：</p><blockquote><p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout）&lt;&lt; 平均故障间隔时间（MTBF）</p></blockquote><p>在这个不等式中，广播时间指的是一个节点并行地发送 RPCs给集群中其他所有的节点并得到响应的平均时间。选举超时时间就是在 5.2节中介绍的选举超时时间。平均故障间隔时间就是对于一台服务器而言，两次故障间隔时间的平均值。广播时间必须选举超时时间小一个量级，这样leader 才能够有效发送心跳信息来组织 follower进入选举状态。再加上随机化选举超时时间的方法，这个不等式也使得无果选票（splitvote）变得几乎不可能。而选举超时时间需要比平均故障间隔时间小上几个数量级，这样整个系统才可以稳定地运行。有了这个限制后，当leader崩溃后，整个系统会有一段大约选举超时时间的时长不可用，我们希望该情况在整个系统运行时间里只占一小部分。</p><p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们可以自定义的。Raft的 RPCs 需要接收方将信息持久化地保存到稳定存储中，所以广播时间大约是0.5ms ~ 20ms 之间，取决于存储的技术。因此，选举超时时间可能需要在 10ms ~500ms之间。而大多数的服务器的平均故障间隔时间都在几个月甚至更长，所以很容易满足时间的要求。</p><h2 id="集群成员变更">6. 集群成员变更</h2><p>到目前为止，我们都假设集群的配置（参与共识算法的服务器节点集合）是固定不变的。但是在实际情况中，我们有时候是需要去改变集群配置的，比如说在服务器崩溃的时候去更换服务器或者是更改副本的数量。尽管可以通过下线整个集群，更新所有配置，然后重启整个集群的方式来实现这个需求，但是这会导致集群在更改过程中是不可用的。另外，如果这个过程中存在一些操作需要人工干预，那么就会有操作失误的风险。为了避免这些问题，我们决定将配置变更自动化并将其纳入到Raft 的共识算法中来。</p><p>为了使配置变更机制足够安全，在配置变更过程中不能存在任何一个时刻使得同一任期中选出两个leader。遗憾的是，任何服务器直接从旧的配置转换为新的配置的方案都是不安全的。一次性自动地转换所有服务器的配置的不可能的，所以在转换期间整个集群可能划分为两个独立的大多数（如图10 所示）。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsgq3skl4gj322c0nwaes.jpg"alt="image-20210714195412552" /><figcaption aria-hidden="true">image-20210714195412552</figcaption></figure><blockquote><p>译者注：图 10 补充</p><p>上图中，在中间位置 Server1 可以通过自身和 Server2 的选票成为leader（满足旧配置下收到大多数选票的原则）；Server3 可以通过自身和Server4、Server5 的选票成为 leader（满足新配置线，即集群有 5个节点的情况下的收到大多数选票的原则）；此时整个集群可能在同一任期中出现了两个leader，这和 Raft 协议是违背的。</p></blockquote><p>为了保证安全性，配置变更必须采取一种两段式方法。目前有很多种两段式的实现。例如，有些系统（如[22]）在第一阶段停掉旧的配置，所以在这个阶段不能处理用户的请求，然后在第二阶段启用新的配置。在Raft 中，集群先切换到一个过渡的配置，我们称之为 <strong>联合共识（jointconsensus）</strong>。一旦联合共识配置已经被提交了，系统就可以切换到新的配置上了。<strong>联合共识配置是新旧配置的并集</strong>：</p><ul><li>日志条目被复制给集群中处于新、老配置的所有节点</li><li>新、旧配置的节点都可能成为 leader</li><li>达成一致（针对选举和提交）需要分别得到在两种配置上过半的支持</li></ul><p>联合共识允许每一个节点在不妥协安全性的前提下，在不同的时刻进行配置转换过程。此外，联合共识还允许在集群配置变更期间响应客户端的请求。</p><p>集群配置在复制日志中以特殊的日志条目来存储和通信。图 11展示了配置变更的过程。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsgpnv9f98j32060p6agz.jpg"alt="image-20210714193852320" /><figcaption aria-hidden="true">image-20210714193852320</figcaption></figure><p>当 leader接收到一个更新配置的请求的时候，它就创建一个联合共识日志条目C<sub>old,new</sub>，并以前面描述的方式复制该条目。<strong>一旦某个节点将该配置日志条目增加到自己的日志中。那么这个节点就会用该配置来做出未来的所有决策（一个节点总是使用日志中最新的配置，无论该日志是否已经被提交）。</strong>这就意味着 leader 会使用 C<sub>old,new</sub> 的规则来判断C<sub>old,new</sub> 日志条目是什么时候被提交的。如果 leader 崩溃了，新的leader 有可能处于 C<sub>old</sub> 配置，也可能处于 C<sub>old,new</sub>配置，这取决于赢得选举的 candidate 是否已经接收到了 C<sub>old,new</sub>配置。在任何情况下，处于 C<sub>new</sub>状态的节点在此期间都是不能单独做出决定的。</p><p>当 C<sub>old,new</sub> 被提交了，那么 C<sub>old</sub> 和C<sub>new</sub> 都不能在没有得到对方认可的情况下做出决定，并且 Leade完整特性（Leader Completeness Property）保证了只有拥有C<sub>old,new</sub> 日志的 candidate 有可能被选为 leader。所以现在leader 就可以安全地创建一个描述 C<sub>new</sub>的日志条目并将其复制给集群中的其他节点了。一样的，新的配置被节点收到后就会立刻生效。当新的配置在C<sub>new</sub>的规则下被提交了之后，旧配置就变得无关紧要了，处于旧配置的节点也可以关闭了。如图11 所示，没有任何一个时刻 C<sub>old</sub> 和 C<sub>new</sub>是可以单独做决定的，这保证了安全性。</p><p>关于配置变更有三个问题需要解决：</p><ul><li><p>第一个问题：新的节点可能在一开始并没有存储任何的日志条目。当这些节点以这种状态加入到集群中的时候，它们需要一段时间来更新自己的日志，以便赶上其他节点，在这个时间段里面它们是不可能提交一个新的日志条目的。<strong>为了避免因此造成的系统短时间的不可用，Raft在配置变更前引入了一个额外的阶段。在该阶段中，新的节点以没有投票权身份加入到集群中来（leader会把日志复制给它们，但是考虑过半的时候不需要考虑它们）。</strong>一旦新节点的日志已经赶上了集群中的其他节点，那么配置变更就可以按照之前描述的方式进行了。</p></li><li><p>第二个问题：leader 有可能不是新配置中的一员（译者注：也就是说这个leader 后面是需要被下线的）。在这种情况下，leader 一旦提交了C<sub>new</sub> 日志条目，它就会退位为follower（译者注：C<sub>old,new</sub>状态下依旧可用）。这就意味着有这样一段时间（leader 提交 C<sub>new</sub>期间）：leader管理着一个不包括自己的集群，它会复制日志给其他节点，但是算副本数量的时候不会算上自己。leader转换发生在 C<sub>new</sub>被提交的时候，因为这是新配置可以独立运行的最早时刻（在这个时刻之后，一定是从C<sub>new</sub> 中选出新的 leader）。在这个时间点之前，有可能只能从C<sub>old</sub> 中选出 leader。</p></li><li><p>第三个问题：那么被移除的节点（不处于 C<sub>new</sub>状态的节点）有可能会扰乱集群。这些节点将不会收到心跳信息，所以当选举超时时，它们就会进行新的选举过程。它们会发送带有新任期号的RequestVote RPCs，这样会导致当前的 leader 回到 follower状态，然后选出一个新的leader。但是这些被移除的节点还是会收不到心跳，然后再次超时，再次循环这个过程，导致系统的可用性很差。</p><p>为了避免这个问题，当节点认为当前有 leader 存在时，节点会忽略RequestVote RPCs。具体来说，当一个节点在最小选举超时时间内收到一个RequestVoteRPC，它不会更新它的任期或授予它的投票。这不会影响正常的选举，每个节点在开启一轮选举之前，它会至少等待一次最小选举超时时间。相反，这有利于避免被移除的节点的扰乱：如果一个leader 能够发送心跳给集群，那它就不会被更大的任期号废黜。</p></li></ul><blockquote><p>译者注：<strong>对配置变更的归纳</strong></p><ol type="1"><li><p>配置变更过程</p><ol type="1"><li><p>leader 在本地生成一个新的日志条目，其内容是 C<sub>old</sub> ∪C<sub>new</sub>，代表当前时刻新旧成员配置共存，写入本地日志，称为C<sub>old,new</sub>。后面 leader就以该日志作为自己的配置了。同时将该日志条目复制集群中是所有节点中。在此之后新的日志同步需要保证得到C<sub>old</sub> 和 C<sub>new</sub> 两个多数派的确认。</p><p>follower 收到 C<sub>old.new</sub>的日志后更新本地日志，并且此时就以该配置作为自己的成员配置。</p><p>如果 C<sub>old</sub> 和 C<sub>new</sub> 中的两个多数派确认了C<sub>old.new</sub> 这个日志条目，leader 就提交它。</p></li><li><p>接下来 leader 生成一条新的日志条目，其内容是新成员配置C<sub>new</sub>，同样将该日志条目写入本地日志，同时复制给集群中其他节点。</p><p>follower 收到新成员配置 C<sub>new</sub>后，将其写入日志，并且从此刻起，就以该配置作为自己的成员配置，并且如果发现自己不在C<sub>new</sub> 这个成员配置中会自动退出。</p><p>leader 收到 C<sub>new</sub>的多数派确认后，表示成员变更成功，后续的日志只要得到 C<sub>new</sub>多数派确认即可。</p></li></ol><p>完成上述两阶段后，leader就可以给客户端回复配置变更执行成功。</p></li><li><p>如果当前的 leader 不在 C<sub>new</sub> 的配置中会怎么样？</p><p>因为当前 leader 不在 C<sub>new</sub> 配置中，所以当 C<sub>new</sub>日志条目被提交的时候，leader 其实是要被下线的（比如说集群节点数从 5缩容为 3，且刚好下线的节点中包含当前 leader）。那这样的话，在C<sub>old,new</sub> 状态下，leader 还是可用的，但是一旦 C<sub>new</sub>日志条目被提交了，leader 就需要下线了，这个时候不用当心，因为C<sub>new</sub> 已经被复制过半了，重新选 leader 也一定是选有C<sub>new</sub> 的。</p></li><li><p>如果在配置分发过程中 leader 崩溃了怎么办？</p><p>分两种情况：</p><ol type="1"><li><p>C<sub>new</sub> 已经分发过半</p><p>集群开始重新选举，此时在 C<sub>new</sub>的规则下，不存在新配置中的节点不会赢得选举（因为他们要在C<sub>old,new</sub>的情况下决定，但是拿不到 C<sub>new</sub> 的选票），只有拿到C<sub>new</sub> 的节点可能成为 leader 并继续下发 C<sub>new</sub>配置，流程恢复。</p></li><li><p>C<sub>new</sub> 没有分发过半</p><p>这种情况下，C<sub>old,new</sub> 和 C<sub>new</sub> 的节点都可以成为leader，但是无所谓，因为无论谁成为leader，都能根据当前的配置继续完成后续流程（如果是 C<sub>new</sub>那么相当与完成了最终的配置，不在 C<sub>new</sub>的节点会因为没有心跳数据而失效）。</p></li></ol></li><li><p>旧配置节点下线造成的问题</p><p>Raft 的处理方式：当节点确信有 leader 存在时，不会进行投票（在 leader超时之前收到新的投票请求时不会提升任期号和做出投票）。且开始选举之前等待一个选举超时时间，这样在新leader 正常工作的情况下，不会受到旧节点的影响。</p><p>旧配置节点在发起选举前需要等待一段时间，那么这段时间新 leader可以发送心跳，这样就减少了影响。 对正常流程的影响不大。（leader失效后要等一段时间，没有及时触发，然而本身这里就有一个判断失效的时间，好像影响不大；比如原先超时时间是10s，那么如果设置成 5s，原策略下 10s 超时就是 10s 后开始选举，新策略下5s 超时就是超时后再等 5s 再开始选举，影响就是超时时间变短）</p></li><li><p>无数据的新节点加入集群中的问题</p><p>新加入的节点需要时间复制数据，在这个过程完成之前，Raft采用以下机制来保证可用性： 新加入节点没有投票权（ leader复制日志给他们，但计算已复制日志条目的副本数的时候不考虑它们），直到这些节点的日志追上其他节点。</p></li><li><p>如果在配置变更过程中接收到用户请求的话，是用旧配置响应还是用新配置响应？</p><p><strong>按照笔者的理解，这个方面，对 Raft协议的具体实现可以根据自身需求来自定义实现，Raft的联合共识是为了避免同一时刻出现了 2 个leader，避免了对客户端的一个请求同时有两个不同的响应出现。而在具体实现中，在某个阶段，究竟是采取新配置响应还是旧配置响应，可以再斟酌。</strong></p><p>比如说可以这样：</p><ol type="1"><li>C<sub>old</sub> 阶段：使用旧配置，需要过半旧配置节点确认</li><li>C<sub>new</sub> 已提交阶段：使用新配置，需要过半新配置节点确认</li><li>C<sub>old,new</sub>阶段：配置信息中有节点数量（这样才可能判断是否过半），这个时候新旧配置都需要过半节点确认，而响应新配置执行的结果还是响应旧配置执行的结果，就看old 多还是 new 多，谁多用谁。</li></ol></li><li><p>如果 leader 要下线，客户端发来的新的请求如何处理？</p><ol type="1"><li>如果是在 leader 复制 C<sub>new</sub> 之后，提交 C<sub>new</sub>之前的话，leader工作在新的集群配置下，所以会将日志复制到新集群的节点下，当收到新集群（不包含leader 本身）超过半数节点确认后，就可以提交日志。</li><li>在其他阶段，leader 就是正常可用的。</li></ol></li><li><p>所谓 C<sub>new</sub> 和 C<sub>old,new</sub>日志条目，里面没有数据，只有指令，里面的指令就是让节点执行对应的配置项。</p></li></ol></blockquote><h2 id="日志压缩">7. 日志压缩</h2><p>在正常情况下，Raft的日志会随着客户端请求的增加而不断增长。但在实际系统中，日志不可能无限制地增长。随着日志越来越长，它会占用越来越多的空间，并且需要花更多的时间来重新执行日志中的日志条目。如果没有一定的机制来清除日志中积累的过期的信息，那么最终一定会影响系统的可用性。</p><p><strong>快照技术（snapshotting）</strong>是日志压缩最简单的方法。在快照技术中，某个时间点下的前整个系统的状态都会以快照的形式持久化起来，然后该时间点之前的日志会被全部丢弃。快照技术呗使用在Chubby 和 ZooKeeper 当中，接下来的章节会介绍 Raft 中的快照技术。</p><p><strong>增量压缩方法（Incremental approach tocompaction）</strong>，例如<strong>日志清洗（log cleaning）</strong>[36]和<strong>日志结构合并树（log-structured merge trees）</strong>[30,5]，都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，选择一个积累了大量被删除或被覆盖的对象的数据区域，然后重写该区域内还活着的对象，之后释放该区域。和快照技术相比，这需要大量额外的机制，并且增加了更多的复杂性，快照技术通过操作整个数据集来简化问题。虽然日志清理需要对Raft 进行修改，但是状态机可以使用与快照技术相同的接口来实现LSM（日志结构合并） 树。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gshvublij8j321s0lsadj.jpg"alt="image-20210715195808192" /><figcaption aria-hidden="true">image-20210715195808192</figcaption></figure><p>图 12 展示了 Raft快照技术的基本思想。每一个节点独立地生成快照，快照中只包含自己日志中已经被提交的条目，这个过程主要的工作是状态机将自己的状态写入快照中。Raft在快照中还保留了少量的元数据：</p><ul><li>last includedindex：指的是最后一个被快照取代的日志条目的索引值（状态机最后应用的日志条目）</li><li>last included term：指的是该条目所处的任期号</li></ul><p>保留这些元数据是为了支持快照后第一个条目的 AppendEntries一致性检查，因为该条目需要一个之前的日志索引和任期号。为了支持集群成员变更（第6 节中讨论的），快照中还包含日志中到 last included index为止的最新的配置。一旦节点完成了快照的写入，它可能就会删除 last includedindex 及之前的所有日志条目，以及之前的快照。</p><p>尽管通常情况下，节点都是独立生成快照的，但是 leader不可避免偶尔需要发送快照给一些落后的 follower。这通常发生在 leader已经丢弃了需要发给 follower的下一条日志条目的时候。幸运的是，这种情况在正常操作中是不会出现的：一个与leader 保持同步的 follower 通常都会拥有该日志条目。不过如果一个 follower运行比较缓慢，或者是它刚加入集群，那么它就可能会没有该日志条目。这个时候leader 会通过网络将该快照发送给该 follower，以使得该 follower可以更新到最新的状态。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gshxf2bjwej31gg0u0k01.jpg"alt="image-20210715205247442" /><figcaption aria-hidden="true">image-20210715205247442</figcaption></figure><p>这个时候 leader 使用了一种新的 RPC 来发送快照给那些太落后的followers，如图 13 所示，这种 RPC 叫做<strong>InstallSnapshot</strong>。当一个 follower 通过这种 RPC收到快照的时候，它必须决定如何处理当前已经存在的日志条目。通常情况下，这份快照会包含接受者日志者没有的信息。所以这种情况下follower会丢弃它的整个日志，它的日志会全部被快照取代，并且可能有与快照冲突的未提交的条目。相反，如果一个follower收到一个描述其日志前缀的快照（可能是由于重传或错误），则被快照覆盖的日志条目将被删除，但是快照之后的条目仍然有效，且必须要保留。</p><p>这种快照的方式违反了 Raft 的 strong leader 原则，因为 follower可能在不知道 leader的情况下创建快照。但是我们认为这种违背是合乎情理的。leader的存在，是为了防止在达成共识的时候产生冲突，但是在创建快照的时候，共识已经达成了，因此没有决策会出现冲突。这种情况下，数据还是跟之前一样，只能从leader 流向 follower，只不过现在允许 follower可以重新组织它们的数组而已。</p><p>我们曾经考虑过一种可替代的方案，那就是只有 leader可以创建快照，然后由 leader 将这份快照发送给其他所有的follower。但是，这种方案有两个缺点：</p><ol type="1"><li>发送快照给每个 follower会浪费网络带宽和延缓了快照处理过程。实际上每一个 follower已经拥有了创建自己快照所需要的全部信息了，所以很显然，follower根据本地的状态创建快照要比通过网络来接收别人发过来的要更加实惠。</li><li>这会造成 leader 的实现更加复杂。比如说，leader 发送快照给 follower的同时要能够做到并行地将新的日志条目发送给它们，这样才不会阻塞新的客户端请求，这就复杂得多了。</li></ol><p>还有两个问题会影响快照的性能：</p><ol type="1"><li><p>每一个节点必须判断何时去生成快照。如果一个节点生成快照的频率太高，那么就会浪费大量的磁盘带宽和其他资源；如果一个节点生成快照的频率太低，那么就要承担耗尽存储容量的风险，同时也增加了重启时重新执行日志的时间。</p><p>一个简单的策略就是当日志大小达到一个固定的阈值的时候就生成一份快照。如果这个阈值设置得显著大于期望的快照的大小，那么快照的磁盘带宽开销将较小。</p></li><li><p>第二个影响性能的就是写快照需要花费一定的时间，而我们又不希望它会影响到正常的操作。</p><p>解决方案就是使用 <strong>写时复制的技术（copy-on-write）</strong>，这样新的更新就可以在不影响正在写的快照的情况下被接收。例如，具有泛型函数结构的状态机天然支持这样的功能。另外，操作系统对写时复制技术的支持（如Linux 上的fork）可以被用来创建整个状态机的内存快照（我们的实现用的就是这种方法）。</p></li></ol><h2 id="客户端交互">8. 客户端交互</h2><p>本节介绍客户端如何和 Raft 进行交互，包括客户端如何找到 leader 和 Raft是如何支持线性化语义的[10]。这些问题对于所有的基于共识算法的系统都是存在的，Raft的解决方案也跟其他的系统差不多。</p><p>Raft 的客户端们将所有的请求发送给leader。当客户端第一次启动的时候，它会随机挑选一个节点来进行通信。如果客户端首选的不是leader，那么被客户端选中的节点就会拒绝客户端的请求并且提供关于它最近收到的leader 的信息（AppendEntries RPC 包含了 leader 的网络地址）。如果 leader崩溃了，客户端请求就会超时，这个时候客户端需要随机选择一个节点来重试发送请求。</p><p>我们对 Raft的期许是希望它可以实现线性化语义（即每次操作看起来似乎都是在调用和响应之间的某个点上即时执行一次）。但是，按照上面描述的，Raft可能会对同一条指令执行多次。例如，如果 leader在提交了某个日志条目后，在还没来得及响应客户端的时候就崩溃了，那么客户端会和新的leader重试该指令，这就造成了同一指令被执行了两次。解决方案是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每个客户端已经处理的最新的序列号以及相关联的响应。如果状态机接收到了一条已经执行过的指令了，就立即作出响应，并且不会重复执行该指令。</p><p>只读操作（Read-Only）可以直接处理而不记录日志。但是，如果不采取任何措施的话，这可能会有返回过期数据（staledata）的风险。<strong>因为 leader 响应客户端请求的时候它可能已经被新的leader 代替了，但是它还不知道自己已经不是最新的 leader 了。</strong></p><blockquote><p>译者补充：<strong>为什么一个 leader 好好的会有另外一个 leader出现？</strong></p><p>参考：https://segmentfault.com/a/1190000039264427</p><p>实际上，老的 leader 可能不会马上消失，例如：网络分区将 leader与集群的其余部分分隔，其余部分选举出了一个新的 leader。然后老的 leader崩溃后重新连接，可能会不知道新的 leader 已经被选出来了。</p></blockquote><p>线性化的操作肯定不会返回过期的数据。Raft需要使用两个额外的预防措施来在不适用日志的时候保证这一点。</p><ol type="1"><li><p>leader 必须拥有那些已提交的日志条目的最新信息。Leader完整性特性（Leader Completeness Property）保证了 leader一定拥有所有已被提交的日志条目，但是在它任期刚开始的时候，它可能还不知道哪些是已经被提交的。为了知道这些信息，它需要在它的任期里提交一个日志条目。</p><p><strong>Raft 通过让 leader在任期开始的时候提交一个空的日志条目到日志中来解决该问题</strong>。（译者注：这就是前面5.4.2 节提到的 no-op 日志）</p></li><li><p>leader在处理只读请求的时候必须检查自己是否已经被替代了（因为如果一个新 leader被选出来了，那么这个旧 leader 的数据可能就过时了）。</p><p>Raft 通过让 leader在响应只读请求之前，先和集群中过半的节点交换一次心跳信息来解决该问题。</p><p>另一种可选的方案，leader 可以依赖心跳机制来实现一种租约的形式[9]，但是这种方式的安全性需要依赖于时序（假设时间误差是有界的）。</p></li></ol><h2 id="算法实现与评估">9. 算法实现与评估</h2><p>我们已经实现了 Raft 作为复制状态机的一部分，该状态机存储了 RAMCloud[33] 的配置信息，并帮助 RAMCloud 协调器进行故障转移。这个 Raft实现大概包含了 2000+ 行 C++代码，但是这里面没有包含测试、注释和空行。这些代码是开源的[23]。同时也有大约 25个其他独立的第三方、针对不同的开发场景、基于这篇论文草稿的开源实现。同时，很多公司已经部署了基于Raft 算法的系统了。</p><p>本节剩下的篇幅将从三个方面来评估 Raft 算法：</p><ul><li>可理解性</li><li>正确性</li><li>性能</li></ul><h3 id="可理解性">9.1 可理解性</h3><p>为了衡量 Raft 相对于 Paxos的可理解性，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一项实验研究。我们为Raft 和 Paxos 分别录制了一个视频教程，并且准备了相应的小测验。其中 Raft课程覆盖了本篇论文除了日志压缩之外的全部内容，而 Paxos课程涵盖了创建一个与 Raft 等价的复制状态机的全部资料，包括 signle-decreePaxos、multi-decree Paxos、重新配置和一切实际系统需要的性能优化（比如leader选举）。这个小测验主要是测试一些对算法的理解和解释一些边缘情况。每个学生都是看完第一个视频，然后做对应的测验，然后再看第二个视频，再做第二份测验。为了解释个人表现与从第一部分研究中获得的经验差异的原因，大约有一半的学生先进行Paxos 的部分，然后另一半学生先进行 Raft的部分。我们通过计算参与人员的每一份测验的得分来看参与者是否更加容易理解Raft 算法。</p><p>我们尽可能的使得在比较 Raft 和 Paxos过程中是公平的。这个实验从两个方面偏向了 Paxos：</p><ol type="1"><li>43 个参与者中有 15 个人在之前有一些 Paxos 的经验</li><li>Paxos 视频教程的时长要长 14%</li></ol><p>如表格 1总结的那样，我们采取了一些措施来减轻这种潜在的偏向。我们所有的材料都可供审查[28, 31]。</p><table style="width:100%;"><colgroup><col style="width: 15%" /><col style="width: 68%" /><col style="width: 15%" /></colgroup><thead><tr class="header"><th>关注点</th><th>缓和偏向采取的手段</th><th>可供查看的材料</th></tr></thead><tbody><tr class="odd"><td>相同的讲课质量</td><td>两份教程采用同一个讲师。Paxos的教程是在现有的一些大学使用的材料基础上改进的。Paxos 的教程要长14%。</td><td>视频</td></tr><tr class="even"><td>相同的测验难度</td><td>问题以难度分组，在两个测验里成对出现。</td><td>小测验</td></tr><tr class="odd"><td>公平评分</td><td>使用评价量规。随机顺序打分，两个测验交替进行。</td><td>评分细则</td></tr></tbody></table><center>表格1：考虑到潜在的实验偏向，我们对于每种情况的解决方法，以及相应的材料。</center><p>平均上看，参与者在 Raft 测验上的得分要比在 Paxos 测验上的得分高处 4.9分（在 60 分中，Raft 的平均得分是 25.7 分，Paxos 的平均得分是 20.8分）。图 14 展示了每个参与者的得分。配对 t 检验（paired t-test）表明，在95% 的置信度下，Raft 分数的真实分布的平均值至少要比 Paxos 的大 2.5分。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsixtffkroj32220my76y.jpg"alt="image-20210716175208106" /><figcaption aria-hidden="true">image-20210716175208106</figcaption></figure><p>我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，这个模型基于以下三点：</p><ol type="1"><li>他们使用的是哪个测验</li><li>之前对于 Paxos 的经验</li><li>学习算法的顺序</li></ol><p>该模型预测，对小测验的选择会产生 12.5 分的有利于 Raft的差别，这很明显高于观察到的 4.9分的分差。这是因为实际上许多的学生之前有学习过 Paxos，这对 Paxos的有很大帮助的，但是对 Raft的帮助就较小了。但是奇怪的是，模型预测对于先进行 Paxos小测验的人而言，Raft 的得分低了 6.3分。虽然我们不知道这是为什么，但是这似乎在统计上是有意义的。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsiz66oe4yj323m0jgdj0.jpg"alt="image-20210716183850084" /><figcaption aria-hidden="true">image-20210716183850084</figcaption></figure><p>我们同时也在测验之后对参与者进行了调查，调查的内容是他们认为哪个算法更容易去实现或解释。这些调查结果展示在图15。调查结果是碾压性的，结果表明 Raft 算法更加容易实现和解释（41 人中的33个）。然而，这种自我报告的感觉可能没有参与者的测试分数来得可靠，而且参与者可能由于我们假设Raft 更容易理解而存在偏向。</p><p>在参考文献 [33] 中有一个关于 Raft 用户学习的更加详细的讨论。</p><h3 id="正确性">9.2 正确性</h3><p>在第 5节中，我们已经对共识机制制定了正式的规范并且对其安全性做了证明。这份正式的规范使用TLA+ 规范语言 [17] 使图 2 中对算法的总结的信息非常清晰。它差不多有 400行并且作为了我们要证明的核心。同时这份规范对于任何想实现 Raft的人都是十分有用的。我们用 TLA 证明系统 [7] 机械地证明了日志完整性（LogCompletenessProperty）。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明规范中的类型安全）。而且，我们已经编写了状态机安全特性的非正式证明[31]，它是完整的（它仅依赖于规范）和相对精确的（大约 3500 字长）。</p><h3 id="性能">9.3 性能</h3><p>Raft 的性能跟其他像 Paxos的共识算法很接近。在性能方面，最重要的关注点就是，当一个 leader被选举出来后，它要在什么时候复制新的日志条目。Raft通过很少量的消息包（一轮从 leader到集群中过半节点的的消息传递）就解决了这个问题。同时，进一步提升 Raft的性能也是有可能的。比如说，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他共识算法已经提出过很多性能优化方案，其中很多都可以应用到Raft 上，但是我们暂时把这些工作放到未来的工作中。</p><p>我们使用我们自己的 Raft 实现来衡量 Raft 的 leader election算法的性能并且回答两个问题：</p><ol type="1"><li>leader 选举过程收敛是否足够快？</li><li>在 leader 崩溃之后，最小的系统崩溃时间是多久？</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsj0yuh34ej61km0u043r02.jpg"alt="image-20210716194110554" /><figcaption aria-hidden="true">image-20210716194110554</figcaption></figure><p>为了衡量 leader election 的性能，我们反复使一个拥有 5 个节点的集群的leader 宕机，并计算它检测崩溃和重新选一个新的 leader 所需的时间（见图16）。为了构建一个最坏的情景，我们使各个节点中的日志长度都是不同的，这样某些candidate 是无法成为 leader 的。而已，为了尽可能出现无结果的投票（splitvote）情况，我们的测试脚本在终止 leader 的进程之前从 leader那触发了一个同步的发送了一次心跳广播（类似于 leader在崩溃前复制一个日志条目给其他节点）。leader在其心跳间隔内均匀随机地崩溃，这个心跳间隔也是所有测试中最小选举超时时长的一半。因此，<strong>最小宕机时间大约就是最小选举超时时间的一半</strong>。</p><p>图 16中上面的图表明，只需要在选举超时时间上使用很小的随机化就可以大大避免出现没有结果的投票的情况。在没有随机化的情况下（译者注：见图16中上面的图右边的橙色虚线），由于出现了很多没有结果的投票的情况，leaderelection 往往都需要花费超过 10s 的时间。仅仅加入 5ms的随机化时间，就大大改善了选举过程，现在平均的宕机时间只有287ms。继续增大随机性可以大大改善最坏的情况：通过增加 50ms的随机化时间，最坏的完成情况（即完成 1000 次实验）只需要 513 ms。</p><p>图 16中下面的图表明，通过减少选举超时时间可以禁烧系统的宕机时间。在选举超时时间为12~24ms 的情况下，只需要平均 35ms 就可以选举出新的leader（最长的一次花费了152ms）。然而，进一步降低选举超时时间可能就会违反 Raft不等式的要求。</p><blockquote><p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout）&lt;&lt; 平均故障间隔时间（MTBF）</p></blockquote><p>因为这会使得在其他节点开启一轮新的选举之前，当前的 leader要完成发送一次心跳广播变得很难。这会造成不必要的 leader更换，从而降低了系统的可用性。我们推荐使用一个更为保守的选举超时时间，比如150~300ms。这样的时间不大可能导致不必要的 leader更换，同时还能提供不错的可用性。</p><h2 id="相关工作">10. 相关工作</h2><p>现在已经有很多关于共识算法相关的产物了，其中很多都属于以下类别之一：</p><ul><li>Lamport 对于 Paxos 的最初的描述 [15]，以及尝试将 Paxos解释地更清晰的描述 [16, 20, 21 ]。</li><li>关于 Paxos的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础[26, 39, 13]。</li><li>实现共识算法的系统，例如 Chubby [2, 4]，ZooKeeper [11, 12] 和Spanner [6]。对于 Chubby 和 Spanner的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper的算法细节已经发表，但是和 Paxos 着实有着很大的差别。</li><li>对于 Paxos 的性能优化 [18, 19, 3, 25, 1, 27]。</li><li>Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos差不多的替代算法。原始的算法描述 [29]和分布式传输协议耦合在了一起，但是核心的共识算法在最近更新的版本 [22]里被分离了出来。VR 使用了一种基于 leader 的方法，和 Raft有很多相似之处。</li></ul><p>Raft 和 Paxos 最大的不同就在于 Raft 的<strong>强领导性（strongleadership）</strong>。Raft 将 leader election作为共识协议中非常重要的一环，并且将尽可能多的功能集中到了 leader身上。这种方法使得算法更加简单和更容易理解。比如说，在 Paxos 中，leaderelection和基本的共识协议是正交的：它只是作为一种性能优化，而不是实现共识所必需的。然而，这带来了很多额外的机制：</p><ul><li>Paxos 中包含了一个两段式的基本共识协议</li><li>Paxos 中还包含了一个单独的 leader election 机制</li></ul><p>相比之下，Raft 将 leader election直接纳入了共识算法并且将其作为共识两阶段中的第一个阶段，这使得 Raft使用的机制要比 Paxos 少得多。</p><p>像 Raft 一样，VR 和 ZooKeeper 也是基于 leader 的，因此他们也拥有一些Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制。因为 Raft尽可能的减少了非 leader 者的功能。例如，Raft 中日志条目都遵循着从 leader发送给 follower 这一个方向：AppendEntries RPCs 是向外发送的。在 VR中，日志条目的流动是双向的（leader人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像Raft。</p><p>跟我们上述提到的其他基于共识性的日志复制算法相比，Raft的消息类型更少。例如，我们计算了一下 VR 和 ZooKeeper用来实现基本功能和集群成员变更（不包括日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）所需要的消息类型。VR和 ZooKeeper 都分别定义了 10 种不同的消息类型。相比之下，Raft 只有 4种消息类型（两种 RPC Request 及其对应的两种 RPC Response）。Raft的消息的消息量比其他算法的要大一点，但总的来说，它们更加简单。另外，VR和 ZooKeeper 都在 leader改变的时候传输了整个日志，所以这些算法为了能在实践中使用，就不得不增加额外的消息类型了。</p><p>Raft 的强 leader模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义Paxos （EPaxos）在某些没有 leader 的情况下可以达到很高的性能[27]。平等主义 Paxos充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos在服务器之间的负载均衡做的很好，并且很容易在 WAN网络环境下获得很低的延迟。但是，他在 Paxos上增加了非常明显的复杂性。</p><p>一些集群成员变更的方法已经被提出或者在其他的工作中被实现，包括Lamport 的原始的讨论 [15]，VR [22] 和 SMART[24]。我们选择使用联合共识的方法是因为它利用了共识协议的其余部分，这样我们只需要很少的一些机制就可以实现成员变更。Lamport的基于 α 的方法之所以没有被 Raft 选择是因为它假设在没有 leader的情况下也可以达到共识性。和 VR 和 SMART 相比较，Raft的重新配置算法可以在不限制正常请求处理的情况下进行。相比之下，VR在配置变更期间需要停止所有正常的处理过程，而 SMART对未完成请求的数量实施了类似 α 方法的限制。另外，和 VR、SMART 相比，Raft的方法也只需要增加更少的额外机制来实现。</p><h2 id="结论">11. 结论</h2><p>算法的设计通常以正确性、效率和简洁性为主要目标。虽然这些都是有价值的目标，但我们相信可理解性同样重要。在开发人员将算法转化为实际实现之前，其他任何目标都不能实现，而实际实现将不可避免地偏离和扩展发布的形式。除非开发人员对算法有深刻的理解，并能对算法有直观的认识，否则他们很难在实现中保留算法理想的特性。</p><p>在本文中，我们讨论了分布式共识的问题，在这个问题上，一个被广泛接受但难以理解的算法：Paxos，多年来一直让学生和开发人员非常挣扎。我们开发了一种新的算法：Raft，我们已经证明它比Paxos 更容易理解。我们也相信 Raft会为系统建设提供更好的基础。将可理解性作为主要设计目标改变了我们处理Raft设计的方式。随着设计的进展，我们发现自己反复使用了一些技术，比如分解问题和简化状态空间。这些技术不仅提高了Raft 的可理解性，而且使我们更容易证实它的正确性。</p><h2 id="致谢">12. 致谢</h2><p>这项研究必须感谢以下人员的支持：Ali Ghodsi，David Mazie`res，和伯克利CS 294-91 课程、斯坦福 CS 240课程的学生，没有他们的大力支持，这项研究是不可能完成的。Scott Klemmer帮我们设计了用户调查，Nelson Ray建议我们进行统计学的分析。在用户调查时使用的关于 Paxos的幻灯片很大一部分是从 Lorenzo Alvisi的幻灯片上借鉴过来的。特别的，非常感谢 DavidMazieres 和 EzraHoch，他们找到了 Raft中一些难以发现的漏洞。许多人提供了关于这篇论文十分有用的反馈和用户调查材料，包括Ed Bugnion，Michael Chan，Hugues Evrard，Daniel Giffin，ArjunGopalan，Jon Howell，Vimalkumar Jeyakumar，Ankita Kejriwal，AleksandarKracun，Amit Levy，Joel Martin，Satoshi Matsushita，Oleg Pesok，DavidRamos，Robbert van Renesse，Mendel Rosenblum，Nicolas Schiper，DeianStefan，Andrew Stone，Ryan Stutsman，David Terei，Stephen Yang，MateiZaharia 以及 24位匿名的会议审查人员（可能有重复），并且特别感谢我们的领导人 EddieKohler。Werner Vogels 发了一条早期草稿链接的推特，给 Raft带来了极大的关注。我们的工作由 Gigascale 系统研究中心和 Multiscale系统研究中心给予支持，这两个研究中心由关注中心研究程序资金支持，一个是半导体研究公司的程序，由STARnet 支持，一个半导体研究公司的程序由 MARCO 和 DARPA支持，在国家科学基金会的 0963859 号批准，并且获得了来自Facebook，Google，Mellanox，NEC，NetApp，SAP 和 Samsung 的支持。DiegoOngaro 由 Junglee 公司，斯坦福的毕业团体支持。</p><h2 id="参考文献">参考文献</h2><p>[1] BOLOSKY, W. J., BRADSHAW, D., HAAGENS, R. B., KUSTERS, N. P., ANDLI, P. Paxos replicated state machines as the basis of ahigh-performance data store. In <em>Proc. NSDI’11, USENIX Conference onNetworked Systems Design and Implementation</em> (2011), USENIX, pp.141–154.</p><p>[2] BURROWS, M. The Chubby lock service for loosely- coupleddistributed systems. In <em>Proc. OSDI’06, Sympo- sium on OperatingSystems Design and Implementation</em> (2006), USENIX, pp. 335–350.</p><p>[3] CAMARGOS, L. J., SCHMIDT, R. M., AND PEDONE, F. MulticoordinatedPaxos. In <em>Proc. PODC’07, ACM Sym- posium on Principles ofDistributed Computing</em> (2007), ACM, pp. 316–317.</p><p>[4] CHANDRA, T. D., GRIESEMER, R., AND REDSTONE, J. Paxos made live:an engineering perspective. In <em>Proc. PODC’07, ACM Symposium onPrinciples of Distributed Computing</em> (2007), ACM, pp. 398–407.</p><p>[5] CHANG, F., DEAN, J., GHEMAWAT, S., HSIEH, W. C., WALLACH, D. A.,BURROWS, M., CHANDRA, T., FIKES, A., AND GRUBER, R. E. Bigtable: adistributed storage system for structured data. In <em>Proc. OSDI’06,USENIX Symposium on Operating Systems Design and Implementation</em>(2006), USENIX, pp. 205–218.</p><p>[6] CORBETT, J. C., DEAN, J., EPSTEIN, M., FIKES, A., FROST, C.,FURMAN, J. J., GHEMAWAT, S., GUBAREV, A., HEISER, C., HOCHSCHILD, P.,HSIEH, W., KAN- THAK, S., KOGAN, E., LI, H., LLOYD, A., MELNIK, S.,MWAURA, D., NAGLE, D., QUINLAN, S., RAO, R., ROLIG, L., SAITO, Y.,SZYMANIAK, M., TAYLOR, C., WANG, R., AND WOODFORD, D. Spanner: Google’sglobally-distributed database. In <em>Proc. OSDI’12, USENIX Conferenceon Operating Systems Design and Implemen- tation</em> (2012), USENIX,pp. 251–264.</p><p>[7] COUSINEAU, D., DOLIGEZ, D., LAMPORT, L., MERZ, S., RICKETTS, D.,AND VANZETTO, H. TLA+ proofs. In <em>Proc. FM’12, Symposium on FormalMethods</em> (2012), D. Giannakopoulou and D. Me ́ry, Eds., vol. 7436 of<em>Lec- ture Notes in Computer Science</em>, Springer, pp. 147–154.</p><p>[8] GHEMAWAT, S., GOBIOFF, H., AND LEUNG, S.-T. The Google filesystem. In <em>Proc. SOSP’03, ACM Symposium on Operating SystemsPrinciples</em> (2003), ACM, pp. 29–43.</p><p>[9] GRAY,C.,ANDCHERITON,D.Leases:Anefficientfault- tolerant mechanismfor distributed file cache consistency. In <em>Proceedings of the 12thACM Ssymposium on Operating Systems Principles</em> (1989), pp.202–210.</p><p>[10] HERLIHY, M. P., AND WING, J. M. Linearizability: a correctnesscondition for concurrent objects. <em>ACM Trans- actions on ProgrammingLanguages and Systems 12</em> (July 1990), 463–492.</p><p>[11] HUNT, P., KONAR, M., JUNQUEIRA, F. P., AND REED, B . ZooKeeper:wait-free coordination for internet-scale systems. In <em>Proc ATC’10,USENIX Annual Technical Con- ference</em> (2010), USENIX, pp.145–158.</p><p>[12] JUNQUEIRA, F. P., REED, B. C., AND SERAFINI, M. Zab:High-performance broadcast for primary-backup sys- tems. In <em>Proc.DSN’11, IEEE/IFIP Int’l Conf. on Depend- able Systems &amp;Networks</em> (2011), IEEE Computer Society, pp. 245–256.</p><p>[13] KIRSCH, J., AND AMIR, Y. Paxos for system builders. Tech. Rep.CNDS-2008-2, Johns Hopkins University, 2008.</p><p>[14] L A M P O RT, L . Time, clocks, and the ordering of events in adistributed system. <em>Commununications of the ACM 21</em>, 7 (July1978), 558–565.</p><p>[15] L A M P O RT, L . The part-time parliament. <em>ACM Transac-tions on Computer Systems 16</em>, 2 (May 1998), 133–169.</p><p>[16] LAMPORT, L. Paxos made simple. <em>ACM SIGACT News 32</em>, 4(Dec. 2001), 18–25.</p><p>[17] L A M P O RT, L . <em>Specifying Systems, The TLA+ Language andTools for Hardware and Software Engineers</em>. Addison- Wesley,2002.</p><p>[18] LAMPORT, L. Generalized consensus and Paxos. Tech. Rep.MSR-TR-2005-33, Microsoft Research, 2005.</p><p>[19] L A M P O RT, L . Fast paxos. (2006), 79–103.</p><p>[20] LAMPSON, B. W. How to build a highly available system usingconsensus. In <em>Distributed Algorithms</em>, O. Baboaglu and K.Marzullo, Eds. Springer-Verlag, 1996, pp. 1–17.</p><p>[21] LAMPSON, B. W. The ABCD’s of Paxos. In <em>Proc. PODC’01, ACMSymposium on Principles of Distributed Computing</em> (2001), ACM, pp.13–13.</p><p>[22] LISKOV, B., AND COWLING, J. Viewstamped replica- tion revisited.Tech. Rep. MIT-CSAIL-TR-2012-021, MIT, July 2012.</p><p>[23] LogCabin source code. http://github.com/ logcabin/logcabin.</p><p>[24] LORCH, J. R., ADYA, A., BOLOSKY, W. J., CHAIKEN, R., DOUCEUR, J.R., AND HOWELL, J. The SMART way to migrate replicated statefulservices. In <em>Proc. Eu- roSys’06, ACM SIGOPS/EuroSys EuropeanConference on Computer Systems</em> (2006), ACM, pp. 103–115.</p><p>[25] MAO, Y., JUNQUEIRA, F. P., AND MARZULLO, K. Mencius: buildingefficient replicated state machines for WANs. In <em>Proc. OSDI’08,USENIX Conference on Operating Systems Design and Implementation</em>(2008), USENIX, pp. 369–384.</p><p>[26] MAZIE` RES, D. Paxos made practical.http://www.scs.stanford.edu/ ̃dm/home/ papers/paxos.pdf, Jan. 2007.</p><p>[27] MORARU, I., ANDERSEN, D. G., AND KAMINSKY, M. There is moreconsensus in egalitarian parliaments. In <em>Proc. SOSP’13, ACMSymposium on Operating System Principles</em> (2013), ACM.</p><p>[28] Raft user study. http://ramcloud.stanford. edu/̃ongaro/userstudy/.</p><p>[29] OKI, B. M., AND LISKOV, B. H. Viewstamped replication: A newprimary copy method to support highly-available distributed systems. In<em>Proc. PODC’88, ACM Symposium on Principles of DistributedComputing</em> (1988), ACM, pp. 8–17.</p><p>[30] O’NEIL, P., CHENG, E., GAWLICK, D., AND ONEIL, E. Thelog-structured merge-tree (LSM-tree). <em>Acta Informat- ica 33</em>, 4(1996), 351–385.</p><p>[31] ONGARO, D. <em>Consensus: Bridging Theory and Practice</em>. PhDthesis, Stanford University, 2014 (work in progress).</p><p>[32] ONGARO, D., AND OUSTERHOUT, J. In search of an understandableconsensus algorithm. In <em>Proc ATC’14, USENIX Annual TechnicalConference</em> (2014), USENIX.</p><p>[33] OUSTERHOUT, J., AGRAWAL, P., ERICKSON, D., KOZYRAKIS, C.,LEVERICH, J., MAZIE`RES, D., MI- TRA, S., NARAYANAN, A., ONGARO, D.,PARULKAR, G., ROSENBLUM, M., RUMBLE, S. M., STRATMANN, E., AND STUTSMAN,R. The case for RAMCloud. <em>Com- munications of the ACM 54</em> (July2011), 121–130.</p><p>[34] Raft consensus algorithm website.http://raftconsensus.github.io.</p><p>[35] REED, B. Personal communications, May 17, 2013.</p><p>[36] ROSENBLUM, M., AND OUSTERHOUT, J. K. The design andimplementation of a log-structured file system. <em>ACM Trans. Comput.Syst. 10</em> (February 1992), 26–52.</p><p>[37] S C H N E I D E R , F. B . Implementing fault-tolerant servicesusing the state machine approach: a tutorial. <em>ACM Com- putingSurveys 22</em>, 4 (Dec. 1990), 299–319.</p><p>[38] SHVACHKO, K., KUANG, H., RADIA, S., AND CHANSLER, R. The Hadoopdistributed file system. In <em>Proc. MSST’10, Symposium on Mass StorageSys- tems and Technologies</em> (2010), IEEE Computer Society, pp.1–10.</p><p>[39] VAN RENESSE, R. Paxos made moderately complex. Tech. rep.,Cornell University, 2012.</p>]]></content>
    
    
    <summary type="html">本文对 Raft-Extended 进行了一比一的翻译，其中有些地方加入了额外的注解，这些都是笔者在学习 Raft 算法时遇到的比较困惑的难点，希望这些注解能对其他读者有帮助。</summary>
    
    
    
    <category term="论文翻译" scheme="https://hedon.top/categories/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="分布式" scheme="https://hedon.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="Raft" scheme="https://hedon.top/tags/Raft/"/>
    
    <category term="原创" scheme="https://hedon.top/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
</feed>
