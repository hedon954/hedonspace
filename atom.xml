<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HedonWang</title>
  
  <subtitle>君子求诸己，律己则安。</subtitle>
  <link href="https://hedon.top/atom.xml" rel="self"/>
  
  <link href="https://hedon.top/"/>
  <updated>2025-05-13T05:22:13.936Z</updated>
  <id>https://hedon.top/</id>
  
  <author>
    <name>Hedon Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust 实战丨实现一个 SpinLock</title>
    <link href="https://hedon.top/2025/05/13/rust-action-spinlock/"/>
    <id>https://hedon.top/2025/05/13/rust-action-spinlock/</id>
    <published>2025-05-13T04:58:25.000Z</published>
    <updated>2025-05-13T05:22:13.936Z</updated>
    
    <content type="html"><![CDATA[<p>自旋锁，就是在尝试获取锁失败时，不直接挂起，而是一直循环尝试获取锁。这在一些锁冲突较小且占用锁时间非常短的场景下非常有用，因为它可以减少相应的系统调用。</p><p>接下来我们就使用 Rust 来实现一个自己的自旋锁。</p><h2 id="基础版">基础版</h2><p>首先是最基础的版本，我们在 <code>lock</code>的时候，如果失败了，就一直循环尝试，直到成功获取锁：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    locked: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            locked: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.locked.<span class="title function_ invoke__">swap</span>(<span class="literal">true</span>, Ordering::Acquire) &#123;</span><br><span class="line">            std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unlock</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.locked.<span class="title function_ invoke__">store</span>(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述实现中，我们定义了结果 <code>SpinLock</code>，它包含一个<code>value</code> 和原子变量 <code>locked</code>。</p><p>在 <code>lock</code> 方法中，我们尝试对 <code>locked</code>原子变量进行 <code>swap</code> 为 <code>true</code>的操作，<code>swap</code> 会返回交换之前的值，如果是<code>false</code>，那就说明抢锁成功了，这个时候 <code>lock</code>就成功返回，否则，则调用 <code>std::hint::spin_loop()</code>进行自选，在下一次 <code>while</code> 循环中再尝试获取锁。</p><p>在 <code>unlock</code> 方法中，我们只需要将 <code>locked</code>设置为 <code>false</code> 即可。</p><p>示例图如下：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250513131603680.png" /></p><p>这里有 2 个需要关注的点：</p><ol type="1"><li><code>std::hint::spin_loop()</code> 会向 CPU 发送特定指令（如 x86 的pause 或 ARM 的 yield），提示当前处于忙等待状态。这允许 CPU优化执行行为，例如：<ul><li><strong>降低功耗</strong>：减少自旋期间的计算资源消耗。</li><li><strong>提升多线程效率</strong>：在超线程架构中，避免单个核心的忙等待阻塞其他线程的执行。</li></ul></li><li>这里我们内存循序使用了一对 <code>Acquire</code> 和<code>Release</code>。其中：<ul><li><code>Acquire</code> 是为了当前线程可以看到其他线程对<code>locked</code> 的写结果，即看到当前 <code>locked</code>真正的值。</li><li><code>Release</code> 是为了当前线程对<code>locked</code>写的结果对其他线程可见，即释放当前<code>locked</code> 真正的值给其他线程。</li></ul></li></ol><h2 id="unsafe-版本">unsafe 版本</h2>]]></content>
    
    
    <summary type="html">本文从零开始，从简单到精细，一步步实现一个高性能的自旋锁 SpinLock。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《Rust Atomics and Locks》</title>
    <link href="https://hedon.top/2025/04/25/note-rust-atomics-and-locks/"/>
    <id>https://hedon.top/2025/04/25/note-rust-atomics-and-locks/</id>
    <published>2025-04-25T07:46:36.000Z</published>
    <updated>2025-04-25T10:18:56.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rust-并发基础">Rust 并发基础</h2><h3 id="多线程">多线程</h3><p>开启线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启线程</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程退出</span></span><br><span class="line">t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>()</span><br></pre></td></tr></table></figure><p>控制线程周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">  s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;)</span><br><span class="line">  s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这里会确保 scope 里面的线程都执行完毕并退出</span></span><br></pre></td></tr></table></figure><h3 id="内部可变性interior-mutability">内部可变性（InteriorMutability）</h3><p>Rust内存安全默认基于以下规则：同一时间，一个数据只能被多个不可变引用（<code>&amp;T</code>）共享，或仅被一个可变引用（<code>&amp;mut T</code>）独占。这种编译时检查避免了数据竞争，但不够灵活，例如多个线程同时持有了同一个引用，那它必然只能是不可变引用，也就无法实现多线程并发修改同一数据的功能了。</p><p>内部可变性允许通过不可变引用（<code>&amp;T</code>）修改数据，即使数据本身未被声明为<code>mut</code>。其核心思想是：<strong>“看似不可变的外部接口，内部可变”</strong>。例如，<code>RefCell</code>允许在运行时动态借用可变引用，而非依赖编译时的静态检查。</p><h4 id="unsafecell">UnsafeCell</h4><p><code>UnsafeCell&lt;T&gt;</code> 是 Rust内部可变性的基石，所有提供内部可变性的类型（如<code>Cell</code>、<code>RefCell</code>）均基于它实现。</p><table><colgroup><col style="width: 20%" /><col style="width: 13%" /><col style="width: 16%" /><col style="width: 20%" /><col style="width: 30%" /></colgroup><thead><tr class="header"><th>类型</th><th>线程安全</th><th>运行时检查</th><th>适用数据类型</th><th>典型场景</th></tr></thead><tbody><tr class="odd"><td><code>Cell&lt;T&gt;</code></td><td>❌</td><td>❌</td><td><code>Copy</code> 类型</td><td>简单值的快速修改</td></tr><tr class="even"><td><code>RefCell&lt;T&gt;</code></td><td>❌</td><td>✔️</td><td>任意类型</td><td>单线程复杂数据结构</td></tr><tr class="odd"><td><code>RwLock&lt;T&gt;</code></td><td>✔️</td><td>✔️（阻塞）</td><td>任意类型</td><td>多线程共享数据</td></tr><tr class="even"><td><code>UnsafeCell</code></td><td>❌</td><td>❌</td><td>任意类型</td><td>底层安全抽象的实现</td></tr></tbody></table><p><code>UnsafeCell&lt;T&gt;</code> 的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// The core primitive for interior mutability in Rust.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// If you have a reference `&amp;T`, then normally in Rust the compiler performs optimizations based on</span></span><br><span class="line"><span class="comment">/// the knowledge that `&amp;T` points to immutable data. Mutating that data, for example through an</span></span><br><span class="line"><span class="comment">/// alias or by transmuting a `&amp;T` into a `&amp;mut T`, is considered undefined behavior.</span></span><br><span class="line"><span class="comment">/// `UnsafeCell&lt;T&gt;` opts-out of the immutability guarantee for `&amp;T`: a shared reference</span></span><br><span class="line"><span class="comment">/// `&amp;UnsafeCell&lt;T&gt;` may point to data that is being mutated. This is called &quot;interior mutability&quot;.</span></span><br><span class="line"><span class="meta">#[repr(transparent)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UnsafeCell</span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    value: T,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>#[repr(transparent)]</code> 保证了<code>UnsafeCell&lt;T&gt;</code> 和 <code>T</code>类型内存布局的一致性，这是后面各种指针可以直接安全强转的基础。</p><p>它有 2 个核心方法，分别为 <code>get_mut</code> 和<code>get</code>，其中 <code>get_mut</code> 比较简单，如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Returns a mutable reference to the underlying data.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This call borrows the `UnsafeCell` mutably (at compile-time) which</span></span><br><span class="line"><span class="comment">/// guarantees that we possess the only reference.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> T &#123;</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数本来就是 <code>&amp;mut</code> 的，所以直接返回<code>&amp;mut self.value</code>就可以了，天然满足编译器检查要求，不需要其他额外的骚操作。</p><p><code>get</code> 就不一般了，因为 <code>get</code>的作用是，<strong>从一个不可变引用中获取可变引用！</strong>这明显是要打破编译器的引用检查机制，所以需要一些骚操作。它的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Gets a mutable pointer to the wrapped value.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">get</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> *<span class="keyword">mut</span> T &#123;</span><br><span class="line">    <span class="keyword">self</span> <span class="keyword">as</span> *<span class="keyword">const</span> UnsafeCell&lt;T&gt; <span class="keyword">as</span> *<span class="keyword">const</span> T <span class="keyword">as</span> *<span class="keyword">mut</span> T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发明 Rust 的绝对是个套娃大佬...</p></blockquote><p><code>self as *const UnsafeCell&lt;T&gt; as *const T as *mut T</code>的三步转换过程可分解为：</p><ol type="1"><li><strong>原始指针获取 self as *constSelf</strong>：将当前对象的不可变引用（<code>&amp;self</code>）转换为不可变的原生指针（<code>*const Self</code>），这一步仅获取地址，不涉及内存操作，是安全的。</li><li><strong>类型强制转换 *const Self as *constT</strong>：将指针类型从指向 <code>Self</code>（即<code>UnsafeCell&lt;T&gt;</code> 类型）转换为指向内部存储的<code>T</code> 类型。由于 <code>UnsafeCell</code> 的内存布局与<code>T</code>完全一致（<code>#[repr(transparent)]</code>），此转换在内存对齐上无风险。</li><li><strong>可变性重解释 *const T as *mutT</strong>：将不可变指针强制转换为可变指针。这一步是 ​<strong>绕过 Rust默认不可变引用规则的关键</strong>，允许通过共享引用修改内部数据，但需开发者自行保证安全性。</li></ol><p>我们可以通过回答 2 个问题来进一步感受 Rust 的设计哲学与安全边界：</p><div class="tag-plugin colorful folders" ><details class="folder" index="0"><summary><p>① 为什么需要多步转换？</p></summary><div class="body"><ul><li><strong>安全隔离</strong>：Rust默认禁止通过不可变引用（<code>&amp;T</code>）修改数据，但<code>UnsafeCell</code>是内部可变性的底层原语，需通过指针转换绕过编译器检查。多步转换将“危险操作”限制在可控范围内。</li><li><strong>类型系统约束</strong>：<code>UnsafeCell</code> 的<code>get()</code> 方法返回 <code>*mut T</code>，但方法参数是<code>&amp;self</code>（不可变引用）。通过逐步转换，既满足方法签名要求，又实现内部可变性。</li></ul></div></details><details class="folder" index="1"><summary><p>② 为什么不直接转换</p></summary><div class="body"><ul><li><strong>不变性（Invariance）</strong>：<code>UnsafeCell</code>的泛型参数 <code>T</code> 的生命周期标记为<strong>不变（invariant）</strong>，防止协变（covariance）导致悬垂指针。直接转换可能破坏生命周期约束。</li><li><strong>裸指针的语义</strong>：<code>*const T</code> 和<code>*mut T</code> 在 Rust中代表不同的内存访问权限。强制转换需显式标记，提醒开发者注意潜在的数据竞争风险。</li></ul></div></details></div><h4 id="cell">Cell</h4><p><code>Cell&lt;T&gt;</code>允许在不可变引用的前提下修改数据。其设计核心是在 <code>UnsafeCell</code>的基础上，通过限制数据访问方式和类型约束，在保证内存安全的同时突破 Rust默认的借用规则。</p><p>它的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A mutable memory location.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # Memory layout</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// `Cell&lt;T&gt;` has the same [memory layout and caveats as</span></span><br><span class="line"><span class="comment">/// `UnsafeCell&lt;T&gt;`](UnsafeCell#memory-layout). In particular, this means that</span></span><br><span class="line"><span class="comment">/// `Cell&lt;T&gt;` has the same in-memory representation as its inner type `T`.</span></span><br><span class="line"><span class="meta">#[repr(transparent)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Cell</span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Cell</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Cell</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们重点来看一下下面 2 行跟 <code>Send</code> 和 <code>Sync</code>相关的实现，我们先回顾一下几个关键的 trait：</p><ul><li><code>Send</code>: 表示类型的所有权可以安全地跨线程转移。</li><li><code>Sync</code>:表示类型的不可变引用（<code>&amp;T</code>）可以安全地跨线程共享。<code>!Sync</code>表示明确禁止这一行为。</li><li><code>Sized</code>: 表示类型的大小是固定的。<code>!Sized</code>表示类型的大小是固定的。泛型类型参数默认隐式包含 <code>T: Sized</code>约束，<code>?Sized</code> 表示支持动态大小的类型</li></ul><p>所以：</p><ul><li><code>unsafe impl&lt;T: ?Sized&gt; Send for Cell&lt;T&gt; where T: Send &#123;&#125;</code>表示在 T 是 <code>Send</code> 的前提下，允许将<code>Cell&lt;T&gt;</code> 的所有权移动到其他线程。</li><li><code>impl&lt;T: ?Sized&gt; !Sync for Cell&lt;T&gt; &#123;&#125;</code>表示🈲止跨线程共享 <code>&amp;Cell&lt;T&gt;</code>。</li></ul>]]></content>
    
    
    <summary type="html">x</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>RAG 技术概览</title>
    <link href="https://hedon.top/2025/04/13/ai-rag-tech-overview/"/>
    <id>https://hedon.top/2025/04/13/ai-rag-tech-overview/</id>
    <published>2025-04-13T14:23:22.000Z</published>
    <updated>2025-04-13T16:38:28.053Z</updated>
    
    <content type="html"><![CDATA[<p>RAG的整个流程可概括为如下图所示，主要分成<strong>索引</strong>、<strong>检索</strong>和<strong>生成</strong>三个部分。</p><p>本文提供配套的完整案例，源码可参考：<ahref="https://github.com/hedon-ai-road/rag-demo">hedon-ai-road/rag-demo</a>，每个commit 都引入了一个新的技术点，感兴趣的读者可根据 commit记录一一查探。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250413223908403.png" /></p><h2 id="文档解析技术">文档解析技术</h2><blockquote><p><ahref="https://github.com/hedon-ai-road/rag-demo/commit/26d52ac964ca099e1726fccb5f4c18adc0fd940f#diff-b10564ab7d2c520cdd0243874879fb0a782862c3c902ab535faabe57d5a505e1">代码示例</a></p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/c60419a3c73f3090651a4c2761e05583.png" /></p><h3 id="pdf">PDF</h3><ul><li>基于规则的开源库<ul><li>pyPDF2</li><li>PyMuPDF</li><li>pdfminer</li><li>pdfplumber</li><li>papermage</li></ul></li><li>基于深度学习的开源库<ul><li>Layout-parser</li><li>PP-StructureV2</li><li>PDF-Extract-Kit</li><li>pix2text</li><li>MinerU</li><li>marker</li><li>Gptpdf（基于 LLM API）</li></ul></li><li>商业闭源库<ul><li>Textln.com</li><li>Doc2x</li><li>mathpix</li><li>庖丁 PDFlux</li><li>腾讯云文档识别</li></ul></li></ul><h2 id="分块策略">分块策略</h2><blockquote><p><ahref="https://github.com/hedon-ai-road/rag-demo/commit/a26ae8895da7a9673660b31904857307a149c983">代码示例</a></p><p><a href="https://chunkviz.up.railway.app/">分块演示工具</a></p></blockquote><p>3 个关键部分组成：</p><ul><li>大小</li><li>重叠</li><li>拆分</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/63b052c1b1639bfa66c23342cf28d9ef.jpg" style="zoom: 33%;" /></p><h3 id="固定大小分块fixed-size-chunking">固定大小分块（Fixed SizeChunking）</h3><p>适用场景：</p><ol type="1"><li>作为分块策略的基准线；</li><li>对大型数据集进行初步分析；</li><li>实现简单且可观测性高，分块便于管理；</li><li>适用于格式和大小相似的同质数据集，如新闻文章或博客文章。</li></ol><p>问题：</p><ol type="1"><li>不考虑内容上下文，容易导致无意义的文本块；</li><li>缺乏灵活性，无法适应文本的自然结构</li></ol><h3 id="重叠分块overlap-chunking">重叠分块（Overlap Chunking）</h3><p>使用场景：</p><ol type="1"><li>需要深入理解语义并保持上下文完整性的文档，如法律文档、技术手册或科研论文；</li><li>提升分块内容的连贯性，以提高分析质量。</li></ol><p>问题：</p><ol type="1"><li>计算复杂度增加，处理效率降低；</li><li>冗余信息的存储和管理成为负担。</li></ol><h3 id="递归分块recursive-chunking">递归分块（Recursive Chunking）</h3><ul><li>通过预定义的文本分隔符（如换行符、、句号、逗号、感叹号、空格等）迭代地将文本分解为更小的块，以实现段大小的均匀性和语义完整性。</li><li>先按较大的逻辑单元分割，再逐步递归到较小单元，确保在分块大小限制内保留最强的语义片段。</li></ul><p>使用场景：</p><ol type="1"><li>需要逐层分析的文本文档或需要分解成长片段、长段落的长文档，如研究报告、法律文档等。</li></ol><p>问题：</p><ol type="1"><li>在块边界处模糊语义，容易将完整的语义单元切分开。</li></ol><h3 id="文档特定分块document-specific-chunking">文档特定分块（DocumentSpecific Chunking）</h3><ul><li>根据文档的格式（如 Markdown、Latex、或编程语言如 Python等）进行定制化分割的技术。此方法依据文档的特定格式和结构规则，例如Markdown 的标题、列表项，或 Python代码中的函数和类定义等，来确定分块边界。</li></ul><p>适用场景：</p><ol type="1"><li>有特定的文档结构，如编程语言、Markdown、Latex 等结构文档。</li></ol><p>问题：</p><ol type="1"><li>格式依赖性强，不同格式之间的分块策略不通用；</li><li>无法处理格式不规范及混合多种格式的情况。</li></ol><h3 id="语义分块semantic-chunking">语义分块（Semantic Chunking）</h3><ul><li>基于文本的自然语言边界（如句子、段落或主题中断）进行分段的技术，需要使用NLP技术根据语义分词分句，旨在确保每个分块都包含语义连贯的信息单元。</li></ul><p>适用场景：</p><ol type="1"><li>确保每个文档块的信息完整性且语义连贯；</li><li>提高检索结果的相关性和准确性；</li><li>适用于复杂文档和上下文敏感的精细化分析。</li></ol><p>问题：</p><ol type="1"><li>需要额外的高计算资源，特别是在处理大型或动态变化的文档数据时；</li><li>处理效率降低。</li></ol><h3 id="混合分块mix-chunking">混合分块（Mix Chunking）</h3><ul><li>在初始阶段使用固定长度分块快速整理大量文档，而在后续阶段使用语义分块进行更精细的分类和主题提取。根据实际业务场景，设计多种分块策略的混合，能够灵活适应各种需求，提供更强大的分块方案。</li></ul><p>适用场景：</p><ol type="1"><li>适用于多层次的精细化分块场景；</li><li>数据集动态变化，包含多种文档格式与结构；</li><li>平衡处理速度与准确性的场景。</li></ol><p>问题：</p><ol type="1"><li>实现复杂度高；</li><li>策略调优难度高；</li><li>资源消耗增加。</li></ol><h2 id="embedding-技术">Embedding 技术</h2><ul><li>Embedding嵌入是指将文本、图像、音频、视频等形式的信息映射为高维空间中的密集向量表示。这些向量在语义空间中起到坐标的作用，捕捉对象之间的语义关系和隐含的意义。通过在向量空间中进行计算（例如余弦相似度），可以量化和衡量这些对象之间的语义相似性。</li><li>向量检索（VectorRetrieval）是一种基于向量表示的搜索技术，通过计算查询向量与已知文本向量的相似度来识别最相关的文本数据。向量检索的高效性在于，它能在大规模数据集中快速、准确地找到与查询最相关的内容，这得益于向量表示中蕴含的丰富语义信息。</li></ul><p>评估指标：（MTEB、C-MTEB）</p><ol type="1"><li>特定领域的适用性</li><li>检索精度</li><li>支持的语言</li><li>文本块长度</li><li>模型大小</li><li>检索效率</li></ol><h2 id="向量数据库">向量数据库</h2><blockquote><p><ahref="https://github.com/hedon-ai-road/rag-demo/commit/1f9c07ec6b10d6bfdb55c17c2c6a7ad461b00ab2">代码示例</a></p></blockquote><ul><li>向量数据库是一种专门用于存储和检索多维向量的数据库类型，与传统的基于行列结构的数据库不同，它主要处理高维空间中的数据点。</li><li>向量数据库的操作逻辑是基于相似性搜索，即在查询时，应用特定的相似性度量（如余弦相似度、欧几里得距离等）来查找与查询向量最相似的向量。</li></ul><p>向量数据库的核心在于其高效的索引和搜索机制。为了优化查询性能，它采用了如哈希、量化和基于图形的多种算法。</p><ul><li>层次化可导航小世界（<strong>HNSW</strong>）：通过在多层结构中将相似向量连接在一起，快速缩小搜索范围。</li><li>产品量化（<strong>PQ</strong>）：通过压缩高维向量，减少内存占用并加速检索。</li><li>位置敏感哈希（<strong>LSH</strong>）：通过哈希函数将相似向量聚集在一起，便于快速定位。</li></ul><p>向量数据库的工作流程：</p><ol type="1"><li>数据处理与向量化</li><li>向量存储</li><li>向量索引</li><li>向量搜索<ul><li>余弦相似度：主要用于文本处理和信息检索，关注向量之间的角度，以捕捉语义相似性。</li><li>欧几里得距离：测量向量之间的实际距离，适用于密集特征集的聚类或分类。</li><li>曼哈顿距离：通过计算笛卡尔坐标中的绝对差值之和，适用于稀疏数据的处理。</li></ul></li><li>数据检索</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/c27b4yy6748a414dae0c679835a1eccc.jpg" /></p><h2 id="混合检索">混合检索</h2><blockquote><p><ahref="https://github.com/hedon-ai-road/rag-demo/commit/38f1739c7ac1d3fc58023cb12bf863d3f502c419">代码示例</a></p></blockquote><ul><li>混合检索（HybridSearch）通过结合关键词检索和语义匹配的优势，可以首先利用关键词检索精确定位到“订单12345”的信息，然后通过语义匹配扩展与该订单相关的其他上下文或客户操作的信息，例如“12开头的订单、包装破损严重”等。这样不仅能够获取精确的订单详情，还能获得与之相关的额外有用信息。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/7eddf214ee696b2e1f5977d72a4db134.jpg" /></p><h2 id="重排序技术">重排序技术</h2><blockquote><p><ahref="https://github.com/hedon-ai-road/rag-demo/commit/4837ef3220d177297169f28fbff5f52eaaee720e">代码示例</a></p></blockquote><ul><li>重排序技术（Reranking）通过对初始检索结果进行重新排序，改善检索结果的相关性，为生成模型提供更优质的上下文，从而提升整体RAG 系统的效果。</li><li>重排序模型大多是基于<strong>双塔</strong>或<strong>交叉编码架构</strong>的模型，在此基础上进一步计算更精确的相关性分数，能够捕捉查询词与文档块之间更细致的相关性，从而在细节层面上提高检索精度。</li></ul><h2 id="提示工程">提示工程</h2><p>一个提示（prompt）通常包含以下几个元素：</p><ol type="1"><li><strong>指令（Instruction）</strong>：指明模型要执行的特定任务或操作。</li><li><strong>上下文（Context）</strong>：为模型提供额外信息或背景，可以帮助引导模型生成更准确的响应。</li><li><strong>输入数据（InputData）</strong>：我们希望模型回答的问题或感兴趣的输入内容。</li><li><strong>输出指示符（OutputIndicator）</strong>：指定模型的输出类型或格式，例如格式、是否要生成代码、总结文本或回答具体问题。</li></ol><p>核心技巧：</p><ul><li><strong>具体指令法</strong>：具体、细致地告诉大模型要做什么。</li><li><strong>示例学习</strong>：给出具体详尽的期望示例。</li><li><strong>默认回复策略</strong>：设定默认回复策略，避免模型产生“幻觉”，让它不知道就说不知道。</li><li><strong>任务角色设定</strong>：设定身份，可以帮助模型更好地理解任务要求和角色责任，从而输出更加一致、专业的内容。</li><li><strong>解释理由法</strong>：向模型解释为什么某些任务需要特定的处理方式，帮助其理解任务背景。</li><li><strong>文档基础说明</strong>：提供文档的背景信息和文本来源。</li></ul><h2 id="优化技术">优化技术</h2><h3 id="数据清洗和预处理">数据清洗和预处理</h3><blockquote><p>在 RAG索引流程中，文档解析之后、文本块切分之前，进行数据清洗和预处理能够有效减少脏数据和噪声，提升文本的整体质量和信息密度。</p><p>通过清除冗余信息、统一格式、处理异常字符等手段，数据清洗和预处理过程确保文档更加规范和高质量，从而提高RAG 系统的检索效果和信息准确性。</p></blockquote><ul><li>处理冗余的模型内容。</li><li>消除文档中的额外空白和格式不一致。</li><li>去除无用的文档脚注、页眉页脚、版权信息。</li></ul><h3 id="查询扩展">查询扩展</h3><blockquote><p>查询扩展策略通过大模型从原始查询语句生成多个语义相关的查询，可以覆盖向量空间中的不同区域，从而提高检索的全面性和准确性。</p></blockquote><p>查询扩展的指令模版：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你是一个AI语言模型助手。</span><br><span class="line">你的任务是生成五个不同版本的用户问题，以便从向量数据库中检索相关文档。</span><br><span class="line">通过从多个角度生成用户问题，你的目标是帮助用户克服基于距离的相似性搜索的一些局限性。</span><br><span class="line">请将这些替代问题用换行符分隔。原始问题：&#123;查询原文&#125;</span><br></pre></td></tr></table></figure><p>假设问题：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面报告中涉及了哪几个行业的案例以及总结各自面临的挑战？</span><br></pre></td></tr></table></figure><p>结果示例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请问报告中提到的案例涉及了哪些行业？这些行业各自面临的挑战有哪些？</span><br><span class="line">报告中有哪些行业的案例被讨论？每个行业在报告中描述的挑战是什么？</span><br><span class="line">这个报告中具体提到了哪些行业的案例？能否总结一下这些行业当前面临的主要挑战？</span><br><span class="line">该报告中涵盖了哪些行业案例，并对各行业的挑战进行了哪些讨论？</span><br><span class="line">在报告中提到的行业案例有哪些？这些行业分别遇到的主要问题和挑战是什么？</span><br></pre></td></tr></table></figure><p>通过这种查询扩展策略，原始问题被分解为多个子查询，每个子查询独立检索相关文档并生成相应的结果。随后，系统将所有子查询的检索结果进行合并和重新排序，效果会更全面更准确。</p><h3 id="自查询">自查询</h3><blockquote><p>自查询策略通过大语言模型自动提取查询中对业务场景至关重要的元数据字段（如标签、作者ID、评论数量等关键信息），并将这些信息结合到嵌入检索过程中。</p></blockquote><p>自查询的指令模版：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你是一个AI语言模型助手。  </span><br><span class="line">你的任务是从用户问题中提取关键信息，你的回复应仅包含提取的关键信息。  </span><br><span class="line">用户问题：&#123;查询原文&#125;</span><br></pre></td></tr></table></figure><p>假设问题：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面报告中涉及了哪几个行业的案例以及总结各自面临的挑战？</span><br></pre></td></tr></table></figure><p>结果示例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行业，案例，挑战</span><br></pre></td></tr></table></figure><h3 id="提示压缩">提示压缩</h3><blockquote><p>提示压缩通过精简上下文、过滤掉不相关的信息，确保系统只处理与查询最相关、最重要的内容。</p></blockquote><p>提示压缩的指令模版：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">你是一个AI语言模型助手，负责对检索到的文档进行上下文压缩。</span><br><span class="line">你的目标是从文档中提取与用户查询高度相关的段落，并删除与查询无关或噪声较大的部分。</span><br><span class="line">你应确保保留所有能够直接回答用户查询的问题核心信息。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">用户查询：&#123;用户的原始查询&#125;</span><br><span class="line">检索到的文档：&#123;检索到的文档内容&#125;</span><br><span class="line"></span><br><span class="line">输出要求：</span><br><span class="line">提取与用户查询最相关的段落和信息。</span><br><span class="line">删除所有与查询无关的内容，包括噪声、背景信息或扩展讨论。</span><br><span class="line">压缩后的内容应简洁清晰，直指用户的核心问题。</span><br><span class="line"></span><br><span class="line">输出格式：</span><br><span class="line">&#123;压缩段落1&#125;</span><br><span class="line">&#123;压缩段落2&#125;</span><br><span class="line">&#123;压缩段落3&#125;</span><br></pre></td></tr></table></figure><h2 id="rag-效果评估">RAG 效果评估</h2><ol type="1"><li>大模型打分：通过 LLM 对 RAG的输出进行自动评分。效率高，但是准确性一般。</li><li>人工打分：手工针对 RAG的输出进行逐一打分。更精确、细致的反馈，成本高。</li></ol><p>评估指标：</p><ol type="1"><li><strong>CR（ContextRelevancy）</strong>检索相关性：检索到的信息是否偏离了原始查询。</li><li><strong>AR（AnswerRelevancy）</strong>答案相关性：是否能解决用户的问题，且内容是否逻辑连贯。</li><li><strong>F（Faithfulness）</strong>可信度：是否存在幻觉或不准确之处。</li></ol><p>打分标准：</p><ol type="1"><li>完美（Perfect）1.0 分</li><li>可接受（Acceptable）0.75 分</li><li>缺失（Missing）0.5 分</li><li>错误（Incorrect）0.25 分</li></ol><h2 id="更高级的-rag">更高级的 RAG</h2><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/7c3ebbe6ec9d9f2886881d7e534396a0.jpg" /></p><h2 id="graphrag">GraphRAG</h2><p>GraphRAG通过构建知识图谱，将实体和实体之间的关系结构化地表示出来，克服了传统 RAG的复杂推理局限性。</p><p>有以下优势：</p><ol type="1"><li>提高答案的准确性和完整性</li><li>提高数据理解和迭代效率</li><li>提升可解释性和可追溯性</li></ol><p>知识图谱的构建步骤：</p><ol type="1"><li><strong>实体识别</strong>：从文本或数据源中识别出关键实体。</li><li><strong>关系抽取</strong>：确定实体之间的关系，可能通过自然语言处理技术实现。</li><li><strong>三元组生成</strong>：将实体和关系表示为 (主体，关系，客体)的形式。</li><li><strong>图谱存储</strong>：使用图数据库或专门的存储系统保存知识图谱。</li></ol><p>知识图谱的主要<strong>成本</strong>挑战：</p><ol type="1"><li>数据收集与清洗成本</li><li>知识图谱构建成本</li><li>图谱的维护与更新</li></ol>]]></content>
    
    
    <summary type="html">本文是在笔者学习了极客时间《RAG 快速开发实战》课程后，对 RAG 相关技术进行一个梳理归纳，帮助开发者在 RAG 开发中进行快速定位、系统学习。</summary>
    
    
    
    <category term="AI" scheme="https://hedon.top/categories/AI/"/>
    
    <category term="RAG" scheme="https://hedon.top/categories/AI/RAG/"/>
    
    
    <category term="AI" scheme="https://hedon.top/tags/AI/"/>
    
    <category term="RAG" scheme="https://hedon.top/tags/RAG/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《Unit Testing Principles, Practices, and Patterns》</title>
    <link href="https://hedon.top/2025/04/09/note-unit-testing/"/>
    <id>https://hedon.top/2025/04/09/note-unit-testing/</id>
    <published>2025-04-09T05:19:20.000Z</published>
    <updated>2025-04-15T07:37:25.158Z</updated>
    
    <content type="html"><![CDATA[<p>本篇在上一篇的基础上，梳理下笔者的个人见解，感兴趣的读者可参考原文对比阅读：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://hedon.top/2025/04/09/note-unit-testing-excerpt/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://hedon.top/2025/04/09/note-unit-testing-excerpt/" autofill="title,icon"><div class="left"><span class="title">https://hedon.top/2025/04/09/note-unit-testing-excerpt/</span><span class="cap link footnote">https://hedon.top/2025/04/09/note-unit-testing-excerpt/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><div class="tag-plugin quot"><h2 class="content" id="揪心疑惑" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">揪心疑惑</span><span class="empty"></span></h2></div><p>在撰写单元测试的过程中，你是否曾经被以下问题困扰过？</p><ol type="1"><li>为什么要写单元测试？单元测试的目标是什么？</li><li>单元测试的粒度是怎样的？什么叫单元？a class, a function, or abehavior, or an observable behavior?</li><li>单测覆盖率真的有用吗？有什么用？又有哪些限制？</li><li>怎样才能写好单元测试？怎样才能写出性价比最高的单元测试？</li><li>如何判断一个单元测试的好坏？有没有具体可供参阅的维度？</li><li>哪些代码需要写单元测试，哪些代码没必要写单元测试？</li><li>单元测试和集成测试的边界是什么？</li><li>（单元丨集成）测试到底是要测什么东西？</li><li>单元测试的侧重点是什么？集成测试的侧重点是什么？二者的比例该是怎样的？</li><li>如何使用 Mock？哪些东西是需要 Mock 的？哪些东西是不应该 Mock的？需要 Mock 的东西，应该在哪个层次进行 Mock？（你的 repository 层需要Mock 吗？）</li><li>为什么你的测试代码很脆弱，总是需要频繁修改，维护起来难度很大？</li><li>如何减少测试结果的假阳性和假阴性？</li></ol><div class="tag-plugin quot"><h2 class="content" id="四根柱子" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">四根柱子</span><span class="empty"></span></h2></div><p>对于第 5 个问题，作者提出了 4 个维度：</p><ul><li><strong>Protection againstregressions：防止回归</strong>，通过自动化验证代码修改后原有功能不受破坏。<ul><li><em>The amount of code that is executed during the test.</em></li><li><em>The complexity of that code.</em></li><li><em>The code’s domain significance.</em></li></ul></li><li><strong>Resistance torefactoring：抗重构性</strong>，重构业务代码时，测试代码无需过多变动便可通过用例，证明重构无误。<ul><li><em>Tests provide an early warning when you break existingfunctionality</em>.</li><li><em>You become confident that your code changes won’t lead toregressions</em>.</li></ul></li><li><strong>Fast feedback：快速反馈</strong>。</li><li><strong>Maintainability：可维护性</strong>。<ul><li><em>How hard it is to understand the test.</em></li><li><em>How hard it is to run the test.</em></li></ul></li></ul><p>对于这 4 个问题，你是否又有以下疑问：</p><ol type="1"><li>哪个维度是最重要的？</li><li>怎样才能写出满足各个维度的测试代码？</li><li>如果维度之间存在矛盾，如何 trade off？</li></ol><h2 id="为什么要写单元测试">为什么要写单元测试？</h2><p>三个最重要的原因：</p><ol type="1"><li><p>验证你的程序逻辑正确性。</p></li><li><p>带来更好的代码设计。</p><p>因为单元测试能够让你站在使用者的角度去使用暴露的接口，如果接口不好用，逻辑不好测，测试条件不好构建，大概率说明代码的设计本身是有缺陷的，包括但不限于：抽象不合理、逻辑划分不清晰、与其他模块耦合严重等。</p></li><li><p>使软件项目更可持续发展。</p><p>如果你的需求没有发生变化，那原本能运行通过的单测应该一直都能运行，这有助于避免在团队协作中不小心改坏你不知道的代码，也有助于你执行各种重构措施。</p></li></ol><p>这三个原因的重要性是显而易见的，但笔者个人觉得还有一个更深层次的最重要的原因：</p><ul><li>你要对你做的事情负责，好的代码一定要先过自己这关。</li></ul><h2 id="单元测试的粒度是什么">单元测试的粒度是什么？</h2><p>这是一个很有争议的话题，单元测试的「单元」到底是什么？</p><ul><li>一个类？</li><li>一个函数？</li><li>还是多个类组成的一个模块？</li><li>还是多个函数组成的一个大逻辑？</li></ul><p>在《Unit Testing》书中，作者指出：<strong>「单元」指的是 anobservable behavior，即一个外部系统可观测到的行为</strong>。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2010.png" /></p><p>为什么是可观测行为：</p><ol type="1"><li>一个帮助客户端实现目标的操作（operation）。</li><li>一个帮助客户端实现目标的状态（state）。</li></ol><p>换言之，也就是我在撰写单元测试的时候，我就是在使用系统提供的能力，我就是个使用者，我只要验证你能提供我要的功能，就 OK了，你背后怎么做，为了这个功能所拆分的类也好，小的辅助函数也好，都不重要，都不属于我要验证的范畴。</p><p>所以这更像是黑盒测试（black-box test）。</p><p>当然，会有例外，如果你底层有一个特别特别复杂的逻辑，你有必要专门花精力去验证它的逻辑正确性，那是可以针对它撰写专门的白盒测试（white-boxtest）的。针对这个情况，作者其实也提出了一个观点，对于这个复杂的逻辑，也可以抽成一个单独的模块，由它来提供能力给你当前模块使用。</p><p>总结：</p><ol type="1"><li>优先选择黑盒测试。</li><li>对于涉及复杂算法的逻辑，单独撰写白盒测试。</li><li>结合覆盖率工具去看哪些代码没被覆盖，然后再站在使用者的角度去思考为什么没被覆盖，是这个分支压根没必要存在，还是还有未考虑到的使用场景。</li></ol><h2 id="如何组织单元测试">如何组织单元测试？</h2><p>两种结构：</p><ul><li>AAA: Arrange-Act-Assert</li><li>GWT: Given-When-Then</li></ul><p>其实都是一个思路：准备前置条件→执行待验证代码→验证逻辑正确性。</p><p>几个建议：</p><ol type="1"><li>尽量避免一个单元测试中包含多个 AAA/GWT。</li><li>避免在单元测试中使用 <code>if</code> 等分支语句。</li><li>命名的时候，尽可能让非程序员也能看懂，即这个命名需要描述一个领域问题。</li></ol><h2 id="如何发挥单测的最大价值">如何发挥单测的最大价值？</h2><ol type="1"><li>单元测试用例必须持续不断反复执行验证。</li><li>用最小的维护代价提供最大价值的单元测试。<ol type="1"><li>识别一个有价值的测试</li><li>撰写一个有价值的测试</li></ol></li><li>验证代码中最重要的部分（领域模型）。</li></ol><h3 id="单元测试用例必须持续不断反复执行验证">1.单元测试用例必须持续不断反复执行验证</h3><p>这里推荐笔者的个人实践：</p><ul><li>在 <code>pre-commit</code>执行<strong>增量单元测试</strong>，确保本次修改的代码涉及的单测可正确通过。</li><li>在 <code>gitlab-ci/github-action</code>流程中执行<strong>全量单元测试</strong>，全面覆盖，避免本次修改的代码影响到其他模块的正常功能。同时如果是合并到主分支的请求，加入增量覆盖率阈值检测，不满足阈值的，发送飞书消息卡片进行告警通知。</li></ul><h4 id="pre-commit-增量单测">pre-commit 增量单测</h4><p><code>.pre-commit-config.yaml</code> 配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">go-unit-tests</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">go-unit-tests</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">run</span> <span class="string">go</span> <span class="string">tests</span> <span class="string">with</span> <span class="string">race</span> <span class="string">detector</span></span><br><span class="line">        <span class="attr">entry:</span> <span class="string">bash</span> <span class="string">-c</span> <span class="string">&#x27;./script/run_diff_go_test.sh&#x27;</span></span><br><span class="line">        <span class="attr">language:</span> <span class="string">golang</span></span><br><span class="line">        <span class="attr">files:</span> <span class="string">\.*$</span></span><br><span class="line">        <span class="attr">pass_filenames:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>run_diff_go_test.sh</code> 脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export GOTOOLCHAIN=auto</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前改动的 Go 文件</span></span><br><span class="line">changed_files=$(git diff --name-only --cached --diff-filter=d | grep &#x27;\.go$&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有改动的 Go 文件，退出</span></span><br><span class="line">if [ -z &quot;$changed_files&quot; ]; then</span><br><span class="line">    echo &quot;No Go files changed.&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提取改动文件所在的包路径（使用相对路径），并排除 vendor 目录</span></span><br><span class="line">test_dirs=$(echo &quot;$changed_files&quot; | xargs -n1 dirname | grep -v &#x27;^vendor&#x27; | sort -u)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对每个改动的包路径运行 go <span class="built_in">test</span></span></span><br><span class="line">for dir in $test_dirs; do</span><br><span class="line">    # 检查目录是否存在</span><br><span class="line">    if [ ! -d &quot;$dir&quot; ]; then</span><br><span class="line">        echo &quot;Directory $dir does not exist. Skipping...&quot;</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 检查是否存在 go.mod 文件，确保在 Go 模块路径中</span><br><span class="line">    if [ -f &quot;$dir/go.mod&quot; ] || [ -f &quot;./go.mod&quot; ]; then</span><br><span class="line">        echo &quot;Running tests in $dir...&quot;</span><br><span class="line">        (cd &quot;$dir&quot; &amp;&amp; go test -mod=vendor -gcflags=all=-l -short ./...)</span><br><span class="line">        if [ $? -ne 0 ]; then</span><br><span class="line">            echo &quot;Tests failed in $dir&quot;</span><br><span class="line">            exit 1</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">        echo &quot;Skipping $dir (no go.mod found)&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;All tests passed.&quot;</span><br></pre></td></tr></table></figure><h4 id="gitlab-ci-全量单测">gitlab-ci 全量单测</h4><p><code>gitlab-ci.yml</code> 配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">go-unit-test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">go-unit-test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sh</span> <span class="string">script/unittest.sh</span> <span class="string">&quot;$CI_MERGE_REQUEST_TITLE&quot;</span> <span class="string">&quot;$GITLAB_USER_EMAIL&quot;</span> <span class="string">&quot;$CI_PIPELINE_ID&quot;</span> <span class="string">&quot;$CI_MERGE_REQUEST_TARGET_BRANCH_NAME&quot;</span> <span class="string">&quot;$CI_JOB_ID&quot;</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_PIPELINE_SOURCE</span> <span class="string">==</span> <span class="string">&quot;merge_request_event&quot;</span> <span class="string">&amp;&amp;</span> <span class="string">$CI_MERGE_REQUEST_TARGET_BRANCH_NAME</span> <span class="string">==</span> <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_PIPELINE_SOURCE</span> <span class="string">==</span> <span class="string">&quot;merge_request_event&quot;</span> <span class="string">&amp;&amp;</span> <span class="string">$CI_MERGE_REQUEST_TARGET_BRANCH_NAME</span> <span class="string">==</span> <span class="string">&#x27;release&#x27;</span></span><br><span class="line">  <span class="attr">coverage:</span> <span class="string">&#x27;/coverage: \d+.\d+% of statements/&#x27;</span></span><br></pre></td></tr></table></figure><p><code>unittest.sh</code> 单测执行脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export GOPROXY=&quot;https://goproxy.cn,direct&quot;</span><br><span class="line"></span><br><span class="line">function generate_coverage_report &#123;</span><br><span class="line">  gocover-cobertura &lt; coverage.out &gt; coverage.xml</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 gotestsum 执行单元测试</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果单测执行失败，会发送飞书消息卡片到告警群中</span></span><br><span class="line">if ! gotestsum --junitfile report.xml --post-run-command=&quot;./script/send_fs_card.sh \&quot;$1\&quot; \&quot;$2\&quot; \&quot;$3\&quot; \&quot;$5\&quot;&quot;  -- ./... -timeout 3s -short -mod=vendor -gcflags=all=-l -coverpkg=./... -coverprofile=coverage.out ; then</span><br><span class="line">  generate_coverage_report</span><br><span class="line">  sh script/cal_diff_coverage.sh &quot;$4&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成单元测试覆盖率报告</span></span><br><span class="line">generate_coverage_report</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果增量覆盖率不满足阈值，会发送飞书消息卡片到告警群中</span></span><br><span class="line">source script/cal_diff_coverage.sh &quot;$4&quot;</span><br><span class="line"></span><br><span class="line">if [[ &quot;$4&quot; == &quot;release&quot; ]]; then</span><br><span class="line">  source script/check_test_coverage.sh &quot;$1&quot; &quot;$2&quot; &quot;$3&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中 <code>cal_diff_coverage.sh</code> 用于计算增量覆盖率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">export COVERAGE_PERCENT=0.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保 coverage.xml 文件存在</span></span><br><span class="line">if [ ! -f coverage.xml ]; then</span><br><span class="line">  echo &quot;coverage: 0.0% of statements&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 diff-cover 生成覆盖率报告</span></span><br><span class="line">diff-cover coverage.xml --exclude **/docs.go --html-report report.html --compare-branch &quot;$1&quot; &gt; diff_detail.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否成功生成报告</span></span><br><span class="line">if [ ! -f report.html ]; then</span><br><span class="line">  echo &quot;coverage: 0.0% of statements&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 grep 和 awk 提取覆盖率信息</span></span><br><span class="line">COVERAGE=$(grep &quot;Coverage:&quot; diff_detail.txt | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果找到了覆盖率数据，检查是否包含小数点</span></span><br><span class="line">if [ -n &quot;$COVERAGE&quot; ]; then</span><br><span class="line">  if [[ &quot;$COVERAGE&quot; != *&quot;.&quot;* ]]; then</span><br><span class="line">    # 如果没有小数点，在百分号前面加上 &#x27;.0&#x27;</span><br><span class="line">    # 这里这么做的目的是不知道为什么 gitlab ci 无法正确解析下面这个正则</span><br><span class="line">    # /coverage: \d+(.\d+)?% of statements/</span><br><span class="line">    # 只能解析这个</span><br><span class="line">    # /coverage: \d+.\d+% of statements/</span><br><span class="line">    COVERAGE=&quot;$&#123;COVERAGE/\%/.0%&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;coverage: $COVERAGE of statements&quot;</span><br><span class="line">else</span><br><span class="line">  COVERAGE=&quot;0.0%&quot;</span><br><span class="line">  echo &quot;coverage: 0.0% of statements&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 COVERAGE 的百分号去掉，只保留数字</span></span><br><span class="line">export COVERAGE_PERCENT=$(echo &quot;$COVERAGE&quot; | sed &#x27;s/%//&#x27;)</span><br></pre></td></tr></table></figure><h3 id="用最小的维护代价提供最大价值的单元测试">2.用最小的维护代价提供最大价值的单元测试</h3><p>如何评价一个单元测试价值是否足够大呢？或者，更简单的说法是，如何评价一个单元测试写得好不好？</p><p>可以从 4 个角度进行评估：</p><ol type="1"><li>protection against regressions</li><li>resistance to refactoring</li><li>fast feedback</li><li>maintainability</li></ol><p>更具体地说：</p><h4 id="防止回归">2.1 防止回归</h4><blockquote><p>代码修改后，原有功能不受影响。</p></blockquote><p>评价指标：</p><ol type="1"><li>被测试代码执行到的业务代码数量（测试覆盖率）。</li><li>业务代码的复杂度。</li><li>业务代码的领域重要性。</li></ol><h4 id="抵抗重构">2.2 抵抗重构</h4><blockquote><p>非功能性重构，测试仍能通过，确保功能一致性。</p></blockquote><p>评价指标：</p><ol type="1"><li>越少的“假阳性”越好。</li><li>在重构代码时，引入了破坏性变更，测试代码能否快速反馈，即越少的“假阴性”越好。</li><li>测试代码是否为你重构代码提供了足够的信心。</li><li>测试代码测试的是业务代码的 observablebehavior，而不是其背后的每一个步骤。</li></ol><h4 id="快速反馈">2.3 快速反馈</h4><blockquote><p>测试代码执行时间越快，则反馈间隔越短，缺陷修复效率和质量就越高。</p></blockquote><p>评价指标：</p><ol type="1"><li>代码执行速度</li></ol><h4 id="可维护性">2.4 可维护性</h4><blockquote><p>测试代码的修改成本，可维护的测试代码更有利于适应需求变更。</p></blockquote><p>评价指标：</p><ol type="1"><li>测试代码有多难理解？</li><li>测试代码的代码行数有多少？</li><li>测试代码的执行难度有多高？即有多少的外部依赖？</li></ol><h4 id="如何权衡">2.5 如何权衡</h4><p>单元测试的价值可以通过上述 4个指标的<strong>乘积</strong>来进行估算，但现实是，这 4者，往往无法兼得。那我们如何做权衡呢？</p><p>首先回顾「为什么要写单元测试」，核心目的是为了<strong>程序逻辑正确性、使软件项目更可持续发展</strong>。所以：</p><ul><li><strong>可维护性（maintainability）</strong>是不可商量的，必须要撰写可维护的测试代码。</li><li><strong>抵抗重构（resistance torefactoring）</strong>是不可商量的，我们的测试代码应尽可能对错误的逻辑进行告警，也应避免对正确的逻辑进行误告警。</li></ul><p>所以我们能权衡的其实就是 protection againts regressions 和 fastfeedback，二者的矛盾很清晰：</p><ol type="1"><li>如果执行的代码越多，相应的效率就越低。</li><li>如果执行的代码太少，那验证的逻辑范围就越小。</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%206.png" style="zoom:33%;" /></p><p>为了权衡这二者，业界提出了“测试金字塔”的概念。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%207.png" style="zoom:33%;" /></p><ol type="1"><li>单元测试的单位更小，涉及的外部依赖也更少，更加 <strong>fastfeedback</strong>，所以在这个层次我们要撰写更多的测试，去尽可能覆盖更多的单元逻辑。</li><li>集成测试、端到端测试的逻辑覆盖范围更大，更加 <strong>resistance torefactoring</strong>，但是往往会依赖更多的组件，执行的效率也更低，所以在这2个层次，我们可以只撰写覆盖最重要（乐观）的业务路径的测试代码，在牺牲有限的执行效率的情况下，尝试更大的防止回归效果。</li></ol><h3 id="验证代码中最重要的部分">3. 验证代码中最重要的部分</h3><p>什么是代码中最重要的部分呢？我们可以将代码分成以下 4 个种类：</p><ol type="1"><li><strong>领域模型和算法（Domain Model andAlgorithms）</strong>：领域模型是对业务领域核心概念和逻辑的抽象，算法则是解决特定问题的计算步骤。两者共同构成系统的核心业务逻辑。</li><li><strong>琐碎代码（TrivialCode）</strong>：实现简单功能、无复杂逻辑的代码片段，通常为工具方法或数据转换层。</li><li><strong>控制器（Controllers）</strong>：协调业务逻辑与外部交互的中间层，常见于MVC 或分层架构中。</li><li><strong>过度复杂代码（OvercomplicatedCode）</strong>：既包含核心业务逻辑，又包含控制器逻辑。</li></ol><p>作者建议：</p><ol type="1"><li>永远为 <strong>Domain Model and Algorithms</strong>撰写全面细致的单元测试。</li><li>永远不为 <strong>Trivial Code</strong> 撰写单元测试。</li><li>为 <strong>Controllers</strong> 撰写集成测试，而不是单元测试。</li><li>避免写 <strong>Overcomplicated Code</strong>，将其拆分成<strong>Domain Model and Algorithms</strong> 和<strong>Controllers</strong> 。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2015.png" /></p><h2 id="如何让代码更容易测试">如何让代码更容易测试？</h2><p>根据不同处理架构的业务代码，可以将测试代码分成以下 3 个种类：</p><ol type="1"><li><code>output-based</code>：业务代码只产生输出结果，所以只需要<strong>验证输出</strong>。</li><li><code>state-based</code>：业务代码会修改内部状态或依赖状态，所以需要<strong>验证状态变化</strong>。</li><li><code>communication-based</code>：业务代码会跟协作方进行交互，所以需要<strong>验证交互情况</strong>。对于这种场景，我们会使用<code>mock</code> 工具来进行验证。关于 <code>mock</code>这个话题，文章后续会进行详细讨论。</li></ol><p>我们按照上述 4 个分析维度，对这 3 种测试代码进行比较：</p><table><colgroup><col style="width: 9%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 21%" /><col style="width: 19%" /></colgroup><thead><tr class="header"><th></th><th>protection againts regressions</th><th>resistance to refactoring</th><th>fast feedback</th><th>maintainability</th></tr></thead><tbody><tr class="odd"><td><strong>output-based</strong></td><td>⭐️⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️⭐️ 最好，不需要外部依赖。</td></tr><tr class="even"><td><strong>state-based</strong></td><td>⭐️⭐️⭐️</td><td>⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️ 比较差，需要外部依赖。</td></tr><tr class="odd"><td><strong>communication-based</strong></td><td>⭐️⭐️ 过度使用会导致需要到处mock，而真正执行的业务代码数量很少。</td><td>⭐️最差，因为验证交互情况，往往会陷入实现细节，很容易在重构过程中出现误警告。</td><td>⭐️⭐️ 大差不差，但是 mock 工具效率可能会相对低一点点。</td><td>⭐️ 最差，需要引入大量的 mock 工具和 mock 代码。</td></tr></tbody></table><p>所以我们应该尽可能写 <strong>output-based</strong> 测试，减少<strong>communication-based</strong> 测试。</p><p>可以采取 <code>functional architecture</code>，将代码分成 2个阶段：</p><ol type="1"><li>根据业务规则做出决定</li><li>根据决定做出行为</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2014.png" /></p><p>为此，在可能的场景下，我们可以尝试通过 2个步骤来优化我们的测试代码：</p><ol type="1"><li>使用 <code>mock</code> 来替代外部依赖<code>out-of-process dependency</code>。</li><li>使用 <code>functional architecture</code> 来替代<code>mock</code>。</li></ol><h2 id="聊一下-mock">聊一下 Mock</h2><p>在撰写单元测试的过程中，如果业务逻辑依赖的组件不好实例化的时候，我们常常会借助各种<code>Mock</code>工具来实现“模拟”功能，使单测更易撰写，这里有一个更准确的词叫<code>test doubles</code>（测试替身）。</p><h3 id="test-double-的种类">test double 的种类</h3><p>从大的方面可以分为 2 种：</p><ol type="1"><li>用于模拟和验证对象间的输出交互（如方法调用次数、参数匹配），则为<code>mock</code>。</li><li>用于模拟输入交互，提供预定义的数据，则为 <code>stub</code>。</li></ol><p>更进一步可以分为：</p><ul><li><code>mock</code><ul><li><code>mock</code>: 由 mock 工具生成。</li><li><code>spy</code>: 手工撰写。</li></ul></li><li><code>stub</code><ul><li><code>stub</code>: 可以通过配置在不同的场景下返回不同的数据。</li><li><code>dummy</code>: 占位符，仅用于填充参数，不参与实际逻辑。</li><li><code>fake</code>: 跟 <code>stub</code> 几乎一样，唯一的区别是<code>fake</code> 经常用于替代尚未开发或复杂的依赖。</li></ul></li></ul><blockquote><p>需要注意的是：永远不要去验证（assert）跟 <code>stub</code>的交互，没必要！</p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%208.png" /></p><h3 id="哪些东西需要-mock">哪些东西需要 Mock？</h3><p>在回答这个问题之前，我们先做下铺垫，聊一下接口的误解、依赖的种类和两种交互的概念。</p><h4 id="接口的误解">接口的误解</h4><p>在谈如何更好地利用 mock之前，我们先来聊一下接口（interface）的误解。</p><p>在业务开发当中，我们经常能看到一些企图进行“优雅”架构设计的代码，上来每一层都定义接口，每一层都使用接口进行交互，反正遇到问题先定义接口再说。</p><p>目的有二：</p><ol type="1"><li>抽象外部依赖，进行解耦。</li><li>可以在不修改既有代码的情况下扩展功能，即所谓的开闭原则（Open-Closedprinciple）。</li></ol><p>但这其实存在一些误区，作者在书中指出：</p><ol type="1"><li><strong>只有一个实现的接口</strong>，并不是抽象，也并没有比具体的对象起到太多所谓的解耦作用。</li><li>上述第 2 点违反了一个更重要的原则 <strong>YAGNI（You are not gonnaneed it）</strong>，也就是你所谓的功能扩展大概率是不需要的。</li><li>上述做法的唯一好处是什么：<strong>使测试成为可能！</strong>因为你不隔离掉外部依赖的话，你的单元测试撰写会非常困难，也无法做到fast feedback。</li></ol><div class="tag-plugin colorful note" color="green"><div class="title">🙋🏻‍♀️</div><div class="body"><p>抽象是发现出来的，而不是发明出来的！</p></div></div><h4 id="依赖的种类">依赖的种类</h4><ul><li><code>shared dependency</code>: 一个在测试代码中的共享对象。</li><li><code>out-of-process dependency</code>:独立于当前应用程序的另外一个进程对象，如数据库、STMP 服务器等。<ul><li><code>managed dependency</code>:仅当前应用程序可访问的依赖（对其他程序、服务是不可见的）。</li><li><code>unmanaged dependency</code>:除了当前应用，其他应用也可见。</li></ul></li><li><code>private dependency</code>: 一个私有对象。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2019.png" /></p><h4 id="两种交互">两种交互</h4><ul><li><code>intra-system communication</code>: 应用程序内部的交互。</li><li><code>inter-system communication</code>: 应用程序之间的交互。</li></ul><h4 id="哪些东西需要-mock-1">哪些东西需要 Mock？</h4><p>铺垫完接口的误解、依赖的种类和两种交互的概念之后，我们来聊一下哪些东西需要Mock？</p><p>在抉择的时候，需要牢记我们测试粒度和评价指标。</p><p>测试粒度：<strong>an observable behavior ⭐️⭐️⭐️⭐️⭐️</strong></p><p>评价指标：</p><ul><li>防止回归：protection against regressions</li><li>抵抗重构：resistance to refactoring</li><li>快速反馈：fast feedback</li><li>可维护性：maintainability</li></ul><p>集合测试粒度和评价指标，Mock 哪些东西可以用一句话来概括：</p><div class="tag-plugin colorful note" color="green"><div class="title">✅</div><div class="body"><p>Mock 那些外部可观测到的交互，而尽量避免 Mock 内部的实现细节。</p></div></div><p>更具体来说：</p><ol type="1"><li><strong>仅对 <code>unmanaged dependency</code> 应用<code>mock</code>对象。</strong>因为我们无法预知其他应用会对这些依赖进行什么操作，所以只能隔离开。</li><li><strong>对系统最外围的边界进行<code>mock</code>。</strong>只有系统边界，才是可观测行为，内部都是实现细节，对实现细节过多Mock，意味着破坏了 resistance to refactoring。</li><li><strong>尽量只在集成测试中使用 mock，避免在单元测试中使用mock。</strong></li><li><strong>只 mock 属于你的对象，不去 mock 依赖库中的对象。</strong><ul><li>始终在第三方库之上编写自己的适配器，并对这些适配器进行 mock，而不是mock底层类型。</li><li>仅从库中暴露你所需要的功能。</li><li>使用项目的领域语言（domain language）来完成上述操作。</li></ul></li></ol><p>举个例子：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2021.png" /></p><p>在上图中，右侧是我们的应用程序，它依赖了左下角的<code>Message bus</code> 这个外部依赖，准确说是<code>unmanaged dependency</code>。对此，我们为其创建了适配器接口<code>IBus</code>，在这个通用接口之上，我们又根据具体业务创建了<code>IMessageBus</code>。</p><p>针对这种情况，我们在进行 mock 的时候，只需要 mock <code>IBus</code>对象，而不是去 mock <code>Message bus</code> 和<code>IMessageBus</code>。</p><h3 id="数据库要不要-mock">数据库要不要 Mock？</h3><p>这个话题比较有意思，作者的建议是：</p><ol type="1"><li>如果这个数据库只有你这个应用可以访问，那就不要 mock。</li><li>如果这个数据库存在可以被其他应用访问的部分，那就只 mock这一部分，不去 mock 独属于你应用的那部分。</li></ol><p>要践行上述标准，需要做到以下前提：</p><ol type="1"><li>将数据库的信息也放在源码控制系统中（git），包括：<ul><li>schema</li><li>reference data（项目启动必须要的初始数据）</li><li>migration（数据变更记录）</li></ul></li><li>每个开发者有一个单独的数据库（测试环境下）</li><li>但数据库变更的时候，不要直接修改，而是要写一条对应 sql去进行修改，同时将这条 sql 也纳入源码控制系统中。</li></ol><p>作者不建议 <code>mock</code> 数据库，包括使用内存数据库替代，如sqlite 替代MySQL，核心原因是：你无法保证这些数据库能跟线上环境的行为一致，可能会导致一些无效测试用例，即假阴性。</p><p>笔者并不完全采纳这个建议，诚然，如果能做到以上前提，是可以考虑践行的。然而，它的要求很高，收益却相对较小，在单元测试环境下，使用内存数据库进行mock，在保证了 fast feedback 和 maintainability的情况下，也能够避免绝大多数的逻辑漏洞了，假阴性的情况会非常少，即便有，也可以交给集成测试和端到端测试去解决。</p><h2 id="反面案例">反面案例</h2><ol type="1"><li>测试私有方法。</li><li>暴露私有状态。</li><li>泄露领域知识到测试中。</li><li>在业务代码中撰写只用于测试的代码。</li><li>mock 具体的类。</li></ol><p>第 3 点比较有意思，比如下面这个例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Adding_two_numbers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> value1 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> value2 = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> expected = value1 + value2;   <span class="comment">// &lt;-----The leakage</span></span><br><span class="line">        <span class="comment">// int expected = 4 // the better one</span></span><br><span class="line">        <span class="built_in">int</span> actual = Calculator.Add(value1, value2);</span><br><span class="line">        Assert.Equal(expected, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么叫做泄露领域知识呢？</p><p>比如你要验证一个加法 <code>Add</code>对不对，但是在测试代码中，你的期望值也是用加法来获得的，这个“加法”就是领域知识，因为这样测的话，就很有可能会出现“<strong>负负得正</strong>”的情况。</p><p>正确的做法是<strong>直接断言你预期的最终结果</strong>，以确保逻辑符合预期。</p><h2 id="go-实践案例">Go 实践案例</h2><p>本章将分享一些笔者在 Go项目实战过程中的一些实践案例，希望对读者撰写单元测试能提供一些帮助。</p><h3 id="依赖-redis-的逻辑怎么测">依赖 Redis 的逻辑怎么测</h3><p>可以使用 <code>miniredis</code>，这是一个使用 Go 语言实现的内存版Redis。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/alicebob/miniredis" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/alicebob/miniredis" autofill="title,icon"><div class="left"><span class="title">https://github.com/alicebob/miniredis</span><span class="cap link footnote">https://github.com/alicebob/miniredis</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><p>可以封装一个函数，用于快速启动 miniredis 并返回客户端对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMiniRedis</span><span class="params">()</span></span> *redis.Client &#123;</span><br><span class="line">    <span class="keyword">var</span> redisClient *redis.Client</span><br><span class="line">    <span class="keyword">var</span> miniRedisClient *miniredis.Miniredis</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    miniRedisClient, err = miniredis.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    redisClient = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">       Addr: miniRedisClient.Addr(),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> redisClient</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里可能会出现作者提到的不要使用内存数据库替代真实的数据库，因为你无法保证它们的行为一致。</p><p>比如这里是单机的，而生产环境可能是集群的，在 Redis Cluster 中，涉及到lua 脚本和事务的所有 key，都必须保证在同一个 slot 上，在这种情况下，使用<code>miniredis</code> 是测不出问题的。</p></blockquote><h3 id="依赖-mysql-的逻辑怎么测">依赖 MySQL 的逻辑怎么测</h3><p>核心挑战：</p><ol type="1"><li>依赖真实 MySQL 则容易因为网络原因而导致测试失败（不可重复性）</li><li>依赖真实 MySQL 会严重影响单侧执行效率</li><li>数据预备</li><li>数据清洗</li><li>单测之间的数据隔离，互不影响</li><li>并发安全</li></ol><p>为了解决上述问题，提供更优雅的 MySQL 单测解决方案，笔者借助<code>dolthub/go-mysql-server</code> 和 <code>gorm</code>的能力，实现了一个 <code>go-mysql-mocker</code>，简称<code>gmm</code>。</p><p>其中：</p><ul><li><code>dolthub/go-mysql-server</code> 提供了内存 MySQL 引擎。</li><li><code>gorm</code> 提供了快速建表和插入数据的能力。</li></ul><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/go-mysql-mocker" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/go-mysql-mocker" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/go-mysql-mocker</span><span class="cap link footnote">https://github.com/hedon954/go-mysql-mocker</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><p>核心功能：</p><ol type="1"><li>内存版数据库，无网络依赖；</li><li>每个单测可单独启动一个数据库，天然做到数据隔离和清洗；</li><li>支持 struct、slice、sql stmt、sql file多种方式进行数据初始化，支持需要前置数据的业务逻辑测试。</li></ol><h3 id="随机概率逻辑怎么测">随机概率逻辑怎么测</h3><p>场景：随机抽奖</p><p>难点：随机概率的结果是不确定的，直接通过 <code>assert.Equal</code>是无法写出可稳定重复运行的单测的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AssertMapRatioEqual 检查实际计数的比例是否符合预期权重的比例</span></span><br><span class="line"><span class="comment">// actual: 实际获得的计数 map[id]count</span></span><br><span class="line"><span class="comment">// expected: 预期的权重 map[id]weight</span></span><br><span class="line"><span class="comment">// tolerance: 允许的误差范围（如 0.05 表示允许 5% 的误差）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssertMapRatioEqual</span><span class="params">(t *testing.T, actual <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int64</span>, expected <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int64</span>, tolerance <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    t.Helper()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算总数</span></span><br><span class="line">    <span class="keyword">var</span> actualTotal, expectedTotal <span class="type">int64</span></span><br><span class="line">    <span class="keyword">for</span> _, count := <span class="keyword">range</span> actual &#123;</span><br><span class="line">        actualTotal += count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, weight := <span class="keyword">range</span> expected &#123;</span><br><span class="line">        expectedTotal += weight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查每个 ID 的比例</span></span><br><span class="line">    <span class="keyword">for</span> id, expectedWeight := <span class="keyword">range</span> expected &#123;</span><br><span class="line">        actualCount, exists := actual[id]</span><br><span class="line">        <span class="keyword">if</span> !exists &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;ID %d 在实际结果中不存在&quot;</span>, id)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        expectedRatio := <span class="type">float64</span>(expectedWeight) / <span class="type">float64</span>(expectedTotal)</span><br><span class="line">        actualRatio := <span class="type">float64</span>(actualCount) / <span class="type">float64</span>(actualTotal)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> diff := math.Abs(expectedRatio - actualRatio); diff &gt; tolerance &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;ID %d 的比例不符合预期: 期望 %.3f, 实际 %.3f, 差异 %.3f, 超出允许误差 %.3f&quot;</span>,</span><br><span class="line">                id, expectedRatio, actualRatio, diff, tolerance)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有多余的 ID</span></span><br><span class="line">    <span class="keyword">for</span> id := <span class="keyword">range</span> actual &#123;</span><br><span class="line">        <span class="keyword">if</span> _, exists := expected[id]; !exists &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;实际结果中存在未预期的 ID: %d&quot;</span>, id)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLottery_randOnce</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Run(<span class="string">&quot;大量抽取应符合权重配置比例&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        gotCount := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int64</span>)</span><br><span class="line">        totalCount := <span class="type">int64</span>(<span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">int64</span>(<span class="number">0</span>); i &lt; totalCount; i++ &#123;</span><br><span class="line">            reward, err := lotteryOnce(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">            assert.Nil(t, err)</span><br><span class="line">            assert.NotNil(t, reward)</span><br><span class="line">            gotCount[reward.Id] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        expectedRatio := <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int64</span>&#123;</span><br><span class="line">            <span class="number">1</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="number">2</span>: <span class="number">20</span>,</span><br><span class="line">            <span class="number">3</span>: <span class="number">30</span>,</span><br><span class="line">            <span class="number">4</span>: <span class="number">40</span>,</span><br><span class="line">            <span class="number">5</span>: <span class="number">40</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        testutil.AssertMapRatioEqual(t, gotCount, expectedRatio, <span class="number">0.05</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="http-接口怎么测">HTTP 接口怎么测</h3><p>挑战：</p><ol type="1"><li>如何快速构建请求体并发送请求？</li><li>如何快速断言异常情况？</li><li>如何快速断言成功情况，并解析出期望的返回值？</li></ol><h4 id="构造请求">1. 构造请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速创建请求体 form 表单格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPPostRequest</span><span class="params">(path <span class="type">string</span>, data any)</span></span> *http.Request &#123;</span><br><span class="line">    req := httptest.NewRequest(<span class="string">&quot;POST&quot;</span>, path, NewHTTPBody(data))</span><br><span class="line">    req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> req</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPBody</span><span class="params">(data any)</span></span> io.Reader &#123;</span><br><span class="line">    values := url.Values&#123;&#125;</span><br><span class="line">    v := reflect.ValueOf(data)</span><br><span class="line">    t := v.Type()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v.Kind() == reflect.Ptr &#123;</span><br><span class="line">        v = v.Elem()</span><br><span class="line">        t = v.Type()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v.Kind() != reflect.Struct &#123;</span><br><span class="line">        <span class="keyword">return</span> strings.NewReader(values.Encode())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">        field := t.Field(i)</span><br><span class="line">        value := v.Field(i)</span><br><span class="line"></span><br><span class="line">        tag := field.Tag.Get(<span class="string">&quot;form&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理复杂类型（结构体、切片、map）</span></span><br><span class="line">        <span class="keyword">switch</span> value.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.Struct, reflect.Slice, reflect.Map:</span><br><span class="line">            jsonBytes, err := json.Marshal(value.Interface())</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                values.Set(tag, <span class="type">string</span>(jsonBytes))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">&quot;Error marshaling %v: %v&quot;</span>, value.Kind(), err)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 处理其他类型</span></span><br><span class="line">            values.Set(tag, fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, value.Interface()))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strings.NewReader(values.Encode())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送请求">2. 发送请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w := httptest.NewRecorder()</span><br><span class="line">sfRouterTest.ServeHTTP(w, request)</span><br></pre></td></tr></table></figure><h4 id="断言异常">3. 断言异常</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AssertRspErr 断言 http 响应异常，expectedErr 为期望的错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssertRspErr</span><span class="params">(w *httptest.ResponseRecorder, t *testing.T, expectedErr <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    assert.Equal(t, http.StatusOK, w.Code)</span><br><span class="line">    body := w.Result().Body</span><br><span class="line">    <span class="keyword">defer</span> body.Close()</span><br><span class="line">    rsp, err := FromHTTPResp[any](body)</span><br><span class="line">    assert.Nil(t, rsp)</span><br><span class="line">    assert.Equal(t, expectedErr, err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="断言正确且返回响应值">4. 断言正确且返回响应值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FromHTTPResp 从 http 响应中解析出数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromHTTPResp</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(resp io.ReadCloser)</span></span> (*T, <span class="type">error</span>) &#123;</span><br><span class="line">    body, err := io.ReadAll(resp)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = resp.Close() &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t httpResp[T]</span><br><span class="line">    err = json.Unmarshal(body, &amp;t)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.Code != <span class="number">200</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(t.Message)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;t.Data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AssertRspOk 断言 http 响应成功，并返回响应体 T</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssertRspOk</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(w *httptest.ResponseRecorder, t *testing.T)</span></span> *T &#123;</span><br><span class="line">    assert.Equal(t, http.StatusOK, w.Code)</span><br><span class="line">    body := w.Result().Body</span><br><span class="line">    <span class="keyword">defer</span> body.Close()</span><br><span class="line">    rsp, err := FromHTTPResp[T](body)</span><br><span class="line">    assert.Nil(t, err)</span><br><span class="line">    assert.NotNil(t, rsp)</span><br><span class="line">    <span class="keyword">return</span> rsp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里其实就违反了上一张反面案例中的第 3点”泄露领域知识到测试中“，因为这里接受响应的时候，还是使用的领域对象结构，所以可能会出现负负得正的情况，比如你的对象字段名就是拼写错误了，但是因为你业务逻辑和断言处都是用的一个结构，所以内部形成了循环，就负负得正了，但是真正到了客户端那，就解析失败了。</p><p>不过在这个情况下，笔者认为这个情况下的这种风险是可以接受的，远盖不住其带来的效率提升。</p></blockquote><h4 id="组合起来">5. 组合起来</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendHTTPRequest</span>[<span class="title">Rsp</span> <span class="title">any</span>]<span class="params">(t *testing.T, server HTTPServer, path <span class="type">string</span>, data any, errMsg ...<span class="type">string</span>)</span></span> *Rsp &#123;</span><br><span class="line">    req := NewHTTPPostRequest(path, data)</span><br><span class="line">    w := httptest.NewRecorder()</span><br><span class="line">    server.ServeHTTP(w, req)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(errMsg) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        AssertRspErr(w, t, errMsg[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AssertRspOk[Rsp](w, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="案例">6. 案例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_GetCollectReward</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Run(<span class="string">&quot;重复领取&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        uid := buildUserInfo(&amp;UserInfo&#123;</span><br><span class="line">            Got: <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>&#123;</span><br><span class="line">                <span class="number">1</span>: &#123;<span class="number">1</span>&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;, apiTest.svc)</span><br><span class="line">        _ = testutil.SendHTTPRequest[GetCollectRewardResp](t, routerTest,</span><br><span class="line">            <span class="string">&quot;/get_collect_reward&quot;</span>, &amp;GetCollectRewardReq&#123;</span><br><span class="line">                UID:       uid,</span><br><span class="line">                CollectID: <span class="number">1</span>,</span><br><span class="line">            &#125;, <span class="string">&quot;重复领取&quot;</span>) <span class="comment">// 错误信息</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    t.Run(<span class="string">&quot;领取成功&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">      uid := uuid.NewString()</span><br><span class="line">        rsp := testutil.SendHTTPRequest[GetCollectRewardResp](t, routerTest,</span><br><span class="line">            <span class="string">&quot;/get_collect_reward&quot;</span>, &amp;GetCollectRewardReq&#123;</span><br><span class="line">                UID:       uid,</span><br><span class="line">                CollectID: <span class="number">1</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line">        assert.NotNil(t, rsp.Reward) <span class="comment">// 正确结果</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖时间的逻辑怎么测">依赖时间的逻辑怎么测</h3><ol type="1"><li>尽量不要依赖时间。</li><li>考虑将时间作为参数，避免 <code>time.Now()</code>。</li></ol><p>也可以参考：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://hedon.top/2025/03/06/go-lib-synctest/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://hedon.top/2025/03/06/go-lib-synctest/" autofill="title,icon"><div class="left"><span class="title">https://hedon.top/2025/03/06/go-lib-synctest/</span><span class="cap link footnote">https://hedon.top/2025/03/06/go-lib-synctest/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><h3 id="并发逻辑怎么测">并发逻辑怎么测</h3><ul><li><code>go test</code> 推荐开启 <code>-race</code>用于检测并发冲突。</li></ul><p>更多可参考：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://hedon.top/2025/03/06/go-lib-synctest/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://hedon.top/2025/03/06/go-lib-synctest/" autofill="title,icon"><div class="left"><span class="title">https://hedon.top/2025/03/06/go-lib-synctest/</span><span class="cap link footnote">https://hedon.top/2025/03/06/go-lib-synctest/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div>]]></content>
    
    
    <summary type="html">本文总结了读者在阅读《Unit Testing》书籍中的收获和思考。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《Unit Testing Principles, Practices, and Patterns》</title>
    <link href="https://hedon.top/2025/04/09/note-unit-testing-excerpt/"/>
    <id>https://hedon.top/2025/04/09/note-unit-testing-excerpt/</id>
    <published>2025-04-09T04:52:14.000Z</published>
    <updated>2025-04-09T05:00:20.421Z</updated>
    
    <content type="html"><![CDATA[<p>Learning unit testing doesn’t stop at mastering the technical bits ofit, such as your favorite test framework, mocking library, and so on.There’s much more to unit testing than the act of writing tests. Youalways have to achieve the best return on the time you invest in unittesting, minimizing the effort you put into tests and maximizing thebenefits they provide. Achieving both things isn’t an easy task.</p><ul><li>They grow effortlessly, don’t require much maintenance, and canquickly adapt to their customers’ ever-changing needs.</li></ul><p>The ratio between the production code and the test code could beanywhere between <code>1:1</code> and <code>1:3</code>.</p><h1 id="coverage-limitations">Coverage limitations</h1><ul><li>You can’t guarantee that the test verifies all the possible outcomesof the system under test.</li><li>No coverage metric can take into account code paths in externallibraries.</li></ul><h1 id="the-goal-of-unit-testing">The goal of unit testing</h1><ol type="1"><li>lead to a better code design</li><li>enable sustainable(可持续的) growth of the software project</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image.png" /></p><p>the cost components of writing unit tests:</p><ol type="1"><li>refactoring the test when you refactor the underlying code</li><li>running the test on each code change</li><li>dealing with false alarms raised by the test</li><li>spending time reading the test when you’re trying to understandinghow the underlying code behaves</li></ol><p>a successful test suite must:</p><ol type="1"><li>integrated into the development cycle</li><li>targets only the most important parts of the code base<ol type="1"><li>👉🏻 domain logic</li><li>infrastructure code</li><li>external services and dependencies</li><li>code that glues everything together</li></ol></li><li>provides maximum value with minimum maintenance costs<ol type="1"><li>recognize a valuable test (and, by extension, a test of lowvalue)</li><li>write a valuable test</li></ol></li></ol><h1 id="what-is-a-unit-test">What is a unit test?</h1><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%201.png" /></p><ol type="1"><li>verifies a single unit of behavior</li><li>dose it quickly</li><li>dost it in isolation from other tests</li></ol><p>An integration test, then, is a test that doesn’t meet one of thesecriteria.</p><p>End-to-end tests are a subset of integration tests.</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%202.png" /></p><h1 id="how-to-structure-a-unit-test">How to structure a unit test?</h1><table><thead><tr class="header"><th>Type</th><th>Components</th></tr></thead><tbody><tr class="odd"><td>AAA</td><td>Arrange - Act - Assert</td></tr><tr class="even"><td>GWT</td><td>Given - When - Then</td></tr></tbody></table><ol type="1"><li>avoid multiple arrange, act, and assert sections.</li><li>avoid if statements in tests.</li><li>name the test as if you were describing the scenario to anon-programmer who is familiar with the problem domain.</li><li>separate words with underscores.</li><li>structure a test is to make it tell a story about the problemdomain</li></ol><h1 id="four-pillars-of-a-good-unit-test">Four pillars of a good unittest</h1><blockquote><p><em>code is not an asset, it’s a liability.</em></p></blockquote><ol type="1"><li><p><strong>protection against regressions</strong></p><ol type="1"><li>the amount of code that is executed during the test</li><li>the complexity of that code</li><li>the code’s domain significance</li></ol></li><li><p><strong>resistance to refactoring</strong></p><ol type="1"><li>the fewer false positives the test generates, the better</li><li>tests provides an early warning when you break exisitingfunctionality</li><li>you become confident that your code changes won’t lead toregressions</li><li>the more the test is coupled to the implementation details of thesystem under set(SUT), the more false alarms it generates</li><li>you need to make sure the test verifies the end result the SUTdelivers: its observable behavior, not the steps it takes to dothat.</li><li>the best way to structure a test is to make it tell a story aboutthe problem domain</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%203.png" /></p></li><li><p><strong>fast feedback</strong></p></li><li><p><strong>maintainability</strong></p><ol type="1"><li>how hard it is to understand the test, which is a function of thetest’s size</li><li>how hard it is to run the test, which is a function of how manyout-of-process dependencies the test works with directly</li></ol></li></ol><h2 id="the-intrinsic-connection-between-the-first-two-attributes">Theintrinsic connection between the first two attributes</h2><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%204.png" /></p><p>Type II Error:</p><ul><li>if functionality is broken, the test should fail, but if the testalso passed, means it is not a good unit test, should if it fails, meansit offers protection against regressions.</li></ul><p>Type I Error:</p><ul><li>if functionality is correct but the test fails, means that the testdose not test the nature of behavior. The good unit test should alwayspass when the functionality is correct. This would help us a lot when wetry to do refactor. If we refactor the code correctly, but the unittests always failed, means that the unit tests are not good enough, weneed to optimize them.</li></ul><h1 id="an-ideal-test">An ideal test</h1><ul><li>value = <code>[0..1] * [0..1] * [0..1] * [0..1]</code>(correspondingto the four pillars)</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%205.png" /></p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%206.png" /></p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%207.png" /></p><h2 id="black-box-and-white-box-testing">black-box and white-boxtesting</h2><ol type="1"><li>choose black-box testing over white-box testing by default.</li><li>the only exception is when the test covers utility code with highalgorithmic complexity</li><li>use code coverage tools to see which code branches are notexercised, but then turn around and test them as if you know nothingabout the code’s internal structure.</li></ol><h1 id="mock">Mock</h1><h2 id="types-of-test-doubles">types of test doubles</h2><ul><li>mock: help to emulate and examine <code>outcoming</code>interactions —— change state<ul><li>mock: generated by tools</li><li>spy: written manually</li></ul></li><li>stub: help to emulate <code>incoming</code> interactions —— getinput data<ul><li>stub: can configure to return different values for differentscenarios.</li><li>dummy: a simple, hardcoded value such as a null value or a made-upstring.</li><li>fake: the same as a stub for most purposes, only except for itscreation, it is usually implemented to replace a dependency that dosenot yet exist</li></ul></li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%208.png" /></p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%209.png" /></p><blockquote><p>never asserting interactions with stubs.</p></blockquote><h2 id="observable-behavior">Observable behavior</h2><ol type="1"><li>expose an <code>operation</code> that helps the client achieve oneof its goals. An operation is a method that performs a calculation orincurs a side effect or both.</li><li>expose a <code>state</code> that helps the client achieve one of itsgoals. State is the current condition of the system.</li></ol><blockquote><p>Whether the code is observable behavior depends on who its client isand what the goals of that client are.</p></blockquote><blockquote><p>Ideally, the system’s public API surface should coincide with itsobservable behavior, and all its implementation details should be hiddenfrom the eyes of the clients.</p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2010.png" /></p><h2 id="mocks-and-test-fragility">Mocks and test fragility</h2><ul><li><code>Intra-system</code> communications are communications betweenclasses inside your application.</li><li><code>Inter-system</code> communications are when your applicationtalks to other applications.</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2011.png" /></p><ol type="1"><li>The use of mocks is <code>beneficial</code> when verifying thecommunication pattern between your system and externalapplications.</li><li>Using mocks to verify communications between classes inside yoursystem results in tests that couple to implementation details andtherefore fall short of the <code>resistance-to-refactoring</code>metric.</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2012.png" /></p><h2 id="types-of-dependencies">Types of dependencies</h2><ul><li><code>shared dependency</code>: a dependency shared by test (notproduction code)</li><li><code>out-of-process dependency</code>: a dependency hosted by aprocess other than the program’s execution process (database, stmpserver)</li><li><code>private dependency</code>: any dependency that is notshared</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2013.png" /></p><h1 id="styles-of-unit-testing">Styles of unit testing</h1><ul><li><code>output-based</code>: only need to verify the output.</li><li><code>state-based</code>: the underlying code changes its own state,the state of its collaborators, or the state of an out-of-processdependency.</li><li><code>communication-based</code>: use mocks to verify communicationsbetween the SUT and its collaborators, to verify the communicationsituations.</li></ul><h2 id="compare">compare</h2><h3 id="protection-against-regressions">protection againstregressions</h3><ul><li>for the most part, they are not very different</li><li>but overusing the <code>communication-based</code> style can resultin shallow tests that verify only a thin slice of code and mock outeverything else.</li></ul><h3 id="fast-feedback">fast feedback</h3><ul><li>for the most part, they are not very different</li><li><code>communication-based</code> testing can be slightly worsebecause the cost of mocks.</li></ul><h3 id="resistance-to-refactoring">resistance to refactoring</h3><ul><li><code>state-based</code> is the best one.</li><li><code>communication-based</code> is the worse one, because it is themost vulnerable to false alarms.</li></ul><h3 id="maintainability">maintainability</h3><ul><li><code>output-based</code> is the best one, because they do not dealwith out-of-process dependencies.</li><li><code>state-based</code> is less maintainable because stateverification takes up more space than output verification.</li><li><code>communication-based</code> is the worst one, it requiressetting up test doubles and interaction assertions, and that takes up alot of space.</li></ul><h2 id="functional-architecture">functional architecture</h2><p><code>*Functional architecture</code>* maximizes the amount of codewritten in a purely functional (immutable) way, while minimizing codethat deals with side effects. <em>Immutable</em> means unchangeable:once an object is created, its state can’t be modified. This is incontrast to a *mutable* object (changeable object), which can bemodified after it is created.</p><p>Separate two kinds of code:</p><ul><li>code that make a decision</li><li>code that acts upon that decision</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2014.png" /></p><h2 id="tips">Tips</h2><ul><li>Moving from using an out-of-process dependency to using mocks.</li><li>Moving from using mocks to using functional architecture</li></ul><h1 id="four-kinds-of-code">Four kinds of code</h1><ul><li>Domain model and algorithms</li><li>Trivial code</li><li>Controllers</li><li>Overcomplicated code</li></ul><h2 id="tips-1">Tips</h2><ol type="1"><li>always write completed unit tests for<code>domain model the algorithms</code> code</li><li>never test <code>trivial code</code></li><li>write integration test for <code>controllers</code></li><li>do not write overcomplicated code, try to separate it into<code>domain model and algorithms</code> and<code>controllers</code></li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2015.png" /></p><h2 id="trade-off">Trade-off</h2><ul><li>domain model testability</li><li>controller simplicity</li><li>performance</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2016.png" /></p><ol type="1"><li>push all external reads and writes to the edges anyway</li><li>inject the out-of-process dependencies into the domain model</li><li><strong>split the decision-making process into more granularsteps</strong> 👈<ol type="1"><li><code>CanExecute/Execute</code> pattern</li><li>domain events</li></ol></li></ol><h2 id="canexecuteexecute-pattern">CanExecute/Execute pattern</h2><p>You can use <code>CanExecute/Execute</code> pattern to balance the<code>performance</code> and <code>testability</code> , but concedescontroller simplicity, but it is manageable in most cases.</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2017.png" /></p><h2 id="domain-events">Domain events</h2><p>Domain events help track important changes in the domain model, andthen convert those changes to calls to out-of-process dependencies. Thispattern removes the tracking responsibility from the controller.</p><ul><li>extract a <code>DomainEvent</code> base class and introduce a baseclass for all domain classes, which would contain a collection of suchevents: <code>List&lt;DomainEvent&gt; events</code></li></ul><h1 id="integration-tests">Integration tests</h1><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2018.png" /></p><ol type="1"><li>check as many of the business scenario’s edge cases as possible withunit tests</li><li>use integration tests to cover one happy path, as well as any edgecases that can’t be covered by unit tests</li><li>if there’s no one path that goes through all happy paths, writeadditional integration tests—as many as needed to capture communicationswith <strong>every</strong> external system</li><li>attempt to apply the <code>fail-fast principle</code> as a viablealternative to integration test.</li></ol><h2 id="two-types-of-out-of-process-dependencies">two types ofout-of-process dependencies</h2><ul><li><code>managed dependencies</code>: only accessible through yourapplication. it is implement details and should not be mock.</li><li><code>unmanaged dependencies</code>: you don’t have full controlover it. It is observable behavior and you should mock it.</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2019.png" /></p><h2 id="interface-misunderstand">interface misunderstand</h2><div class="tag-plugin quot"><p class="content" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e092ff.png" /><span class="text">🙋🏻‍♀️ Genuine abstractions are discovered, not invented.</span><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e0ab55.png" /></p></div><p>👉🏻 For an interface to be a genuine abstraction, it must have atlease two implemtations.</p><p>The common reasoning behind the use of interfaces is that they helpto:</p><ol type="1"><li>Abstract out-of-process dependencies, thus achieving loosecoupling.</li><li>Add new functionality without changing the existing code, thusadhering to the <code>Open-Closed principle</code></li></ol><p>Misconceptions:</p><ol type="1"><li>Interfaces with a single implementation are not abstractions anddon’t provide loose coupling any more than concrete classes thatimplement those interfaces.</li><li>The second reason violates a more foundational principle:<code>YAGNI (You are not gonna need it)</code>.</li><li>The only reason to use interfaces for out-of-process dependencies itis to <code>enable testing</code>!</li><li>Do not introduce interfaces for out-of-process dependencies unlessyou need to mock out those dependencies.</li></ol><h2 id="integration-test-best-practices">integration test bestpractices</h2><ol type="1"><li>making domain model boundaries explicit</li><li>reducing the number of layers in the application</li><li>eliminating circular dependencies</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2020.png" /></p><h2 id="maximozing-mocks-value">maximozing mock’s value</h2><ol type="1"><li><p>when mocking, always try to <strong>verify interactions withunmanaged dependencies at the very edges of your system</strong>.</p><blockquote><p>Mocking <code>IBus</code> instead of <code>IMessageBus</code>maximizes the mock’s protection against regressions.</p></blockquote><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2021.png" /></p></li><li><p>A call to an unmanaged dependency goes through several stagesbefore it leaves your application. <strong>Pick the last suchstage</strong>. It is the best way to ensure backward compatibility withexternal systems, which is the goal that mocks help youachieve.</p></li><li><p>In some cases, you can use <code>spy</code> instead of<code>mock</code> for more succinct and expressive.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Changing_email_from_corporate_to_non_corporate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> busSpy = <span class="keyword">new</span> BusSpy();</span><br><span class="line">    <span class="keyword">var</span> messageBus = <span class="keyword">new</span> MessageBus(busSpy);</span><br><span class="line">    <span class="keyword">var</span> loggerMock = <span class="keyword">new</span> Mock&lt;IDomainLogger&gt;();</span><br><span class="line">    <span class="keyword">var</span> sut = <span class="keyword">new</span> UserController(db, messageBus, loggerMock.Object);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">    busSpy.ShouldSendNumberOfMessages(<span class="number">1</span>)</span><br><span class="line">        .WithEmailChangedMessage(user.UserId, <span class="string">&quot;new@gmail.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="mocking-best-practices">mocking best practices</h2><ol type="1"><li>applying mocks to unmanaged dependencies only</li><li>verifying the interactions with those dependencies at the very edgesof your system</li><li>using mocks in integration tests only, not in unit test</li><li>always verifying the number of calls made to the mock</li><li>do not rely on production code when making assertions. Use aseparate set of literals and constants in tests.</li><li>mocking only types that you own<ol type="1"><li>always write your own adapters on top of third-party libraries andmock those adapters instead of the underlying types.</li><li>only expose features you need from the library</li><li>do that using your project’s domain language</li><li>this guideline dose not apply to in-process dependencies. There isno need to abstract in-memory or managed dependencies. Similarly,there’s no need to abstract an ORM as long as it’s used for accessing adatabase that isn’t visible to external applications.</li></ol></li></ol><h1 id="testing-the-database">Testing the database</h1><h2 id="prerequisites">prerequisites</h2><ol type="1"><li><p>keeping the database in the source control system</p><ol type="1"><li>database schemas</li><li>reference data</li></ol></li><li><p>using a separate database instance for every developer</p></li><li><p>applying the migration-based approach to database delivery</p><blockquote><p>applying every modification to the database schema (includingreference data) through migrations. Do not modify migrations once theyare committed to the source control. If a migration is incorrect, createa new migration instead of fixing the old one. Make exceptions to thisrule only when the incorrect migration can lead to data loss.</p></blockquote></li></ol><h2 id="transaction">transaction</h2><p>split the <code>Database</code> class into <code>repositories</code>and a <code>transaction</code>:</p><ul><li><code>repositories</code> are classes that enable access to andmodification of the data in the database.</li><li><code>transaction</code> is a class that either commits or rollsback data updates in full. This will be a custom class relying on theunderlying database’s transactions to provide atomicity of datamodification.</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2022.png" /></p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2023.png" /></p><h2 id="tips-2">tips</h2><ol type="1"><li>use at least three transactions or units of work in an integrationstest: one per each arrange, act and assert section.</li><li>your tests should not depend on the state of the database. Yourtests should bring that state to the required condition on theirown.</li><li>create two collections for unit and integrations, and then disabletest parallelization in the collection with the integration test.</li><li>clean up data at the beginning of a test</li><li>write the SQL script manually. It’s simpler and gives you moregranular control over the deletion process.</li><li>the best way to shorten integration is by extracting technical,non-business-related bits into private methods or helper classes.</li><li>only the most complex or important read operations should be test,disregard the rest.</li><li>do not test repositories directly, only as part of the overarchingintegration test suite.</li></ol><h1 id="unit-testing-anti-patterns">Unit testing anti-patterns</h1><blockquote><p>⚠️ Do not do the things like below!</p></blockquote><ol type="1"><li><p>unit testing private methods</p><blockquote><p>Private methods are implementation details! Just test observablebehaviors!</p></blockquote><blockquote><p><strong>If the private method is too complex to be tested as part ofthe public API that uses it, that’s an indication of a missingabstraction. Extract this abstraction into a separate class instead ofmaking the private method public.</strong></p></blockquote></li><li><p>expose private state</p></li><li><p>leaking domain knowledges to tests</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Adding_two_numbers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> value1 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> value2 = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> expected = value1 + value2;   <span class="comment">// &lt;-----The leakage</span></span><br><span class="line">        <span class="comment">// int expected = 4 // the better one</span></span><br><span class="line">        <span class="built_in">int</span> actual = Calculator.Add(value1, value2);</span><br><span class="line">        Assert.Equal(expected, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>code pollution</p><blockquote><p>Code pollution is adding production code that’s only needed fortesting.</p></blockquote></li><li><p>mocking concrete classes</p></li><li><p>working with time</p></li></ol>]]></content>
    
    
    <summary type="html">本文对《Unit Testing》的关键观点进行了梳理总结。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单元测试" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一步步推导出 MySQL 数据的底层存储结构</title>
    <link href="https://hedon.top/2025/04/08/mysql-ibd/"/>
    <id>https://hedon.top/2025/04/08/mysql-ibd/</id>
    <published>2025-04-08T04:54:13.000Z</published>
    <updated>2025-04-08T16:01:04.216Z</updated>
    
    <content type="html"><![CDATA[<p>以下均以 InnoDB 引擎为基础进行分析。假设我们现在有 3行数据，如下：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408125932725.png" /></p><p>其中：</p><ul><li><code>id</code> 是主键索引。</li><li><code>a</code> 和 <code>b</code> 都是数据字段。</li><li><code>tx_id</code> 是隐藏字段，表示事务 id，用于实现 MVCC。</li><li><code>rollback_ptr</code> 是回指针，用于 undo log。</li></ul><p>在将数据存储到文件的时候，我们会将这三行数据进行序列化，然后以二进制流的形式存储到文件中。</p><p>现在我们要解决第一个问题：</p><div class="tag-plugin quot"><h4 class="content" id="如何按照主键（id）排序？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如何按照主键（id）排序？</span><span class="empty"></span></h4></div><p>在 InnoDB 中，会在每一行的前面，加一个 <code>next_record</code>字段，用于指向比当前数据 id 大的下一条数据，我们假设一行数据占 20个字节，那么就如下图所示：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408130510505.png" /></p><p>另外，为了便于定位每一行，InnoDB 会在每一行前面再加一个字段<code>heap_no</code>，它的规则很简单，就是自增，在内部会用于定位一行记录，方便上锁等各种操作。</p><p>所以现在的存储结构如下图所示：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408130840634.png" /></p><p>现在我们来解决解决第二个问题：</p><div class="tag-plugin quot"><h4 class="content" id="如何快速定位到起点（最小）和终点（最大）？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如何快速定位到起点（最小）和终点（最大）？</span><span class="empty"></span></h4></div><p>在最前面加 2 条特殊的记录：</p><ul><li><code>PAGE_NEW_INFIMUM</code>：指向最小记录。</li><li><code>PAGE_NEW_SUPERMUM</code>：最大记录，最大的一个 id会指向它。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408130825820.png" /></p><p>第三个问题：</p><div class="tag-plugin quot"><h4 class="content" id="每次 select * from t where id = ? 都要进行 I/O 操作吗？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">每次 select * from t where id = ? 都要进行 I/O 操作吗？</span><span class="empty"></span></h4></div><p>很显然是不行的，效率太低了。这个相信绝大多数读者都知道 ，InnoDB 会以Page（默认16KB）为最小单位，一次性将数据从磁盘加载到内存中。为此，需要在最前面再加一条记录，且该记录的前三行分别为：</p><ul><li><code>page_no</code>：页号，自增，InnoDB 最多支持 32位页号，所以存储上限是 16KB * 2<sup>32</sup> = 64T。</li><li><code>prev_page</code>：指向上一页。</li><li><code>next_page</code>：指向下一页。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250409000055738.png" /></p><div class="tag-plugin quot"><h4 class="content" id="如果一个 Page 放不下呢？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如果一个 Page 放不下呢？</span><span class="empty"></span></h4></div><p>很显然，那就要进行分页，即按照 ID 的顺序进行一分为二，前者取范围<code>[a, b)</code>，后者取范围 <code>[b, c)</code>。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408131632390.png" /></p><div class="tag-plugin quot"><h4 class="content" id="如何快速定位到数据在哪个 Page 上呢？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如何快速定位到数据在哪个 Page 上呢？</span><span class="empty"></span></h4></div><p>这个时候，我们需要新创建一个 Page，专门用于管理这些数据 Page 的，这个Page 我们这里暂且称为索引 Page。</p><p>其中核心数据就是 2 个：</p><ul><li><code>min_id</code>：即当前页存储的最小主键 ID。</li><li><code>page_no</code>：页号，用于定位到 Page。</li></ul><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408131810905.png" /></p><p>这是什么呀？这其实就是 B+树！在文件层面的存储，是连续存储的，但是为了便于理解，我们可以在逻辑层面将其绘制成B+ 树的形态。如下图可以看到这其实就是一颗 B+ 树。</p><p>在主键索引树上：</p><ol type="1"><li>叶子节点存储的就是具体某一行的数据（聚簇索引）。</li><li>非叶子节点存储的是索引。</li><li>每一层的节点，都是一条有序的双向链表。</li></ol><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408132026228.png" /></p><div class="tag-plugin quot"><h4 class="content" id="如果对非主键索引 a 创建索引呢？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如果对非主键索引 a 创建索引呢？</span><span class="empty"></span></h4></div><p>因为要建索引，所以需要先对 a 进行排序，然后针对 a 建立一颗 b+树。而且由于 a是非主键索引，即辅助索引，所以叶子节点存储的是主键的值，用于回表。</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408132300926.png" /></p><div class="tag-plugin quot"><h4 class="content" id="假设 a =15 的数据非常多，一个 page 放不下呢？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">假设 a =15 的数据非常多，一个 page 放不下呢？</span><span class="empty"></span></h4></div><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408132323227.png" /></p><p>会加入主键 ID 作为二维排序来进行分裂：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408132350638.png" /></p><div class="tag-plugin quot"><h4 class="content" id="估算一下一个三层的 B+ 树可以存储多少条数据？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">估算一下一个三层的 B+ 树可以存储多少条数据？</span><span class="empty"></span></h4></div><ul><li>一个 Page 是 16KB</li><li>假设 1 个 Page 可以存放 1000 个 key</li><li>假设 1 个 Page 可以存放 200 条记录</li></ul><p>基于这种估算：</p><ul><li>第 1 层：1 个节点是 1 个 Page，存放 1000 个 key，对应 1000个分叉</li><li>第 2 层：1000 个节点 1000 个 Page，存放 1000*1000 个 Key，对应1000*1000 个分叉</li><li>第 3 层：1000*1000 个 Page，每个 Page 200 条数据，共 1000*1000*200=2亿条数据 = 16KB*1000*1000=16GB</li></ul><p>🐂🐂🐂</p>]]></content>
    
    
    <summary type="html">本文从最简单的数据格式开始，通过不断解决一个个关键问题，最终推导出 MySQL 数据的底层存储结构，即 B+ 树。</summary>
    
    
    
    <category term="数据库" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mysql" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
    <category term="mysql" scheme="https://hedon.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Python 知识图谱</title>
    <link href="https://hedon.top/2025/04/05/python-mindmap/"/>
    <id>https://hedon.top/2025/04/05/python-mindmap/</id>
    <published>2025-04-05T12:00:24.000Z</published>
    <updated>2025-04-08T04:54:07.126Z</updated>
    
    <content type="html"><![CDATA[<figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/2cfc18adf51b61ca8140561071d20c1d.png"alt="python-mindmap" /><figcaption aria-hidden="true">python-mindmap</figcaption></figure>]]></content>
    
    
    <summary type="html">本文梳理了 Python 的知识。</summary>
    
    
    
    <category term="python" scheme="https://hedon.top/categories/python/"/>
    
    <category term="mindmap" scheme="https://hedon.top/categories/python/mindmap/"/>
    
    
    <category term="python" scheme="https://hedon.top/tags/python/"/>
    
    <category term="mindmap" scheme="https://hedon.top/tags/mindmap/"/>
    
  </entry>
  
  <entry>
    <title>后端开发之路</title>
    <link href="https://hedon.top/2025/03/17/backend-road/"/>
    <id>https://hedon.top/2025/03/17/backend-road/</id>
    <published>2025-03-17T12:00:24.000Z</published>
    <updated>2025-03-17T12:43:04.569Z</updated>
    
    <content type="html"><![CDATA[<style>svg.markmap {        width: 100%;        height: 100vh;      }</style><div class="markmap" id="markmap-83b52cb2-6f49-4a38-8af4-f6085575e699">  <script type="text/template">- 后端开发之路  - 基础知识    - 计算机基础    - 网络基础    - 数据库基础    - 操作系统基础    - 编程语言基础  - 编程语言    - Java    - Python    - Node.js    - Go    - PHP    - Ruby    - C#    - C++    - C    - JavaScript    - TypeScript    - Kotlin    - Swift  - 框架    - Spring Boot    - Django    - Flask    - Express    - Koa    - Nest.js  - 数据库    - MySQL    - PostgreSQL    - MongoDB    - Redis    - SQLite    - Oracle  - 中间件    - Nginx    - Apache    - Tomcat    - Jetty    - Undertow  - 设计模式    - 单例模式    - 工厂模式    - 观察者模式    - 策略模式    - 装饰器模式    - 适配器模式    - 门面模式  - 架构模式    - 微服务架构    - 事件驱动架构    - 发布订阅架构    - 流式处理架构    - 服务网格架构  - 性能优化    - 代码优化    - 数据库优化    - 缓存优化    - 异步编程    - 并发编程    - 多线程编程    - 分布式编程    - 高可用性设计  </script></div>  ]]></content>
    
    
    <summary type="html">本文介绍了后端开发的成长道路</summary>
    
    
    
    <category term="roadmap" scheme="https://hedon.top/categories/roadmap/"/>
    
    
    <category term="roadmap" scheme="https://hedon.top/tags/roadmap/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 博客中优雅地集成 Markmap 思维导图</title>
    <link href="https://hedon.top/2025/03/17/mindmap-for-hexo/"/>
    <id>https://hedon.top/2025/03/17/mindmap-for-hexo/</id>
    <published>2025-03-17T10:21:18.000Z</published>
    <updated>2025-03-17T11:57:48.209Z</updated>
    
    <content type="html"><![CDATA[<p>在技术博客写作中，思维导图是一个非常有用的工具，它可以帮助我们更清晰地展示知识结构和概念关系。本文将介绍如何在Hexo 博客中集成 Markmap，让你能够直接在 Markdown文件中创建交互式思维导图。</p><h2 id="什么是-markmap">什么是 Markmap？</h2><p>Markmap 是一个将 Markdown格式的文本转换为思维导图的开源工具。它允许我们使用熟悉的 Markdown语法来创建漂亮的、交互式的思维导图。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://markmap.js.org/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://markmap.js.org/" autofill="title,icon"><div class="left"><span class="title">https://markmap.js.org/</span><span class="cap link footnote">https://markmap.js.org/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><h2 id="实现方案">实现方案</h2><h3 id="安装必要依赖">1. 安装必要依赖</h3><p>首先，我们需要安装 <code>uuid</code>包，这是用来给我们每一个思维导图生成一个唯一的 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uuid --save</span><br></pre></td></tr></table></figure><h3 id="创建自定义标签插件">2. 创建自定义标签插件</h3><p>在 <code>scripts/markmap_tag.js</code> 中创建自定义标签：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Markmap Tag Plugin for Hexo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">v4</span>: uuidv4 &#125; = <span class="built_in">require</span>(<span class="string">&quot;uuid&quot;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(</span><br><span class="line">  <span class="string">&quot;markmap&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">args, content</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">uuidv4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div class=&quot;markmap&quot; id=&quot;markmap-<span class="subst">$&#123;id&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;script type=&quot;text/template&quot;&gt;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;content&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123;</span></span><br><span class="line"><span class="string">  const template = document.querySelector(&#x27;#markmap-<span class="subst">$&#123;id&#125;</span> script[type=&quot;text/template&quot;]&#x27;);</span></span><br><span class="line"><span class="string">  if (template) &#123;</span></span><br><span class="line"><span class="string">    const content = template.textContent;</span></span><br><span class="line"><span class="string">    window.markmap.autoLoader.renderString(content, null, document.querySelector(&#x27;#markmap-<span class="subst">$&#123;id&#125;</span>&#x27;));</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">ends</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="添加样式">3. 添加样式</h3><p>创建 <code>source/css/markmap.css</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Markmap Styles */</span></span><br><span class="line"><span class="selector-class">.markmap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eaeaea</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.markmap</span> svg &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 响应式设计 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.markmap</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">480px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.markmap</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新主题配置">4. 更新主题配置</h3><p>在主题配置文件中添加必要的资源引用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/markmap.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/npm/markmap-autoloader@0.18&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用方法">使用方法</h2><div class="tag-plugin tabs" align="center"id="tab_1"><div class="nav-tabs"><div class="tab active"><a href="#tab_1-1">代码块</a></div><div class="tab"><a href="#tab_1-2">效果</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_1-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% markmap %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 技术栈</span><br><span class="line"><span class="bullet">  -</span> 前端</span><br><span class="line"><span class="bullet">    -</span> Vue.js</span><br><span class="line"><span class="bullet">    -</span> React</span><br><span class="line"><span class="bullet">    -</span> Angular</span><br><span class="line"><span class="bullet">  -</span> 后端</span><br><span class="line"><span class="bullet">    -</span> Node.js</span><br><span class="line"><span class="bullet">    -</span> Python</span><br><span class="line"><span class="bullet">    -</span> Go</span><br><span class="line"><span class="bullet">  -</span> 数据库</span><br><span class="line"><span class="bullet">    -</span> MySQL</span><br><span class="line"><span class="bullet">    -</span> MongoDB</span><br><span class="line"><span class="bullet">    -</span> Redis</span><br><span class="line"></span><br><span class="line">&#123;% endmarkmap %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab_1-2"><style>svg.markmap {        width: 100%;        height: 500px;      }</style><div id="markmap-1933a41b-a792-4db8-a49c-51e7402847a4" class="markmap"><script type="text/template">- 技术栈  - 前端    - Vue.js    - React    - Angular  - 后端    - Node.js    - Python    - Go  - 数据库    - MySQL    - MongoDB    - Redis  </script></div></div></div></div><h2 id="工作原理">工作原理</h2><h3 id="hexo-插件系统">1. Hexo 插件系统</h3><ul><li>Hexo 提供了强大的插件系统，允许我们通过 <code>hexo.extend</code> API来扩展功能</li><li>我们使用了 <code>hexo.extend.tag</code> 来注册自定义标签，这是 Hexo提供的标准扩展点之一</li></ul><h3 id="标签插件的工作原理">2. 标签插件的工作原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(</span><br><span class="line">  <span class="string">&quot;markmap&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">args, content</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">uuidv4</span>(); <span class="comment">// 生成唯一ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;markmap&quot; id=&quot;markmap-<span class="subst">$&#123;id&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;script type=&quot;text/template&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;content&#125;</span></span></span><br><span class="line"><span class="string">      &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">ends</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>当 Hexo 解析到 <code>markmap</code>标签时，会调用这个注册的函数</li><li><code>content</code> 参数包含了标签之间的所有内容（你的 markdown结构）</li><li><code>&#123;ends: true&#125;</code> 表示这是一个闭合标签（需要 endmarkmap结束）</li></ul><h3 id="markmap-库的渲染过程">3. Markmap 库的渲染过程</h3><ul><li>Markmap 库使用 <code>markmap-autoloader</code> 自动处理 markdown到思维导图的转换</li><li>转换过程：<ol type="1"><li>Markdown 文本被解析成层级结构</li><li>层级结构被转换为 SVG 路径</li><li>SVG 被渲染到页面上，并添加交互功能</li></ol></li></ul><h3 id="html-结构设计">4. HTML 结构设计</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;markmap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;markmap-$&#123;id&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/template&quot;</span>&gt;</span></span><br><span class="line">    $&#123;content&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>script type="text/template"</code> 来存储原始markdown</li><li>每个思维导图都有唯一 ID，避免页面上多个图表互相干扰</li></ul><h3 id="javascript-初始化">5. JavaScript 初始化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> template = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(</span><br><span class="line">    <span class="string">&#x27;#markmap-$&#123;id&#125; script[type=&quot;text/template&quot;]&#x27;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (template) &#123;</span><br><span class="line">    <span class="keyword">const</span> content = template.<span class="property">textContent</span>;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">markmap</span>.<span class="property">autoLoader</span>.<span class="title function_">renderString</span>(</span><br><span class="line">      content,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#markmap-$&#123;id&#125;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>等待页面加载完成</li><li>获取模板中的 markdown 内容</li><li>使用 markmap 库渲染思维导图</li></ul><h3 id="样式控制">6. 样式控制</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.markmap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eaeaea</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>提供响应式布局</li><li>确保思维导图在各种屏幕尺寸下都能正常显示</li></ul><h3 id="主题集成">7. 主题集成</h3><ul><li>在主题配置中注入必要的 CSS 和 JavaScript</li><li>确保资源在正确的时机加载</li></ul>]]></content>
    
    
    <summary type="html">本文详细介绍了如何在 Hexo 博客中优雅地集成 Markmap 思维导图，让你能够直接在 Markdown 文件中创建交互式思维导图。同时这也是一个 Hexo 插件的标准实现案例。</summary>
    
    
    
    <category term="小技术" scheme="https://hedon.top/categories/%E5%B0%8F%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="hexo" scheme="https://hedon.top/tags/hexo/"/>
    
    <category term="markmap" scheme="https://hedon.top/tags/markmap/"/>
    
  </entry>
  
  <entry>
    <title>为什么 OpenTelemetry 的 SDK 中不支持尾采样 Hook？</title>
    <link href="https://hedon.top/2025/03/13/opentelemetry-tail-sampler/"/>
    <id>https://hedon.top/2025/03/13/opentelemetry-tail-sampler/</id>
    <published>2025-03-13T07:10:27.000Z</published>
    <updated>2025-03-17T10:19:07.413Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式追踪系统中，采样策略直接影响着系统的性能和可观测性。OpenTelemetry作为当前最流行的可观测性框架，其采样机制设计有着深刻的考量。本文将深入探讨OpenTelemetry 的采样机制，特别是为什么它在 SDK 层面不支持尾采样。</p><h2 id="前置采样-vs-尾采样">前置采样 vs 尾采样</h2><p>在讨论 OpenTelemetry的采样机制前，我们需要理解两种主要的采样策略：</p><p><strong>前置采样（Head-based Sampling）</strong>：</p><ul><li>在链路开始时就决定是否采样</li><li>决策一旦做出，整个链路都遵循这个决策</li><li>不需要缓存完整的链路数据</li></ul><p><strong>尾采样（Tail-based Sampling）</strong>：</p><ul><li>在链路结束后决定是否保留</li><li>可以基于完整链路信息（如总耗时、是否有错误）做决策</li><li>需要临时缓存所有链路数据</li></ul><h2 id="opentelemetry-的采样实现">OpenTelemetry 的采样实现</h2><p>通过分析 <ahref="https://github.com/open-telemetry/opentelemetry-go/blob/v1.35.0/sdk/trace/tracer.go#L65">OpenTelemetryGo SDK的源码</a>，我们可以清晰地看到它采用的是前置采样策略。关键代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tr *tracer)</span></span> newSpan(ctx context.Context, name <span class="type">string</span>, config *trace.SpanConfig) trace.Span &#123;</span><br><span class="line">    <span class="comment">// ... 前面的代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行采样决策</span></span><br><span class="line">    samplingResult := tr.provider.sampler.ShouldSample(SamplingParameters&#123;</span><br><span class="line">        ParentContext: ctx,</span><br><span class="line">        TraceID:       tid,</span><br><span class="line">        Name:          name,</span><br><span class="line">        Kind:          config.SpanKind(),</span><br><span class="line">        Attributes:    config.Attributes(),</span><br><span class="line">        Links:         config.Links(),</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置采样标志</span></span><br><span class="line">    <span class="keyword">if</span> isSampled(samplingResult) &#123;</span><br><span class="line">        scc.TraceFlags = psc.TraceFlags() | trace.FlagsSampled</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scc.TraceFlags = psc.TraceFlags() &amp;^ trace.FlagsSampled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 后面的代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码揭示了几个关键点：</p><ol type="1"><li>采样决策在 span 创建时就已经做出</li><li>采样标志通过位操作设置在 TraceFlags 中</li><li>这个标志会随着 SpanContext 传播到整个分布式系统</li></ol><h2 id="采样标志的传播机制">采样标志的传播机制</h2><p>特别值得注意的是设置采样标志的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> isSampled(samplingResult) &#123;</span><br><span class="line">    scc.TraceFlags = psc.TraceFlags() | trace.FlagsSampled</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scc.TraceFlags = psc.TraceFlags() &amp;^ trace.FlagsSampled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用位操作来设置或清除采样标志：</p><ul><li><code>|</code> 操作用于设置采样标志，保留其他标志位不变</li><li><code>&amp;^</code>操作用于清除采样标志，同样保留其他标志位不变</li></ul><p>这确保了采样决策能够一致地传播到整个分布式链路中。</p><h2 id="为什么-opentelemetry-不支持尾采样">为什么 OpenTelemetry不支持尾采样？</h2><p>最重要的原因是：<font color="red">在 SDK中找不到尾巴！因为不知道链路什么时候结束！</font></p><p>在分布式系统中，一条链路可能跨越多个服务，所以你在某一个服务中，是不知道链路是否结束的，而OpenTelemetry 也不是一次性上报一整条链路，而是每个 <code>span</code>独立上报，最后再拼接到一起。</p><h3 id="opentelemetry-上报原理">OpenTelemetry 上报原理</h3><ol type="1"><li><p>独立上报</p><ul><li><p>每个 <code>span</code> 在结束时（调用<code>span.End()</code>）会被传递给 <code>SpanProcessor</code></p></li><li><p><code>SpanProcessor</code> 决定如何处理这个<code>span</code>（立即导出或批量导出）</p></li><li><p>导出是独立的，不会等待整个 <code>trace</code> 完成</p></li></ul></li><li><p>批处理机制</p><ul><li><p>默认使用 <code>BatchSpanProcessor</code>，它会收集一定数量的<code>spans</code> 或等待一定时间然后批量导出</p></li><li><p>但这个批处理与 <code>trace</code>完整性无关，只是为了效率</p></li></ul></li></ol><h3 id="collector-如何实现尾采样">Collector 如何实现尾采样</h3><p>Collector 通过以下方式解决这些问题：</p><ol type="1"><li><p>设置等待时间窗口</p><ul><li><p>为每个 trace 设置一个等待期（如 10 秒）</p></li><li><p>在此期间收集该 trace 的所有 spans</p></li><li><p><strong>超过等待期后，基于已收集的 spans 做决策</strong></p></li></ul></li><li><p>集中式收集</p><ul><li><p>所有服务的 spans 都发送到 Collector</p></li><li><p>Collector 有更全面的视图来关联 spans</p></li></ul></li><li><p>专门的资源分配：Collector作为独立组件，有专门的资源处理这种复杂逻辑，不会影响应用性能。</p></li></ol><h2 id="如何在-opentelemetry-生态中实现尾采样">如何在 OpenTelemetry生态中实现尾采样？</h2><p>虽然 SDK 不直接支持尾采样，但 OpenTelemetry生态提供了其他方式实现类似功能：</p><h3 id="使用-opentelemetry-collector">1. 使用 OpenTelemetryCollector</h3><p>Collector 提供了 Tail SamplingProcessor，可以在数据聚合层实现尾采样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">tail_sampling:</span></span><br><span class="line">    <span class="attr">decision_wait:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">num_traces:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">expected_new_traces_per_sec:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">policies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">error-policy</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">status_code</span></span><br><span class="line">        <span class="attr">status_code:</span> <span class="string">ERROR</span></span><br></pre></td></tr></table></figure><h3 id="结合前置采样和错误捕获">2. 结合前置采样和错误捕获</h3><p>可以实现一个智能的前置采样器，对特定场景（如包含错误属性）强制采样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SmartSampler <span class="keyword">struct</span> &#123;</span><br><span class="line">    baseSamplingRate <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartSampler)</span></span> ShouldSample(p trace.SamplingParameters) trace.SamplingResult &#123;</span><br><span class="line">    <span class="comment">// 错误请求必采样</span></span><br><span class="line">    <span class="keyword">for</span> _, attr := <span class="keyword">range</span> p.Attributes &#123;</span><br><span class="line">        <span class="keyword">if</span> attr.Key == <span class="string">&quot;error&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> trace.SamplingResult&#123;Decision: trace.RecordAndSample&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他请求使用基础采样率</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">float64</span>(p.TraceID[<span class="number">0</span>])/<span class="number">255.0</span> &lt; s.baseSamplingRate &#123;</span><br><span class="line">        <span class="keyword">return</span> trace.SamplingResult&#123;Decision: trace.RecordAndSample&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> trace.SamplingResult&#123;Decision: trace.Drop&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用专门的后端系统">3. 使用专门的后端系统</h3><p>一些专门的可观测性后端系统提供了尾采样功能：</p><ul><li><p>Jaeger 的 Adaptive Sampling</p></li><li><p>SkyWalking 的 Trace Sampling</p></li><li><p>Grafana Tempo 的 Trace Sampling</p></li></ul><h2 id="结论">结论</h2><p>OpenTelemetry SDK采用前置采样而非尾采样，是基于分布式系统一致性、性能优化和架构分层等多方面考虑的结果。虽然这意味着无法基于完整链路信息做采样决策，但OpenTelemetry 生态提供了多种方式来弥补这一限制。</p><p>在实际应用中，我们可以：</p><ol type="1"><li>在 SDK 层使用智能前置采样策略，确保关键链路被采样</li><li>在 Collector 层实现尾采样，进一步筛选有价值的链路</li><li>结合使用多种采样策略，平衡性能和可观测性</li></ol><p>通过这种分层设计，OpenTelemetry既保证了高效的数据收集，又为高级采样策略提供了可能性，满足了不同场景的需求。</p><div class="tag-plugin quot"><h2 class="content" id="实战案例" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">实战案例</span><span class="empty"></span></h2></div><p>笔者实现一个 Go 语言的开源项目 <code>goapm</code>，对多个 Go语言中常用的组件进行了 trace、log 和 metrics 的集成封装，用于快速在 Go语言项目中实现可观测性，同时还提供了 <code>goapm-example</code>实战案例，可供参考。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/goapm" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/goapm" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/goapm</span><span class="cap link footnote">https://github.com/hedon954/goapm</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/goapm-example" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/goapm-example" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/goapm-example</span><span class="cap link footnote">https://github.com/hedon954/goapm-example</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div>]]></content>
    
    
    <summary type="html">本文介绍了 OpenTelemetry 的采样机制，特别是为什么它在 SDK 层面不支持尾采样。</summary>
    
    
    
    <category term="服务监控" scheme="https://hedon.top/categories/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
    
    <category term="opentelemetry" scheme="https://hedon.top/tags/opentelemetry/"/>
    
    <category term="服务监控" scheme="https://hedon.top/tags/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《悟道领域驱动设计》</title>
    <link href="https://hedon.top/2025/03/11/note-ddd-awareness/"/>
    <id>https://hedon.top/2025/03/11/note-ddd-awareness/</id>
    <published>2025-03-11T06:45:32.000Z</published>
    <updated>2025-03-12T11:15:35.890Z</updated>
    
    <content type="html"><![CDATA[<div class="tag-plugin quot"><h2 class="content" id="思维转变" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">思维转变</span><span class="empty"></span></h2></div><p>领域驱动设计（Domain-Driven Design，以下简称DDD）的核心价值在于其对「业务领域」的深度聚焦。这里的「领域」并非单纯的技术范畴，而是指代软件系统所要映射的现实业务场景及其核心价值主张。DDD通过建立与业务高度契合的领域模型，使得技术实现与业务本质形成同频共振，从而有效解决复杂业务场景下的认知鸿沟问题。</p><p>在 VUCA（Volatile 易变性、Uncertain 不确定性、Complex复杂性、Ambiguous模糊性）特征愈发显著的现代商业环境中，任何架构设计都面临固有局限。这种局限性既源于业务需求本身的动态演进，也受制于人类认知的有限性——正如Eric Evans在开山之作中强调的“<strong>模型永远是对现实的近似抽象</strong>”。但正是这种局限性，凸显了DDD 方法论的战略意义：</p><div class="tag-plugin colorful note" color="blue"><div class="body"><p>它通过"战略设计"构建业务全景图，运用限界上下文划定领域边界，通过"战术设计"落地聚合根、实体/值对象等模式，形成应对复杂性的结构化解决方案。</p></div></div><p>需要特别指出的是，DDD的复杂性并非方法论本身的缺陷，而是其应对现实业务复杂度的必要代价。这种复杂性体现在三个维度：</p><ol type="1"><li><strong>认知复杂性</strong>：要求开发团队与领域专家共建"通用语言"，实现业务概念与代码模型的精准映射。</li><li><strong>架构复杂性</strong>：通过分层架构实现业务逻辑与技术实现的解耦，采用防腐层处理系统集成问题。</li><li><strong>演进复杂性</strong>：借助子域划分和上下文映射，为持续演进的业务提供可扩展的架构基础。</li></ol><p>对于实践者而言，DDD 的价值不在于提供完美无缺的终极方案，而是为 VUCA环境下的系统建设提供基础性指引。其核心思想——无论是通过限界上下文实现的领域自治，还是通过聚合根维护的业务一致性——都为控制软件熵增提供了可落地的模式库。即便不完全采用DDD完整体系，其领域建模思想、分层架构理念等核心要素，仍能显著提升复杂系统的可维护性和演进能力。这种开放包容的哲学，恰是DDD 历经二十年仍保持生命力的关键所在。</p><h3 id="贫血模型-vs.-充血模型">贫血模型 vs. 充血模型</h3><ul><li>贫血模型：指的是只有属性而没有行为的模型。</li><li>充血模型：指的是既有属性又有行为的模型。</li></ul><p>笔者过往的实践中，基本上都使用类似于<code>controller→service→repository[model]</code> 的三层架构：</p><ul><li><code>conrtoller</code> 负责暴露对外接口。</li><li><code>service</code> 负责执行所有的业务逻辑。</li><li><code>repository</code> 复杂数据的存储和缓存，包含数据对象<code>model</code> 的定义。</li></ul><p>在这个模式下，基本上所有的核心逻辑都充斥在 <code>service</code>层中，所以 <code>service</code>层一般都会非常大，它要扮演多面手，即要负责跟各个模块协作，还要负责处理具体的业务规则，最终完成一个业务行为。这个过程中，<code>model</code>即为贫血模型，因为逻辑都给 <code>service</code>处理了，这种架构也称为<strong>贫血三层架构</strong>。</p><p>在 DDD的理念下，很多的核心业务概念都会被建模为「领域对象」，这些「领域对象」本身就是一种业务规则的体现，所以把业务的处理逻辑，都归属到这些「领域对象」的行为当中了，即所谓的充血模型。</p><p>在这个理念下，一个优化后的<strong>充血四层架构</strong>如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250311152623058.png"alt="充血四层架构" /><figcaption aria-hidden="true">充血四层架构</figcaption></figure><p>贫血模型推荐场景：业务简单、迭代快速、团队技术栈偏传统（如 SpringBoot+MyBatis）时，避免过度设计。</p><p>充血模型推荐场景：业务复杂、需长期演进（如核心交易系统）、团队具备DDD 经验时，通过实体、值对象、领域服务等战术设计理念降低系统熵增。</p><p>混合使用的场景：部分核心领域用充血模型（如订单、支付），非核心模块用贫血模型（如日志、配置），平衡效率与质量。</p><p>实际上，充血模型因其状态完整，适合进行<strong>状态变更类</strong>的操作，以确保业务操作符合领域规则；贫血模型由于其轻量级，更适合作为不会涉及状态变更的操作的数据容器。这其实就是CQRS 的理念。</p><div class="tag-plugin quot"><h2 class="content" id="概念清单" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">概念清单</span><span class="empty"></span></h2></div><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/ddd.jpg" /></p><h3 id="战术设计">战术设计</h3><details class="tag-plugin colorful folding" ><summary><p>实体</p></summary><div class="body"><p><strong>定义</strong>：会随着业务变化发生变化的业务概念叫作实体对象。</p><p><strong>关键点</strong>：实体需要唯一表示</p></div></details><details class="tag-plugin colorful folding" ><summary><p>值对象</p></summary><div class="body"><p><strong>定义</strong>：一些对象在表达业务概念时是必须的，可业务并不围绕着它们进行，它们仅是对这些重要业务概念的描述，这一类对象叫作值对象。</p><p><strong>关键点</strong>：</p><ol type="1"><li>值对象的意义取决于属性，只要对象的属性一模一样，那么对象就是相同的。</li><li>尽量把值对象实现为不可变对象。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>领域服务</p></summary><div class="body"><p><strong>定义</strong>：领域服务自身是没有数据的，只是表达了某种业务计算逻辑，或者业务的某种策略。</p><p><strong>关键点</strong>：</p><ol type="1"><li>领域服务是无状态的。</li><li>只有在确实表达了一个相对独立的业务概念或者业务策略，并且不能简单地把它归结到某个既有的业务对象上时，才是一个真正的领域服务。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>领域事件</p></summary><div class="body"><p><strong>定义</strong>：领域事件代表从业务专家视角看到的某种重要的事情发生了。</p><p><strong>关键点</strong>：</p><ol type="1"><li>领域事件是一种特殊的值对象。</li><li>应该根据限界上下文中的通用语言来命名事件：AccountActivited。</li><li>应该将事件建模成值对象或贫血对象。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>聚合</p></summary><div class="body"><p><strong>定义</strong>：聚合从本质上讲是在基础的构造块上增加了一层边界，用边界把那些紧密相关的对象放到了一起。</p><p><strong>关键点</strong>：</p><ol type="1"><li>紧密相关的对象存在数据一致性问题；</li><li>缺乏边界时，维护数据一致性是困难的；</li><li>划分边界的关键在于既不要让整个系统成为一个整体，又让每个单独划分出的聚合具有明确的业务意义；</li><li>聚合需要关注三条法则：<ol type="1"><li>生命周期一致性：如果一个对象在聚合根消失之后仍然有意义，那么说明此时在系统中必然存在能够访问该对象的方法。这和聚合的定义矛盾，所以聚合内的其他元素必然在聚合根消失后失效。</li><li>问题域一致性：不属于同一个问题域的对象，不应该出现在同一个聚合中。</li><li>尽量小的聚合：聚合的本质作用是提升对象系统的粒度，确保一致性、降低复杂度。不过，粒度绝不是越大越好。如果聚合的粒度太大，那内部的逻辑复杂度也会大大增加还会影响到复用度。因此，要能够比较容易地断开聚合。</li></ol></li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>资源库</p></summary><div class="body"><p><strong>定义</strong>：对于查询、创建、修改、删除数据的操作，领域模型使用“资源库(Repository)”这个概念来承载它们。</p><p><strong>关键点</strong>：一个聚合对应一个资源库，应以聚合根命名资源库，除了聚合根之外的其他对象，都不应该提供资源库对象。</p></div></details><details class="tag-plugin colorful folding" ><summary><p>工厂</p></summary><div class="body"><p><strong>定义</strong>：工厂用于构建聚合。</p><p><strong>关键点</strong>：一个聚合往往包含多个对象，这些对象的数据之间又可能存在联系，如果允许分别创建这些对象，就会让聚合是业务完整性的单元这个定义面临失败。</p></div></details><h3 id="战略设计">战略设计</h3><details class="tag-plugin colorful folding" ><summary><p>统一语言</p></summary><div class="body"><p><strong>定义</strong>：与业务专家协作定义全团队通用的术语表，消除沟通歧义。</p><p><strong>关键点</strong>：</p><ol type="1"><li>同一个概念在不同的上下文中可能存在不同的含义；</li><li>同一个概念在同一上下文中的不同环节，也可能存在不同的含义，需要非常明确清晰的界定，降低沟通成本。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>子域</p></summary><div class="body"><p><strong>定义</strong>：子域是对业务领域的逻辑划分，用于分解复杂问题。通常分为<strong>核心子域</strong>（业务核心竞争力）、<strong>支撑子域</strong>（辅助核心业务）和<strong>通用子域</strong>（可复用的标准化能力）。</p><p><strong>关键点</strong>：因业务目标、团队定位和组织发展阶段等方面的不同，这三个子域的划分并非一成不变，而是会互相转换。</p></div></details><details class="tag-plugin colorful folding" ><summary><p>限界上下文</p></summary><div class="body"><p><strong>定义</strong>：限界上下文本质上是一个自治的小世界，它有完备的职责，还有清晰的边界。</p><p><strong>关键点</strong>：</p><ol type="1"><li>一个子域的一切资产，包括领域模型、数据库、包、可执行程序、接口声明等，都应该封装在限界上下文中，避免跨越边界。</li><li>如何平衡边界的价值和不利影响，是划分边界时要做的一种重要取舍。<strong>一个较为稳妥的策略是考虑认知的渐进特征，不要过早隔离。在已经确定的边界上进行划分，延缓划分那些尚具模糊性的边界，在这些边界逐渐变得清晰时再分离它们。</strong></li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>上下文映射</p></summary><div class="body"><p><strong>定义</strong>：限界上下文约定了基于领域模型的架构层次的设计分解，而分解必然意味着集成和协作。上下文映射就是对限界上下文之间的协作关系的模式总结。</p><p><strong>关键点</strong>：</p><ol type="1"><li>在边界上完成概念映射是一种基本模式。通过在应用层组装或者使用适配器完成概念映射，可以保持领域概念的清晰，避免领域模型遭到不必要的污染。</li><li>防腐层模式、标准开放服务模式、客户-供应商模式、追随者模式。</li></ol></div></details><h3 id="串讲">串讲</h3><p>在应对复杂业务系统时，DDD通过<strong>分治策略</strong>将业务领域拆分为多个<strong>子域</strong>（如电商系统的订单、支付子域），每个子域对应一个<strong>限界上下文</strong>——这是技术与业务对齐的关键边界，既承载领域模型的实现，也通过<strong>上下文映射</strong>（如防腐层、共享内核等模式）实现跨子域协作，避免模型污染。</p><p>限界上下文内的<strong>领域对象</strong>是业务逻辑的载体：具备唯一标识和生命周期的<strong>实体</strong>（如订单实体通过ID跟踪状态变化）、描述特征且不可变的<strong>值对象</strong>（如地址由省市构成，修改需整体替换），以及通过<strong>聚合根</strong>统一操作保证一致性的<strong>聚合</strong>（如订单聚合根管理订单项和配送信息）。当业务逻辑跨越多个聚合时，由无状态的<strong>领域服务</strong>协调（如支付计算需整合订单、账户聚合）。</p><p>对象的创建与持久化分别由<strong>工厂</strong>（封装复杂初始化逻辑）和<strong>资源库</strong>（隔离存储细节）负责，而<strong>领域事件</strong>（如订单支付成功事件）则驱动跨上下文的异步协作。</p><div class="tag-plugin quot"><h2 class="content" id="战术设计" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">战术设计</span><span class="empty"></span></h2></div><h3 id="factory">factory</h3><ul><li>factory 用于构建复杂的领域对象。</li></ul><h3 id="repository">repository</h3><ul><li>只有聚合根有 repository。</li><li>repository 就只提供 <code>load</code> 和 <code>save</code>功能，且要保证事务一致性。</li><li>尽可能提供行级的 repository，而不是表级的 repository，对于表级的repository，可以抽成一个领域服务。</li></ul><h3 id="设计模式">设计模式</h3><h4 id="责任链模式">责任链模式</h4><blockquote><p>将请求的发送者和接受者解耦，使多个对象都有机会处理请求。</p></blockquote><ul><li>责任链模式的使用要点在于要将维护责任链的代码和业务代码分开。</li><li>在 DDD中使用责任链模式时，应创建一个领域服务，在领域服务中完成责任链的创建和执行。</li><li>尽量不要在责任链的处理器中通过 <code>set</code>修改领域对象（聚合根）的状态，责任链应仅用于某些值的计算，最终将计算结果交给聚合根完成业务操作。</li></ul><p>笔者实现了一个快速构建责任链的工具：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go</span><span class="cap link footnote">https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><h4 id="策略模式">策略模式</h4><blockquote><p>允许在运行时根据需要选择不同的实现。</p></blockquote><ul><li>在 DDD中使用策略模式时，通常先定义一个领域服务接口，再在其实现类中完成策略的加载、选择和执行。</li><li>注意屏蔽策略模式的实现细节，避免上层关注领域服务内的设计模式细节。</li></ul><h4 id="桥接模式">桥接模式</h4><blockquote><p>旨在通过解耦抽象和实现，使两者能够独立扩展和变化。</p></blockquote><ul><li><strong>多维解耦机制</strong>：桥接模式通过组合/聚合关系替代继承关系，将原本紧密耦合的抽象层（功能定义）与实现层（具体操作）分离例如遥控器（抽象）与电视（实现）的协作，遥控器通过接口控制电视，无需关注具体品牌。</li><li><strong>正交扩展能力</strong>：支持两个独立变化维度（如消息类型与通知渠道、图形与渲染方式），避免类数量呈指数级增长（M×N组合问题）。电商物流系统中，新增微信通知渠道时，无需修改所有消息类即可实现扩展。</li></ul><h4 id="规约模式">规约模式</h4><blockquote><p>规约模式是一种用于定义业务领域中规则和约束的模式，通常由规约接口（Specification）和验证器（Validator）两个部分组成。</p></blockquote><ul><li>在 DDD中，规约模式并不是在聚合根进行业务操作之前做前置校验，而是在聚合根完成业务操作之后做后置校验，确保Repository 保存的聚合根符合业务规则。</li></ul><h4 id="适配器模式">适配器模式</h4><blockquote><p>将<strong>被适配者（Adaptee）的接口</strong>转换为<strong>目标接口（Target）</strong>，使原本因接口不兼容而无法协同工作的类能够协同。</p></blockquote><ul><li>在 DDD中，可以使用适配器模式来实现防腐层，以将外部上下文接口（如开放主机服务）返回的模型转换为本地上下文定义的领域模型，并将本地上下文的操作转换为对外部上下文的操作。可以有效隔离外部上下文的领域模型，避免互相污染。</li></ul><h3 id="领域事件">领域事件</h3><h4 id="幂等性">幂等性</h4><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image.png" /></p><h4 id="领域事件的定义">领域事件的定义</h4><blockquote><p>领域事件是领域模型的组成部分，它通常由聚合根产生，并被其他聚合或者限界上下文订阅和处理，触发相应的业务逻辑。</p></blockquote><p>注意点：</p><ul><li>应该根据限界上下文中的通用语言来命名事件：AccountActivited。</li><li>应该将事件建模成值对象或贫血对象。</li></ul><p>应用：</p><ol type="1"><li>解耦领域对象之间的关系；</li><li>触发其他领域对象的行为；</li><li>记录领域内已发生的状态变化；</li><li>实现跨聚合的最终一致性；</li><li>进行限界上下文集成。</li></ol><p>消息体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;event_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;event_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;entity_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;event_time&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extra_data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="领域事件的生成">领域事件的生成</h4><ol type="1"><li>应用层创建领域事件。</li><li>聚合根创建领域事件。</li></ol><p>要避免在聚合根内部调用基础实施发布领域事件，而是生成后返回给应用层，由应用层去发布。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entity <span class="keyword">struct</span> &#123;</span><br><span class="line">  Events []Event</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e *Entity)</span></span>ResgisterEvent(event Event) &#123;</span><br><span class="line">  e.Events = <span class="built_in">append</span>(e.Events. event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e *Entity)</span></span> GetEvents() []Event &#123;</span><br><span class="line">  res := e.Events()</span><br><span class="line">  e.Events = []Event&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="领域事件的发布">领域事件的发布</h4><ol type="1"><li>直接发布并轮询补偿：为事件存储一个发布状态标识，用于记录是否补发成功。并提供定时任务检索超时未发布成功的事件进行重新发布。</li><li>采用事务日志拖尾：引入变更数据捕获组件（Change Data Capture，简称CDC），捕获数据的变更日志，解析后获得领域事件并发布。</li></ol><h4 id="领域事件的订阅">领域事件的订阅</h4><p>将领域事件订阅者放置在用户接口层<code>user-interface-subscriber</code>，收到事件后调用应用服务执行业务逻辑。</p><h3 id="事件溯源">事件溯源</h3><p>事件溯源（Event Sourcing）是一种将所有的领域事件（DomainEvent）存储到事件存储（EventStore）中，并通过重放历史事件来还原领域对象状态的模式。</p><p>核心思想是将系统中所有的状态变更都视为事件，将这些事件以事件顺序记录下来，并存储到事件存储中。这样，可以通过重放这些事件，来还原任意时刻的系统状态。</p><p>三种方案：</p><ol type="1"><li>通过回放所有的历史事件重建聚合根。</li><li>通过快照提高重建聚合根的效率。</li><li><strong>通过拉链表生成所有事件对应的快照。</strong></li></ol><div class="tag-plugin colorful note" color="green"><div class="body"><p>拉链表是一种用于处理缓慢变化维度问题的数据结构，它可以有效地处理维度数据的历史变化。在拉链表中，每个记录都有一个开始时间和结束时间，用于描述该记录的存活时间，即该记录的有效期。</p></div></div><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250312183214921.png"alt="拉链法示意图" /><figcaption aria-hidden="true">拉链法示意图</figcaption></figure><h3 id="cqrs">CQRS</h3><p>CQRS 将系统的操作分为两类：</p><ul><li><strong>命令（Command）</strong>：负责数据的写操作（增、删、改），不返回数据。</li><li><strong>查询（Query）</strong>：负责数据的读操作，仅返回结果且不修改数据。</li></ul><p>两者的数据模型可独立设计，甚至使用不同的数据库或存储技术。</p><details class="tag-plugin colorful folding" color="blue"><summary><p>适用场景</p></summary><div class="body"><p><strong>应对高并发读写场景</strong></p><ul><li><p>案例 1：B 站点赞系统</p><p>在日均活跃用户近亿的 B 站，点赞功能通过 CQRS分离读写操作。写入端通过消息队列（如Kafka）异步处理请求，避免数据库锁竞争；查询端通过缓存优化读取性能，显著提升系统吞吐量和稳定性。</p></li><li><p>案例 2：实时答题 PK 游戏</p><p>高并发的答题得分计算场景中，CQRS 结合事件溯源（EventSourcing）记录每个操作事件，确保读写模型的最终一致性，同时支持复杂战况数据的实时展示。</p></li></ul><p><strong>解决复杂查询需求</strong></p><ul><li><p>案例 3：电商订单查询</p><p>随着订单查询需求多样化（如按时间筛选、跨实体聚合数据），CQRS通过独立读模型简化查询逻辑，避免领域模型被复杂查询逻辑污染。</p></li><li><p>案例 4：微服务数据聚合</p><p>在微服务架构中，CQRS允许通过事件同步跨服务数据到专用读库，避免跨服务联表查询的性能瓶颈（如行程管理服务与用户信息服务的聚合查询）。</p></li></ul><p><strong>提升数据模型灵活性</strong></p><ul><li><p>案例 5：文本增量更新</p><p>针对大型文本编辑场景，CQRS拆分读写模型，增量保存修改记录并通过事件合并，减少网络传输数据量，同时支持任意版本的历史数据恢复。</p></li></ul></div></details><details class="tag-plugin colorful folding" color="orange"><summary><p>不适用场景</p></summary><div class="body"><ul><li>简单 CRUD 系统（如小型管理后台）</li><li>强一致性要求的金融交易场景（如实时扣款）</li><li>团队缺乏事件驱动架构经验时</li></ul></div></details><h3 id="一致性">一致性</h3><h4 id="聚合内事务实现">聚合内事务实现</h4><ul><li>聚合内事务控制不要放在应用层，会使应用层承担过多的责任。应用层应专注于协调领域对象和基础设施以完成业务操作，不应过多涉及数据访问和事务控制的细节。</li><li>聚合内事务控制可以交给 <code>Repository</code>来实现，采用乐观锁解决并发问题，可以基于版本号和时间戳，一般重试 1-3次即可。</li></ul><h4 id="聚合间事务实现">聚合间事务实现</h4><ul><li><p>聚合间控制可以单独建立一个领域服务 Domain Service来完成。</p></li><li><p>对于实时性要求不高，仅需最终一致性，可以使用<strong>本地消息表</strong>或者<strong>最大努力通知</strong>的方案。</p></li><li><p>对于实时性一致性要求比较高，可以采用<strong>TCC（Try-Confirm-Cancel）</strong> 事务方案。</p></li><li><p>对于长事务场景，或者涉及外部系统、遗留系统，可以考虑<strong>Saga</strong> 事务方案。</p><blockquote><p>Saga将事务分为多个事务，这些分支事务按照一定的顺序执行。当某个分支事务执行成功后，会通过消息通知下一个分支执行；当某个分支事务执行失败时，会按照正常事务执行顺序的相反方向进行一系列的补偿操作，以确保全局事务的一致性。</p></blockquote></li></ul><div class="tag-plugin quot"><h2 class="content" id="战略设计" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">战略设计</span><span class="empty"></span></h2></div><h3 id="事件风暴">事件风暴</h3><h4 id="核心概念与元素">核心概念与元素</h4><table><colgroup><col style="width: 46%" /><col style="width: 6%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th>元素名称</th><th>颜色标识</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><font color="#FFA500"><strong>领域事件（DomainEvent）</strong></font></td><td>橙色</td><td>表示已发生的业务事实，以“动词过去式”命名（如“订单已提交”），是事件风暴的核心起点。</td></tr><tr class="even"><td><font color="#00008B"><strong>命令（Command）</strong></font></td><td>深蓝色</td><td>触发领域事件的操作或意图（如“提交订单”），通常由用户或系统触发。</td></tr><tr class="odd"><td><font color="#FFFF00"><strong>参与者（Actor）</strong></font></td><td>黄色</td><td>执行命令的角色，包括用户、部门或外部系统（如“客户”触发支付命令）。</td></tr><tr class="even"><td><font color="#FFC0CB"><strong>外部系统（ExternalSystem）</strong></font></td><td>粉色</td><td>与当前系统交互的第三方服务（如支付网关回调生成事件）。</td></tr><tr class="odd"><td><font color="#800080"><strong>策略（Policy）</strong></font></td><td>紫色</td><td>业务规则或约束条件（如“库存不足时取消订单”），决定事件触发的逻辑。</td></tr><tr class="even"><td><font color="#008000"><strong>读模型（ReadModel）</strong></font></td><td>绿色</td><td>为查询优化的数据视图（如“用户订单列表”），支持决策展示。</td></tr><tr class="odd"><td><font color="#FFD700"><strong>聚合（Aggregate）</strong></font></td><td>大黄色</td><td>业务对象集合（如“订单聚合”包含订单项和状态），维护一致性和完整性。</td></tr><tr class="even"><td><font color="#FF0000"><strong>问题（Question）</strong></font></td><td>红色</td><td>未达成共识的争议点（如事件定义分歧），需后续专项讨论。</td></tr></tbody></table><h4 id="实施流程与步骤">实施流程与步骤</h4><ol type="1"><li><p><strong>准备工作</strong></p><ul><li><strong>参与人员</strong>：业务专家、开发、产品、测试等跨职能角色，需领域专家主导。<br /></li><li><strong>物料</strong>：多色便签、白板、马克笔，线上工具辅助远程协作。</li></ul></li><li><p><strong>识别领域事件</strong>团队通过头脑风暴罗列所有可能事件（如电商场景的“订单已创建”“库存已扣减”），按时间轴排列，争议事件用红色便签标记并暂存。</p></li><li><p><strong>补充命令与角色</strong>为每个事件关联触发命令及执行者（如“客户”执行“支付订单”命令生成“支付完成”事件），区分内部操作与外部系统调用。</p></li><li><p><strong>定义策略与读模型</strong>添加业务规则（如“订单金额≥1000元需审核”）和数据展示需求（如“实时库存看板”）。</p></li><li><p><strong>构建聚合与划分子域</strong>将相关事件、命令归类为聚合（如“支付聚合”），划分限界上下文（如“订单服务”“库存服务”），明确微服务边界。</p></li></ol><h4 id="注意事项">注意事项</h4><ol type="1"><li><p><strong>事件粒度的把控</strong>：避免过度细化（如“用户已睁眼"）或过于宽泛（如“订单已修改”），需聚焦业务关键节点。</p></li><li><p><strong>争议处理与迭代</strong>：对未达成共识的事件标记为“问题”（红色便签），后续专题讨论；定期回顾模型，修正错误或补充遗漏。</p></li><li><p><strong>技术实现衔接</strong>：事件风暴的输出需转化为代码模型，例如通过事件溯源（EventSourcing）持久化事件流，或结合 CQRS 分离读写逻辑。</p></li></ol><h3 id="c4-架构模型">C4 架构模型</h3><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://c4model.com/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://c4model.com/" autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div><span class="cap link footnote">https://c4model.com/</span></div><div class="bottom"><span class="title">https://c4model.com/</span><span class="cap desc footnote"></span></div></a></div><table><colgroup><col style="width: 13%" /><col style="width: 30%" /><col style="width: 17%" /><col style="width: 38%" /></colgroup><thead><tr class="header"><th><strong>层级</strong></th><th><strong>核心目标</strong></th><th><strong>受众</strong></th><th><strong>关键元素</strong></th></tr></thead><tbody><tr class="odd"><td><strong>Context（上下文）</strong></td><td>描述系统与外部实体（用户、第三方系统）的交互关系</td><td>非技术人员（如业务方、客户）</td><td>系统边界、用户角色、外部依赖（如支付网关）</td></tr><tr class="even"><td><strong>Container（容器）</strong></td><td>展示系统内部的高阶技术组件（进程级单元）</td><td>技术管理者、架构师</td><td>Web 应用、数据库、消息队列等独立进程单元，关注技术选型与通信协议（如REST API、gRPC）</td></tr><tr class="odd"><td><strong>Component（组件）</strong></td><td>细化容器内部的业务模块与交互逻辑</td><td>开发团队</td><td>服务、模块、接口（如订单服务、库存服务），强调职责划分与依赖关系</td></tr><tr class="even"><td><strong>Code（代码）</strong></td><td>展示组件实现的代码结构</td><td>开发者</td><td>类、方法、数据库表（如 UML 类图、ER 图），通常由 IDE工具自动生成</td></tr></tbody></table><p>除了四层核心视图，C4 模型还提供：</p><ul><li><strong>部署图</strong>：展示容器在物理环境中的分布（如 Kubernetes集群部署）。</li><li><strong>动态图</strong>：描述业务流程（如用户下单到支付完成的时序交互）。</li><li><strong>系统景观图</strong>：多系统协同的全局视图（如企业级中台架构）。</li></ul><div class="tag-plugin tabs" align="center"id="tab_2"><div class="nav-tabs"><div class="tab active"><a href="#tab_2-1">Context</a></div><div class="tab"><a href="#tab_2-2">Container</a></div><div class="tab"><a href="#tab_2-3">Component</a></div><div class="tab"><a href="#tab_2-4">Code</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_2-1"><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/SystemContext-20250312173256060.png" /></p></div><div class="tab-pane" id="tab_2-2"><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Containers-20250312173305921.png" /></p></div><div class="tab-pane" id="tab_2-3"><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Components-20250312173320890.png" /></p></div><div class="tab-pane" id="tab_2-4"><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/MainframeBankingSystemFacade-20250312173313572.png" /></p></div></div></div><div class="tag-plugin quot"><h2 class="content" id="实践案例" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">实践案例</span><span class="empty"></span></h2></div><p>参考作者的 <ahref="https://github.com/feiniaojin/ddd-archetype">ddd-archetype</a>，笔者实现了一个 Go 版本的 <code>ddd-archetype-go</code>：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon-go-road/ddd-archetype-go" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon-go-road/ddd-archetype-go" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon-go-road/ddd-archetype-go</span><span class="cap link footnote">https://github.com/hedon-go-road/ddd-archetype-go</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><p>整体架构如下：</p><p><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/ddd-ruoyi.drawio.png" /></p>]]></content>
    
    
    <summary type="html">阅读《悟道领域驱动设计》后的一些笔记和思考。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDD" scheme="https://hedon.top/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.24 新特性解读：使用 testing/synctest 优雅地测试并发代码</title>
    <link href="https://hedon.top/2025/03/06/go-lib-synctest/"/>
    <id>https://hedon.top/2025/03/06/go-lib-synctest/</id>
    <published>2025-03-06T07:00:18.000Z</published>
    <updated>2025-03-06T10:35:38.581Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go语言开发中，并发编程一直是其最引人注目的特性之一。然而，如何有效地测试并发代码却常常让开发者感到头疼。Go1.24 版本引入的实验性包 <code>testing/synctest</code>为这个问题带来了优雅的解决方案。今天，让我们深入了解这个新特性。</p><h1 id="并发测试的传统困境">并发测试的传统困境</h1><p>在介绍新方案之前，我们先看看传统的并发测试面临哪些问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTraditional</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 执行某些操作</span></span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待操作完成</span></span><br><span class="line">    time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">if</span> !done &#123;</span><br><span class="line">        t.Fatal(<span class="string">&quot;操作未完成&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式存在明显的问题：</p><ol type="1"><li><strong>时间依赖</strong>：需要通过 Sleep等待，导致测试运行缓慢</li><li><strong>不稳定性</strong>：在不同环境下可能产生不同结果</li><li><strong>精确性差</strong>：难以准确把握检查时机</li></ol><h1 id="synctest优雅的解决方案">synctest：优雅的解决方案</h1><p><code>testing/synctest</code> 包通过两个核心函数改变了这一切：</p><ul><li><code>Run()</code>: 创建隔离的测试环境（bubble）</li><li><code>Wait()</code>: 等待所有 goroutine 进入稳定状态</li></ul><p>让我们看看如何改写上面的测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWithSynctest</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 执行某些操作</span></span><br><span class="line">            time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">            done = <span class="literal">true</span></span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        synctest.Wait()  <span class="comment">// 等待所有 goroutine 进入稳定状态</span></span><br><span class="line">        <span class="keyword">if</span> !done &#123;</span><br><span class="line">            t.Fatal(<span class="string">&quot;操作未完成&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="深入理解-wait-机制">深入理解 Wait 机制</h1><h2 id="wait-的本质">Wait 的本质</h2><p>很多开发者初次接触 <code>Wait()</code>时可能会感到困惑：它到底在等待什么？什么时候会返回？</p><p>想象一个场景：你在拍摄一张全家福，需要等待所有人都找到自己的位置，站好不动，才能按下快门。<code>Wait()</code>就像这个摄影师，它在等待所有goroutine（就像照片中的人）都进入一个稳定的状态（站好不动）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 类比：三个人要拍全家福</span></span><br><span class="line">    <span class="keyword">go</span> person1()  <span class="comment">// 第一个人找位置</span></span><br><span class="line">    <span class="keyword">go</span> person2()  <span class="comment">// 第二个人找位置</span></span><br><span class="line">    <span class="keyword">go</span> person3()  <span class="comment">// 第三个人找位置</span></span><br><span class="line"></span><br><span class="line">    synctest.Wait()  <span class="comment">// 等待所有人都站好不动</span></span><br><span class="line">    <span class="comment">// 这时可以安全地&quot;按下快门&quot;（检查程序状态）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="为什么需要-wait">为什么需要 Wait？</h2><p>在并发程序中，我们经常需要在特定时刻检查程序状态。但是，如果某些goroutine 还在运行，这个状态可能随时发生变化。<code>Wait()</code>通过确保所有 goroutine 都进入稳定状态，为我们提供了一个"快照"时刻。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        result = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    synctest.Wait()  <span class="comment">// 等待 goroutine 进入稳定状态</span></span><br><span class="line">    <span class="comment">// 此时 result 的值是确定的，不会突然改变</span></span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="持久阻塞的概念">持久阻塞的概念</h2><p>哪些操作会导致持久阻塞？</p><ul><li>channel 操作（同一 bubble 内）</li><li>time.Sleep</li><li>sync.WaitGroup.Wait</li><li>sync.Cond.Wait</li></ul><p>哪些操作不算持久阻塞？</p><ul><li>互斥锁操作</li><li>外部 I/O</li><li>外部 channel 操作</li></ul><h1 id="虚拟时钟测试的神器">虚拟时钟：测试的神器</h1><p><code>synctest</code> 的另一个强大特性是虚拟时钟机制。在 bubble内部，所有时间相关的操作都使用虚拟时钟，这意味着：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 看似等待24小时</span></span><br><span class="line">    time.Sleep(<span class="number">24</span> * time.Hour)</span><br><span class="line">    <span class="comment">// 实际上立即执行完成！</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个特性让我们能够：</p><ol type="1"><li>快速测试长时间操作</li><li>精确控制时间流逝</li><li>避免测试的不确定性</li></ol><h1 id="实战案例深入理解-http-100-continue-测试">实战案例：深入理解 HTTP100 Continue 测试</h1><h2 id="背景知识">背景知识</h2><p>HTTP 的 100 Continue 机制是一个优化大文件上传的协议特性：</p><ol type="1"><li>客户端想上传大文件时，先发送带有 "Expect: 100-continue"头的请求</li><li>服务器可以决定是否接受这个上传：<ul><li>如果接受，返回 "100 Continue"</li><li>如果拒绝，可以直接返回错误状态码</li></ul></li><li>客户端根据服务器的响应决定是否发送文件内容</li></ol><h2 id="详细测试实现">详细测试实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHTTPContinue</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 第一步：建立测试环境</span></span><br><span class="line">        srvConn, cliConn := net.Pipe()</span><br><span class="line">        <span class="keyword">defer</span> srvConn.Close()</span><br><span class="line">        <span class="keyword">defer</span> cliConn.Close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二步：配置 HTTP 客户端</span></span><br><span class="line">        tr := &amp;http.Transport&#123;</span><br><span class="line">            DialContext: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, address <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cliConn, <span class="literal">nil</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ExpectContinueTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三步：准备测试数据</span></span><br><span class="line">        body := <span class="string">&quot;request body&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第四步：发送请求</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            req, _ := http.NewRequest(<span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;http://test.tld/&quot;</span>, </span><br><span class="line">                strings.NewReader(body))</span><br><span class="line">            req.Header.Set(<span class="string">&quot;Expect&quot;</span>, <span class="string">&quot;100-continue&quot;</span>)</span><br><span class="line">            resp, err := tr.RoundTrip(req)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                t.Errorf(<span class="string">&quot;请求失败: %v&quot;</span>, err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.Body.Close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第五步：验证请求头</span></span><br><span class="line">        req, err := http.ReadRequest(bufio.NewReader(srvConn))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;读取请求失败: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第六步：验证请求体未发送</span></span><br><span class="line">        <span class="keyword">var</span> gotBody strings.Builder</span><br><span class="line">        <span class="keyword">go</span> io.Copy(&amp;gotBody, req.Body)</span><br><span class="line">        synctest.Wait()</span><br><span class="line">        <span class="keyword">if</span> got := gotBody.String(); got != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;在发送 100 Continue 之前，意外收到请求体: %q&quot;</span>, got)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第七步：发送 100 Continue</span></span><br><span class="line">        srvConn.Write([]<span class="type">byte</span>(<span class="string">&quot;HTTP/1.1 100 Continue\r\n\r\n&quot;</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第八步：验证请求体</span></span><br><span class="line">        synctest.Wait()</span><br><span class="line">        <span class="keyword">if</span> got := gotBody.String(); got != body &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;收到的请求体 %q，期望 %q&quot;</span>, got, body)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第九步：完成请求</span></span><br><span class="line">        srvConn.Write([]<span class="type">byte</span>(<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试的关键点解析">测试的关键点解析</h2><ol type="1"><li><strong>使用 net.Pipe()</strong><ul><li>创建内存中的网络连接</li><li>避免依赖真实网络</li><li>保证测试的可重复性</li></ul></li><li><strong>请求发送过程</strong><ul><li>在独立的 goroutine 中发送请求</li><li>设置 "Expect: 100-continue" 头</li><li>准备要发送的请求体</li></ul></li><li><strong>验证关键行为</strong><ul><li>确认请求头正确发送</li><li>验证请求体在收到 100 Continue 之前未发送</li><li>验证请求体在收到 100 Continue 后正确发送</li></ul></li><li><strong>使用 Wait 的时机</strong><ul><li>在检查请求体之前调用 Wait</li><li>确保所有数据传输操作都已完成或阻塞</li><li>获得稳定的程序状态进行验证</li></ul></li></ol><h1 id="使用建议">使用建议</h1><ol type="1"><li><strong>明确边界</strong>：理解什么操作会导致持久阻塞，什么不会</li><li><strong>清理资源</strong>：确保所有 goroutine 在测试结束前退出</li><li><strong>模拟 I/O</strong>：使用内存管道替代真实网络连接</li><li><strong>合理使用 Wait</strong>：在需要检查状态的关键点调用</li></ol><h1 id="注意事项">注意事项</h1><ol type="1"><li>目前是实验性功能，需要设置 <code>GOEXPERIMENT=synctest</code></li><li>不支持测试真实的外部 I/O 操作</li><li>互斥锁操作不被视为持久阻塞</li></ol>]]></content>
    
    
    <summary type="html">本文介绍了 Go 1.24 版本引入的实验性包 testing/synctest，并详细讲解了如何使用它优雅地测试并发代码。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>直播系统推拉流原理</title>
    <link href="https://hedon.top/2025/03/04/live-stream-push-pull/"/>
    <id>https://hedon.top/2025/03/04/live-stream-push-pull/</id>
    <published>2025-03-04T03:34:09.000Z</published>
    <updated>2025-03-04T04:22:36.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直播系统推拉流原理概述">直播系统推拉流原理概述</h1><p>直播系统的核心功能是实现主播端视频采集后的实时传输，以及观众端的实时观看。整个过程主要包含：推流、服务器处理、拉流三个环节。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250304121833913.png"alt="直播系统架构" /><figcaption aria-hidden="true">直播系统架构</figcaption></figure><h2 id="核心概念解析">核心概念解析</h2><h3 id="推流push">1. 推流（Push）</h3><p>推流是指主播端将视频数据传输到服务器的过程。主要使用<code>RTMP</code> 协议（Real Time Messaging Protocol）。</p><p>比如可能有如下推流 URL 的生成逻辑： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generatePushUrl</span><span class="params">(String pushDomain, String pushKey, String appName, String streamName, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pushUrl</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 推流域名未开启鉴权功能的情况下</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(pushKey)) &#123;</span><br><span class="line">        pushUrl = <span class="string">&quot;rtmp://&quot;</span> + pushDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000L</span> + expireTime;</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringToMd5</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;-&quot;</span> + Long.toString(timeStamp) + <span class="string">&quot;-0-0-&quot;</span> + pushKey;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authKey</span> <span class="operator">=</span> md5(stringToMd5);</span><br><span class="line">        pushUrl = <span class="string">&quot;rtmp://&quot;</span> + pushDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;?auth_key=&quot;</span> + Long.toString(timeStamp) + <span class="string">&quot;-0-0-&quot;</span> + authKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pushUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>推流地址的组成部分： - rtmp:// - 协议 - pushDomain - 推流域名 -appName - 应用名称 - streamName - 流名称 - auth_key -鉴权参数（可选）</p><h3 id="拉流pull">2. 拉流（Pull）</h3><p>拉流是观众观看直播的过程。支持多种协议： - RTMP：延迟低（1-3秒） -HTTP-FLV：延迟适中（2-5秒） - HLS(m3u8)：延迟较高（5-30秒）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FLV 格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generalPullUrlFlv</span><span class="params">(String pullDomain, String pullKey, String appName, String streamName, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(pullKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://&quot;</span> + pullDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;.flv&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 鉴权逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HLS 格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generalPullUrlHls</span><span class="params">(String pullDomain, String pullKey, String appName, String streamName, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(pullKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://&quot;</span> + pullDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;.m3u8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 鉴权逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直播流程">直播流程</h2><ol type="1"><li><strong>主播开播</strong>：<ul><li>系统生成唯一的 streamId</li><li>生成带鉴权的推流地址</li><li>主播端推流软件（如 OBS）开始推流</li></ul></li><li><strong>服务器处理</strong>：<ul><li>流媒体服务器接收推流</li><li>进行转码、录制等处理</li><li>将流分发到 CDN 节点</li></ul></li><li><strong>观众观看</strong>：<ul><li>获取对应格式的拉流地址</li><li>通过播放器拉取直播流</li><li>实现实时观看</li></ul></li></ol><h2 id="实现建议">实现建议</h2><ol type="1"><li><strong>选择合适的流媒体服务器</strong>：<ul><li>商业云服务：阿里云直播、腾讯云直播</li><li>开源方案：SRS、Nginx-RTMP</li></ul></li><li><strong>根据业务场景选择协议</strong>：<ul><li>普通直播：HTTP-FLV</li><li>低延迟场景：RTMP</li><li>移动端兼容性要求高：HLS</li></ul></li><li><strong>关注关键指标</strong>：<ul><li>延迟控制</li><li>卡顿率</li><li>首屏时间</li><li>带宽成本</li></ul></li><li><strong>安全鉴权：</strong><ul><li>防盗链机制</li></ul></li></ol>]]></content>
    
    
    <summary type="html">本文介绍了直播系统推拉流的基本原理，包括推流和拉流的过程、协议选择、关键指标等。</summary>
    
    
    
    <category term="解决方案" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="直播系统" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="直播系统" scheme="https://hedon.top/tags/%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>网络数据包的完整旅程：从发送到接收的全过程</title>
    <link href="https://hedon.top/2025/03/01/net-data-journey/"/>
    <id>https://hedon.top/2025/03/01/net-data-journey/</id>
    <published>2025-03-01T04:58:37.000Z</published>
    <updated>2025-03-03T13:59:29.408Z</updated>
    
    <content type="html"><![CDATA[<p>不知道你是否曾经好奇你发出的一个网络请求，最终是怎么到达对端，并将你想要的信息返回给你的。本文将通过一个HTTP请求与响应，从一个比较宏观的角度来梳理下一个数据包在网络中的旅途，旨在帮助笔者和各位读者建立起对计算机网络模型一个比较全面的认知。</p><blockquote><p>本文参考极客时间《网络架构实战课（谢友鹏）》，再根据笔者的知识面、按照个人理解，补充更多丰富具体的内容。</p></blockquote><h1 id="实战">实战</h1><p>好，那我们直接开始，我们先使用 <code>curl</code> 来发起一个 HTTP请求，看看这过程中发生了什么：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /dev/null -v https://example.com</span><br></pre></td></tr></table></figure><p>在笔者的 mac 机器上，这行命令的输出如下：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301131247066.png" data-fancybox="true" alt="curl https//example.com 结果分析" style="width: 100%; height: auto;"></p><p>当我们发起请求时，首先会对 <code>example.com</code>进行域名解析，分别尝试解析到它的 <code>IPv6</code> 和<code>IPv4</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* IPv6: (none)</span><br><span class="line">* IPv4: 23.215.0.138, 96.7.128.198, 23.192.228.80, 23.192.228.84, 23.215.0.136, 96.7.128.175</span><br></pre></td></tr></table></figure><p>因为我们使用的是 <code>https</code> 协议，所以会尝试跟这些地址的<code>443</code> 端口建立 <code>TCP</code> 连接，（如果是<code>https</code> 则跟 <code>80</code> 端口），并进行<code>TLS 握手验证</code>，如果成功了，则会建立 <code>TCP</code>连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Trying <span class="number">23.215</span><span class="number">.0</span><span class="number">.138</span>:<span class="number">443.</span>..</span><br><span class="line">...[TLS handshake]</span><br><span class="line">* Connected to example.com (<span class="number">23.215</span><span class="number">.0</span><span class="number">.138</span>) port <span class="number">443</span></span><br></pre></td></tr></table></figure><p>建立连接后，就开始发送 <code>HTTP</code> 请求，这里使用的是 HTTP2协议。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* using HTTP/2</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0* [HTTP/2] [1] OPENED stream <span class="keyword">for</span> https://example.com/</span><br><span class="line">* [HTTP/2] [1] [:method: GET]</span><br><span class="line">* [HTTP/2] [1] [:scheme: https]</span><br><span class="line">* [HTTP/2] [1] [:authority: example.com]</span><br><span class="line">* [HTTP/2] [1] [:path: /]</span><br><span class="line">* [HTTP/2] [1] [user-agent: curl/8.10.1]</span><br><span class="line">* [HTTP/2] [1] [accept: */*]</span><br><span class="line">&#125; [5 bytes data]</span><br><span class="line">&gt; GET / HTTP/2</span><br><span class="line">&gt; Host: example.com</span><br><span class="line">&gt; User-Agent: curl/8.10.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">* Request completely sent off</span><br></pre></td></tr></table></figure><p>最后，服务器返回了 HTTP 200 OK 的响应。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123; [5 bytes data]</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):</span><br><span class="line">&#123; [265 bytes data]</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):</span><br><span class="line">&#123; [265 bytes data]</span><br><span class="line">&lt; HTTP/2 200</span><br><span class="line">&lt; content-type: text/html</span><br><span class="line">&lt; etag: <span class="string">&quot;84238dfc8092e5d9c0dac8ef93371a07:1736799080.121134&quot;</span></span><br><span class="line">&lt; last-modified: Mon, 13 Jan 2025 20:11:20 GMT</span><br><span class="line">&lt; cache-control: max-age=1374</span><br><span class="line">&lt; <span class="built_in">date</span>: Sat, 01 Mar 2025 05:01:03 GMT</span><br><span class="line">&lt; alt-svc: h3=<span class="string">&quot;:443&quot;</span>; ma=93600,h3-29=<span class="string">&quot;:443&quot;</span>; ma=93600,quic=<span class="string">&quot;:443&quot;</span>; ma=93600; v=<span class="string">&quot;43&quot;</span></span><br><span class="line">&lt; content-length: 1256</span><br><span class="line">&lt;</span><br><span class="line">&#125; [5 bytes data]</span><br><span class="line">100  1256  100  1256    0     0   1172      0  0:00:01  0:00:01 --:--:--  1172</span><br><span class="line">* Connection <span class="comment">#0 to host example.com left intact</span></span><br></pre></td></tr></table></figure><p>要进一步了解网络数据包的细节，我们可以通过抓包工具进行分析。你可以使用<code>tcpdump</code> 抓取与 example.com 的通信数据包。</p><p>运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump host example.com -w example.com.pcap</span><br></pre></td></tr></table></figure><p>然后再另外一个命令行窗口再次发送请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /dev/null -v https://example.com</span><br></pre></td></tr></table></figure><p>回到 <code>tcpdump</code> 的窗口并结束监听，我们就会得到<code>example.com.pcap</code> 的抓包文件，可以通过<code>Wireshark</code> 软件打开该文件：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301133015523.png"alt="tcpdump 分析结果" /><figcaption aria-hidden="true">tcpdump 分析结果</figcaption></figure><h1 id="网络分层">网络分层</h1><p>通过上述实验，我们可以清晰看到网络是分层的，主流的分层模型有 OSI七层模型和 TCP/IP 四层模型，它们的对应关系及常见的协议如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/OSI-vs-TCP.png"alt="OSI-vs-TCP/IP" /><figcaption aria-hidden="true">OSI-vs-TCP/IP</figcaption></figure><p>我们在 Wireshark上方随便选择一个数据包，使用鼠标点击下方左侧的每一层，可以在右侧看到对应的层级数据。从链路层到应用层，每一层的数据都是对下一层的进一步封装。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301134103404.png"alt="数据包封装" /><figcaption aria-hidden="true">数据包封装</figcaption></figure><p>在发送方，用户程序需要传输的数据会经过逐层封装。首先添加应用层的 HTTPHeader，然后是传输层的 TCP Header，接着是网络层的 IPHeader，最后在链路层添加以太网帧的帧头和帧尾，包括源 MAC 地址、目的 MAC地址等链路层信息，最终形成网络中传输的完整数据包。</p><p>在接收方，数据包会按相反的顺序逐层解封装。接收设备从链路层开始解析数据，依次解读网络层、传输层和应用层的信息，最后将数据传递给接收方的应用程序。</p><p>如下图所示：</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/cn1.png"alt="数据包封装 &amp; 解析" /><figcaption aria-hidden="true">数据包封装 &amp; 解析</figcaption></figure><p>我们在 Wireshark中点开下面的每一层，可以看到如下信息，我在图标注了最重要的几个信息：<imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301135433547.png"alt="网络数据包关键信息" /></p><h1 id="网络之旅">网络之旅</h1><p>经过上述实验，我们可以做个小总结：</p><p>通过上述实验，我们可以清晰理解数据包的传输过程：</p><ul><li>HTTP请求是网络通信的应用层内容，它需要通过各层网络协议的封装才能实现端到端传输。</li><li>从发送方角度，数据传输遵循一个明确的逻辑顺序：首先将域名（example.com）解析为IP 地址，然后基于该 IP 地址和目标端口（443）建立 TCP 连接，接着找到目标IP 的 MAC 地址，最终由网卡将完整封装的数据包发送到网络中。</li><li>从接收方角度，服务器处理数据包的过程是一个自下而上的解封装过程：数据链路层接收到的帧包含源MAC 地址，网络层解析出 IPv4 地址和协议类型，传输层识别出 TCP协议和源端口号，最终在应用层获取并处理 HTTP请求数据。服务器根据这些信息构建响应，并按相反顺序封装返回给客户端。</li></ul><p>这种分层处理机制确保了网络通信的灵活性和可靠性，每层只需关注自己的职责，共同完成端到端的数据传输任务。</p><p>好，那么这里就有 2 个最关键的问题：</p><ol type="1"><li>如何通过域名获得 IP 地址？</li><li>如何通过 IP 地址获取 MAC 地址？</li></ol><h2 id="dns-解析">DNS 解析</h2><p>DNS（Domain NameSystem，域名系统）是互联网的一项核心服务，它允许我们使用易记的域名（如<code>example.com</code>）而不是数字 IP 地址（如<code>93.184.216.34</code>）来访问网站。</p><p>当你在浏览器中输入一个域名时，DNS 解析按以下步骤进行：</p><ol type="1"><li><p><strong>浏览器缓存检查</strong>：浏览器首先检查自己的缓存，看是否已经存储了该域名对应的IP 地址。</p></li><li><p><strong>操作系统缓存检查</strong>：如果浏览器缓存中没有，系统会检查操作系统的DNS 缓存（如 Windows 的 DNS Client 服务）。</p></li><li><p><strong>路由器缓存检查</strong>：若系统缓存中也没有，请求会被发送到你的路由器，它也维护着一个DNS 缓存。</p></li><li><p><strong>ISP DNS服务器查询</strong>：如果以上缓存都未命中，请求会被发送到你的ISP（互联网服务提供商）的 DNS 服务器。</p></li><li><p><strong>递归查询</strong>：ISP 的 DNS 服务器会执行递归查询：</p><ul><li>首先查询根域名服务器（Root DNS Server）</li><li>根服务器会引导到顶级域名服务器（TLD DNS Server，如 .com, .net, .org等）</li><li>顶级域名服务器会引导到权威域名服务器（Authoritative DNSServer）</li><li>权威服务器会返回该域名的 IP 地址</li></ul></li><li><p><strong>结果返回与缓存</strong>：一旦获取到 IP地址，它会被沿着查询路径返回，并在各个层级上缓存一段时间（由 TTL值决定）。</p></li></ol><p>你可以使用以下工具查询 DNS 信息：</p><ul><li><strong>nslookup</strong>：<code>nslookup example.com</code></li><li><strong>dig</strong>：<code>dig example.com</code></li><li><strong>host</strong>：<code>host example.com</code></li></ul><p>这些工具可以帮助你了解域名的解析过程和结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ host example.com</span><br><span class="line">example.com has address 23.215.0.138</span><br><span class="line">example.com has address 23.192.228.84</span><br><span class="line">example.com has address 23.215.0.136</span><br><span class="line">example.com has address 23.192.228.80</span><br><span class="line">example.com has address 96.7.128.175</span><br><span class="line">example.com has address 96.7.128.198</span><br><span class="line">example.com has IPv6 address 2600:1408:ec00:36::1736:7f31</span><br><span class="line">example.com has IPv6 address 2600:1406:3a00:21::173e:2e65</span><br><span class="line">example.com has IPv6 address 2600:1406:3a00:21::173e:2e66</span><br><span class="line">example.com has IPv6 address 2600:1406:bc00:53::b81e:94c8</span><br><span class="line">example.com has IPv6 address 2600:1406:bc00:53::b81e:94ce</span><br><span class="line">example.com has IPv6 address 2600:1408:ec00:36::1736:7f24</span><br><span class="line">example.com mail is handled by 0 .</span><br></pre></td></tr></table></figure><p>通过 DNS 解析将域名转换为 IP地址后，网络通信的下一步就是确定如何将数据包发送到目标 IP地址，这就需要用到 ARP 协议来获取目标设备的 MAC 地址。</p><h2 id="穿越客户端局域网">穿越客户端局域网</h2><p><strong>当我们发送一个网络请求时，数据包如何找到离开家庭/办公网络的"出口"？</strong></p><p>数据包首先需要解决的是"该往哪走"的问题：</p><ol type="1"><li><p><strong>问题：我需要直接联系目标设备还是找个"中介"？</strong></p><p>解决方案：子网判断</p><ul><li>设备会比较目标 IP 与自己的 IP 和子网掩码</li><li>就像判断收件人是不是住在同一个小区</li></ul></li><li><p><strong>问题：如何找到同一网络中的设备？</strong></p><p>解决方案：ARP 协议</p><ul><li>类似于小区广播："谁是 202 号房的？请告诉我你的门牌号！"</li><li>目标设备回应自己的 MAC 地址（设备的"身份证号"）</li></ul></li><li><p><strong>问题：目标在远方，如何离开本地网络？</strong></p><p>解决方案：默认网关</p><ul><li>就像不认识远方收件人的地址，先交给小区门卫（路由器）</li><li>数据包头上标注最终目的地 IP，但先送到网关的 MAC 地址</li></ul></li><li><p><strong>问题：数据如何在本地网络中转发？</strong></p><p>解决方案：交换机的 MAC 地址表</p><ul><li>交换机就像小区内的快递员，记住了每家每户的门牌号</li><li>它查表后将包裹精确送到对应的门口，不会打扰其他住户</li></ul></li></ol><p>简单来说，数据包在本地网络中的旅程就像是快递先确认收件人是否在同一小区，如果是，直接送达；如果不是，则交给小区出口的保安，由他负责进一步转发。</p><h2 id="穿越公网">穿越公网</h2><p><strong>数据包离开了本地网络，如何在茫茫互联网中找到遥远的目标服务器？</strong></p><p>数据包在互联网上的旅程就像一次跨国旅行：</p><ol type="1"><li><p><strong>问题：如何从私人区域进入公共世界？</strong></p><p>解决方案：NAT（网络地址转换）</p><ul><li><p>就像多人共用一个护照出国，本地设备共享一个公网 IP</p></li><li><p>路由器会记住谁发了什么请求，回程时能送回正确的设备</p></li></ul></li><li><p><strong>问题：互联网如此庞大复杂，谁来管理这些网络？</strong></p><p>解决方案：自治系统（Autonomous System, AS）</p><ul><li><p>AS 就像互联网世界的"国家"或"独立王国"</p></li><li><p>每个 AS 由单一技术管理机构控制（如ISP、大企业或教育机构）</p></li><li><p>你的数据包首先进入你的 ISP 所在的 AS，然后可能穿越多个AS</p></li><li><p>每个 AS 有唯一的 AS 号（ASN），如 AS7018(AT&amp;T) 或AS8075(Microsoft)</p></li></ul></li><li><p><strong>问题：这些"网络王国"如何相互通信和合作？</strong></p><p>解决方案：BGP 协议(边界网关协议)</p><ul><li><p>BGP 是 AS 之间的"外交语言"，用于宣告路由信息</p></li><li><p>它告诉其他 AS："通过我可以到达这些网络"</p></li><li><p>路由器根据 BGP 信息，决定数据包应该经过哪些 AS</p></li></ul></li><li><p><strong>问题：如何决定数据包在 AS 内部该走哪条路？</strong></p><p>解决方案：内部路由协议</p><ul><li><p>AS 内部使用 OSPF 或 IS-IS 等协议来找到最佳路径</p></li><li><p>路由器像城市中的交通指挥，根据"路况"决定下一个方向</p></li></ul></li><li><p><strong>问题：不同运营商之间如何连接？</strong></p><p>解决方案：互联网交换中心（IXP）</p><ul><li><p>就像不同航空公司在大型枢纽机场交换乘客</p></li><li><p>数据包在 IXP 从一个 AS “转机”到另一个 AS</p></li><li><p>这减少了路径长度，提高了传输效率</p></li></ul></li><li><p><strong>问题：我能知道我的数据经过了哪些地方吗？</strong></p><p>解决方案：路径追踪工具</p><ul><li><p>traceroute/tracert 就像给数据包装上 GPS</p></li><li><p>你可以看到数据包穿越的不同 AS 和路由器</p></li></ul></li></ol><p>互联网就像一个巨大的全球快递网络，你的数据包可能穿越多个国家、经过海底电缆，由不同的运营商接力传递，最终到达目的地的网络。</p><h2 id="穿越服务端局域网">穿越服务端局域网</h2><p><strong>数据包到达目标所在网络后，如何找到并到达最终的服务器？</strong></p><p>数据包抵达目的地网络，就像国际快递到达目标城市，还需要最后一段"本地配送"：</p><ol type="1"><li><p><strong>问题：如何确保只有合法请求能进入网络？</strong></p><p>解决方案：防火墙和安全策略</p><ul><li>就像机场海关，检查入境者是否符合入境条件</li><li>只有合法的数据包才能通过安全检查</li></ul></li><li><p><strong>问题：大型网站如何处理海量请求？</strong></p><p>解决方案：负载均衡</p><ul><li>像大型医院的分诊台，将病人分配到不同的医生处</li><li>根据服务器负载、用户位置等因素智能分发请求</li></ul></li><li><p><strong>问题：如何在数据中心复杂环境中找到目标服务器？</strong></p><p>解决方案：内部路由与最后一跳 ARP</p><ul><li>数据中心内部有自己的"地图"和"道路系统"</li><li>最后一个路由器会通过 ARP 找到服务器的具体位置</li></ul></li><li><p><strong>问题：现代云环境中，服务器可能是虚拟的，怎么处理？</strong></p><p>解决方案：虚拟网络</p><ul><li>物理服务器上可能运行多个虚拟机或容器</li><li>虚拟交换机将数据包准确送达虚拟环境中的目标应用</li></ul></li></ol><p>这就像国际快递最后的“最后一公里”配送 -从目的地城市的分拣中心，经过层层筛选，最终送到收件人手中。</p><h2 id="总结">总结</h2><p>网络请求就像一封国际信件的旅程：</p><ol type="1"><li><p>本地投递：从你家出发，判断收件人是否在同小区。如不在，交给小区出口的门卫（网关）。</p></li><li><p>国际运输：</p><ul><li>先经过你所在“国家”（你 ISP 的 AS）的海关（NAT）</li><li>然后可能穿越多个“国家”（不同的 AS）</li><li>各国海关（路由器）通过“国际条约”（BGP）决定包裹走向</li><li>有时通过“国际中转站”（IXP）快速转运到其他“国家”</li></ul></li><li><p>目的地配送：</p><ul><li><p>通过目的地“海关”（防火墙）入境检查</p></li><li><p>经过“分拣中心”（负载均衡器）分配处理人员</p></li><li><p>最终通过“本地快递员”（内部路由和交换）送达收件人手中</p></li></ul></li></ol><p>数据包就这样完成了客户端设备到服务器的全程旅行，然后服务器的响应再沿着类似的路径返回到客户端设备，完成整个请求-响应循环。</p><h1 id="参考">参考</h1><ul><li><p><ahref="https://time.geekbang.org/column/article/846257">极客时间《网络架构实战课》</a></p></li><li><p><ahref="https://www.geeksforgeeks.org/difference-between-osi-model-and-tcp-ip-model/">DifferenceBetween OSI Model and TCP/IP Model</a></p></li></ul>]]></content>
    
    
    <summary type="html">通过一个 HTTP 请求与响应，深入探索背后的网络通信机制，从 DNS 解析、TCP 连接到数据封装与传输，全面解析数据包如何穿越局域网与公网到达目标服务器。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>解决方案丨游戏后端中的 Push-ACK 机制设计与内存优化</title>
    <link href="https://hedon.top/2025/02/27/solution-push-ack/"/>
    <id>https://hedon.top/2025/02/27/solution-push-ack/</id>
    <published>2025-02-27T12:31:45.000Z</published>
    <updated>2025-03-03T11:53:53.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言">引言</h2><p>在现代在线游戏开发中，服务器与客户端之间实时、可靠的通信机制是游戏体验的基石。作为一名游戏后端开发者，我曾经遇到过这样的场景：更新了一个公会系统的新功能，服务器需要向成千上万个在线玩家推送公会状态变更。短短几小时后，服务器内存使用率飙升至90%，系统告警不断。问题出在哪里？Push消息的可靠性机制实现不当导致了内存泄漏。</p><p>本文将深入探讨游戏后端中 Push-ACK机制的设计与实现，特别关注如何避免内存暴涨问题，分享我在多个大型游戏项目中积累的经验与教训。</p><h2 id="背景为什么需要应用层的-ack-机制">背景：为什么需要应用层的 ACK机制？</h2><p>TCP协议确实提供了可靠的数据传输保证，包括数据包的序列号、校验和、超时重传等机制。那么，为什么我们还需要在应用层实现额外的ACK 机制呢？</p><h3 id="tcp-可靠性的边界">TCP 可靠性的边界</h3><p>TCP只能保证<strong>数据被送达到客户端的网络栈</strong>，但无法保证：</p><ol type="1"><li>数据被客户端应用程序正确处理</li><li>处理过程中没有出现异常</li><li>客户端的业务逻辑正确执行</li></ol><p>想象这样一个场景：服务器向玩家推送了一条"获得稀有装备"的消息，TCP确保了数据送达客户端，但如果客户端在处理这个消息时崩溃了呢？对于游戏这类状态敏感的应用，我们需要知道消息是否被<strong>成功处理</strong>，而不仅仅是<strong>成功传输</strong>。</p><h3 id="业务可靠性需求">业务可靠性需求</h3><p>实际游戏开发中，不同类型的消息有不同的可靠性需求：</p><table><thead><tr class="header"><th>消息类型</th><th>示例</th><th>可靠性需求</th></tr></thead><tbody><tr class="odd"><td>关键状态变更</td><td>道具获取、货币变化</td><td>极高（必须确认处理）</td></tr><tr class="even"><td>游戏进程通知</td><td>任务更新、成就解锁</td><td>高（需要确认）</td></tr><tr class="odd"><td>实时位置同步</td><td>玩家位置、NPC 移动</td><td>中（新数据可覆盖旧数据）</td></tr><tr class="even"><td>环境信息</td><td>天气变化、背景音乐</td><td>低（可接受偶尔丢失）</td></tr></tbody></table><h2 id="设计通用的-push-ack-机制">设计通用的 Push-ACK 机制</h2><p>一个完善的 Push-ACK机制需要考虑以下几个方面：消息唯一标识、优先级分级、超时重试、批量确认和失败处理。下面是基于Go 语言的设计实现：</p><h3 id="核心数据结构">核心数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Message 表示服务器推送的消息</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    MsgID        <span class="type">string</span>      <span class="string">`json:&quot;msg_id&quot;`</span>        <span class="comment">// 唯一消息标识</span></span><br><span class="line">    MsgType      <span class="type">string</span>      <span class="string">`json:&quot;msg_type&quot;`</span>      <span class="comment">// 消息类型</span></span><br><span class="line">    Timestamp    <span class="type">int64</span>       <span class="string">`json:&quot;timestamp&quot;`</span>     <span class="comment">// 发送时间戳</span></span><br><span class="line">    Priority     <span class="type">int</span>         <span class="string">`json:&quot;priority&quot;`</span>      <span class="comment">// 优先级：1-高，2-中，3-低</span></span><br><span class="line">    Payload      <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;payload&quot;`</span>       <span class="comment">// 消息内容</span></span><br><span class="line">    RequiresAck  <span class="type">bool</span>        <span class="string">`json:&quot;requires_ack&quot;`</span>  <span class="comment">// 是否需要确认</span></span><br><span class="line">    Expiration   <span class="type">int64</span>       <span class="string">`json:&quot;expiration&quot;`</span>    <span class="comment">// 过期时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AckMessage 表示客户端的确认消息</span></span><br><span class="line"><span class="keyword">type</span> AckMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">    AckID            <span class="type">string</span>  <span class="string">`json:&quot;ack_id&quot;`</span>           <span class="comment">// 对应原消息ID</span></span><br><span class="line">    Status           <span class="type">string</span>  <span class="string">`json:&quot;status&quot;`</span>           <span class="comment">// 状态：success/failed/partial</span></span><br><span class="line">    ClientTimestamp  <span class="type">int64</span>   <span class="string">`json:&quot;client_timestamp&quot;`</span> <span class="comment">// 客户端处理时间</span></span><br><span class="line">    ErrorCode        <span class="type">int</span>     <span class="string">`json:&quot;error_code&quot;`</span>       <span class="comment">// 错误码</span></span><br><span class="line">    ErrorMessage     <span class="type">string</span>  <span class="string">`json:&quot;error_message&quot;`</span>    <span class="comment">// 错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BatchAckMessage 表示批量确认消息</span></span><br><span class="line"><span class="keyword">type</span> BatchAckMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">    BatchAck        <span class="type">bool</span>     <span class="string">`json:&quot;batch_ack&quot;`</span>       <span class="comment">// 批量确认标志</span></span><br><span class="line">    AckIDs          []<span class="type">string</span> <span class="string">`json:&quot;ack_ids&quot;`</span>         <span class="comment">// 消息ID列表</span></span><br><span class="line">    Status          <span class="type">string</span>   <span class="string">`json:&quot;status&quot;`</span>          <span class="comment">// 状态</span></span><br><span class="line">    ClientTimestamp <span class="type">int64</span>    <span class="string">`json:&quot;client_timestamp&quot;`</span><span class="comment">// 确认时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PendingMessageInfo 表示等待确认的消息信息</span></span><br><span class="line"><span class="keyword">type</span> PendingMessageInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    ClientID    <span class="type">string</span>      <span class="comment">// 客户端ID</span></span><br><span class="line">    Message     *Message    <span class="comment">// 原始消息</span></span><br><span class="line">    SentTime    <span class="type">int64</span>       <span class="comment">// 发送时间</span></span><br><span class="line">    RetryCount  <span class="type">int</span>         <span class="comment">// 重试次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器端-push-管理器实现">服务器端 Push 管理器实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PushManager 负责管理推送消息和确认</span></span><br><span class="line"><span class="keyword">type</span> PushManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    pendingMessages    <span class="keyword">map</span>[<span class="type">string</span>]*PendingMessageInfo  <span class="comment">// 等待确认的消息</span></span><br><span class="line">    clientMessageCount <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>                  <span class="comment">// 每个客户端的消息数量</span></span><br><span class="line">    ackTimeout         <span class="type">int64</span>                           <span class="comment">// 确认超时时间(秒)</span></span><br><span class="line">    maxRetries         <span class="type">int</span>                             <span class="comment">// 最大重试次数</span></span><br><span class="line">    maxPendingPerClient <span class="type">int</span>                            <span class="comment">// 每客户端最大消息数</span></span><br><span class="line">    maxMessageAge      <span class="type">int64</span>                           <span class="comment">// 消息最大生存时间(秒)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存监控相关</span></span><br><span class="line">    memoryThresholdMB  <span class="type">int64</span>                           <span class="comment">// 内存阈值(MB)</span></span><br><span class="line">    criticalThresholdMB <span class="type">int64</span>                          <span class="comment">// 危险内存阈值(MB)</span></span><br><span class="line"></span><br><span class="line">    mutex              sync.RWMutex                    <span class="comment">// 保护并发访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网络接口（依赖外部实现）</span></span><br><span class="line">    networkLayer       NetworkInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPushManager 创建一个新的推送管理器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPushManager</span><span class="params">(networkLayer NetworkInterface)</span></span> *PushManager &#123;</span><br><span class="line">    pm := &amp;PushManager&#123;</span><br><span class="line">        pendingMessages:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*PendingMessageInfo),</span><br><span class="line">        clientMessageCount:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>),</span><br><span class="line">        ackTimeout:          <span class="number">10</span>,</span><br><span class="line">        maxRetries:          <span class="number">3</span>,</span><br><span class="line">        maxPendingPerClient: <span class="number">1000</span>,</span><br><span class="line">        maxMessageAge:       <span class="number">300</span>,</span><br><span class="line">        memoryThresholdMB:   <span class="number">1000</span>,  <span class="comment">// 1GB</span></span><br><span class="line">        criticalThresholdMB: <span class="number">1500</span>,  <span class="comment">// 1.5GB</span></span><br><span class="line">        networkLayer:        networkLayer,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动后台任务</span></span><br><span class="line">    <span class="keyword">go</span> pm.checkTimeoutsLoop()</span><br><span class="line">    <span class="keyword">go</span> pm.cleanupLoop()</span><br><span class="line">    <span class="keyword">go</span> pm.memoryMonitorLoop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushMessage 向客户端推送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> PushMessage(clientID <span class="type">string</span>, message *Message) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不需要确认，直接发送</span></span><br><span class="line">    <span class="keyword">if</span> !message.RequiresAck &#123;</span><br><span class="line">        <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查客户端消息数是否超限</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &gt;= pm.maxPendingPerClient &#123;</span><br><span class="line">        pm.handleQueueOverflow(clientID, message)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储待确认消息</span></span><br><span class="line">    pm.pendingMessages[message.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">        ClientID:    clientID,</span><br><span class="line">        Message:     message,</span><br><span class="line">        SentTime:    time.Now().Unix(),</span><br><span class="line">        RetryCount:  <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新客户端消息计数</span></span><br><span class="line">    pm.clientMessageCount[clientID]++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProcessAck 处理客户端的确认消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> ProcessAck(clientID <span class="type">string</span>, ack *AckMessage) <span class="type">bool</span> &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    info, exists := pm.pendingMessages[ack.AckID]</span><br><span class="line">    <span class="keyword">if</span> !exists || info.ClientID != clientID &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认成功，删除消息</span></span><br><span class="line">    <span class="built_in">delete</span>(pm.pendingMessages, ack.AckID)</span><br><span class="line">    pm.clientMessageCount[clientID]--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客户端没有待确认消息了，清理计数器</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProcessBatchAck 处理批量确认</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> ProcessBatchAck(clientID <span class="type">string</span>, batchAck *BatchAckMessage) <span class="type">int</span> &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    confirmedCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, ackID := <span class="keyword">range</span> batchAck.AckIDs &#123;</span><br><span class="line">        info, exists := pm.pendingMessages[ackID]</span><br><span class="line">        <span class="keyword">if</span> exists &amp;&amp; info.ClientID == clientID &#123;</span><br><span class="line">            <span class="built_in">delete</span>(pm.pendingMessages, ackID)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line">            confirmedCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客户端没有待确认消息了，清理计数器</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> confirmedCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台任务：超时检查与重试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> checkTimeoutsLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        pm.checkTimeouts()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时检查与重试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> checkTimeouts() &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    now := time.Now().Unix()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.pendingMessages &#123;</span><br><span class="line">        <span class="comment">// 检查是否超时</span></span><br><span class="line">        <span class="keyword">if</span> now - info.SentTime &gt; pm.ackTimeout &#123;</span><br><span class="line">            <span class="keyword">if</span> info.RetryCount &lt; pm.maxRetries &#123;</span><br><span class="line">                <span class="comment">// 增加重试次数</span></span><br><span class="line">                info.RetryCount++</span><br><span class="line">                info.SentTime = now</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新发送</span></span><br><span class="line">                pm.networkLayer.SendToClient(info.ClientID, info.Message)</span><br><span class="line">                log.Printf(<span class="string">&quot;Retrying message %s to client %s, attempt %d&quot;</span>,</span><br><span class="line">                          msgID, info.ClientID, info.RetryCount)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 超出最大重试次数，放弃并记录</span></span><br><span class="line">                log.Printf(<span class="string">&quot;Message %s to client %s failed after %d attempts&quot;</span>,</span><br><span class="line">                          msgID, info.ClientID, pm.maxRetries)</span><br><span class="line"></span><br><span class="line">                <span class="built_in">delete</span>(pm.pendingMessages, msgID)</span><br><span class="line">                pm.clientMessageCount[info.ClientID]--</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通知业务层处理失败</span></span><br><span class="line">                <span class="keyword">go</span> pm.notifyMessageFailed(info.ClientID, info.Message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决内存暴涨问题">解决内存暴涨问题</h2><p>在大型游戏中，服务器可能同时维护数十万甚至上百万个连接，如果每个连接都有数百条待确认消息，服务器内存很快就会爆满。以下是我在实践中总结的几种高效内存管理策略：</p><h3 id="周期性过期消息清理">1. 周期性过期消息清理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清理过期消息的后台循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> cleanupLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Minute)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        pm.cleanExpiredMessages()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理过期消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> cleanExpiredMessages() &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    now := time.Now().Unix()</span><br><span class="line">    expiredCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.pendingMessages &#123;</span><br><span class="line">        <span class="comment">// 检查消息是否过期</span></span><br><span class="line">        <span class="keyword">if</span> now - info.SentTime &gt; pm.maxMessageAge &#123;</span><br><span class="line">            <span class="built_in">delete</span>(pm.pendingMessages, msgID)</span><br><span class="line">            pm.clientMessageCount[info.ClientID]--</span><br><span class="line">            expiredCount++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">            log.Printf(<span class="string">&quot;Cleaned expired message %s to client %s (age: %d seconds)&quot;</span>,</span><br><span class="line">                      msgID, info.ClientID, now - info.SentTime)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> expiredCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Cleanup: Removed %d expired messages&quot;</span>, expiredCount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息压缩与合并">2. 消息压缩与合并</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompressMessage 压缩消息以减少内存占用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompressMessage</span><span class="params">(message *Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="comment">// 将消息转为JSON</span></span><br><span class="line">    jsonData, err := json.Marshal(message)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error marshaling message: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用gzip压缩</span></span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    writer := gzip.NewWriter(&amp;buf)</span><br><span class="line"></span><br><span class="line">    _, err = writer.Write(jsonData)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error compressing message: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := writer.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error closing gzip writer: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DecompressMessage 解压缩消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecompressMessage</span><span class="params">(compressed []<span class="type">byte</span>)</span></span> (*Message, <span class="type">error</span>) &#123;</span><br><span class="line">    reader, err := gzip.NewReader(bytes.NewReader(compressed))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;create gzip reader: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> reader.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(&amp;buf, reader); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;decompress data: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> message Message</span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(buf.Bytes(), &amp;message); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unmarshal json: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;message, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分级存储策略">3. 分级存储策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PushManager 增加分级存储功能</span></span><br><span class="line"><span class="keyword">type</span> PushManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ... 之前的字段 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存中存储高优先级消息</span></span><br><span class="line">    memoryPending     <span class="keyword">map</span>[<span class="type">string</span>]*PendingMessageInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis客户端，用于存储低优先级消息</span></span><br><span class="line">    redisClient      *redis.Client</span><br><span class="line">    redisKeyPrefix   <span class="type">string</span></span><br><span class="line">    redisExpiry      time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushMessage 分级存储版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> PushMessage(clientID <span class="type">string</span>, message *Message) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不需要确认，直接发送</span></span><br><span class="line">    <span class="keyword">if</span> !message.RequiresAck &#123;</span><br><span class="line">        <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查客户端消息数量限制</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &gt;= pm.maxPendingPerClient &#123;</span><br><span class="line">        pm.handleQueueOverflow(clientID, message)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm.clientMessageCount[clientID]++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据优先级选择存储位置</span></span><br><span class="line">    <span class="keyword">if</span> message.Priority &lt;= <span class="number">2</span> &#123; <span class="comment">// 高优先级和中优先级</span></span><br><span class="line">        <span class="comment">// 存入内存</span></span><br><span class="line">        pm.memoryPending[message.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">            ClientID:    clientID,</span><br><span class="line">            Message:     message,</span><br><span class="line">            SentTime:    time.Now().Unix(),</span><br><span class="line">            RetryCount:  <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 低优先级</span></span><br><span class="line">        <span class="comment">// 存入Redis</span></span><br><span class="line">        messageInfo := &amp;PendingMessageInfo&#123;</span><br><span class="line">            ClientID:    clientID,</span><br><span class="line">            Message:     message,</span><br><span class="line">            SentTime:    time.Now().Unix(),</span><br><span class="line">            RetryCount:  <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jsonData, err := json.Marshal(messageInfo)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error marshaling message: %v&quot;</span>, err)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        redisKey := pm.redisKeyPrefix + message.MsgID</span><br><span class="line">        err = pm.redisClient.Set(context.Background(), redisKey, jsonData, pm.redisExpiry).Err()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error storing message in Redis: %v&quot;</span>, err)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProcessAck 分级存储版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> ProcessAck(clientID <span class="type">string</span>, ack *AckMessage) <span class="type">bool</span> &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查内存中的消息</span></span><br><span class="line">    info, existsInMemory := pm.memoryPending[ack.AckID]</span><br><span class="line">    <span class="keyword">if</span> existsInMemory &amp;&amp; info.ClientID == clientID &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pm.memoryPending, ack.AckID)</span><br><span class="line">        pm.clientMessageCount[clientID]--</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再检查Redis中的消息</span></span><br><span class="line">    redisKey := pm.redisKeyPrefix + ack.AckID</span><br><span class="line">    exists, err := pm.redisClient.Exists(context.Background(), redisKey).Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error checking message in Redis: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> exists == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 获取消息以验证客户端ID</span></span><br><span class="line">        jsonData, err := pm.redisClient.Get(context.Background(), redisKey).Bytes()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error getting message from Redis: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> messageInfo PendingMessageInfo</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(jsonData, &amp;messageInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error unmarshaling message from Redis: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> messageInfo.ClientID == clientID &#123;</span><br><span class="line">            <span class="comment">// 从Redis删除并更新计数</span></span><br><span class="line">            pm.redisClient.Del(context.Background(), redisKey)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存自适应调整">4. 内存自适应调整</h3><p>内存自适应调整是我在实际项目中解决突发流量问题的关键策略。它能够根据当前系统负载动态调整消息处理参数，确保系统稳定性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存监控循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> memoryMonitorLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">10</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        memoryMB := pm.getMemoryUsageMB()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> memoryMB &gt; pm.criticalThresholdMB &#123;</span><br><span class="line">            <span class="comment">// 紧急情况，进行应急清理</span></span><br><span class="line">            pm.emergencyCleanup(memoryMB)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> memoryMB &gt; pm.memoryThresholdMB &#123;</span><br><span class="line">            <span class="comment">// 超过警戒线，调整参数</span></span><br><span class="line">            pm.adjustParameters(memoryMB)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前进程内存使用量（MB）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> getMemoryUsageMB() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> memStats runtime.MemStats</span><br><span class="line">    runtime.ReadMemStats(&amp;memStats)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(memStats.Alloc / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据内存使用情况调整参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> adjustParameters(currentMemoryMB <span class="type">int64</span>) &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算内存超出比例</span></span><br><span class="line">    excessRatio := <span class="type">float64</span>(currentMemoryMB - pm.memoryThresholdMB) / <span class="type">float64</span>(pm.memoryThresholdMB)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整每客户端最大消息数</span></span><br><span class="line">    newMaxPerClient := <span class="type">int</span>(<span class="type">float64</span>(pm.maxPendingPerClient) * (<span class="number">1</span> - excessRatio*<span class="number">0.5</span>))</span><br><span class="line">    <span class="keyword">if</span> newMaxPerClient &lt; <span class="number">100</span> &#123;</span><br><span class="line">        newMaxPerClient = <span class="number">100</span> <span class="comment">// 确保至少保留100条</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整消息最大生存时间</span></span><br><span class="line">    newMaxAge := <span class="type">int64</span>(<span class="type">float64</span>(pm.maxMessageAge) * (<span class="number">1</span> - excessRatio*<span class="number">0.5</span>))</span><br><span class="line">    <span class="keyword">if</span> newMaxAge &lt; <span class="number">60</span> &#123;</span><br><span class="line">        newMaxAge = <span class="number">60</span> <span class="comment">// 至少60秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新参数</span></span><br><span class="line">    pm.maxPendingPerClient = newMaxPerClient</span><br><span class="line">    pm.maxMessageAge = newMaxAge</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;Memory usage: %d MB, adjusted parameters: maxPending=%d, maxAge=%ds&quot;</span>,</span><br><span class="line">               currentMemoryMB, pm.maxPendingPerClient, pm.maxMessageAge)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一次清理</span></span><br><span class="line">    pm.cleanExpiredMessages()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧急清理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> emergencyCleanup(currentMemoryMB <span class="type">int64</span>) &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;CRITICAL: Memory usage at %d MB, performing emergency cleanup&quot;</span>, currentMemoryMB)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大幅降低参数</span></span><br><span class="line">    pm.maxPendingPerClient = <span class="number">100</span></span><br><span class="line">    pm.maxMessageAge = <span class="number">60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理低优先级消息</span></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.memoryPending &#123;</span><br><span class="line">        <span class="keyword">if</span> info.Message.Priority &gt; <span class="number">1</span> &#123; <span class="comment">// 只保留最高优先级</span></span><br><span class="line">            <span class="built_in">delete</span>(pm.memoryPending, msgID)</span><br><span class="line">            pm.clientMessageCount[info.ClientID]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;Emergency cleanup completed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列溢出处理策略">5. 队列溢出处理策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理队列溢出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> handleQueueOverflow(clientID <span class="type">string</span>, newMessage *Message) &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Queue overflow for client %s&quot;</span>, clientID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略1: 根据消息优先级决定是否替换现有消息</span></span><br><span class="line">    <span class="keyword">if</span> newMessage.Priority == <span class="number">1</span> &#123; <span class="comment">// 高优先级消息</span></span><br><span class="line">        <span class="comment">// 查找并替换该客户端的一条低优先级消息</span></span><br><span class="line">        <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.memoryPending &#123;</span><br><span class="line">            <span class="keyword">if</span> info.ClientID == clientID &amp;&amp; info.Message.Priority &gt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// 记录</span></span><br><span class="line">                log.Printf(<span class="string">&quot;Replacing low priority message %s with high priority message&quot;</span>, msgID)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 删除旧消息</span></span><br><span class="line">                <span class="built_in">delete</span>(pm.memoryPending, msgID)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加新消息</span></span><br><span class="line">                pm.memoryPending[newMessage.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">                    ClientID:    clientID,</span><br><span class="line">                    Message:     newMessage,</span><br><span class="line">                    SentTime:    time.Now().Unix(),</span><br><span class="line">                    RetryCount:  <span class="number">0</span>,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送新消息</span></span><br><span class="line">                pm.networkLayer.SendToClient(clientID, newMessage)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略2: 丢弃旧消息以腾出空间</span></span><br><span class="line">    <span class="comment">// 查找该客户端最旧的消息</span></span><br><span class="line">    <span class="keyword">var</span> oldestMsgID <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> oldestTime <span class="type">int64</span> = math.MaxInt64</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.memoryPending &#123;</span><br><span class="line">        <span class="keyword">if</span> info.ClientID == clientID &amp;&amp; info.SentTime &lt; oldestTime &#123;</span><br><span class="line">            oldestMsgID = msgID</span><br><span class="line">            oldestTime = info.SentTime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldestMsgID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Dropping oldest message %s for client %s&quot;</span>, oldestMsgID, clientID)</span><br><span class="line">        <span class="built_in">delete</span>(pm.memoryPending, oldestMsgID)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加新消息</span></span><br><span class="line">        pm.memoryPending[newMessage.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">            ClientID:    clientID,</span><br><span class="line">            Message:     newMessage,</span><br><span class="line">            SentTime:    time.Now().Unix(),</span><br><span class="line">            RetryCount:  <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送新消息</span></span><br><span class="line">        pm.networkLayer.SendToClient(clientID, newMessage)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 极端情况，无法找到可替换的消息</span></span><br><span class="line">        log.Printf(<span class="string">&quot;Cannot find message to replace for client %s&quot;</span>, clientID)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端实现">客户端实现</h2><p>客户端实现同样关键，特别是批量确认机制能显著减少网络流量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PushReceiver 客户端推送接收处理器</span></span><br><span class="line"><span class="keyword">type</span> PushReceiver <span class="keyword">struct</span> &#123;</span><br><span class="line">    connection        Connection          <span class="comment">// 网络连接接口</span></span><br><span class="line">    processedMsgIDs   <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>    <span class="comment">// 已处理消息ID及处理时间</span></span><br><span class="line">    pendingAcks       []<span class="type">string</span>            <span class="comment">// 待确认的消息ID</span></span><br><span class="line">    ackBatchSize      <span class="type">int</span>                 <span class="comment">// 批量确认大小</span></span><br><span class="line">    ackInterval       time.Duration       <span class="comment">// 批量确认间隔</span></span><br><span class="line">    messageHandlers   <span class="keyword">map</span>[<span class="type">string</span>]MessageHandler <span class="comment">// 消息处理函数</span></span><br><span class="line"></span><br><span class="line">    mutex             sync.Mutex          <span class="comment">// 保护并发访问</span></span><br><span class="line">    stopChan          <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;       <span class="comment">// 停止信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageHandler 消息处理函数类型</span></span><br><span class="line"><span class="keyword">type</span> MessageHandler <span class="function"><span class="keyword">func</span><span class="params">(payload <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPushReceiver 创建推送接收器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPushReceiver</span><span class="params">(conn Connection)</span></span> *PushReceiver &#123;</span><br><span class="line">    receiver := &amp;PushReceiver&#123;</span><br><span class="line">        connection:       conn,</span><br><span class="line">        processedMsgIDs:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>),</span><br><span class="line">        pendingAcks:      <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>),</span><br><span class="line">        ackBatchSize:     <span class="number">50</span>,</span><br><span class="line">        ackInterval:      time.Second,</span><br><span class="line">        messageHandlers:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]MessageHandler),</span><br><span class="line">        stopChan:         <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动批量确认任务</span></span><br><span class="line">    <span class="keyword">go</span> receiver.ackLoop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动过期消息ID清理任务</span></span><br><span class="line">    <span class="keyword">go</span> receiver.cleanupLoop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterHandler 注册消息处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> RegisterHandler(msgType <span class="type">string</span>, handler MessageHandler) &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    r.messageHandlers[msgType] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleMessage 处理收到的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> HandleMessage(message *Message) &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    msgID := message.MsgID</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已处理过该消息</span></span><br><span class="line">    <span class="keyword">if</span> _, exists := r.processedMsgIDs[msgID]; exists &#123;</span><br><span class="line">        <span class="comment">// 已处理过，再次发送确认</span></span><br><span class="line">        <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">            r.pendingAcks = <span class="built_in">append</span>(r.pendingAcks, msgID)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果积累的确认数量超过批量大小，立即发送</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(r.pendingAcks) &gt;= r.ackBatchSize &#123;</span><br><span class="line">                <span class="keyword">go</span> r.sendBatchAcks()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找处理函数</span></span><br><span class="line">    handler, exists := r.messageHandlers[message.MsgType]</span><br><span class="line">    <span class="keyword">if</span> !exists &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;No handler for message type: %s&quot;</span>, message.MsgType)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未知消息类型也需要确认</span></span><br><span class="line">        <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">            r.sendErrorAck(msgID, <span class="string">&quot;Unknown message type&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    err := handler(message.Payload)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error processing message %s: %v&quot;</span>, msgID, err)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">            r.sendErrorAck(msgID, err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录已处理的消息</span></span><br><span class="line">    r.processedMsgIDs[msgID] = time.Now().Unix()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要确认，加入待确认队列</span></span><br><span class="line">    <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">        r.pendingAcks = <span class="built_in">append</span>(r.pendingAcks, msgID)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果积累的确认数量超过批量大小，立即发送</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(r.pendingAcks) &gt;= r.ackBatchSize &#123;</span><br><span class="line">            <span class="keyword">go</span> r.sendBatchAcks()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送批量确认</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> sendBatchAcks() &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有待确认消息，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(r.pendingAcks) == <span class="number">0</span> &#123;</span><br><span class="line">        r.mutex.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制当前的待确认ID列表</span></span><br><span class="line">    ackIDs := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(r.pendingAcks))</span><br><span class="line">    <span class="built_in">copy</span>(ackIDs, r.pendingAcks)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空待确认列表</span></span><br><span class="line">    r.pendingAcks = r.pendingAcks[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建批量确认消息</span></span><br><span class="line">    batchAck := &amp;BatchAckMessage&#123;</span><br><span class="line">        BatchAck:        <span class="literal">true</span>,</span><br><span class="line">        AckIDs:          ackIDs,</span><br><span class="line">        Status:          <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        ClientTimestamp: time.Now().Unix(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送确认</span></span><br><span class="line">    r.connection.Send(batchAck)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送错误确认</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> sendErrorAck(msgID <span class="type">string</span>, errorMessage <span class="type">string</span>) &#123;</span><br><span class="line">    ack := &amp;AckMessage&#123;</span><br><span class="line">        AckID:           msgID,</span><br><span class="line">        Status:          <span class="string">&quot;failed&quot;</span>,</span><br><span class="line">        ClientTimestamp: time.Now().Unix(),</span><br><span class="line">        ErrorCode:       <span class="number">1001</span>,</span><br><span class="line">        ErrorMessage:    errorMessage,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.connection.Send(ack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量确认定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> ackLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(r.ackInterval)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            r.sendBatchAcks()</span><br><span class="line">        <span class="keyword">case</span> &lt;-r.stopChan:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理过期的已处理消息ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> cleanupLoop() &#123;</span><br><span class="line">    <span class="comment">// 每小时清理一次</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Hour)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            r.cleanupProcessedIDs()</span><br><span class="line">        <span class="keyword">case</span> &lt;-r.stopChan:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理过期的已处理消息ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> cleanupProcessedIDs() &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    now := time.Now().Unix()</span><br><span class="line">    expireTime := <span class="type">int64</span>(<span class="number">86400</span>) <span class="comment">// 24小时过期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, processTime := <span class="keyword">range</span> r.processedMsgIDs &#123;</span><br><span class="line">        <span class="keyword">if</span> now - processTime &gt; expireTime &#123;</span><br><span class="line">            <span class="built_in">delete</span>(r.processedMsgIDs, msgID)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭推送接收器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> Close() &#123;</span><br><span class="line">    <span class="comment">// 发送所有待确认消息</span></span><br><span class="line">    r.sendBatchAcks()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止所有后台任务</span></span><br><span class="line">    <span class="built_in">close</span>(r.stopChan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战经验与最佳实践">实战经验与最佳实践</h2><p>在多个千万用户级别的游戏项目实践中，我总结了以下几点 Push-ACK机制的最佳实践：</p><h3 id="消息分级是关键">1. 消息分级是关键</h3><p>不是所有消息都需要相同级别的可靠性保证。在一个 MMORPG项目中，我们将消息分为四级：</p><ul><li><strong>关键级</strong>：直接影响游戏平衡和经济的消息，如道具获取、货币变化</li><li><strong>重要级</strong>：影响游戏进程的消息，如任务更新、排行榜变动</li><li><strong>普通级</strong>：一般游戏状态信息，如其他玩家动作、环境变化</li><li><strong>低优先级</strong>：可以容忍丢失的背景信息，如聊天、天气效果</li></ul><p>高级别消息使用完整的 ACK 机制，低级别消息可以简化甚至取消 ACK需求，这样大大减轻了服务器内存压力。</p><h3 id="利用统计指标进行调优">2. 利用统计指标进行调优</h3><p>监控以下关键指标：</p><ul><li>ACK 响应时间分布</li><li>消息重试率</li><li>每客户端平均待确认消息数</li><li>内存使用增长曲线</li></ul><p>在一个足球经理类游戏中，通过这些指标我们发现，将 ACK 超时时间从 10秒调整到 5 秒，并将最大重试次数从 3 次增加到 5次，可以将消息最终确认率从 99.2%提高到 99.8%，同时减少了25%的内存使用。</p><h3 id="针对不同网络环境优化">3. 针对不同网络环境优化</h3><p>移动网络环境差异很大，针对不同网络条件动态调整策略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据网络条件调整参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> adjustForNetworkCondition(clientID <span class="type">string</span>, rtt time.Duration) &#123;</span><br><span class="line">    <span class="comment">// 网络条件良好</span></span><br><span class="line">    <span class="keyword">if</span> rtt &lt; <span class="number">100</span>*time.Millisecond &#123;</span><br><span class="line">        pm.clientTimeouts[clientID] = <span class="number">3</span> <span class="comment">// 3秒超时</span></span><br><span class="line">        pm.clientRetries[clientID] = <span class="number">2</span>  <span class="comment">// 2次重试</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> rtt &lt; <span class="number">300</span>*time.Millisecond &#123;</span><br><span class="line">        pm.clientTimeouts[clientID] = <span class="number">5</span> <span class="comment">// 5秒超时</span></span><br><span class="line">        pm.clientRetries[clientID] = <span class="number">3</span>  <span class="comment">// 3次重试</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pm.clientTimeouts[clientID] = <span class="number">10</span> <span class="comment">// 10秒超时</span></span><br><span class="line">        pm.clientRetries[clientID] = <span class="number">5</span>   <span class="comment">// 5次重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定期压力测试">4. 定期压力测试</h3><p>在一个大型开放世界游戏中，我们每月进行一次"混沌测试"，模拟极端情况：</p><ol type="1"><li>突发 50%客户端同时掉线然后重连</li><li>模拟网络延迟突然从 50ms 增加到 500ms</li><li>模拟 10%的确认消息丢失</li></ol><p>这种测试让我们发现了很多边缘情况，并建立了更健壮的防御机制。</p><h2 id="结论">结论</h2><p>一个设计良好的 Push-ACK机制是现代游戏服务器架构的核心组件。它确保了游戏状态的一致性，提升了玩家体验，同时也为运营团队提供了可靠的数据基础。最重要的是，它必须是高性能且资源友好的。</p><p>通过采用本文介绍的多级存储、自适应参数调整、消息优先级和过期策略等技术，我们可以构建一个既可靠又高效的推送确认系统，即使在面对数十万并发</p>]]></content>
    
    
    <summary type="html">本文介绍了游戏后端中的 Push-ACK 机制的设计与实现，特别关注如何避免内存暴涨问题，分享了在多个大型游戏项目中积累的经验与教训。</summary>
    
    
    
    <category term="解决方案" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="游戏后端" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%B8%B8%E6%88%8F%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="解决方案" scheme="https://hedon.top/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="游戏后端" scheme="https://hedon.top/tags/%E6%B8%B8%E6%88%8F%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Push-Ack" scheme="https://hedon.top/tags/Push-Ack/"/>
    
  </entry>
  
  <entry>
    <title>服务监控丨Prometheus 四大数据类型详解</title>
    <link href="https://hedon.top/2025/02/26/prometheus-data-type/"/>
    <id>https://hedon.top/2025/02/26/prometheus-data-type/</id>
    <published>2025-02-26T07:52:10.000Z</published>
    <updated>2025-03-03T11:53:59.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在微服务和云原生架构的世界中，一套强大的监控系统是保障服务稳定性的基石。Prometheus作为 CNCF的明星项目，凭借其简单高效的特性，已成为事实上的云原生监控标准。本文将深入剖析Prometheus 的四大数据类型及其 PromQL查询语言，帮助开发团队构建强大的可观测性系统。</p><h2 id="结论先行prometheus-四大数据类型速览">结论先行：Prometheus四大数据类型速览</h2><table style="width:100%;"><colgroup><col style="width: 12%" /><col style="width: 22%" /><col style="width: 19%" /><col style="width: 19%" /><col style="width: 26%" /></colgroup><thead><tr class="header"><th>特性</th><th>Counter</th><th>Gauge</th><th>Histogram</th><th>Summary</th></tr></thead><tbody><tr class="odd"><td><strong>定义</strong></td><td>只增不减的累积计数器</td><td>可增可减的瞬时值</td><td>观测值分布的分桶统计</td><td>客户端计算的分位数统计</td></tr><tr class="even"><td><strong>重置行为</strong></td><td>服务重启时归零</td><td>保持当前值</td><td>桶计数归零</td><td>计数归零</td></tr><tr class="odd"><td><strong>典型应用</strong></td><td>请求计数、错误数、流量统计</td><td>温度、内存使用、连接数</td><td>请求延迟、响应大小</td><td>请求延迟、队列等待时间</td></tr><tr class="even"><td><strong>数据点</strong></td><td>单一值</td><td>单一值</td><td>_bucket、_sum、count</td><td>{quantile="x"}、_sum、_count</td></tr><tr class="odd"><td><strong>查询重点</strong></td><td>rate()、increase()</td><td>直接使用、预测函数</td><td>histogram_quantile()</td><td>直接读取分位数</td></tr><tr class="even"><td><strong>分布式聚合</strong></td><td>可以（sum、rate）</td><td>可以（avg、max、min）</td><td>可以（百分位也可聚合）</td><td>有限（分位数不可聚合）</td></tr><tr class="odd"><td><strong>资源消耗</strong></td><td>低</td><td>低</td><td>中（依赖桶数量）</td><td>中（客户端计算）</td></tr></tbody></table><h2 id="一prometheus-核心数据类型详解">一、Prometheus核心数据类型详解</h2><h3 id="counter计数器持续增长的累积值">1.Counter（计数器）：持续增长的累积值</h3><p>Counter是最简单但也最常用的指标类型，代表一个只增不减的累积数值。每当事件发生，计数器增加；当监控目标重启时，计数器归零。</p><p><strong>适用场景</strong>：</p><ul><li>API 请求总数</li><li>错误发生次数</li><li>处理任务的数量</li><li>网络流量字节数</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的计数器</span></span><br><span class="line">requestCounter := prometheus.NewCounterVec(</span><br><span class="line">    prometheus.CounterOpts&#123;</span><br><span class="line">        Name: <span class="string">&quot;http_requests_total&quot;</span>,</span><br><span class="line">        Help: <span class="string">&quot;Total number of HTTP requests&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;method&quot;</span>, <span class="string">&quot;path&quot;</span>, <span class="string">&quot;status&quot;</span>&#125;, <span class="comment">// 定义标签维度</span></span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(requestCounter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用标签记录请求</span></span><br><span class="line">requestCounter.WithLabelValues(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>, <span class="string">&quot;200&quot;</span>).Inc()</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 每秒请求率（5分钟窗口）</span><br><span class="line">rate(http_requests_total&#123;status=&quot;200&quot;&#125;[5m])</span><br><span class="line"></span><br><span class="line"># 错误率计算</span><br><span class="line">sum(rate(http_requests_total&#123;status=~&quot;5..&quot;&#125;[5m])) / sum(rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># 1小时内的请求增量</span><br><span class="line">increase(http_requests_total[1h])</span><br></pre></td></tr></table></figure><p><strong>最佳实践</strong>：</p><ul><li>永远不要直接使用 Counter 的原始值，总是使用 <code>rate()</code> 或<code>increase()</code></li><li>使用有意义的标签进行多维度分析，但避免高基数标签</li><li>Counter 重置（如服务重启）会被 <code>rate()</code> 函数自动处理</li></ul><h3 id="gauge仪表盘可变的瞬时值">2. Gauge（仪表盘）：可变的瞬时值</h3><p>Gauge 表示一个可增可减的瞬时测量值，反映系统的当前状态。</p><p><strong>适用场景</strong>：</p><ul><li>内存使用量</li><li>CPU 使用率</li><li>当前活跃连接数</li><li>队列深度</li><li>温度等物理量</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的仪表盘</span></span><br><span class="line">memoryGauge := prometheus.NewGaugeVec(</span><br><span class="line">    prometheus.GaugeOpts&#123;</span><br><span class="line">        Name: <span class="string">&quot;app_memory_usage_bytes&quot;</span>,</span><br><span class="line">        Help: <span class="string">&quot;Current memory usage in bytes&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;component&quot;</span>, <span class="string">&quot;instance&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(memoryGauge)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前值</span></span><br><span class="line">memoryGauge.WithLabelValues(<span class="string">&quot;api-server&quot;</span>, <span class="string">&quot;instance-1&quot;</span>).Set(<span class="type">float64</span>(getCurrentMemoryUsage()))</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 直接使用当前值</span><br><span class="line">app_memory_usage_bytes&#123;component=&quot;api-server&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 统计聚合</span><br><span class="line">avg_over_time(app_memory_usage_bytes[1h])</span><br><span class="line">max_over_time(app_memory_usage_bytes[24h])</span><br><span class="line"></span><br><span class="line"># 趋势预测（线性回归）</span><br><span class="line">predict_linear(app_memory_usage_bytes[6h], 4 * 3600)</span><br><span class="line"></span><br><span class="line"># 计算变化率</span><br><span class="line">(app_memory_usage_bytes - app_memory_usage_bytes offset 1h) / app_memory_usage_bytes offset 1h</span><br></pre></td></tr></table></figure><p><strong>最佳实践</strong>：</p><ul><li>Gauge 可以直接使用其瞬时值，不需要像 Counter 那样使用 rate</li><li>对于容易波动的指标，考虑使用 <code>avg_over_time</code>平滑数据</li><li>利用 <code>predict_linear</code> 进行容量规划和趋势预测</li></ul><h3 id="histogram直方图观测值分布的分桶统计">3.Histogram（直方图）：观测值分布的分桶统计</h3><p>Histogram允许对观测值（如请求延迟）进行分布式统计，将数据分散到预定义的桶中，是分析性能分布的理想工具。</p><p><strong>自动生成的指标</strong>：</p><ul><li><code>&lt;metric&gt;_bucket&#123;le="&lt;upper bound&gt;"&#125;</code>:小于等于特定阈值的观测值计数</li><li><code>&lt;metric&gt;_sum</code>: 所有观测值的总和</li><li><code>&lt;metric&gt;_count</code>: 观测值总数</li></ul><p><strong>适用场景</strong>：</p><ul><li>请求延迟分布</li><li>响应大小分布</li><li>批处理任务执行时间</li><li>任何需要百分位数分析的场景</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的直方图</span></span><br><span class="line">durationHistogram := prometheus.NewHistogramVec(</span><br><span class="line">    prometheus.HistogramOpts&#123;</span><br><span class="line">        Name:    <span class="string">&quot;http_request_duration_seconds&quot;</span>,</span><br><span class="line">        Help:    <span class="string">&quot;HTTP request duration in seconds&quot;</span>,</span><br><span class="line">        Buckets: prometheus.ExponentialBuckets(<span class="number">0.001</span>, <span class="number">2</span>, <span class="number">10</span>), <span class="comment">// 从1ms开始指数增长</span></span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;method&quot;</span>, <span class="string">&quot;path&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(durationHistogram)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录请求延迟</span></span><br><span class="line">durationHistogram.WithLabelValues(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>).Observe(responseTime)</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 计算平均响应时间</span><br><span class="line">rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])</span><br><span class="line"></span><br><span class="line"># 计算P90延迟</span><br><span class="line">histogram_quantile(0.9, rate(http_request_duration_seconds_bucket[5m]))</span><br><span class="line"></span><br><span class="line"># 按API路径分析P95延迟</span><br><span class="line">histogram_quantile(0.95, sum by(path, le) (rate(http_request_duration_seconds_bucket[5m])))</span><br><span class="line"></span><br><span class="line"># 计算SLO：延迟小于100ms的请求比例</span><br><span class="line">sum(rate(http_request_duration_seconds_bucket&#123;le=&quot;0.1&quot;&#125;[5m])) / sum(rate(http_request_duration_seconds_count[5m]))</span><br></pre></td></tr></table></figure><p><strong>最佳实践</strong>：</p><ul><li>仔细设计桶边界，覆盖关键分位数区域</li><li>对于延迟指标，通常使用指数桶比线性桶更合理</li><li>利用 <code>histogram_quantile</code> 计算任意分位数</li><li>桶的数量会影响存储和性能，权衡精度和开销</li></ul><h3 id="summary摘要客户端计算的分位数统计">4.Summary（摘要）：客户端计算的分位数统计</h3><p>Summary 与 Histogram类似，但在客户端直接计算并存储分位数，无需服务器端计算。</p><p><strong>自动生成的指标</strong>：</p><ul><li><code>&lt;metric&gt;&#123;quantile="&lt;φ&gt;"&#125;</code>: φ 分位数的值</li><li><code>&lt;metric&gt;_sum</code>: 所有观测值的总和</li><li><code>&lt;metric&gt;_count</code>: 观测值总数</li></ul><p><strong>适用场景</strong>：</p><ul><li>需要高精度分位数的场景</li><li>客户端计算分位数更高效的情况</li><li>对服务器端聚合要求不高的场景</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的摘要</span></span><br><span class="line">durationSummary := prometheus.NewSummaryVec(</span><br><span class="line">    prometheus.SummaryOpts&#123;</span><br><span class="line">        Name:       <span class="string">&quot;http_request_duration_seconds_summary&quot;</span>,</span><br><span class="line">        Help:       <span class="string">&quot;HTTP request duration in seconds&quot;</span>,</span><br><span class="line">        Objectives: <span class="keyword">map</span>[<span class="type">float64</span>]<span class="type">float64</span>&#123;<span class="number">0.5</span>: <span class="number">0.05</span>, <span class="number">0.9</span>: <span class="number">0.01</span>, <span class="number">0.99</span>: <span class="number">0.001</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;method&quot;</span>, <span class="string">&quot;path&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(durationSummary)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录请求延迟</span></span><br><span class="line">durationSummary.WithLabelValues(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/api/login&quot;</span>).Observe(responseTime)</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 直接读取P99延迟</span><br><span class="line">http_request_duration_seconds_summary&#123;quantile=&quot;0.99&quot;, method=&quot;GET&quot;, path=&quot;/api/users&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 计算平均响应时间</span><br><span class="line">rate(http_request_duration_seconds_summary_sum[5m]) / rate(http_request_duration_seconds_summary_count[5m])</span><br><span class="line"></span><br><span class="line"># 每个服务的中位数延迟</span><br><span class="line">max by(service) (http_request_duration_seconds_summary&#123;quantile=&quot;0.5&quot;&#125;)</span><br></pre></td></tr></table></figure><p><strong>最佳实践与限制</strong>：</p><ul><li>Summary 预计算的分位数不能跨实例聚合（这是关键限制）</li><li>适用于分位数精度要求高且实例相对独立的场景</li><li>客户端计算分位数会增加应用资源消耗</li><li>分位数设置后不可更改，需提前规划好监控需求</li></ul><h2 id="二promql-查询语言精通">二、PromQL 查询语言精通</h2><p>PromQL 是 Prometheus的强大武器，掌握它能让我们精确提取所需的监控数据。</p><h3 id="基础查询与标签选择">1. 基础查询与标签选择</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 基本查询与精确匹配</span><br><span class="line">http_requests_total&#123;status=&quot;200&quot;, method=&quot;GET&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 正则表达式匹配</span><br><span class="line">http_requests_total&#123;path=~&quot;/api/v1/.+&quot;, method!=&quot;OPTIONS&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 范围查询（返回时间序列）</span><br><span class="line">http_requests_total&#123;status=&quot;500&quot;&#125;[5m]</span><br></pre></td></tr></table></figure><h3 id="操作符与函数">2. 操作符与函数</h3><p><strong>算术运算符</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 计算内存使用率百分比</span><br><span class="line">100 * (node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes</span><br></pre></td></tr></table></figure><p><strong>聚合函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 按服务和路径分组求和</span><br><span class="line">sum by(service, path) (rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># 丢弃instance标签求最大值</span><br><span class="line">max without(instance) (node_cpu_seconds_total)</span><br></pre></td></tr></table></figure><p><strong>瞬时向量函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 标签替换</span><br><span class="line">label_replace(up, &quot;host&quot;, &quot;$1&quot;, &quot;instance&quot;, &quot;(.*):.*&quot;)</span><br><span class="line"></span><br><span class="line"># 按标签分组取topk</span><br><span class="line">topk by(path) (5, http_request_duration_seconds_sum / http_request_duration_seconds_count)</span><br></pre></td></tr></table></figure><h3 id="复杂查询模式">3. 复杂查询模式</h3><p><strong>SLI/SLO 监控</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 服务可用性SLI</span><br><span class="line">sum(rate(http_requests_total&#123;status=~&quot;2..|3..&quot;&#125;[5m])) / sum(rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># 延迟SLO</span><br><span class="line">histogram_quantile(0.99, sum by(le) (rate(http_request_duration_seconds_bucket[5m]))) &lt; 0.3</span><br></pre></td></tr></table></figure><p><strong>异常检测</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 相对于历史同期的异常增长</span><br><span class="line">rate(http_requests_total[5m])</span><br><span class="line">  &gt; 2 * avg_over_time(rate(http_requests_total[5m])[1d:5m] offset 1d)</span><br></pre></td></tr></table></figure><p><strong>预测分析</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 磁盘空间预测</span><br><span class="line">predict_linear(node_filesystem_free_bytes&#123;mountpoint=&quot;/&quot;&#125;[6h], 7 * 24 * 3600) &lt; 10 * 1024 * 1024 * 1024</span><br></pre></td></tr></table></figure><h2 id="三实战应用场景">三、实战应用场景</h2><h3 id="服务健康度监控">1. 服务健康度监控</h3><p><strong>RED 方法实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Rate - 请求率</span><br><span class="line">sum by(service) (rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># Error - 错误率</span><br><span class="line">sum by(service) (rate(http_requests_total&#123;status=~&quot;5..&quot;&#125;[5m])) / sum by(service) (rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># Duration - P95延迟</span><br><span class="line">histogram_quantile(0.95, sum by(service, le) (rate(http_request_duration_seconds_bucket[5m])))</span><br></pre></td></tr></table></figure><p><strong>服务依赖健康度</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 数据库查询错误率</span><br><span class="line">sum(rate(database_query_errors_total[5m])) / sum(rate(database_queries_total[5m]))</span><br><span class="line"></span><br><span class="line"># 第三方API调用延迟</span><br><span class="line">histogram_quantile(0.99, sum by(api_name, le) (rate(api_request_duration_seconds_bucket[5m])))</span><br></pre></td></tr></table></figure><h3 id="性能瓶颈分析">2. 性能瓶颈分析</h3><p><strong>热点 API 发现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 延迟最高的10个接口</span><br><span class="line">topk(10,</span><br><span class="line">  histogram_quantile(0.95, sum by(method, path, le) (rate(http_request_duration_seconds_bucket[5m])))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 请求量最大的接口</span><br><span class="line">topk(10, sum by(method, path) (rate(http_requests_total[5m])))</span><br></pre></td></tr></table></figure><p><strong>数据库性能分析</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 平均查询时间趋势</span><br><span class="line">rate(db_query_duration_seconds_sum[5m]) / rate(db_query_duration_seconds_count[5m])</span><br><span class="line"></span><br><span class="line"># 慢查询比例</span><br><span class="line">sum(rate(db_query_duration_seconds_bucket&#123;le=&quot;+Inf&quot;&#125;[5m])) - sum(rate(db_query_duration_seconds_bucket&#123;le=&quot;0.1&quot;&#125;[5m])) / sum(rate(db_query_duration_seconds_bucket&#123;le=&quot;+Inf&quot;&#125;[5m]))</span><br></pre></td></tr></table></figure><h3 id="容量规划与告警">3. 容量规划与告警</h3><p><strong>资源预测</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># CPU使用率预测</span><br><span class="line">predict_linear(avg by(instance) (rate(node_cpu_seconds_total&#123;mode!=&quot;idle&quot;&#125;[6h])) [3d:], 7 * 24 * 3600) &gt; 0.85</span><br><span class="line"></span><br><span class="line"># 内存压力告警</span><br><span class="line">(node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes &gt; 0.9</span><br></pre></td></tr></table></figure><p><strong>流量容量规划</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 带宽使用预测</span><br><span class="line">predict_linear(rate(node_network_transmit_bytes_total[12h])[7d:], 30 * 24 * 3600)</span><br></pre></td></tr></table></figure><h2 id="四最佳实践与性能优化">四、最佳实践与性能优化</h2><h3 id="指标命名与标签设计">1. 指标命名与标签设计</h3><p><strong>命名规范</strong>：</p><ul><li>使用 snake_case</li><li>包含单位后缀（_bytes, _seconds, _total）</li><li>保持风格一致性</li></ul><p><strong>标签最佳实践</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合理设计标签维度</span></span><br><span class="line">apiLatency := prometheus.NewHistogramVec(</span><br><span class="line">    prometheus.HistogramOpts&#123;</span><br><span class="line">        Name:    <span class="string">&quot;api_request_duration_seconds&quot;</span>,</span><br><span class="line">        Help:    <span class="string">&quot;API request duration in seconds&quot;</span>,</span><br><span class="line">        Buckets: prometheus.ExponentialBuckets(<span class="number">0.001</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;service&quot;</span>, <span class="string">&quot;endpoint&quot;</span>, <span class="string">&quot;status_code&quot;</span>&#125;, <span class="comment">// 合理的低基数标签</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变标签使用ConstLabels</span></span><br><span class="line">prometheus.NewGaugeVec(</span><br><span class="line">    prometheus.GaugeOpts&#123;</span><br><span class="line">        Name:        <span class="string">&quot;service_info&quot;</span>,</span><br><span class="line">        Help:        <span class="string">&quot;Service information&quot;</span>,</span><br><span class="line">        ConstLabels: prometheus.Labels&#123;<span class="string">&quot;version&quot;</span>: <span class="string">&quot;v2.1.3&quot;</span>, <span class="string">&quot;environment&quot;</span>: <span class="string">&quot;production&quot;</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;instance&quot;</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="客户端性能优化">2. 客户端性能优化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存常用标签组合以提高性能</span></span><br><span class="line">getCounter := requestCounter.WithLabelValues(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>, <span class="string">&quot;200&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    getCounter.Inc() <span class="comment">// 重用标签组合，避免重复创建</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量更新方式</span></span><br><span class="line"><span class="keyword">var</span> rpcDurations = prometheus.NewSummaryVec(</span><br><span class="line">    prometheus.SummaryOpts&#123;</span><br><span class="line">        Name:       <span class="string">&quot;rpc_durations_seconds&quot;</span>,</span><br><span class="line">        Help:       <span class="string">&quot;RPC latency distributions.&quot;</span>,</span><br><span class="line">        Objectives: <span class="keyword">map</span>[<span class="type">float64</span>]<span class="type">float64</span>&#123;<span class="number">0.5</span>: <span class="number">0.05</span>, <span class="number">0.9</span>: <span class="number">0.01</span>, <span class="number">0.99</span>: <span class="number">0.001</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;service&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ObserveBatch</span><span class="params">(durations <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> service, duration := <span class="keyword">range</span> durations &#123;</span><br><span class="line">        rpcDurations.WithLabelValues(service).Observe(duration)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询优化">3. 查询优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 优化前：高基数查询</span><br><span class="line">sum(rate(http_requests_total&#123;path=~&quot;/api/.*&quot;&#125;[5m])) by (path, method, status)</span><br><span class="line"></span><br><span class="line"># 优化后：降低基数，按需聚合</span><br><span class="line">sum(rate(http_requests_total&#123;path=~&quot;/api/.*&quot;&#125;[5m])) by (method, status)</span><br><span class="line"></span><br><span class="line"># 优化聚合顺序（先聚合再求和）</span><br><span class="line">sum(</span><br><span class="line">  avg by(instance) (rate(node_cpu_seconds_total&#123;mode!=&quot;idle&quot;&#125;[5m]))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="五常见陷阱与解决方案">五、常见陷阱与解决方案</h2><h3 id="高基数问题">1. 高基数问题</h3><p><strong>问题</strong>：标签组合过多导致时间序列爆炸<strong>解决方案</strong>：</p><ul><li>限制标签基数，避免使用 UserID、SessionID 等作为标签</li><li>使用<code>label_replace</code>和正则表达式转换高基数标签</li><li>考虑使用 Exemplars 而非标签存储高基数数据</li></ul><h3 id="数据类型选择误区">2. 数据类型选择误区</h3><p><strong>Counter vs Gauge</strong>：请求数应使用 Counter 而非 Gauge<strong>Histogram vs Summary</strong>：需要聚合分析请使用Histogram，精确分位数可选 Summary</p><h3 id="查询性能问题">3. 查询性能问题</h3><p><strong>问题</strong>：复杂查询导致 Prometheus 高负载<strong>解决方案</strong>：</p><ul><li>使用记录规则预计算常用查询</li><li>合理设置 scrape 间隔，避免过度采集</li><li>对高请求量接口使用客户端聚合</li></ul><h2 id="总结与展望">总结与展望</h2><p>Prometheus 的四种数据类型各有所长：Counter 适合累积事件计数，Gauge适合瞬时状态测量，Histogram 适合分布统计和百分位分析，Summary适合客户端精确分位数计算。与之配合的 PromQL提供了强大的数据查询和分析能力，共同构成了完整的监控解决方案。</p><p>随着云原生技术的发展，Prometheus 生态也在不断壮大，与Grafana、Alertmanager、Thanos等工具集成，能够构建更完善的监控告警平台。在微服务架构中，结合RED（Rate、Error、Duration）和USE（Utilization、Saturation、Errors）方法论，可以构建全面的可观测性系统。</p><p>无论你是刚开始使用 Prometheus的新手，还是寻求优化监控系统的资深工程师，希望本文对你理解和应用Prometheus有所帮助。记住，好的监控不仅能及时发现问题，更能预测和防范问题，最终服务于业务可靠性和用户体验的提升。</p><hr /><p><em>参考资源:</em></p><ul><li>Prometheus 官方文档: https://prometheus.io/docs/</li><li>Google SRE 书籍:https://sre.google/sre-book/monitoring-distributed-systems/</li><li>Prometheus 实战: https://prometheusbook.com/</li></ul>]]></content>
    
    
    <summary type="html">本文介绍了 Prometheus 的四大数据类型及其 PromQL 查询语言，帮助开发团队构建强大的可观测性系统。</summary>
    
    
    
    <category term="服务监控" scheme="https://hedon.top/categories/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
    
    <category term="服务监控" scheme="https://hedon.top/tags/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
    <category term="prometheus" scheme="https://hedon.top/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>在 Go 项目中实现 JWT 用户认证与续期机制</title>
    <link href="https://hedon.top/2025/02/15/go-action-jwt/"/>
    <id>https://hedon.top/2025/02/15/go-action-jwt/</id>
    <published>2025-02-15T15:28:10.000Z</published>
    <updated>2025-03-06T11:02:36.692Z</updated>
    
    <content type="html"><![CDATA[<p>JWT (JSON Web Token)是一种广泛使用的用户认证方案，因其无状态、跨域支持和灵活性而受到欢迎。本文将结合实际代码，详细讲解如何在Go 项目中实现 JWT 认证机制，并探讨两种常见的 Token 续期策略：自动续期和Refresh Token。</p><h2 id="jwt-基础概念">1. JWT 基础概念</h2><p>JWT 由三部分组成：Header、Payload 和 Signature。使用 JWT进行登录认证的基本工作流程是：</p><ol type="1"><li>用户登录成功后，服务器生成 JWT。</li><li>服务器将 token 返回给客户端。</li><li>客户端后续请求携带 token。</li><li>服务器验证 token 的有效性。</li></ol><p>我们可以在 https://jwt.io/ 网站对 JWT进行分析，查看其具体的组成成分。</p><h2 id="基本准备">2. 基本准备</h2><p>在本篇，我们将使用 Go 语言，通过一个完整的案例实现在 HTTP接口中，使用 JWT 进行用户登录和认证流程。本文假设读者已掌握基本的 Go语言语法和网络编程经验，并对 <ahref="https://github.com/gin-gonic/gin">Gin</a> 框架有基本的了解。</p><p>为了快速响应失败，本文案例中使用了封装好的异常处理机制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrUser = errors.New(<span class="string">&quot;&quot;</span>)</span><br><span class="line">ErrSys  = errors.New(<span class="string">&quot;&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户侧错误，会直接将错误内容返回给用户，不打印日志。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserErr</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w%v&quot;</span>, ErrUser, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserErrf</span><span class="params">(format <span class="type">string</span>, a ...any)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w%v&quot;</span>, ErrUser, fmt.Sprintf(format, a...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义系统内部错误，会固定返回 internal server error 给用户，但是会将原始错误信息输出到日志中，便于内部排查。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SystemErr</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w%v&quot;</span>, ErrSys, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SystemErrf</span><span class="params">(format <span class="type">string</span>, a ...any)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w%v&quot;</span>, ErrSys, fmt.Sprintf(format, a...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GinErr</span><span class="params">(c *gin.Context, req any, err <span class="type">error</span>, msgs ...<span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrUser) &#123;</span><br><span class="line">c.JSON(http.StatusOK, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg := <span class="string">&quot;internal server error&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(msgs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">msg = msgs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">slog.Error(msg,</span><br><span class="line">slog.Any(<span class="string">&quot;req&quot;</span>, req),</span><br><span class="line">slog.String(<span class="string">&quot;err&quot;</span>, err.Error()),</span><br><span class="line">)</span><br><span class="line">c.JSON(http.StatusOK, <span class="string">&quot;internal server error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现用户认证">3. 实现用户认证</h2><p>在进行实际代码编写之前，你需要先初始化好项目并引入 <code>jwt</code>依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang-jwt/jwt/v5</span><br></pre></td></tr></table></figure><p>在代码中使用的时候，可以：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/golang-jwt/jwt/v5&quot;</span></span><br></pre></td></tr></table></figure><p>那接下来我们就正式开始我们的功能实现。</p><h3 id="定义-claims-结构">3.1 定义 Claims 结构</h3><p>首先，我们需要定义 JWT 的载荷（Payload）结构，即决定将什么信息存储在token 当中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">    jwt.RegisteredClaims</span><br><span class="line">    UserID    <span class="type">uint64</span> <span class="string">`json:&quot;user_id&quot;`</span>    <span class="comment">// 用户ID</span></span><br><span class="line">    UserAgent <span class="type">string</span> <span class="string">`json:&quot;user_agent&quot;`</span>  <span class="comment">// 用户设备信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们：</p><ul><li><p>组合了 <code>jwt.RegisteredClaims</code>，它包含了标准的 JWT字段（如过期时间），帮助我们实现了 <code>jwt.Clamis</code> 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Claims <span class="keyword">interface</span> &#123;</span><br><span class="line">GetExpirationTime() (*NumericDate, <span class="type">error</span>)</span><br><span class="line">GetIssuedAt() (*NumericDate, <span class="type">error</span>)</span><br><span class="line">GetNotBefore() (*NumericDate, <span class="type">error</span>)</span><br><span class="line">GetIssuer() (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">GetSubject() (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">GetAudience() (ClaimStrings, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jwt.RegisteredClaims</code> 的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RegisteredClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">Issuer <span class="type">string</span> <span class="string">`json:&quot;iss,omitempty&quot;`</span></span><br><span class="line">Subject <span class="type">string</span> <span class="string">`json:&quot;sub,omitempty&quot;`</span></span><br><span class="line">Audience ClaimStrings <span class="string">`json:&quot;aud,omitempty&quot;`</span></span><br><span class="line">ExpiresAt *NumericDate <span class="string">`json:&quot;exp,omitempty&quot;`</span></span><br><span class="line">NotBefore *NumericDate <span class="string">`json:&quot;nbf,omitempty&quot;`</span></span><br><span class="line">IssuedAt *NumericDate <span class="string">`json:&quot;iat,omitempty&quot;`</span></span><br><span class="line">ID <span class="type">string</span> <span class="string">`json:&quot;jti,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetExpirationTime() (*NumericDate, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.ExpiresAt, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetNotBefore() (*NumericDate, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.NotBefore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetIssuedAt() (*NumericDate, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.IssuedAt, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetAudience() (ClaimStrings, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.Audience, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetIssuer() (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.Issuer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetSubject() (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.Subject, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加了自定义字段 <code>UserID</code> 和 <code>UserAgent</code>用于安全控制。你可以根据自己的业务需求，添加任意非敏感信息到这个结构中。</p></li></ul><h3 id="登录接口实现">3.2 登录接口实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   AccessTokenDuration = time.Minute * <span class="number">15</span></span><br><span class="line">   RefreshTokenDuration = time.Hour * <span class="number">24</span> * <span class="number">7</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> LoginJWT(ctx *gin.Context) &#123;</span><br><span class="line">    <span class="comment">// 1. 校验用户信息，在本案例中，使用邮箱加密码进行登录</span></span><br><span class="line">    user, err := u.svc.Login(ctx.Request.Context(), req.Email, req.Password)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, req, utils.UserErr(err), <span class="string">&quot;login failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建 JWT Claims</span></span><br><span class="line">    accessClaims := UserClaims&#123;</span><br><span class="line">        UserID:    user.ID,</span><br><span class="line">        UserAgent: ctx.Request.UserAgent(),</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(AccessTokenDuration)), <span class="comment">// 15分钟过期</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 生成 Access Token</span></span><br><span class="line">    accessToken := jwt.NewWithClaims(jwt.SigningMethodHS512, accessClaims)</span><br><span class="line">    accessTokenStr, err := accessToken.SignedString(AccessTokenKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, req, utils.SystemErr(err), <span class="string">&quot;generate access token failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 生成 Refresh Token，用于 Token 续期</span></span><br><span class="line">    refreshClaims := RefreshClaims&#123;</span><br><span class="line">        UserID:    user.ID,</span><br><span class="line">        UserAgent: ctx.Request.UserAgent(),</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(RefreshTokenDuration)), <span class="comment">// 7天过期</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS512, refreshClaims)</span><br><span class="line">    refreshTokenStr, err := refreshToken.SignedString(RefreshTokenKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, req, utils.SystemErr(err), <span class="string">&quot;generate refresh token failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 返回两个 token</span></span><br><span class="line">    ctx.Header(<span class="string">&quot;x-jwt-token&quot;</span>, accessTokenStr)</span><br><span class="line">    ctx.Header(<span class="string">&quot;x-refresh-token&quot;</span>, refreshTokenStr)</span><br><span class="line">    ctx.JSON(http.StatusOK, <span class="string">&quot;login success&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jwt-中间件实现">3.3 JWT 中间件实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LoginJWTMiddlewareBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">whiteList []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLoginJWTMiddlewareBuilder</span><span class="params">()</span></span> *LoginJWTMiddlewareBuilder &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;LoginJWTMiddlewareBuilder&#123;</span><br><span class="line">whiteList: []<span class="type">string</span>&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *LoginJWTMiddlewareBuilder)</span></span> IgnorePaths(paths ...<span class="type">string</span>) *LoginJWTMiddlewareBuilder &#123;</span><br><span class="line">b.whiteList = <span class="built_in">append</span>(b.whiteList, paths...)</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *LoginJWTMiddlewareBuilder)</span></span> Build() gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 1. 提取 token</span></span><br><span class="line">        authCode := ctx.GetHeader(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">        tokenStr := strings.TrimPrefix(authCode, <span class="string">&quot;Bearer &quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 解析和验证 token</span></span><br><span class="line">        uc := web.UserClaims&#123;&#125;</span><br><span class="line">        token, err := jwt.ParseWithClaims(tokenStr, &amp;uc, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> web.AccessTokenKey, <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 验证 token 有效性</span></span><br><span class="line">        <span class="keyword">if</span> token == <span class="literal">nil</span> || !token.Valid &#123;</span><br><span class="line">            ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 验证 UserAgent</span></span><br><span class="line">        <span class="keyword">if</span> uc.UserAgent != ctx.Request.UserAgent() &#123;</span><br><span class="line">            ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 设置用户信息到上下文</span></span><br><span class="line">        ctx.Set(<span class="string">&quot;user_id&quot;</span>, uc.UserID)</span><br><span class="line">      ctx.Set(<span class="string">&quot;claims&quot;</span>, uc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册中间件">3.4 注册中间件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initWebServer</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">server := gin.Default()</span><br><span class="line"></span><br><span class="line">server.Use(</span><br><span class="line">middleware.CORS(),</span><br><span class="line">middleware.NewLoginJWTMiddlewareBuilder().</span><br><span class="line">IgnorePaths(<span class="string">&quot;/users/signup&quot;</span>).</span><br><span class="line">IgnorePaths(<span class="string">&quot;/users/login&quot;</span>).</span><br><span class="line">Build(),</span><br><span class="line">)</span><br><span class="line">web.RegisterRoutes(server)</span><br><span class="line"><span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRoutes</span><span class="params">(server *gin.Engine)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">userHandler.RegisterRoutes(server)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> RegisterRoutes(server *gin.Engine) &#123;</span><br><span class="line">  ur := server.Group(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">  ur.POST(<span class="string">&quot;/login&quot;</span>, u.LoginJWT)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在其他接口中使用-token-的相关信息">4. 在其他接口中使用 Token的相关信息</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> Profile(ctx *gin.Context) &#123;</span><br><span class="line">  <span class="comment">// 可以获取 user_id</span></span><br><span class="line">userID := ctx.GetUint64(<span class="string">&quot;user_id&quot;</span>)</span><br><span class="line">  <span class="comment">// 也可以直接获取整个 claims。</span></span><br><span class="line">  <span class="comment">// 这里我们可以选择不进行断言，因为理论上我们的可以保证这里通过断言。</span></span><br><span class="line">  <span class="comment">// 如果这里发生 panic 了，则说明我们的内部逻辑没有形成闭环，存在问题。</span></span><br><span class="line">  <span class="comment">// panic 可以第一时间暴露问题，然后被解决掉。</span></span><br><span class="line">  <span class="comment">// 不过这个时候建议你使用 gin 的 recover 中间件进行全局保护，避免整个服务因为 panic 而宕机。</span></span><br><span class="line">  uc, _ := ctx.Get(<span class="string">&quot;claims&quot;</span>)</span><br><span class="line">userClaims := uc.(*UserClaims)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="refresh-token-机制">5. Refresh Token 机制</h2><h3 id="添加刷新-token-接口">5.1 添加刷新 Token 接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> RefreshToken(ctx *gin.Context) &#123;</span><br><span class="line">    <span class="comment">// 从请求头获取 Refresh Token</span></span><br><span class="line">    refreshTokenStr := ctx.GetHeader(<span class="string">&quot;x-refresh-token&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> refreshTokenStr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析和验证 Refresh Token</span></span><br><span class="line">    <span class="keyword">var</span> refreshClaims RefreshClaims</span><br><span class="line">    refreshToken, err := jwt.ParseWithClaims(refreshTokenStr, &amp;refreshClaims, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> RefreshTokenKey, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !refreshToken.Valid &#123;</span><br><span class="line">        ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证 User Agent</span></span><br><span class="line">    <span class="keyword">if</span> refreshClaims.UserAgent != ctx.Request.UserAgent() &#123;</span><br><span class="line">        ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成新的 Access Token</span></span><br><span class="line">    accessClaims := UserClaims&#123;</span><br><span class="line">        UserID:    refreshClaims.UserID,</span><br><span class="line">        UserAgent: ctx.Request.UserAgent(),</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(AccessTokenDuration)),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    newAccessToken := jwt.NewWithClaims(jwt.SigningMethodHS512, accessClaims)</span><br><span class="line">    newAccessTokenStr, err := newAccessToken.SignedString(AccessTokenKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, <span class="literal">nil</span>, utils.SystemErr(err), <span class="string">&quot;generate new access token failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 Refresh Token 进行续期</span></span><br><span class="line">  refreshClaims := RefreshClaims&#123;</span><br><span class="line">        UserID:    user.ID,</span><br><span class="line">        UserAgent: ctx.Request.UserAgent(),</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(RefreshTokenDuration)), <span class="comment">// 7天过期</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    newRefreshToken := jwt.NewWithClaims(jwt.SigningMethodHS512, refreshClaims)</span><br><span class="line">    newRefreshTokenStr, err := newRefreshToken.SignedString(RefreshTokenKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, req, utils.SystemErr(err), <span class="string">&quot;generate new refresh token failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新的 Access Token 和续期后的 Refresh Token</span></span><br><span class="line">    ctx.Header(<span class="string">&quot;x-jwt-token&quot;</span>, newAccessTokenStr)</span><br><span class="line">   ctx.Header(<span class="string">&quot;x-refresh-token&quot;</span>, newRefreshTokenStr)</span><br><span class="line">    ctx.JSON(http.StatusOK, <span class="string">&quot;token refreshed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册路由">5.2 注册路由</h3><p>在 <code>RegisterRoutes</code> 方法中添加新路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> RegisterRoutes(server *gin.Engine) &#123;</span><br><span class="line">  ur := server.Group(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">  ur.POST(<span class="string">&quot;/login&quot;</span>, u.LoginJWT)</span><br><span class="line">  ur.GET(<span class="string">&quot;/profile&quot;</span>, u.Profile)</span><br><span class="line">  ur.POST(<span class="string">&quot;/refresh&quot;</span>, u.RefreshToken)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端使用流程">6. 客户端使用流程</h2><ol type="1"><li>登录后获取 Access Token 和 Refresh Token</li><li>使用 Access Token 访问受保护资源</li><li>当 Access Token 过期时调用 /refresh 接口获取新的 Access Token</li><li>使用新的 Access Token 继续访问</li></ol><p>刷新 token 的客户端示例代码（笔者并不擅长写前端代码 hhh，所以这是让ChatGPT 帮忙写的 😄）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">async function refreshAccessToken() &#123;</span><br><span class="line">    <span class="keyword">const</span> response = await fetch(<span class="string">&#x27;/users/refresh&#x27;</span>, &#123;</span><br><span class="line">        method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">&#x27;x-refresh-token&#x27;</span>: localStorage.getItem(<span class="string">&#x27;refreshToken&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">        <span class="keyword">const</span> newAccessToken = response.headers.get(<span class="string">&#x27;x-jwt-token&#x27;</span>);</span><br><span class="line">        localStorage.setItem(<span class="string">&#x27;accessToken&#x27;</span>, newAccessToken);</span><br><span class="line">        <span class="keyword">const</span> newRefreshToken = response.headers.get(<span class="string">&#x27;x-refresh-token&#x27;</span>);</span><br><span class="line">        localStorage.setItem(<span class="string">&#x27;refreshToken&#x27;</span>, newRefreshToken);</span><br><span class="line">        <span class="keyword">return</span> newAccessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果刷新失败，重定向到登录页</span></span><br><span class="line">    window.location.href = <span class="string">&#x27;/login&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="token-续期策略对比">7. Token 续期策略对比</h2><p>在前面案例中，细心的读者可以观察到我们对 <code>AccessToken</code> 和<code>RefreshToken</code> 分别采用了 2 种不同的续期策略。</p><h3 id="自动续期">自动续期</h3><p><strong>优点：</strong></p><ul><li>简单易用：在每次请求时自动检查并续期 Token，用户体验流畅。</li><li>无额外存储需求：不需要存储 RefreshToken，减少了存储和管理的复杂性</li></ul><p><strong>缺点：</strong></p><ul><li>安全性较低：如果 Token被盗用，攻击者可以通过自动续期保持长时间的访问。</li><li>Token 过期时间不固定：Token 的有效期会不断延长，难以控制。</li></ul><h3 id="refresh-token">Refresh Token</h3><p><strong>优点：</strong></p><ul><li>更高的安全性：即使 Access Token被盗用，攻击者也无法续期，除非同时获取 Refresh Token。</li><li>可控的 Token 生命周期：Access Token 有固定的短期有效期，RefreshToken 有较长的有效期。</li><li>支持 Token 撤销：可以实现 Refresh Token的黑名单机制，支持手动撤销。</li></ul><p><strong>缺点：</strong></p><ul><li>实现复杂度较高：需要额外的接口和逻辑来处理 Refresh Token。</li><li>存储需求：需要安全存储 Refresh Token，可能需要数据库支持。</li></ul><h2 id="总结">8. 总结</h2><p>JWT 实现用户认证的优势在于无状态、跨域支持和灵活性。通过合理使用 JWT和选择合适的 Token续期策略，我们可以构建安全、可靠的用户认证系统。希望本文能帮助您在 Go项目中更好地实现 JWT 认证。</p>]]></content>
    
    
    <summary type="html">本文将结合实际代码，详细讲解如何在 Go 项目中实现 JWT 认证机制，并探讨两种常见的 Token 续期策略：自动续期和 Refresh Token。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="Go 实战" scheme="https://hedon.top/categories/Go/Go-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="JWT" scheme="https://hedon.top/tags/JWT/"/>
    
    <category term="Go 实战" scheme="https://hedon.top/tags/Go-%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>深入 Go 语言核心：map 和 slice 的传参有什么不同</title>
    <link href="https://hedon.top/2025/02/14/go-slice-vs-map/"/>
    <id>https://hedon.top/2025/02/14/go-slice-vs-map/</id>
    <published>2025-02-14T07:34:05.000Z</published>
    <updated>2025-03-06T10:35:35.891Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 开发中，经常会遇到需要在函数中修改 map 或 slice的场景。虽然它们都支持动态扩容，但在函数传参时的行为却大不相同。今天，让我们通过实例深入理解这个问题。</p><h2 id="一个困惑的开始">一个困惑的开始</h2><p>看这样一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Map 示例</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;old&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    modifyMap(m)</span><br><span class="line">    fmt.Println(m) <span class="comment">// 输出: map[new:1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slice 示例</span></span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    modifySlice(s)</span><br><span class="line">    fmt.Println(s) <span class="comment">// 输出: [100 2 3]，而不是 [100 2 3 200]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyMap</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;new&quot;</span>] = <span class="number">1</span>        <span class="comment">// 会影响原始 map</span></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">&quot;old&quot;</span>)    <span class="comment">// 也会影响原始 map</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">100</span>          <span class="comment">// 会影响原始 slice</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">200</span>)  <span class="comment">// 不会影响原始 slice</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有趣的是：</p><ol type="1"><li>map 的所有操作都会影响原始数据</li><li>slice 的简单索引修改会影响原始数据，但 append 可能不会</li></ol><p>为什么会这样？让我们从内部结构开始分析。</p><h2 id="内部结构解析">内部结构解析</h2><h3 id="map-的内部结构">Map 的内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count      <span class="type">int</span>            <span class="comment">// 元素个数</span></span><br><span class="line">    flags      <span class="type">uint8</span>          <span class="comment">// 状态标志</span></span><br><span class="line">    B          <span class="type">uint8</span>          <span class="comment">// 桶的对数 B</span></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 指向桶数组的指针</span></span><br><span class="line">    <span class="comment">// ... 其他字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们声明一个 map 变量时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 实际上 m 是 *hmap，即指向 hmap 结构的指针</span></span><br></pre></td></tr></table></figure><h3 id="slice-的内部结构">Slice 的内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer  <span class="comment">// 指向底层数组的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span>            <span class="comment">// 当前长度</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span>            <span class="comment">// 当前容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们声明一个 slice 变量时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// s 是一个完整的 slice 结构体，而不是指针</span></span><br></pre></td></tr></table></figure><h2 id="深入理解传参行为">深入理解传参行为</h2><h3 id="场景一简单修改不涉及扩容">场景一：简单修改（不涉及扩容）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyBoth</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span>   <span class="comment">// 通过指针修改原始 map</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">100</span>     <span class="comment">// 通过指向相同底层数组的指针修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map:</span><br><span class="line">main()中的 m  -----&gt; hmap&#123;...&#125;  &lt;----- modifyBoth()中的 m</span><br><span class="line">(同一个底层结构)</span><br><span class="line"></span><br><span class="line">Slice:</span><br><span class="line">main()中的 s      = slice&#123;array: 指向数组1, len: 3, cap: 3&#125;</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                        [1 2 3]</span><br><span class="line">                           ^</span><br><span class="line">modifyBoth()中的 s = slice&#123;array: 指向数组1, len: 3, cap: 3&#125;</span><br></pre></td></tr></table></figure><h3 id="场景二涉及扩容的操作">场景二：涉及扩容的操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expandBoth</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// map 扩容</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        m[fmt.Sprintf(<span class="string">&quot;key%d&quot;</span>, i)] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slice 扩容</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Map 扩容过程：</span><br><span class="line">Before:</span><br><span class="line">main()中的 m  -----&gt; hmap&#123;buckets: 指向存储A&#125;</span><br><span class="line">                           ^</span><br><span class="line">expandBoth()中的 m ---------|</span><br><span class="line"></span><br><span class="line">After:</span><br><span class="line">main()中的 m  -----&gt; hmap&#123;buckets: 指向更大的存储B&#125;  // 同一个 hmap，只是更新了内部指针</span><br><span class="line">                           ^</span><br><span class="line">expandBoth()中的 m ---------|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Slice 扩容过程：</span><br><span class="line">Before:</span><br><span class="line">main()中的 s      = slice&#123;array: 指向数组A, len: 3, cap: 3&#125;</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                        [1 2 3]</span><br><span class="line">                           ^</span><br><span class="line">expandBoth()中的 s = slice&#123;array: 指向数组A, len: 3, cap: 3&#125;</span><br><span class="line"></span><br><span class="line">After append:</span><br><span class="line">main()中的 s      = slice&#123;array: 指向数组A, len: 3, cap: 3&#125;     // 保持不变</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                        [1 2 3]</span><br><span class="line"></span><br><span class="line">expandBoth()中的 s = slice&#123;array: 指向数组B, len: 4, cap: 6&#125;    // 新的结构体，指向新数组</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                     [1 2 3 200]</span><br></pre></td></tr></table></figure><h2 id="关键区别解析">关键区别解析</h2><ol type="1"><li><p><strong>传递方式不同</strong>：</p><ul><li>map 传递的是指针，函数内外使用的是同一个 hmap 结构</li><li>slice 传递的是结构体副本，函数内的修改发生在副本上</li></ul></li><li><p><strong>扩容行为不同</strong>：</p><ul><li>map 扩容时，原有的 hmap 结构保持不变，只更新内部的 buckets 指针</li><li>slice 扩容时，会创建新的底层数组，并返回一个指向新数组的新 slice结构体</li></ul></li><li><p><strong>修改效果不同</strong>：</p><ul><li>map 的所有操作（包括扩容）都会反映到原始数据</li><li>slice 的行为分两种情况：<ul><li>不涉及扩容的修改会影响原始数据（因为指向同一个底层数组）</li><li>涉及扩容的操作（如append）会创建新的底层数组，修改不会影响原始数据</li></ul></li></ul></li></ol><h2 id="最佳实践">最佳实践</h2><p>基于以上原理，在编码时应注意：</p><ol type="1"><li>对于 map：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyMap</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span>    <span class="comment">// 直接修改即可，不需要返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>对于 slice：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 如果需要 append 或其他可能导致扩容的操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line">s = modifySlice(s)</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>理解 map 和 slice 的这些差异，关键在于：</p><ol type="1"><li>map 是指针类型，始终指向同一个 hmap 结构</li><li>slice 是结构体，包含了指向底层数组的指针</li><li>扩容时 map 只更新内部指针，而 slice 需要创建新的底层数组</li></ol><p>这种设计各有优势：</p><ul><li>map 的行为更加统一和直观</li><li>slice 的设计提供了更多的灵活性和控制权</li></ul><p>在实际编程中，正确理解和处理这些差异，是写出健壮 Go 代码的关键。</p>]]></content>
    
    
    <summary type="html">本文通过一个令人困惑的例子开始，探讨 Go 语言中 map 和 slice 动态扩容机制与传参时需要注意的问题。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨解密 QUIC/HTTP3：未来互联网的基石</title>
    <link href="https://hedon.top/2025/01/15/book-quic-http3/"/>
    <id>https://hedon.top/2025/01/15/book-quic-http3/</id>
    <published>2025-01-15T11:17:20.000Z</published>
    <updated>2025-03-17T11:42:00.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="quic-产生背景">1. QUIC 产生背景</h1><h2 id="常见网络协议">常见网络协议</h2><ul><li><code>UDP</code></li><li><code>TCP</code></li><li><code>SCTP</code>（Stream Control TransmissionProtocol）：用于电话网络。</li><li><code>KCP</code>：基于 UDP在应用层实现可靠性传输，牺牲带宽换取效率。</li><li><code>RTP</code>（Real-time Transport Protocol）：与 RTCP配合传输实时数据，如交互式音频和视频数据。<ul><li>RTCP：传输控制信息</li><li>RTP：传输实时数据</li></ul></li></ul><h2 id="tsl-版本演化">TSL 版本演化</h2><ul><li><p><code>SSLv2</code>：安全性低</p></li><li><p><code>SSLv3</code>：分为握手阶段和数据传输阶段。</p><ul><li>握手阶段完成对端点的认证和确定保护数据传输的密钥。</li><li>一旦确定了密钥，后面的数据传输和SSL协议过程都受到加密和完整性保护。</li></ul></li><li><p><code>TSL1.0</code>：基于 SSLv3，存在 CBC（Cipher BlockChaining，密文分组链接）加密和解密模式漏洞，使得主动攻击者可以观察到当前记录的IV（IntiallizationVector，初始化向量），猜测一个数据库，进行数据注入。</p></li><li><p><code>TSL1.1</code>：修复了 TSL1.0 的一些关键安全问题：</p><ul><li>BC 加密使用每条记录一个的显式IV；</li><li>为了防止 CBC 填充攻击，使用 bad_record_mac 错误码代替decryption_failed 回复填充错误；</li><li>支持传输参数的IANA（Internet Assigned NumbersAuthority，互联网数字分配机构）注册，增加了传输参数的灵活性；</li><li>改进了连接关闭过早情况下的连接恢复问题。</li></ul><p>有些加密算法还是存在安全漏洞，使用的 MD5 也不安全。</p></li><li><p><code>TSL1.2</code>：主要关注了架构灵活性和安全问题。</p><ul><li>架构：<ul><li>客户端可以指定自己支持的签名和 hash 算法列表；</li><li>支持非协议固定的算法；</li></ul></li><li>安全：<ul><li>增加了对 AEAD（Authenticated Encryption with Associated Data关联数据认证加密）的支持，可以在加密中认证没有加密部分的关键数据，甚至是不在报文中的关键数据，可以保护更大的范围。</li><li>规定必须实现密码套件 TLS_RSA_WITH_AES_128_CBC_SHA。</li><li>增加了 HMAC-SHA256 密码套件。</li><li>删除了包含已废弃算法的 IDEA 和 DES 密码套件。</li><li>对 EncryptedPreMasterSecret 版本号进行了更严格的检查。</li></ul></li></ul></li><li><p><code>TSL1.3</code>：除了增加安全性，重点改进了连接速度，首次连接发送数据最低可以1-RTT，恢复连接发送数据最低可以 0-RTT。</p><ul><li>安全：<ul><li>删除了所有被证明有问题的对称加密算法，只保留了 AEAD的加密套件。密码套件的概念也已经改变，将认证和密钥交换机制与加密算法和散列（用于密钥导出函数和握手消息认证码）分离。</li><li>删除 RSA 和静态 DH 密码套件，因为静态 RSA加密预主密钥的方式和使用静态 DH私钥都不能保证前向安全性，很容易泄露密钥。只保留能保证前向安全的密钥交换算法，如使用临时私钥的ECDHE（Elliptic Curve Diffie-Hellman Ephemeral，椭圆曲线 DH临时密钥交换算法）和 DHE（Diffie-Hellman Ephemeral, DH临时密钥交换算法）。</li><li>ServerHello 之后的消息都加密传输。</li><li>删除了压缩功能。之前版本的压缩功能由于存在被攻击的风险实际上很少使用，而且现代的压缩基本都在应用层实现，比如HTTP就自己实现的压缩。</li></ul></li></ul></li></ul><h2 id="http-版本演化">HTTP 版本演化</h2><ul><li><p><code>HTTP0.9</code>：仅支持简单的请求响应，只能访问<strong>简单的文本</strong>文档。</p></li><li><p><code>HTTP1.0</code>：HTTP1中引入了<strong>请求头和响应头</strong>，请求时可以指定 HTTP版本号、用户代理、接收类型等，响应可以指明响应状态、内容长度、内容类型等。</p></li><li><p><code>HTTP1.1</code>：增加了<strong>重用 TCP连接</strong>（keep-alive）的方法，默认保持连接，除非显式通知关闭连接[插图]。这样可以在一个TCP 连接上完成多个请求-响应，消除了 TCP 建立的延迟，也避免了新建立的 TCP连接的慢启动过程。</p><ul><li>HTTP1.1 在 HTTP 请求首部中增加了 Host 字段，用来支持共享 IP地址的虚拟主机服务器。</li><li>同时支持了更多的方法，如 PUT、PATCH、DELETE、OPTIONS。</li><li>引入分块传输支持动态内容。</li><li>引入了更多的缓存控制策略。</li><li>支持请求部分内容。</li></ul></li><li><p><code>HTTP2</code>：修改了 HTTP1.1的封装格式，增加了一个二进制分帧层。基于二进制分层，HTTP2 实现了 HTTP的<strong>多路复用</strong>。HTTP2为每个请求分配了一个流标识，服务器响应时带上相同的流标识，客户端就可以方便地将响应与请求关联起来，而不用依赖顺序，从而可以降低延迟和提高吞吐量。</p><ul><li>HTTP2 还增加了首部压缩 HPACK（Header Compression for HTTP2，HTTP2首部压缩算法）。</li><li>支持请求优先级。</li><li>支持服务器主动推送。</li><li>增加了 ALPN（Application-Layer ProtocolNegotiation，应用层协议协商）。</li><li>支持认证、加密和完整性保护，即 <code>HTTPS</code>。</li></ul><p>但多个请求或响应在同一个 TCP 上发送时，仍然受制于 TCP的队首阻塞问题。</p></li><li><p><code>HTTP3</code>：基于 <code>QUIC</code> 协议，底层使用 UDP实现，摆脱了 TCP 的队首阻塞问题。同时改进了 TCP中存在的一些其他问题，比如拥塞控制、协议僵化、启动慢、重连慢、安全弱等。</p><ul><li>实现了没有队首阻塞的并发。如果 QUIC丢了一个报文，仅仅影响对应流的交付，不会阻塞其他流。</li><li>与 TLS1.3 紧密合作，尽可能的加密。还增加了 QUIC报文的首部加密，除保证了报文安全性，提高了攻击门槛，还避免了协议僵化。</li><li>选择 UDP 作为底层实现。一方面避免了 TCP的首部阻塞，另一方面互联网中绝大部分的主机和中间件都是 TCP 和 UDP的天下，所以天然支持。</li><li>用户态实现。不依赖于内核，容易单独升级。</li><li>低延迟的建立。实现了首次最低 1-RTT发送应用数据，恢复连接时发送应用数据最低只需 0-RTT。</li><li>无缝的连接迁移。QUIC 的连接基于连接标识，改变 IP 或者 UDP端口号并不影响连接的识别，因此可以实现无缝的连接迁移。但是负载均衡就麻烦了。</li><li>改进的流量控制。</li><li>协议行为作为负载。</li></ul></li></ul><h1 id="quic-报文">2. QUIC 报文</h1><ul><li>长首部报文：用于建立 QUIC 连接和建立连接前发送应用数据。</li><li>短首部报文：用于在 QUIC 连接建立后发送应用数据和 QUIC协议内容。</li><li>无状态重置报文：当服务器丢失了连接状态但仍然收到该连接的数据包时，可以发送无状态重置报文通知客户端立即终止连接。</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250122195252117.png"alt="QUIC 报文类型" /><figcaption aria-hidden="true">QUIC 报文类型</figcaption></figure><p>初始报文：客户端使用初始报文来发起连接，服务器使用初始报文和握手报文回应客户端的请求。</p><p>0-RTT 报文：用于承载 QUIC连接之前想要发送的数据，一般用于恢复连接后立即发送数据。</p><p>握手报文：用来携带服务器和客户端的 TLS 加密握手信息和确认，载荷一般是CRYPTO 帧和 ACK 帧。</p><p>重试报文：是服务器用来验证客户端地址的报文，可以防止源地址欺骗。</p><blockquote><p>服务器使用重试报文通知客户端按照要求重新发送初始报文，在重试报文中携带重试令牌给客户端，并使用服务器选择的连接标识作为重试报文的源连接标识；客户端需要使用服务器指定的连接标识作为目的连接标识，携带服务器指定的重试令牌，构建新的初始报文，重新发送给服务器。</p></blockquote><p>版本协商报文：当服务器收到包含自己不支持的版本号的初始报文时，就会发送版本协商报文。客户端收到版本协商报文后需要在其中选择一个自己支持的版本号，重新以新版本号发送初始报文。</p><p>短首部报文：一般也叫作 1-RTT 报文，连接在协商出 1-RTT密钥后就可以发送短首部报文，用于携带应用数据。</p>]]></content>
    
    
    <summary type="html">整理阅读《解密 QUIC/HTTP3：未来互联网的基石》笔记。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="QUIC" scheme="https://hedon.top/tags/QUIC/"/>
    
    <category term="HTTP3" scheme="https://hedon.top/tags/HTTP3/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>匠心码道丨01 编写优质代码的十大黄金法则</title>
    <link href="https://hedon.top/2024/12/12/clean-code-10-rules/"/>
    <id>https://hedon.top/2024/12/12/clean-code-10-rules/</id>
    <published>2024-12-12T02:22:49.000Z</published>
    <updated>2025-03-03T11:54:14.961Z</updated>
    
    <content type="html"><![CDATA[<p>代码质量的优劣直接影响着项目的可维护性和团队的开发效率。一个经验丰富的开发者不仅要能实现功能，更要善于编写清晰易懂、结构合理的代码。本文将介绍10 条帮助你编写清晰、易维护且可扩展代码的重要规则。</p><h1 id="规则">规则</h1><h2 id="使用有意义的变量和函数名称">1. 使用有意义的变量和函数名称</h2><p>变量、函数和类的命名应该具有描述性和意义。你的代码应该能够清晰地表达其意图，而无需额外的注释来解释。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> api.<span class="title function_">get</span>();</span><br><span class="line"><span class="keyword">const</span> arr = users.<span class="title function_">filter</span>(<span class="function"><span class="params">u</span> =&gt;</span> u.<span class="property">a</span> === <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxRetries = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> currentDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> userResponse = <span class="keyword">await</span> api.<span class="title function_">getUserProfile</span>();</span><br><span class="line"><span class="keyword">const</span> activeUsers = users.<span class="title function_">filter</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">isActive</span> === <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p>有意义的命名能讲述代码的故事。读者应该能够仅通过名称就理解变量或函数的用途。</p><p>💡实践建议：</p><ul><li>使用动词前缀命名函数：<code>getUserProfile()</code>、<code>validateInput()</code>、<code>calculateTotal()</code></li><li>使用名词命名变量：<code>userCount</code>、<code>activeUsers</code>、<code>orderStatus</code></li><li>布尔值使用 is/has/should等前缀：<code>isValid</code>、<code>hasPermission</code>、<code>shouldUpdate</code></li></ul><h2 id="保持函数简短且专注">2. 保持函数简短且专注</h2><p>函数应该保持简短，并且只做一件事。函数承担的责任越多，测试、调试和理解起来就越困难。</p><p><strong>反面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_order</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="comment"># 多个责任：验证、定价、折扣、配送等</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">validate_order</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_total</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_discount</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>每个函数应该只有一个责任。如果你需要用"和"来描述函数的功能，那么这个函数可能做得太多了。</p><p>💡 最佳实践：</p><ul><li>函数建议保持在 20-30 行以内</li><li>如果超过 50 行，应该考虑拆分</li><li>一个函数最好不要超过 3 个参数</li></ul><h2 id="避免深层嵌套">3. 避免深层嵌套</h2><p>深层嵌套的循环和条件语句会使代码难以理解。通过使用提前返回、函数拆分或将大问题分解为小问题来使代码扁平化。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (user.<span class="title function_">isActive</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (order != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="title function_">processOrder</span>(order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span> || !user.<span class="title function_">isActive</span>()) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (order == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="title function_">processOrder</span>(order);</span><br></pre></td></tr></table></figure></p><p>提前返回可以减少读者的认知负担，使代码更简单、更容易理解。</p><h2 id="明智地使用注释">4. 明智地使用注释</h2><p>注释不应该解释代码做了什么；代码本身应该是自解释的。只在必要时使用注释来解释复杂逻辑背后的"原因"，而不是"是什么"。</p><p><strong>反面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置用户状态为激活</span></span><br><span class="line"><span class="variable">$user</span>-&gt;isActive = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录成功后将用户标记为激活状态</span></span><br><span class="line"><span class="variable">$user</span>-&gt;isActive = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>注释应该增加价值，解释特定实现背后的原因或解释复杂的业务逻辑。</p><h2 id="保持一致的格式">5. 保持一致的格式</h2><p>一致的代码格式使代码更容易阅读和导航。在项目中使用统一的缩进、间距和对齐方式。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a+b;&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>许多团队使用 Prettier 或 ESLint等工具来自动格式化并强制执行代码风格规则。</p><h2 id="不要重复自己dry-原则">6. 不要重复自己（DRY 原则）</h2><p>代码重复会导致不一致、bug 和不必要的复杂性。应用 DRY原则可以保持代码库精简，更易于维护。</p><p><strong>反面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$userType</span> == <span class="string">&quot;admin&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 复杂逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$userType</span> == <span class="string">&quot;superadmin&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 相同的复杂逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">userIsAdmin</span>(<span class="variable">$userType</span>)) &#123;</span><br><span class="line">    <span class="comment">// 复杂逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过将共同逻辑抽象到函数、类或工具中来避免代码重复。</p><h2 id="单一责任原则srp">7. 单一责任原则（SRP）</h2><p>每个类和函数应该只有一个改变的理由。遵循单一责任原则使代码模块化，更容易重构。</p><p><strong>反面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>承担太多责任的类更难维护。SRP 使代码更模块化，更容易测试。</p><h2 id="避免魔法数字和字符串">8. 避免魔法数字和字符串</h2><p>魔法数字（或字符串）是没有上下文或解释的硬编码值。使用常量或枚举代替，这样可以增加代码的清晰度。</p><p><strong>反面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">discount = <span class="number">0.05</span></span><br><span class="line"><span class="keyword">if</span> user.role == <span class="string">&quot;admin&quot;</span>:</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DISCOUNT_RATE = <span class="number">0.05</span></span><br><span class="line">ADMIN_ROLE = <span class="string">&quot;admin&quot;</span></span><br><span class="line">discount = DISCOUNT_RATE</span><br><span class="line"><span class="keyword">if</span> user.role == ADMIN_ROLE:</span><br></pre></td></tr></table></figure></p><p>常量为数字或字符串提供了含义，使代码更容易理解。</p><h2 id="编写测试">9. 编写测试</h2><p>单元测试和集成测试确保你的代码按预期工作，并且在进行更改时不会出错。编写测试使代码更可靠，长期更易于维护。</p><p><strong>反面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法没有测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// 逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProcessOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    <span class="comment">// 断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试应该成为你工作流程的一部分，确保代码无 BUG 且稳定。</p><h2 id="保持简单kiss-原则">10. 保持简单（KISS 原则）</h2><p>KISS（Keep It Simple,Stupid）原则提醒我们简单是关键。复杂的解决方案会导致混淆，更难维护。在面对决策时，选择最简单、最直接的方案来满足需求。</p><p><strong>反面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过度复杂的购物车商品总价计算</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateTotal</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> discount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复杂的折扣计算逻辑</span></span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;electronics&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.<span class="property">price</span> &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                discount += item.<span class="property">price</span> * <span class="number">0.1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">price</span> &gt; <span class="number">500</span>) &#123;</span><br><span class="line">                discount += item.<span class="property">price</span> * <span class="number">0.05</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;books&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.<span class="property">quantity</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                discount += item.<span class="property">price</span> * item.<span class="property">quantity</span> * <span class="number">0.15</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        total += item.<span class="property">price</span> * item.<span class="property">quantity</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total - discount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>正面示例：</strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将复杂逻辑拆分成小函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateDiscount</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;electronics&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item.<span class="property">price</span> &gt; <span class="number">1000</span> ? <span class="number">0.1</span> : (item.<span class="property">price</span> &gt; <span class="number">500</span> ? <span class="number">0.05</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;books&#x27;</span> &amp;&amp; item.<span class="property">quantity</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateTotal</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> discount = <span class="title function_">calculateDiscount</span>(item);</span><br><span class="line">        <span class="keyword">const</span> itemTotal = item.<span class="property">price</span> * item.<span class="property">quantity</span>;</span><br><span class="line">        <span class="keyword">return</span> total + itemTotal * (<span class="number">1</span> - discount);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>💡 最佳实践：</p><ul><li>将复杂逻辑拆分成小的、容易理解的函数</li><li>避免在一个函数中处理过多的条件判断</li><li>使用清晰的命名来表达意图</li><li>保持函数的单一职责</li></ul><h1 id="总结">总结</h1><p>干净的代码对于可维护性、可读性和协作至关重要。遵循这 10条规则——使用有意义的命名、保持函数简短、避免魔法数字、编写测试等，将会带来更健壮、更易理解和更易扩展的代码库。编写代码不仅仅是要让它能工作，更要让其他人（包括未来的你）能够轻松理解和扩展。</p><h1 id="代码审查清单">代码审查清单</h1><p>在提交代码前，可以使用以下清单进行自查：</p><ul class="task-list"><li><label><inputtype="checkbox" />变量和函数名称是否具有描述性</label></li><li><label><input type="checkbox" />函数是否只做一件事</label></li><li><label><input type="checkbox" />是否存在重复代码</label></li><li><label><input type="checkbox" />是否有未使用的魔法数字</label></li><li><label><input type="checkbox" />是否编写了相应的测试</label></li><li><label><input type="checkbox" />代码格式是否统一</label></li><li><label><input type="checkbox" />注释是否有价值</label></li><li><label><input type="checkbox" />嵌套是否过深</label></li></ul><h1 id="参考">参考</h1><ul><li><ahref="https://www.thecodingdev.com/2024/09/top-10-clean-code-rules-every-developer.html?ref=dailydev">top-10-clean-code-rules-every-developer-should-follow</a></li></ul>]]></content>
    
    
    <summary type="html">详解编写整洁代码的十大原则，帮你写出更好的代码。</summary>
    
    
    
    <category term="匠心码道" scheme="https://hedon.top/categories/%E5%8C%A0%E5%BF%83%E7%A0%81%E9%81%93/"/>
    
    
    <category term="编程规范" scheme="https://hedon.top/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
    <category term="代码质量" scheme="https://hedon.top/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
    <category term="最佳实践" scheme="https://hedon.top/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
</feed>
