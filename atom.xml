<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HedonWang</title>
  
  <subtitle>君子求诸己，律己则安。</subtitle>
  <link href="https://hedon.top/atom.xml" rel="self"/>
  
  <link href="https://hedon.top/"/>
  <updated>2025-06-04T01:43:36.728Z</updated>
  <id>https://hedon.top/</id>
  
  <author>
    <name>Hedon Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust 实战丨手写一个 Arc</title>
    <link href="https://hedon.top/2025/06/03/rust-action-arc/"/>
    <id>https://hedon.top/2025/06/03/rust-action-arc/</id>
    <published>2025-06-03T05:00:00.000Z</published>
    <updated>2025-06-04T01:43:36.728Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust 实战丨手写一个 SpinLock</a></li><li><a href="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust 实战丨手写一个 oneshot channel</a></li></ul><p>继上篇 <a href="https://hedon.top/2025/05/29/rust-action-oneshot-channel/">Rust 实战丨手写一个 oneshot channel</a>，本篇我们继续参考 <a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 一书，来实现一个 <code>Arc</code>。</p><h2 id="Arc-简介">Arc 简介</h2><p><code>Arc</code>（<em>Atomic Reference Counted</em>）是 Rust 标准库里位于 <code>std::sync</code> 模块中的智能指针，用于 <strong>在多个线程之间安全地共享只读数据</strong>。和只适用于单线程场景的 <code>Rc&lt;T&gt;</code> 不同，<code>Arc&lt;T&gt;</code> 的引用计数增减操作使用原子指令，从而保证跨线程的内存安全。</p><p>我们举一个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">u16</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    address: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">without_arc_should_not_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        name: <span class="string">&quot;hedon&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">p1</span> = &amp;p;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p1);</span><br><span class="line">        &#125;);</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">p2</span> = &amp;p;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p2);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = &amp;p;  <span class="comment">// &lt;--------- 报错</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p3);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面这个测试用例，我们会得到如下的报错信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0597]: `p` does not live long enough</span><br><span class="line"><span class="meta prompt_">  --&gt; </span><span class="language-bash">src/arc.rs:31:18</span></span><br><span class="line">   |</span><br><span class="line">14 |           let p = Person &#123;</span><br><span class="line">   |               - binding `p` declared here</span><br><span class="line">...</span><br><span class="line">31 |           let p3 = &amp;p;</span><br><span class="line">   |                    ^^ borrowed value does not live long enough</span><br><span class="line">32 | /         thread::spawn(move || &#123;</span><br><span class="line">33 | |             println!(&quot;&#123;:?&#125;&quot;, p3);</span><br><span class="line">34 | |         &#125;);</span><br><span class="line">   | |__________- argument requires that `p` is borrowed for `&#x27;static`</span><br><span class="line">35 |       &#125;</span><br><span class="line">   |       - `p` dropped here while still borrowed</span><br></pre></td></tr></table></figure><p><strong><code>scope</code> 里的线程</strong>必须在闭包结束前 join；因而可以捕获非 <code>'static</code> 数据，所以这个时候我们使用引用，是没问题的。但是在 <strong><code>thread::spawn</code></strong> 中，需要 <code>'static</code>，这个时候，仅使用引用，就无法保证生命周期符合要求了。</p><p>这个时候，我们可以使用 <code>Arc</code> 来将 <code>p</code> 包起来，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    age: <span class="type">u16</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    address: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">arc_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Arc::<span class="title function_ invoke__">new</span>(Person &#123;  <span class="comment">// 使用 Arc</span></span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        name: <span class="string">&quot;hedon&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">p1</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;p); <span class="comment">// 等价于 p.clone()</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p1);</span><br><span class="line">        &#125;);</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">p2</span> = p.<span class="title function_ invoke__">clone</span>(); <span class="comment">// 等价于 Arc::clone(&amp;p)</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p2);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p.<span class="title function_ invoke__">clone</span>();  <span class="comment">// &lt;----- 编译通过</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p3);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>现象</th><th>关键原因</th><th><code>Arc</code> 怎么解决</th></tr></thead><tbody><tr><td><code>thread::spawn</code> 要求闭包里的 <strong>所有捕获值都满足 <code>'static</code></strong>；<code>&amp;p</code> 只是对栈上变量 <code>p</code> 的借用，不具备 <code>'static</code> 生命周期。</td><td>线程可能在父栈帧结束后仍继续运行，如果还持有对局部变量的引用就会悬垂。</td><td><code>Arc::new(p)</code> 把数据移到堆上，返回的智能指针本身是 <code>'static</code>；克隆 <code>Arc</code> 只是原子计数 +1，任何线程都能安全持有。</td></tr><tr><td>想给 <strong>多个线程同时用同一份数据</strong>，但引用只有 “临时借阅” 语义，生命周期无法跨线程。</td><td>Rust 的借用规则禁止 “多所有权 + 并发”。</td><td><code>Arc</code> 通过 <strong>原子引用计数</strong> 实现多所有权，最后一个线程 <code>drop</code> 时才真正释放。</td></tr></tbody></table><p>OK，在简单回顾完 <code>Arc</code> 的作用后，我们正式开始自己来实现一个可以媲美标准库的 <code>Arc</code>。</p><h2 id="读完本篇你能学到什么">读完本篇你能学到什么</h2><h2 id="v0：基础引用计数">v0：基础引用计数</h2><p>我们先来分析一下基本的数据结构改如何定义，在之前的 <a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust 实战丨手写一个 SpinLock</a>，我们讲到了 C++/Rust 常用的并发编程方式 RAII（Resource Acquisition Is Initialization，资源获取即初始化），其核心思想是：<strong>在对象构造函数中获取资源，在析构函数中释放资源</strong>。上面的案例中，我们在初始化 <code>Person</code> 的时候其实也是应用了这种思路。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = Arc::<span class="title function_ invoke__">new</span>(Person &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    name: <span class="string">&quot;hedon&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    address: <span class="string">&quot;China&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以我们的自定义 <code>Arc</code> 需要泛型 <code>T</code>，使其可以承载不同的数据类型的数据 <code>data</code>，同时为了做引用计数，它需要一个数值类型 <code>ref_count</code> 来计数，为了并发安全，我们可以选择原子类型 <code>AtomicUsize</code>。</p><p>在 <code>Arc</code> 中，我们需要自己管理 <code>data</code> 的生命周期，除了使用裸指针 <code>*mut T</code> 或 <code>*const T</code> 之外，我们可以使用 <code>std::ptr::NonNull&lt;T&gt;</code> ，它是一个零成本、保证非空、支持协变（可安全向子类型转换）的裸指针包装器，具体可参考<strong>附录 1. NonNull&lt;T&gt;</strong>。</p><p>综上，我们可以定义以下数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    ref_count: AtomicUsize,</span><br><span class="line">    data: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Arc &#123;</span><br><span class="line">            ptr: NonNull::<span class="title function_ invoke__">from</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(ArcData &#123;</span><br><span class="line">                ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                data,</span><br><span class="line">            &#125;))),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们定义了 <code>ArcData</code> 和 <code>Arc</code> 两个结构，其中 <code>ArcData</code> 包含引用计数 <code>ref_count</code> 和实际数据 <code>data</code>。</li><li>在 <code>Arc</code> 中，我们使用 <code>NonNull</code> 来管理 <code>ArcData</code> 的生命周期。初始化时，先用 <code>Box::new()</code> 在堆上分配内存，再通过 <code>Box::leak()</code> 放弃 <code>Box&lt;T&gt;</code> 的所有权，交由 <code>Arc</code> 自行管理。</li></ol><p>另外，跨线程发送 <code>Arc&lt;T&gt;</code> 会导致 <code>T</code> 对象被共享，即 <code>T</code> 需要满足 <code>Sync</code> trait，而跨线程发送 <code>Arc&lt;T&gt;</code> 也会导致需要由另外一个线程来释放 <code>T</code>，所以需要 <code>T</code> 满足 <code>Send</code> trait。所以只有当 <code>T</code> 满足 <code>Send+Sync</code> 的时候，<code>Arc&lt;T&gt;</code> 才是 <code>Send</code> 的，对于 <code>Sync</code> 也是同理，因为我们可以为 <code>Arc&lt;T&gt;</code> 分别实现 <code>Sync</code> 和 <code>Send</code> trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>为了能够便捷的获取 <code>data</code>，我们先为 <code>Arc&lt;T&gt;</code> 实现一个 <code>data()</code> 用于获取 <code>ArcData&lt;T&gt;</code>，同时为其实现 <code>Deref</code> trait，用于像指针一样无感操作 <code>data: T</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ref</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础部分我们已经铺垫完了，现在我们需要来实现 2 个最重要的 trait 了：</p><ul><li><strong>Clone</strong>: <code>Arc</code> 引用计数的关键，在每次 <code>clone()</code> 的时候，我们不拷贝 <code>data</code>，而是让 <code>ref_count</code> 自增，进行引用计数。</li><li><strong>Drop</strong>: 在 <code>Arc&lt;T&gt;</code> 实例离开作用域的时候，我们需要让 <code>ref_count</code> 自减，同时在最后一个 <code>Arc&lt;T&gt;</code> 被销毁时，我们需要主动释放 <code>ArcData&lt;T&gt;</code> 的内存资源。</li></ul><p>我们先来实现 <code>Clone</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 处理整型溢出的情况</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed)</span><br><span class="line">        Arc &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里没有其他原子操作需要跟当前操作建立严格的 <code>happens-before</code> 关系，所以这里我们可以使用最松的 <code>Relaxed</code> 内存顺序。</p><p>接下来看下 <code>Drop</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> &lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, ???) == <span class="number">1</span> &#123; <span class="comment">// &lt;----- 这里需要什么使用内存顺序约束？</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>Drop</code>，我们就需要好好想一想需要什么内存顺序约束了。在最后一个 <code>drop</code> 的时候，我们有 2 个目标：</p><ol><li><strong>不能过早释放</strong>：确保在引用计数减到 0 并销毁对象之前，没有别的线程仍在使用这份数据；</li><li><strong>要看得见别人写的东西</strong>：如果别的线程在它们各自的 <code>drop</code> 里面对共享对象做了写入，最后一个线程做析构时必须“看到”这些写入，否则就可能出现数据竞争或次序错误。</li></ol><p>换言之，我们需要最后一个 <code>fetch_sub</code> 跟前面其他每一个 <code>fetch_sub</code> 都建立起 happens before 关系，也即我们需要一对 Release 和 Acquire 来保证 happens-before。</p><p>这里简单回顾一下 <code>Release</code> 和 <code>Acquire</code>，不熟悉的读者可以参阅：<a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a>。</p><ul><li><code>Release</code>: 作用于写操作（store），确保该操作之前的所有内存访问不会被重排到这个 Release 操作之后。</li><li><code>Acquire</code>: 作用于读操作（load），确保该操作之后的所有内存访问不会被重排到这个 Acquire 操作之前。</li><li>当一个线程通过 <code>Acquire</code> 读取到另一个线程通过 <code>Release</code> 写入的值时，会建立一个 happens-before 关系：<strong>线程 A 中 Release 写入之前的所有内存写操作，对于线程 B 中 Acquire 读取之后的所有内存读操作都是可见的</strong>。</li></ul><p>我们当然可以使用 <code> Release</code> 和 <code>Acuqire</code> 的结合体 <code>AcqRel</code> 来一步到位解决这个问题。不过考虑到只有最后一个 <code>drop</code> 需要满足这个关系，我们可以尝试做得更优雅一些。</p><p><strong>在这种仅需在临界值保证 happens-before 的场景下，我们都可以单独在临界情况下使用一个 <code>fence</code> 来建立起 happens-before。</strong></p><p>具体来说：</p><ul><li><strong>对于非最终 <code>drop</code></strong>：我们只需要使用 <code>Release</code>，即 <code>fetch_sub(1, Ordering::Release)</code>，它保证了别的线程如果最终做“最后一次 drop”，只要它对相同原子执行一条 <em>Acquire</em> 操作，它就能同步到前面所有线程对数据做过的改动。</li><li><strong>对于最终 <code>drop</code></strong>：在调用 <code>fetch_sub</code> 的时候我们仍需要 <code>Release</code> 语义，但是调用时，我们并不知道自己是不是“最后那个线程”。当 <code>fetch_sub</code> 返回 <code>1</code> 的时候，说明我们是“最后那个线程”。这个时候，我们需要建立一个 <code>fetch(Acuqire)</code>，与之前的所有 <code>Release</code> 形成配对，确保看到<strong>之前所有的历史写入</strong>，这个时候我们才能确定已经没有别的线程在使用数据了，我们才可以安全地销毁对象。</li></ul><p>如下图所示；</p><pre class="mermaid">sequenceDiagram    participant A as Thread A    participant B as Thread B    participant C as Thread C<br/>(最后 drop)    %% 普通写入    A->>A: write shared data …    B->>B: write shared data …    %% 非最终 drop：Release 写    A->>A: fetch_sub (Release)  ⬅ 计数 n→n-1    B->>B: fetch_sub (Release)  ⬅ 计数 n-1→n-2    %% 形成 release-sequence    Note over A,B: 这两次 Release 写组成<br/>同一条 release-sequence    %% 最终 drop：Release 写 & 返回 1    C->>C: fetch_sub (Release)  ⬅ 返回 1 → 计数 0    %% Acquire fence 同步    C-->>C: fence (Acquire)<br/>【接收 release-sequence】    %% 安全析构    C->>C: drop(Box::from_raw)    %% 结果说明    Note over C: fence (Acquire) 使 A/B<br/>对共享数据的写必定<br/>在析构前可见</pre><p>经过这么一顿分析后，我们最终的 <code>Drop</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// ❶ 所有 `drop` 都执行：Release</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// ❷ 只有最后一个引用才会进来</span></span><br><span class="line">            std::sync::atomic::<span class="title function_ invoke__">fence</span>(Ordering::Acquire); <span class="comment">// ❸ 补上 Acquire</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="comment">// ❹ 现在可以安全地回收并析构</span></span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤拆分如下：</p><table><thead><tr><th>步骤</th><th>发生了什么</th><th>语义 &amp; 作用</th></tr></thead><tbody><tr><td><strong>① <code>val = fetch_sub(1, Release)</code></strong></td><td>把引用计数原子减 1，并返回减前的旧值</td><td>提供 <em>Release</em>，与之前所有 <code>Release</code> 或 <code>AcqRel</code> 写入建立 release-sequence</td></tr><tr><td><strong>② 判断 <code>val == 1</code></strong></td><td>若旧值是 1 → 现在减到 0，说明“我是最后一个”</td><td><strong>只有这时才需要额外的 Acquire</strong></td></tr><tr><td><strong>③ <code>fence(Acquire)</code></strong></td><td>发出一条 Acquire 栅栏</td><td>与那条 release-sequence 对接，<em>同步至此</em>（拿到“所有历史写入”的可见性）</td></tr><tr><td><strong>④ <code>drop(Box::from_raw(ptr))</code></strong></td><td>独占地回收堆内存并运行 <code>T</code> 的析构</td><td>现在安全：① 没人再持有引用；② 我已看到所有之前线程对 <code>T</code> 做的写入</td></tr></tbody></table><p>自此，我们第一个版本的 <code>Arc</code> 就实现完毕了，我们来看一下最终完成的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    ref_count: AtomicUsize,</span><br><span class="line">    data: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Arc &#123;</span><br><span class="line">            ptr: NonNull::<span class="title function_ invoke__">from</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(ArcData &#123;</span><br><span class="line">                ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                data,</span><br><span class="line">            &#125;))),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ref</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        Arc &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个单元测试验证一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">arc_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> NUM_DROPS: AtomicUsize = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DetectDrop</span>;</span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">DetectDrop</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">            NUM_DROPS.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 2 个 Arc 共享一个元组，包含一个字符串和 DetectDrop 对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = Arc::<span class="title function_ invoke__">new</span>((<span class="string">&quot;hedon&quot;</span>, DetectDrop));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 x 转移到另外一个线程并使用它</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(x.<span class="number">0</span>, <span class="string">&quot;hedon&quot;</span>); <span class="comment">// 可以正常使用</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里，y 应该也是可以正常使用的</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(y.<span class="number">0</span>, <span class="string">&quot;hedon&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 t 线程执行完毕</span></span><br><span class="line">    t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个时候 `x` 已经被释放了，但是`y` 还没有被释放，</span></span><br><span class="line">    <span class="comment">// 所以 `DetectDrop` 应该还没被释放。</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(NUM_DROPS.<span class="title function_ invoke__">load</span>(Ordering::Relaxed), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动释放掉 `y`，这是最后一个 `Arc`，所以 `DetectDrop` 应该会被释放</span></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(y);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(NUM_DROPS.<span class="title function_ invoke__">load</span>(Ordering::Relaxed), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果是 ok 的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">running 1 test</span><br><span class="line">test arc::tests::arc_should_work ... ok</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line"></span><br><span class="line">successes:</span><br><span class="line">    arc::tests::arc_should_work</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure><h2 id="v1-实现-get-mut-获取可变引用">v1: 实现 get_mut 获取可变引用</h2><p>按照前面版本的实现，我们是不能为 <code>Arc&lt;T&gt;</code> 实现 <code>DerefMut</code> trait 的，因为我们不能无条件地提供 <code>&amp;mut T</code> 可变引用，因为它可能同时被其他的 <code>Arc&lt;T&gt;</code> 所访问中。</p><p>不过，当满足一定条件的时候，我们还是可以提供 <code>&amp;mut T</code> 可变引用的。具体来说，需要满足 2 个条件：</p><ol><li>使用 <code>&amp;mut Arc&lt;T&gt;</code> 保证当前 <code>Arc&lt;T&gt;</code> 只有一个地方在使用；</li><li>需要确保全局只有一个 <code>Arc&lt;T&gt;</code>。</li></ol><p>为了避免跟 <code>DerefMut</code> 混淆，我们将其声明为一个静态方法，并将 <code>Arc&lt;T&gt;</code> 作为参数，同时因为只有满足特定条件的情况下，才能返回 <code>&amp;mut T</code>，所以我们使用 <code>Option</code> 作为返回值。如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(arc: &amp;<span class="keyword">mut</span> Arc&lt;T&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> arc.<span class="title function_ invoke__">data</span>().ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">        <span class="comment">// Safety: 没有其他地方可以访问数据，</span></span><br><span class="line">        <span class="comment">// 因为我们使用了 &amp;mut 独占引用，而且此时只有一个 `Arc`。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">Some</span>(&amp;<span class="keyword">mut</span> arc.ptr.<span class="title function_ invoke__">as_mut</span>().data) &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>这里我们在确定只有一个 <code>Arc</code> 实例的时候，使用 <code>fetch(Acuqire)</code> 来跟所有其他 <code>Arc</code> 执行 <code>drop()</code> 的 <code>fetch_sub(Release)</code> 建立 happens-before 关系。</p></li><li><p>因为此时 <code>ref_count=1</code>，说明仅有当前 <code>Arc</code> 这一个实例，而 <code>get_mut</code> 需要的又是独占引用，所以当前 <code>Arc</code> 不可能再被拿去做 <code>clone()</code> 操作，所以在这个情况下，是可以保证有且仅有一个 <code>Arc</code> 实例，所以我们是可以安全返回 <code>&amp;mut T</code> 的。</p></li><li><p>返回的 <code>&amp;mut T</code> 会隐式地借用参数 <code>&amp;mut Arc&lt;T&gt;</code> 的生命周期，而 Rust 不允许可变引用和只读引用交叉存在，所以当前仅剩的这个 <code>Arc</code>，直到 <code>&amp;mut T</code> 作用域结束之前，都是不可用的，所以在那之前，不会再被拿去执行 <code>clone()</code> 和 <code>Deref</code> 等操作，所以是安全的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_mut_should_be_safe</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = Arc::<span class="title function_ invoke__">get_mut</span>(&amp;<span class="keyword">mut</span> x).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">clone</span>(); <span class="comment">// &lt;---- cannot borrow `x` as immutable</span></span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面这个例子，就会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable</span><br><span class="line"><span class="meta prompt_">   --&gt; </span><span class="language-bash">src/arc.rs:117:17</span></span><br><span class="line">    |</span><br><span class="line">114 |         let v = Arc::get_mut(&amp;mut x).unwrap();</span><br><span class="line">    |                              ------ mutable borrow occurs here</span><br><span class="line">...</span><br><span class="line">117 |         let y = x.clone();</span><br><span class="line">    |                 ^ immutable borrow occurs here</span><br><span class="line">118 |         v.push(2);</span><br><span class="line">    |         - mutable borrow later used here</span><br></pre></td></tr></table></figure></li></ol><h2 id="v2：弱指针-Weak-T-解决循环引用">v2：弱指针 Weak&lt;T&gt; 解决循环引用</h2><pre class="mermaid">graph TDA --> B;A --> C;</pre><p>引用计数在各种数据结构的表示中非常有用，如上图所示的树形结构，当释放 A 的时候，因为 B 和 C 不再被引用，所以也可以顺带释放了。</p><p>但是，如果 B 和 C 也持有对 A 的引用，即形成了循环引用，那按照我们之前的实现，A、B、C 都将永远不会被释放了，因为它们的引用计数永不为 0，哪怕它们三者均不再被使用。如下图所示：</p><pre class="mermaid">graph TDA <--> B;A <--> C;B -.-> A;C -.-> A;</pre><p>为了应对这种场景，Rust 的标准库中提出的解决方案是：<strong><code>Weak&lt;T&gt;</code>，也称弱指针</strong>。<strong><code>T</code> 可以在 <code>Arc&lt;T&gt;</code>  和 <code>Weak&lt;T&gt;</code> 之间共享，当所有的 <code>Arc&lt;T&gt;</code> 都失效的时候，<code>T</code> 被释放，无论此时是否有 <code>Weak&lt;T&gt;</code> 的存在。</strong></p><p>如下图所示，父节点对子节点使用的是强引用，确保了父节点存活的时候，子节点都存在。而子节点对父节点使用的是弱引用，只即保留了子节点回溯父节点的能力，也不会阻止父节点的释放。</p><p>当父节点被释放时，所有强引用计数归零，节点可以依次被释放。</p><pre class="mermaid">graph TDA -- Arc --> B;A -- Arc --> C;B -.->|Weak| A;C -.->|Weak| A;</pre><p>OK，做了这么多铺垫后，我们来思考一下现在的 <code>ArcData</code> 该如何调整。</p><ol><li>之前我们用 <code>ref_count</code> 做引用计数，它代表的都是强引用，现在我们需要记录弱引用数量的相关字段。</li><li>当只有弱引用的时候，<code>data</code> 就已经被释放了，我们需要使用 <code>None</code> 来表示这种情况，所以 <code>data</code> 应该是一个 <code>Option&lt;T&gt;</code> 类型。</li><li>当 <code>ArcData&lt;T&gt;</code> 被一个 <code>Arc</code> 和多个 <code>Weak</code> 共享时，释放最后一个 <code>Arc</code> 时，我们仅拥有 <code>&amp;ArcData&lt;T&gt;</code> 不可变引用，这个时候我们需要将其从 <code>Some(T)</code> 置为 <code>None</code>，即要在不可变引用上实现修改，这就涉及到了前几篇提到的：<strong>内部可变性</strong>。<strong>UnsafeCell</strong> 是 Rust 提供的一个内部可变性工具类型，它包装一个数据，使得即使在只有不可变引用的情况下也可以进行修改（当然需要在 <code>unsafe</code> 块中操作）。所以我们需要将 <code>data</code> 再用 <code>UnsafeCell</code> 包一层，以满足此场景的需求。</li></ol><p>综上，最新的 <code>ArcData</code> 定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// `Arc` 的数量，也即数据 T 的强引用计数。</span></span><br><span class="line">    data_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// `Arc` + `Weak` 的数量。</span></span><br><span class="line">    alloc_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// 数据，当只有 `Weak` 的时候，为 None。</span></span><br><span class="line">    data: UnsafeCell&lt;<span class="type">Option</span>&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要定义一个新结构 <code>Weak&lt;T&gt;</code> ，用来表示弱引用，假定这个时候，我们将维护 <code>ArcData</code> 存活的职责交给 <code>Weak&lt;T&gt;</code>，那就可以将 <code>ArcData</code> 转给 <code>Weak&lt;T&gt;</code> 持有，然后在 <code>Arc&lt;T&gt;</code> 中持有一个 <code>Weak&lt;T&gt;</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArcData</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// `Arc` 的数量，也即数据 T 的强引用计数。</span></span><br><span class="line">    data_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// `Arc` + `Weak` 的数量。</span></span><br><span class="line">    alloc_ref_count: AtomicUsize,</span><br><span class="line">    <span class="comment">// 数据，当只有 `Weak` 的时候，为 None。</span></span><br><span class="line">    data: UnsafeCell&lt;<span class="type">Option</span>&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    weak: Weak&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    ptr: NonNull&lt;ArcData&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(data: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Arc &#123;</span><br><span class="line">            weak: Weak &#123;</span><br><span class="line">                ptr: NonNull::<span class="title function_ invoke__">from</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(ArcData &#123;</span><br><span class="line">                    alloc_ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                    data_ref_count: AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>),</span><br><span class="line">                    data: UnsafeCell::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Some</span>(data)),</span><br><span class="line">                &#125;))),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Weak&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">data</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ref</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ptr</span> = <span class="keyword">self</span>.weak.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>();</span><br><span class="line">        <span class="comment">// Safety: 这个时候还有 Arc 存在，所以 data 肯定是生效的。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*ptr).<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，除了数据结构之外，我们做了 3 点调整：</p><ol><li>只需要为 <code>Weak&lt;T&gt;</code> 实现 <code>Sync</code> 和 <code>Send</code> trait，这个时候 <code>Arc&lt;T&gt;</code> 就会被自动实现这 2 个 triat。</li><li><code>data(&amp;self)</code> 辅助函数，移到了 <code>Weak&lt;T&gt;</code> 身上。</li><li><code>Arc&lt;T&gt;</code> 要从 <code>Deref</code> 获取 <code>&amp;T</code>，需要先经过一道 <code>Weak&lt;T&gt;</code>。</li></ol><p>现在重点来了，我们需要来思考 <code>Weak&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code> 的 <code>Clone</code> 和 <code>Drop</code> 该如何实现。其实重点就是该<strong>如何管理 <code>alloc_ref_count</code> 和 <code>data_ref_count</code> 的计数</strong>。</p><p>再次明确下我们的定义：</p><ul><li><code>data_ref_count</code>: 代表的是强引用 <code>Arc&lt;T&gt;</code> 的数量。</li><li><code>alloc_ref_count</code>: 代表的是 <code>Arc&lt;T&gt;</code> + <code>Weak&lt;T&gt;</code> 的数量。</li></ul><p>因此：</p><ul><li>Clone:<ul><li>当 <code>Weak&lt;T&gt;</code> 拷贝时，仅增加了弱引用的数量，所以我们只需对 <code>alloc_ref_count</code> 进行自增。</li><li>当 <code>Arc&lt;T&gt;</code> 拷贝时，不仅需要拷贝内部的 <code>Weak&lt;T&gt;</code>，还增加了强引用的数量，所以我们还需要对 <code>data_ref_count</code> 进行自增。</li></ul></li><li>Drop:<ul><li>当 <code>Arc&lt;T&gt;</code> 被释放时，不仅释放了其内部的 <code>Weak&lt;T&gt;</code>，还减少了一个强引用，所以需要对 <code>data_ref_count</code> 进行自减。另外，如果是最后一个 <code>Arc&lt;T&gt;</code> 被释放，我们需要将 <code>ArcData&lt;T&gt;.data</code> 置为 <code>None</code>。</li><li>当 <code>Weak&lt;T&gt;</code> 被释放时，我们仅需减少弱引用的数量，即对 <code>alloc_ref_count</code> 进行自减。另外，当最后一个 <code>Weak&lt;T&gt;</code> 被释放时（此时肯定也没有 <code>Arc&lt;T&gt;</code> 了），我们还需要负责释放 <code>ArcData&lt;T&gt;</code> 。</li></ul></li></ul><p>综上，我们的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed) &gt; <span class="type">usize</span>::MAX / <span class="number">2</span> &#123;</span><br><span class="line">            std::process::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">Self</span> &#123; ptr: <span class="keyword">self</span>.ptr &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">weak</span> = <span class="keyword">self</span>.weak.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">if</span> weak.<span class="title function_ invoke__">data</span>().data_ref_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed) &gt; <span class="type">usize</span>::MAX / <span class="number">2</span> &#123;</span><br><span class="line">            std::process::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Arc &#123; weak &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Weak</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="comment">// Safety: 最后一个 Weak&lt;T&gt; 已经被释放了。</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">drop</span>(<span class="type">Box</span>::<span class="title function_ invoke__">from_raw</span>(<span class="keyword">self</span>.ptr.<span class="title function_ invoke__">as_ptr</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span></span><br><span class="line">            .weak</span><br><span class="line">            .<span class="title function_ invoke__">data</span>()</span><br><span class="line">            .data_ref_count</span><br><span class="line">            .<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::Release)</span><br><span class="line">            == <span class="number">1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">ptr</span> = <span class="keyword">self</span>.weak.<span class="title function_ invoke__">data</span>().data.<span class="title function_ invoke__">get</span>();</span><br><span class="line">            <span class="comment">// Safety: data_ref_count 已经为 0 了，没有地方在使用 data 了。</span></span><br><span class="line">            <span class="keyword">unsafe</span> &#123; (*ptr) = <span class="literal">None</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里考虑到实际场景中的内存限制，我们对引用计数进行了简单的限制，当其超过 <code>usize::Max/2</code> 的时候，就执行 <code>std::process:abort()</code> 让整个进程崩溃。</p></blockquote><p>到这里，我们执行之前的 <code>arc_should_work</code> 测试用例，可以发现是顺利通过的。</p><p>接下来我们来考虑下 <code>get_mut(arc: &amp;mut Arc)</code> 该如何修改。什么时候可以返回 <code>&amp;mut T</code>，很明显，<strong>当且仅当只有一个 <code>Arc&lt;T&gt;</code> 的时候才可以</strong>。</p><p>故 <code>get_mut</code> 的实现修改如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_mut</span>(arc: &amp;<span class="keyword">mut</span> Arc&lt;T&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> arc.weak.<span class="title function_ invoke__">data</span>().alloc_ref_count.<span class="title function_ invoke__">load</span>(Ordering::Relaxed) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">fence</span>(Ordering::Acquire);</span><br><span class="line">        <span class="comment">// Safety: 这个时候没有其他地方能使用数据，因为只有一个 `Arc`，</span></span><br><span class="line">        <span class="comment">// 同时我们拥有仅存的这个 `Arc` 的不可变引用。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">arcdata</span> = <span class="keyword">unsafe</span> &#123; arc.weak.ptr.<span class="title function_ invoke__">as_mut</span>() &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">option</span> = arcdata.data.<span class="title function_ invoke__">get_mut</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = option.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><h2 id="附录">附录</h2><h3 id="1-NonNull-T">1. NonNull&lt;T&gt;</h3><p><code>std::prt::NonNull&lt;T&gt;</code> 是一个 <strong>零成本、非空、协变</strong> 的裸指针包装器。它本质上只是把一个原始指针塞进 <code>#[repr(transparent)]</code> 的新类型中，但强制保证 <strong>绝不为空</strong>，因此可以拿到「空值当作枚举判别位」这份额外信息 —— <code>Option&lt;NonNull&lt;T&gt;&gt;</code> 与一个普通指针占用同样大小。</p><p>重要特性：</p><ul><li><strong>永远非空</strong>：创建时若传入空指针即触发 <strong>未定义行为</strong>。编译器可依赖这一点做优化，例如把 <code>Option&lt;NonNull&lt;T&gt;&gt;</code> 合并为一个指针宽度。</li><li><strong>协变</strong>：与 <code>*mut T</code> 不同，<code>NonNull&lt;T&gt;</code> 可以在 <code>U: Deref&lt;Target = T&gt;</code> 的场景下安全向子类型转换（因为禁止空值带来了额外保证），这使它非常适合构建自定义智能指针。</li><li><strong>无自动 Drop</strong>：<code> NonNull</code> 只存地址，不持有所有权；销毁与释放内存仍由外部逻辑决定（如 <code>Box::from_raw</code>、<code>Vec::dealloc</code> 等）。</li></ul><p>我们将其与裸指针、 <code>Box&lt;T&gt;</code> 智能指针和引用 <code>&amp;T</code> 做一个简单的比较：</p><table><thead><tr><th>特性</th><th><code>*mut T</code> / <code>*const T</code></th><th><code>NonNull&lt;T&gt;</code></th><th><code>Box&lt;T&gt;</code> / <code>&amp;T</code></th></tr></thead><tbody><tr><td><strong>是否允许为空</strong></td><td>✅</td><td><strong>❌ 必须非空</strong></td><td>不适用</td></tr><tr><td><strong>协变性</strong></td><td><code>*mut</code> 不协变</td><td><strong>协变</strong>（可安全向子类型转换）</td><td><code>&amp;T</code> 协变</td></tr><tr><td><strong>Option 优化</strong></td><td>❌ 多 1 B 判别字节</td><td><strong>✅ 与裸指针同尺寸</strong></td><td>已自带优化</td></tr><tr><td><strong>所有权 / drop 责任</strong></td><td>没有</td><td>没有（纯指针）</td><td>有</td></tr><tr><td><strong>Send / Sync</strong></td><td>与 <code>T</code> 无关</td><td>默认 <code>!Send !Sync</code></td><td>取决于 <code>T</code></td></tr><tr><td><strong>常见用途</strong></td><td>FFI、底层算法</td><td><strong>智能指针内部、侵入式容器、裁掉空判</strong></td><td>高层所有权模型</td></tr></tbody></table><p>关键的 API：</p><table><thead><tr><th>分组</th><th>代表方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>构造</strong></td><td><code>NonNull::new(ptr)</code> → <code>Option&lt;NonNull&lt;T&gt;&gt;</code> <br><code>unsafe &#123; NonNull::new_unchecked(ptr) &#125;</code> <br><code>NonNull::dangling()</code></td><td>安全 / 不安全 / 占位</td></tr><tr><td><strong>引用视图</strong></td><td><code>unsafe</code> <br><code>fn as_ref</code> / <code>as_mut</code></td><td>把裸指针临时借用成 <code>&amp;T</code> / <code>&amp;mut T</code></td></tr><tr><td><strong>裸指针互转</strong></td><td><code>fn as_ptr</code></td><td>取回 <code>*mut T</code>，解引用仍需 <code>unsafe</code></td></tr><tr><td><strong>类型转换</strong></td><td><code>fn cast&lt;U&gt;</code> <br><code>fn cast_mut</code> / <code>cast_const</code></td><td>保留地址，换类型或可变性</td></tr><tr><td><strong>地址运算</strong></td><td><code>unsafe fn add / byte_add / sub / offset</code></td><td>指针算术，与 <code>ptr::add</code> 族一致</td></tr><tr><td><strong>切片助手</strong></td><td><code>NonNull::slice_from_raw_parts(data, len)</code> <br><code>fn len()</code></td><td>1.70+ 稳定，为 <code>[T]</code> 提供非空裸切片构造 (<a href="https://rustwiki.org/zh-CN/std/ptr/struct.NonNull.html?utm_source=chatgpt.com">rustwiki.org</a>)</td></tr></tbody></table><blockquote><p>⚠️ 任何把 <code>NonNull</code> 重新解释为引用或解引用的操作，都必须在 <code>unsafe</code> 块里手动保证内存有效性与别名规则。</p></blockquote><p>典型使用场景：</p><table><thead><tr><th>场景</th><th>作用</th></tr></thead><tbody><tr><td><strong>智能指针内部实现</strong> (<code>Box</code>/<code>Rc</code>/<code>Arc</code>)</td><td>需要 <em>非空</em> 原始指针存放被管对象，且要在 <code>Option</code> 等场景下节省空间</td></tr><tr><td><strong>自研侵入式链表 / 红黑树</strong></td><td>节点自身持有前后指针字段 <code>NonNull&lt;Node&lt;T&gt;&gt;</code>，天然避免空判分支</td></tr><tr><td><strong>惰性初始化 / <code>Vec::new</code></strong></td><td>先用 <code>NonNull::dangling()</code> 占位，等真正分配后再写入正确地址</td></tr><tr><td><strong>FFI</strong></td><td>C API 明确保证参数永不为空时，用 <code>NonNull</code> 在类型层面表达前置条件</td></tr><tr><td><strong>自引用结构（Pin 工作区）</strong></td><td>在完成真正初始化前使用 <code>NonNull::dangling()</code> 保存指向自身字段的指针</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文从零开始，通过多版本迭代，实现一个安全的 Rust Arc。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨手写一个 oneshot channel</title>
    <link href="https://hedon.top/2025/05/29/rust-action-oneshot-channel/"/>
    <id>https://hedon.top/2025/05/29/rust-action-oneshot-channel/</id>
    <published>2025-05-29T14:11:03.000Z</published>
    <updated>2025-06-03T14:52:26.928Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li><li><a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust 实战丨手写一个 SpinLock</a></li></ul><p>继上篇 <a href="https://hedon.top/2025/05/13/rust-action-spinlock/">Rust 实战丨手写一个 SpinLock</a>，本篇我们继续参考 <a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 一书，来实现一个 <code>oneshot channel</code>。</p><p>在 Go 语言中，有一句名言：</p><blockquote><p>Don’t communicate by sharing memory, share memory by communicating. 不要通过共享内存来通信，而要通过通信来共享内存。</p></blockquote><p>讲的就是通道 <code>channel</code>。使用 <code>channel</code> 来通信，一方面可以避免共享状态的并发竞争问题，另一方面可以解耦生产者和消费者。</p><p><code>channel</code> 根据生产者和消费者的数量，可以分为以下几种：</p><ol><li><strong>单生产者单消费者</strong> (SPSC)</li><li><strong>单生产者多消费者</strong> (SPMC)</li><li><strong>多生产者单消费者</strong> (MPSC)</li><li><strong>多生产者多消费者</strong> (MPMC)</li></ol><p>在<strong>单生产者单消费者</strong>这个分类中，有一种特殊且常用的场景，叫<strong>一次性通道</strong>（oneshot channel）。它在 SPSC 的基础上增加了额外约束：整个生命周期内只传递一次数据，传递完成后通道就失效了。</p><p>熟悉 Go 语言的读者应该对以下使用场景很熟悉，这些都是典型的 oneshot channel 应用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ... do something</span></span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">oneShot := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">oneShot &lt;- generateText()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">text := &lt;-oneShot</span><br><span class="line">doSthWithText(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateText</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSthWithText</span><span class="params">(text <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Rust 社区里面，就有一个非常优秀的 <a href="https://docs.rs/oneshot/latest/oneshot/">oneshot</a> 实现，在详细深入它的实现之前，我们先参考 <a href="https://marabos.nl/atomics/building-channels.html">Rust Atomics and Locks</a> 一书，来尝试实现一个 <code>oneshot channel</code>!</p><h2 id="读完本篇你能学到什么">读完本篇你能学到什么</h2><ol><li><p><strong>一次性 (oneshot) 通道的场景与优势</strong></p><ul><li>了解它与多生产者/多消费者通道的区别</li><li>掌握常见使用模式（如线程同步、单次结果返回）</li></ul></li><li><p><strong>Rust 并发核心原语的渐进式实践</strong></p><ul><li><code>UnsafeCell</code>：内部可变性基石</li><li><code>AtomicBool</code> + <code>Ordering::&#123;Release,Acquire&#125;</code>：最小化同步原语</li><li><code>MaybeUninit&lt;T&gt;</code>：零成本延迟初始化</li></ul></li><li><p><strong>用所有权与生命周期设计零误用 API</strong></p><ul><li>将 <code>Sender</code> / <code>Receiver</code> 拆分并一次性消费</li><li>生命周期引用 vs <code>Arc</code> 的权衡与替换技巧</li></ul></li><li><p><strong>线程挂起/唤醒机制</strong></p><ul><li><code>std::thread::park / unpark</code> 的阻塞式等待模型</li></ul></li><li><p><strong>类型系统层面的“防呆”手段</strong></p><ul><li>利用 <code>PhantomData</code> 禁止跨线程误用</li><li><code>Drop</code> 手动回收，避免内存泄漏</li></ul></li><li><p><strong>一步步优化的思考路径</strong></p><ul><li>如何发现问题 → 提出假设 → 实现 → 验证 → 再迭代</li></ul></li></ol><blockquote><p>带着这些目标，跟随本文一路迭代到 <strong>v8</strong>，你将拥有一个高性能、零误用的 oneshot channel，以及一整套可迁移到其它并发场景的设计思维。</p></blockquote><h2 id="热身版-v0：基于锁的通道">热身版 v0：基于锁的通道</h2><p>我们先来实现一个<strong>万能版</strong> <code>channel</code> 热热身。顾名思义，<code>channel</code> 分为 2 个功能，<code>send</code> 和 <code>receive</code>，其中：</p><ul><li><code>send</code> 往 <code>channel</code> 一头放数据。</li><li><code>receive</code> 从 <code>channel</code> 另外一头取数据，如果没有数据，则阻塞住，直到有数据时返回取出数据并返回。</li></ul><p>在 Rust 中，我们可以用队列 <code>VecQueue</code> 来作为数据的承载，同时为了对队列访问的并发安全，我们需要使用锁 <code>Mutex</code> 来保护它，另外，在消费者取数据时，如果没有数据，则需要阻塞并等待唤醒（使用循环等待就太耗 CPU 了），所以我们可以使用条件变量 <code>Condvar</code> 来实现挂起和唤醒。</p><p>经过以上分析，我们可以定义如下的结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    collections::VecDeque,</span><br><span class="line">    sync::&#123;Condvar, Mutex&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,</span><br><span class="line">    item_ready: Condvar,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>send</code> 和 <code>receive</code> 方法也比较简单，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            queue: Mutex::<span class="title function_ invoke__">new</span>(VecDeque::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">            item_ready: Condvar::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: T) &#123;</span><br><span class="line">      <span class="comment">// 上锁并从队列后面插入数据</span></span><br><span class="line">        <span class="keyword">self</span>.queue.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">push_back</span>(message);</span><br><span class="line">        <span class="comment">// 唤醒一个等待数据的线程</span></span><br><span class="line">        <span class="keyword">self</span>.item_ready.<span class="title function_ invoke__">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">receive</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">      <span class="comment">// 抢占队列</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="keyword">self</span>.queue.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">          <span class="comment">// 尝试从队列中获取数据，如果获取到，则直接返回（并释放锁）</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(message) = b.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 没有数据，则挂起当前线程（同时释放锁）</span></span><br><span class="line">            b = <span class="keyword">self</span>.item_ready.<span class="title function_ invoke__">wait</span>(b).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，<code>self.queue.lock().unwrap()</code> 返回的 <code>b</code> 是一个 <code>MutextGuard</code>，所以当执行 <code>self.item_ready.wait(b)</code> 的时候，在挂起当前线程的时候，会释放 <code>b</code>，所以这里不会一直占用锁，而导致其他线程抢不到锁。</p><p>这个版本的实现在功能上当然没有问题，但是在性能上还有非常多可以优化的地方，尤其是在锁的使用上，在高并发的情况下，锁的竞争会非常激烈。</p><p>OK，热完身后，我们开始基于这个实现，来一步步实现一个高性能的 <code>oneshot channel</code>！</p><h2 id="基础版-v1：unsafe-提醒使用者">基础版 v1：unsafe 提醒使用者</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    queue: Mutex&lt;VecDeque&lt;T&gt;&gt;,</span><br><span class="line">    item_ready: Condvar,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来分析一下，一个 <code>oneshot channel</code> 的结构，需要包含哪些字段。</p><ol><li>首先它可能会有 0 条数据或 1 条数据，所以很当然，数据可以用一个 <code>Option</code> 来承载。</li><li>另外，<code>send</code> 和 <code>receive</code> 可以在不同的线程中被调用，所以我们只能用共享只读引用，而不是用 <code>mut</code> 独享可变引用，但是 <code>send</code> 和 <code>receive</code> 都需要对数据进行修改，所以我们这里就需要一个支持内部可变性的数据结构，这个时候，就用到了上篇 <a href="https://hedon.top/2025/05/13/rust-action-spinlock/#%E5%8D%87%E7%BA%A7%E7%89%88-v1">Rust 实战丨手写一个 SpinLock</a> 介绍的 <code>UnsafeCell&lt;T&gt;</code>，它允许在共享引用下进行内部可变性修改，是 Rust 并发原语的基石，这里不再赘述。</li><li>最后，我们需要一个变量来表明是否有数据，为了并发安全，这里可以用 <code>AtomicBool</code>，为此，我们也增加了一个 <code>is_ready</code> 的方法，用于判断数据是否已准备好。对于原子变量，我们使用一对 <code>Release</code> 和 <code>Acquire</code>（<code>Release</code> 确保之前的写入对其他线程可见，<code>Acquire</code> 确保能看到之前的 <code>Release</code> 写入）来确保原子变量的跨线程可见性。</li></ol><p>基于以上分析，我们定出了新的 <code>Channel</code> 结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    message: UnsafeCell&lt;<span class="type">Option</span>&lt;T&gt;&gt;,</span><br><span class="line">    ready: AtomicBool,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 <code>send</code>、<code>receive</code> 和 <code>is_ready</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            message: UnsafeCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">            ready: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Safety: Only call this once!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: T) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.message.<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">write</span>(<span class="title function_ invoke__">Some</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.ready.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_ready</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.ready.<span class="title function_ invoke__">load</span>(Ordering::Acquire)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Safety: Only call this once,</span></span><br><span class="line">    <span class="comment">/// and only after is_ready() returns true!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">receive</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.message.<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个版本中：</p><ol><li>我们暂且使用 <code>unsafe</code> 加注释的方式，来 <strong>提醒</strong> 使用者，<code>send</code> 和 <code>receive</code> 只能被调用一次，同时，在调用 <code>receive</code> 之前，必须先使用 <code>is_ready</code> 进行数据检查。</li><li>对于原子变量，我们使用一对 Release 和 Acquire 来确保原子变量的跨线程可见性，具体可参考 <a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a>。</li></ol><p>另外别忘了，<code>UnsafeCell&lt;T&gt;</code> 是不支持 <code>Sync</code> 的，所以为了我们的 <code>Channel</code> 可以跨线程使用，我们需要为其实现 <code>Sync</code> trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Channel&lt;T&gt; 可以在不同的线程中被分别执行 send 和 receive，所以它的引用可以在线程中共享，所以需要实现 Sync；</span></span><br><span class="line"><span class="comment">// 2. T 由线程 1 生成并放入 Channel，然后由线程 2 从 Channel 中获取，所以它需要从一个线程转移到另外一个线程，所以需要实现 Send。</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Channel</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        channel.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> channel.<span class="title function_ invoke__">is_ready</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msg</span> = <span class="keyword">unsafe</span> &#123; channel.<span class="title function_ invoke__">receive</span>() &#125;;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(msg, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                channel.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> channel.<span class="title function_ invoke__">is_ready</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">unsafe</span> &#123; channel.<span class="title function_ invoke__">receive</span>() &#125;;</span><br><span class="line">                <span class="built_in">assert_eq!</span>(res, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础版-v2：使用-MaybeUninit-替代-Option-减少内存开销">基础版 v2：使用 MaybeUninit 替代 Option 减少内存开销</h2><p>我们先来思考一个问题：<strong>Option&lt;T&gt; 的内存占用是多少？</strong></p><blockquote><p>结论是：：<strong><code>Option&lt;T&gt;</code> 相比于 T，可能需要额外消耗标记位和填充位的空间</strong>。具体可参考<u>附录：1. Option&lt;T&gt; 的内存占用是多少</u>。</p></blockquote><p>另外一点是，<code>Option&lt;T&gt;</code> 其实已经包含了是否存在值的信息了，它跟 <code>ready</code> 这个标志的作用其实重复了，有一些浪费。</p><p>在当下场景，我们可以使用另外一个数据结构来替代 <code>Option&lt;T&gt;</code> —— <code>MaybeUninit&lt;T&gt;</code>，相比于 <code>Option&lt;T&gt;</code>，它有以下优势：</p><ol><li><strong>内存占用优化</strong>：在 <code>Option&lt;T&gt;</code> 中，对于非空指针优化（Niche Optimization）的类型，<code>None</code> 会占用额外的空间（一个字节的标签+可能的对齐填充）。而 <code>MaybeUninit&lt;T&gt;</code> 本身就是一个大小与 <code>T</code> 相同的未初始化内存，它没有标签，因此不会引入额外的内存开销。</li><li><strong>避免初始化开销</strong>：使用 <code>Option&lt;T&gt;</code> 时，在初始化时设置为 <code>None</code>，实际上会写入一个表示 <code>None</code> 的值（即进行初始化）。而 <code>MaybeUninit&lt;T&gt;</code> 的 <code>uninit()</code> 不会对内存进行任何初始化，这在性能敏感的场景下可以避免不必要的初始化开销（特别是当 <code>T</code> 很大时）。</li><li><strong>更灵活地控制初始化</strong>：在通道的实现中，消息可能由生产者写入，然后通过设置 <code>ready</code> 标志来通知消费者。使用 <code>MaybeUninit</code> 允许我们延迟初始化，直到实际需要写入消息的时候。这样，在通道创建时，我们不需要为 <code>T</code> 类型的值进行任何初始化（即使是 <code>None</code>），而是留出一块未初始化的内存，在后续由生产者写入实际的值。</li><li><strong>与原子标志配合更高效</strong>：在上个版本的视线中，<code>ready</code> 是一个 <code>AtomicBool</code>，用于指示消息是否就绪。在 <code>Option&lt;T&gt;</code> 版本中，我们需要检查 <code>Option</code> 是否为 <code>Some</code>，同时还要检查 <code>ready</code> 标志。而使用 <code>MaybeUninit</code> 后，我们完全依赖 <code>ready</code> 标志来判断消息是否可用，避免了双重检查（因为 <code>MaybeUninit</code> 本身不携带状态，所以状态完全由 <code>ready</code> 控制）。这样，结构体的内存布局更紧凑，且访问模式更直接。</li><li><strong>潜在的性能提升</strong>：由于避免了额外的标签和初始化，以及更紧凑的内存布局，可能会提高缓存利用率，从而提升性能。</li></ol><p><code>MaybeUninit&lt;T&gt;</code> 有以下常用方法：</p><table><thead><tr><th>常用方法</th><th>作用</th><th>安全级别</th></tr></thead><tbody><tr><td><code>MaybeUninit::uninit()</code></td><td>创建一块<strong>完全未初始化</strong>的内存</td><td><code>const fn</code>、<code>safe</code></td></tr><tr><td><code>as_mut_ptr()</code> / <code>as_ptr()</code></td><td>取出裸指针，供外部写入或读取</td><td><code>safe</code></td></tr><tr><td><code>assume_init()</code> / <code>assume_init_read()</code></td><td>告诉编译器“这里已经是一个合法的 <code>T</code> 了”，并返回它</td><td><code>unsafe</code>（因为你得保证真初始化过）</td></tr><tr><td><code>write(val)</code></td><td><strong>按位把 <code>val</code> 复制/移动</strong> 到这块未初始化内存；此后视为已初始化</td><td><code>unsafe</code></td></tr></tbody></table><p>经过上面一顿分析，我们来使用 <code>MaybeUninit&lt;T&gt;</code> 来替代 <code>Option&lt;T&gt;</code>，进一步减少内存占用和提升性能，新的 <code>Channel</code> 结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    message: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,</span><br><span class="line">    ready: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">          <span class="comment">// 创建一块完全未初始化的内存，先占位</span></span><br><span class="line">            message: UnsafeCell::<span class="title function_ invoke__">new</span>(MaybeUninit::<span class="title function_ invoke__">uninit</span>()),</span><br><span class="line">            ready: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 <code>send</code> 和 <code>receive</code> 实现更新如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// Safety: Only call this once!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: T) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="comment">// 从 UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt; 中取出 MaybeUninit&lt;T&gt; 并写入数据。</span></span><br><span class="line">            (*<span class="keyword">self</span>.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">write</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.ready.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Safety: Only call this once,</span></span><br><span class="line">    <span class="comment">/// and only after is_ready() returns true!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">receive</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">      <span class="comment">// 从 UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt; 中取出 MaybeUninit&lt;T&gt; 并读出数据。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*<span class="keyword">self</span>.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">assume_init_read</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>send</code> 中，<code>(*self.message.get())</code> 从 <code>UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;</code> 中取出 <code>MaybeUninit&lt;T&gt;</code>，然后调用 <code>write</code> 方法把 <code>message</code> 写入这块未初始化的内存中，此后视为已初始化，并可以使用使用 <code>assume_init_read</code> 进行读取。</p><p>修改后，测试代码没有发生变化，我们执行之前的测试代码，发现还是可以通过的！</p><h2 id="基础版-v3：增加动态检查提高安全性">基础版 v3：增加动态检查提高安全性</h2><p>上述版本中，我们通过 <code>unsafe</code> 和注释去“要求”调用者严格遵循以下约束：</p><ol><li><code>send</code> 和 <code>receive</code> 最多只调用一次。</li><li><code>receive</code> 调用之前，必须先经过 <code>is_ready</code> 的检查。</li></ol><p>在这个版本中，我们加一下动态检查，如果调用者不按要求做事，那就直接 <code>panic</code> 给出告警。</p><p>在 <code>receive</code> 中，我们需要做 2 点保证：① 已经有数据了，② 数据只被消耗了一次。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">receive</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="keyword">self</span>.ready.<span class="title function_ invoke__">swap</span>(<span class="literal">false</span>, Ordering::Acquire) &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;no message available!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; (*<span class="keyword">self</span>.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">assume_init_read</span>() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用 <code>swap</code>，将 <code>ready</code> 从 <code>false</code> 转为 <code>true</code>，达到了 2 个目的：</p><ol><li>如果返回了 <code>false</code>，则说明之前的 <code>ready</code> 为 <code>false</code>，即数据没准备好。</li><li>如果返回了 <code>true</code>，则说明数据已经准备好了，这个时候，也已经将 <code>ready</code> 置为 <code>false</code>，这样后面调用的 <code>receive</code> 也将失败。</li></ol><p>对于 <code>send</code>，我们需要保证只写入一次，所以这里我们需要引入一个新的变量 <code>in_user</code>，表示 <code>send</code> 是否已经使用了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    message: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,</span><br><span class="line">    in_use: AtomicBool, <span class="comment">// 新变量，表示 send 是否已经使用了。</span></span><br><span class="line">    ready: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            message: UnsafeCell::<span class="title function_ invoke__">new</span>(MaybeUninit::<span class="title function_ invoke__">uninit</span>()),</span><br><span class="line">            in_use: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">            ready: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>send</code> 中，我们依旧使用 <code>swap</code>，来将 <code>in_use</code> 从转为 <code>true</code>，如果返回 <code>true</code>，则说明之前已经执行过 <code>send</code> 了，这个时候将执行 panic 进行告警。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Panics when trying to send more than one message.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: T) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.in_use.<span class="title function_ invoke__">swap</span>(<span class="literal">true</span>, Ordering::Relaxed) &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;can&#x27;t send more than one message&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        (*<span class="keyword">self</span>.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">write</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.ready.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述的 2 个优化，我们的 <code>Channel</code> 又“安全”了一丢丢！</p><h2 id="基础版-v4：实现-Drop-自动清理无用内存">基础版 v4：实现 Drop 自动清理无用内存</h2><p>因为我们使用了 <code>MaybeUninit&lt;T&gt;</code>，所以我们需要自己管理 <code>T</code> 的内存管理，但在上述的实现中，可能存在一种情况，导致内存得不到释放：<strong>我们只执行了 <code>send</code>，但直到 <code>Channel</code> 超过作用域的时候，都没有被 <code>receive</code></strong>。</p><p>为此，我们可以为 <code>Channel</code> 实现 <code>Drop</code> trait，当有数据的时候，对<code>MaybeUninit&lt;T&gt;</code> 进行内存释放：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> *<span class="keyword">self</span>.ready.<span class="title function_ invoke__">get_mut</span>() &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.message.<span class="title function_ invoke__">get_mut</span>().<span class="title function_ invoke__">assume_init_drop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安全非阻塞版-v5：提供安全方法，减少使用者误用">安全非阻塞版 v5：提供安全方法，减少使用者误用</h2><p>在这个版本中，我们来解决前面实现的最大问题：<strong>方法是不安全的，严重依赖调用者的自觉性，没有充分发挥 Rust 强大编译器的检查能力</strong>。</p><p>回顾我们的需求：<strong>我们要实现的是一个 <code>oneshot channel</code>，即只能调用一次 <code>send</code> 和 <code>receive</code></strong>。</p><p>第一个问题是：如何利用 Rust 天然的编译器检查能力来约束这一点呢？很明显，就是<strong>所有权机制</strong>！什么东西只能执行一次呢？消耗所有权的东西！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于第一个参数为 self 的方法，执行时，会转移所有权，执行后，原变量就不能再用了，因为所有权已经转移了。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do</span>(<span class="keyword">self</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>好，那第二个问题就来了：<code>self</code> 方法只能调用一次，但很明显我们总共需要 2 次的调用（<code>send</code> 和 <code>receive</code>），所以这里我们可以将 <code>Channel</code> 进行拆开，分成 <code>Sender</code> 和 <code>Receiver</code>。</p><p>那第三个问题也就随之而来了，<code>Sender</code> 和 <code>Receiver</code> 都需要持有 <code>Channel</code>，并且可能处于不同的线程，这里我们可以先用 <code>Arc</code> 来对 <code>Channel</code> 进行引用。</p><p>解决了上述 3 个问题，我们可以梳理新的数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Sender</span>&lt;T&gt; &#123;</span><br><span class="line">    channel: Arc&lt;Channel&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Receiver</span>&lt;T&gt; &#123;</span><br><span class="line">    channel: Arc&lt;Channel&lt;T&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    message: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,</span><br><span class="line">    ready: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">channel</span>&lt;T&gt;() <span class="punctuation">-&gt;</span> (Sender&lt;T&gt;, Receiver&lt;T&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Arc::<span class="title function_ invoke__">new</span>(Channel &#123;</span><br><span class="line">        message: UnsafeCell::<span class="title function_ invoke__">new</span>(MaybeUninit::<span class="title function_ invoke__">uninit</span>()),</span><br><span class="line">        ready: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">    (Sender &#123; channel: a.<span class="title function_ invoke__">clone</span>() &#125;, Receiver &#123; channel: a &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Channel</code> 中移除了 <code>in_use</code> 属性，因为我们已经有 <code>self</code> 做所有权检查了，不再需要 <code>in_use</code> 来避免重复调用 <code>send</code> 了。</li><li>新增了 <code>Sender&lt;T&gt;</code> 和 <code>Receiver&lt;T&gt;</code> 两个结构，它们都各自持有了一个 <code>Arc&lt;Channel&gt;</code>。</li></ol><p>对应的 <code>send</code> 和 <code>receive</code> 方法当然也就转移到 <code>Sender&lt;T&gt;</code> 和 <code>Receiver&lt;T&gt;</code> 身上了，实现也和之前基本一致：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Sender&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">send</span>(<span class="keyword">self</span>, messgae: T) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*<span class="keyword">self</span>.channel.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">write</span>(messgae) &#125;;</span><br><span class="line">        <span class="keyword">self</span>.channel.ready.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Receiver&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_ready</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.channel.ready.<span class="title function_ invoke__">load</span>(Ordering::Relaxed)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Safety: only after is_ready() returns true!</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">receive</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.channel.ready.<span class="title function_ invoke__">swap</span>(<span class="literal">false</span>, Ordering::Acquire) &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;no message available!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*<span class="keyword">self</span>.channel.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">assume_init_read</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drop 没变</span></span><br></pre></td></tr></table></figure><p>修改了结构了，我们需要修改对应的测试代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = <span class="title function_ invoke__">channel</span>();</span><br><span class="line">    sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> receiver.<span class="title function_ invoke__">is_ready</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msg</span> = receiver.<span class="title function_ invoke__">receive</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(msg, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = <span class="title function_ invoke__">channel</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line">            sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>); <span class="comment">// 没有 unsafe 了！</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> receiver.<span class="title function_ invoke__">is_ready</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">res</span> = receiver.<span class="title function_ invoke__">receive</span>(); <span class="comment">// 没有 unsafe 了！</span></span><br><span class="line">                <span class="built_in">assert_eq!</span>(res, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最新的测试代码中，我们已经不再需要 <code>unsafe</code> 代码了！这对于使用者来说，就非常友好了！</p><p>而且这个时候，你如果尝试执行多次 <code>send</code> 和 <code>receive</code> 的时候，编译器就会报错了！</p><p>不过它还是有 2 个缺点：</p><ol><li><code>Arc</code> 的复制还是有一些开销的。</li><li>我们依旧依赖使用者提前用 <code>is_ready</code> 来检查，否则直接调用 <code>receive</code> 就有可能会 <code>panic</code>。</li></ol><p>我们先来解决第 1 个问题。</p><h2 id="安全非阻塞版-v6：使用生命周期加引用，避免-Arc-的复制开销">安全非阻塞版 v6：使用生命周期加引用，避免 Arc 的复制开销</h2><p>为了避免 Arc 的开销，我们需要在 <code>Sender&lt;T&gt;</code> 和 <code>Receiver&lt;T&gt;</code> 中持有 <code>Channel&lt;T&gt;</code> 的引用，而引用的对象的生命周期是不确定的，所以我们需要加入生命周期标注，来告诉编译器我们的引用是逻辑自洽的。</p><p>新的结构和构造函数如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Sender</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    channel: &amp;<span class="symbol">&#x27;a</span> Channel&lt;T&gt;, <span class="comment">// 使用引用替代 Arc，并加入生命周期标注</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Receiver</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    channel: &amp;<span class="symbol">&#x27;a</span> Channel&lt;T&gt;, <span class="comment">// 使用引用替代 Arc，并加入生命周期标注</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    message: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,</span><br><span class="line">    ready: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Channel&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            message: UnsafeCell::<span class="title function_ invoke__">new</span>(MaybeUninit::<span class="title function_ invoke__">uninit</span>()),</span><br><span class="line">            ready: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">split</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> (Sender&lt;<span class="symbol">&#x27;a</span>, T&gt;, Receiver&lt;<span class="symbol">&#x27;a</span>, T&gt;) &#123;</span><br><span class="line">        *<span class="keyword">self</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        (Sender &#123; channel: <span class="keyword">self</span> &#125;, Receiver &#123; channel: <span class="keyword">self</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drop 没变</span></span><br></pre></td></tr></table></figure><p>在这个版本的实现中，我们新增了 <code>split</code> 方法：</p><ol><li>其中参数 <code>&amp;'a mut self</code> 表明它是一个独占引用，即 <code>channel.split()</code> 不会有并发问题。</li><li>第一行代码 <code>*self = Self::new()</code> 我们对原有的 <code>Channel</code> 进行重置，保证<strong>拆分之前通道里绝对没有残留数据</strong>，避免旧消息被下一对 <code>Sender/Receiver</code> 误使用。</li><li><code>'a</code> 直接来自于 <code>&amp;'a mut self</code>，保证两端把手<strong>绝不会比原始 <code>Channel</code> 活得更久</strong>。</li></ol><p>新的测试代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel.<span class="title function_ invoke__">split</span>();</span><br><span class="line">    sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> receiver.<span class="title function_ invoke__">is_ready</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msg</span> = receiver.<span class="title function_ invoke__">receive</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(msg, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel.<span class="title function_ invoke__">split</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">            sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> !receiver.<span class="title function_ invoke__">is_ready</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(receiver.<span class="title function_ invoke__">receive</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安全阻塞版-v7：去掉-is-ready-完全避免使用者误调用">安全阻塞版 v7：去掉 is_ready 完全避免使用者误调用</h2><p>截止目前的实现版本中，我们还是依赖使用者在执行 <code>receive</code> 之前先执行 <code>is_ready</code> 进行数据检查，还是存在一定的误操作性。现在我们来实现一个完全阻塞的版本，来完全避免这个情况。</p><p>我们需要做几件事情：</p><ol><li>去掉 <code>is_ready</code> 方法；</li><li>在 <code>receive</code> 中，根据 <code>ready</code> 判断是否存在数据：<ol><li>如果存在，则直接取出数据并返回；</li><li>如果不存在，则需要先挂起当前线程，等待唤醒（直接 CPU 循环检查肯定可以，但不够优雅！咱不干！）；</li></ol></li><li>在 <code>send</code> 中，放入数据后，尝试唤醒可能处于挂起中的线程。</li></ol><p>那现在最重要的一个问题是：**如何唤醒处于挂起中的线程？**更进一步，<strong>唤醒哪个线程？</strong></p><p>这里其实是说不定的，因为 <code>Sender</code> 和 <code>Receiver</code> 都可能被放入任何一个线程中，不过在 <a href="https://marabos.nl/atomics/building-channels.html">Rust Atomics and Locks</a> 书中，作者假定了 <code>Receiver</code> 会固定在调用 <code>split</code> 的那个线程。</p><p>笔者认为这个假设是简单且有效的，回顾一下我们前面举的 Go 语言的 2 个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 类似于 split</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ... do something</span></span><br><span class="line"><span class="built_in">close</span>(done)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-done  <span class="comment">// receiver</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">oneShot := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)  <span class="comment">// 类似于 split</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">oneShot &lt;- generateText()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">text := &lt;-oneShot  <span class="comment">// receiver</span></span><br><span class="line">doSthWithText(text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这两个最常见的 <code>oneshot channel</code> 的例子中，<code>Receiver</code> 就是处于调用 <code>split</code> 的线程中。所以我们可以基于这个假设来实现这个版本。</p><p>先回顾下 <code>Thread</code> 2 个最核心的方法：</p><ul><li><code> Thread.park(thread)</code>: 挂起线程，等待唤醒。</li><li><code>thread.unpark()</code>: 唤醒线程。</li></ul><p>首先我们需要在 <code>Sender</code> 中保存待唤醒的线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Sender</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    channel: &amp;<span class="symbol">&#x27;a</span> Channel&lt;T&gt;,</span><br><span class="line">    receiving_thread: Thread,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>split()</code> 的时候，我们需要获取当前线程并保存在 <code>Sender</code> 中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">split</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> (Sender&lt;<span class="symbol">&#x27;a</span>, T&gt;, Receiver&lt;<span class="symbol">&#x27;a</span>, T&gt;) &#123;</span><br><span class="line">    *<span class="keyword">self</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    (</span><br><span class="line">        Sender &#123;</span><br><span class="line">            channel: <span class="keyword">self</span>,</span><br><span class="line">          <span class="comment">// 获取当前线程。记住！这里我们假设了 receiver 会固定在 split 的线程中！</span></span><br><span class="line">            receiving_thread: thread::<span class="title function_ invoke__">current</span>(),</span><br><span class="line">        &#125;,</span><br><span class="line">        Receiver &#123; channel: <span class="keyword">self</span> &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>recevie</code> 的时候，如果没有数据，我们就可以挂起当前线程，等待唤醒：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Receiver&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">receive</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">while</span> !<span class="keyword">self</span>.channel.ready.<span class="title function_ invoke__">swap</span>(<span class="literal">false</span>, Ordering::Acquire) &#123;</span><br><span class="line">            thread::<span class="title function_ invoke__">park</span>(); <span class="comment">// 挂起当前线程，即 thread::current() 线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*<span class="keyword">self</span>.channel.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">assume_init_read</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>send</code> 完数据后，唤醒可能挂起的线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Sender&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">send</span>(<span class="keyword">self</span>, messgae: T) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (*<span class="keyword">self</span>.channel.message.<span class="title function_ invoke__">get</span>()).<span class="title function_ invoke__">write</span>(messgae) &#125;;</span><br><span class="line">        <span class="keyword">self</span>.channel.ready.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release);</span><br><span class="line">        Thread::<span class="title function_ invoke__">unpark</span>(&amp;<span class="keyword">self</span>.receiving_thread); <span class="comment">// 唤醒 receiver 线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后删除之前的 <code>is_ready</code> 方法，然后更新我们的测试代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel.<span class="title function_ invoke__">split</span>();</span><br><span class="line">    sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = receiver.<span class="title function_ invoke__">receive</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel.<span class="title function_ invoke__">split</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">            sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(receiver.<span class="title function_ invoke__">receive</span>(), <span class="number">1</span>); <span class="comment">// 不再需要检查 is_ready，这里会阻塞一直直到有数据到来</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终版-v8：使用-PhantomData-来保证-Receiver-处于-split-线程">最终版 v8：使用 PhantomData 来保证 Receiver 处于 split() 线程</h2><p>是不是觉得，上述实现已经完美无瑕了！其实不然，我们虽然假设了 <code>Receiver</code> 处于调用 <code>split()</code> 的线程中，但是还是无法阻止使用者将 <code>Receiver</code> 转移到其他线程。</p><p>再次回顾下我们现在的 <code>Channel</code> 和 <code>Receiver</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Receiver</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    channel: &amp;<span class="symbol">&#x27;a</span> Channel&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Channel</span>&lt;T&gt; &#123;</span><br><span class="line">    message: UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;,</span><br><span class="line">    ready: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Channel</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们为 <code>Channel&lt;T&gt;</code> 实现了 <code>Sync</code> trait，而标准库中有这 2 行代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> &amp;T &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> &amp;T &#123;&#125;</span><br></pre></td></tr></table></figure><p>所以 <code>&amp;Channel&lt;T&gt;</code> 实现了 <code>Sync/Send</code> trait，而 <code>Receiver</code> 只持有了一个 <code>&amp;'a Channel&lt;T&gt;</code>，所以它也是 <code>Send</code> 的！</p><p>所以 <code>Receiver</code> 是可以被转移到其他线程的，即下述的测试代码在编译上也是通过的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">channel</span> = Channel::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = channel.<span class="title function_ invoke__">split</span>(); <span class="comment">// 执行 split() 的线程</span></span><br><span class="line">    thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">            sender.<span class="title function_ invoke__">send</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里在另外一个线程中，执行了 `receiver.receive()`</span></span><br><span class="line">        s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">            <span class="built_in">assert_eq!</span>(receiver.<span class="title function_ invoke__">receive</span>(), <span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们执行后会发现，<code>receiver.receive()</code> 会被永久阻塞住，这是因为 <code>sender.send(1)</code> 只会唤醒执行 <code>split()</code> 的线程。</p><p>为了避免这种情况的发生，我们需要强行防止 <code>Receiver</code> 实现 <code>Send</code> trait！</p><p>怎么办呢？我们需要做到 2 件事情：</p><ol><li>让 <code>Receiver</code> 持有一个非 <code>Sync</code> 的属性；</li><li>这个属性除了标记没有其他作用，最好不要占用任何的资源。</li></ol><p>这里我们介绍一位新朋友：<code>PhantomData</code>：</p><blockquote><p><code>PhantomData</code> 是一个零大小类型（Zero-Sized Type, ZST），用于在编译期向类型系统传递额外信息，而不占用运行时内存。</p><p>我们可以用它在包一个 <code>!Send</code> 的类型，这样 <code>Receiver</code> 就是 <code>!Send</code> 的了。关于 <code>PhantomData</code> 的更多介绍，可以参考<u>附录 2：PhantomData</u>。</p></blockquote><p>在介绍完 <code>PhantomData</code> 后，我们就可以使用它来防止 <code>Receiver</code> 实现 <code>Send</code> trait 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Receiver</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    channel: &amp;<span class="symbol">&#x27;a</span> Channel&lt;T&gt;,</span><br><span class="line">    _no_send: PhantomData&lt;*<span class="title function_ invoke__">const</span> ()&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>*const()</code> 是 <code>!Send</code> 的，所以我们的 <code>Receiver</code> 再也不会被转移到其他线程了，而 <code>send</code> 是要求 <code>self</code>，所以即便是 <code>Sync</code> 的也无所谓了，因为无法通过引用来执行 <code>receive()</code> 方法。</p><p>现在我们可以再次执行上面的测试代码（强行将 Receiver 移动到其他线程中），将会得到以下的报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `*const ()` cannot be sent between threads safely</span><br><span class="line"><span class="meta prompt_">   --&gt; </span><span class="language-bash">src/oneshotchannel.rs:103:21</span></span><br><span class="line">    |</span><br><span class="line">103 |               s.spawn(|| &#123;</span><br><span class="line">    |                 ----- ^-</span><br><span class="line">    |                 |     |</span><br><span class="line">    |  _______________|_____within this `&#123;closure@oneshotchannel.rs:103:21&#125;`</span><br><span class="line">    | |               |</span><br><span class="line">    | |               required by a bound introduced by this call</span><br><span class="line">104 | |                 assert_eq!(receiver.receive(), 1);</span><br><span class="line">105 | |             &#125;);</span><br><span class="line">    | |_____________^ `*const ()` cannot be sent between threads safely</span><br></pre></td></tr></table></figure><p>到这里，通过 8 个版本，我们一步步实现了一个高性能、低内存占用且安全可用的 <code>oneshot channel</code> 了！</p><h2 id="总结">总结</h2><p>至此，通过 8 个小版本，我们不仅手写了一个 <strong>高性能、安全友好的 oneshot channel</strong>，还更进一步体验了 Rust 在并发领域 <strong>“以类型系统驱动正确性”</strong> 的威力。我们来做一个简单的小结。</p><p>关键收获：</p><table><thead><tr><th>版本</th><th>新增能力</th><th>解决了什么问题</th></tr></thead><tbody><tr><td><strong>v0</strong></td><td><code>Mutex</code> + <code>Condvar</code> 通用通道</td><td>打开话题、对比后续无锁方案</td></tr><tr><td><strong>v1</strong></td><td><code>UnsafeCell&lt;Option&lt;T&gt;&gt;</code> + <code>AtomicBool</code></td><td>去锁化、最小可行一次性通道</td></tr><tr><td><strong>v2</strong></td><td>替换为 <code>MaybeUninit&lt;T&gt;</code></td><td>节省内存&amp;避免双状态检查</td></tr><tr><td><strong>v3</strong></td><td>运行时检查 (<code>swap</code>)</td><td>阻止未准备/二次调用导致 UB</td></tr><tr><td><strong>v4</strong></td><td><code>Drop</code> 清理</td><td>防止“只 send 不 recv”泄漏</td></tr><tr><td><strong>v5</strong></td><td><code>Sender</code> / <code>Receiver</code> 所有权 API</td><td>编译期保证“仅调用一次”</td></tr><tr><td><strong>v6</strong></td><td>生命周期引用替换 <code>Arc</code></td><td>消除引用计数开销</td></tr><tr><td><strong>v7</strong></td><td><code>park / unpark</code> 阻塞模型</td><td>使用者不再需要轮询 <code>is_ready</code></td></tr><tr><td><strong>v8</strong></td><td><code>PhantomData</code> 防跨线程误用</td><td>类型系统彻底封死错误用法</td></tr></tbody></table><p>核心记忆点：</p><ul><li><strong>内部可变性</strong>：<code>UnsafeCell</code> 是所有并发原语的基石。</li><li><strong>延迟初始化</strong>：<code>MaybeUninit&lt;T&gt;</code> + “就绪标志” 是零成本组合。</li><li><strong>Release / Acquire</strong>：最轻量的跨线程可见性保障。</li><li><strong>所有权设计 API</strong>：让编译器替你兜底逻辑约束。</li><li><strong>PhantomData</strong>：零大小但能影响 <code>Send/Sync</code> 的类型级标记。</li><li><strong>迭代思路</strong>：先跑通，再收口安全性与性能，最后用类型系统“防呆”。</li></ul><p>完整的代码可以参考：<a href="https://github.com/hedon-rust-road/conutils/blob/main/src/oneshot.rs">conutils-oneshot</a>。</p><h2 id="oneshot-crate-浅探">oneshot crate 浅探</h2><h2 id="附录">附录</h2><h3 id="1-Option-T-的内存占用是多少？">1. Option&lt;T&gt; 的内存占用是多少？</h3><p>在 Rust 中，<code>Option&lt;T&gt;</code> 类型占用的内存，取决于泛型参数 <code>T</code> 的类型特性。具体可分为两种情况：</p><ul><li>当 T 是<strong>非指针类型</strong>（如基本类型、结构体等）时，<code>Option&lt;T&gt;</code> 需要额外的空间存储 Some 或 None 的标签，此时：<ul><li>内存布局：包含一个 1 字节的标签（标识 Some 或 None）和 <code>T</code> 类型的数据空间（可能包含对齐填充）。</li><li>即使为 <code>None</code>，仍需保留 <code>T</code> 所需的内存空间（含填充），以保障枚举值大小统一。如 <code>Option&lt;i32&gt;</code> 占用 8 字节（1 字节标签 + 4 字节 i32 + 3 字节填充）。</li></ul></li><li>当 T 是<strong>不可为空的指针类型</strong>（如 Box&lt;T&gt;、&amp;T、&amp;mut T）时，Rust 编译器会启用<strong>空指针优化</strong>（Niche Optimization）。即利用<strong>指针不能为 0</strong> 的特性，将 <code>None</code> 标识为全零位模式（0x00），而 <code>Some(ptr)</code> 存储实际指针地址，此时无需额外标签。这个时候，<code>None</code> 和 <code>Some(T)</code> 不占用任何的额外空间，大小与 T 相同。</li></ul><p>我们可以写个程序来简单验证一下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">test_option</span>() &#123;</span><br><span class="line">    <span class="comment">// 1. 基本数据类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span>: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i_none</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i_some</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;基本类型：&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;i32: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;i), &amp;i); <span class="comment">// 4 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;None&lt;i32&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;i_none), &amp;i_none); <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Some&lt;i32&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;i_some), &amp;i_some); <span class="comment">// 8 bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 自定义类型</span></span><br><span class="line">    <span class="meta">#[repr(C)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">        a: <span class="type">u64</span>,</span><br><span class="line">        b: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = Data &#123; a: <span class="number">1</span>, b: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_none</span>: <span class="type">Option</span>&lt;Data&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data_some</span>: <span class="type">Option</span>&lt;Data&gt; = <span class="title function_ invoke__">Some</span>(Data &#123; a: <span class="number">1</span>, b: <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n自定义结构体：&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Data: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;data), &amp;data); <span class="comment">// 16 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;None&lt;Data&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;data_none), &amp;data_none); <span class="comment">// 24 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Some&lt;Data&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;data_some), &amp;data_some); <span class="comment">// 24 bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 指针类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b_none</span>: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="type">i32</span>&gt;&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b_some</span>: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="type">i32</span>&gt;&gt; = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n指针类型：&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Box&lt;i32&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;b), &amp;b); <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;None&lt;Box&lt;i32&gt;&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;b_none), &amp;b_none); <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Some&lt;Box&lt;i32&gt;&gt;: &#123;&#125; bytes, ptr: &#123;:p&#125;&quot;</span>, mem::<span class="title function_ invoke__">size_of_val</span>(&amp;b_some), &amp;b_some); <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none_value</span> = <span class="keyword">unsafe</span> &#123; *(&amp;b_none <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i64</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;None&lt;Box&lt;i32&gt;&gt; bit pattern: &#123;:#x&#125;&quot;</span>, none_value); <span class="comment">// 0x0</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">some_value</span> = <span class="keyword">unsafe</span> &#123; *(&amp;b_some <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i64</span>) &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;None&lt;Box&lt;i32&gt;&gt; bit pattern: &#123;:#x&#125;&quot;</span>, some_value); <span class="comment">// 0x15d0043c0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在笔者的电脑下，输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">基本类型：</span><br><span class="line">i32: 4 bytes, ptr: 0x16bef203c</span><br><span class="line">None&lt;i32&gt;: 8 bytes, ptr: 0x16bef2040</span><br><span class="line">Some&lt;i32&gt;: 8 bytes, ptr: 0x16bef2048</span><br><span class="line"></span><br><span class="line">自定义结构体：</span><br><span class="line">Data: 16 bytes, ptr: 0x16bef2200</span><br><span class="line">None&lt;Data&gt;: 24 bytes, ptr: 0x16bef2210</span><br><span class="line">Some&lt;Data&gt;: 24 bytes, ptr: 0x16bef2228</span><br><span class="line"></span><br><span class="line">指针类型：</span><br><span class="line">Box&lt;i32&gt;: 8 bytes, ptr: 0x16bef23f8</span><br><span class="line">None&lt;Box&lt;i32&gt;&gt;: 8 bytes, ptr: 0x16bef2400</span><br><span class="line">Some&lt;Box&lt;i32&gt;&gt;: 8 bytes, ptr: 0x16bef2408</span><br><span class="line">None&lt;Box&lt;i32&gt;&gt; bit pattern: 0x0</span><br></pre></td></tr></table></figure><p>通过输出我们可以观察到经过<strong>空指针优化</strong>，<code>Option&lt;Box&lt;i32&gt;&gt;</code> 的 <code>None</code> 和 <code>Some</code> 都只占 <strong>8 字节</strong>（与 <code>Box&lt;i32&gt;</code> 相同），同时通过为 <code>None</code> 复用类型的无效位模式（如 <code>0x0</code>）消除枚举标签，实现零成本抽象。</p><h3 id="2-PhantomData">2. PhantomData</h3><p>Rust 中的 <code>PhantomData</code> 是一个零大小类型（Zero-Sized Type, ZST），用于在编译期向类型系统传递额外信息，而不占用运行时内存。它在泛型编程、生命周期管理和所有权标记中扮演关键角色。</p><p>它有以下的核心特性和作用：</p><ol><li><p><strong>零内存开销</strong>：<code>PhantomData&lt;T&gt;</code> 本身不存储任何数据，编译后会被优化掉，因此<strong>不会增加结构体的实际内存占用</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker::PhantomData;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>&lt;T&gt; &#123;</span><br><span class="line">    data: <span class="type">u32</span>,</span><br><span class="line">    _marker: PhantomData&lt;T&gt;, <span class="comment">// 不占空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>标记未使用的泛型参数</strong>：Rust 要求泛型参数必须在结构体中被显式使用。若泛型参数未直接出现在字段中，可通过 <code>PhantomData</code> 标记其存在性，避免编译错误。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Resource</span>&lt;T&gt; &#123;</span><br><span class="line">    handle: *<span class="title function_ invoke__">mut</span> (),</span><br><span class="line">    _phantom: PhantomData&lt;T&gt;, <span class="comment">// 标记类型 T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>声明生命周期依赖</strong>：当结构体包含原始指针（如 <code>*const T</code>）时，<code>PhantomData</code> 可绑定生命周期，确保引用的数据有效性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Slice</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    start: *<span class="keyword">const</span> T,</span><br><span class="line">    end: *<span class="keyword">const</span> T,</span><br><span class="line">    _phantom: PhantomData&lt;&amp;<span class="symbol">&#x27;a</span> T&gt;, <span class="comment">// 绑定生命周期 &#x27;a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>协变与逆变控制</strong>：通过 <code>PhantomData&lt;&amp;'a T&gt;</code> 或 <code>PhantomData&lt;*mut T&gt;</code> 等不同形式，调整类型的协变/逆变行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker::PhantomData;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记类型为 !Send 且 !Sync</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NotThreadSafe</span> &#123;</span><br><span class="line">    _marker: PhantomData&lt;Rc&lt;()&gt;&gt;, <span class="comment">// Rc&lt;()&gt; 本身是 !Send + !Sync</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">本文从零开始，通过多版本迭代，实现一个安全的 Rust oneshot channel。我们将深入 `AtomicBool`、`UnsafeCell`、`MaybeUninit` 的使用，通过 `Drop` 管理内存，并最终以 `Sender`/`Receiver` 模式和所有权机制封装 `unsafe`，构建健壮的并发原语。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨手写一个 SpinLock</title>
    <link href="https://hedon.top/2025/05/13/rust-action-spinlock/"/>
    <id>https://hedon.top/2025/05/13/rust-action-spinlock/</id>
    <published>2025-05-13T04:58:25.000Z</published>
    <updated>2025-06-03T14:52:26.928Z</updated>
    
    <content type="html"><![CDATA[<p>系列文章：</p><ul><li><a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a></li></ul><p>在并发编程中，<strong>锁</strong>（lock）是一种常用的同步机制，用于保护共享数据避免竞态条件。然而，在许多编程语言中，锁的使用往往需要手动“加锁”和“解锁”。<strong>手动解锁</strong>的时机很难控制——如果程序在临界区出现错误而跳出了正常流程，开发者可能会忘记解锁锁，从而导致其他线程永远无法取得该锁，发生死锁。另外，还可能发生<strong>重复解锁</strong>的问题：比如线程A解锁后，线程B很快加锁，这时如果线程A的异常处理代码再次执行了解锁操作，就会把线程B的锁过早释放，造成数据竞态。另外，大部分语言中<strong>锁和它所保护的数据缺乏关联</strong>：编译器并不知道某个数据必须在特定锁保护下访问，这样一来，程序员很容易犯“未加锁就访问数据”的错误。这些问题对于新手来说尤其常见，而且<strong>编译器无法帮助检查</strong>并发使用上的这些 Bug。</p><p>为了解决上述问题，理想情况是让<strong>锁的管理和资源的生命周期绑定</strong>，由语言帮我们自动管理解锁。Rust 正是通过所有权和生命周期机制，实现了资源与作用域生命周期的绑定，即典型的 <strong>RAII</strong> 技术（<em>Resource Acquisition Is Initialization</em>，资源获取即初始化）。</p><p>在 Rust 标准库中，像 <code>Mutex</code>（互斥锁）就利用了 RAII：获取锁会返回一个守卫对象（例如 <code>MutexGuard</code>），当守卫对象被丢弃（析构）时自动解锁，从而避免显式解锁的麻烦。Rust 标准库的 <code>Mutex</code> 底层利用了操作系统的锁机制，在线程争用时会使线程休眠挂起，以避免浪费 CPU。然而，在一些场景下，比如<strong>无操作系统环境（no_std）<strong>的内核开发、<strong>中断处理</strong>、或者</strong>临界区极短</strong>的场合，我们可能希望使用<strong>自旋锁</strong>（SpinLock）来忙等待锁，而不进入休眠。自旋锁在锁竞争短暂时能省去线程切换的开销，但如果锁被占用时间过长，会浪费大量 CPU 时间，因此需要慎重使用。</p><p>接下来，我们将参考 <a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 一书，<strong>从零开始实现一个 Rust 版本的 SpinLock</strong>。我们会按三个版本逐步引入功能和概念：</p><ol><li>首先实现基本的 <strong>v0</strong> 版本（不保护具体数据，仅提供加锁/解锁机制）；</li><li>然后扩展为能够保护数据的 <strong>v1</strong> 版本；</li><li>最后加入 RAII 机制实现自动解锁的<strong>v2</strong>版本。</li></ol><p>过程中，我们会讨论相关的 Rust 并发概念，包括 <strong>Atomic</strong> 原子类型、<strong>Ordering</strong> 内存序、<strong>UnsafeCell</strong>、<strong>Send/Sync</strong> 并发安全标记、以及 RAII 中的 <strong>Deref/Drop</strong> trait 等。</p><p>让我们一步步实现这个自旋锁吧！</p><h2 id="读完本篇你能学到什么">读完本篇你能学到什么</h2><ol><li><strong>自旋锁与互斥锁的权衡</strong>：了解自旋锁适合的场景（极短临界区、内核/中断上下文、无 OS 环境），以及为何在锁竞争时间较长时应优先选择休眠式互斥锁。</li><li><strong>原子操作 + 内存顺序的实战用法</strong>：学会使用 <code>AtomicBool</code>，并理解 <code>Acquire / Release</code> 在加锁、解锁时建立的 <em>happens-before</em> 关系；掌握 <code>swap</code> 与 <code>spin_loop</code> 的配合细节。</li><li><strong>内部可变性（UnsafeCell）</strong>：掌握如何在持有不可变引用的情况下对数据进行安全修改。</li><li><strong>RAII + <code>Drop</code> 机制消除“忘记解锁”Bug</strong>：通过 <code>SpinLockGuard</code> + <code>Drop</code>，体验如何把“资源释放”交给作用域管理，彻底根除忘记/重复解锁的风险。</li><li><strong><code>Deref</code> / <code>DerefMut</code> 的零成本抽象</strong>：掌握为守卫对象实现 <code>Deref</code>/<code>DerefMut</code>，让使用者像操作普通引用一样操作受保护数据，而不引入额外运行时开销。</li></ol><h2 id="基础版-v0：自旋锁的基本实现">基础版 v0：自旋锁的基本实现</h2><p>我们先从最基础的版本开始，我们在 <code>lock</code> 的时候，如果失败了，就一直循环尝试，直到成功获取锁：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">  <span class="comment">// 原子布尔标志，表示锁是否被占用</span></span><br><span class="line">    locked: AtomicBool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            locked: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用原子操作尝试将 flag 变为 true，并返回之前的值：</span></span><br><span class="line">      <span class="comment">//   如果返回的是 true，则说明锁已经被其他线程抢走了。</span></span><br><span class="line">      <span class="comment">// 如果返回的是 false，则说明当前线程抢占锁成功。</span></span><br><span class="line">        <span class="comment">// 获取锁使用 Acquire 语义以确保后续对受保护数据的内存访问不会被重排到锁获取之前。</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.locked.<span class="title function_ invoke__">swap</span>(<span class="literal">true</span>, Ordering::Acquire) &#123;</span><br><span class="line">            <span class="comment">// 向处理器发出一个提示，表示当前线程正忙等待。</span></span><br><span class="line">          <span class="comment">// 这在某些架构上可以减少功耗或让处理器优化性能（比如 x86 上的 PAUSE 指令），避免无效地占用总线。</span></span><br><span class="line">            std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unlock</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 将标志置回 false，释放锁。使用 Release 语义以确保之前临界区的修改对后续获取锁的线程可见。</span></span><br><span class="line">        <span class="keyword">self</span>.locked.<span class="title function_ invoke__">store</span>(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述实现中，我们定义了结构 <code>SpinLock</code>，它包含一个原子变量 <code>locked</code>。</p><p>在 <code>lock</code> 方法中，我们尝试对 <code>locked</code> 原子变量进行 <code>swap</code> 为 <code>true</code> 的操作，<code>swap</code> 会返回交换之前的值，如果是 <code>false</code>，那就说明抢锁成功了，这个时候 <code>lock</code> 就成功返回，否则，则调用 <code>std::hint::spin_loop()</code> 进行自旋，在下一次 <code>while</code> 循环中再尝试获取锁。</p><p>在 <code>unlock</code> 方法中，我们只需要将 <code>locked</code> 设置为 <code>false</code> 即可。</p><p>示例图如下：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250513131603680.png" alt=""></p><p>这里有几个需要关注的点：</p><ol><li><code>std::hint::spin_loop()</code> 会向 CPU 发送特定指令（如 x86 的 pause 或 ARM 的 yield），提示当前处于忙等待状态。这允许 CPU 优化执行行为：<ul><li><strong>降低功耗</strong>：减少自旋期间的计算资源消耗。</li><li><strong>提升多线程效率</strong>：在超线程架构中，避免单个核心的忙等待阻塞其他线程的执行。</li></ul></li><li><code>locked</code> 是一个原子变量，对其的操作称为原子操作（Atomic Operation）。<strong>原子操作是指在多线程情况下不可被中断的操作，能保证对变量的读/写要么完整完成要么不发生，因此不存在数据竞争</strong>。在 Rust 中，每个原子操作都需要指定内存顺序（Memory Ordering）参数，用于约束编译器和 CPU 对指令重排的规则。更详细的规则可参阅：<a href="https://hedon.top/2024/11/11/rust-memory-order/">Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</a>。</li><li>这里我们内存顺序使用了一对 <code>Acquire</code> 和 <code>Release</code>。其中：<ul><li>获取锁的时候使用 <code>Acquire</code> 确保后续对受保护数据的内存访问不会被重排到锁获取之前。</li><li>释放锁的时候使用 <code>Release</code> 确保之前临界区内的所有修改都完成发布（对其他线程可见），再让其他线程获取锁。</li></ul></li></ol><p>我们来撰写单元测试：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = SpinLock::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = <span class="built_in">vec!</span>[]; <span class="comment">// 临界区资源</span></span><br><span class="line"></span><br><span class="line">        lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        data.<span class="title function_ invoke__">push</span>(<span class="number">1</span>); <span class="comment">// 临界区代码</span></span><br><span class="line">        lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line"></span><br><span class="line">        lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, data); <span class="comment">// 临界区代码</span></span><br><span class="line">        lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = <span class="built_in">vec!</span>[];  <span class="comment">// 临界区资源</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = SpinLock::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">                lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">                <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">data_ptr</span> = &amp;data <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;;</span><br><span class="line">                    (*data_ptr).<span class="title function_ invoke__">push</span>(<span class="number">1</span>);  <span class="comment">// 临界区代码</span></span><br><span class="line">                &#125;</span><br><span class="line">                lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">            lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">data_ptr</span> = &amp;data <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;;</span><br><span class="line">                (*data_ptr).<span class="title function_ invoke__">push</span>(<span class="number">2</span>); <span class="comment">// 临界区代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, data);  <span class="comment">// 临界区代码</span></span><br><span class="line">        lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在跨线程的测试用例 <code>cross_thread_should_work</code> 中，为了对 <code>data</code> 进行修改，我们只能在 <code>unsafe</code> 里面强行使用裸指针来进行操作，否则编译就会失败。</p><h2 id="升级版-v1：将锁与数据关联">升级版 v1：将锁与数据关联</h2><p>在上一个基础版本中，虽然这么做能起到互斥的作用，但是存在 2 个问题：</p><ol><li>我们会发现操作临界资源非常麻烦，因为临界资源的类型，可能是不满足 <code>Sync</code> 和 <code>Send</code> 的，所以它们无法在跨线程中进行传递或转移，所以即便我们能从逻辑上断定它们是并发安全的，但是编译器可没那么聪明，所以我们只能通过 <code>unsafe</code> 强行绕过编译期的检查。</li><li>锁和被保护的数据是分离的。程序员必须小心确保每次访问共享数据都正确地调用了 <code>lock()</code> 和 <code>unlock()</code>。一旦忘记调用 <code>unlock()</code>，或者搞错了加锁解锁的配对关系，编译器都不会报错，但程序的并发行为就可能出问题。</li></ol><p>显然，我们希望让<strong>锁与数据关联</strong>起来，从语法层面降低误用的可能，同时便于我们为临界资源的数据类型限定相关的 trait，提高资源访问的便捷性。这正是下一步要做的改进。</p><p>我们看看标准库的 <code>Mutex</code> 是怎么实现的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> LockResult&lt;MutexGuard&lt;<span class="symbol">&#x27;_</span>, T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.inner.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        MutexGuard::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MutexGuard</span>&lt;<span class="symbol">&#x27;a</span>, T: ?<span class="built_in">Sized</span> + <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    lock: &amp;<span class="symbol">&#x27;a</span> Mutex&lt;T&gt;,</span><br><span class="line">    poison: poison::Guard,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，标准的锁是将要保护的临界资源放在了锁里，在获取锁的时候，就返回这个临界资源的 <code>Guard</code>。</p><p>OK，我们先不着急引入这个 <code>Guard</code>，我们就直接在获取锁的时候返回临界资源的可变引用即可。</p><p>更新后的版本如下所示；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpinLock</span>&lt;T&gt; &#123;</span><br><span class="line">    locked: AtomicBool,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; SpinLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            locked: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">            value: UnsafeCell::<span class="title function_ invoke__">new</span>(value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> T &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.locked.<span class="title function_ invoke__">swap</span>(<span class="literal">true</span>, Ordering::Acquire) &#123;</span><br><span class="line">            std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// Safety: 我们知道这个时候同时只可能有一个线程能获取到 value，</span></span><br><span class="line">      <span class="comment">// 也知道这个 value 一定存在，所以可以直接 unwrap()。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="keyword">self</span>.value.<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unlock</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.locked.<span class="title function_ invoke__">store</span>(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">SpinLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">SpinLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在 <code>SpinLock</code> 中加入了类型为 <code>UnsafeCell&lt;T&gt;</code> 的字段 <code>value</code>，然后在 <code>lock()</code> 抢到锁的时候，通过 <code>self.value.get().as_mut().unwrap()</code> 获取 <code>value</code> 的可变引用，我们知道这里是安全的，所以 <code>unsafe</code> 是安全的。</p><p>在这个版本中，我们见到了一个新朋友 <code>UnsafeCell</code>，事实上它是 Rust 标准库中所有的并发工具的基石，它涉及到了一个概念：<strong>内部可变性</strong>。</p><p>在 Rust 的类型系统中，如果我们只有一个对锁的不可变引用（<code>&amp;SpinLock&lt;T&gt;</code>），按正常规则是无法直接获得对内部数据的可变引用（<code>&amp;mut T</code>）的——<strong>毕竟 Rust 不允许在仅持有不可变引用的情况下修改数据</strong>。但对于实现锁这种特殊结构，我们清楚只有获取锁后才会独占数据的访问权，此时产生一个可变引用是安全的。为了突破编译器的限制，我们需要借助 <code>std::cell::UnsafeCell</code>。</p><p><strong>UnsafeCell</strong> 是 Rust 提供的一个内部可变性工具类型，它包装一个数据，使得即使在只有不可变引用的情况下也可以进行修改（当然需要在 <code>unsafe</code> 块中操作）。很多线程同步原语（比如 <code>Mutex</code>、<code>AtomicBool</code> 自身等）内部都用 <code>UnsafeCell</code> 来允许内部数据的可变访问。</p><p>标准库中，基于 <code>UnsafeCell&lt;T</code>&gt;，封装了一些满足<strong>内部可变性</strong>的类型：</p><ul><li><p><code>Cell&lt;T&gt;</code>: 只允许 Copy 类型，通过 get()/set() 操作。</p></li><li><p><code>RefCell&lt;T&gt;</code>: 运行时借用检查，但不是 Sync。</p></li><li><p><code>Mutex&lt;T&gt;</code>: 线程安全，但性能开销大。</p></li></ul><p>同时也因为 <code>UnsafeCell&lt;T</code>&gt; 并不满足 <code>Send</code> 和 <code>Sync</code> trait，所以我们需要手动为其实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">SpinLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">SpinLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们修改我们的测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = SpinLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]); <span class="comment">// 临界资源包在锁里面了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        data.<span class="title function_ invoke__">push</span>(<span class="number">1</span>); <span class="comment">// 临界区代码</span></span><br><span class="line">        lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, data); <span class="comment">// 临界区代码</span></span><br><span class="line">        lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = SpinLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]); <span class="comment">// 临界资源包在锁里面了</span></span><br><span class="line">        thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">data1</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">                data1.<span class="title function_ invoke__">push</span>(<span class="number">1</span>); <span class="comment">// 临界区代码</span></span><br><span class="line">                lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">data2</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">            data2.<span class="title function_ invoke__">push</span>(<span class="number">2</span>); <span class="comment">// 临界区代码</span></span><br><span class="line">            lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, data); <span class="comment">// 临界区代码</span></span><br><span class="line">        lock.<span class="title function_ invoke__">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本的测试用例中，对于使用者来说，很明显就简洁很多了，再也不需要使用 <code>unsafe</code> 这种危险工具了。</p><h2 id="最终版-v2：引入-RAII-的自旋锁守卫">最终版 v2：引入 RAII 的自旋锁守卫</h2><p>v1 的实现仍然存在隐患，它要求调用者严格按照正确的顺序使用。我们可以想象一些误用场景：</p><ul><li><strong>忘记解锁：</strong> 如果线程获得了锁却没有调用 <code>unlock()</code> 就结束了，那么锁将一直保持锁定状态，导致其他线程永远自旋等待，无法前进。</li><li><strong>重复解锁：</strong> 如果调用者不小心对同一个锁调用了两次 <code>unlock()</code>，第二次解锁会将另一个线程持有的锁误释放，造成数据同时被两个线程访问的风险。</li><li><strong>未加锁访问：</strong> 由于我们提供了 <code>lock()</code> 返回 <code>&amp;mut T</code> 的接口，调用者理论上可以持有这个引用不放，然后调用 <code>unlock()</code> 解锁。这样一来，就出现了一个悬空引用——锁已经释放但仍持有先前的 <code>&amp;mut T</code>，如果此时另一线程加锁并修改数据，两个线程将同时持有对同一数据的可变引用，发生数据竞争！换言之，v1 的接口并不能防止调用者违反“先锁后用、用完解锁”的约定，Rust 编译器也无法帮我们检查这种逻辑错误。</li></ul><p>综上，v1 尽管把数据和锁绑定在一起，但<strong>正确使用仍然完全依赖程序员自觉</strong>，稍有不慎就可能出错。这显然不符合 Rust 一贯的“编译期保证安全”的理念。有没有办法在<strong>编译阶段</strong>就防止上述误用呢？这就是我们下一步要做的：引入 <strong>RAII</strong> 机制，用 Rust 的所有权来管理锁的获取和释放。</p><blockquote><p>RAII（Resource Acquisition Is Initialization，资源获取即初始化）是 C++/Rust 中的核心编程范式，通过将资源的生命周期与对象的生命周期绑定，实现资源的自动管理。其核心思想是：<strong>在对象构造函数中获取资源，在析构函数中释放资源</strong>，确保资源在任何情况下（包括异常）都能被正确释放。</p></blockquote><p>这个时候，<code>Guard</code> 就可以登场了，我们可以参考标准库一样，在 <code>lock</code> 的时候返回一个 <code>Guard</code>，当这个 <code>Guard</code> 离开作用域的时候，它的 <code>drop</code> 就会被调用，我们可以在里面，执行 <code>unlock</code> 操作，这有 2 个好处：</p><ol><li><code>drop(guard)</code> 是要消耗所有权的，所以可以避免重复释放锁；</li><li><code>drop(guard)</code> 在变量离开作用域后会被自动调用，所以可以避免忘记释放锁的情况发生。</li></ol><p>更新后的版本如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpinLock</span>&lt;T&gt; &#123;</span><br><span class="line">    locked: AtomicBool,</span><br><span class="line">    value: UnsafeCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SpinLockGuard</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    lock: &amp;<span class="symbol">&#x27;a</span> SpinLock&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">SpinLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">SpinLock</span>&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; SpinLock&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            locked: AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>),</span><br><span class="line">            value: UnsafeCell::<span class="title function_ invoke__">new</span>(value),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">lock</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> SpinLockGuard&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">self</span>.locked.<span class="title function_ invoke__">swap</span>(<span class="literal">true</span>, Ordering::Acquire) &#123;</span><br><span class="line">            std::hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        SpinLockGuard::<span class="title function_ invoke__">new</span>(&amp;<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; SpinLockGuard&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(lock: &amp;<span class="symbol">&#x27;a</span> SpinLock&lt;T&gt;) <span class="punctuation">-&gt;</span> SpinLockGuard&lt;<span class="symbol">&#x27;a</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; lock &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> <span class="title class_">SpinLockGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="comment">// 释放锁。</span></span><br><span class="line">        <span class="keyword">self</span>.lock.falg.<span class="title function_ invoke__">store</span>(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">SpinLockGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="comment">// Safety: 这里我们已经拿到锁（SpinLockGuard）了，</span></span><br><span class="line">        <span class="comment">// 所以可以确保数据的存在且独占的。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*<span class="keyword">self</span>.lock.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; DerefMut <span class="keyword">for</span> <span class="title class_">SpinLockGuard</span>&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> <span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        <span class="comment">// Safety: 这里我们已经拿到锁（SpinLockGuard）了，</span></span><br><span class="line">        <span class="comment">// 所以可以确保数据的存在且独占的。</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.lock.value.<span class="title function_ invoke__">get</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们引入了类型 <code>SpinLockGuard</code>，它包含了一个 <code>SpinLock</code> 的引用，所以我们需要用生命周期 <code>'a</code> 进行标注。</li><li><code>SpinLock</code> 在 <code>lock()</code> 成功时，返回一个 <code>SpinLockGuard</code>。</li><li>我们为 <code>SpinLockGuard</code> 实现 <code>drop</code> trait，让其在被 drop 时自动执行 <code>unlock</code>，这样就实现了离开作用域自动 unlock 的功能。</li><li>同时为了操作数据的简单性，我们为 <code>SpinLockGuard</code> 实现了 <code>Deref</code> 和 <code>DerefMut</code> 这 2 个 trait。</li></ol><p>修改一下我们的测试代码，可以发现更加简洁了，同时有编译器的保护，我们想犯错都难了！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = SpinLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);  <span class="comment">// 临界资源包在锁里面了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        data.<span class="title function_ invoke__">push</span>(<span class="number">1</span>); <span class="comment">// 临界代码区</span></span><br><span class="line">        <span class="title function_ invoke__">drop</span>(data); <span class="comment">// 主动调用 drop 释放锁。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *data);</span><br><span class="line">      <span class="comment">// 离开作用域后，这里编译器会自动调用 drop(data) 释放锁。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cross_thread_should_work</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">lock</span> = SpinLock::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]);  <span class="comment">// 临界资源包在锁里面了</span></span><br><span class="line">        thread::<span class="title function_ invoke__">scope</span>(|s| &#123;</span><br><span class="line">            s.<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data1</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">                data1.<span class="title function_ invoke__">push</span>(<span class="number">1</span>); <span class="comment">// 临界代码区</span></span><br><span class="line">              <span class="comment">// data1 离开作用域，自动调用 drop(data1)，释放锁。</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data2</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">            data2.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = lock.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>总结一下，在本实战篇中，我们从最初简单的原子标志锁出发，逐步演进，最终实现了一个拥有 RAII 机制的自旋锁 <code>SpinLock</code>。让我们回顾一下这个自旋锁的特点：</p><ul><li><strong>忙等待实现：</strong> 使用原子变量和循环实现锁的争用等待，而不涉及线程休眠。这样做在临界区很短时可以省去线程切换的开销，但如果锁持有时间较长，会浪费大量 CPU 时间。因此，本实现适合在<strong>短临界区</strong>或者<strong>无操作系统</strong>环境（如内核/中断上下文）使用。</li><li><strong>RAII 保证解锁：</strong> 通过引入 <code>SpinLockGuard</code> 守卫并实现 <code>Drop</code>，我们将解锁操作自动化。开发者无须显式调用解锁函数，避免了因遗忘或异常路径导致的死锁。同时也防止了双重解锁的发生——同一把锁只有一个守卫，Rust 不允许守卫被意外复制或重复释放。</li><li><strong>锁与数据绑定：</strong> 自旋锁内部直接持有被保护的数据，并通过类型系统将两者关联。任何对数据的访问都必须经由自旋锁提供的方法，这使“未加锁就访问数据”在语法上变得不可能（否则无法拿到数据的引用）。</li><li><strong>编译期并发检查：</strong> 利用 Rust 的所有权和借用规则，我们实现了<strong>一定程度的编译期并发安全检查</strong>。只要代码编译通过，就已经避免了绝大多数常见并发错误（数据竞争、未解锁等）。当然，这不意味着可以高枕无忧，我们仍需注意避免死锁等逻辑问题，但 Rust 会提供最大程度的帮助。</li></ul><p>同时，我们更进一步地理解原子变量和内存顺序的应用，也结识了一个新的朋友 <code>UnsafeCell</code>，它是 Rust 中同步原语的基础，后面我们还会经常见到。</p><p>下篇我们将尝试实现一个非常实用的工具：<code>oneshot-channel</code>（一次性通道），敬请期待！</p><p>Happy Coding! Peace~</p>]]></content>
    
    
    <summary type="html">本文以三段迭代示例演示如何在 Rust 中手写自旋锁：从最小化原子标志实现，到绑定受保护数据，再到借助 RAII 实现自动解锁。过程中深入讲解 Atomic 内存顺序、UnsafeCell 内部可变性、Send/Sync 并发标记，以及 Drop/Deref 零成本抽象，帮助读者理解自旋锁适用场景与潜在陷阱，并掌握将并发安全问题前移到编译期的工程思维。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>RAG 技术概览</title>
    <link href="https://hedon.top/2025/04/13/ai-rag-tech-overview/"/>
    <id>https://hedon.top/2025/04/13/ai-rag-tech-overview/</id>
    <published>2025-04-13T14:23:22.000Z</published>
    <updated>2025-04-15T16:25:59.245Z</updated>
    
    <content type="html"><![CDATA[<p>RAG 的整个流程可概括为如下图所示，主要分成<strong>索引</strong>、<strong>检索</strong>和<strong>生成</strong>三个部分。</p><p>本文提供配套的完整案例，源码可参考：<a href="https://github.com/hedon-ai-road/rag-demo">hedon-ai-road/rag-demo</a>，每个 commit 都引入了一个新的技术点，感兴趣的读者可根据 commit 记录一一查探。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250413223908403.png" alt=""></p><h2 id="文档解析技术">文档解析技术</h2><blockquote><p><a href="https://github.com/hedon-ai-road/rag-demo/commit/26d52ac964ca099e1726fccb5f4c18adc0fd940f#diff-b10564ab7d2c520cdd0243874879fb0a782862c3c902ab535faabe57d5a505e1">代码示例</a></p></blockquote><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/c60419a3c73f3090651a4c2761e05583.png" alt=""></p><h3 id="PDF">PDF</h3><ul><li>基于规则的开源库<ul><li>pyPDF2</li><li>PyMuPDF</li><li>pdfminer</li><li>pdfplumber</li><li>papermage</li></ul></li><li>基于深度学习的开源库<ul><li>Layout-parser</li><li>PP-StructureV2</li><li>PDF-Extract-Kit</li><li>pix2text</li><li>MinerU</li><li>marker</li><li>Gptpdf（基于 LLM API）</li></ul></li><li>商业闭源库<ul><li><a href="http://Textln.com">Textln.com</a></li><li>Doc2x</li><li>mathpix</li><li>庖丁 PDFlux</li><li>腾讯云文档识别</li></ul></li></ul><h2 id="分块策略">分块策略</h2><blockquote><p><a href="https://github.com/hedon-ai-road/rag-demo/commit/a26ae8895da7a9673660b31904857307a149c983">代码示例</a></p><p><a href="https://chunkviz.up.railway.app/">分块演示工具</a></p></blockquote><p>3 个关键部分组成：</p><ul><li>大小</li><li>重叠</li><li>拆分</li></ul><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/63b052c1b1639bfa66c23342cf28d9ef.jpg" style="zoom: 33%;" /><h3 id="固定大小分块（Fixed-Size-Chunking）">固定大小分块（Fixed Size Chunking）</h3><p>适用场景：</p><ol><li>作为分块策略的基准线；</li><li>对大型数据集进行初步分析；</li><li>实现简单且可观测性高，分块便于管理；</li><li>适用于格式和大小相似的同质数据集，如新闻文章或博客文章。</li></ol><p>问题：</p><ol><li>不考虑内容上下文，容易导致无意义的文本块；</li><li>缺乏灵活性，无法适应文本的自然结构</li></ol><h3 id="重叠分块（Overlap-Chunking）">重叠分块（Overlap Chunking）</h3><p>使用场景：</p><ol><li>需要深入理解语义并保持上下文完整性的文档，如法律文档、技术手册或科研论文；</li><li>提升分块内容的连贯性，以提高分析质量。</li></ol><p>问题：</p><ol><li>计算复杂度增加，处理效率降低；</li><li>冗余信息的存储和管理成为负担。</li></ol><h3 id="递归分块（Recursive-Chunking）">递归分块（Recursive Chunking）</h3><ul><li>通过预定义的文本分隔符（如换行符 \n\n、\n、句号、逗号、感叹号、空格等）迭代地将文本分解为更小的块，以实现段大小的均匀性和语义完整性。</li><li>先按较大的逻辑单元分割，再逐步递归到较小单元，确保在分块大小限制内保留最强的语义片段。</li></ul><p>使用场景：</p><ol><li>需要逐层分析的文本文档或需要分解成长片段、长段落的长文档，如研究报告、法律文档等。</li></ol><p>问题：</p><ol><li>在块边界处模糊语义，容易将完整的语义单元切分开。</li></ol><h3 id="文档特定分块（Document-Specific-Chunking）">文档特定分块（Document Specific Chunking）</h3><ul><li>根据文档的格式（如 Markdown、Latex、或编程语言如 Python 等）进行定制化分割的技术。此方法依据文档的特定格式和结构规则，例如 Markdown 的标题、列表项，或 Python 代码中的函数和类定义等，来确定分块边界。</li></ul><p>适用场景：</p><ol><li>有特定的文档结构，如编程语言、Markdown、Latex 等结构文档。</li></ol><p>问题：</p><ol><li>格式依赖性强，不同格式之间的分块策略不通用；</li><li>无法处理格式不规范及混合多种格式的情况。</li></ol><h3 id="语义分块（Semantic-Chunking）">语义分块（Semantic Chunking）</h3><ul><li>基于文本的自然语言边界（如句子、段落或主题中断）进行分段的技术，需要使用 NLP 技术根据语义分词分句，旨在确保每个分块都包含语义连贯的信息单元。</li></ul><p>适用场景：</p><ol><li>确保每个文档块的信息完整性且语义连贯；</li><li>提高检索结果的相关性和准确性；</li><li>适用于复杂文档和上下文敏感的精细化分析。</li></ol><p>问题：</p><ol><li>需要额外的高计算资源，特别是在处理大型或动态变化的文档数据时；</li><li>处理效率降低。</li></ol><h3 id="混合分块（Mix-Chunking）">混合分块（Mix Chunking）</h3><ul><li>在初始阶段使用固定长度分块快速整理大量文档，而在后续阶段使用语义分块进行更精细的分类和主题提取。根据实际业务场景，设计多种分块策略的混合，能够灵活适应各种需求，提供更强大的分块方案。</li></ul><p>适用场景：</p><ol><li>适用于多层次的精细化分块场景；</li><li>数据集动态变化，包含多种文档格式与结构；</li><li>平衡处理速度与准确性的场景。</li></ol><p>问题：</p><ol><li>实现复杂度高；</li><li>策略调优难度高；</li><li>资源消耗增加。</li></ol><h2 id="Embedding-技术">Embedding 技术</h2><ul><li>Embedding 嵌入是指将文本、图像、音频、视频等形式的信息映射为高维空间中的密集向量表示。这些向量在语义空间中起到坐标的作用，捕捉对象之间的语义关系和隐含的意义。通过在向量空间中进行计算（例如余弦相似度），可以量化和衡量这些对象之间的语义相似性。</li><li>向量检索（Vector Retrieval）是一种基于向量表示的搜索技术，通过计算查询向量与已知文本向量的相似度来识别最相关的文本数据。向量检索的高效性在于，它能在大规模数据集中快速、准确地找到与查询最相关的内容，这得益于向量表示中蕴含的丰富语义信息。</li></ul><p>评估指标：（MTEB、C-MTEB）</p><ol><li>特定领域的适用性</li><li>检索精度</li><li>支持的语言</li><li>文本块长度</li><li>模型大小</li><li>检索效率</li></ol><h2 id="向量数据库">向量数据库</h2><blockquote><p><a href="https://github.com/hedon-ai-road/rag-demo/commit/1f9c07ec6b10d6bfdb55c17c2c6a7ad461b00ab2">代码示例</a></p></blockquote><ul><li>向量数据库是一种专门用于存储和检索多维向量的数据库类型，与传统的基于行列结构的数据库不同，它主要处理高维空间中的数据点。</li><li>向量数据库的操作逻辑是基于相似性搜索，即在查询时，应用特定的相似性度量（如余弦相似度、欧几里得距离等）来查找与查询向量最相似的向量。</li></ul><p>向量数据库的核心在于其高效的索引和搜索机制。为了优化查询性能，它采用了如哈希、量化和基于图形的多种算法。</p><ul><li>层次化可导航小世界（<strong>HNSW</strong>）：通过在多层结构中将相似向量连接在一起，快速缩小搜索范围。</li><li>产品量化（<strong>PQ</strong>）：通过压缩高维向量，减少内存占用并加速检索。</li><li>位置敏感哈希（<strong>LSH</strong>）：通过哈希函数将相似向量聚集在一起，便于快速定位。</li></ul><p>向量数据库的工作流程：</p><ol><li>数据处理与向量化</li><li>向量存储</li><li>向量索引</li><li>向量搜索<ul><li>余弦相似度：主要用于文本处理和信息检索，关注向量之间的角度，以捕捉语义相似性。</li><li>欧几里得距离：测量向量之间的实际距离，适用于密集特征集的聚类或分类。</li><li>曼哈顿距离：通过计算笛卡尔坐标中的绝对差值之和，适用于稀疏数据的处理。</li></ul></li><li>数据检索</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/c27b4yy6748a414dae0c679835a1eccc.jpg" alt=""></p><h2 id="混合检索">混合检索</h2><blockquote><p><a href="https://github.com/hedon-ai-road/rag-demo/commit/38f1739c7ac1d3fc58023cb12bf863d3f502c419">代码示例</a></p></blockquote><ul><li>混合检索（Hybrid Search）通过结合关键词检索和语义匹配的优势，可以首先利用关键词检索精确定位到“订单 12345”的信息，然后通过语义匹配扩展与该订单相关的其他上下文或客户操作的信息，例如“12 开头的订单、包装破损严重”等。这样不仅能够获取精确的订单详情，还能获得与之相关的额外有用信息。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/7eddf214ee696b2e1f5977d72a4db134.jpg" alt=""></p><h2 id="重排序技术">重排序技术</h2><blockquote><p><a href="https://github.com/hedon-ai-road/rag-demo/commit/4837ef3220d177297169f28fbff5f52eaaee720e">代码示例</a></p></blockquote><ul><li>重排序技术（Reranking）通过对初始检索结果进行重新排序，改善检索结果的相关性，为生成模型提供更优质的上下文，从而提升整体 RAG 系统的效果。</li><li>重排序模型大多是基于<strong>双塔</strong>或<strong>交叉编码架构</strong>的模型，在此基础上进一步计算更精确的相关性分数，能够捕捉查询词与文档块之间更细致的相关性，从而在细节层面上提高检索精度。</li></ul><h2 id="提示工程">提示工程</h2><p>一个提示（prompt）通常包含以下几个元素：</p><ol><li><strong>指令（Instruction）</strong>：指明模型要执行的特定任务或操作。</li><li><strong>上下文（Context）</strong>：为模型提供额外信息或背景，可以帮助引导模型生成更准确的响应。</li><li><strong>输入数据（Input Data）</strong>：我们希望模型回答的问题或感兴趣的输入内容。</li><li><strong>输出指示符（Output Indicator）</strong>：指定模型的输出类型或格式，例如格式、是否要生成代码、总结文本或回答具体问题。</li></ol><p>核心技巧：</p><ul><li><strong>具体指令法</strong>：具体、细致地告诉大模型要做什么。</li><li><strong>示例学习</strong>：给出具体详尽的期望示例。</li><li><strong>默认回复策略</strong>：设定默认回复策略，避免模型产生“幻觉”，让它不知道就说不知道。</li><li><strong>任务角色设定</strong>：设定身份，可以帮助模型更好地理解任务要求和角色责任，从而输出更加一致、专业的内容。</li><li><strong>解释理由法</strong>：向模型解释为什么某些任务需要特定的处理方式，帮助其理解任务背景。</li><li><strong>文档基础说明</strong>：提供文档的背景信息和文本来源。</li></ul><h2 id="优化技术">优化技术</h2><h3 id="数据清洗和预处理">数据清洗和预处理</h3><blockquote><p>在 RAG 索引流程中，文档解析之后、文本块切分之前，进行数据清洗和预处理能够有效减少脏数据和噪声，提升文本的整体质量和信息密度。</p><p>通过清除冗余信息、统一格式、处理异常字符等手段，数据清洗和预处理过程确保文档更加规范和高质量，从而提高 RAG 系统的检索效果和信息准确性。</p></blockquote><ul><li>处理冗余的模型内容。</li><li>消除文档中的额外空白和格式不一致。</li><li>去除无用的文档脚注、页眉页脚、版权信息。</li></ul><h3 id="查询扩展">查询扩展</h3><blockquote><p>查询扩展策略通过大模型从原始查询语句生成多个语义相关的查询，可以覆盖向量空间中的不同区域，从而提高检索的全面性和准确性。</p></blockquote><p>查询扩展的指令模版：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你是一个AI语言模型助手。</span><br><span class="line">你的任务是生成五个不同版本的用户问题，以便从向量数据库中检索相关文档。</span><br><span class="line">通过从多个角度生成用户问题，你的目标是帮助用户克服基于距离的相似性搜索的一些局限性。</span><br><span class="line">请将这些替代问题用换行符分隔。原始问题：&#123;查询原文&#125;</span><br></pre></td></tr></table></figure><p>假设问题：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面报告中涉及了哪几个行业的案例以及总结各自面临的挑战？</span><br></pre></td></tr></table></figure><p>结果示例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请问报告中提到的案例涉及了哪些行业？这些行业各自面临的挑战有哪些？</span><br><span class="line">报告中有哪些行业的案例被讨论？每个行业在报告中描述的挑战是什么？</span><br><span class="line">这个报告中具体提到了哪些行业的案例？能否总结一下这些行业当前面临的主要挑战？</span><br><span class="line">该报告中涵盖了哪些行业案例，并对各行业的挑战进行了哪些讨论？</span><br><span class="line">在报告中提到的行业案例有哪些？这些行业分别遇到的主要问题和挑战是什么？</span><br></pre></td></tr></table></figure><p>通过这种查询扩展策略，原始问题被分解为多个子查询，每个子查询独立检索相关文档并生成相应的结果。随后，系统将所有子查询的检索结果进行合并和重新排序，效果会更全面更准确。</p><h3 id="自查询">自查询</h3><blockquote><p>自查询策略通过大语言模型自动提取查询中对业务场景至关重要的元数据字段（如标签、作者 ID、评论数量等关键信息），并将这些信息结合到嵌入检索过程中。</p></blockquote><p>自查询的指令模版：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你是一个AI语言模型助手。  </span><br><span class="line">你的任务是从用户问题中提取关键信息，你的回复应仅包含提取的关键信息。  </span><br><span class="line">用户问题：&#123;查询原文&#125;</span><br></pre></td></tr></table></figure><p>假设问题：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面报告中涉及了哪几个行业的案例以及总结各自面临的挑战？</span><br></pre></td></tr></table></figure><p>结果示例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行业，案例，挑战</span><br></pre></td></tr></table></figure><h3 id="提示压缩">提示压缩</h3><blockquote><p>提示压缩通过精简上下文、过滤掉不相关的信息，确保系统只处理与查询最相关、最重要的内容。</p></blockquote><p>提示压缩的指令模版：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">你是一个AI语言模型助手，负责对检索到的文档进行上下文压缩。</span><br><span class="line">你的目标是从文档中提取与用户查询高度相关的段落，并删除与查询无关或噪声较大的部分。</span><br><span class="line">你应确保保留所有能够直接回答用户查询的问题核心信息。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">用户查询：&#123;用户的原始查询&#125;</span><br><span class="line">检索到的文档：&#123;检索到的文档内容&#125;</span><br><span class="line"></span><br><span class="line">输出要求：</span><br><span class="line">提取与用户查询最相关的段落和信息。</span><br><span class="line">删除所有与查询无关的内容，包括噪声、背景信息或扩展讨论。</span><br><span class="line">压缩后的内容应简洁清晰，直指用户的核心问题。</span><br><span class="line"></span><br><span class="line">输出格式：</span><br><span class="line">&#123;压缩段落1&#125;</span><br><span class="line">&#123;压缩段落2&#125;</span><br><span class="line">&#123;压缩段落3&#125;</span><br></pre></td></tr></table></figure><h2 id="RAG-效果评估">RAG 效果评估</h2><ol><li>大模型打分：通过 LLM 对 RAG 的输出进行自动评分。效率高，但是准确性一般。</li><li>人工打分：手工针对 RAG 的输出进行逐一打分。更精确、细致的反馈，成本高。</li></ol><p>评估指标：</p><ol><li>**CR（Context Relevancy）**检索相关性：检索到的信息是否偏离了原始查询。</li><li>**AR（Answer Relevancy）**答案相关性：是否能解决用户的问题，且内容是否逻辑连贯。</li><li>**F（Faithfulness）**可信度：是否存在幻觉或不准确之处。</li></ol><p>打分标准：</p><ol><li>完美（Perfect）1.0 分</li><li>可接受（Acceptable）0.75 分</li><li>缺失（Missing）0.5 分</li><li>错误（Incorrect）0.25 分</li></ol><h2 id="更高级的-RAG">更高级的 RAG</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/7c3ebbe6ec9d9f2886881d7e534396a0.jpg" alt=""></p><h2 id="GraphRAG">GraphRAG</h2><p>GraphRAG 通过构建知识图谱，将实体和实体之间的关系结构化地表示出来，克服了传统 RAG 的复杂推理局限性。</p><p>有以下优势：</p><ol><li>提高答案的准确性和完整性</li><li>提高数据理解和迭代效率</li><li>提升可解释性和可追溯性</li></ol><p>知识图谱的构建步骤：</p><ol><li><strong>实体识别</strong>：从文本或数据源中识别出关键实体。</li><li><strong>关系抽取</strong>：确定实体之间的关系，可能通过自然语言处理技术实现。</li><li><strong>三元组生成</strong>：将实体和关系表示为 (主体，关系，客体) 的形式。</li><li><strong>图谱存储</strong>：使用图数据库或专门的存储系统保存知识图谱。</li></ol><p>知识图谱的主要<strong>成本</strong>挑战：</p><ol><li>数据收集与清洗成本</li><li>知识图谱构建成本</li><li>图谱的维护与更新</li></ol>]]></content>
    
    
    <summary type="html">本文是在笔者学习了极客时间《RAG 快速开发实战》课程后，对 RAG 相关技术进行一个梳理归纳，帮助开发者在 RAG 开发中进行快速定位、系统学习。</summary>
    
    
    
    <category term="AI" scheme="https://hedon.top/categories/AI/"/>
    
    <category term="RAG" scheme="https://hedon.top/categories/AI/RAG/"/>
    
    
    <category term="AI" scheme="https://hedon.top/tags/AI/"/>
    
    <category term="RAG" scheme="https://hedon.top/tags/RAG/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《Unit Testing Principles, Practices, and Patterns》</title>
    <link href="https://hedon.top/2025/04/09/note-unit-testing/"/>
    <id>https://hedon.top/2025/04/09/note-unit-testing/</id>
    <published>2025-04-09T05:19:20.000Z</published>
    <updated>2025-04-15T16:25:59.245Z</updated>
    
    <content type="html"><![CDATA[<p>本篇在上一篇的基础上，梳理下笔者的个人见解，感兴趣的读者可参考原文对比阅读：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://hedon.top/2025/04/09/note-unit-testing-excerpt/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://hedon.top/2025/04/09/note-unit-testing-excerpt/" autofill="title,icon"><div class="left"><span class="title">https://hedon.top/2025/04/09/note-unit-testing-excerpt/</span><span class="cap link footnote">https://hedon.top/2025/04/09/note-unit-testing-excerpt/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><div class="tag-plugin quot"><h2 class="content" id="揪心疑惑" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">揪心疑惑</span><span class="empty"></span></h2></div><p>在撰写单元测试的过程中，你是否曾经被以下问题困扰过？</p><ol><li>为什么要写单元测试？单元测试的目标是什么？</li><li>单元测试的粒度是怎样的？什么叫单元？a class, a function, or a behavior, or an observable behavior?</li><li>单测覆盖率真的有用吗？有什么用？又有哪些限制？</li><li>怎样才能写好单元测试？怎样才能写出性价比最高的单元测试？</li><li>如何判断一个单元测试的好坏？有没有具体可供参阅的维度？</li><li>哪些代码需要写单元测试，哪些代码没必要写单元测试？</li><li>单元测试和集成测试的边界是什么？</li><li>（单元丨集成）测试到底是要测什么东西？</li><li>单元测试的侧重点是什么？集成测试的侧重点是什么？二者的比例该是怎样的？</li><li>如何使用 Mock？哪些东西是需要 Mock 的？哪些东西是不应该 Mock 的？需要 Mock 的东西，应该在哪个层次进行 Mock？（你的 repository 层需要 Mock 吗？）</li><li>为什么你的测试代码很脆弱，总是需要频繁修改，维护起来难度很大？</li><li>如何减少测试结果的假阳性和假阴性？</li></ol><div class="tag-plugin quot"><h2 class="content" id="四根柱子" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">四根柱子</span><span class="empty"></span></h2></div><p>对于第 5 个问题，作者提出了 4 个维度：</p><ul><li><strong>Protection against regressions：防止回归</strong>，通过自动化验证代码修改后原有功能不受破坏。<ul><li><em>The amount of code that is executed during the test.</em></li><li><em>The complexity of that code.</em></li><li><em>The code’s domain significance.</em></li></ul></li><li><strong>Resistance to refactoring：抗重构性</strong>，重构业务代码时，测试代码无需过多变动便可通过用例，证明重构无误。<ul><li><em>Tests provide an early warning when you break existing functionality</em>.</li><li><em>You become confident that your code changes won’t lead to regressions</em>.</li></ul></li><li><strong>Fast feedback：快速反馈</strong>。</li><li><strong>Maintainability：可维护性</strong>。<ul><li><em>How hard it is to understand the test.</em></li><li><em>How hard it is to run the test.</em></li></ul></li></ul><p>对于这 4 个问题，你是否又有以下疑问：</p><ol><li>哪个维度是最重要的？</li><li>怎样才能写出满足各个维度的测试代码？</li><li>如果维度之间存在矛盾，如何 trade off？</li></ol><h2 id="为什么要写单元测试？">为什么要写单元测试？</h2><p>三个最重要的原因：</p><ol><li><p>验证你的程序逻辑正确性。</p></li><li><p>带来更好的代码设计。</p><p>因为单元测试能够让你站在使用者的角度去使用暴露的接口，如果接口不好用，逻辑不好测，测试条件不好构建，大概率说明代码的设计本身是有缺陷的，包括但不限于：抽象不合理、逻辑划分不清晰、与其他模块耦合严重等。</p></li><li><p>使软件项目更可持续发展。</p><p>如果你的需求没有发生变化，那原本能运行通过的单测应该一直都能运行，这有助于避免在团队协作中不小心改坏你不知道的代码，也有助于你执行各种重构措施。</p></li></ol><p>这三个原因的重要性是显而易见的，但笔者个人觉得还有一个更深层次的最重要的原因：</p><ul><li>你要对你做的事情负责，好的代码一定要先过自己这关。</li></ul><h2 id="单元测试的粒度是什么？">单元测试的粒度是什么？</h2><p>这是一个很有争议的话题，单元测试的「单元」到底是什么？</p><ul><li>一个类？</li><li>一个函数？</li><li>还是多个类组成的一个模块？</li><li>还是多个函数组成的一个大逻辑？</li></ul><p>在《Unit Testing》书中，作者指出：<strong>「单元」指的是 an observable behavior，即一个外部系统可观测到的行为</strong>。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2010.png" alt=""></p><p>为什么是可观测行为：</p><ol><li>一个帮助客户端实现目标的操作（operation）。</li><li>一个帮助客户端实现目标的状态（state）。</li></ol><p>换言之，也就是我在撰写单元测试的时候，我就是在使用系统提供的能力，我就是个使用者， 我只要验证你能提供我要的功能，就 OK 了，你背后怎么做，为了这个功能所拆分的类也好，小的辅助函数也好，都不重要，都不属于我要验证的范畴。</p><p>所以这更像是黑盒测试（black-box test）。</p><p>当然，会有例外，如果你底层有一个特别特别复杂的逻辑，你有必要专门花精力去验证它的逻辑正确性，那是可以针对它撰写专门的白盒测试（white-box test）的。针对这个情况，作者其实也提出了一个观点，对于这个复杂的逻辑，也可以抽成一个单独的模块，由它来提供能力给你当前模块使用。</p><p>总结：</p><ol><li>优先选择黑盒测试。</li><li>对于涉及复杂算法的逻辑，单独撰写白盒测试。</li><li>结合覆盖率工具去看哪些代码没被覆盖，然后再站在使用者的角度去思考为什么没被覆盖，是这个分支压根没必要存在，还是还有未考虑到的使用场景。</li></ol><h2 id="如何组织单元测试？">如何组织单元测试？</h2><p>两种结构：</p><ul><li>AAA: Arrange-Act-Assert</li><li>GWT: Given-When-Then</li></ul><p>其实都是一个思路：准备前置条件→执行待验证代码→验证逻辑正确性。</p><p>几个建议：</p><ol><li>尽量避免一个单元测试中包含多个  AAA/GWT。</li><li>避免在单元测试中使用 <code>if</code> 等分支语句。</li><li>命名的时候，尽可能让非程序员也能看懂，即这个命名需要描述一个领域问题。</li></ol><h2 id="如何发挥单测的最大价值？">如何发挥单测的最大价值？</h2><ol><li>单元测试用例必须持续不断反复执行验证。</li><li>用最小的维护代价提供最大价值的单元测试。<ol><li>识别一个有价值的测试</li><li>撰写一个有价值的测试</li></ol></li><li>验证代码中最重要的部分（领域模型）。</li></ol><h3 id="1-单元测试用例必须持续不断反复执行验证">1. 单元测试用例必须持续不断反复执行验证</h3><p>这里推荐笔者的个人实践：</p><ul><li>在 <code>pre-commit</code> 执行<strong>增量单元测试</strong>，确保本次修改的代码涉及的单测可正确通过。</li><li>在 <code>gitlab-ci/github-action</code> 流程中执行<strong>全量单元测试</strong>，全面覆盖，避免本次修改的代码影响到其他模块的正常功能。同时如果是合并到主分支的请求，加入增量覆盖率阈值检测，不满足阈值的，发送飞书消息卡片进行告警通知。</li></ul><h4 id="pre-commit-增量单测">pre-commit 增量单测</h4><p><code>.pre-commit-config.yaml</code> 配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">go-unit-tests</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">go-unit-tests</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">run</span> <span class="string">go</span> <span class="string">tests</span> <span class="string">with</span> <span class="string">race</span> <span class="string">detector</span></span><br><span class="line">        <span class="attr">entry:</span> <span class="string">bash</span> <span class="string">-c</span> <span class="string">&#x27;./script/run_diff_go_test.sh&#x27;</span></span><br><span class="line">        <span class="attr">language:</span> <span class="string">golang</span></span><br><span class="line">        <span class="attr">files:</span> <span class="string">\.*$</span></span><br><span class="line">        <span class="attr">pass_filenames:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>run_diff_go_test.sh</code> 脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export GOTOOLCHAIN=auto</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前改动的 Go 文件</span></span><br><span class="line">changed_files=$(git diff --name-only --cached --diff-filter=d | grep &#x27;\.go$&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有改动的 Go 文件，退出</span></span><br><span class="line">if [ -z &quot;$changed_files&quot; ]; then</span><br><span class="line">    echo &quot;No Go files changed.&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提取改动文件所在的包路径（使用相对路径），并排除 vendor 目录</span></span><br><span class="line">test_dirs=$(echo &quot;$changed_files&quot; | xargs -n1 dirname | grep -v &#x27;^vendor&#x27; | sort -u)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对每个改动的包路径运行 go <span class="built_in">test</span></span></span><br><span class="line">for dir in $test_dirs; do</span><br><span class="line">    # 检查目录是否存在</span><br><span class="line">    if [ ! -d &quot;$dir&quot; ]; then</span><br><span class="line">        echo &quot;Directory $dir does not exist. Skipping...&quot;</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 检查是否存在 go.mod 文件，确保在 Go 模块路径中</span><br><span class="line">    if [ -f &quot;$dir/go.mod&quot; ] || [ -f &quot;./go.mod&quot; ]; then</span><br><span class="line">        echo &quot;Running tests in $dir...&quot;</span><br><span class="line">        (cd &quot;$dir&quot; &amp;&amp; go test -mod=vendor -gcflags=all=-l -short ./...)</span><br><span class="line">        if [ $? -ne 0 ]; then</span><br><span class="line">            echo &quot;Tests failed in $dir&quot;</span><br><span class="line">            exit 1</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">        echo &quot;Skipping $dir (no go.mod found)&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;All tests passed.&quot;</span><br></pre></td></tr></table></figure><h4 id="gitlab-ci-全量单测">gitlab-ci 全量单测</h4><p><code>gitlab-ci.yml</code> 配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">go-unit-test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">go-unit-test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sh</span> <span class="string">script/unittest.sh</span> <span class="string">&quot;$CI_MERGE_REQUEST_TITLE&quot;</span> <span class="string">&quot;$GITLAB_USER_EMAIL&quot;</span> <span class="string">&quot;$CI_PIPELINE_ID&quot;</span> <span class="string">&quot;$CI_MERGE_REQUEST_TARGET_BRANCH_NAME&quot;</span> <span class="string">&quot;$CI_JOB_ID&quot;</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_PIPELINE_SOURCE</span> <span class="string">==</span> <span class="string">&quot;merge_request_event&quot;</span> <span class="string">&amp;&amp;</span> <span class="string">$CI_MERGE_REQUEST_TARGET_BRANCH_NAME</span> <span class="string">==</span> <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_PIPELINE_SOURCE</span> <span class="string">==</span> <span class="string">&quot;merge_request_event&quot;</span> <span class="string">&amp;&amp;</span> <span class="string">$CI_MERGE_REQUEST_TARGET_BRANCH_NAME</span> <span class="string">==</span> <span class="string">&#x27;release&#x27;</span></span><br><span class="line">  <span class="attr">coverage:</span> <span class="string">&#x27;/coverage: \d+.\d+% of statements/&#x27;</span></span><br></pre></td></tr></table></figure><p><code>unittest.sh</code> 单测执行脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export GOPROXY=&quot;https://goproxy.cn,direct&quot;</span><br><span class="line"></span><br><span class="line">function generate_coverage_report &#123;</span><br><span class="line">  gocover-cobertura &lt; coverage.out &gt; coverage.xml</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 gotestsum 执行单元测试</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果单测执行失败，会发送飞书消息卡片到告警群中</span></span><br><span class="line">if ! gotestsum --junitfile report.xml --post-run-command=&quot;./script/send_fs_card.sh \&quot;$1\&quot; \&quot;$2\&quot; \&quot;$3\&quot; \&quot;$5\&quot;&quot;  -- ./... -timeout 3s -short -mod=vendor -gcflags=all=-l -coverpkg=./... -coverprofile=coverage.out ; then</span><br><span class="line">  generate_coverage_report</span><br><span class="line">  sh script/cal_diff_coverage.sh &quot;$4&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成单元测试覆盖率报告</span></span><br><span class="line">generate_coverage_report</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果增量覆盖率不满足阈值，会发送飞书消息卡片到告警群中</span></span><br><span class="line">source script/cal_diff_coverage.sh &quot;$4&quot;</span><br><span class="line"></span><br><span class="line">if [[ &quot;$4&quot; == &quot;release&quot; ]]; then</span><br><span class="line">  source script/check_test_coverage.sh &quot;$1&quot; &quot;$2&quot; &quot;$3&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其中 <code>cal_diff_coverage.sh</code> 用于计算增量覆盖率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">export COVERAGE_PERCENT=0.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保 coverage.xml 文件存在</span></span><br><span class="line">if [ ! -f coverage.xml ]; then</span><br><span class="line">  echo &quot;coverage: 0.0% of statements&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 diff-cover 生成覆盖率报告</span></span><br><span class="line">diff-cover coverage.xml --exclude **/docs.go --html-report report.html --compare-branch &quot;$1&quot; &gt; diff_detail.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否成功生成报告</span></span><br><span class="line">if [ ! -f report.html ]; then</span><br><span class="line">  echo &quot;coverage: 0.0% of statements&quot;</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 grep 和 awk 提取覆盖率信息</span></span><br><span class="line">COVERAGE=$(grep &quot;Coverage:&quot; diff_detail.txt | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果找到了覆盖率数据，检查是否包含小数点</span></span><br><span class="line">if [ -n &quot;$COVERAGE&quot; ]; then</span><br><span class="line">  if [[ &quot;$COVERAGE&quot; != *&quot;.&quot;* ]]; then</span><br><span class="line">    # 如果没有小数点，在百分号前面加上 &#x27;.0&#x27;</span><br><span class="line">    # 这里这么做的目的是不知道为什么 gitlab ci 无法正确解析下面这个正则</span><br><span class="line">    # /coverage: \d+(.\d+)?% of statements/</span><br><span class="line">    # 只能解析这个</span><br><span class="line">    # /coverage: \d+.\d+% of statements/</span><br><span class="line">    COVERAGE=&quot;$&#123;COVERAGE/\%/.0%&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;coverage: $COVERAGE of statements&quot;</span><br><span class="line">else</span><br><span class="line">  COVERAGE=&quot;0.0%&quot;</span><br><span class="line">  echo &quot;coverage: 0.0% of statements&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 COVERAGE 的百分号去掉，只保留数字</span></span><br><span class="line">export COVERAGE_PERCENT=$(echo &quot;$COVERAGE&quot; | sed &#x27;s/%//&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-用最小的维护代价提供最大价值的单元测试">2. 用最小的维护代价提供最大价值的单元测试</h3><p>如何评价一个单元测试价值是否足够大呢？或者，更简单的说法是，如何评价一个单元测试写得好不好？</p><p>可以从 4 个角度进行评估：</p><ol><li>protection against regressions</li><li>resistance to refactoring</li><li>fast feedback</li><li>maintainability</li></ol><p>更具体地说：</p><h4 id="2-1-防止回归">2.1 防止回归</h4><blockquote><p>代码修改后，原有功能不受影响。</p></blockquote><p>评价指标：</p><ol><li>被测试代码执行到的业务代码数量（测试覆盖率）。</li><li>业务代码的复杂度。</li><li>业务代码的领域重要性。</li></ol><h4 id="2-2-抵抗重构">2.2 抵抗重构</h4><blockquote><p>非功能性重构，测试仍能通过，确保功能一致性。</p></blockquote><p>评价指标：</p><ol><li>越少的“假阳性”越好。</li><li>在重构代码时，引入了破坏性变更，测试代码能否快速反馈，即越少的“假阴性”越好。</li><li>测试代码是否为你重构代码提供了足够的信心。</li><li>测试代码测试的是业务代码的 observable behavior，而不是其背后的每一个步骤。</li></ol><h4 id="2-3-快速反馈">2.3 快速反馈</h4><blockquote><p>测试代码执行时间越快，则反馈间隔越短，缺陷修复效率和质量就越高。</p></blockquote><p>评价指标：</p><ol><li>代码执行速度</li></ol><h4 id="2-4-可维护性">2.4 可维护性</h4><blockquote><p>测试代码的修改成本，可维护的测试代码更有利于适应需求变更。</p></blockquote><p>评价指标：</p><ol><li>测试代码有多难理解？</li><li>测试代码的代码行数有多少？</li><li>测试代码的执行难度有多高？即有多少的外部依赖？</li></ol><h4 id="2-5-如何权衡">2.5 如何权衡</h4><p>单元测试的价值可以通过上述 4 个指标的<strong>乘积</strong>来进行估算，但现实是，这 4 者，往往无法兼得。那我们如何做权衡呢？</p><p>首先回顾「为什么要写单元测试」，核心目的是为了<strong>程序逻辑正确性、使软件项目更可持续发展</strong>。所以：</p><ul><li>**可维护性（maintainability）**是不可商量的，必须要撰写可维护的测试代码。</li><li>**抵抗重构（resistance to refactoring）**是不可商量的，我们的测试代码应尽可能对错误的逻辑进行告警，也应避免对正确的逻辑进行误告警。</li></ul><p>所以我们能权衡的其实就是 protection againts regressions 和 fast feedback，二者的矛盾很清晰：</p><ol><li>如果执行的代码越多，相应的效率就越低。</li><li>如果执行的代码太少，那验证的逻辑范围就越小。</li></ol><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%206.png" style="zoom:33%;" /><p>为了权衡这二者，业界提出了“测试金字塔”的概念。</p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%207.png" style="zoom:33%;" /><ol><li>单元测试的单位更小，涉及的外部依赖也更少，更加 <strong>fast feedback</strong>，所以在这个层次我们要撰写更多的测试，去尽可能覆盖更多的单元逻辑。</li><li>集成测试、端到端测试的逻辑覆盖范围更大，更加 <strong>resistance to refactoring</strong>，但是往往会依赖更多的组件，执行的效率也更低，所以在这 2 个层次，我们可以只撰写覆盖最重要（乐观）的业务路径的测试代码，在牺牲有限的执行效率的情况下，尝试更大的防止回归效果。</li></ol><h3 id="3-验证代码中最重要的部分">3. 验证代码中最重要的部分</h3><p>什么是代码中最重要的部分呢？我们可以将代码分成以下 4 个种类：</p><ol><li><strong>领域模型和算法（Domain Model and Algorithms）</strong>：领域模型是对业务领域核心概念和逻辑的抽象，算法则是解决特定问题的计算步骤。两者共同构成系统的核心业务逻辑。</li><li><strong>琐碎代码（Trivial Code）</strong>：实现简单功能、无复杂逻辑的代码片段，通常为工具方法或数据转换层。</li><li><strong>控制器（Controllers）</strong>：协调业务逻辑与外部交互的中间层，常见于 MVC 或分层架构中。</li><li><strong>过度复杂代码（Overcomplicated Code）</strong>：既包含核心业务逻辑，又包含控制器逻辑。</li></ol><p>作者建议：</p><ol><li>永远为 <strong>Domain Model and Algorithms</strong> 撰写全面细致的单元测试。</li><li>永远不为 <strong>Trivial Code</strong> 撰写单元测试。</li><li>为 <strong>Controllers</strong> 撰写集成测试，而不是单元测试。</li><li>避免写 <strong>Overcomplicated Code</strong>，将其拆分成 <strong>Domain Model and Algorithms</strong> 和 <strong>Controllers</strong> 。</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2015.png" alt=""></p><h2 id="如何让代码更容易测试？">如何让代码更容易测试？</h2><p>根据不同处理架构的业务代码，可以将测试代码分成以下 3 个种类：</p><ol><li><code>output-based</code>：业务代码只产生输出结果，所以只需要<strong>验证输出</strong>。</li><li><code>state-based</code>：业务代码会修改内部状态或依赖状态，所以需要<strong>验证状态变化</strong>。</li><li><code>communication-based</code>：业务代码会跟协作方进行交互，所以需要<strong>验证交互情况</strong>。对于这种场景，我们会使用 <code>mock</code>  工具来进行验证。关于 <code>mock</code> 这个话题，文章后续会进行详细讨论。</li></ol><p>我们按照上述 4 个分析维度，对这 3 种测试代码进行比较：</p><table><thead><tr><th></th><th>protection againts regressions</th><th>resistance to refactoring</th><th>fast feedback</th><th>maintainability</th></tr></thead><tbody><tr><td><strong>output-based</strong></td><td>⭐️⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️⭐️ 最好，不需要外部依赖。</td></tr><tr><td><strong>state-based</strong></td><td>⭐️⭐️⭐️</td><td>⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️ 比较差，需要外部依赖。</td></tr><tr><td><strong>communication-based</strong></td><td>⭐️⭐️ 过度使用会导致需要到处 mock，而真正执行的业务代码数量很少。</td><td>⭐️ 最差，因为验证交互情况，往往会陷入实现细节，很容易在重构过程中出现误警告。</td><td>⭐️⭐️ 大差不差，但是 mock 工具效率可能会相对低一点点。</td><td>⭐️ 最差，需要引入大量的 mock 工具和 mock 代码。</td></tr></tbody></table><p>所以我们应该尽可能写 <strong>output-based</strong> 测试，减少 <strong>communication-based</strong> 测试。</p><p>可以采取 <code>functional architecture</code>，将代码分成 2 个阶段：</p><ol><li>根据业务规则做出决定</li><li>根据决定做出行为</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2014.png" alt=""></p><p>为此，在可能的场景下，我们可以尝试通过 2 个步骤来优化我们的测试代码：</p><ol><li>使用 <code>mock</code> 来替代外部依赖 <code>out-of-process dependency</code>。</li><li>使用 <code>functional architecture</code> 来替代 <code>mock</code>。</li></ol><h2 id="聊一下-Mock">聊一下 Mock</h2><p>在撰写单元测试的过程中，如果业务逻辑依赖的组件不好实例化的时候，我们常常会借助各种 <code>Mock</code>  工具来实现“模拟”功能，使单测更易撰写，这里有一个更准确的词叫 <code>test doubles</code>（测试替身）。</p><h3 id="test-double-的种类">test double 的种类</h3><p>从大的方面可以分为 2 种：</p><ol><li>用于模拟和验证对象间的输出交互（如方法调用次数、参数匹配），则为 <code>mock</code>。</li><li>用于模拟输入交互，提供预定义的数据，则为 <code>stub</code>。</li></ol><p>更进一步可以分为：</p><ul><li><code>mock</code><ul><li><code>mock</code>: 由 mock 工具生成。</li><li><code>spy</code>: 手工撰写。</li></ul></li><li><code>stub</code><ul><li><code>stub</code>: 可以通过配置在不同的场景下返回不同的数据。</li><li><code>dummy</code>: 占位符，仅用于填充参数，不参与实际逻辑。</li><li><code>fake</code>: 跟 <code>stub</code> 几乎一样，唯一的区别是 <code>fake</code> 经常用于替代尚未开发或复杂的依赖。</li></ul></li></ul><blockquote><p>需要注意的是：永远不要去验证（assert）跟 <code>stub</code> 的交互，没必要！</p></blockquote><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%208.png" alt=""></p><h3 id="哪些东西需要-Mock？">哪些东西需要 Mock？</h3><p>在回答这个问题之前，我们先做下铺垫，聊一下接口的误解、依赖的种类和两种交互的概念。</p><h4 id="接口的误解">接口的误解</h4><p>在谈如何更好地利用 mock 之前，我们先来聊一下接口（interface）的误解。</p><p>在业务开发当中，我们经常能看到一些企图进行“优雅”架构设计的代码，上来每一层都定义接口，每一层都使用接口进行交互，反正遇到问题先定义接口再说。</p><p>目的有二：</p><ol><li>抽象外部依赖，进行解耦。</li><li>可以在不修改既有代码的情况下扩展功能，即所谓的开闭原则（Open-Closed principle）。</li></ol><p>但这其实存在一些误区，作者在书中指出：</p><ol><li><strong>只有一个实现的接口</strong>，并不是抽象，也并没有比具体的对象起到太多所谓的解耦作用。</li><li>上述第 2 点违反了一个更重要的原则 <strong>YAGNI（You are not gonna need it）</strong>，也就是你所谓的功能扩展大概率是不需要的。</li><li>上述做法的唯一好处是什么：**使测试成为可能！**因为你不隔离掉外部依赖的话，你的单元测试撰写会非常困难，也无法做到 fast feedback。</li></ol><div class="tag-plugin colorful note" color="green"><div class="title">🙋🏻‍♀️</div><div class="body"><p>抽象是发现出来的，而不是发明出来的！</p></div></div><h4 id="依赖的种类">依赖的种类</h4><ul><li><code>shared dependency</code>: 一个在测试代码中的共享对象。</li><li><code>out-of-process dependency</code>: 独立于当前应用程序的另外一个进程对象，如数据库、STMP 服务器等。<ul><li><code>managed dependency</code>: 仅当前应用程序可访问的依赖（对其他程序、服务是不可见的）。</li><li><code>unmanaged dependency</code>: 除了当前应用，其他应用也可见。</li></ul></li><li><code>private dependency</code>: 一个私有对象。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2019.png" alt=""></p><h4 id="两种交互">两种交互</h4><ul><li><code>intra-system communication</code>: 应用程序内部的交互。</li><li><code>inter-system communication</code>: 应用程序之间的交互。</li></ul><h4 id="哪些东西需要-Mock？-2">哪些东西需要 Mock？</h4><p>铺垫完接口的误解、依赖的种类和两种交互的概念之后，我们来聊一下哪些东西需要 Mock？</p><p>在抉择的时候，需要牢记我们测试粒度和评价指标。</p><p>测试粒度：<strong>an observable behavior ⭐️⭐️⭐️⭐️⭐️</strong></p><p>评价指标：</p><ul><li>防止回归：protection against regressions</li><li>抵抗重构：resistance to refactoring</li><li>快速反馈：fast feedback</li><li>可维护性：maintainability</li></ul><p>集合测试粒度和评价指标，Mock 哪些东西可以用一句话来概括：</p><div class="tag-plugin colorful note" color="green"><div class="title">✅</div><div class="body"><p>Mock 那些外部可观测到的交互，而尽量避免 Mock 内部的实现细节。</p></div></div><p>更具体来说：</p><ol><li>**仅对 <code>unmanaged dependency</code> 应用 <code>mock</code> 对象。**因为我们无法预知其他应用会对这些依赖进行什么操作，所以只能隔离开。</li><li>**对系统最外围的边界进行 <code>mock</code>。**只有系统边界，才是可观测行为，内部都是实现细节，对实现细节过多 Mock，意味着破坏了 resistance to refactoring。</li><li><strong>尽量只在集成测试中使用 mock，避免在单元测试中使用 mock。</strong></li><li><strong>只 mock 属于你的对象，不去 mock 依赖库中的对象。</strong><ul><li>始终在第三方库之上编写自己的适配器，并对这些适配器进行 mock，而不是 mock底层类型。</li><li>仅从库中暴露你所需要的功能。</li><li>使用项目的领域语言（domain language）来完成上述操作。</li></ul></li></ol><p>举个例子：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2021.png" alt=""></p><p>在上图中，右侧是我们的应用程序，它依赖了左下角的 <code>Message bus</code> 这个外部依赖，准确说是 <code>unmanaged dependency</code>。对此，我们为其创建了适配器接口 <code>IBus</code>，在这个通用接口之上，我们又根据具体业务创建了 <code>IMessageBus</code>。</p><p>针对这种情况，我们在进行 mock 的时候，只需要 mock <code>IBus</code> 对象，而不是去 mock <code>Message bus</code> 和 <code>IMessageBus</code>。</p><h3 id="数据库要不要-Mock？">数据库要不要 Mock？</h3><p>这个话题比较有意思，作者的建议是：</p><ol><li>如果这个数据库只有你这个应用可以访问，那就不要 mock。</li><li>如果这个数据库存在可以被其他应用访问的部分，那就只 mock 这一部分，不去 mock 独属于你应用的那部分。</li></ol><p>要践行上述标准，需要做到以下前提：</p><ol><li>将数据库的信息也放在源码控制系统中（git），包括：<ul><li>schema</li><li>reference data（项目启动必须要的初始数据）</li><li>migration（数据变更记录）</li></ul></li><li>每个开发者有一个单独的数据库（测试环境下）</li><li>但数据库变更的时候，不要直接修改，而是要写一条对应 sql 去进行修改，同时将这条 sql 也纳入源码控制系统中。</li></ol><p>作者不建议 <code>mock</code> 数据库，包括使用内存数据库替代，如 sqlite 替代 MySQL，核心原因是：你无法保证这些数据库能跟线上环境的行为一致，可能会导致一些无效测试用例，即假阴性。</p><p>笔者并不完全采纳这个建议，诚然，如果能做到以上前提，是可以考虑践行的。然而，它的要求很高，收益却相对较小，在单元测试环境下，使用内存数据库进行 mock，在保证了 fast feedback 和 maintainability 的情况下，也能够避免绝大多数的逻辑漏洞了，假阴性的情况会非常少，即便有，也可以交给集成测试和端到端测试去解决。</p><h2 id="反面案例">反面案例</h2><ol><li>测试私有方法。</li><li>暴露私有状态。</li><li>泄露领域知识到测试中。</li><li>在业务代码中撰写只用于测试的代码。</li><li>mock 具体的类。</li></ol><p>第 3 点比较有意思，比如下面这个例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Adding_two_numbers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> value1 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> value2 = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> expected = value1 + value2;   <span class="comment">// &lt;-----The leakage</span></span><br><span class="line">        <span class="comment">// int expected = 4 // the better one</span></span><br><span class="line">        <span class="built_in">int</span> actual = Calculator.Add(value1, value2);</span><br><span class="line">        Assert.Equal(expected, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么叫做泄露领域知识呢？</p><p>比如你要验证一个加法 <code>Add</code> 对不对，但是在测试代码中，你的期望值也是用加法来获得的，这个“加法”就是领域知识，因为这样测的话，就很有可能会出现“<strong>负负得正</strong>”的情况。</p><p>正确的做法是<strong>直接断言你预期的最终结果</strong>，以确保逻辑符合预期。</p><h2 id="Go-实践案例">Go 实践案例</h2><p>本章将分享一些笔者在 Go 项目实战过程中的一些实践案例，希望对读者撰写单元测试能提供一些帮助。</p><h3 id="依赖-Redis-的逻辑怎么测">依赖 Redis 的逻辑怎么测</h3><p>可以使用 <code>miniredis</code>，这是一个使用 Go 语言实现的内存版 Redis。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/alicebob/miniredis" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/alicebob/miniredis" autofill="title,icon"><div class="left"><span class="title">https://github.com/alicebob/miniredis</span><span class="cap link footnote">https://github.com/alicebob/miniredis</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><p>可以封装一个函数，用于快速启动 miniredis 并返回客户端对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMiniRedis</span><span class="params">()</span></span> *redis.Client &#123;</span><br><span class="line">    <span class="keyword">var</span> redisClient *redis.Client</span><br><span class="line">    <span class="keyword">var</span> miniRedisClient *miniredis.Miniredis</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    miniRedisClient, err = miniredis.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    redisClient = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">       Addr: miniRedisClient.Addr(),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> redisClient</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里可能会出现作者提到的不要使用内存数据库替代真实的数据库，因为你无法保证它们的行为一致。</p><p>比如这里是单机的，而生产环境可能是集群的，在 Redis Cluster 中，涉及到 lua 脚本和事务的所有 key，都必须保证在同一个 slot 上，在这种情况下，使用 <code>miniredis</code> 是测不出问题的。</p></blockquote><h3 id="依赖-MySQL-的逻辑怎么测">依赖 MySQL 的逻辑怎么测</h3><p>核心挑战：</p><ol><li>依赖真实 MySQL 则容易因为网络原因而导致测试失败（不可重复性）</li><li>依赖真实 MySQL 会严重影响单侧执行效率</li><li>数据预备</li><li>数据清洗</li><li>单测之间的数据隔离，互不影响</li><li>并发安全</li></ol><p>为了解决上述问题，提供更优雅的 MySQL 单测解决方案，笔者借助 <code>dolthub/go-mysql-server</code> 和 <code>gorm</code> 的能力，实现了一个 <code>go-mysql-mocker</code>，简称 <code>gmm</code>。</p><p>其中：</p><ul><li><code>dolthub/go-mysql-server</code> 提供了内存 MySQL 引擎。</li><li><code>gorm</code> 提供了快速建表和插入数据的能力。</li></ul><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/go-mysql-mocker" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/go-mysql-mocker" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/go-mysql-mocker</span><span class="cap link footnote">https://github.com/hedon954/go-mysql-mocker</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><p>核心功能：</p><ol><li>内存版数据库，无网络依赖；</li><li>每个单测可单独启动一个数据库，天然做到数据隔离和清洗；</li><li>支持 struct、slice、sql stmt、sql file 多种方式进行数据初始化，支持需要前置数据的业务逻辑测试。</li></ol><h3 id="随机概率逻辑怎么测">随机概率逻辑怎么测</h3><p>场景：随机抽奖</p><p>难点：随机概率的结果是不确定的，直接通过 <code>assert.Equal</code> 是无法写出可稳定重复运行的单测的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AssertMapRatioEqual 检查实际计数的比例是否符合预期权重的比例</span></span><br><span class="line"><span class="comment">// actual: 实际获得的计数 map[id]count</span></span><br><span class="line"><span class="comment">// expected: 预期的权重 map[id]weight</span></span><br><span class="line"><span class="comment">// tolerance: 允许的误差范围（如 0.05 表示允许 5% 的误差）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssertMapRatioEqual</span><span class="params">(t *testing.T, actual <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int64</span>, expected <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int64</span>, tolerance <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    t.Helper()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算总数</span></span><br><span class="line">    <span class="keyword">var</span> actualTotal, expectedTotal <span class="type">int64</span></span><br><span class="line">    <span class="keyword">for</span> _, count := <span class="keyword">range</span> actual &#123;</span><br><span class="line">        actualTotal += count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, weight := <span class="keyword">range</span> expected &#123;</span><br><span class="line">        expectedTotal += weight</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查每个 ID 的比例</span></span><br><span class="line">    <span class="keyword">for</span> id, expectedWeight := <span class="keyword">range</span> expected &#123;</span><br><span class="line">        actualCount, exists := actual[id]</span><br><span class="line">        <span class="keyword">if</span> !exists &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;ID %d 在实际结果中不存在&quot;</span>, id)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        expectedRatio := <span class="type">float64</span>(expectedWeight) / <span class="type">float64</span>(expectedTotal)</span><br><span class="line">        actualRatio := <span class="type">float64</span>(actualCount) / <span class="type">float64</span>(actualTotal)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> diff := math.Abs(expectedRatio - actualRatio); diff &gt; tolerance &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;ID %d 的比例不符合预期: 期望 %.3f, 实际 %.3f, 差异 %.3f, 超出允许误差 %.3f&quot;</span>,</span><br><span class="line">                id, expectedRatio, actualRatio, diff, tolerance)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有多余的 ID</span></span><br><span class="line">    <span class="keyword">for</span> id := <span class="keyword">range</span> actual &#123;</span><br><span class="line">        <span class="keyword">if</span> _, exists := expected[id]; !exists &#123;</span><br><span class="line">            t.Errorf(<span class="string">&quot;实际结果中存在未预期的 ID: %d&quot;</span>, id)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLottery_randOnce</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Run(<span class="string">&quot;大量抽取应符合权重配置比例&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        gotCount := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int64</span>)</span><br><span class="line">        totalCount := <span class="type">int64</span>(<span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">int64</span>(<span class="number">0</span>); i &lt; totalCount; i++ &#123;</span><br><span class="line">            reward, err := lotteryOnce(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">            assert.Nil(t, err)</span><br><span class="line">            assert.NotNil(t, reward)</span><br><span class="line">            gotCount[reward.Id] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        expectedRatio := <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int64</span>&#123;</span><br><span class="line">            <span class="number">1</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="number">2</span>: <span class="number">20</span>,</span><br><span class="line">            <span class="number">3</span>: <span class="number">30</span>,</span><br><span class="line">            <span class="number">4</span>: <span class="number">40</span>,</span><br><span class="line">            <span class="number">5</span>: <span class="number">40</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        testutil.AssertMapRatioEqual(t, gotCount, expectedRatio, <span class="number">0.05</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP-接口怎么测">HTTP 接口怎么测</h3><p>挑战：</p><ol><li>如何快速构建请求体并发送请求？</li><li>如何快速断言异常情况？</li><li>如何快速断言成功情况，并解析出期望的返回值？</li></ol><h4 id="1-构造请求">1. 构造请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速创建请求体 form 表单格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPPostRequest</span><span class="params">(path <span class="type">string</span>, data any)</span></span> *http.Request &#123;</span><br><span class="line">    req := httptest.NewRequest(<span class="string">&quot;POST&quot;</span>, path, NewHTTPBody(data))</span><br><span class="line">    req.Header.Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> req</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPBody</span><span class="params">(data any)</span></span> io.Reader &#123;</span><br><span class="line">    values := url.Values&#123;&#125;</span><br><span class="line">    v := reflect.ValueOf(data)</span><br><span class="line">    t := v.Type()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v.Kind() == reflect.Ptr &#123;</span><br><span class="line">        v = v.Elem()</span><br><span class="line">        t = v.Type()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v.Kind() != reflect.Struct &#123;</span><br><span class="line">        <span class="keyword">return</span> strings.NewReader(values.Encode())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">        field := t.Field(i)</span><br><span class="line">        value := v.Field(i)</span><br><span class="line"></span><br><span class="line">        tag := field.Tag.Get(<span class="string">&quot;form&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理复杂类型（结构体、切片、map）</span></span><br><span class="line">        <span class="keyword">switch</span> value.Kind() &#123;</span><br><span class="line">        <span class="keyword">case</span> reflect.Struct, reflect.Slice, reflect.Map:</span><br><span class="line">            jsonBytes, err := json.Marshal(value.Interface())</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                values.Set(tag, <span class="type">string</span>(jsonBytes))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">&quot;Error marshaling %v: %v&quot;</span>, value.Kind(), err)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 处理其他类型</span></span><br><span class="line">            values.Set(tag, fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, value.Interface()))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strings.NewReader(values.Encode())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-发送请求">2. 发送请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w := httptest.NewRecorder()</span><br><span class="line">sfRouterTest.ServeHTTP(w, request)</span><br></pre></td></tr></table></figure><h4 id="3-断言异常">3. 断言异常</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AssertRspErr 断言 http 响应异常，expectedErr 为期望的错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssertRspErr</span><span class="params">(w *httptest.ResponseRecorder, t *testing.T, expectedErr <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    assert.Equal(t, http.StatusOK, w.Code)</span><br><span class="line">    body := w.Result().Body</span><br><span class="line">    <span class="keyword">defer</span> body.Close()</span><br><span class="line">    rsp, err := FromHTTPResp[any](body)</span><br><span class="line">    assert.Nil(t, rsp)</span><br><span class="line">    assert.Equal(t, expectedErr, err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-断言正确且返回响应值">4. 断言正确且返回响应值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FromHTTPResp 从 http 响应中解析出数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromHTTPResp</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(resp io.ReadCloser)</span></span> (*T, <span class="type">error</span>) &#123;</span><br><span class="line">    body, err := io.ReadAll(resp)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; _ = resp.Close() &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t httpResp[T]</span><br><span class="line">    err = json.Unmarshal(body, &amp;t)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t.Code != <span class="number">200</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(t.Message)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;t.Data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AssertRspOk 断言 http 响应成功，并返回响应体 T</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AssertRspOk</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(w *httptest.ResponseRecorder, t *testing.T)</span></span> *T &#123;</span><br><span class="line">    assert.Equal(t, http.StatusOK, w.Code)</span><br><span class="line">    body := w.Result().Body</span><br><span class="line">    <span class="keyword">defer</span> body.Close()</span><br><span class="line">    rsp, err := FromHTTPResp[T](body)</span><br><span class="line">    assert.Nil(t, err)</span><br><span class="line">    assert.NotNil(t, rsp)</span><br><span class="line">    <span class="keyword">return</span> rsp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里其实就违反了上一张反面案例中的第 3 点”泄露领域知识到测试中“，因为这里接受响应的时候，还是使用的领域对象结构，所以可能会出现负负得正的情况，比如你的对象字段名就是拼写错误了，但是因为你业务逻辑和断言处都是用的一个结构，所以内部形成了循环，就负负得正了，但是真正到了客户端那，就解析失败了。</p><p>不过在这个情况下，笔者认为这个情况下的这种风险是可以接受的，远盖不住其带来的效率提升。</p></blockquote><h4 id="5-组合起来">5. 组合起来</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendHTTPRequest</span>[<span class="title">Rsp</span> <span class="title">any</span>]<span class="params">(t *testing.T, server HTTPServer, path <span class="type">string</span>, data any, errMsg ...<span class="type">string</span>)</span></span> *Rsp &#123;</span><br><span class="line">    req := NewHTTPPostRequest(path, data)</span><br><span class="line">    w := httptest.NewRecorder()</span><br><span class="line">    server.ServeHTTP(w, req)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(errMsg) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        AssertRspErr(w, t, errMsg[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AssertRspOk[Rsp](w, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-案例">6. 案例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_GetCollectReward</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Run(<span class="string">&quot;重复领取&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        uid := buildUserInfo(&amp;UserInfo&#123;</span><br><span class="line">            Got: <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>&#123;</span><br><span class="line">                <span class="number">1</span>: &#123;<span class="number">1</span>&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;, apiTest.svc)</span><br><span class="line">        _ = testutil.SendHTTPRequest[GetCollectRewardResp](t, routerTest,</span><br><span class="line">            <span class="string">&quot;/get_collect_reward&quot;</span>, &amp;GetCollectRewardReq&#123;</span><br><span class="line">                UID:       uid,</span><br><span class="line">                CollectID: <span class="number">1</span>,</span><br><span class="line">            &#125;, <span class="string">&quot;重复领取&quot;</span>) <span class="comment">// 错误信息</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    t.Run(<span class="string">&quot;领取成功&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">      uid := uuid.NewString()</span><br><span class="line">        rsp := testutil.SendHTTPRequest[GetCollectRewardResp](t, routerTest,</span><br><span class="line">            <span class="string">&quot;/get_collect_reward&quot;</span>, &amp;GetCollectRewardReq&#123;</span><br><span class="line">                UID:       uid,</span><br><span class="line">                CollectID: <span class="number">1</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        )</span><br><span class="line">        assert.NotNil(t, rsp.Reward) <span class="comment">// 正确结果</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖时间的逻辑怎么测">依赖时间的逻辑怎么测</h3><ol><li>尽量不要依赖时间。</li><li>考虑将时间作为参数，避免 <code>time.Now()</code>。</li></ol><p>也可以参考：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://hedon.top/2025/03/06/go-lib-synctest/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://hedon.top/2025/03/06/go-lib-synctest/" autofill="title,icon"><div class="left"><span class="title">https://hedon.top/2025/03/06/go-lib-synctest/</span><span class="cap link footnote">https://hedon.top/2025/03/06/go-lib-synctest/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><h3 id="并发逻辑怎么测">并发逻辑怎么测</h3><ul><li><code>go test</code> 推荐开启 <code>-race</code> 用于检测并发冲突。</li></ul><p>更多可参考：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://hedon.top/2025/03/06/go-lib-synctest/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://hedon.top/2025/03/06/go-lib-synctest/" autofill="title,icon"><div class="left"><span class="title">https://hedon.top/2025/03/06/go-lib-synctest/</span><span class="cap link footnote">https://hedon.top/2025/03/06/go-lib-synctest/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div>]]></content>
    
    
    <summary type="html">本文总结了读者在阅读《Unit Testing》书籍中的收获和思考。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《Unit Testing Principles, Practices, and Patterns》</title>
    <link href="https://hedon.top/2025/04/09/note-unit-testing-excerpt/"/>
    <id>https://hedon.top/2025/04/09/note-unit-testing-excerpt/</id>
    <published>2025-04-09T04:52:14.000Z</published>
    <updated>2025-04-15T16:25:59.245Z</updated>
    
    <content type="html"><![CDATA[<p>Learning unit testing doesn’t stop at mastering the technical bits of it, such as your favorite test framework, mocking library, and so on. There’s much more to unit testing than the act of writing tests. You always have to achieve the best return on the time you invest in unit testing, minimizing the effort you put into tests and maximizing the benefits they provide. Achieving both things isn’t an easy task.</p><ul><li>They grow effortlessly, don’t require much maintenance, and can quickly adapt to their customers’ ever-changing needs.</li></ul><p>The ratio between the production code and the test code could be anywhere between <code>1:1</code> and <code>1:3</code>.</p><h1>Coverage limitations</h1><ul><li>You can’t guarantee that the test verifies all the possible outcomes of the system under test.</li><li>No coverage metric can take into account code paths in external libraries.</li></ul><h1>The goal of unit testing</h1><ol><li>lead to a better code design</li><li>enable sustainable(可持续的) growth of the software project</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image.png" alt=""></p><p>the cost components of writing unit tests:</p><ol><li>refactoring the test when you refactor the underlying code</li><li>running the test on each code change</li><li>dealing with false alarms raised by the test</li><li>spending time reading the test when you’re trying to understanding how the underlying code behaves</li></ol><p>a successful test suite must:</p><ol><li>integrated into the development cycle</li><li>targets only the most important parts of the code base<ol><li>👉🏻 domain logic</li><li>infrastructure code</li><li>external services and dependencies</li><li>code that glues everything together</li></ol></li><li>provides maximum value with minimum maintenance costs<ol><li>recognize a valuable test (and, by extension, a test of low value)</li><li>write a valuable test</li></ol></li></ol><h1>What is a unit test?</h1><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%201.png" alt=""></p><ol><li>verifies a single unit of behavior</li><li>dose it quickly</li><li>dost it in isolation from other tests</li></ol><p>An integration test, then, is a test that doesn’t meet one of these criteria.</p><p>End-to-end tests are a subset of integration tests.</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%202.png" alt=""></p><h1>How to structure a unit test?</h1><table><thead><tr><th>Type</th><th>Components</th></tr></thead><tbody><tr><td>AAA</td><td>Arrange - Act - Assert</td></tr><tr><td>GWT</td><td>Given - When - Then</td></tr></tbody></table><ol><li>avoid multiple arrange, act, and assert sections.</li><li>avoid if statements in tests.</li><li>name the test as if you were describing the scenario to a non-programmer who is familiar with the problem domain.</li><li>separate words with underscores.</li><li>structure a test is to make it tell a story about the problem domain</li></ol><h1>Four pillars of a good unit test</h1><blockquote><p><em>code is not an asset, it’s a liability.</em></p></blockquote><ol><li><p><strong>protection against regressions</strong></p><ol><li>the amount of code that is executed during the test</li><li>the complexity of that code</li><li>the code’s domain significance</li></ol></li><li><p><strong>resistance to refactoring</strong></p><ol><li>the fewer false positives the test generates, the better</li><li>tests provides an early warning when you break exisiting functionality</li><li>you become confident that your code changes won’t lead to regressions</li><li>the more the test is coupled to the implementation details of the system under set(SUT), the more false alarms it generates</li><li>you need to make sure the test verifies the end result the SUT delivers: its observable behavior, not the steps it takes to do that.</li><li>the best way to structure a test is to make it tell a story about the problem domain</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%203.png" alt=""></p></li><li><p><strong>fast feedback</strong></p></li><li><p><strong>maintainability</strong></p><ol><li>how hard it is to understand the test, which is a function of the test’s size</li><li>how hard it is to run the test, which is a function of how many out-of-process dependencies the test works with directly</li></ol></li></ol><h2 id="The-intrinsic-connection-between-the-first-two-attributes">The intrinsic connection between the first two attributes</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%204.png" alt=""></p><p>Type II Error:</p><ul><li>if functionality is broken, the test should fail, but if the test also passed, means it is not a good unit test, should if it fails, means it offers protection against regressions.</li></ul><p>Type I Error:</p><ul><li>if functionality is correct but the test fails, means that the test dose not test the nature of behavior. The good unit test should always pass when the functionality is correct. This would help us a lot when we try to do refactor. If we refactor the code correctly, but the unit tests always failed, means that the unit tests are not good enough, we need to optimize them.</li></ul><h1>An ideal test</h1><ul><li>value = <code>[0..1] * [0..1] * [0..1] * [0..1]</code>(corresponding to the four pillars)</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%205.png" alt=""></p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%206.png" alt=""></p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%207.png" alt=""></p><h2 id="black-box-and-white-box-testing">black-box and white-box testing</h2><ol><li>choose black-box testing over white-box testing by default.</li><li>the only exception is when the test covers utility code with high algorithmic complexity</li><li>use code coverage tools to see which code branches are not exercised, but then turn around and test them as if you know nothing about the code’s internal structure.</li></ol><h1>Mock</h1><h2 id="types-of-test-doubles">types of test doubles</h2><ul><li>mock: help to emulate and examine <code>outcoming</code> interactions —— change state<ul><li>mock: generated by tools</li><li>spy: written manually</li></ul></li><li>stub: help to emulate <code>incoming</code> interactions —— get input data<ul><li>stub: can configure to return different values for different scenarios.</li><li>dummy: a simple, hardcoded value such as a null value or a made-up string.</li><li>fake: the same as a stub for most purposes, only except for its creation, it is usually implemented to replace a dependency that dose not yet exist</li></ul></li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%208.png" alt=""></p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%209.png" alt=""></p><blockquote><p>never asserting interactions with stubs.</p></blockquote><h2 id="Observable-behavior">Observable behavior</h2><ol><li>expose an <code>operation</code> that helps the client achieve one of its goals. An operation is a method that performs a calculation or incurs a side effect or both.</li><li>expose a <code>state</code> that helps the client achieve one of its goals. State is the current condition of the system.</li></ol><blockquote><p>Whether the code is observable behavior depends on who its client is and what the goals of that client are.</p></blockquote><blockquote><p>Ideally, the system’s public API surface should coincide with its observable behavior, and all its implementation details should be hidden from the eyes of the clients.</p></blockquote><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2010.png" alt=""></p><h2 id="Mocks-and-test-fragility">Mocks and test fragility</h2><ul><li><code>Intra-system</code> communications are communications between classes inside your application.</li><li><code>Inter-system</code> communications are when your application talks to other applications.</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2011.png" alt=""></p><ol><li>The use of mocks is <code>beneficial</code> when verifying the communication pattern between your system and external applications.</li><li>Using mocks to verify communications between classes inside your system results in tests that couple to implementation details and therefore fall short of the <code>resistance-to-refactoring</code> metric.</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2012.png" alt=""></p><h2 id="Types-of-dependencies">Types of dependencies</h2><ul><li><code>shared dependency</code>: a dependency shared by test (not production code)</li><li><code>out-of-process dependency</code>: a dependency hosted by a process other than the program’s execution process (database, stmp server)</li><li><code>private dependency</code>: any dependency that is not shared</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2013.png" alt=""></p><h1>Styles of unit testing</h1><ul><li><code>output-based</code>: only need to verify the output.</li><li><code>state-based</code>: the underlying code changes its own state, the state of its collaborators, or the state of an out-of-process dependency.</li><li><code>communication-based</code>: use mocks to verify communications between the SUT and its collaborators, to verify the communication situations.</li></ul><h2 id="compare">compare</h2><h3 id="protection-against-regressions">protection against regressions</h3><ul><li>for the most part, they are not very different</li><li>but overusing the <code>communication-based</code> style can result in shallow tests that verify only a thin slice of code and mock out everything else.</li></ul><h3 id="fast-feedback">fast feedback</h3><ul><li>for the most part, they are not very different</li><li><code>communication-based</code> testing can be slightly worse because the cost of mocks.</li></ul><h3 id="resistance-to-refactoring">resistance to refactoring</h3><ul><li><code>state-based</code> is the best one.</li><li><code>communication-based</code> is the worse one, because it is the most vulnerable to false alarms.</li></ul><h3 id="maintainability">maintainability</h3><ul><li><code>output-based</code> is the best one, because they do not deal with out-of-process dependencies.</li><li><code>state-based</code> is less maintainable because state verification takes up more space than output verification.</li><li><code>communication-based</code> is the worst one, it requires setting up test doubles and interaction assertions, and that takes up a lot of space.</li></ul><h2 id="functional-architecture">functional architecture</h2><p><code>*Functional architecture</code>* maximizes the amount of code written in a purely functional (immutable) way, while minimizing code that deals with side effects. <em>Immutable</em> means unchangeable: once an object is created, its state can’t be modified. This is in contrast to a *mutable* object (changeable object), which can be modified after it is created.</p><p>Separate two kinds of code:</p><ul><li>code that make a decision</li><li>code that acts upon that decision</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2014.png" alt=""></p><h2 id="Tips">Tips</h2><ul><li>Moving from using an out-of-process dependency to using mocks.</li><li>Moving from using mocks to using functional architecture</li></ul><h1>Four kinds of code</h1><ul><li>Domain model and algorithms</li><li>Trivial code</li><li>Controllers</li><li>Overcomplicated code</li></ul><h2 id="Tips-2">Tips</h2><ol><li>always write completed unit tests for <code>domain model the algorithms</code> code</li><li>never test <code>trivial code</code></li><li>write integration test for <code>controllers</code></li><li>do not write overcomplicated code, try to separate it into <code>domain model and algorithms</code> and <code>controllers</code></li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2015.png" alt=""></p><h2 id="Trade-off">Trade-off</h2><ul><li>domain model testability</li><li>controller simplicity</li><li>performance</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2016.png" alt=""></p><ol><li>push all external reads and writes to the edges anyway</li><li>inject the out-of-process dependencies into the domain model</li><li><strong>split the decision-making process into more granular steps</strong> 👈<ol><li><code>CanExecute/Execute</code> pattern</li><li>domain events</li></ol></li></ol><h2 id="CanExecute-Execute-pattern">CanExecute/Execute pattern</h2><p>You can use <code>CanExecute/Execute</code> pattern to balance the <code>performance</code> and <code>testability</code> , but concedes controller simplicity, but it is manageable in most cases.</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2017.png" alt=""></p><h2 id="Domain-events">Domain events</h2><p>Domain events help track important changes in the domain model, and then convert those changes to calls to out-of-process dependencies. This pattern removes the tracking responsibility from the controller.</p><ul><li>extract a <code>DomainEvent</code> base class and introduce a base class for all domain classes, which would contain a collection of such events: <code>List&lt;DomainEvent&gt; events</code></li></ul><h1>Integration tests</h1><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2018.png" alt=""></p><ol><li>check as many of the business scenario’s edge cases as possible with unit tests</li><li>use integration tests to cover one happy path, as well as any edge cases that can’t be covered by unit tests</li><li>if there’s no one path that goes through all happy paths, write additional integration tests—as many as needed to capture communications with <strong>every</strong> external system</li><li>attempt to apply the <code>fail-fast principle</code> as a viable alternative to integration test.</li></ol><h2 id="two-types-of-out-of-process-dependencies">two types of out-of-process dependencies</h2><ul><li><code>managed dependencies</code>: only accessible through your application. it is implement details and should not be mock.</li><li><code>unmanaged dependencies</code>: you don’t have full control over it. It is observable behavior and you should mock it.</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2019.png" alt=""></p><h2 id="interface-misunderstand">interface misunderstand</h2><div class="tag-plugin quot"><p class="content" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e092ff.png" /><span class="text">🙋🏻‍♀️ Genuine abstractions are discovered, not invented.</span><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e0ab55.png" /></p></div><p>👉🏻 For an interface to be a genuine abstraction, it must have at lease two implemtations.</p><p>The common reasoning behind the use of interfaces is that they help to:</p><ol><li>Abstract out-of-process dependencies, thus achieving loose coupling.</li><li>Add new functionality without changing the existing code, thus adhering to the <code>Open-Closed principle</code></li></ol><p>Misconceptions:</p><ol><li>Interfaces with a single implementation are not abstractions and don’t provide loose coupling any more than concrete classes that implement those interfaces.</li><li>The second reason violates a more foundational principle: <code>YAGNI (You are not gonna need it)</code>.</li><li>The only reason to use interfaces for out-of-process dependencies it is to <code>enable testing</code>!</li><li>Do not introduce interfaces for out-of-process dependencies unless you need to mock out those dependencies.</li></ol><h2 id="integration-test-best-practices">integration test best practices</h2><ol><li>making domain model boundaries explicit</li><li>reducing the number of layers in the application</li><li>eliminating circular dependencies</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2020.png" alt=""></p><h2 id="maximozing-mock’s-value">maximozing mock’s value</h2><ol><li><p>when mocking, always try to <strong>verify interactions with unmanaged dependencies at the very edges of your system</strong>.</p><blockquote><p>Mocking <code>IBus</code> instead of <code>IMessageBus</code> maximizes the mock’s protection against regressions.</p></blockquote><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2021.png" alt=""></p></li><li><p>A call to an unmanaged dependency goes through several stages before it leaves your application. <strong>Pick the last such stage</strong>. It is the best way to ensure backward compatibility with external systems, which is the goal that mocks help you achieve.</p></li><li><p>In some cases, you can use <code>spy</code> instead of <code>mock</code> for more succinct and expressive.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Fact</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Changing_email_from_corporate_to_non_corporate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> busSpy = <span class="keyword">new</span> BusSpy();</span><br><span class="line">    <span class="keyword">var</span> messageBus = <span class="keyword">new</span> MessageBus(busSpy);</span><br><span class="line">    <span class="keyword">var</span> loggerMock = <span class="keyword">new</span> Mock&lt;IDomainLogger&gt;();</span><br><span class="line">    <span class="keyword">var</span> sut = <span class="keyword">new</span> UserController(db, messageBus, loggerMock.Object);</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">    busSpy.ShouldSendNumberOfMessages(<span class="number">1</span>)</span><br><span class="line">        .WithEmailChangedMessage(user.UserId, <span class="string">&quot;new@gmail.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="mocking-best-practices">mocking best practices</h2><ol><li>applying mocks to unmanaged dependencies only</li><li>verifying the interactions with those dependencies at the very edges of your system</li><li>using mocks in integration tests only, not in unit test</li><li>always verifying the number of calls made to the mock</li><li>do not rely on production code when making assertions. Use a separate set of literals and constants in tests.</li><li>mocking only types that you own<ol><li>always write your own adapters on top of third-party libraries and mock those adapters instead of the underlying types.</li><li>only expose features you need from the library</li><li>do that using your project’s domain language</li><li>this guideline dose not apply to in-process dependencies. There is no need to abstract in-memory or managed dependencies. Similarly, there’s no need to abstract an ORM as long as it’s used for accessing a database that isn’t visible to external applications.</li></ol></li></ol><h1>Testing the database</h1><h2 id="prerequisites">prerequisites</h2><ol><li><p>keeping the database in the source control system</p><ol><li>database schemas</li><li>reference data</li></ol></li><li><p>using a separate database instance for every developer</p></li><li><p>applying the migration-based approach to database delivery</p><blockquote><p>applying every modification to the database schema (including reference data) through migrations. Do not modify migrations once they are committed to the source control. If a migration is incorrect, create a new migration instead of fixing the old one. Make exceptions to this rule only when the incorrect migration can lead to data loss.</p></blockquote></li></ol><h2 id="transaction">transaction</h2><p>split the <code>Database</code> class into <code>repositories</code> and a <code>transaction</code>:</p><ul><li><code>repositories</code> are classes that enable access to and modification of the data in the database.</li><li><code>transaction</code> is a class that either commits or rolls back data updates in full. This will be a custom class relying on the underlying database’s transactions to provide atomicity of data modification.</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2022.png" alt=""></p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%2023.png" alt=""></p><h2 id="tips">tips</h2><ol><li>use at least three transactions or units of work in an integrations test: one per each arrange, act and assert section.</li><li>your tests should not depend on the state of the database. Your tests should bring that state to the required condition on their own.</li><li>create two collections for unit and integrations, and then disable test parallelization in the collection with the integration test.</li><li>clean up data at the beginning of a test</li><li>write the SQL script manually. It’s simpler and gives you more granular control over the deletion process.</li><li>the best way to shorten integration is by extracting technical, non-business-related bits into private methods or helper classes.</li><li>only the most complex or important read operations should be test, disregard the rest.</li><li>do not test repositories directly, only as part of the overarching integration test suite.</li></ol><h1>Unit testing anti-patterns</h1><blockquote><p>⚠️ Do not do the things like below!</p></blockquote><ol><li><p>unit testing private methods</p><blockquote><p>Private methods are implementation details! Just test observable behaviors!</p></blockquote><blockquote><p><strong>If the private method is too complex to be tested as part of the public API that uses it, that’s an indication of a missing abstraction. Extract this abstraction into a separate class instead of making the private method public.</strong></p></blockquote></li><li><p>expose private state</p></li><li><p>leaking domain knowledges to tests</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Fact</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Adding_two_numbers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> value1 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> value2 = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> expected = value1 + value2;   <span class="comment">// &lt;-----The leakage</span></span><br><span class="line">        <span class="comment">// int expected = 4 // the better one</span></span><br><span class="line">        <span class="built_in">int</span> actual = Calculator.Add(value1, value2);</span><br><span class="line">        Assert.Equal(expected, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>code pollution</p><blockquote><p>Code pollution is adding production code that’s only needed for testing.</p></blockquote></li><li><p>mocking concrete classes</p></li><li><p>working with time</p></li></ol>]]></content>
    
    
    <summary type="html">本文对《Unit Testing》的关键观点进行了梳理总结。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="单元测试" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>一步步推导出 MySQL 数据的底层存储结构</title>
    <link href="https://hedon.top/2025/04/08/mysql-ibd/"/>
    <id>https://hedon.top/2025/04/08/mysql-ibd/</id>
    <published>2025-04-08T04:54:13.000Z</published>
    <updated>2025-04-15T16:25:59.245Z</updated>
    
    <content type="html"><![CDATA[<p>以下均以 InnoDB 引擎为基础进行分析。假设我们现在有 3 行数据，如下：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408125932725.png" alt=""></p><p>其中：</p><ul><li><code>id</code> 是主键索引。</li><li><code>a</code> 和 <code>b</code> 都是数据字段。</li><li><code>tx_id</code> 是隐藏字段，表示事务 id，用于实现 MVCC。</li><li><code>rollback_ptr</code> 是回指针，用于 undo log。</li></ul><p>在将数据存储到文件的时候，我们会将这三行数据进行序列化，然后以二进制流的形式存储到文件中。</p><p>现在我们要解决第一个问题：</p><div class="tag-plugin quot"><h4 class="content" id="如何按照主键（id）排序？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如何按照主键（id）排序？</span><span class="empty"></span></h4></div><p>在 InnoDB 中，会在每一行的前面，加一个 <code>next_record</code> 字段，用于指向比当前数据 id 大的下一条数据，我们假设一行数据占 20 个字节，那么就如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408130510505.png" alt=""></p><p>另外，为了便于定位每一行，InnoDB 会在每一行前面再加一个字段 <code>heap_no</code>，它的规则很简单，就是自增，在内部会用于定位一行记录，方便上锁等各种操作。</p><p>所以现在的存储结构如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408130840634.png" alt=""></p><p>现在我们来解决解决第二个问题：</p><div class="tag-plugin quot"><h4 class="content" id="如何快速定位到起点（最小）和终点（最大）？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如何快速定位到起点（最小）和终点（最大）？</span><span class="empty"></span></h4></div><p>在最前面加 2 条特殊的记录：</p><ul><li><code>PAGE_NEW_INFIMUM</code>：指向最小记录。</li><li><code>PAGE_NEW_SUPERMUM</code>：最大记录，最大的一个 id 会指向它。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408130825820.png" alt=""></p><p>第三个问题：</p><div class="tag-plugin quot"><h4 class="content" id="每次 select * from t where id = ? 都要进行 I/O 操作吗？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">每次 select * from t where id = ? 都要进行 I/O 操作吗？</span><span class="empty"></span></h4></div><p>很显然是不行的，效率太低了。这个相信绝大多数读者都知道 ，InnoDB 会以 Page（默认 16KB）为最小单位，一次性将数据从磁盘加载到内存中。为此，需要在最前面再加一条记录，且该记录的前三行分别为：</p><ul><li><code>page_no</code>：页号，自增，InnoDB 最多支持 32 位页号，所以存储上限是 16KB * 2^32^ = 64T。</li><li><code>prev_page</code>：指向上一页。</li><li><code>next_page</code>：指向下一页。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250409000055738.png" alt=""></p><div class="tag-plugin quot"><h4 class="content" id="如果一个 Page 放不下呢？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如果一个 Page 放不下呢？</span><span class="empty"></span></h4></div><p>很显然，那就要进行分页，即按照 ID 的顺序进行一分为二，前者取范围 <code>[a, b)</code>，后者取范围 <code>[b, c)</code>。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408131632390.png" alt=""></p><div class="tag-plugin quot"><h4 class="content" id="如何快速定位到数据在哪个 Page 上呢？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如何快速定位到数据在哪个 Page 上呢？</span><span class="empty"></span></h4></div><p>这个时候，我们需要新创建一个 Page，专门用于管理这些数据 Page 的，这个 Page 我们这里暂且称为索引 Page。</p><p>其中核心数据就是 2 个：</p><ul><li><code>min_id</code>：即当前页存储的最小主键 ID。</li><li><code>page_no</code>：页号，用于定位到 Page。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408131810905.png" alt=""></p><p>这是什么呀？这其实就是 B+ 树！在文件层面的存储，是连续存储的，但是为了便于理解，我们可以在逻辑层面将其绘制成 B+ 树的形态。如下图可以看到这其实就是一颗 B+ 树。</p><p>在主键索引树上：</p><ol><li>叶子节点存储的就是具体某一行的数据（聚簇索引）。</li><li>非叶子节点存储的是索引。</li><li>每一层的节点，都是一条有序的双向链表。</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408132026228.png" alt=""></p><div class="tag-plugin quot"><h4 class="content" id="如果对非主键索引 a 创建索引呢？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">如果对非主键索引 a 创建索引呢？</span><span class="empty"></span></h4></div><p>因为要建索引，所以需要先对 a 进行排序，然后针对 a 建立一颗 b+ 树。而且由于 a 是非主键索引，即辅助索引，所以叶子节点存储的是主键的值，用于回表。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408132300926.png" alt=""></p><div class="tag-plugin quot"><h4 class="content" id="假设 a =15 的数据非常多，一个 page 放不下呢？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">假设 a =15 的数据非常多，一个 page 放不下呢？</span><span class="empty"></span></h4></div><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408132323227.png" alt=""></p><p>会加入主键 ID 作为二维排序来进行分裂：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250408132350638.png" alt=""></p><div class="tag-plugin quot"><h4 class="content" id="估算一下一个三层的 B+ 树可以存储多少条数据？" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">估算一下一个三层的 B+ 树可以存储多少条数据？</span><span class="empty"></span></h4></div><ul><li>一个 Page 是 16KB</li><li>假设 1 个 Page 可以存放 1000 个 key</li><li>假设 1 个 Page 可以存放 200 条记录</li></ul><p>基于这种估算：</p><ul><li>第 1 层：1 个节点是 1 个 Page，存放 1000 个 key，对应 1000 个分叉</li><li>第 2 层：1000 个节点 1000 个 Page，存放 1000*1000 个 Key，对应 1000*1000 个分叉</li><li>第 3 层：1000*1000 个 Page，每个 Page 200 条数据，共 1000*1000*200=2 亿条数据 = 16KB*1000*1000=16GB</li></ul><p>🐂🐂🐂</p>]]></content>
    
    
    <summary type="html">本文从最简单的数据格式开始，通过不断解决一个个关键问题，最终推导出 MySQL 数据的底层存储结构，即 B+ 树。</summary>
    
    
    
    <category term="数据库" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mysql" scheme="https://hedon.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
    <category term="mysql" scheme="https://hedon.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 博客中优雅地集成 Markmap 思维导图</title>
    <link href="https://hedon.top/2025/03/17/mindmap-for-hexo/"/>
    <id>https://hedon.top/2025/03/17/mindmap-for-hexo/</id>
    <published>2025-03-17T10:21:18.000Z</published>
    <updated>2025-04-05T14:31:32.876Z</updated>
    
    <content type="html"><![CDATA[<p>在技术博客写作中，思维导图是一个非常有用的工具，它可以帮助我们更清晰地展示知识结构和概念关系。本文将介绍如何在 Hexo 博客中集成 Markmap，让你能够直接在 Markdown 文件中创建交互式思维导图。</p><h2 id="什么是-Markmap？">什么是 Markmap？</h2><p>Markmap 是一个将 Markdown 格式的文本转换为思维导图的开源工具。它允许我们使用熟悉的 Markdown 语法来创建漂亮的、交互式的思维导图。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://markmap.js.org/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://markmap.js.org/" autofill="title,icon"><div class="left"><span class="title">https://markmap.js.org/</span><span class="cap link footnote">https://markmap.js.org/</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><h2 id="实现方案">实现方案</h2><h3 id="1-安装必要依赖">1. 安装必要依赖</h3><p>首先，我们需要安装 <code>uuid</code> 包，这是用来给我们每一个思维导图生成一个唯一的 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uuid --save</span><br></pre></td></tr></table></figure><h3 id="2-创建自定义标签插件">2. 创建自定义标签插件</h3><p>在 <code>scripts/markmap_tag.js</code> 中创建自定义标签：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Markmap Tag Plugin for Hexo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">v4</span>: uuidv4 &#125; = <span class="built_in">require</span>(<span class="string">&quot;uuid&quot;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(</span><br><span class="line">  <span class="string">&quot;markmap&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">args, content</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">uuidv4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div class=&quot;markmap&quot; id=&quot;markmap-<span class="subst">$&#123;id&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;script type=&quot;text/template&quot;&gt;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;content&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123;</span></span><br><span class="line"><span class="string">  const template = document.querySelector(&#x27;#markmap-<span class="subst">$&#123;id&#125;</span> script[type=&quot;text/template&quot;]&#x27;);</span></span><br><span class="line"><span class="string">  if (template) &#123;</span></span><br><span class="line"><span class="string">    const content = template.textContent;</span></span><br><span class="line"><span class="string">    window.markmap.autoLoader.renderString(content, null, document.querySelector(&#x27;#markmap-<span class="subst">$&#123;id&#125;</span>&#x27;));</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">ends</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="3-添加样式">3. 添加样式</h3><p>创建 <code>source/css/markmap.css</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Markmap Styles */</span></span><br><span class="line"><span class="selector-class">.markmap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eaeaea</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.markmap</span> <span class="selector-tag">svg</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 响应式设计 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.markmap</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">480px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.markmap</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-更新主题配置">4. 更新主题配置</h3><p>在主题配置文件中添加必要的资源引用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/markmap.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/npm/markmap-autoloader@0.18&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用方法">使用方法</h2><div class="tag-plugin tabs" align="center"id="tab_1"><div class="nav-tabs"><div class="tab active"><a href="#tab_1-1">代码块</a></div><div class="tab"><a href="#tab_1-2">效果</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_1-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% markmap %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 技术栈</span><br><span class="line"><span class="bullet">  -</span> 前端</span><br><span class="line"><span class="bullet">    -</span> Vue.js</span><br><span class="line"><span class="bullet">    -</span> React</span><br><span class="line"><span class="bullet">    -</span> Angular</span><br><span class="line"><span class="bullet">  -</span> 后端</span><br><span class="line"><span class="bullet">    -</span> Node.js</span><br><span class="line"><span class="bullet">    -</span> Python</span><br><span class="line"><span class="bullet">    -</span> Go</span><br><span class="line"><span class="bullet">  -</span> 数据库</span><br><span class="line"><span class="bullet">    -</span> MySQL</span><br><span class="line"><span class="bullet">    -</span> MongoDB</span><br><span class="line"><span class="bullet">    -</span> Redis</span><br><span class="line"></span><br><span class="line">&#123;% endmarkmap %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab_1-2"><style>svg.markmap {        width: 100%;        height: 500px;      }</style><div class="markmap" id="markmap-2b38cb72-9e11-4fee-88d4-4a531d2f97c6">  <script type="text/template"><ul><li><p>技术栈</p><ul><li>前端<ul><li>Vue.js</li><li>React</li><li>Angular</li></ul></li><li>后端<ul><li>Node.js</li><li>Python</li><li>Go</li></ul></li><li>数据库<ul><li>MySQL</li><li>MongoDB</li><li>Redis</li></ul></li></ul></script></li></ul></div></div></div></div><h2 id="工作原理">工作原理</h2><h3 id="1-Hexo-插件系统">1. Hexo 插件系统</h3><ul><li>Hexo 提供了强大的插件系统，允许我们通过 <code>hexo.extend</code> API 来扩展功能</li><li>我们使用了 <code>hexo.extend.tag</code> 来注册自定义标签，这是 Hexo 提供的标准扩展点之一</li></ul><h3 id="2-标签插件的工作原理">2. 标签插件的工作原理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(</span><br><span class="line">  <span class="string">&quot;markmap&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">args, content</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="title function_">uuidv4</span>(); <span class="comment">// 生成唯一ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;markmap&quot; id=&quot;markmap-<span class="subst">$&#123;id&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;script type=&quot;text/template&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;content&#125;</span></span></span><br><span class="line"><span class="string">      &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">ends</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>当 Hexo 解析到 <code>markmap</code> 标签时，会调用这个注册的函数</li><li><code>content</code> 参数包含了标签之间的所有内容（你的 markdown 结构）</li><li><code>&#123;ends: true&#125;</code> 表示这是一个闭合标签（需要 endmarkmap 结束）</li></ul><h3 id="3-Markmap-库的渲染过程">3. Markmap 库的渲染过程</h3><ul><li>Markmap 库使用 <code>markmap-autoloader</code> 自动处理 markdown 到思维导图的转换</li><li>转换过程：<ol><li>Markdown 文本被解析成层级结构</li><li>层级结构被转换为 SVG 路径</li><li>SVG 被渲染到页面上，并添加交互功能</li></ol></li></ul><h3 id="4-HTML-结构设计">4. HTML 结构设计</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;markmap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;markmap-$&#123;id&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/template&quot;</span>&gt;</span></span><br><span class="line">    $&#123;content&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>script type=&quot;text/template&quot;</code> 来存储原始 markdown</li><li>每个思维导图都有唯一 ID，避免页面上多个图表互相干扰</li></ul><h3 id="5-JavaScript-初始化">5. JavaScript 初始化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> template = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(</span><br><span class="line">    <span class="string">&#x27;#markmap-$&#123;id&#125; script[type=&quot;text/template&quot;]&#x27;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (template) &#123;</span><br><span class="line">    <span class="keyword">const</span> content = template.<span class="property">textContent</span>;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">markmap</span>.<span class="property">autoLoader</span>.<span class="title function_">renderString</span>(</span><br><span class="line">      content,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#markmap-$&#123;id&#125;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>等待页面加载完成</li><li>获取模板中的 markdown 内容</li><li>使用 markmap 库渲染思维导图</li></ul><h3 id="6-样式控制">6. 样式控制</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.markmap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eaeaea</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>提供响应式布局</li><li>确保思维导图在各种屏幕尺寸下都能正常显示</li></ul><h3 id="7-主题集成">7. 主题集成</h3><ul><li>在主题配置中注入必要的 CSS 和 JavaScript</li><li>确保资源在正确的时机加载</li></ul>]]></content>
    
    
    <summary type="html">本文详细介绍了如何在 Hexo 博客中优雅地集成 Markmap 思维导图，让你能够直接在 Markdown 文件中创建交互式思维导图。同时这也是一个 Hexo 插件的标准实现案例。</summary>
    
    
    
    <category term="小技术" scheme="https://hedon.top/categories/%E5%B0%8F%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="hexo" scheme="https://hedon.top/tags/hexo/"/>
    
    <category term="markmap" scheme="https://hedon.top/tags/markmap/"/>
    
  </entry>
  
  <entry>
    <title>为什么 OpenTelemetry 的 SDK 中不支持尾采样 Hook？</title>
    <link href="https://hedon.top/2025/03/13/opentelemetry-tail-sampler/"/>
    <id>https://hedon.top/2025/03/13/opentelemetry-tail-sampler/</id>
    <published>2025-03-13T07:10:27.000Z</published>
    <updated>2025-04-05T14:31:32.877Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式追踪系统中，采样策略直接影响着系统的性能和可观测性。OpenTelemetry 作为当前最流行的可观测性框架，其采样机制设计有着深刻的考量。本文将深入探讨 OpenTelemetry 的采样机制，特别是为什么它在 SDK 层面不支持尾采样。</p><h2 id="前置采样-vs-尾采样">前置采样 vs 尾采样</h2><p>在讨论 OpenTelemetry 的采样机制前，我们需要理解两种主要的采样策略：</p><p><strong>前置采样（Head-based Sampling）</strong>：</p><ul><li>在链路开始时就决定是否采样</li><li>决策一旦做出，整个链路都遵循这个决策</li><li>不需要缓存完整的链路数据</li></ul><p><strong>尾采样（Tail-based Sampling）</strong>：</p><ul><li>在链路结束后决定是否保留</li><li>可以基于完整链路信息（如总耗时、是否有错误）做决策</li><li>需要临时缓存所有链路数据</li></ul><h2 id="OpenTelemetry-的采样实现">OpenTelemetry 的采样实现</h2><p>通过分析 <a href="https://github.com/open-telemetry/opentelemetry-go/blob/v1.35.0/sdk/trace/tracer.go#L65">OpenTelemetry Go SDK 的源码</a>，我们可以清晰地看到它采用的是前置采样策略。关键代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tr *tracer)</span></span> newSpan(ctx context.Context, name <span class="type">string</span>, config *trace.SpanConfig) trace.Span &#123;</span><br><span class="line">    <span class="comment">// ... 前面的代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行采样决策</span></span><br><span class="line">    samplingResult := tr.provider.sampler.ShouldSample(SamplingParameters&#123;</span><br><span class="line">        ParentContext: ctx,</span><br><span class="line">        TraceID:       tid,</span><br><span class="line">        Name:          name,</span><br><span class="line">        Kind:          config.SpanKind(),</span><br><span class="line">        Attributes:    config.Attributes(),</span><br><span class="line">        Links:         config.Links(),</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置采样标志</span></span><br><span class="line">    <span class="keyword">if</span> isSampled(samplingResult) &#123;</span><br><span class="line">        scc.TraceFlags = psc.TraceFlags() | trace.FlagsSampled</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scc.TraceFlags = psc.TraceFlags() &amp;^ trace.FlagsSampled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 后面的代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码揭示了几个关键点：</p><ol><li>采样决策在 span 创建时就已经做出</li><li>采样标志通过位操作设置在 TraceFlags 中</li><li>这个标志会随着 SpanContext 传播到整个分布式系统</li></ol><h2 id="采样标志的传播机制">采样标志的传播机制</h2><p>特别值得注意的是设置采样标志的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> isSampled(samplingResult) &#123;</span><br><span class="line">    scc.TraceFlags = psc.TraceFlags() | trace.FlagsSampled</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scc.TraceFlags = psc.TraceFlags() &amp;^ trace.FlagsSampled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用位操作来设置或清除采样标志：</p><ul><li><code>|</code> 操作用于设置采样标志，保留其他标志位不变</li><li><code>&amp;^</code> 操作用于清除采样标志，同样保留其他标志位不变</li></ul><p>这确保了采样决策能够一致地传播到整个分布式链路中。</p><h2 id="为什么-OpenTelemetry-不支持尾采样？">为什么 OpenTelemetry 不支持尾采样？</h2><p>最重要的原因是：<font color="red">在 SDK 中找不到尾巴！因为不知道链路什么时候结束！</font></p><p>在分布式系统中，一条链路可能跨越多个服务，所以你在某一个服务中，是不知道链路是否结束的，而 OpenTelemetry 也不是一次性上报一整条链路，而是每个 <code>span</code> 独立上报，最后再拼接到一起。</p><h3 id="OpenTelemetry-上报原理">OpenTelemetry 上报原理</h3><ol><li><p>独立上报</p><ul><li><p>每个 <code>span</code> 在结束时（调用 <code>span.End()</code>）会被传递给 <code>SpanProcessor</code></p></li><li><p><code>SpanProcessor</code> 决定如何处理这个 <code>span</code>（立即导出或批量导出）</p></li><li><p>导出是独立的，不会等待整个 <code>trace</code> 完成</p></li></ul></li><li><p>批处理机制</p><ul><li><p>默认使用 <code>BatchSpanProcessor</code>，它会收集一定数量的 <code>spans</code> 或等待一定时间然后批量导出</p></li><li><p>但这个批处理与 <code>trace</code> 完整性无关，只是为了效率</p></li></ul></li></ol><h3 id="Collector-如何实现尾采样">Collector 如何实现尾采样</h3><p>Collector 通过以下方式解决这些问题：</p><ol><li><p>设置等待时间窗口</p><ul><li><p>为每个 trace 设置一个等待期（如 10 秒）</p></li><li><p>在此期间收集该 trace 的所有 spans</p></li><li><p><strong>超过等待期后，基于已收集的 spans 做决策</strong></p></li></ul></li><li><p>集中式收集</p><ul><li><p>所有服务的 spans 都发送到 Collector</p></li><li><p>Collector 有更全面的视图来关联 spans</p></li></ul></li><li><p>专门的资源分配：Collector 作为独立组件，有专门的资源处理这种复杂逻辑，不会影响应用性能。</p></li></ol><h2 id="如何在-OpenTelemetry-生态中实现尾采样？">如何在 OpenTelemetry 生态中实现尾采样？</h2><p>虽然 SDK 不直接支持尾采样，但 OpenTelemetry 生态提供了其他方式实现类似功能：</p><h3 id="1-使用-OpenTelemetry-Collector">1. 使用 OpenTelemetry Collector</h3><p>Collector 提供了 Tail Sampling Processor，可以在数据聚合层实现尾采样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">processors:</span></span><br><span class="line">  <span class="attr">tail_sampling:</span></span><br><span class="line">    <span class="attr">decision_wait:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">num_traces:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">expected_new_traces_per_sec:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">policies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">error-policy</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">status_code</span></span><br><span class="line">        <span class="attr">status_code:</span> <span class="string">ERROR</span></span><br></pre></td></tr></table></figure><h3 id="2-结合前置采样和错误捕获">2. 结合前置采样和错误捕获</h3><p>可以实现一个智能的前置采样器，对特定场景（如包含错误属性）强制采样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SmartSampler <span class="keyword">struct</span> &#123;</span><br><span class="line">    baseSamplingRate <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SmartSampler)</span></span> ShouldSample(p trace.SamplingParameters) trace.SamplingResult &#123;</span><br><span class="line">    <span class="comment">// 错误请求必采样</span></span><br><span class="line">    <span class="keyword">for</span> _, attr := <span class="keyword">range</span> p.Attributes &#123;</span><br><span class="line">        <span class="keyword">if</span> attr.Key == <span class="string">&quot;error&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> trace.SamplingResult&#123;Decision: trace.RecordAndSample&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他请求使用基础采样率</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">float64</span>(p.TraceID[<span class="number">0</span>])/<span class="number">255.0</span> &lt; s.baseSamplingRate &#123;</span><br><span class="line">        <span class="keyword">return</span> trace.SamplingResult&#123;Decision: trace.RecordAndSample&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> trace.SamplingResult&#123;Decision: trace.Drop&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用专门的后端系统">3. 使用专门的后端系统</h3><p>一些专门的可观测性后端系统提供了尾采样功能：</p><ul><li><p>Jaeger 的 Adaptive Sampling</p></li><li><p>SkyWalking 的 Trace Sampling</p></li><li><p>Grafana Tempo 的 Trace Sampling</p></li></ul><h2 id="结论">结论</h2><p>OpenTelemetry SDK 采用前置采样而非尾采样，是基于分布式系统一致性、性能优化和架构分层等多方面考虑的结果。虽然这意味着无法基于完整链路信息做采样决策，但 OpenTelemetry 生态提供了多种方式来弥补这一限制。</p><p>在实际应用中，我们可以：</p><ol><li>在 SDK 层使用智能前置采样策略，确保关键链路被采样</li><li>在 Collector 层实现尾采样，进一步筛选有价值的链路</li><li>结合使用多种采样策略，平衡性能和可观测性</li></ol><p>通过这种分层设计，OpenTelemetry 既保证了高效的数据收集，又为高级采样策略提供了可能性，满足了不同场景的需求。</p><div class="tag-plugin quot"><h2 class="content" id="实战案例" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">实战案例</span><span class="empty"></span></h2></div><p>笔者实现一个 Go 语言的开源项目 <code>goapm</code>，对多个 Go 语言中常用的组件进行了 trace、log 和 metrics 的集成封装，用于快速在 Go 语言项目中实现可观测性，同时还提供了 <code>goapm-example</code> 实战案例，可供参考。</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/goapm" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/goapm" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/goapm</span><span class="cap link footnote">https://github.com/hedon954/goapm</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/goapm-example" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/goapm-example" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/goapm-example</span><span class="cap link footnote">https://github.com/hedon954/goapm-example</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div>]]></content>
    
    
    <summary type="html">本文介绍了 OpenTelemetry 的采样机制，特别是为什么它在 SDK 层面不支持尾采样。</summary>
    
    
    
    <category term="服务监控" scheme="https://hedon.top/categories/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
    
    <category term="opentelemetry" scheme="https://hedon.top/tags/opentelemetry/"/>
    
    <category term="服务监控" scheme="https://hedon.top/tags/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《悟道领域驱动设计》</title>
    <link href="https://hedon.top/2025/03/11/note-ddd-awareness/"/>
    <id>https://hedon.top/2025/03/11/note-ddd-awareness/</id>
    <published>2025-03-11T06:45:32.000Z</published>
    <updated>2025-04-05T14:31:32.877Z</updated>
    
    <content type="html"><![CDATA[<div class="tag-plugin quot"><h2 class="content" id="思维转变" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">思维转变</span><span class="empty"></span></h2></div><p>领域驱动设计（Domain-Driven Design，以下简称 DDD）的核心价值在于其对「业务领域」的深度聚焦。这里的「领域」并非单纯的技术范畴，而是指代软件系统所要映射的现实业务场景及其核心价值主张。DDD 通过建立与业务高度契合的领域模型，使得技术实现与业务本质形成同频共振，从而有效解决复杂业务场景下的认知鸿沟问题。</p><p>在 VUCA（Volatile 易变性、Uncertain 不确定性、Complex 复杂性、Ambiguous 模糊性）特征愈发显著的现代商业环境中，任何架构设计都面临固有局限。这种局限性既源于业务需求本身的动态演进，也受制于人类认知的有限性——正如 Eric Evans 在开山之作中强调的“<strong>模型永远是对现实的近似抽象</strong>”。但正是这种局限性，凸显了 DDD 方法论的战略意义：</p><div class="tag-plugin colorful note" color="blue"><div class="body"><p>它通过&quot;战略设计&quot;构建业务全景图，运用限界上下文划定领域边界，通过&quot;战术设计&quot;落地聚合根、实体/值对象等模式，形成应对复杂性的结构化解决方案。</p></div></div><p>需要特别指出的是，DDD 的复杂性并非方法论本身的缺陷，而是其应对现实业务复杂度的必要代价。这种复杂性体现在三个维度：</p><ol><li><strong>认知复杂性</strong>：要求开发团队与领域专家共建&quot;通用语言&quot;，实现业务概念与代码模型的精准映射。</li><li><strong>架构复杂性</strong>：通过分层架构实现业务逻辑与技术实现的解耦，采用防腐层处理系统集成问题。</li><li><strong>演进复杂性</strong>：借助子域划分和上下文映射，为持续演进的业务提供可扩展的架构基础。</li></ol><p>对于实践者而言，DDD 的价值不在于提供完美无缺的终极方案，而是为 VUCA 环境下的系统建设提供基础性指引。其核心思想——无论是通过限界上下文实现的领域自治，还是通过聚合根维护的业务一致性——都为控制软件熵增提供了可落地的模式库。即便不完全采用DDD 完整体系，其领域建模思想、分层架构理念等核心要素，仍能显著提升复杂系统的可维护性和演进能力。这种开放包容的哲学，恰是 DDD 历经二十年仍保持生命力的关键所在。</p><h3 id="贫血模型-vs-充血模型">贫血模型 vs. 充血模型</h3><ul><li>贫血模型：指的是只有属性而没有行为的模型。</li><li>充血模型：指的是既有属性又有行为的模型。</li></ul><p>笔者过往的实践中，基本上都使用类似于 <code>controller→service→repository[model]</code> 的三层架构：</p><ul><li><code>conrtoller</code> 负责暴露对外接口。</li><li><code>service</code> 负责执行所有的业务逻辑。</li><li><code>repository</code> 复杂数据的存储和缓存，包含数据对象 <code>model</code> 的定义。</li></ul><p>在这个模式下，基本上所有的核心逻辑都充斥在 <code>service</code> 层中，所以 <code>service</code> 层一般都会非常大，它要扮演多面手，即要负责跟各个模块协作，还要负责处理具体的业务规则，最终完成一个业务行为。这个过程中，<code>model</code> 即为贫血模型，因为逻辑都给 <code>service</code> 处理了，这种架构也称为<strong>贫血三层架构</strong>。</p><p>在 DDD 的理念下，很多的核心业务概念都会被建模为「领域对象」，这些「领域对象」本身就是一种业务规则的体现，所以把业务的处理逻辑，都归属到这些「领域对象」的行为当中了，即所谓的充血模型。</p><p>在这个理念下，一个优化后的<strong>充血四层架构</strong>如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250311152623058.png" alt="充血四层架构"></p><p>贫血模型推荐场景：业务简单、迭代快速、团队技术栈偏传统（如 Spring Boot+MyBatis）时，避免过度设计。</p><p>充血模型推荐场景：业务复杂、需长期演进（如核心交易系统）、团队具备 DDD 经验时，通过实体、值对象、领域服务等战术设计理念降低系统熵增。</p><p>混合使用的场景：部分核心领域用充血模型（如订单、支付），非核心模块用贫血模型（如日志、配置），平衡效率与质量。</p><p>实际上，充血模型因其状态完整，适合进行<strong>状态变更类</strong>的操作，以确保业务操作符合领域规则；贫血模型由于其轻量级，更适合作为不会涉及状态变更的操作的数据容器。这其实就是 CQRS 的理念。</p><div class="tag-plugin quot"><h2 class="content" id="概念清单" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">概念清单</span><span class="empty"></span></h2></div><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/ddd.jpg" alt=""></p><h3 id="战术设计">战术设计</h3><details class="tag-plugin colorful folding" ><summary><p>实体</p></summary><div class="body"><p><strong>定义</strong>：会随着业务变化发生变化的业务概念叫作实体对象。</p><p><strong>关键点</strong>：实体需要唯一表示</p></div></details><details class="tag-plugin colorful folding" ><summary><p>值对象</p></summary><div class="body"><p><strong>定义</strong>：一些对象在表达业务概念时是必须的，可业务并不围绕着它们进行，它们仅是对这些重要业务概念的描述，这一类对象叫作值对象。</p><p><strong>关键点</strong>：</p><ol><li>值对象的意义取决于属性，只要对象的属性一模一样，那么对象就是相同的。</li><li>尽量把值对象实现为不可变对象。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>领域服务</p></summary><div class="body"><p><strong>定义</strong>：领域服务自身是没有数据的，只是表达了某种业务计算逻辑，或者业务的某种策略。</p><p><strong>关键点</strong>：</p><ol><li>领域服务是无状态的。</li><li>只有在确实表达了一个相对独立的业务概念或者业务策略，并且不能简单地把它归结到某个既有的业务对象上时，才是一个真正的领域服务。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>领域事件</p></summary><div class="body"><p><strong>定义</strong>：领域事件代表从业务专家视角看到的某种重要的事情发生了。</p><p><strong>关键点</strong>：</p><ol><li>领域事件是一种特殊的值对象。</li><li>应该根据限界上下文中的通用语言来命名事件：AccountActivited。</li><li>应该将事件建模成值对象或贫血对象。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>聚合</p></summary><div class="body"><p><strong>定义</strong>：聚合从本质上讲是在基础的构造块上增加了一层边界，用边界把那些紧密相关的对象放到了一起。</p><p><strong>关键点</strong>：</p><ol><li>紧密相关的对象存在数据一致性问题；</li><li>缺乏边界时，维护数据一致性是困难的；</li><li>划分边界的关键在于既不要让整个系统成为一个整体，又让每个单独划分出的聚合具有明确的业务意义；</li><li>聚合需要关注三条法则：<ol><li>生命周期一致性：如果一个对象在聚合根消失之后仍然有意义，那么说明此时在系统中必然存在能够访问该对象的方法。这和聚合的定义矛盾，所以聚合内的其他元素必然在聚合根消失后失效。</li><li>问题域一致性：不属于同一个问题域的对象，不应该出现在同一个聚合中。</li><li>尽量小的聚合：聚合的本质作用是提升对象系统的粒度，确保一致性、降低复杂度。不过，粒度绝不是越大越好。如果聚合的粒度太大，那内部的逻辑复杂度也会大大增加还会影响到复用度。因此，要能够比较容易地断开聚合。</li></ol></li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>资源库</p></summary><div class="body"><p><strong>定义</strong>：对于查询、创建、修改、删除数据的操作，领域模型使用“资源库(Repository)”这个概念来承载它们。</p><p><strong>关键点</strong>：一个聚合对应一个资源库，应以聚合根命名资源库，除了聚合根之外的其他对象，都不应该提供资源库对象。</p></div></details><details class="tag-plugin colorful folding" ><summary><p>工厂</p></summary><div class="body"><p><strong>定义</strong>：工厂用于构建聚合。</p><p><strong>关键点</strong>：一个聚合往往包含多个对象，这些对象的数据之间又可能存在联系，如果允许分别创建这些对象，就会让聚合是业务完整性的单元这个定义面临失败。</p></div></details><h3 id="战略设计">战略设计</h3><details class="tag-plugin colorful folding" ><summary><p>统一语言</p></summary><div class="body"><p><strong>定义</strong>：与业务专家协作定义全团队通用的术语表，消除沟通歧义。</p><p><strong>关键点</strong>：</p><ol><li>同一个概念在不同的上下文中可能存在不同的含义；</li><li>同一个概念在同一上下文中的不同环节，也可能存在不同的含义，需要非常明确清晰的界定，降低沟通成本。</li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>子域</p></summary><div class="body"><p><strong>定义</strong>：子域是对业务领域的逻辑划分，用于分解复杂问题。通常分为<strong>核心子域</strong>（业务核心竞争力）、<strong>支撑子域</strong>（辅助核心业务）和<strong>通用子域</strong>（可复用的标准化能力）。</p><p><strong>关键点</strong>：因业务目标、团队定位和组织发展阶段等方面的不同，这三个子域的划分并非一成不变，而是会互相转换。</p></div></details><details class="tag-plugin colorful folding" ><summary><p>限界上下文</p></summary><div class="body"><p><strong>定义</strong>：限界上下文本质上是一个自治的小世界，它有完备的职责，还有清晰的边界。</p><p><strong>关键点</strong>：</p><ol><li>一个子域的一切资产，包括领域模型、数据库、包、可执行程序、接口声明等，都应该封装在限界上下文中，避免跨越边界。</li><li>如何平衡边界的价值和不利影响，是划分边界时要做的一种重要取舍。<strong>一个较为稳妥的策略是考虑认知的渐进特征，不要过早隔离。在已经确定的边界上进行划分，延缓划分那些尚具模糊性的边界，在这些边界逐渐变得清晰时再分离它们。</strong></li></ol></div></details><details class="tag-plugin colorful folding" ><summary><p>上下文映射</p></summary><div class="body"><p><strong>定义</strong>：限界上下文约定了基于领域模型的架构层次的设计分解，而分解必然意味着集成和协作。上下文映射就是对限界上下文之间的协作关系的模式总结。</p><p><strong>关键点</strong>：</p><ol><li>在边界上完成概念映射是一种基本模式。通过在应用层组装或者使用适配器完成概念映射，可以保持领域概念的清晰，避免领域模型遭到不必要的污染。</li><li>防腐层模式、标准开放服务模式、客户-供应商模式、追随者模式。</li></ol></div></details><h3 id="串讲">串讲</h3><p>在应对复杂业务系统时，DDD 通过<strong>分治策略</strong>将业务领域拆分为多个<strong>子域</strong>（如电商系统的订单、支付子域），每个子域对应一个<strong>限界上下文</strong>——这是技术与业务对齐的关键边界，既承载领域模型的实现，也通过<strong>上下文映射</strong>（如防腐层、共享内核等模式）实现跨子域协作，避免模型污染。</p><p>限界上下文内的<strong>领域对象</strong>是业务逻辑的载体：具备唯一标识和生命周期的<strong>实体</strong>（如订单实体通过 ID 跟踪状态变化）、描述特征且不可变的<strong>值对象</strong>（如地址由省市构成，修改需整体替换），以及通过<strong>聚合根</strong>统一操作保证一致性的<strong>聚合</strong>（如订单聚合根管理订单项和配送信息）。当业务逻辑跨越多个聚合时，由无状态的<strong>领域服务</strong>协调（如支付计算需整合订单、账户聚合）。</p><p>对象的创建与持久化分别由<strong>工厂</strong>（封装复杂初始化逻辑）和<strong>资源库</strong>（隔离存储细节）负责，而<strong>领域事件</strong>（如订单支付成功事件）则驱动跨上下文的异步协作。</p><div class="tag-plugin quot"><h2 class="content" id="战术设计" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">战术设计</span><span class="empty"></span></h2></div><h3 id="factory">factory</h3><ul><li>factory 用于构建复杂的领域对象。</li></ul><h3 id="repository">repository</h3><ul><li>只有聚合根有 repository。</li><li>repository 就只提供 <code>load</code> 和 <code>save</code> 功能，且要保证事务一致性。</li><li>尽可能提供行级的 repository，而不是表级的 repository，对于表级的 repository，可以抽成一个领域服务。</li></ul><h3 id="设计模式">设计模式</h3><h4 id="责任链模式">责任链模式</h4><blockquote><p>将请求的发送者和接受者解耦，使多个对象都有机会处理请求。</p></blockquote><ul><li>责任链模式的使用要点在于要将维护责任链的代码和业务代码分开。</li><li>在 DDD 中使用责任链模式时，应创建一个领域服务，在领域服务中完成责任链的创建和执行。</li><li>尽量不要在责任链的处理器中通过 <code>set</code>  修改领域对象（聚合根）的状态，责任链应仅用于某些值的计算，最终将计算结果交给聚合根完成业务操作。</li></ul><p>笔者实现了一个快速构建责任链的工具：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go</span><span class="cap link footnote">https://github.com/hedon954/devkit-go/blob/main/designmode/responsibility/builder.go</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><h4 id="策略模式">策略模式</h4><blockquote><p>允许在运行时根据需要选择不同的实现。</p></blockquote><ul><li>在 DDD 中使用策略模式时，通常先定义一个领域服务接口，再在其实现类中完成策略的加载、选择和执行。</li><li>注意屏蔽策略模式的实现细节，避免上层关注领域服务内的设计模式细节。</li></ul><h4 id="桥接模式">桥接模式</h4><blockquote><p>旨在通过解耦抽象和实现，使两者能够独立扩展和变化。</p></blockquote><ul><li><strong>多维解耦机制</strong>：桥接模式通过组合/聚合关系替代继承关系，将原本紧密耦合的抽象层（功能定义）与实现层（具体操作）分离例如遥控器（抽象）与电视（实现）的协作，遥控器通过接口控制电视，无需关注具体品牌。</li><li><strong>正交扩展能力</strong>：支持两个独立变化维度（如消息类型与通知渠道、图形与渲染方式），避免类数量呈指数级增长（M×N 组合问题）。电商物流系统中，新增微信通知渠道时，无需修改所有消息类即可实现扩展。</li></ul><h4 id="规约模式">规约模式</h4><blockquote><p>规约模式是一种用于定义业务领域中规则和约束的模式，通常由规约接口（Specification）和验证器（Validator）两个部分组成。</p></blockquote><ul><li>在 DDD 中，规约模式并不是在聚合根进行业务操作之前做前置校验，而是在聚合根完成业务操作之后做后置校验，确保 Repository 保存的聚合根符合业务规则。</li></ul><h4 id="适配器模式">适配器模式</h4><blockquote><p>将<strong>被适配者（Adaptee）的接口</strong>转换为<strong>目标接口（Target）</strong>，使原本因接口不兼容而无法协同工作的类能够协同。</p></blockquote><ul><li>在 DDD 中，可以使用适配器模式来实现防腐层，以将外部上下文接口（如开放主机服务）返回的模型转换为本地上下文定义的领域模型，并将本地上下文的操作转换为对外部上下文的操作。可以有效隔离外部上下文的领域模型，避免互相污染。</li></ul><h3 id="领域事件">领域事件</h3><h4 id="幂等性">幂等性</h4><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image.png" alt=""></p><h4 id="领域事件的定义">领域事件的定义</h4><blockquote><p>领域事件是领域模型的组成部分，它通常由聚合根产生，并被其他聚合或者限界上下文订阅和处理，触发相应的业务逻辑。</p></blockquote><p>注意点：</p><ul><li>应该根据限界上下文中的通用语言来命名事件：AccountActivited。</li><li>应该将事件建模成值对象或贫血对象。</li></ul><p>应用：</p><ol><li>解耦领域对象之间的关系；</li><li>触发其他领域对象的行为；</li><li>记录领域内已发生的状态变化；</li><li>实现跨聚合的最终一致性；</li><li>进行限界上下文集成。</li></ol><p>消息体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;event_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;event_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;entity_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;event_time&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extra_data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="领域事件的生成">领域事件的生成</h4><ol><li>应用层创建领域事件。</li><li>聚合根创建领域事件。</li></ol><p>要避免在聚合根内部调用基础实施发布领域事件，而是生成后返回给应用层，由应用层去发布。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entity <span class="keyword">struct</span> &#123;</span><br><span class="line">  Events []Event</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e *Entity)</span></span>ResgisterEvent(event Event) &#123;</span><br><span class="line">  e.Events = <span class="built_in">append</span>(e.Events. event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e *Entity)</span></span> GetEvents() []Event &#123;</span><br><span class="line">  res := e.Events()</span><br><span class="line">  e.Events = []Event&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="领域事件的发布">领域事件的发布</h4><ol><li>直接发布并轮询补偿：为事件存储一个发布状态标识，用于记录是否补发成功。并提供定时任务检索超时未发布成功的事件进行重新发布。</li><li>采用事务日志拖尾：引入变更数据捕获组件（Change Data Capture，简称 CDC），捕获数据的变更日志，解析后获得领域事件并发布。</li></ol><h4 id="领域事件的订阅">领域事件的订阅</h4><p>将领域事件订阅者放置在用户接口层 <code>user-interface-subscriber</code>，收到事件后调用应用服务执行业务逻辑。</p><h3 id="事件溯源">事件溯源</h3><p>事件溯源（Event Sourcing）是一种将所有的领域事件（Domain Event）存储到事件存储（Event Store）中，并通过重放历史事件来还原领域对象状态的模式。</p><p>核心思想是将系统中所有的状态变更都视为事件，将这些事件以事件顺序记录下来，并存储到事件存储中。这样，可以通过重放这些事件，来还原任意时刻的系统状态。</p><p>三种方案：</p><ol><li>通过回放所有的历史事件重建聚合根。</li><li>通过快照提高重建聚合根的效率。</li><li><strong>通过拉链表生成所有事件对应的快照。</strong></li></ol><div class="tag-plugin colorful note" color="green"><div class="body"><p>拉链表是一种用于处理缓慢变化维度问题的数据结构，它可以有效地处理维度数据的历史变化。在拉链表中，每个记录都有一个开始时间和结束时间，用于描述该记录的存活时间，即该记录的有效期。</p></div></div><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250312183214921.png" alt="拉链法示意图"></p><h3 id="CQRS">CQRS</h3><p>CQRS 将系统的操作分为两类：</p><ul><li><strong>命令（Command）</strong>：负责数据的写操作（增、删、改），不返回数据。</li><li><strong>查询（Query）</strong>：负责数据的读操作，仅返回结果且不修改数据。</li></ul><p>两者的数据模型可独立设计，甚至使用不同的数据库或存储技术。</p><details class="tag-plugin colorful folding" color="blue"><summary><p>适用场景</p></summary><div class="body"><p><strong>应对高并发读写场景</strong></p><ul><li><p>案例 1：B 站点赞系统</p><p>在日均活跃用户近亿的 B 站，点赞功能通过 CQRS 分离读写操作。写入端通过消息队列（如 Kafka）异步处理请求，避免数据库锁竞争；查询端通过缓存优化读取性能，显著提升系统吞吐量和稳定性。</p></li><li><p>案例 2：实时答题 PK 游戏</p><p>高并发的答题得分计算场景中，CQRS 结合事件溯源（Event Sourcing）记录每个操作事件，确保读写模型的最终一致性，同时支持复杂战况数据的实时展示。</p></li></ul><p><strong>解决复杂查询需求</strong></p><ul><li><p>案例 3：电商订单查询</p><p>随着订单查询需求多样化（如按时间筛选、跨实体聚合数据），CQRS 通过独立读模型简化查询逻辑，避免领域模型被复杂查询逻辑污染。</p></li><li><p>案例 4：微服务数据聚合</p><p>在微服务架构中，CQRS 允许通过事件同步跨服务数据到专用读库，避免跨服务联表查询的性能瓶颈（如行程管理服务与用户信息服务的聚合查询）。</p></li></ul><p><strong>提升数据模型灵活性</strong></p><ul><li><p>案例 5：文本增量更新</p><p>针对大型文本编辑场景，CQRS 拆分读写模型，增量保存修改记录并通过事件合并，减少网络传输数据量，同时支持任意版本的历史数据恢复。</p></li></ul></div></details><details class="tag-plugin colorful folding" color="orange"><summary><p>不适用场景</p></summary><div class="body"><ul><li>简单 CRUD 系统（如小型管理后台）</li><li>强一致性要求的金融交易场景（如实时扣款）</li><li>团队缺乏事件驱动架构经验时</li></ul></div></details><h3 id="一致性">一致性</h3><h4 id="聚合内事务实现">聚合内事务实现</h4><ul><li>聚合内事务控制不要放在应用层，会使应用层承担过多的责任。应用层应专注于协调领域对象和基础设施以完成业务操作，不应过多涉及数据访问和事务控制的细节。</li><li>聚合内事务控制可以交给 <code>Repository</code> 来实现，采用乐观锁解决并发问题，可以基于版本号和时间戳，一般重试 1-3 次即可。</li></ul><h4 id="聚合间事务实现">聚合间事务实现</h4><ul><li><p>聚合间控制可以单独建立一个领域服务 Domain Service 来完成。</p></li><li><p>对于实时性要求不高，仅需最终一致性，可以使用<strong>本地消息表</strong>或者<strong>最大努力通知</strong>的方案。</p></li><li><p>对于实时性一致性要求比较高，可以采用 <strong>TCC（Try-Confirm-Cancel）</strong> 事务方案。</p></li><li><p>对于长事务场景，或者涉及外部系统、遗留系统，可以考虑 <strong>Saga</strong> 事务方案。</p><blockquote><p>Saga 将事务分为多个事务，这些分支事务按照一定的顺序执行。当某个分支事务执行成功后，会通过消息通知下一个分支执行；当某个分支事务执行失败时，会按照正常事务执行顺序的相反方向进行一系列的补偿操作，以确保全局事务的一致性。</p></blockquote></li></ul><div class="tag-plugin quot"><h2 class="content" id="战略设计" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">战略设计</span><span class="empty"></span></h2></div><h3 id="事件风暴">事件风暴</h3><h4 id="核心概念与元素">核心概念与元素</h4><table><thead><tr><th>元素名称</th><th>颜色标识</th><th>说明</th></tr></thead><tbody><tr><td><font color="#FFA500"><strong>领域事件（Domain Event）</strong></font></td><td>橙色</td><td>表示已发生的业务事实，以“动词过去式”命名（如“订单已提交”），是事件风暴的核心起点。</td></tr><tr><td><font color="#00008B"><strong>命令（Command）</strong></font></td><td>深蓝色</td><td>触发领域事件的操作或意图（如“提交订单”），通常由用户或系统触发。</td></tr><tr><td><font color="#FFFF00"><strong>参与者（Actor）</strong></font></td><td>黄色</td><td>执行命令的角色，包括用户、部门或外部系统（如“客户”触发支付命令）。</td></tr><tr><td><font color="#FFC0CB"><strong>外部系统（External System）</strong></font></td><td>粉色</td><td>与当前系统交互的第三方服务（如支付网关回调生成事件）。</td></tr><tr><td><font color="#800080"><strong>策略（Policy）</strong></font></td><td>紫色</td><td>业务规则或约束条件（如“库存不足时取消订单”），决定事件触发的逻辑。</td></tr><tr><td><font color="#008000"><strong>读模型（Read Model）</strong></font></td><td>绿色</td><td>为查询优化的数据视图（如“用户订单列表”），支持决策展示。</td></tr><tr><td><font color="#FFD700"><strong>聚合（Aggregate）</strong></font></td><td>大黄色</td><td>业务对象集合（如“订单聚合”包含订单项和状态），维护一致性和完整性。</td></tr><tr><td><font color="#FF0000"><strong>问题（Question）</strong></font></td><td>红色</td><td>未达成共识的争议点（如事件定义分歧），需后续专项讨论。</td></tr></tbody></table><h4 id="实施流程与步骤">实施流程与步骤</h4><ol><li><p><strong>准备工作</strong></p><ul><li><strong>参与人员</strong>：业务专家、开发、产品、测试等跨职能角色，需领域专家主导。</li><li><strong>物料</strong>：多色便签、白板、马克笔，线上工具辅助远程协作。</li></ul></li><li><p><strong>识别领域事件</strong><br>团队通过头脑风暴罗列所有可能事件（如电商场景的“订单已创建”“库存已扣减”），按时间轴排列，争议事件用红色便签标记并暂存。</p></li><li><p><strong>补充命令与角色</strong><br>为每个事件关联触发命令及执行者（如“客户”执行“支付订单”命令生成“支付完成”事件），区分内部操作与外部系统调用。</p></li><li><p><strong>定义策略与读模型</strong><br>添加业务规则（如“订单金额≥1000元需审核”）和数据展示需求（如“实时库存看板”）。</p></li><li><p><strong>构建聚合与划分子域</strong><br>将相关事件、命令归类为聚合（如“支付聚合”），划分限界上下文（如“订单服务”“库存服务”），明确微服务边界。</p></li></ol><h4 id="注意事项">注意事项</h4><ol><li><p><strong>事件粒度的把控</strong>：避免过度细化（如“用户已睁眼&quot;）或过于宽泛（如“订单已修改”），需聚焦业务关键节点。</p></li><li><p><strong>争议处理与迭代</strong>：对未达成共识的事件标记为“问题”（红色便签），后续专题讨论；定期回顾模型，修正错误或补充遗漏。</p></li><li><p><strong>技术实现衔接</strong> ：事件风暴的输出需转化为代码模型，例如通过事件溯源（Event Sourcing）持久化事件流，或结合 CQRS 分离读写逻辑。</p></li></ol><h3 id="C4-架构模型">C4 架构模型</h3><div class="tag-plugin link dis-select"><a class="link-card rich" title="" href="https://c4model.com/" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://c4model.com/" autofill="title,icon,desc"><div class="top"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div><span class="cap link footnote">https://c4model.com/</span></div><div class="bottom"><span class="title">https://c4model.com/</span><span class="cap desc footnote"></span></div></a></div><table><thead><tr><th><strong>层级</strong></th><th><strong>核心目标</strong></th><th><strong>受众</strong></th><th><strong>关键元素</strong></th></tr></thead><tbody><tr><td><strong>Context（上下文）</strong></td><td>描述系统与外部实体（用户、第三方系统）的交互关系</td><td>非技术人员（如业务方、客户）</td><td>系统边界、用户角色、外部依赖（如支付网关）</td></tr><tr><td><strong>Container（容器）</strong></td><td>展示系统内部的高阶技术组件（进程级单元）</td><td>技术管理者、架构师</td><td>Web 应用、数据库、消息队列等独立进程单元，关注技术选型与通信协议（如 REST API、gRPC）</td></tr><tr><td><strong>Component（组件）</strong></td><td>细化容器内部的业务模块与交互逻辑</td><td>开发团队</td><td>服务、模块、接口（如订单服务、库存服务），强调职责划分与依赖关系</td></tr><tr><td><strong>Code（代码）</strong></td><td>展示组件实现的代码结构</td><td>开发者</td><td>类、方法、数据库表（如 UML 类图、ER 图），通常由 IDE 工具自动生成</td></tr></tbody></table><p>除了四层核心视图，C4 模型还提供：</p><ul><li><strong>部署图</strong>：展示容器在物理环境中的分布（如 Kubernetes 集群部署）。</li><li><strong>动态图</strong>：描述业务流程（如用户下单到支付完成的时序交互）。</li><li><strong>系统景观图</strong>：多系统协同的全局视图（如企业级中台架构）。</li></ul><div class="tag-plugin tabs" align="center"id="tab_2"><div class="nav-tabs"><div class="tab active"><a href="#tab_2-1">Context</a></div><div class="tab"><a href="#tab_2-2">Container</a></div><div class="tab"><a href="#tab_2-3">Component</a></div><div class="tab"><a href="#tab_2-4">Code</a></div></div><div class="tab-content"><div class="tab-pane active" id="tab_2-1"><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/SystemContext-20250312173256060.png" alt=""></p></div><div class="tab-pane" id="tab_2-2"><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Containers-20250312173305921.png" alt=""></p></div><div class="tab-pane" id="tab_2-3"><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Components-20250312173320890.png" alt=""></p></div><div class="tab-pane" id="tab_2-4"><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/MainframeBankingSystemFacade-20250312173313572.png" alt=""></p></div></div></div><div class="tag-plugin quot"><h2 class="content" id="实践案例" type="icon"><img class="icon prefix" src="https://bu.dusays.com/2022/10/24/63567d3e07da3.png" /><span class="text">实践案例</span><span class="empty"></span></h2></div><p>参考作者的 <a href="https://github.com/feiniaojin/ddd-archetype">ddd-archetype</a> ，笔者实现了一个 Go 版本的 <code>ddd-archetype-go</code>：</p><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/hedon-go-road/ddd-archetype-go" target="_blank" rel="external nofollow noopener noreferrer" cardlink api="https://site-info-api-hedon.vercel.app/api/v1?url=https://github.com/hedon-go-road/ddd-archetype-go" autofill="title,icon"><div class="left"><span class="title">https://github.com/hedon-go-road/ddd-archetype-go</span><span class="cap link footnote">https://github.com/hedon-go-road/ddd-archetype-go</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg"></div></div></a></div><p>整体架构如下：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/ddd-ruoyi.drawio.png" alt=""></p>]]></content>
    
    
    <summary type="html">阅读《悟道领域驱动设计》后的一些笔记和思考。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDD" scheme="https://hedon.top/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.24 新特性解读：使用 testing/synctest 优雅地测试并发代码</title>
    <link href="https://hedon.top/2025/03/06/go-lib-synctest/"/>
    <id>https://hedon.top/2025/03/06/go-lib-synctest/</id>
    <published>2025-03-06T07:00:18.000Z</published>
    <updated>2025-04-05T14:31:32.873Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言开发中，并发编程一直是其最引人注目的特性之一。然而，如何有效地测试并发代码却常常让开发者感到头疼。Go 1.24 版本引入的实验性包 <code>testing/synctest</code> 为这个问题带来了优雅的解决方案。今天，让我们深入了解这个新特性。</p><h1>并发测试的传统困境</h1><p>在介绍新方案之前，我们先看看传统的并发测试面临哪些问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTraditional</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 执行某些操作</span></span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待操作完成</span></span><br><span class="line">    time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">if</span> !done &#123;</span><br><span class="line">        t.Fatal(<span class="string">&quot;操作未完成&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式存在明显的问题：</p><ol><li><strong>时间依赖</strong>：需要通过 Sleep 等待，导致测试运行缓慢</li><li><strong>不稳定性</strong>：在不同环境下可能产生不同结果</li><li><strong>精确性差</strong>：难以准确把握检查时机</li></ol><h1>synctest：优雅的解决方案</h1><p><code>testing/synctest</code> 包通过两个核心函数改变了这一切：</p><ul><li><code>Run()</code>: 创建隔离的测试环境（bubble）</li><li><code>Wait()</code>: 等待所有 goroutine 进入稳定状态</li></ul><p>让我们看看如何改写上面的测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWithSynctest</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 执行某些操作</span></span><br><span class="line">            time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">            done = <span class="literal">true</span></span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        synctest.Wait()  <span class="comment">// 等待所有 goroutine 进入稳定状态</span></span><br><span class="line">        <span class="keyword">if</span> !done &#123;</span><br><span class="line">            t.Fatal(<span class="string">&quot;操作未完成&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>深入理解 Wait 机制</h1><h2 id="Wait-的本质">Wait 的本质</h2><p>很多开发者初次接触 <code>Wait()</code> 时可能会感到困惑：它到底在等待什么？什么时候会返回？</p><p>想象一个场景：你在拍摄一张全家福，需要等待所有人都找到自己的位置，站好不动，才能按下快门。<code>Wait()</code> 就像这个摄影师，它在等待所有 goroutine（就像照片中的人）都进入一个稳定的状态（站好不动）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 类比：三个人要拍全家福</span></span><br><span class="line">    <span class="keyword">go</span> person1()  <span class="comment">// 第一个人找位置</span></span><br><span class="line">    <span class="keyword">go</span> person2()  <span class="comment">// 第二个人找位置</span></span><br><span class="line">    <span class="keyword">go</span> person3()  <span class="comment">// 第三个人找位置</span></span><br><span class="line"></span><br><span class="line">    synctest.Wait()  <span class="comment">// 等待所有人都站好不动</span></span><br><span class="line">    <span class="comment">// 这时可以安全地&quot;按下快门&quot;（检查程序状态）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="为什么需要-Wait？">为什么需要 Wait？</h2><p>在并发程序中，我们经常需要在特定时刻检查程序状态。但是，如果某些 goroutine 还在运行，这个状态可能随时发生变化。<code>Wait()</code> 通过确保所有 goroutine 都进入稳定状态，为我们提供了一个&quot;快照&quot;时刻。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        result = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    synctest.Wait()  <span class="comment">// 等待 goroutine 进入稳定状态</span></span><br><span class="line">    <span class="comment">// 此时 result 的值是确定的，不会突然改变</span></span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="持久阻塞的概念">持久阻塞的概念</h2><p>哪些操作会导致持久阻塞？</p><ul><li>channel 操作（同一 bubble 内）</li><li>time.Sleep</li><li>sync.WaitGroup.Wait</li><li>sync.Cond.Wait</li></ul><p>哪些操作不算持久阻塞？</p><ul><li>互斥锁操作</li><li>外部 I/O</li><li>外部 channel 操作</li></ul><h1>虚拟时钟：测试的神器</h1><p><code>synctest</code> 的另一个强大特性是虚拟时钟机制。在 bubble 内部，所有时间相关的操作都使用虚拟时钟，这意味着：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 看似等待24小时</span></span><br><span class="line">    time.Sleep(<span class="number">24</span> * time.Hour)</span><br><span class="line">    <span class="comment">// 实际上立即执行完成！</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个特性让我们能够：</p><ol><li>快速测试长时间操作</li><li>精确控制时间流逝</li><li>避免测试的不确定性</li></ol><h1>实战案例：深入理解 HTTP 100 Continue 测试</h1><h2 id="背景知识">背景知识</h2><p>HTTP 的 100 Continue 机制是一个优化大文件上传的协议特性：</p><ol><li>客户端想上传大文件时，先发送带有 “Expect: 100-continue” 头的请求</li><li>服务器可以决定是否接受这个上传：<ul><li>如果接受，返回 “100 Continue”</li><li>如果拒绝，可以直接返回错误状态码</li></ul></li><li>客户端根据服务器的响应决定是否发送文件内容</li></ol><h2 id="详细测试实现">详细测试实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHTTPContinue</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    synctest.Run(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 第一步：建立测试环境</span></span><br><span class="line">        srvConn, cliConn := net.Pipe()</span><br><span class="line">        <span class="keyword">defer</span> srvConn.Close()</span><br><span class="line">        <span class="keyword">defer</span> cliConn.Close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二步：配置 HTTP 客户端</span></span><br><span class="line">        tr := &amp;http.Transport&#123;</span><br><span class="line">            DialContext: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, address <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cliConn, <span class="literal">nil</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ExpectContinueTimeout: <span class="number">5</span> * time.Second,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三步：准备测试数据</span></span><br><span class="line">        body := <span class="string">&quot;request body&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第四步：发送请求</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            req, _ := http.NewRequest(<span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;http://test.tld/&quot;</span>, </span><br><span class="line">                strings.NewReader(body))</span><br><span class="line">            req.Header.Set(<span class="string">&quot;Expect&quot;</span>, <span class="string">&quot;100-continue&quot;</span>)</span><br><span class="line">            resp, err := tr.RoundTrip(req)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                t.Errorf(<span class="string">&quot;请求失败: %v&quot;</span>, err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.Body.Close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第五步：验证请求头</span></span><br><span class="line">        req, err := http.ReadRequest(bufio.NewReader(srvConn))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;读取请求失败: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第六步：验证请求体未发送</span></span><br><span class="line">        <span class="keyword">var</span> gotBody strings.Builder</span><br><span class="line">        <span class="keyword">go</span> io.Copy(&amp;gotBody, req.Body)</span><br><span class="line">        synctest.Wait()</span><br><span class="line">        <span class="keyword">if</span> got := gotBody.String(); got != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;在发送 100 Continue 之前，意外收到请求体: %q&quot;</span>, got)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第七步：发送 100 Continue</span></span><br><span class="line">        srvConn.Write([]<span class="type">byte</span>(<span class="string">&quot;HTTP/1.1 100 Continue\r\n\r\n&quot;</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第八步：验证请求体</span></span><br><span class="line">        synctest.Wait()</span><br><span class="line">        <span class="keyword">if</span> got := gotBody.String(); got != body &#123;</span><br><span class="line">            t.Fatalf(<span class="string">&quot;收到的请求体 %q，期望 %q&quot;</span>, got, body)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第九步：完成请求</span></span><br><span class="line">        srvConn.Write([]<span class="type">byte</span>(<span class="string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试的关键点解析">测试的关键点解析</h2><ol><li><p><strong>使用 net.Pipe()</strong></p><ul><li>创建内存中的网络连接</li><li>避免依赖真实网络</li><li>保证测试的可重复性</li></ul></li><li><p><strong>请求发送过程</strong></p><ul><li>在独立的 goroutine 中发送请求</li><li>设置 “Expect: 100-continue” 头</li><li>准备要发送的请求体</li></ul></li><li><p><strong>验证关键行为</strong></p><ul><li>确认请求头正确发送</li><li>验证请求体在收到 100 Continue 之前未发送</li><li>验证请求体在收到 100 Continue 后正确发送</li></ul></li><li><p><strong>使用 Wait 的时机</strong></p><ul><li>在检查请求体之前调用 Wait</li><li>确保所有数据传输操作都已完成或阻塞</li><li>获得稳定的程序状态进行验证</li></ul></li></ol><h1>使用建议</h1><ol><li><strong>明确边界</strong>：理解什么操作会导致持久阻塞，什么不会</li><li><strong>清理资源</strong>：确保所有 goroutine 在测试结束前退出</li><li><strong>模拟 I/O</strong>：使用内存管道替代真实网络连接</li><li><strong>合理使用 Wait</strong>：在需要检查状态的关键点调用</li></ol><h1>注意事项</h1><ol><li>目前是实验性功能，需要设置 <code>GOEXPERIMENT=synctest</code></li><li>不支持测试真实的外部 I/O 操作</li><li>互斥锁操作不被视为持久阻塞</li></ol>]]></content>
    
    
    <summary type="html">本文介绍了 Go 1.24 版本引入的实验性包 testing/synctest，并详细讲解了如何使用它优雅地测试并发代码。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>直播系统推拉流原理</title>
    <link href="https://hedon.top/2025/03/04/live-stream-push-pull/"/>
    <id>https://hedon.top/2025/03/04/live-stream-push-pull/</id>
    <published>2025-03-04T03:34:09.000Z</published>
    <updated>2025-04-05T14:31:32.876Z</updated>
    
    <content type="html"><![CDATA[<h1>直播系统推拉流原理概述</h1><p>直播系统的核心功能是实现主播端视频采集后的实时传输，以及观众端的实时观看。整个过程主要包含：推流、服务器处理、拉流三个环节。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250304121833913.png" alt="直播系统架构"></p><h2 id="核心概念解析">核心概念解析</h2><h3 id="1-推流（Push）">1. 推流（Push）</h3><p>推流是指主播端将视频数据传输到服务器的过程。主要使用 <code>RTMP</code> 协议（Real Time Messaging Protocol）。</p><p>比如可能有如下推流 URL 的生成逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generatePushUrl</span><span class="params">(String pushDomain, String pushKey, String appName, String streamName, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pushUrl</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 推流域名未开启鉴权功能的情况下</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(pushKey)) &#123;</span><br><span class="line">        pushUrl = <span class="string">&quot;rtmp://&quot;</span> + pushDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000L</span> + expireTime;</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringToMd5</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;-&quot;</span> + Long.toString(timeStamp) + <span class="string">&quot;-0-0-&quot;</span> + pushKey;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authKey</span> <span class="operator">=</span> md5(stringToMd5);</span><br><span class="line">        pushUrl = <span class="string">&quot;rtmp://&quot;</span> + pushDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;?auth_key=&quot;</span> + Long.toString(timeStamp) + <span class="string">&quot;-0-0-&quot;</span> + authKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pushUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推流地址的组成部分：</p><ul><li>rtmp:// - 协议</li><li>pushDomain - 推流域名</li><li>appName - 应用名称</li><li>streamName - 流名称</li><li>auth_key - 鉴权参数（可选）</li></ul><h3 id="2-拉流（Pull）">2. 拉流（Pull）</h3><p>拉流是观众观看直播的过程。支持多种协议：</p><ul><li>RTMP：延迟低（1-3秒）</li><li>HTTP-FLV：延迟适中（2-5秒）</li><li>HLS(m3u8)：延迟较高（5-30秒）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FLV 格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generalPullUrlFlv</span><span class="params">(String pullDomain, String pullKey, String appName, String streamName, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(pullKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://&quot;</span> + pullDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;.flv&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 鉴权逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HLS 格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generalPullUrlHls</span><span class="params">(String pullDomain, String pullKey, String appName, String streamName, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(pullKey)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://&quot;</span> + pullDomain + <span class="string">&quot;/&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + streamName + <span class="string">&quot;.m3u8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 鉴权逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直播流程">直播流程</h2><ol><li><p><strong>主播开播</strong>：</p><ul><li>系统生成唯一的 streamId</li><li>生成带鉴权的推流地址</li><li>主播端推流软件（如 OBS）开始推流</li></ul></li><li><p><strong>服务器处理</strong>：</p><ul><li>流媒体服务器接收推流</li><li>进行转码、录制等处理</li><li>将流分发到 CDN 节点</li></ul></li><li><p><strong>观众观看</strong>：</p><ul><li>获取对应格式的拉流地址</li><li>通过播放器拉取直播流</li><li>实现实时观看</li></ul></li></ol><h2 id="实现建议">实现建议</h2><ol><li><p><strong>选择合适的流媒体服务器</strong>：</p><ul><li>商业云服务：阿里云直播、腾讯云直播</li><li>开源方案：SRS、Nginx-RTMP</li></ul></li><li><p><strong>根据业务场景选择协议</strong>：</p><ul><li>普通直播：HTTP-FLV</li><li>低延迟场景：RTMP</li><li>移动端兼容性要求高：HLS</li></ul></li><li><p><strong>关注关键指标</strong>：</p><ul><li>延迟控制</li><li>卡顿率</li><li>首屏时间</li><li>带宽成本</li></ul></li><li><p><strong>安全鉴权：</strong></p><ul><li>防盗链机制</li></ul></li></ol>]]></content>
    
    
    <summary type="html">本文介绍了直播系统推拉流的基本原理，包括推流和拉流的过程、协议选择、关键指标等。</summary>
    
    
    
    <category term="解决方案" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="直播系统" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="直播系统" scheme="https://hedon.top/tags/%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>网络数据包的完整旅程：从发送到接收的全过程</title>
    <link href="https://hedon.top/2025/03/01/net-data-journey/"/>
    <id>https://hedon.top/2025/03/01/net-data-journey/</id>
    <published>2025-03-01T04:58:37.000Z</published>
    <updated>2025-04-05T14:31:32.876Z</updated>
    
    <content type="html"><![CDATA[<p>不知道你是否曾经好奇你发出的一个网络请求，最终是怎么到达对端，并将你想要的信息返回给你的。本文将通过一个 HTTP 请求与响应，从一个比较宏观的角度来梳理下一个数据包在网络中的旅途，旨在帮助笔者和各位读者建立起对计算机网络模型一个比较全面的认知。</p><blockquote><p>本文参考极客时间《网络架构实战课（谢友鹏）》，再根据笔者的知识面、按照个人理解，补充更多丰富具体的内容。</p></blockquote><h1>实战</h1><p>好，那我们直接开始，我们先使用 <code>curl</code> 来发起一个 HTTP 请求，看看这过程中发生了什么：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /dev/null -v https://example.com</span><br></pre></td></tr></table></figure><p>在笔者的 mac 机器上，这行命令的输出如下：</p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301131247066.png" data-fancybox="true" alt="curl https//example.com 结果分析" style="width: 100%; height: auto;"><p>当我们发起请求时，首先会对 <code>example.com</code> 进行域名解析，分别尝试解析到它的 <code>IPv6</code> 和 <code>IPv4</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* IPv6: (none)</span><br><span class="line">* IPv4: 23.215.0.138, 96.7.128.198, 23.192.228.80, 23.192.228.84, 23.215.0.136, 96.7.128.175</span><br></pre></td></tr></table></figure><p>因为我们使用的是 <code>https</code> 协议，所以会尝试跟这些地址的 <code>443</code> 端口建立 <code>TCP</code> 连接，（如果是 <code>https</code> 则跟 <code>80</code> 端口），并进行 <code>TLS 握手验证</code>，如果成功了，则会建立 <code>TCP</code> 连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Trying <span class="number">23.215</span><span class="number">.0</span><span class="number">.138</span>:<span class="number">443.</span>..</span><br><span class="line">...[TLS handshake]</span><br><span class="line">* Connected to example.com (<span class="number">23.215</span><span class="number">.0</span><span class="number">.138</span>) port <span class="number">443</span></span><br></pre></td></tr></table></figure><p>建立连接后，就开始发送 <code>HTTP</code> 请求，这里使用的是 HTTP2 协议。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* using HTTP/2</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0* [HTTP/2] [1] OPENED stream <span class="keyword">for</span> https://example.com/</span><br><span class="line">* [HTTP/2] [1] [:method: GET]</span><br><span class="line">* [HTTP/2] [1] [:scheme: https]</span><br><span class="line">* [HTTP/2] [1] [:authority: example.com]</span><br><span class="line">* [HTTP/2] [1] [:path: /]</span><br><span class="line">* [HTTP/2] [1] [user-agent: curl/8.10.1]</span><br><span class="line">* [HTTP/2] [1] [accept: */*]</span><br><span class="line">&#125; [5 bytes data]</span><br><span class="line">&gt; GET / HTTP/2</span><br><span class="line">&gt; Host: example.com</span><br><span class="line">&gt; User-Agent: curl/8.10.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">* Request completely sent off</span><br></pre></td></tr></table></figure><p>最后，服务器返回了 HTTP 200 OK 的响应。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123; [5 bytes data]</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):</span><br><span class="line">&#123; [265 bytes data]</span><br><span class="line">* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):</span><br><span class="line">&#123; [265 bytes data]</span><br><span class="line">&lt; HTTP/2 200</span><br><span class="line">&lt; content-type: text/html</span><br><span class="line">&lt; etag: <span class="string">&quot;84238dfc8092e5d9c0dac8ef93371a07:1736799080.121134&quot;</span></span><br><span class="line">&lt; last-modified: Mon, 13 Jan 2025 20:11:20 GMT</span><br><span class="line">&lt; cache-control: max-age=1374</span><br><span class="line">&lt; <span class="built_in">date</span>: Sat, 01 Mar 2025 05:01:03 GMT</span><br><span class="line">&lt; alt-svc: h3=<span class="string">&quot;:443&quot;</span>; ma=93600,h3-29=<span class="string">&quot;:443&quot;</span>; ma=93600,quic=<span class="string">&quot;:443&quot;</span>; ma=93600; v=<span class="string">&quot;43&quot;</span></span><br><span class="line">&lt; content-length: 1256</span><br><span class="line">&lt;</span><br><span class="line">&#125; [5 bytes data]</span><br><span class="line">100  1256  100  1256    0     0   1172      0  0:00:01  0:00:01 --:--:--  1172</span><br><span class="line">* Connection <span class="comment">#0 to host example.com left intact</span></span><br></pre></td></tr></table></figure><p>要进一步了解网络数据包的细节，我们可以通过抓包工具进行分析。你可以使用 <code>tcpdump</code> 抓取与 <a href="http://example.com">example.com</a> 的通信数据包。</p><p>运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> tcpdump host example.com -w example.com.pcap</span><br></pre></td></tr></table></figure><p>然后再另外一个命令行窗口再次发送请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /dev/null -v https://example.com</span><br></pre></td></tr></table></figure><p>回到 <code>tcpdump</code> 的窗口并结束监听，我们就会得到 <code>example.com.pcap</code> 的抓包文件，可以通过 <code>Wireshark</code> 软件打开该文件：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301133015523.png" alt="tcpdump 分析结果"></p><h1>网络分层</h1><p>通过上述实验，我们可以清晰看到网络是分层的，主流的分层模型有 OSI 七层模型和 TCP/IP 四层模型，它们的对应关系及常见的协议如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/OSI-vs-TCP.png" alt="OSI-vs-TCP/IP"></p><p>我们在 Wireshark 上方随便选择一个数据包，使用鼠标点击下方左侧的每一层，可以在右侧看到对应的层级数据。从链路层到应用层，每一层的数据都是对下一层的进一步封装。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301134103404.png" alt="数据包封装"></p><p>在发送方，用户程序需要传输的数据会经过逐层封装。首先添加应用层的 HTTP Header，然后是传输层的 TCP Header，接着是网络层的 IP Header，最后在链路层添加以太网帧的帧头和帧尾，包括源 MAC 地址、目的 MAC 地址等链路层信息，最终形成网络中传输的完整数据包。</p><p>在接收方，数据包会按相反的顺序逐层解封装。接收设备从链路层开始解析数据，依次解读网络层、传输层和应用层的信息，最后将数据传递给接收方的应用程序。</p><p>如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/cn1.png" alt="数据包封装 &amp; 解析"></p><p>我们在 Wireshark 中点开下面的每一层，可以看到如下信息，我在图标注了最重要的几个信息：<img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250301135433547.png" alt="网络数据包关键信息"></p><h1>网络之旅</h1><p>经过上述实验，我们可以做个小总结：</p><p>通过上述实验，我们可以清晰理解数据包的传输过程：</p><ul><li>HTTP 请求是网络通信的应用层内容，它需要通过各层网络协议的封装才能实现端到端传输。</li><li>从发送方角度，数据传输遵循一个明确的逻辑顺序：首先将域名（<a href="http://example.com">example.com</a>）解析为 IP 地址，然后基于该 IP 地址和目标端口（443）建立 TCP 连接，接着找到目标 IP 的 MAC 地址，最终由网卡将完整封装的数据包发送到网络中。</li><li>从接收方角度，服务器处理数据包的过程是一个自下而上的解封装过程：数据链路层接收到的帧包含源 MAC 地址，网络层解析出 IPv4 地址和协议类型，传输层识别出 TCP 协议和源端口号，最终在应用层获取并处理 HTTP 请求数据。服务器根据这些信息构建响应，并按相反顺序封装返回给客户端。</li></ul><p>这种分层处理机制确保了网络通信的灵活性和可靠性，每层只需关注自己的职责，共同完成端到端的数据传输任务。</p><p>好，那么这里就有 2 个最关键的问题：</p><ol><li>如何通过域名获得 IP 地址？</li><li>如何通过 IP 地址获取 MAC 地址？</li></ol><h2 id="DNS-解析">DNS 解析</h2><p>DNS（Domain Name System，域名系统）是互联网的一项核心服务，它允许我们使用易记的域名（如 <code>example.com</code>）而不是数字 IP 地址（如 <code>93.184.216.34</code>）来访问网站。</p><p>当你在浏览器中输入一个域名时，DNS 解析按以下步骤进行：</p><ol><li><p><strong>浏览器缓存检查</strong>：浏览器首先检查自己的缓存，看是否已经存储了该域名对应的 IP 地址。</p></li><li><p><strong>操作系统缓存检查</strong>：如果浏览器缓存中没有，系统会检查操作系统的 DNS 缓存（如 Windows 的 DNS Client 服务）。</p></li><li><p><strong>路由器缓存检查</strong>：若系统缓存中也没有，请求会被发送到你的路由器，它也维护着一个 DNS 缓存。</p></li><li><p><strong>ISP DNS 服务器查询</strong>：如果以上缓存都未命中，请求会被发送到你的 ISP（互联网服务提供商）的 DNS 服务器。</p></li><li><p><strong>递归查询</strong>：ISP 的 DNS 服务器会执行递归查询：</p><ul><li>首先查询根域名服务器（Root DNS Server）</li><li>根服务器会引导到顶级域名服务器（TLD DNS Server，如 .com, .net, .org 等）</li><li>顶级域名服务器会引导到权威域名服务器（Authoritative DNS Server）</li><li>权威服务器会返回该域名的 IP 地址</li></ul></li><li><p><strong>结果返回与缓存</strong>：一旦获取到 IP 地址，它会被沿着查询路径返回，并在各个层级上缓存一段时间（由 TTL 值决定）。</p></li></ol><p>你可以使用以下工具查询 DNS 信息：</p><ul><li><strong>nslookup</strong>：<code>nslookup example.com</code></li><li><strong>dig</strong>：<code>dig example.com</code></li><li><strong>host</strong>：<code>host example.com</code></li></ul><p>这些工具可以帮助你了解域名的解析过程和结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ host example.com</span><br><span class="line">example.com has address 23.215.0.138</span><br><span class="line">example.com has address 23.192.228.84</span><br><span class="line">example.com has address 23.215.0.136</span><br><span class="line">example.com has address 23.192.228.80</span><br><span class="line">example.com has address 96.7.128.175</span><br><span class="line">example.com has address 96.7.128.198</span><br><span class="line">example.com has IPv6 address 2600:1408:ec00:36::1736:7f31</span><br><span class="line">example.com has IPv6 address 2600:1406:3a00:21::173e:2e65</span><br><span class="line">example.com has IPv6 address 2600:1406:3a00:21::173e:2e66</span><br><span class="line">example.com has IPv6 address 2600:1406:bc00:53::b81e:94c8</span><br><span class="line">example.com has IPv6 address 2600:1406:bc00:53::b81e:94ce</span><br><span class="line">example.com has IPv6 address 2600:1408:ec00:36::1736:7f24</span><br><span class="line">example.com mail is handled by 0 .</span><br></pre></td></tr></table></figure><p>通过 DNS 解析将域名转换为 IP 地址后，网络通信的下一步就是确定如何将数据包发送到目标 IP 地址，这就需要用到 ARP 协议来获取目标设备的 MAC 地址。</p><h2 id="穿越客户端局域网">穿越客户端局域网</h2><p><strong>当我们发送一个网络请求时，数据包如何找到离开家庭/办公网络的&quot;出口&quot;？</strong></p><p>数据包首先需要解决的是&quot;该往哪走&quot;的问题：</p><ol><li><p><strong>问题：我需要直接联系目标设备还是找个&quot;中介&quot;？</strong></p><p>解决方案：子网判断</p><ul><li>设备会比较目标 IP 与自己的 IP 和子网掩码</li><li>就像判断收件人是不是住在同一个小区</li></ul></li><li><p><strong>问题：如何找到同一网络中的设备？</strong></p><p>解决方案：ARP 协议</p><ul><li>类似于小区广播：“谁是 202 号房的？请告诉我你的门牌号！”</li><li>目标设备回应自己的 MAC 地址（设备的&quot;身份证号&quot;）</li></ul></li><li><p><strong>问题：目标在远方，如何离开本地网络？</strong></p><p>解决方案：默认网关</p><ul><li>就像不认识远方收件人的地址，先交给小区门卫（路由器）</li><li>数据包头上标注最终目的地 IP，但先送到网关的 MAC 地址</li></ul></li><li><p><strong>问题：数据如何在本地网络中转发？</strong></p><p>解决方案：交换机的 MAC 地址表</p><ul><li>交换机就像小区内的快递员，记住了每家每户的门牌号</li><li>它查表后将包裹精确送到对应的门口，不会打扰其他住户</li></ul></li></ol><p>简单来说，数据包在本地网络中的旅程就像是快递先确认收件人是否在同一小区，如果是，直接送达；如果不是，则交给小区出口的保安，由他负责进一步转发。</p><h2 id="穿越公网">穿越公网</h2><p><strong>数据包离开了本地网络，如何在茫茫互联网中找到遥远的目标服务器？</strong></p><p>数据包在互联网上的旅程就像一次跨国旅行：</p><ol><li><p><strong>问题：如何从私人区域进入公共世界？</strong></p><p>解决方案：NAT（网络地址转换）</p><ul><li><p>就像多人共用一个护照出国，本地设备共享一个公网 IP</p></li><li><p>路由器会记住谁发了什么请求，回程时能送回正确的设备</p></li></ul></li><li><p><strong>问题：互联网如此庞大复杂，谁来管理这些网络？</strong></p><p>解决方案：自治系统（Autonomous System, AS）</p><ul><li><p>AS 就像互联网世界的&quot;国家&quot;或&quot;独立王国&quot;</p></li><li><p>每个 AS 由单一技术管理机构控制（如 ISP、大企业或教育机构）</p></li><li><p>你的数据包首先进入你的 ISP 所在的 AS，然后可能穿越多个 AS</p></li><li><p>每个 AS 有唯一的 AS 号（ASN），如 AS7018(AT&amp;T) 或 AS8075(Microsoft)</p></li></ul></li><li><p><strong>问题：这些&quot;网络王国&quot;如何相互通信和合作？</strong></p><p>解决方案：BGP 协议(边界网关协议)</p><ul><li><p>BGP 是 AS 之间的&quot;外交语言&quot;，用于宣告路由信息</p></li><li><p>它告诉其他 AS：“通过我可以到达这些网络”</p></li><li><p>路由器根据 BGP 信息，决定数据包应该经过哪些 AS</p></li></ul></li><li><p><strong>问题：如何决定数据包在 AS 内部该走哪条路？</strong></p><p>解决方案：内部路由协议</p><ul><li><p>AS 内部使用 OSPF 或 IS-IS 等协议来找到最佳路径</p></li><li><p>路由器像城市中的交通指挥，根据&quot;路况&quot;决定下一个方向</p></li></ul></li><li><p><strong>问题：不同运营商之间如何连接？</strong></p><p>解决方案：互联网交换中心（IXP）</p><ul><li><p>就像不同航空公司在大型枢纽机场交换乘客</p></li><li><p>数据包在 IXP 从一个 AS “转机”到另一个 AS</p></li><li><p>这减少了路径长度，提高了传输效率</p></li></ul></li><li><p><strong>问题：我能知道我的数据经过了哪些地方吗？</strong></p><p>解决方案：路径追踪工具</p><ul><li><p>traceroute/tracert 就像给数据包装上 GPS</p></li><li><p>你可以看到数据包穿越的不同 AS 和路由器</p></li></ul></li></ol><p>互联网就像一个巨大的全球快递网络，你的数据包可能穿越多个国家、经过海底电缆，由不同的运营商接力传递，最终到达目的地的网络。</p><h2 id="穿越服务端局域网">穿越服务端局域网</h2><p><strong>数据包到达目标所在网络后，如何找到并到达最终的服务器？</strong></p><p>数据包抵达目的地网络，就像国际快递到达目标城市，还需要最后一段&quot;本地配送&quot;：</p><ol><li><p><strong>问题：如何确保只有合法请求能进入网络？</strong></p><p>解决方案：防火墙和安全策略</p><ul><li>就像机场海关，检查入境者是否符合入境条件</li><li>只有合法的数据包才能通过安全检查</li></ul></li><li><p><strong>问题：大型网站如何处理海量请求？</strong></p><p>解决方案：负载均衡</p><ul><li>像大型医院的分诊台，将病人分配到不同的医生处</li><li>根据服务器负载、用户位置等因素智能分发请求</li></ul></li><li><p><strong>问题：如何在数据中心复杂环境中找到目标服务器？</strong></p><p>解决方案：内部路由与最后一跳 ARP</p><ul><li>数据中心内部有自己的&quot;地图&quot;和&quot;道路系统&quot;</li><li>最后一个路由器会通过 ARP 找到服务器的具体位置</li></ul></li><li><p><strong>问题：现代云环境中，服务器可能是虚拟的，怎么处理？</strong></p><p>解决方案：虚拟网络</p><ul><li>物理服务器上可能运行多个虚拟机或容器</li><li>虚拟交换机将数据包准确送达虚拟环境中的目标应用</li></ul></li></ol><p>这就像国际快递最后的“最后一公里”配送 - 从目的地城市的分拣中心，经过层层筛选，最终送到收件人手中。</p><h2 id="总结">总结</h2><p>网络请求就像一封国际信件的旅程：</p><ol><li><p>本地投递：从你家出发，判断收件人是否在同小区。如不在，交给小区出口的门卫（网关）。</p></li><li><p>国际运输：</p><ul><li>先经过你所在“国家”（你 ISP 的 AS）的海关（NAT）</li><li>然后可能穿越多个“国家”（不同的 AS）</li><li>各国海关（路由器）通过“国际条约”（BGP）决定包裹走向</li><li>有时通过“国际中转站”（IXP）快速转运到其他“国家”</li></ul></li><li><p>目的地配送：</p><ul><li><p>通过目的地“海关”（防火墙）入境检查</p></li><li><p>经过“分拣中心”（负载均衡器）分配处理人员</p></li><li><p>最终通过“本地快递员”（内部路由和交换）送达收件人手中</p></li></ul></li></ol><p>数据包就这样完成了客户端设备到服务器的全程旅行，然后服务器的响应再沿着类似的路径返回到客户端设备，完成整个请求-响应循环。</p><h1>参考</h1><ul><li><p><a href="https://time.geekbang.org/column/article/846257">极客时间《网络架构实战课》</a></p></li><li><p><a href="https://www.geeksforgeeks.org/difference-between-osi-model-and-tcp-ip-model/">Difference Between OSI Model and TCP/IP Model</a></p></li></ul>]]></content>
    
    
    <summary type="html">通过一个 HTTP 请求与响应，深入探索背后的网络通信机制，从 DNS 解析、TCP 连接到数据封装与传输，全面解析数据包如何穿越局域网与公网到达目标服务器。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>解决方案丨游戏后端中的 Push-ACK 机制设计与内存优化</title>
    <link href="https://hedon.top/2025/02/27/solution-push-ack/"/>
    <id>https://hedon.top/2025/02/27/solution-push-ack/</id>
    <published>2025-02-27T12:31:45.000Z</published>
    <updated>2025-04-05T14:31:32.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言">引言</h2><p>在现代在线游戏开发中，服务器与客户端之间实时、可靠的通信机制是游戏体验的基石。作为一名游戏后端开发者，我曾经遇到过这样的场景：更新了一个公会系统的新功能，服务器需要向成千上万个在线玩家推送公会状态变更。短短几小时后，服务器内存使用率飙升至 90%，系统告警不断。问题出在哪里？Push 消息的可靠性机制实现不当导致了内存泄漏。</p><p>本文将深入探讨游戏后端中 Push-ACK 机制的设计与实现，特别关注如何避免内存暴涨问题，分享我在多个大型游戏项目中积累的经验与教训。</p><h2 id="背景：为什么需要应用层的-ACK-机制？">背景：为什么需要应用层的 ACK 机制？</h2><p>TCP 协议确实提供了可靠的数据传输保证，包括数据包的序列号、校验和、超时重传等机制。那么，为什么我们还需要在应用层实现额外的 ACK 机制呢？</p><h3 id="TCP-可靠性的边界">TCP 可靠性的边界</h3><p>TCP 只能保证<strong>数据被送达到客户端的网络栈</strong>，但无法保证：</p><ol><li>数据被客户端应用程序正确处理</li><li>处理过程中没有出现异常</li><li>客户端的业务逻辑正确执行</li></ol><p>想象这样一个场景：服务器向玩家推送了一条&quot;获得稀有装备&quot;的消息，TCP 确保了数据送达客户端，但如果客户端在处理这个消息时崩溃了呢？对于游戏这类状态敏感的应用，我们需要知道消息是否被<strong>成功处理</strong>，而不仅仅是<strong>成功传输</strong>。</p><h3 id="业务可靠性需求">业务可靠性需求</h3><p>实际游戏开发中，不同类型的消息有不同的可靠性需求：</p><table><thead><tr><th>消息类型</th><th>示例</th><th>可靠性需求</th></tr></thead><tbody><tr><td>关键状态变更</td><td>道具获取、货币变化</td><td>极高（必须确认处理）</td></tr><tr><td>游戏进程通知</td><td>任务更新、成就解锁</td><td>高（需要确认）</td></tr><tr><td>实时位置同步</td><td>玩家位置、NPC 移动</td><td>中（新数据可覆盖旧数据）</td></tr><tr><td>环境信息</td><td>天气变化、背景音乐</td><td>低（可接受偶尔丢失）</td></tr></tbody></table><h2 id="设计通用的-Push-ACK-机制">设计通用的 Push-ACK 机制</h2><p>一个完善的 Push-ACK 机制需要考虑以下几个方面：消息唯一标识、优先级分级、超时重试、批量确认和失败处理。下面是基于 Go 语言的设计实现：</p><h3 id="核心数据结构">核心数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Message 表示服务器推送的消息</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    MsgID        <span class="type">string</span>      <span class="string">`json:&quot;msg_id&quot;`</span>        <span class="comment">// 唯一消息标识</span></span><br><span class="line">    MsgType      <span class="type">string</span>      <span class="string">`json:&quot;msg_type&quot;`</span>      <span class="comment">// 消息类型</span></span><br><span class="line">    Timestamp    <span class="type">int64</span>       <span class="string">`json:&quot;timestamp&quot;`</span>     <span class="comment">// 发送时间戳</span></span><br><span class="line">    Priority     <span class="type">int</span>         <span class="string">`json:&quot;priority&quot;`</span>      <span class="comment">// 优先级：1-高，2-中，3-低</span></span><br><span class="line">    Payload      <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;payload&quot;`</span>       <span class="comment">// 消息内容</span></span><br><span class="line">    RequiresAck  <span class="type">bool</span>        <span class="string">`json:&quot;requires_ack&quot;`</span>  <span class="comment">// 是否需要确认</span></span><br><span class="line">    Expiration   <span class="type">int64</span>       <span class="string">`json:&quot;expiration&quot;`</span>    <span class="comment">// 过期时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AckMessage 表示客户端的确认消息</span></span><br><span class="line"><span class="keyword">type</span> AckMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">    AckID            <span class="type">string</span>  <span class="string">`json:&quot;ack_id&quot;`</span>           <span class="comment">// 对应原消息ID</span></span><br><span class="line">    Status           <span class="type">string</span>  <span class="string">`json:&quot;status&quot;`</span>           <span class="comment">// 状态：success/failed/partial</span></span><br><span class="line">    ClientTimestamp  <span class="type">int64</span>   <span class="string">`json:&quot;client_timestamp&quot;`</span> <span class="comment">// 客户端处理时间</span></span><br><span class="line">    ErrorCode        <span class="type">int</span>     <span class="string">`json:&quot;error_code&quot;`</span>       <span class="comment">// 错误码</span></span><br><span class="line">    ErrorMessage     <span class="type">string</span>  <span class="string">`json:&quot;error_message&quot;`</span>    <span class="comment">// 错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BatchAckMessage 表示批量确认消息</span></span><br><span class="line"><span class="keyword">type</span> BatchAckMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">    BatchAck        <span class="type">bool</span>     <span class="string">`json:&quot;batch_ack&quot;`</span>       <span class="comment">// 批量确认标志</span></span><br><span class="line">    AckIDs          []<span class="type">string</span> <span class="string">`json:&quot;ack_ids&quot;`</span>         <span class="comment">// 消息ID列表</span></span><br><span class="line">    Status          <span class="type">string</span>   <span class="string">`json:&quot;status&quot;`</span>          <span class="comment">// 状态</span></span><br><span class="line">    ClientTimestamp <span class="type">int64</span>    <span class="string">`json:&quot;client_timestamp&quot;`</span><span class="comment">// 确认时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PendingMessageInfo 表示等待确认的消息信息</span></span><br><span class="line"><span class="keyword">type</span> PendingMessageInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    ClientID    <span class="type">string</span>      <span class="comment">// 客户端ID</span></span><br><span class="line">    Message     *Message    <span class="comment">// 原始消息</span></span><br><span class="line">    SentTime    <span class="type">int64</span>       <span class="comment">// 发送时间</span></span><br><span class="line">    RetryCount  <span class="type">int</span>         <span class="comment">// 重试次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器端-Push-管理器实现">服务器端 Push 管理器实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PushManager 负责管理推送消息和确认</span></span><br><span class="line"><span class="keyword">type</span> PushManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    pendingMessages    <span class="keyword">map</span>[<span class="type">string</span>]*PendingMessageInfo  <span class="comment">// 等待确认的消息</span></span><br><span class="line">    clientMessageCount <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>                  <span class="comment">// 每个客户端的消息数量</span></span><br><span class="line">    ackTimeout         <span class="type">int64</span>                           <span class="comment">// 确认超时时间(秒)</span></span><br><span class="line">    maxRetries         <span class="type">int</span>                             <span class="comment">// 最大重试次数</span></span><br><span class="line">    maxPendingPerClient <span class="type">int</span>                            <span class="comment">// 每客户端最大消息数</span></span><br><span class="line">    maxMessageAge      <span class="type">int64</span>                           <span class="comment">// 消息最大生存时间(秒)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存监控相关</span></span><br><span class="line">    memoryThresholdMB  <span class="type">int64</span>                           <span class="comment">// 内存阈值(MB)</span></span><br><span class="line">    criticalThresholdMB <span class="type">int64</span>                          <span class="comment">// 危险内存阈值(MB)</span></span><br><span class="line"></span><br><span class="line">    mutex              sync.RWMutex                    <span class="comment">// 保护并发访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网络接口（依赖外部实现）</span></span><br><span class="line">    networkLayer       NetworkInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPushManager 创建一个新的推送管理器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPushManager</span><span class="params">(networkLayer NetworkInterface)</span></span> *PushManager &#123;</span><br><span class="line">    pm := &amp;PushManager&#123;</span><br><span class="line">        pendingMessages:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*PendingMessageInfo),</span><br><span class="line">        clientMessageCount:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>),</span><br><span class="line">        ackTimeout:          <span class="number">10</span>,</span><br><span class="line">        maxRetries:          <span class="number">3</span>,</span><br><span class="line">        maxPendingPerClient: <span class="number">1000</span>,</span><br><span class="line">        maxMessageAge:       <span class="number">300</span>,</span><br><span class="line">        memoryThresholdMB:   <span class="number">1000</span>,  <span class="comment">// 1GB</span></span><br><span class="line">        criticalThresholdMB: <span class="number">1500</span>,  <span class="comment">// 1.5GB</span></span><br><span class="line">        networkLayer:        networkLayer,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动后台任务</span></span><br><span class="line">    <span class="keyword">go</span> pm.checkTimeoutsLoop()</span><br><span class="line">    <span class="keyword">go</span> pm.cleanupLoop()</span><br><span class="line">    <span class="keyword">go</span> pm.memoryMonitorLoop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushMessage 向客户端推送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> PushMessage(clientID <span class="type">string</span>, message *Message) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不需要确认，直接发送</span></span><br><span class="line">    <span class="keyword">if</span> !message.RequiresAck &#123;</span><br><span class="line">        <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查客户端消息数是否超限</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &gt;= pm.maxPendingPerClient &#123;</span><br><span class="line">        pm.handleQueueOverflow(clientID, message)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储待确认消息</span></span><br><span class="line">    pm.pendingMessages[message.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">        ClientID:    clientID,</span><br><span class="line">        Message:     message,</span><br><span class="line">        SentTime:    time.Now().Unix(),</span><br><span class="line">        RetryCount:  <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新客户端消息计数</span></span><br><span class="line">    pm.clientMessageCount[clientID]++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProcessAck 处理客户端的确认消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> ProcessAck(clientID <span class="type">string</span>, ack *AckMessage) <span class="type">bool</span> &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    info, exists := pm.pendingMessages[ack.AckID]</span><br><span class="line">    <span class="keyword">if</span> !exists || info.ClientID != clientID &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认成功，删除消息</span></span><br><span class="line">    <span class="built_in">delete</span>(pm.pendingMessages, ack.AckID)</span><br><span class="line">    pm.clientMessageCount[clientID]--</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客户端没有待确认消息了，清理计数器</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProcessBatchAck 处理批量确认</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> ProcessBatchAck(clientID <span class="type">string</span>, batchAck *BatchAckMessage) <span class="type">int</span> &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    confirmedCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, ackID := <span class="keyword">range</span> batchAck.AckIDs &#123;</span><br><span class="line">        info, exists := pm.pendingMessages[ackID]</span><br><span class="line">        <span class="keyword">if</span> exists &amp;&amp; info.ClientID == clientID &#123;</span><br><span class="line">            <span class="built_in">delete</span>(pm.pendingMessages, ackID)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line">            confirmedCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客户端没有待确认消息了，清理计数器</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> confirmedCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台任务：超时检查与重试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> checkTimeoutsLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        pm.checkTimeouts()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时检查与重试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> checkTimeouts() &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    now := time.Now().Unix()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.pendingMessages &#123;</span><br><span class="line">        <span class="comment">// 检查是否超时</span></span><br><span class="line">        <span class="keyword">if</span> now - info.SentTime &gt; pm.ackTimeout &#123;</span><br><span class="line">            <span class="keyword">if</span> info.RetryCount &lt; pm.maxRetries &#123;</span><br><span class="line">                <span class="comment">// 增加重试次数</span></span><br><span class="line">                info.RetryCount++</span><br><span class="line">                info.SentTime = now</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新发送</span></span><br><span class="line">                pm.networkLayer.SendToClient(info.ClientID, info.Message)</span><br><span class="line">                log.Printf(<span class="string">&quot;Retrying message %s to client %s, attempt %d&quot;</span>,</span><br><span class="line">                          msgID, info.ClientID, info.RetryCount)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 超出最大重试次数，放弃并记录</span></span><br><span class="line">                log.Printf(<span class="string">&quot;Message %s to client %s failed after %d attempts&quot;</span>,</span><br><span class="line">                          msgID, info.ClientID, pm.maxRetries)</span><br><span class="line"></span><br><span class="line">                <span class="built_in">delete</span>(pm.pendingMessages, msgID)</span><br><span class="line">                pm.clientMessageCount[info.ClientID]--</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通知业务层处理失败</span></span><br><span class="line">                <span class="keyword">go</span> pm.notifyMessageFailed(info.ClientID, info.Message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决内存暴涨问题">解决内存暴涨问题</h2><p>在大型游戏中，服务器可能同时维护数十万甚至上百万个连接，如果每个连接都有数百条待确认消息，服务器内存很快就会爆满。以下是我在实践中总结的几种高效内存管理策略：</p><h3 id="1-周期性过期消息清理">1. 周期性过期消息清理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清理过期消息的后台循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> cleanupLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Minute)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        pm.cleanExpiredMessages()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理过期消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> cleanExpiredMessages() &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    now := time.Now().Unix()</span><br><span class="line">    expiredCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.pendingMessages &#123;</span><br><span class="line">        <span class="comment">// 检查消息是否过期</span></span><br><span class="line">        <span class="keyword">if</span> now - info.SentTime &gt; pm.maxMessageAge &#123;</span><br><span class="line">            <span class="built_in">delete</span>(pm.pendingMessages, msgID)</span><br><span class="line">            pm.clientMessageCount[info.ClientID]--</span><br><span class="line">            expiredCount++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">            log.Printf(<span class="string">&quot;Cleaned expired message %s to client %s (age: %d seconds)&quot;</span>,</span><br><span class="line">                      msgID, info.ClientID, now - info.SentTime)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> expiredCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Cleanup: Removed %d expired messages&quot;</span>, expiredCount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-消息压缩与合并">2. 消息压缩与合并</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompressMessage 压缩消息以减少内存占用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompressMessage</span><span class="params">(message *Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="comment">// 将消息转为JSON</span></span><br><span class="line">    jsonData, err := json.Marshal(message)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error marshaling message: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用gzip压缩</span></span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    writer := gzip.NewWriter(&amp;buf)</span><br><span class="line"></span><br><span class="line">    _, err = writer.Write(jsonData)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error compressing message: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := writer.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error closing gzip writer: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DecompressMessage 解压缩消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecompressMessage</span><span class="params">(compressed []<span class="type">byte</span>)</span></span> (*Message, <span class="type">error</span>) &#123;</span><br><span class="line">    reader, err := gzip.NewReader(bytes.NewReader(compressed))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;create gzip reader: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> reader.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> _, err := io.Copy(&amp;buf, reader); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;decompress data: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> message Message</span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(buf.Bytes(), &amp;message); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unmarshal json: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;message, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-分级存储策略">3. 分级存储策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PushManager 增加分级存储功能</span></span><br><span class="line"><span class="keyword">type</span> PushManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ... 之前的字段 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存中存储高优先级消息</span></span><br><span class="line">    memoryPending     <span class="keyword">map</span>[<span class="type">string</span>]*PendingMessageInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis客户端，用于存储低优先级消息</span></span><br><span class="line">    redisClient      *redis.Client</span><br><span class="line">    redisKeyPrefix   <span class="type">string</span></span><br><span class="line">    redisExpiry      time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PushMessage 分级存储版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> PushMessage(clientID <span class="type">string</span>, message *Message) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不需要确认，直接发送</span></span><br><span class="line">    <span class="keyword">if</span> !message.RequiresAck &#123;</span><br><span class="line">        <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查客户端消息数量限制</span></span><br><span class="line">    <span class="keyword">if</span> pm.clientMessageCount[clientID] &gt;= pm.maxPendingPerClient &#123;</span><br><span class="line">        pm.handleQueueOverflow(clientID, message)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pm.clientMessageCount[clientID]++</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据优先级选择存储位置</span></span><br><span class="line">    <span class="keyword">if</span> message.Priority &lt;= <span class="number">2</span> &#123; <span class="comment">// 高优先级和中优先级</span></span><br><span class="line">        <span class="comment">// 存入内存</span></span><br><span class="line">        pm.memoryPending[message.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">            ClientID:    clientID,</span><br><span class="line">            Message:     message,</span><br><span class="line">            SentTime:    time.Now().Unix(),</span><br><span class="line">            RetryCount:  <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 低优先级</span></span><br><span class="line">        <span class="comment">// 存入Redis</span></span><br><span class="line">        messageInfo := &amp;PendingMessageInfo&#123;</span><br><span class="line">            ClientID:    clientID,</span><br><span class="line">            Message:     message,</span><br><span class="line">            SentTime:    time.Now().Unix(),</span><br><span class="line">            RetryCount:  <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jsonData, err := json.Marshal(messageInfo)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error marshaling message: %v&quot;</span>, err)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        redisKey := pm.redisKeyPrefix + message.MsgID</span><br><span class="line">        err = pm.redisClient.Set(context.Background(), redisKey, jsonData, pm.redisExpiry).Err()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error storing message in Redis: %v&quot;</span>, err)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">return</span> pm.networkLayer.SendToClient(clientID, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProcessAck 分级存储版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> ProcessAck(clientID <span class="type">string</span>, ack *AckMessage) <span class="type">bool</span> &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查内存中的消息</span></span><br><span class="line">    info, existsInMemory := pm.memoryPending[ack.AckID]</span><br><span class="line">    <span class="keyword">if</span> existsInMemory &amp;&amp; info.ClientID == clientID &#123;</span><br><span class="line">        <span class="built_in">delete</span>(pm.memoryPending, ack.AckID)</span><br><span class="line">        pm.clientMessageCount[clientID]--</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再检查Redis中的消息</span></span><br><span class="line">    redisKey := pm.redisKeyPrefix + ack.AckID</span><br><span class="line">    exists, err := pm.redisClient.Exists(context.Background(), redisKey).Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error checking message in Redis: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> exists == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 获取消息以验证客户端ID</span></span><br><span class="line">        jsonData, err := pm.redisClient.Get(context.Background(), redisKey).Bytes()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error getting message from Redis: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> messageInfo PendingMessageInfo</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(jsonData, &amp;messageInfo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Error unmarshaling message from Redis: %v&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> messageInfo.ClientID == clientID &#123;</span><br><span class="line">            <span class="comment">// 从Redis删除并更新计数</span></span><br><span class="line">            pm.redisClient.Del(context.Background(), redisKey)</span><br><span class="line">            pm.clientMessageCount[clientID]--</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> pm.clientMessageCount[clientID] &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">delete</span>(pm.clientMessageCount, clientID)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-内存自适应调整">4. 内存自适应调整</h3><p>内存自适应调整是我在实际项目中解决突发流量问题的关键策略。它能够根据当前系统负载动态调整消息处理参数，确保系统稳定性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存监控循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> memoryMonitorLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">10</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        memoryMB := pm.getMemoryUsageMB()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> memoryMB &gt; pm.criticalThresholdMB &#123;</span><br><span class="line">            <span class="comment">// 紧急情况，进行应急清理</span></span><br><span class="line">            pm.emergencyCleanup(memoryMB)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> memoryMB &gt; pm.memoryThresholdMB &#123;</span><br><span class="line">            <span class="comment">// 超过警戒线，调整参数</span></span><br><span class="line">            pm.adjustParameters(memoryMB)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前进程内存使用量（MB）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> getMemoryUsageMB() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> memStats runtime.MemStats</span><br><span class="line">    runtime.ReadMemStats(&amp;memStats)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(memStats.Alloc / <span class="number">1024</span> / <span class="number">1024</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据内存使用情况调整参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> adjustParameters(currentMemoryMB <span class="type">int64</span>) &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算内存超出比例</span></span><br><span class="line">    excessRatio := <span class="type">float64</span>(currentMemoryMB - pm.memoryThresholdMB) / <span class="type">float64</span>(pm.memoryThresholdMB)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整每客户端最大消息数</span></span><br><span class="line">    newMaxPerClient := <span class="type">int</span>(<span class="type">float64</span>(pm.maxPendingPerClient) * (<span class="number">1</span> - excessRatio*<span class="number">0.5</span>))</span><br><span class="line">    <span class="keyword">if</span> newMaxPerClient &lt; <span class="number">100</span> &#123;</span><br><span class="line">        newMaxPerClient = <span class="number">100</span> <span class="comment">// 确保至少保留100条</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整消息最大生存时间</span></span><br><span class="line">    newMaxAge := <span class="type">int64</span>(<span class="type">float64</span>(pm.maxMessageAge) * (<span class="number">1</span> - excessRatio*<span class="number">0.5</span>))</span><br><span class="line">    <span class="keyword">if</span> newMaxAge &lt; <span class="number">60</span> &#123;</span><br><span class="line">        newMaxAge = <span class="number">60</span> <span class="comment">// 至少60秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新参数</span></span><br><span class="line">    pm.maxPendingPerClient = newMaxPerClient</span><br><span class="line">    pm.maxMessageAge = newMaxAge</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;Memory usage: %d MB, adjusted parameters: maxPending=%d, maxAge=%ds&quot;</span>,</span><br><span class="line">               currentMemoryMB, pm.maxPendingPerClient, pm.maxMessageAge)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一次清理</span></span><br><span class="line">    pm.cleanExpiredMessages()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧急清理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> emergencyCleanup(currentMemoryMB <span class="type">int64</span>) &#123;</span><br><span class="line">    pm.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> pm.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;CRITICAL: Memory usage at %d MB, performing emergency cleanup&quot;</span>, currentMemoryMB)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大幅降低参数</span></span><br><span class="line">    pm.maxPendingPerClient = <span class="number">100</span></span><br><span class="line">    pm.maxMessageAge = <span class="number">60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理低优先级消息</span></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.memoryPending &#123;</span><br><span class="line">        <span class="keyword">if</span> info.Message.Priority &gt; <span class="number">1</span> &#123; <span class="comment">// 只保留最高优先级</span></span><br><span class="line">            <span class="built_in">delete</span>(pm.memoryPending, msgID)</span><br><span class="line">            pm.clientMessageCount[info.ClientID]--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;Emergency cleanup completed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-队列溢出处理策略">5. 队列溢出处理策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理队列溢出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> handleQueueOverflow(clientID <span class="type">string</span>, newMessage *Message) &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Queue overflow for client %s&quot;</span>, clientID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略1: 根据消息优先级决定是否替换现有消息</span></span><br><span class="line">    <span class="keyword">if</span> newMessage.Priority == <span class="number">1</span> &#123; <span class="comment">// 高优先级消息</span></span><br><span class="line">        <span class="comment">// 查找并替换该客户端的一条低优先级消息</span></span><br><span class="line">        <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.memoryPending &#123;</span><br><span class="line">            <span class="keyword">if</span> info.ClientID == clientID &amp;&amp; info.Message.Priority &gt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// 记录</span></span><br><span class="line">                log.Printf(<span class="string">&quot;Replacing low priority message %s with high priority message&quot;</span>, msgID)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 删除旧消息</span></span><br><span class="line">                <span class="built_in">delete</span>(pm.memoryPending, msgID)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加新消息</span></span><br><span class="line">                pm.memoryPending[newMessage.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">                    ClientID:    clientID,</span><br><span class="line">                    Message:     newMessage,</span><br><span class="line">                    SentTime:    time.Now().Unix(),</span><br><span class="line">                    RetryCount:  <span class="number">0</span>,</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送新消息</span></span><br><span class="line">                pm.networkLayer.SendToClient(clientID, newMessage)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略2: 丢弃旧消息以腾出空间</span></span><br><span class="line">    <span class="comment">// 查找该客户端最旧的消息</span></span><br><span class="line">    <span class="keyword">var</span> oldestMsgID <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> oldestTime <span class="type">int64</span> = math.MaxInt64</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, info := <span class="keyword">range</span> pm.memoryPending &#123;</span><br><span class="line">        <span class="keyword">if</span> info.ClientID == clientID &amp;&amp; info.SentTime &lt; oldestTime &#123;</span><br><span class="line">            oldestMsgID = msgID</span><br><span class="line">            oldestTime = info.SentTime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldestMsgID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Dropping oldest message %s for client %s&quot;</span>, oldestMsgID, clientID)</span><br><span class="line">        <span class="built_in">delete</span>(pm.memoryPending, oldestMsgID)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加新消息</span></span><br><span class="line">        pm.memoryPending[newMessage.MsgID] = &amp;PendingMessageInfo&#123;</span><br><span class="line">            ClientID:    clientID,</span><br><span class="line">            Message:     newMessage,</span><br><span class="line">            SentTime:    time.Now().Unix(),</span><br><span class="line">            RetryCount:  <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送新消息</span></span><br><span class="line">        pm.networkLayer.SendToClient(clientID, newMessage)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 极端情况，无法找到可替换的消息</span></span><br><span class="line">        log.Printf(<span class="string">&quot;Cannot find message to replace for client %s&quot;</span>, clientID)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端实现">客户端实现</h2><p>客户端实现同样关键，特别是批量确认机制能显著减少网络流量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PushReceiver 客户端推送接收处理器</span></span><br><span class="line"><span class="keyword">type</span> PushReceiver <span class="keyword">struct</span> &#123;</span><br><span class="line">    connection        Connection          <span class="comment">// 网络连接接口</span></span><br><span class="line">    processedMsgIDs   <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>    <span class="comment">// 已处理消息ID及处理时间</span></span><br><span class="line">    pendingAcks       []<span class="type">string</span>            <span class="comment">// 待确认的消息ID</span></span><br><span class="line">    ackBatchSize      <span class="type">int</span>                 <span class="comment">// 批量确认大小</span></span><br><span class="line">    ackInterval       time.Duration       <span class="comment">// 批量确认间隔</span></span><br><span class="line">    messageHandlers   <span class="keyword">map</span>[<span class="type">string</span>]MessageHandler <span class="comment">// 消息处理函数</span></span><br><span class="line"></span><br><span class="line">    mutex             sync.Mutex          <span class="comment">// 保护并发访问</span></span><br><span class="line">    stopChan          <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;       <span class="comment">// 停止信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageHandler 消息处理函数类型</span></span><br><span class="line"><span class="keyword">type</span> MessageHandler <span class="function"><span class="keyword">func</span><span class="params">(payload <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPushReceiver 创建推送接收器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPushReceiver</span><span class="params">(conn Connection)</span></span> *PushReceiver &#123;</span><br><span class="line">    receiver := &amp;PushReceiver&#123;</span><br><span class="line">        connection:       conn,</span><br><span class="line">        processedMsgIDs:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int64</span>),</span><br><span class="line">        pendingAcks:      <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">100</span>),</span><br><span class="line">        ackBatchSize:     <span class="number">50</span>,</span><br><span class="line">        ackInterval:      time.Second,</span><br><span class="line">        messageHandlers:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]MessageHandler),</span><br><span class="line">        stopChan:         <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动批量确认任务</span></span><br><span class="line">    <span class="keyword">go</span> receiver.ackLoop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动过期消息ID清理任务</span></span><br><span class="line">    <span class="keyword">go</span> receiver.cleanupLoop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterHandler 注册消息处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> RegisterHandler(msgType <span class="type">string</span>, handler MessageHandler) &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    r.messageHandlers[msgType] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleMessage 处理收到的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> HandleMessage(message *Message) &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    msgID := message.MsgID</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已处理过该消息</span></span><br><span class="line">    <span class="keyword">if</span> _, exists := r.processedMsgIDs[msgID]; exists &#123;</span><br><span class="line">        <span class="comment">// 已处理过，再次发送确认</span></span><br><span class="line">        <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">            r.pendingAcks = <span class="built_in">append</span>(r.pendingAcks, msgID)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果积累的确认数量超过批量大小，立即发送</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(r.pendingAcks) &gt;= r.ackBatchSize &#123;</span><br><span class="line">                <span class="keyword">go</span> r.sendBatchAcks()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找处理函数</span></span><br><span class="line">    handler, exists := r.messageHandlers[message.MsgType]</span><br><span class="line">    <span class="keyword">if</span> !exists &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;No handler for message type: %s&quot;</span>, message.MsgType)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未知消息类型也需要确认</span></span><br><span class="line">        <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">            r.sendErrorAck(msgID, <span class="string">&quot;Unknown message type&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    err := handler(message.Payload)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;Error processing message %s: %v&quot;</span>, msgID, err)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">            r.sendErrorAck(msgID, err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录已处理的消息</span></span><br><span class="line">    r.processedMsgIDs[msgID] = time.Now().Unix()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要确认，加入待确认队列</span></span><br><span class="line">    <span class="keyword">if</span> message.RequiresAck &#123;</span><br><span class="line">        r.pendingAcks = <span class="built_in">append</span>(r.pendingAcks, msgID)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果积累的确认数量超过批量大小，立即发送</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(r.pendingAcks) &gt;= r.ackBatchSize &#123;</span><br><span class="line">            <span class="keyword">go</span> r.sendBatchAcks()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送批量确认</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> sendBatchAcks() &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有待确认消息，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(r.pendingAcks) == <span class="number">0</span> &#123;</span><br><span class="line">        r.mutex.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制当前的待确认ID列表</span></span><br><span class="line">    ackIDs := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(r.pendingAcks))</span><br><span class="line">    <span class="built_in">copy</span>(ackIDs, r.pendingAcks)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空待确认列表</span></span><br><span class="line">    r.pendingAcks = r.pendingAcks[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建批量确认消息</span></span><br><span class="line">    batchAck := &amp;BatchAckMessage&#123;</span><br><span class="line">        BatchAck:        <span class="literal">true</span>,</span><br><span class="line">        AckIDs:          ackIDs,</span><br><span class="line">        Status:          <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        ClientTimestamp: time.Now().Unix(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送确认</span></span><br><span class="line">    r.connection.Send(batchAck)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送错误确认</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> sendErrorAck(msgID <span class="type">string</span>, errorMessage <span class="type">string</span>) &#123;</span><br><span class="line">    ack := &amp;AckMessage&#123;</span><br><span class="line">        AckID:           msgID,</span><br><span class="line">        Status:          <span class="string">&quot;failed&quot;</span>,</span><br><span class="line">        ClientTimestamp: time.Now().Unix(),</span><br><span class="line">        ErrorCode:       <span class="number">1001</span>,</span><br><span class="line">        ErrorMessage:    errorMessage,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.connection.Send(ack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量确认定时器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> ackLoop() &#123;</span><br><span class="line">    ticker := time.NewTicker(r.ackInterval)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            r.sendBatchAcks()</span><br><span class="line">        <span class="keyword">case</span> &lt;-r.stopChan:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理过期的已处理消息ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> cleanupLoop() &#123;</span><br><span class="line">    <span class="comment">// 每小时清理一次</span></span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Hour)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            r.cleanupProcessedIDs()</span><br><span class="line">        <span class="keyword">case</span> &lt;-r.stopChan:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理过期的已处理消息ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> cleanupProcessedIDs() &#123;</span><br><span class="line">    r.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    now := time.Now().Unix()</span><br><span class="line">    expireTime := <span class="type">int64</span>(<span class="number">86400</span>) <span class="comment">// 24小时过期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> msgID, processTime := <span class="keyword">range</span> r.processedMsgIDs &#123;</span><br><span class="line">        <span class="keyword">if</span> now - processTime &gt; expireTime &#123;</span><br><span class="line">            <span class="built_in">delete</span>(r.processedMsgIDs, msgID)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭推送接收器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *PushReceiver)</span></span> Close() &#123;</span><br><span class="line">    <span class="comment">// 发送所有待确认消息</span></span><br><span class="line">    r.sendBatchAcks()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止所有后台任务</span></span><br><span class="line">    <span class="built_in">close</span>(r.stopChan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战经验与最佳实践">实战经验与最佳实践</h2><p>在多个千万用户级别的游戏项目实践中，我总结了以下几点 Push-ACK 机制的最佳实践：</p><h3 id="1-消息分级是关键">1. 消息分级是关键</h3><p>不是所有消息都需要相同级别的可靠性保证。在一个 MMORPG 项目中，我们将消息分为四级：</p><ul><li><strong>关键级</strong>：直接影响游戏平衡和经济的消息，如道具获取、货币变化</li><li><strong>重要级</strong>：影响游戏进程的消息，如任务更新、排行榜变动</li><li><strong>普通级</strong>：一般游戏状态信息，如其他玩家动作、环境变化</li><li><strong>低优先级</strong>：可以容忍丢失的背景信息，如聊天、天气效果</li></ul><p>高级别消息使用完整的 ACK 机制，低级别消息可以简化甚至取消 ACK 需求，这样大大减轻了服务器内存压力。</p><h3 id="2-利用统计指标进行调优">2. 利用统计指标进行调优</h3><p>监控以下关键指标：</p><ul><li>ACK 响应时间分布</li><li>消息重试率</li><li>每客户端平均待确认消息数</li><li>内存使用增长曲线</li></ul><p>在一个足球经理类游戏中，通过这些指标我们发现，将 ACK 超时时间从 10 秒调整到 5 秒，并将最大重试次数从 3 次增加到 5 次，可以将消息最终确认率从 99.2%提高到 99.8%，同时减少了 25%的内存使用。</p><h3 id="3-针对不同网络环境优化">3. 针对不同网络环境优化</h3><p>移动网络环境差异很大，针对不同网络条件动态调整策略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据网络条件调整参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PushManager)</span></span> adjustForNetworkCondition(clientID <span class="type">string</span>, rtt time.Duration) &#123;</span><br><span class="line">    <span class="comment">// 网络条件良好</span></span><br><span class="line">    <span class="keyword">if</span> rtt &lt; <span class="number">100</span>*time.Millisecond &#123;</span><br><span class="line">        pm.clientTimeouts[clientID] = <span class="number">3</span> <span class="comment">// 3秒超时</span></span><br><span class="line">        pm.clientRetries[clientID] = <span class="number">2</span>  <span class="comment">// 2次重试</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> rtt &lt; <span class="number">300</span>*time.Millisecond &#123;</span><br><span class="line">        pm.clientTimeouts[clientID] = <span class="number">5</span> <span class="comment">// 5秒超时</span></span><br><span class="line">        pm.clientRetries[clientID] = <span class="number">3</span>  <span class="comment">// 3次重试</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pm.clientTimeouts[clientID] = <span class="number">10</span> <span class="comment">// 10秒超时</span></span><br><span class="line">        pm.clientRetries[clientID] = <span class="number">5</span>   <span class="comment">// 5次重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-定期压力测试">4. 定期压力测试</h3><p>在一个大型开放世界游戏中，我们每月进行一次&quot;混沌测试&quot;，模拟极端情况：</p><ol><li>突发 50%客户端同时掉线然后重连</li><li>模拟网络延迟突然从 50ms 增加到 500ms</li><li>模拟 10%的确认消息丢失</li></ol><p>这种测试让我们发现了很多边缘情况，并建立了更健壮的防御机制。</p><h2 id="结论">结论</h2><p>一个设计良好的 Push-ACK 机制是现代游戏服务器架构的核心组件。它确保了游戏状态的一致性，提升了玩家体验，同时也为运营团队提供了可靠的数据基础。最重要的是，它必须是高性能且资源友好的。</p><p>通过采用本文介绍的多级存储、自适应参数调整、消息优先级和过期策略等技术，我们可以构建一个既可靠又高效的推送确认系统，即使在面对数十万并发</p>]]></content>
    
    
    <summary type="html">本文介绍了游戏后端中的 Push-ACK 机制的设计与实现，特别关注如何避免内存暴涨问题，分享了在多个大型游戏项目中积累的经验与教训。</summary>
    
    
    
    <category term="解决方案" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="游戏后端" scheme="https://hedon.top/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%B8%B8%E6%88%8F%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="解决方案" scheme="https://hedon.top/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="游戏后端" scheme="https://hedon.top/tags/%E6%B8%B8%E6%88%8F%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Push-Ack" scheme="https://hedon.top/tags/Push-Ack/"/>
    
  </entry>
  
  <entry>
    <title>服务监控丨Prometheus 四大数据类型详解</title>
    <link href="https://hedon.top/2025/02/26/prometheus-data-type/"/>
    <id>https://hedon.top/2025/02/26/prometheus-data-type/</id>
    <published>2025-02-26T07:52:10.000Z</published>
    <updated>2025-04-05T14:31:32.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在微服务和云原生架构的世界中，一套强大的监控系统是保障服务稳定性的基石。Prometheus 作为 CNCF 的明星项目，凭借其简单高效的特性，已成为事实上的云原生监控标准。本文将深入剖析 Prometheus 的四大数据类型及其 PromQL 查询语言，帮助开发团队构建强大的可观测性系统。</p><h2 id="结论先行：Prometheus-四大数据类型速览">结论先行：Prometheus 四大数据类型速览</h2><table><thead><tr><th>特性</th><th>Counter</th><th>Gauge</th><th>Histogram</th><th>Summary</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>只增不减的累积计数器</td><td>可增可减的瞬时值</td><td>观测值分布的分桶统计</td><td>客户端计算的分位数统计</td></tr><tr><td><strong>重置行为</strong></td><td>服务重启时归零</td><td>保持当前值</td><td>桶计数归零</td><td>计数归零</td></tr><tr><td><strong>典型应用</strong></td><td>请求计数、错误数、流量统计</td><td>温度、内存使用、连接数</td><td>请求延迟、响应大小</td><td>请求延迟、队列等待时间</td></tr><tr><td><strong>数据点</strong></td><td>单一值</td><td>单一值</td><td>_bucket、_sum、count</td><td>{quantile=“x”}、_sum、_count</td></tr><tr><td><strong>查询重点</strong></td><td>rate()、increase()</td><td>直接使用、预测函数</td><td>histogram_quantile()</td><td>直接读取分位数</td></tr><tr><td><strong>分布式聚合</strong></td><td>可以（sum、rate）</td><td>可以（avg、max、min）</td><td>可以（百分位也可聚合）</td><td>有限（分位数不可聚合）</td></tr><tr><td><strong>资源消耗</strong></td><td>低</td><td>低</td><td>中（依赖桶数量）</td><td>中（客户端计算）</td></tr></tbody></table><h2 id="一、Prometheus-核心数据类型详解">一、Prometheus 核心数据类型详解</h2><h3 id="1-Counter（计数器）：持续增长的累积值">1. Counter（计数器）：持续增长的累积值</h3><p>Counter 是最简单但也最常用的指标类型，代表一个只增不减的累积数值。每当事件发生，计数器增加；当监控目标重启时，计数器归零。</p><p><strong>适用场景</strong>：</p><ul><li>API 请求总数</li><li>错误发生次数</li><li>处理任务的数量</li><li>网络流量字节数</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的计数器</span></span><br><span class="line">requestCounter := prometheus.NewCounterVec(</span><br><span class="line">    prometheus.CounterOpts&#123;</span><br><span class="line">        Name: <span class="string">&quot;http_requests_total&quot;</span>,</span><br><span class="line">        Help: <span class="string">&quot;Total number of HTTP requests&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;method&quot;</span>, <span class="string">&quot;path&quot;</span>, <span class="string">&quot;status&quot;</span>&#125;, <span class="comment">// 定义标签维度</span></span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(requestCounter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用标签记录请求</span></span><br><span class="line">requestCounter.WithLabelValues(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>, <span class="string">&quot;200&quot;</span>).Inc()</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 每秒请求率（5分钟窗口）</span><br><span class="line">rate(http_requests_total&#123;status=&quot;200&quot;&#125;[5m])</span><br><span class="line"></span><br><span class="line"># 错误率计算</span><br><span class="line">sum(rate(http_requests_total&#123;status=~&quot;5..&quot;&#125;[5m])) / sum(rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># 1小时内的请求增量</span><br><span class="line">increase(http_requests_total[1h])</span><br></pre></td></tr></table></figure><p><strong>最佳实践</strong>：</p><ul><li>永远不要直接使用 Counter 的原始值，总是使用 <code>rate()</code> 或 <code>increase()</code></li><li>使用有意义的标签进行多维度分析，但避免高基数标签</li><li>Counter 重置（如服务重启）会被 <code>rate()</code> 函数自动处理</li></ul><h3 id="2-Gauge（仪表盘）：可变的瞬时值">2. Gauge（仪表盘）：可变的瞬时值</h3><p>Gauge 表示一个可增可减的瞬时测量值，反映系统的当前状态。</p><p><strong>适用场景</strong>：</p><ul><li>内存使用量</li><li>CPU 使用率</li><li>当前活跃连接数</li><li>队列深度</li><li>温度等物理量</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的仪表盘</span></span><br><span class="line">memoryGauge := prometheus.NewGaugeVec(</span><br><span class="line">    prometheus.GaugeOpts&#123;</span><br><span class="line">        Name: <span class="string">&quot;app_memory_usage_bytes&quot;</span>,</span><br><span class="line">        Help: <span class="string">&quot;Current memory usage in bytes&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;component&quot;</span>, <span class="string">&quot;instance&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(memoryGauge)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前值</span></span><br><span class="line">memoryGauge.WithLabelValues(<span class="string">&quot;api-server&quot;</span>, <span class="string">&quot;instance-1&quot;</span>).Set(<span class="type">float64</span>(getCurrentMemoryUsage()))</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 直接使用当前值</span><br><span class="line">app_memory_usage_bytes&#123;component=&quot;api-server&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 统计聚合</span><br><span class="line">avg_over_time(app_memory_usage_bytes[1h])</span><br><span class="line">max_over_time(app_memory_usage_bytes[24h])</span><br><span class="line"></span><br><span class="line"># 趋势预测（线性回归）</span><br><span class="line">predict_linear(app_memory_usage_bytes[6h], 4 * 3600)</span><br><span class="line"></span><br><span class="line"># 计算变化率</span><br><span class="line">(app_memory_usage_bytes - app_memory_usage_bytes offset 1h) / app_memory_usage_bytes offset 1h</span><br></pre></td></tr></table></figure><p><strong>最佳实践</strong>：</p><ul><li>Gauge 可以直接使用其瞬时值，不需要像 Counter 那样使用 rate</li><li>对于容易波动的指标，考虑使用 <code>avg_over_time</code> 平滑数据</li><li>利用 <code>predict_linear</code> 进行容量规划和趋势预测</li></ul><h3 id="3-Histogram（直方图）：观测值分布的分桶统计">3. Histogram（直方图）：观测值分布的分桶统计</h3><p>Histogram 允许对观测值（如请求延迟）进行分布式统计，将数据分散到预定义的桶中，是分析性能分布的理想工具。</p><p><strong>自动生成的指标</strong>：</p><ul><li><code>&lt;metric&gt;_bucket&#123;le=&quot;&lt;upper bound&gt;&quot;&#125;</code>: 小于等于特定阈值的观测值计数</li><li><code>&lt;metric&gt;_sum</code>: 所有观测值的总和</li><li><code>&lt;metric&gt;_count</code>: 观测值总数</li></ul><p><strong>适用场景</strong>：</p><ul><li>请求延迟分布</li><li>响应大小分布</li><li>批处理任务执行时间</li><li>任何需要百分位数分析的场景</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的直方图</span></span><br><span class="line">durationHistogram := prometheus.NewHistogramVec(</span><br><span class="line">    prometheus.HistogramOpts&#123;</span><br><span class="line">        Name:    <span class="string">&quot;http_request_duration_seconds&quot;</span>,</span><br><span class="line">        Help:    <span class="string">&quot;HTTP request duration in seconds&quot;</span>,</span><br><span class="line">        Buckets: prometheus.ExponentialBuckets(<span class="number">0.001</span>, <span class="number">2</span>, <span class="number">10</span>), <span class="comment">// 从1ms开始指数增长</span></span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;method&quot;</span>, <span class="string">&quot;path&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(durationHistogram)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录请求延迟</span></span><br><span class="line">durationHistogram.WithLabelValues(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>).Observe(responseTime)</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 计算平均响应时间</span><br><span class="line">rate(http_request_duration_seconds_sum[5m]) / rate(http_request_duration_seconds_count[5m])</span><br><span class="line"></span><br><span class="line"># 计算P90延迟</span><br><span class="line">histogram_quantile(0.9, rate(http_request_duration_seconds_bucket[5m]))</span><br><span class="line"></span><br><span class="line"># 按API路径分析P95延迟</span><br><span class="line">histogram_quantile(0.95, sum by(path, le) (rate(http_request_duration_seconds_bucket[5m])))</span><br><span class="line"></span><br><span class="line"># 计算SLO：延迟小于100ms的请求比例</span><br><span class="line">sum(rate(http_request_duration_seconds_bucket&#123;le=&quot;0.1&quot;&#125;[5m])) / sum(rate(http_request_duration_seconds_count[5m]))</span><br></pre></td></tr></table></figure><p><strong>最佳实践</strong>：</p><ul><li>仔细设计桶边界，覆盖关键分位数区域</li><li>对于延迟指标，通常使用指数桶比线性桶更合理</li><li>利用 <code>histogram_quantile</code> 计算任意分位数</li><li>桶的数量会影响存储和性能，权衡精度和开销</li></ul><h3 id="4-Summary（摘要）：客户端计算的分位数统计">4. Summary（摘要）：客户端计算的分位数统计</h3><p>Summary 与 Histogram 类似，但在客户端直接计算并存储分位数，无需服务器端计算。</p><p><strong>自动生成的指标</strong>：</p><ul><li><code>&lt;metric&gt;&#123;quantile=&quot;&lt;φ&gt;&quot;&#125;</code>: φ 分位数的值</li><li><code>&lt;metric&gt;_sum</code>: 所有观测值的总和</li><li><code>&lt;metric&gt;_count</code>: 观测值总数</li></ul><p><strong>适用场景</strong>：</p><ul><li>需要高精度分位数的场景</li><li>客户端计算分位数更高效的情况</li><li>对服务器端聚合要求不高的场景</li></ul><p><strong>正确的代码实现</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明带标签的摘要</span></span><br><span class="line">durationSummary := prometheus.NewSummaryVec(</span><br><span class="line">    prometheus.SummaryOpts&#123;</span><br><span class="line">        Name:       <span class="string">&quot;http_request_duration_seconds_summary&quot;</span>,</span><br><span class="line">        Help:       <span class="string">&quot;HTTP request duration in seconds&quot;</span>,</span><br><span class="line">        Objectives: <span class="keyword">map</span>[<span class="type">float64</span>]<span class="type">float64</span>&#123;<span class="number">0.5</span>: <span class="number">0.05</span>, <span class="number">0.9</span>: <span class="number">0.01</span>, <span class="number">0.99</span>: <span class="number">0.001</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;method&quot;</span>, <span class="string">&quot;path&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">prometheus.MustRegister(durationSummary)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录请求延迟</span></span><br><span class="line">durationSummary.WithLabelValues(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/api/login&quot;</span>).Observe(responseTime)</span><br></pre></td></tr></table></figure><p><strong>PromQL 查询技巧</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 直接读取P99延迟</span><br><span class="line">http_request_duration_seconds_summary&#123;quantile=&quot;0.99&quot;, method=&quot;GET&quot;, path=&quot;/api/users&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 计算平均响应时间</span><br><span class="line">rate(http_request_duration_seconds_summary_sum[5m]) / rate(http_request_duration_seconds_summary_count[5m])</span><br><span class="line"></span><br><span class="line"># 每个服务的中位数延迟</span><br><span class="line">max by(service) (http_request_duration_seconds_summary&#123;quantile=&quot;0.5&quot;&#125;)</span><br></pre></td></tr></table></figure><p><strong>最佳实践与限制</strong>：</p><ul><li>Summary 预计算的分位数不能跨实例聚合（这是关键限制）</li><li>适用于分位数精度要求高且实例相对独立的场景</li><li>客户端计算分位数会增加应用资源消耗</li><li>分位数设置后不可更改，需提前规划好监控需求</li></ul><h2 id="二、PromQL-查询语言精通">二、PromQL 查询语言精通</h2><p>PromQL 是 Prometheus 的强大武器，掌握它能让我们精确提取所需的监控数据。</p><h3 id="1-基础查询与标签选择">1. 基础查询与标签选择</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 基本查询与精确匹配</span><br><span class="line">http_requests_total&#123;status=&quot;200&quot;, method=&quot;GET&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 正则表达式匹配</span><br><span class="line">http_requests_total&#123;path=~&quot;/api/v1/.+&quot;, method!=&quot;OPTIONS&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 范围查询（返回时间序列）</span><br><span class="line">http_requests_total&#123;status=&quot;500&quot;&#125;[5m]</span><br></pre></td></tr></table></figure><h3 id="2-操作符与函数">2. 操作符与函数</h3><p><strong>算术运算符</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 计算内存使用率百分比</span><br><span class="line">100 * (node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes</span><br></pre></td></tr></table></figure><p><strong>聚合函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 按服务和路径分组求和</span><br><span class="line">sum by(service, path) (rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># 丢弃instance标签求最大值</span><br><span class="line">max without(instance) (node_cpu_seconds_total)</span><br></pre></td></tr></table></figure><p><strong>瞬时向量函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 标签替换</span><br><span class="line">label_replace(up, &quot;host&quot;, &quot;$1&quot;, &quot;instance&quot;, &quot;(.*):.*&quot;)</span><br><span class="line"></span><br><span class="line"># 按标签分组取topk</span><br><span class="line">topk by(path) (5, http_request_duration_seconds_sum / http_request_duration_seconds_count)</span><br></pre></td></tr></table></figure><h3 id="3-复杂查询模式">3. 复杂查询模式</h3><p><strong>SLI/SLO 监控</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 服务可用性SLI</span><br><span class="line">sum(rate(http_requests_total&#123;status=~&quot;2..|3..&quot;&#125;[5m])) / sum(rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># 延迟SLO</span><br><span class="line">histogram_quantile(0.99, sum by(le) (rate(http_request_duration_seconds_bucket[5m]))) &lt; 0.3</span><br></pre></td></tr></table></figure><p><strong>异常检测</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 相对于历史同期的异常增长</span><br><span class="line">rate(http_requests_total[5m])</span><br><span class="line">  &gt; 2 * avg_over_time(rate(http_requests_total[5m])[1d:5m] offset 1d)</span><br></pre></td></tr></table></figure><p><strong>预测分析</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 磁盘空间预测</span><br><span class="line">predict_linear(node_filesystem_free_bytes&#123;mountpoint=&quot;/&quot;&#125;[6h], 7 * 24 * 3600) &lt; 10 * 1024 * 1024 * 1024</span><br></pre></td></tr></table></figure><h2 id="三、实战应用场景">三、实战应用场景</h2><h3 id="1-服务健康度监控">1. 服务健康度监控</h3><p><strong>RED 方法实现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Rate - 请求率</span><br><span class="line">sum by(service) (rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># Error - 错误率</span><br><span class="line">sum by(service) (rate(http_requests_total&#123;status=~&quot;5..&quot;&#125;[5m])) / sum by(service) (rate(http_requests_total[5m]))</span><br><span class="line"></span><br><span class="line"># Duration - P95延迟</span><br><span class="line">histogram_quantile(0.95, sum by(service, le) (rate(http_request_duration_seconds_bucket[5m])))</span><br></pre></td></tr></table></figure><p><strong>服务依赖健康度</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 数据库查询错误率</span><br><span class="line">sum(rate(database_query_errors_total[5m])) / sum(rate(database_queries_total[5m]))</span><br><span class="line"></span><br><span class="line"># 第三方API调用延迟</span><br><span class="line">histogram_quantile(0.99, sum by(api_name, le) (rate(api_request_duration_seconds_bucket[5m])))</span><br></pre></td></tr></table></figure><h3 id="2-性能瓶颈分析">2. 性能瓶颈分析</h3><p><strong>热点 API 发现</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 延迟最高的10个接口</span><br><span class="line">topk(10,</span><br><span class="line">  histogram_quantile(0.95, sum by(method, path, le) (rate(http_request_duration_seconds_bucket[5m])))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 请求量最大的接口</span><br><span class="line">topk(10, sum by(method, path) (rate(http_requests_total[5m])))</span><br></pre></td></tr></table></figure><p><strong>数据库性能分析</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 平均查询时间趋势</span><br><span class="line">rate(db_query_duration_seconds_sum[5m]) / rate(db_query_duration_seconds_count[5m])</span><br><span class="line"></span><br><span class="line"># 慢查询比例</span><br><span class="line">sum(rate(db_query_duration_seconds_bucket&#123;le=&quot;+Inf&quot;&#125;[5m])) - sum(rate(db_query_duration_seconds_bucket&#123;le=&quot;0.1&quot;&#125;[5m])) / sum(rate(db_query_duration_seconds_bucket&#123;le=&quot;+Inf&quot;&#125;[5m]))</span><br></pre></td></tr></table></figure><h3 id="3-容量规划与告警">3. 容量规划与告警</h3><p><strong>资源预测</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># CPU使用率预测</span><br><span class="line">predict_linear(avg by(instance) (rate(node_cpu_seconds_total&#123;mode!=&quot;idle&quot;&#125;[6h])) [3d:], 7 * 24 * 3600) &gt; 0.85</span><br><span class="line"></span><br><span class="line"># 内存压力告警</span><br><span class="line">(node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes &gt; 0.9</span><br></pre></td></tr></table></figure><p><strong>流量容量规划</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 带宽使用预测</span><br><span class="line">predict_linear(rate(node_network_transmit_bytes_total[12h])[7d:], 30 * 24 * 3600)</span><br></pre></td></tr></table></figure><h2 id="四、最佳实践与性能优化">四、最佳实践与性能优化</h2><h3 id="1-指标命名与标签设计">1. 指标命名与标签设计</h3><p><strong>命名规范</strong>：</p><ul><li>使用 snake_case</li><li>包含单位后缀（_bytes, _seconds, _total）</li><li>保持风格一致性</li></ul><p><strong>标签最佳实践</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合理设计标签维度</span></span><br><span class="line">apiLatency := prometheus.NewHistogramVec(</span><br><span class="line">    prometheus.HistogramOpts&#123;</span><br><span class="line">        Name:    <span class="string">&quot;api_request_duration_seconds&quot;</span>,</span><br><span class="line">        Help:    <span class="string">&quot;API request duration in seconds&quot;</span>,</span><br><span class="line">        Buckets: prometheus.ExponentialBuckets(<span class="number">0.001</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;service&quot;</span>, <span class="string">&quot;endpoint&quot;</span>, <span class="string">&quot;status_code&quot;</span>&#125;, <span class="comment">// 合理的低基数标签</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变标签使用ConstLabels</span></span><br><span class="line">prometheus.NewGaugeVec(</span><br><span class="line">    prometheus.GaugeOpts&#123;</span><br><span class="line">        Name:        <span class="string">&quot;service_info&quot;</span>,</span><br><span class="line">        Help:        <span class="string">&quot;Service information&quot;</span>,</span><br><span class="line">        ConstLabels: prometheus.Labels&#123;<span class="string">&quot;version&quot;</span>: <span class="string">&quot;v2.1.3&quot;</span>, <span class="string">&quot;environment&quot;</span>: <span class="string">&quot;production&quot;</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;instance&quot;</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="2-客户端性能优化">2. 客户端性能优化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存常用标签组合以提高性能</span></span><br><span class="line">getCounter := requestCounter.WithLabelValues(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/api/users&quot;</span>, <span class="string">&quot;200&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    getCounter.Inc() <span class="comment">// 重用标签组合，避免重复创建</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量更新方式</span></span><br><span class="line"><span class="keyword">var</span> rpcDurations = prometheus.NewSummaryVec(</span><br><span class="line">    prometheus.SummaryOpts&#123;</span><br><span class="line">        Name:       <span class="string">&quot;rpc_durations_seconds&quot;</span>,</span><br><span class="line">        Help:       <span class="string">&quot;RPC latency distributions.&quot;</span>,</span><br><span class="line">        Objectives: <span class="keyword">map</span>[<span class="type">float64</span>]<span class="type">float64</span>&#123;<span class="number">0.5</span>: <span class="number">0.05</span>, <span class="number">0.9</span>: <span class="number">0.01</span>, <span class="number">0.99</span>: <span class="number">0.001</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    []<span class="type">string</span>&#123;<span class="string">&quot;service&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ObserveBatch</span><span class="params">(durations <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> service, duration := <span class="keyword">range</span> durations &#123;</span><br><span class="line">        rpcDurations.WithLabelValues(service).Observe(duration)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-查询优化">3. 查询优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 优化前：高基数查询</span><br><span class="line">sum(rate(http_requests_total&#123;path=~&quot;/api/.*&quot;&#125;[5m])) by (path, method, status)</span><br><span class="line"></span><br><span class="line"># 优化后：降低基数，按需聚合</span><br><span class="line">sum(rate(http_requests_total&#123;path=~&quot;/api/.*&quot;&#125;[5m])) by (method, status)</span><br><span class="line"></span><br><span class="line"># 优化聚合顺序（先聚合再求和）</span><br><span class="line">sum(</span><br><span class="line">  avg by(instance) (rate(node_cpu_seconds_total&#123;mode!=&quot;idle&quot;&#125;[5m]))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="五、常见陷阱与解决方案">五、常见陷阱与解决方案</h2><h3 id="1-高基数问题">1. 高基数问题</h3><p><strong>问题</strong>：标签组合过多导致时间序列爆炸<br><strong>解决方案</strong>：</p><ul><li>限制标签基数，避免使用 UserID、SessionID 等作为标签</li><li>使用<code>label_replace</code>和正则表达式转换高基数标签</li><li>考虑使用 Exemplars 而非标签存储高基数数据</li></ul><h3 id="2-数据类型选择误区">2. 数据类型选择误区</h3><p><strong>Counter vs Gauge</strong>：请求数应使用 Counter 而非 Gauge<br><strong>Histogram vs Summary</strong>：需要聚合分析请使用 Histogram，精确分位数可选 Summary</p><h3 id="3-查询性能问题">3. 查询性能问题</h3><p><strong>问题</strong>：复杂查询导致 Prometheus 高负载<br><strong>解决方案</strong>：</p><ul><li>使用记录规则预计算常用查询</li><li>合理设置 scrape 间隔，避免过度采集</li><li>对高请求量接口使用客户端聚合</li></ul><h2 id="总结与展望">总结与展望</h2><p>Prometheus 的四种数据类型各有所长：Counter 适合累积事件计数，Gauge 适合瞬时状态测量，Histogram 适合分布统计和百分位分析，Summary 适合客户端精确分位数计算。与之配合的 PromQL 提供了强大的数据查询和分析能力，共同构成了完整的监控解决方案。</p><p>随着云原生技术的发展，Prometheus 生态也在不断壮大，与 Grafana、Alertmanager、Thanos 等工具集成，能够构建更完善的监控告警平台。在微服务架构中，结合 RED（Rate、Error、Duration）和 USE（Utilization、Saturation、Errors）方法论，可以构建全面的可观测性系统。</p><p>无论你是刚开始使用 Prometheus 的新手，还是寻求优化监控系统的资深工程师，希望本文对你理解和应用 Prometheus 有所帮助。记住，好的监控不仅能及时发现问题，更能预测和防范问题，最终服务于业务可靠性和用户体验的提升。</p><hr><p><em>参考资源:</em></p><ul><li>Prometheus 官方文档: <a href="https://prometheus.io/docs/">https://prometheus.io/docs/</a></li><li>Google SRE 书籍: <a href="https://sre.google/sre-book/monitoring-distributed-systems/">https://sre.google/sre-book/monitoring-distributed-systems/</a></li><li>Prometheus 实战: <a href="https://prometheusbook.com/">https://prometheusbook.com/</a></li></ul>]]></content>
    
    
    <summary type="html">本文介绍了 Prometheus 的四大数据类型及其 PromQL 查询语言，帮助开发团队构建强大的可观测性系统。</summary>
    
    
    
    <category term="服务监控" scheme="https://hedon.top/categories/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
    
    <category term="服务监控" scheme="https://hedon.top/tags/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"/>
    
    <category term="prometheus" scheme="https://hedon.top/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>在 Go 项目中实现 JWT 用户认证与续期机制</title>
    <link href="https://hedon.top/2025/02/15/go-action-jwt/"/>
    <id>https://hedon.top/2025/02/15/go-action-jwt/</id>
    <published>2025-02-15T15:28:10.000Z</published>
    <updated>2025-04-05T14:31:32.872Z</updated>
    
    <content type="html"><![CDATA[<p>JWT (JSON Web Token) 是一种广泛使用的用户认证方案，因其无状态、跨域支持和灵活性而受到欢迎。本文将结合实际代码，详细讲解如何在 Go 项目中实现 JWT 认证机制，并探讨两种常见的 Token 续期策略：自动续期和 Refresh Token。</p><h2 id="1-JWT-基础概念">1. JWT 基础概念</h2><p>JWT 由三部分组成：Header、Payload 和 Signature。使用 JWT 进行登录认证的基本工作流程是：</p><ol><li>用户登录成功后，服务器生成 JWT。</li><li>服务器将 token 返回给客户端。</li><li>客户端后续请求携带 token。</li><li>服务器验证 token 的有效性。</li></ol><p>我们可以在 <a href="https://jwt.io/">https://jwt.io/</a> 网站对 JWT 进行分析，查看其具体的组成成分。</p><h2 id="2-基本准备">2. 基本准备</h2><p>在本篇，我们将使用 Go 语言，通过一个完整的案例实现在 HTTP 接口中，使用 JWT 进行用户登录和认证流程。本文假设读者已掌握基本的 Go 语言语法和网络编程经验，并对 <a href="https://github.com/gin-gonic/gin">Gin</a> 框架有基本的了解。</p><p>为了快速响应失败，本文案例中使用了封装好的异常处理机制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrUser = errors.New(<span class="string">&quot;&quot;</span>)</span><br><span class="line">ErrSys  = errors.New(<span class="string">&quot;&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户侧错误，会直接将错误内容返回给用户，不打印日志。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserErr</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w%v&quot;</span>, ErrUser, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserErrf</span><span class="params">(format <span class="type">string</span>, a ...any)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w%v&quot;</span>, ErrUser, fmt.Sprintf(format, a...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义系统内部错误，会固定返回 internal server error 给用户，但是会将原始错误信息输出到日志中，便于内部排查。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SystemErr</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w%v&quot;</span>, ErrSys, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SystemErrf</span><span class="params">(format <span class="type">string</span>, a ...any)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w%v&quot;</span>, ErrSys, fmt.Sprintf(format, a...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GinErr</span><span class="params">(c *gin.Context, req any, err <span class="type">error</span>, msgs ...<span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrUser) &#123;</span><br><span class="line">c.JSON(http.StatusOK, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg := <span class="string">&quot;internal server error&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(msgs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">msg = msgs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">slog.Error(msg,</span><br><span class="line">slog.Any(<span class="string">&quot;req&quot;</span>, req),</span><br><span class="line">slog.String(<span class="string">&quot;err&quot;</span>, err.Error()),</span><br><span class="line">)</span><br><span class="line">c.JSON(http.StatusOK, <span class="string">&quot;internal server error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-实现用户认证">3. 实现用户认证</h2><p>在进行实际代码编写之前，你需要先初始化好项目并引入 <code>jwt</code> 依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang-jwt/jwt/v5</span><br></pre></td></tr></table></figure><p>在代码中使用的时候，可以：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/golang-jwt/jwt/v5&quot;</span></span><br></pre></td></tr></table></figure><p>那接下来我们就正式开始我们的功能实现。</p><h3 id="3-1-定义-Claims-结构">3.1 定义 Claims 结构</h3><p>首先，我们需要定义 JWT 的载荷（Payload）结构，即决定将什么信息存储在 token 当中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">    jwt.RegisteredClaims</span><br><span class="line">    UserID    <span class="type">uint64</span> <span class="string">`json:&quot;user_id&quot;`</span>    <span class="comment">// 用户ID</span></span><br><span class="line">    UserAgent <span class="type">string</span> <span class="string">`json:&quot;user_agent&quot;`</span>  <span class="comment">// 用户设备信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们：</p><ul><li><p>组合了 <code>jwt.RegisteredClaims</code>，它包含了标准的 JWT 字段（如过期时间），帮助我们实现了 <code>jwt.Clamis</code> 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Claims <span class="keyword">interface</span> &#123;</span><br><span class="line">GetExpirationTime() (*NumericDate, <span class="type">error</span>)</span><br><span class="line">GetIssuedAt() (*NumericDate, <span class="type">error</span>)</span><br><span class="line">GetNotBefore() (*NumericDate, <span class="type">error</span>)</span><br><span class="line">GetIssuer() (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">GetSubject() (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">GetAudience() (ClaimStrings, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jwt.RegisteredClaims</code> 的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RegisteredClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">Issuer <span class="type">string</span> <span class="string">`json:&quot;iss,omitempty&quot;`</span></span><br><span class="line">Subject <span class="type">string</span> <span class="string">`json:&quot;sub,omitempty&quot;`</span></span><br><span class="line">Audience ClaimStrings <span class="string">`json:&quot;aud,omitempty&quot;`</span></span><br><span class="line">ExpiresAt *NumericDate <span class="string">`json:&quot;exp,omitempty&quot;`</span></span><br><span class="line">NotBefore *NumericDate <span class="string">`json:&quot;nbf,omitempty&quot;`</span></span><br><span class="line">IssuedAt *NumericDate <span class="string">`json:&quot;iat,omitempty&quot;`</span></span><br><span class="line">ID <span class="type">string</span> <span class="string">`json:&quot;jti,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetExpirationTime() (*NumericDate, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.ExpiresAt, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetNotBefore() (*NumericDate, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.NotBefore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetIssuedAt() (*NumericDate, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.IssuedAt, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetAudience() (ClaimStrings, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.Audience, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetIssuer() (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.Issuer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c RegisteredClaims)</span></span> GetSubject() (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.Subject, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加了自定义字段 <code>UserID</code> 和 <code>UserAgent</code> 用于安全控制。你可以根据自己的业务需求，添加任意非敏感信息到这个结构中。</p></li></ul><h3 id="3-2-登录接口实现">3.2 登录接口实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   AccessTokenDuration = time.Minute * <span class="number">15</span></span><br><span class="line">   RefreshTokenDuration = time.Hour * <span class="number">24</span> * <span class="number">7</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> LoginJWT(ctx *gin.Context) &#123;</span><br><span class="line">    <span class="comment">// 1. 校验用户信息，在本案例中，使用邮箱加密码进行登录</span></span><br><span class="line">    user, err := u.svc.Login(ctx.Request.Context(), req.Email, req.Password)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, req, utils.UserErr(err), <span class="string">&quot;login failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建 JWT Claims</span></span><br><span class="line">    accessClaims := UserClaims&#123;</span><br><span class="line">        UserID:    user.ID,</span><br><span class="line">        UserAgent: ctx.Request.UserAgent(),</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(AccessTokenDuration)), <span class="comment">// 15分钟过期</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 生成 Access Token</span></span><br><span class="line">    accessToken := jwt.NewWithClaims(jwt.SigningMethodHS512, accessClaims)</span><br><span class="line">    accessTokenStr, err := accessToken.SignedString(AccessTokenKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, req, utils.SystemErr(err), <span class="string">&quot;generate access token failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 生成 Refresh Token，用于 Token 续期</span></span><br><span class="line">    refreshClaims := RefreshClaims&#123;</span><br><span class="line">        UserID:    user.ID,</span><br><span class="line">        UserAgent: ctx.Request.UserAgent(),</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(RefreshTokenDuration)), <span class="comment">// 7天过期</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS512, refreshClaims)</span><br><span class="line">    refreshTokenStr, err := refreshToken.SignedString(RefreshTokenKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, req, utils.SystemErr(err), <span class="string">&quot;generate refresh token failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 返回两个 token</span></span><br><span class="line">    ctx.Header(<span class="string">&quot;x-jwt-token&quot;</span>, accessTokenStr)</span><br><span class="line">    ctx.Header(<span class="string">&quot;x-refresh-token&quot;</span>, refreshTokenStr)</span><br><span class="line">    ctx.JSON(http.StatusOK, <span class="string">&quot;login success&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-JWT-中间件实现">3.3 JWT 中间件实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LoginJWTMiddlewareBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">whiteList []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLoginJWTMiddlewareBuilder</span><span class="params">()</span></span> *LoginJWTMiddlewareBuilder &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;LoginJWTMiddlewareBuilder&#123;</span><br><span class="line">whiteList: []<span class="type">string</span>&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *LoginJWTMiddlewareBuilder)</span></span> IgnorePaths(paths ...<span class="type">string</span>) *LoginJWTMiddlewareBuilder &#123;</span><br><span class="line">b.whiteList = <span class="built_in">append</span>(b.whiteList, paths...)</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *LoginJWTMiddlewareBuilder)</span></span> Build() gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 1. 提取 token</span></span><br><span class="line">        authCode := ctx.GetHeader(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">        tokenStr := strings.TrimPrefix(authCode, <span class="string">&quot;Bearer &quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 解析和验证 token</span></span><br><span class="line">        uc := web.UserClaims&#123;&#125;</span><br><span class="line">        token, err := jwt.ParseWithClaims(tokenStr, &amp;uc, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> web.AccessTokenKey, <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 验证 token 有效性</span></span><br><span class="line">        <span class="keyword">if</span> token == <span class="literal">nil</span> || !token.Valid &#123;</span><br><span class="line">            ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 验证 UserAgent</span></span><br><span class="line">        <span class="keyword">if</span> uc.UserAgent != ctx.Request.UserAgent() &#123;</span><br><span class="line">            ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 设置用户信息到上下文</span></span><br><span class="line">        ctx.Set(<span class="string">&quot;user_id&quot;</span>, uc.UserID)</span><br><span class="line">      ctx.Set(<span class="string">&quot;claims&quot;</span>, uc)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-注册中间件">3.4 注册中间件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initWebServer</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">server := gin.Default()</span><br><span class="line"></span><br><span class="line">server.Use(</span><br><span class="line">middleware.CORS(),</span><br><span class="line">middleware.NewLoginJWTMiddlewareBuilder().</span><br><span class="line">IgnorePaths(<span class="string">&quot;/users/signup&quot;</span>).</span><br><span class="line">IgnorePaths(<span class="string">&quot;/users/login&quot;</span>).</span><br><span class="line">Build(),</span><br><span class="line">)</span><br><span class="line">web.RegisterRoutes(server)</span><br><span class="line"><span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRoutes</span><span class="params">(server *gin.Engine)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">userHandler.RegisterRoutes(server)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> RegisterRoutes(server *gin.Engine) &#123;</span><br><span class="line">  ur := server.Group(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">  ur.POST(<span class="string">&quot;/login&quot;</span>, u.LoginJWT)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-在其他接口中使用-Token-的相关信息">4. 在其他接口中使用 Token 的相关信息</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> Profile(ctx *gin.Context) &#123;</span><br><span class="line">  <span class="comment">// 可以获取 user_id</span></span><br><span class="line">userID := ctx.GetUint64(<span class="string">&quot;user_id&quot;</span>)</span><br><span class="line">  <span class="comment">// 也可以直接获取整个 claims。</span></span><br><span class="line">  <span class="comment">// 这里我们可以选择不进行断言，因为理论上我们的可以保证这里通过断言。</span></span><br><span class="line">  <span class="comment">// 如果这里发生 panic 了，则说明我们的内部逻辑没有形成闭环，存在问题。</span></span><br><span class="line">  <span class="comment">// panic 可以第一时间暴露问题，然后被解决掉。</span></span><br><span class="line">  <span class="comment">// 不过这个时候建议你使用 gin 的 recover 中间件进行全局保护，避免整个服务因为 panic 而宕机。</span></span><br><span class="line">  uc, _ := ctx.Get(<span class="string">&quot;claims&quot;</span>)</span><br><span class="line">userClaims := uc.(*UserClaims)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Refresh-Token-机制">5. Refresh Token 机制</h2><h3 id="5-1-添加刷新-Token-接口">5.1 添加刷新 Token 接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> RefreshToken(ctx *gin.Context) &#123;</span><br><span class="line">    <span class="comment">// 从请求头获取 Refresh Token</span></span><br><span class="line">    refreshTokenStr := ctx.GetHeader(<span class="string">&quot;x-refresh-token&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> refreshTokenStr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析和验证 Refresh Token</span></span><br><span class="line">    <span class="keyword">var</span> refreshClaims RefreshClaims</span><br><span class="line">    refreshToken, err := jwt.ParseWithClaims(refreshTokenStr, &amp;refreshClaims, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> RefreshTokenKey, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !refreshToken.Valid &#123;</span><br><span class="line">        ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证 User Agent</span></span><br><span class="line">    <span class="keyword">if</span> refreshClaims.UserAgent != ctx.Request.UserAgent() &#123;</span><br><span class="line">        ctx.AbortWithStatus(http.StatusUnauthorized)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成新的 Access Token</span></span><br><span class="line">    accessClaims := UserClaims&#123;</span><br><span class="line">        UserID:    refreshClaims.UserID,</span><br><span class="line">        UserAgent: ctx.Request.UserAgent(),</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(AccessTokenDuration)),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    newAccessToken := jwt.NewWithClaims(jwt.SigningMethodHS512, accessClaims)</span><br><span class="line">    newAccessTokenStr, err := newAccessToken.SignedString(AccessTokenKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, <span class="literal">nil</span>, utils.SystemErr(err), <span class="string">&quot;generate new access token failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 Refresh Token 进行续期</span></span><br><span class="line">  refreshClaims := RefreshClaims&#123;</span><br><span class="line">        UserID:    user.ID,</span><br><span class="line">        UserAgent: ctx.Request.UserAgent(),</span><br><span class="line">        RegisteredClaims: jwt.RegisteredClaims&#123;</span><br><span class="line">            ExpiresAt: jwt.NewNumericDate(time.Now().Add(RefreshTokenDuration)), <span class="comment">// 7天过期</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    newRefreshToken := jwt.NewWithClaims(jwt.SigningMethodHS512, refreshClaims)</span><br><span class="line">    newRefreshTokenStr, err := newRefreshToken.SignedString(RefreshTokenKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        utils.GinErr(ctx, req, utils.SystemErr(err), <span class="string">&quot;generate new refresh token failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新的 Access Token 和续期后的 Refresh Token</span></span><br><span class="line">    ctx.Header(<span class="string">&quot;x-jwt-token&quot;</span>, newAccessTokenStr)</span><br><span class="line">   ctx.Header(<span class="string">&quot;x-refresh-token&quot;</span>, newRefreshTokenStr)</span><br><span class="line">    ctx.JSON(http.StatusOK, <span class="string">&quot;token refreshed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-注册路由">5.2 注册路由</h3><p>在 <code>RegisterRoutes</code> 方法中添加新路由：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *UserHandler)</span></span> RegisterRoutes(server *gin.Engine) &#123;</span><br><span class="line">  ur := server.Group(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">  ur.POST(<span class="string">&quot;/login&quot;</span>, u.LoginJWT)</span><br><span class="line">  ur.GET(<span class="string">&quot;/profile&quot;</span>, u.Profile)</span><br><span class="line">  ur.POST(<span class="string">&quot;/refresh&quot;</span>, u.RefreshToken)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-客户端使用流程">6. 客户端使用流程</h2><ol><li>登录后获取 Access Token 和 Refresh Token</li><li>使用 Access Token 访问受保护资源</li><li>当 Access Token 过期时调用 /refresh 接口获取新的 Access Token</li><li>使用新的 Access Token 继续访问</li></ol><p>刷新 token 的客户端示例代码（笔者并不擅长写前端代码 hhh，所以这是让 ChatGPT 帮忙写的 😄）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">async function refreshAccessToken() &#123;</span><br><span class="line">    <span class="keyword">const</span> response = await fetch(<span class="string">&#x27;/users/refresh&#x27;</span>, &#123;</span><br><span class="line">        method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">&#x27;x-refresh-token&#x27;</span>: localStorage.getItem(<span class="string">&#x27;refreshToken&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">        <span class="keyword">const</span> newAccessToken = response.headers.get(<span class="string">&#x27;x-jwt-token&#x27;</span>);</span><br><span class="line">        localStorage.setItem(<span class="string">&#x27;accessToken&#x27;</span>, newAccessToken);</span><br><span class="line">        <span class="keyword">const</span> newRefreshToken = response.headers.get(<span class="string">&#x27;x-refresh-token&#x27;</span>);</span><br><span class="line">        localStorage.setItem(<span class="string">&#x27;refreshToken&#x27;</span>, newRefreshToken);</span><br><span class="line">        <span class="keyword">return</span> newAccessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果刷新失败，重定向到登录页</span></span><br><span class="line">    window.location.href = <span class="string">&#x27;/login&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Token-续期策略对比">7. Token 续期策略对比</h2><p>在前面案例中，细心的读者可以观察到我们对 <code>AccessToken</code> 和 <code>RefreshToken</code> 分别采用了 2 种不同的续期策略。</p><h3 id="自动续期">自动续期</h3><p><strong>优点：</strong></p><ul><li>简单易用：在每次请求时自动检查并续期 Token，用户体验流畅。</li><li>无额外存储需求：不需要存储 Refresh Token，减少了存储和管理的复杂性</li></ul><p><strong>缺点：</strong></p><ul><li>安全性较低：如果 Token 被盗用，攻击者可以通过自动续期保持长时间的访问。</li><li>Token 过期时间不固定：Token 的有效期会不断延长，难以控制。</li></ul><h3 id="Refresh-Token">Refresh Token</h3><p><strong>优点：</strong></p><ul><li>更高的安全性：即使 Access Token 被盗用，攻击者也无法续期，除非同时获取 Refresh Token。</li><li>可控的 Token 生命周期：Access Token 有固定的短期有效期，Refresh Token 有较长的有效期。</li><li>支持 Token 撤销：可以实现 Refresh Token 的黑名单机制，支持手动撤销。</li></ul><p><strong>缺点：</strong></p><ul><li>实现复杂度较高：需要额外的接口和逻辑来处理 Refresh Token。</li><li>存储需求：需要安全存储 Refresh Token，可能需要数据库支持。</li></ul><h2 id="8-总结">8. 总结</h2><p>JWT 实现用户认证的优势在于无状态、跨域支持和灵活性。通过合理使用 JWT 和选择合适的 Token 续期策略，我们可以构建安全、可靠的用户认证系统。希望本文能帮助您在 Go 项目中更好地实现 JWT 认证。</p>]]></content>
    
    
    <summary type="html">本文将结合实际代码，详细讲解如何在 Go 项目中实现 JWT 认证机制，并探讨两种常见的 Token 续期策略：自动续期和 Refresh Token。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="Go 实战" scheme="https://hedon.top/categories/Go/Go-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="JWT" scheme="https://hedon.top/tags/JWT/"/>
    
    <category term="Go 实战" scheme="https://hedon.top/tags/Go-%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>深入 Go 语言核心：map 和 slice 的传参有什么不同</title>
    <link href="https://hedon.top/2025/02/14/go-slice-vs-map/"/>
    <id>https://hedon.top/2025/02/14/go-slice-vs-map/</id>
    <published>2025-02-14T07:34:05.000Z</published>
    <updated>2025-04-05T14:31:32.874Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 开发中，经常会遇到需要在函数中修改 map 或 slice 的场景。虽然它们都支持动态扩容，但在函数传参时的行为却大不相同。今天，让我们通过实例深入理解这个问题。</p><h2 id="一个困惑的开始">一个困惑的开始</h2><p>看这样一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Map 示例</span></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;old&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    modifyMap(m)</span><br><span class="line">    fmt.Println(m) <span class="comment">// 输出: map[new:1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slice 示例</span></span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    modifySlice(s)</span><br><span class="line">    fmt.Println(s) <span class="comment">// 输出: [100 2 3]，而不是 [100 2 3 200]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyMap</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;new&quot;</span>] = <span class="number">1</span>        <span class="comment">// 会影响原始 map</span></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">&quot;old&quot;</span>)    <span class="comment">// 也会影响原始 map</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">100</span>          <span class="comment">// 会影响原始 slice</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">200</span>)  <span class="comment">// 不会影响原始 slice</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有趣的是：</p><ol><li>map 的所有操作都会影响原始数据</li><li>slice 的简单索引修改会影响原始数据，但 append 可能不会</li></ol><p>为什么会这样？让我们从内部结构开始分析。</p><h2 id="内部结构解析">内部结构解析</h2><h3 id="Map-的内部结构">Map 的内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count      <span class="type">int</span>            <span class="comment">// 元素个数</span></span><br><span class="line">    flags      <span class="type">uint8</span>          <span class="comment">// 状态标志</span></span><br><span class="line">    B          <span class="type">uint8</span>          <span class="comment">// 桶的对数 B</span></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 指向桶数组的指针</span></span><br><span class="line">    <span class="comment">// ... 其他字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们声明一个 map 变量时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 实际上 m 是 *hmap，即指向 hmap 结构的指针</span></span><br></pre></td></tr></table></figure><h3 id="Slice-的内部结构">Slice 的内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer  <span class="comment">// 指向底层数组的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span>            <span class="comment">// 当前长度</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span>            <span class="comment">// 当前容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们声明一个 slice 变量时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// s 是一个完整的 slice 结构体，而不是指针</span></span><br></pre></td></tr></table></figure><h2 id="深入理解传参行为">深入理解传参行为</h2><h3 id="场景一：简单修改（不涉及扩容）">场景一：简单修改（不涉及扩容）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyBoth</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span>   <span class="comment">// 通过指针修改原始 map</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">100</span>     <span class="comment">// 通过指向相同底层数组的指针修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map:</span><br><span class="line">main()中的 m  -----&gt; hmap&#123;...&#125;  &lt;----- modifyBoth()中的 m</span><br><span class="line">(同一个底层结构)</span><br><span class="line"></span><br><span class="line">Slice:</span><br><span class="line">main()中的 s      = slice&#123;array: 指向数组1, len: 3, cap: 3&#125;</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                        [1 2 3]</span><br><span class="line">                           ^</span><br><span class="line">modifyBoth()中的 s = slice&#123;array: 指向数组1, len: 3, cap: 3&#125;</span><br></pre></td></tr></table></figure><h3 id="场景二：涉及扩容的操作">场景二：涉及扩容的操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expandBoth</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// map 扩容</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        m[fmt.Sprintf(<span class="string">&quot;key%d&quot;</span>, i)] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slice 扩容</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Map 扩容过程：</span><br><span class="line">Before:</span><br><span class="line">main()中的 m  -----&gt; hmap&#123;buckets: 指向存储A&#125;</span><br><span class="line">                           ^</span><br><span class="line">expandBoth()中的 m ---------|</span><br><span class="line"></span><br><span class="line">After:</span><br><span class="line">main()中的 m  -----&gt; hmap&#123;buckets: 指向更大的存储B&#125;  // 同一个 hmap，只是更新了内部指针</span><br><span class="line">                           ^</span><br><span class="line">expandBoth()中的 m ---------|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Slice 扩容过程：</span><br><span class="line">Before:</span><br><span class="line">main()中的 s      = slice&#123;array: 指向数组A, len: 3, cap: 3&#125;</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                        [1 2 3]</span><br><span class="line">                           ^</span><br><span class="line">expandBoth()中的 s = slice&#123;array: 指向数组A, len: 3, cap: 3&#125;</span><br><span class="line"></span><br><span class="line">After append:</span><br><span class="line">main()中的 s      = slice&#123;array: 指向数组A, len: 3, cap: 3&#125;     // 保持不变</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                        [1 2 3]</span><br><span class="line"></span><br><span class="line">expandBoth()中的 s = slice&#123;array: 指向数组B, len: 4, cap: 6&#125;    // 新的结构体，指向新数组</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                     [1 2 3 200]</span><br></pre></td></tr></table></figure><h2 id="关键区别解析">关键区别解析</h2><ol><li><p><strong>传递方式不同</strong>：</p><ul><li>map 传递的是指针，函数内外使用的是同一个 hmap 结构</li><li>slice 传递的是结构体副本，函数内的修改发生在副本上</li></ul></li><li><p><strong>扩容行为不同</strong>：</p><ul><li>map 扩容时，原有的 hmap 结构保持不变，只更新内部的 buckets 指针</li><li>slice 扩容时，会创建新的底层数组，并返回一个指向新数组的新 slice 结构体</li></ul></li><li><p><strong>修改效果不同</strong>：</p><ul><li>map 的所有操作（包括扩容）都会反映到原始数据</li><li>slice 的行为分两种情况：<ul><li>不涉及扩容的修改会影响原始数据（因为指向同一个底层数组）</li><li>涉及扩容的操作（如 append）会创建新的底层数组，修改不会影响原始数据</li></ul></li></ul></li></ol><h2 id="最佳实践">最佳实践</h2><p>基于以上原理，在编码时应注意：</p><ol><li>对于 map：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyMap</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span>    <span class="comment">// 直接修改即可，不需要返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>对于 slice：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 如果需要 append 或其他可能导致扩容的操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line">s = modifySlice(s)</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>理解 map 和 slice 的这些差异，关键在于：</p><ol><li>map 是指针类型，始终指向同一个 hmap 结构</li><li>slice 是结构体，包含了指向底层数组的指针</li><li>扩容时 map 只更新内部指针，而 slice 需要创建新的底层数组</li></ol><p>这种设计各有优势：</p><ul><li>map 的行为更加统一和直观</li><li>slice 的设计提供了更多的灵活性和控制权</li></ul><p>在实际编程中，正确理解和处理这些差异，是写出健壮 Go 代码的关键。</p>]]></content>
    
    
    <summary type="html">本文通过一个令人困惑的例子开始，探讨 Go 语言中 map 和 slice 动态扩容机制与传参时需要注意的问题。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨解密 QUIC/HTTP3：未来互联网的基石</title>
    <link href="https://hedon.top/2025/01/15/book-quic-http3/"/>
    <id>https://hedon.top/2025/01/15/book-quic-http3/</id>
    <published>2025-01-15T11:17:20.000Z</published>
    <updated>2025-04-05T14:31:32.871Z</updated>
    
    <content type="html"><![CDATA[<h1>1. QUIC 产生背景</h1><h2 id="常见网络协议">常见网络协议</h2><ul><li><code>UDP</code></li><li><code>TCP</code></li><li><code>SCTP</code>（Stream Control Transmission Protocol）：用于电话网络。</li><li><code>KCP</code>：基于 UDP 在应用层实现可靠性传输，牺牲带宽换取效率。</li><li><code>RTP</code>（Real-time Transport Protocol）：与 RTCP 配合传输实时数据，如交互式音频和视频数据。<ul><li>RTCP：传输控制信息</li><li>RTP：传输实时数据</li></ul></li></ul><h2 id="TSL-版本演化">TSL 版本演化</h2><ul><li><p><code>SSLv2</code>：安全性低</p></li><li><p><code>SSLv3</code>：分为握手阶段和数据传输阶段。</p><ul><li>握手阶段完成对端点的认证和确定保护数据传输的密钥。</li><li>一旦确定了密钥，后面的数据传输和SSL协议过程都受到加密和完整性保护。</li></ul></li><li><p><code>TSL1.0</code>：基于 SSLv3，存在 CBC（Cipher Block Chaining，密文分组链接）加密和解密模式漏洞，使得主动攻击者可以观察到当前记录的 IV（Intiallization Vector，初始化向量），猜测一个数据库，进行数据注入。</p></li><li><p><code>TSL1.1</code>：修复了 TSL1.0 的一些关键安全问题：</p><ul><li>BC 加密使用每条记录一个的显式IV；</li><li>为了防止 CBC 填充攻击，使用 bad_record_mac 错误码代替 decryption_failed 回复填充错误；</li><li>支持传输参数的IANA（Internet Assigned Numbers Authority，互联网数字分配机构）注册，增加了传输参数的灵活性；</li><li>改进了连接关闭过早情况下的连接恢复问题。</li></ul><p>有些加密算法还是存在安全漏洞，使用的 MD5 也不安全。</p></li><li><p><code>TSL1.2</code>：主要关注了架构灵活性和安全问题。</p><ul><li>架构：<ul><li>客户端可以指定自己支持的签名和 hash 算法列表；</li><li>支持非协议固定的算法；</li></ul></li><li>安全：<ul><li>增加了对 AEAD（Authenticated Encryption with Associated Data 关联数据认证加密）的支持，可以在加密中认证没有加密部分的关键数据，甚至是不在报文中的关键数据，可以保护更大的范围。</li><li>规定必须实现密码套件 TLS_RSA_WITH_AES_128_CBC_SHA。</li><li>增加了 HMAC-SHA256 密码套件。</li><li>删除了包含已废弃算法的 IDEA 和 DES 密码套件。</li><li>对 EncryptedPreMasterSecret 版本号进行了更严格的检查。</li></ul></li></ul></li><li><p><code>TSL1.3</code>：除了增加安全性，重点改进了连接速度，首次连接发送数据最低可以 1-RTT，恢复连接发送数据最低可以 0-RTT。</p><ul><li>安全：<ul><li>删除了所有被证明有问题的对称加密算法，只保留了 AEAD 的加密套件。密码套件的概念也已经改变，将认证和密钥交换机制与加密算法和散列（用于密钥导出函数和握手消息认证码）分离。</li><li>删除 RSA 和静态 DH 密码套件，因为静态 RSA 加密预主密钥的方式和使用静态 DH 私钥都不能保证前向安全性，很容易泄露密钥。只保留能保证前向安全的密钥交换算法，如使用临时私钥的 ECDHE（Elliptic Curve Diffie-Hellman Ephemeral，椭圆曲线 DH 临时密钥交换算法）和 DHE（Diffie-Hellman Ephemeral, DH 临时密钥交换算法）。</li><li>ServerHello 之后的消息都加密传输。</li><li>删除了压缩功能。之前版本的压缩功能由于存在被攻击的风险实际上很少使用，而且现代的压缩基本都在应用层实现，比如HTTP 就自己实现的压缩。</li></ul></li></ul></li></ul><h2 id="HTTP-版本演化">HTTP 版本演化</h2><ul><li><p><code>HTTP0.9</code>：仅支持简单的请求响应，只能访问<strong>简单的文本</strong>文档。</p></li><li><p><code>HTTP1.0</code>：HTTP1 中引入了<strong>请求头和响应头</strong>，请求时可以指定 HTTP 版本号、用户代理、接收类型等，响应可以指明响应状态、内容长度、内容类型等。</p></li><li><p><code>HTTP1.1</code>：增加了<strong>重用 TCP 连接</strong>（keep-alive）的方法，默认保持连接，除非显式通知关闭连接[插图]。这样可以在一个 TCP 连接上完成多个请求-响应，消除了 TCP 建立的延迟，也避免了新建立的 TCP 连接的慢启动过程。</p><ul><li>HTTP1.1 在 HTTP 请求首部中增加了 Host 字段，用来支持共享 IP 地址的虚拟主机服务器。</li><li>同时支持了更多的方法，如 PUT、PATCH、DELETE、OPTIONS。</li><li>引入分块传输支持动态内容。</li><li>引入了更多的缓存控制策略。</li><li>支持请求部分内容。</li></ul></li><li><p><code>HTTP2</code>：修改了 HTTP1.1 的封装格式，增加了一个二进制分帧层。基于二进制分层，HTTP2 实现了 HTTP 的<strong>多路复用</strong>。HTTP2 为每个请求分配了一个流标识，服务器响应时带上相同的流标识，客户端就可以方便地将响应与请求关联起来，而不用依赖顺序，从而可以降低延迟和提高吞吐量。</p><ul><li>HTTP2 还增加了首部压缩 HPACK（Header Compression for HTTP2，HTTP2 首部压缩算法）。</li><li>支持请求优先级。</li><li>支持服务器主动推送。</li><li>增加了 ALPN（Application-Layer Protocol Negotiation，应用层协议协商）。</li><li>支持认证、加密和完整性保护，即 <code>HTTPS</code>。</li></ul><p>但多个请求或响应在同一个 TCP 上发送时，仍然受制于 TCP 的队首阻塞问题。</p></li><li><p><code>HTTP3</code>：基于 <code>QUIC</code> 协议，底层使用 UDP 实现，摆脱了 TCP 的队首阻塞问题。同时改进了 TCP 中存在的一些其他问题，比如拥塞控制、协议僵化、启动慢、重连慢、安全弱等。</p><ul><li>实现了没有队首阻塞的并发。如果 QUIC 丢了一个报文，仅仅影响对应流的交付，不会阻塞其他流。</li><li>与 TLS1.3 紧密合作，尽可能的加密。还增加了 QUIC 报文的首部加密，除保证了报文安全性，提高了攻击门槛，还避免了协议僵化。</li><li>选择 UDP 作为底层实现。一方面避免了 TCP 的首部阻塞，另一方面互联网中绝大部分的主机和中间件都是 TCP 和 UDP 的天下，所以天然支持。</li><li>用户态实现。不依赖于内核，容易单独升级。</li><li>低延迟的建立。实现了首次最低 1-RTT 发送应用数据，恢复连接时发送应用数据最低只需 0-RTT。</li><li>无缝的连接迁移。QUIC 的连接基于连接标识，改变 IP 或者 UDP 端口号并不影响连接的识别，因此可以实现无缝的连接迁移。但是负载均衡就麻烦了。</li><li>改进的流量控制。</li><li>协议行为作为负载。</li></ul></li></ul><h1>2. QUIC 报文</h1><ul><li>长首部报文：用于建立 QUIC 连接和建立连接前发送应用数据。</li><li>短首部报文：用于在 QUIC 连接建立后发送应用数据和 QUIC 协议内容。</li><li>无状态重置报文：当服务器丢失了连接状态但仍然收到该连接的数据包时，可以发送无状态重置报文通知客户端立即终止连接。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250122195252117.png" alt="QUIC 报文类型"></p><p>初始报文：客户端使用初始报文来发起连接，服务器使用初始报文和握手报文回应客户端的请求。</p><p>0-RTT 报文：用于承载 QUIC 连接之前想要发送的数据，一般用于恢复连接后立即发送数据。</p><p>握手报文：用来携带服务器和客户端的 TLS 加密握手信息和确认，载荷一般是 CRYPTO 帧和 ACK 帧。</p><p>重试报文：是服务器用来验证客户端地址的报文，可以防止源地址欺骗。</p><blockquote><p>服务器使用重试报文通知客户端按照要求重新发送初始报文，在重试报文中携带重试令牌给客户端，并使用服务器选择的连接标识作为重试报文的源连接标识；客户端需要使用服务器指定的连接标识作为目的连接标识，携带服务器指定的重试令牌，构建新的初始报文，重新发送给服务器。</p></blockquote><p>版本协商报文：当服务器收到包含自己不支持的版本号的初始报文时，就会发送版本协商报文。客户端收到版本协商报文后需要在其中选择一个自己支持的版本号，重新以新版本号发送初始报文。</p><p>短首部报文：一般也叫作 1-RTT 报文，连接在协商出 1-RTT 密钥后就可以发送短首部报文，用于携带应用数据。</p>]]></content>
    
    
    <summary type="html">整理阅读《解密 QUIC/HTTP3：未来互联网的基石》笔记。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="QUIC" scheme="https://hedon.top/tags/QUIC/"/>
    
    <category term="HTTP3" scheme="https://hedon.top/tags/HTTP3/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>匠心码道丨01 编写优质代码的十大黄金法则</title>
    <link href="https://hedon.top/2024/12/12/clean-code-10-rules/"/>
    <id>https://hedon.top/2024/12/12/clean-code-10-rules/</id>
    <published>2024-12-12T02:22:49.000Z</published>
    <updated>2025-04-05T14:31:32.871Z</updated>
    
    <content type="html"><![CDATA[<p>代码质量的优劣直接影响着项目的可维护性和团队的开发效率。一个经验丰富的开发者不仅要能实现功能，更要善于编写清晰易懂、结构合理的代码。本文将介绍 10 条帮助你编写清晰、易维护且可扩展代码的重要规则。</p><h1>规则</h1><h2 id="1-使用有意义的变量和函数名称">1. 使用有意义的变量和函数名称</h2><p>变量、函数和类的命名应该具有描述性和意义。你的代码应该能够清晰地表达其意图，而无需额外的注释来解释。</p><p><strong>反面示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> api.<span class="title function_">get</span>();</span><br><span class="line"><span class="keyword">const</span> arr = users.<span class="title function_">filter</span>(<span class="function"><span class="params">u</span> =&gt;</span> u.<span class="property">a</span> === <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><strong>正面示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxRetries = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> currentDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> userResponse = <span class="keyword">await</span> api.<span class="title function_">getUserProfile</span>();</span><br><span class="line"><span class="keyword">const</span> activeUsers = users.<span class="title function_">filter</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">isActive</span> === <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>有意义的命名能讲述代码的故事。读者应该能够仅通过名称就理解变量或函数的用途。</p><p>💡实践建议：</p><ul><li>使用动词前缀命名函数：<code>getUserProfile()</code>、<code>validateInput()</code>、<code>calculateTotal()</code></li><li>使用名词命名变量：<code>userCount</code>、<code>activeUsers</code>、<code>orderStatus</code></li><li>布尔值使用 is/has/should 等前缀：<code>isValid</code>、<code>hasPermission</code>、<code>shouldUpdate</code></li></ul><h2 id="2-保持函数简短且专注">2. 保持函数简短且专注</h2><p>函数应该保持简短，并且只做一件事。函数承担的责任越多，测试、调试和理解起来就越困难。</p><p><strong>反面示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_order</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="comment"># 多个责任：验证、定价、折扣、配送等</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>正面示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">validate_order</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_total</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_discount</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>每个函数应该只有一个责任。如果你需要用&quot;和&quot;来描述函数的功能，那么这个函数可能做得太多了。</p><p>💡 最佳实践：</p><ul><li>函数建议保持在 20-30 行以内</li><li>如果超过 50 行，应该考虑拆分</li><li>一个函数最好不要超过 3 个参数</li></ul><h2 id="3-避免深层嵌套">3. 避免深层嵌套</h2><p>深层嵌套的循环和条件语句会使代码难以理解。通过使用提前返回、函数拆分或将大问题分解为小问题来使代码扁平化。</p><p><strong>反面示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (user.<span class="title function_">isActive</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (order != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="title function_">processOrder</span>(order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正面示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span> || !user.<span class="title function_">isActive</span>()) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (order == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="title function_">processOrder</span>(order);</span><br></pre></td></tr></table></figure><p>提前返回可以减少读者的认知负担，使代码更简单、更容易理解。</p><h2 id="4-明智地使用注释">4. 明智地使用注释</h2><p>注释不应该解释代码做了什么；代码本身应该是自解释的。只在必要时使用注释来解释复杂逻辑背后的&quot;原因&quot;，而不是&quot;是什么&quot;。</p><p><strong>反面示例：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置用户状态为激活</span></span><br><span class="line"><span class="variable">$user</span>-&gt;isActive = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>正面示例：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录成功后将用户标记为激活状态</span></span><br><span class="line"><span class="variable">$user</span>-&gt;isActive = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>注释应该增加价值，解释特定实现背后的原因或解释复杂的业务逻辑。</p><h2 id="5-保持一致的格式">5. 保持一致的格式</h2><p>一致的代码格式使代码更容易阅读和导航。在项目中使用统一的缩进、间距和对齐方式。</p><p><strong>反面示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a+b;&#125;</span><br></pre></td></tr></table></figure><p><strong>正面示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>许多团队使用 Prettier 或 ESLint 等工具来自动格式化并强制执行代码风格规则。</p><h2 id="6-不要重复自己（DRY-原则）">6. 不要重复自己（DRY 原则）</h2><p>代码重复会导致不一致、bug 和不必要的复杂性。应用 DRY 原则可以保持代码库精简，更易于维护。</p><p><strong>反面示例：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$userType</span> == <span class="string">&quot;admin&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 复杂逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$userType</span> == <span class="string">&quot;superadmin&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 相同的复杂逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正面示例：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">userIsAdmin</span>(<span class="variable">$userType</span>)) &#123;</span><br><span class="line">    <span class="comment">// 复杂逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将共同逻辑抽象到函数、类或工具中来避免代码重复。</p><h2 id="7-单一责任原则（SRP）">7. 单一责任原则（SRP）</h2><p>每个类和函数应该只有一个改变的理由。遵循单一责任原则使代码模块化，更容易重构。</p><p><strong>反面示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正面示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>承担太多责任的类更难维护。SRP 使代码更模块化，更容易测试。</p><h2 id="8-避免魔法数字和字符串">8. 避免魔法数字和字符串</h2><p>魔法数字（或字符串）是没有上下文或解释的硬编码值。使用常量或枚举代替，这样可以增加代码的清晰度。</p><p><strong>反面示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">discount = <span class="number">0.05</span></span><br><span class="line"><span class="keyword">if</span> user.role == <span class="string">&quot;admin&quot;</span>:</span><br></pre></td></tr></table></figure><p><strong>正面示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DISCOUNT_RATE = <span class="number">0.05</span></span><br><span class="line">ADMIN_ROLE = <span class="string">&quot;admin&quot;</span></span><br><span class="line">discount = DISCOUNT_RATE</span><br><span class="line"><span class="keyword">if</span> user.role == ADMIN_ROLE:</span><br></pre></td></tr></table></figure><p>常量为数字或字符串提供了含义，使代码更容易理解。</p><h2 id="9-编写测试">9. 编写测试</h2><p>单元测试和集成测试确保你的代码按预期工作，并且在进行更改时不会出错。编写测试使代码更可靠，长期更易于维护。</p><p><strong>反面示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法没有测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// 逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正面示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProcessOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    <span class="comment">// 断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试应该成为你工作流程的一部分，确保代码无 BUG 且稳定。</p><h2 id="10-保持简单（KISS-原则）">10. 保持简单（KISS 原则）</h2><p>KISS（Keep It Simple, Stupid）原则提醒我们简单是关键。复杂的解决方案会导致混淆，更难维护。在面对决策时，选择最简单、最直接的方案来满足需求。</p><p><strong>反面示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过度复杂的购物车商品总价计算</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateTotal</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> discount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复杂的折扣计算逻辑</span></span><br><span class="line">    items.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;electronics&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.<span class="property">price</span> &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                discount += item.<span class="property">price</span> * <span class="number">0.1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">price</span> &gt; <span class="number">500</span>) &#123;</span><br><span class="line">                discount += item.<span class="property">price</span> * <span class="number">0.05</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;books&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.<span class="property">quantity</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                discount += item.<span class="property">price</span> * item.<span class="property">quantity</span> * <span class="number">0.15</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        total += item.<span class="property">price</span> * item.<span class="property">quantity</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total - discount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正面示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将复杂逻辑拆分成小函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateDiscount</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;electronics&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> item.<span class="property">price</span> &gt; <span class="number">1000</span> ? <span class="number">0.1</span> : (item.<span class="property">price</span> &gt; <span class="number">500</span> ? <span class="number">0.05</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">category</span> === <span class="string">&#x27;books&#x27;</span> &amp;&amp; item.<span class="property">quantity</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateTotal</span>(<span class="params">items</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> discount = <span class="title function_">calculateDiscount</span>(item);</span><br><span class="line">        <span class="keyword">const</span> itemTotal = item.<span class="property">price</span> * item.<span class="property">quantity</span>;</span><br><span class="line">        <span class="keyword">return</span> total + itemTotal * (<span class="number">1</span> - discount);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>💡 最佳实践：</p><ul><li>将复杂逻辑拆分成小的、容易理解的函数</li><li>避免在一个函数中处理过多的条件判断</li><li>使用清晰的命名来表达意图</li><li>保持函数的单一职责</li></ul><h1>总结</h1><p>干净的代码对于可维护性、可读性和协作至关重要。遵循这 10 条规则——使用有意义的命名、保持函数简短、避免魔法数字、编写测试等，将会带来更健壮、更易理解和更易扩展的代码库。编写代码不仅仅是要让它能工作，更要让其他人（包括未来的你）能够轻松理解和扩展。</p><h1>代码审查清单</h1><p>在提交代码前，可以使用以下清单进行自查：</p><ul><li>[ ] 变量和函数名称是否具有描述性</li><li>[ ] 函数是否只做一件事</li><li>[ ] 是否存在重复代码</li><li>[ ] 是否有未使用的魔法数字</li><li>[ ] 是否编写了相应的测试</li><li>[ ] 代码格式是否统一</li><li>[ ] 注释是否有价值</li><li>[ ] 嵌套是否过深</li></ul><h1>参考</h1><ul><li><a href="https://www.thecodingdev.com/2024/09/top-10-clean-code-rules-every-developer.html?ref=dailydev">top-10-clean-code-rules-every-developer-should-follow</a></li></ul>]]></content>
    
    
    <summary type="html">详解编写整洁代码的十大原则，帮你写出更好的代码。</summary>
    
    
    
    <category term="匠心码道" scheme="https://hedon.top/categories/%E5%8C%A0%E5%BF%83%E7%A0%81%E9%81%93/"/>
    
    
    <category term="编程规范" scheme="https://hedon.top/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
    <category term="代码质量" scheme="https://hedon.top/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
    <category term="最佳实践" scheme="https://hedon.top/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>KCP 源码分析与原理总结</title>
    <link href="https://hedon.top/2024/12/01/kcp/"/>
    <id>https://hedon.top/2024/12/01/kcp/</id>
    <published>2024-12-01T02:08:02.000Z</published>
    <updated>2025-04-05T14:31:32.876Z</updated>
    
    <content type="html"><![CDATA[<h1>序言</h1><p>本文很大部分参考了 <a href="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP 协议的原理和实现</a>，非常感谢该文作者的讲解。本文再此基础上，加入了一些笔者的思考和分析图示，以期更好地理解 KCP 的底层原理。</p><h1>结论先行</h1><p>KCP 是一个快速可靠协议，能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。</p><p>TCP 是为流量设计的（每秒内可以传输多少 KB 的数据），讲究的是充分利用带宽。而 KCP 是为流速设计的（单个数据包从一端发送到一端需要多少时间），以 10%-20% 带宽浪费的代价换取了比 TCP 快 30%-40% 的传输速度。TCP 信道是一条流速很慢，但每秒流量很大的大运河，而 KCP 是水流湍急的小激流。</p><h2 id="KCP-增加的带宽在哪里？增加的速度又在哪里？">KCP 增加的带宽在哪里？增加的速度又在哪里？</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612111337839.png" alt="为什么 KCP 能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%？"></p><h2 id="KCP-核心特性">KCP 核心特性</h2><p><strong>快速重传</strong>： KCP 支持快速重传机制，不像 TCP 那样依赖超时重传。KCP 可以根据接收方返回的确认信息快速判断哪些数据包已经丢失，并迅速进行重传。</p><p><strong>选择性确认（Selective Acknowledgment, SACK）</strong>： KCP 支持 SACK，这允许接收端告知发送端哪些包已经收到，从而仅重传未被确认接收的数据包，减少不必要的重传。</p><p><strong>无连接操作</strong>： 基于 UDP 的实现使得 KCP 在传输数据前不需要像 TCP 那样进行三次握手建立连接，这减少了初始的延迟，并使其能在连接性较差的网络环境下更加灵活和快速。</p><p><strong>拥塞控制</strong>： KCP 实现了类似 TCP 的拥塞控制算法，但更为简化，能够快速适应网络条件的变化，如带宽波动和丢包。</p><p><strong>流量控制</strong>： KCP 允许调整发送和接收的窗口大小，使得发送方可以根据接收方的处理能力和网络条件调整数据发送速率，优化网络利用率和减少拥塞。</p><p><strong>可配置的传输策略</strong>： KCP 允许用户根据应用需求调整内部参数，如传输间隔、窗口大小等，以达到最优的传输效率和延迟。</p><p><strong>前向错误校正（Forward Error Correction, FEC）</strong>： KCP 还可以结合使用 FEC 技术，通过发送额外的冗余数据来恢复丢失的包，进一步提高在高丢包环境下的数据传输可靠性。</p><h2 id="为什么-TCP-做不到-KCP-这样？">为什么 TCP 做不到 KCP 这样？</h2><p>TCP 作为一种成熟且广泛使用的传输协议，在设计上注重可靠性和通用性，因此在拥塞控制和流量控制方面相对保守，以确保在各种网络条件下都能稳定运行。然而，这些设计上的保守性也导致了 TCP 在某些情况下的灵活性和自适应性不如 KCP。</p><table><thead><tr><th>特性类别</th><th>协议</th><th>描述</th></tr></thead><tbody><tr><td>拥塞控制机制</td><td>TCP</td><td>固定算法（慢启动、拥塞避免等），保守的调整策略（指数和线性增长）</td></tr><tr><td></td><td>KCP</td><td>灵活算法，动态调整策略，快速调整窗口大小</td></tr><tr><td>重传机制的延迟</td><td>TCP</td><td>固定重传间隔（RTO），多次确认触发重传，需要主动开启选择性重传（SACK）</td></tr><tr><td></td><td>KCP</td><td>快速重传，选择性重传，减少重传延迟</td></tr><tr><td>流量控制</td><td>TCP</td><td>固定流量控制（依赖接收窗口和发送窗口），通用性设计</td></tr><tr><td></td><td>KCP</td><td>自适应流量控制，应用层反馈调整发送窗口和重传策略</td></tr><tr><td>应用场景</td><td>TCP</td><td>广泛应用于各种网络环境，标准化要求高</td></tr><tr><td></td><td>KCP</td><td>优化特定场景（如高丢包率和高延迟网络），灵活实现</td></tr></tbody></table><h3 id="1-拥塞控制机制的固定性">1. 拥塞控制机制的固定性</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定算法</strong>：TCP 的拥塞控制算法，如慢启动（Slow Start）、拥塞避免（Congestion Avoidance）、快速重传（Fast Retransmit）和快速恢复（Fast Recovery），在设计时考虑了广泛的兼容性和可靠性。这些算法虽然有效，但其调整机制相对固定，响应速度较慢。</li><li><strong>保守的调整策略</strong>：TCP 的拥塞控制算法采用了保守的调整策略，例如指数增长和线性增长，这在高丢包率或高延迟网络中，可能会导致拥塞窗口（cwnd）增长速度较慢，影响传输效率。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>灵活算法</strong>：KCP 的拥塞控制机制更为灵活，可以根据实时网络状况进行快速调整。例如，KCP 的快速重传和选择性重传机制，使其能更快速地响应网络丢包情况。</li><li><strong>动态调整策略</strong>：KCP 的拥塞窗口调整更为灵活，可以根据网络状况快速增加或减少窗口大小，提高传输效率。</li></ul><h3 id="2-重传机制的延迟">2. 重传机制的延迟</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定重传间隔</strong>：TCP 使用固定的重传超时（RTO），并随着每次重传逐渐增加（指数回退），这种保守的重传机制在高延迟和高丢包率网络中可能导致重传延迟较长。</li><li><strong>多次确认触发重传</strong>：TCP 的快速重传需要等待三个重复的 ACK 才能触发，这在丢包率较高的情况下，可能会导致较长的延迟。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>快速重传</strong>：KCP 在检测到丢包后立即进行重传，而不需要等待多个重复的 ACK，这显著减少了重传延迟。</li><li><strong>选择性重传</strong>：KCP 只重传丢失的数据包，而不是所有未确认的数据包，减少了不必要的重传开销。（TCP 其实也支持选择性重传 SACK）</li></ul><h3 id="3-流量控制的灵活性">3. 流量控制的灵活性</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定流量控制</strong>：TCP 的流量控制主要依赖于接收窗口（rwnd）和发送窗口（swnd），在处理突发流量或变化较大的网络条件时，调整速度较慢。</li><li><strong>通用性设计</strong>：TCP 作为一种通用协议，其设计必须兼顾各种网络环境，因此在流量控制上相对保守，以确保在任何环境下都能稳定运行。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>自适应流量控制</strong>：KCP 的流量控制机制可以根据实际应用需求进行更细粒度的调整。例如，KCP 可以根据延迟抖动、丢包率等动态参数调整发送速率，确保在不同网络条件下都能保持高效传输。</li><li><strong>应用层反馈</strong>：KCP 可以根据应用层的实时反馈，动态调整发送窗口和重传策略，进一步优化传输效率。</li></ul><h3 id="4-应用场景的差异">4. 应用场景的差异</h3><p><strong>TCP</strong>：</p><ul><li><strong>广泛应用</strong>：TCP 设计用于广泛的网络环境，包括稳定的有线网络和不稳定的无线网络，因此其机制必须足够通用和保守，保证在各种情况下的可靠性。</li><li><strong>标准化要求</strong>：作为互联网的基础协议，TCP 的各项机制经过严格标准化，任何修改都需要广泛测试和验证，以确保不会影响现有网络的稳定性。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>特定优化</strong>：KCP 设计初衷是优化特定场景下的传输性能，特别是高丢包率和高延迟网络，因此在设计上更加灵活，能够根据实时网络状况进行调整。</li><li><strong>灵活实现</strong>：KCP 可以根据具体应用需求进行优化，例如在实时通信和在线游戏等场景中，灵活的流量控制和快速重传机制显著提升了传输效率。</li></ul><h3 id="结论">结论</h3><p>虽然 TCP 在拥塞控制和流量控制方面具备基本的动态调整能力，但其保守的设计和标准化要求使得其在高丢包率和高延迟网络中的适应性和灵活性不如 KCP。KCP 通过灵活的拥塞控制、快速重传和自适应流量控制机制，能够更有效地应对不同网络条件下的传输需求，提供更高效的传输性能。</p><h2 id="KCP-一定比-TCP-快吗？">KCP 一定比 TCP 快吗？</h2><p><font color="red">不一定</font>。KCP 并不一定在所有情况下都比 TCP 快。虽然 KCP 在某些特定网络环境（如高丢包率和高延迟的网络）中表现更优异，但在某些情况下，TCP 可能更合适。</p><h3 id="1-网络环境">1. 网络环境</h3><p><strong>高丢包率和高延迟网络</strong>：</p><ul><li><strong>KCP</strong>：KCP 通过快速重传和选择性重传机制，以及动态调整的窗口和重传间隔，能够更好地应对高丢包率和高延迟网络，减少传输延迟，提高传输效率。</li><li><strong>TCP</strong>：TCP 的重传机制和保守的拥塞控制在这种环境中可能导致较高的延迟和较低的带宽利用率。</li></ul><p><strong>低丢包率和低延迟网络</strong>：</p><ul><li><strong>KCP</strong>：在稳定的低丢包率和低延迟网络中，KCP 的频繁重传和控制报文可能会导致额外的带宽开销，未必有明显的性能优势。</li><li><strong>TCP</strong>：TCP 在这种环境中表现稳定，且由于其带宽开销较小，可能比 KCP 更高效。</li></ul><h3 id="2-带宽利用率">2. 带宽利用率</h3><p><strong>带宽充足的网络</strong>：</p><ul><li><strong>KCP</strong>：KCP 由于其频繁的重传和控制报文，可能会占用更多的带宽，但如果带宽充足，这种开销对整体性能影响较小，且其低延迟优势可能更明显。</li><li><strong>TCP</strong>：TCP 的带宽利用率较高，适合带宽充足的环境。</li></ul><p><strong>带宽受限的网络</strong>：</p><ul><li><strong>KCP</strong>：KCP 的额外带宽开销在带宽受限的网络中可能会显著影响整体传输效率。</li><li><strong>TCP</strong>：TCP 的较低带宽开销使其在带宽受限的环境中更有优势。</li></ul><h3 id="3-应用场景">3. 应用场景</h3><p><strong>实时应用</strong>（如在线游戏、视频会议）：</p><ul><li><strong>KCP</strong>：KCP 的低延迟和快速响应能力使其非常适合实时应用，在这些场景中，传输的及时性比带宽利用率更重要。</li><li><strong>TCP</strong>：TCP 在这些场景中的表现可能不如 KCP，特别是在高丢包率和高延迟的网络中。</li></ul><p><strong>非实时应用</strong>（如文件传输、网页浏览）：</p><ul><li><strong>KCP</strong>：KCP 在这些场景中可能不如 TCP 高效，特别是在网络稳定且带宽有限的情况下。</li><li><strong>TCP</strong>：TCP 的可靠性和高带宽利用率使其非常适合非实时应用。</li></ul><h3 id="4-实现和配置">4. 实现和配置</h3><p><strong>实现复杂性</strong>：</p><ul><li><strong>KCP</strong>：实现和配置 KCP 可能比 TCP 更复杂，需要根据具体应用和网络环境进行优化和调整。</li><li><strong>TCP</strong>：TCP 是一个成熟的协议，系统和库的支持较好，配置和使用相对简单。</li></ul><h3 id="总结">总结</h3><p>KCP 在某些特定环境和应用场景中确实比 TCP 更快，尤其是高丢包率和高延迟的网络环境，以及对低延迟要求较高的实时应用。但在网络稳定、带宽有限或非实时应用场景中，TCP 可能表现更好。因此，选择使用 KCP 还是 TCP 应根据具体的网络条件和应用需求进行权衡。</p><h1>前置准备</h1><p>笔者不想那么快就贴出大段大段的代码进行分析，这可能会使读者不知所云。为了更好地阐述 KCP 的底层原理，笔者的设想是先对原理部分进行概要总结，然后再带着这些结论去分析源码，进一步填充里面的边角细节。</p><p>但是呢，为了更好地理解 KCP 的原理，又不得不对涉及源码的一些重要设计，为了避免在原理分析阶段，对源码进行过多的涉及，笔者决定添加这单独的一章内容，对 KCP 的“接口设计”、“报文段”、“KCP 控制块”以及“队列和缓冲区”先进行简要概述，以辅助读者更好地理解后续的内容。</p><h2 id="接口设计">接口设计</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612171839051.png" alt="KCP 工作简约图"></p><p>在 <a href="https://github.com/skywind3000/kcp/blob/master/ikcp.h">kcp.h</a> 文件中，定义了 KCP 最核心的几个接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 KCP 控制对象</span></span><br><span class="line">ikcpcb* <span class="title function_">ikcp_create</span><span class="params">(IUINT32 conv, <span class="type">void</span> *user)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放一个 KCP 控制对象。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_release</span><span class="params">(ikcpcb *kcp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 KCP 的输出回调函数，这个回调函数在 KCP 需要发送数据时被调用。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_setoutput</span><span class="params">(ikcpcb *kcp, <span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">ikcpcb *kcp, <span class="type">void</span> *user))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 KCP 的接收队列中接收数据，用于上层从 KCP 中读取数据。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_recv</span><span class="params">(ikcpcb *kcp, <span class="type">char</span> *buffer, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 KCP 的发送队列中添加数据，用于上层向 KCP 发送数据，KCP 会管理这些数据并负责其可靠传输。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_send</span><span class="params">(ikcpcb *kcp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 KCP 的内部状态，通常需要定期调用。</span></span><br><span class="line"><span class="comment">// 这个函数负责处理 KCP 的超时、重传等操作，需要在一定的时间间隔内反复调用（通常每 10-100 毫秒）。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_update</span><span class="params">(ikcpcb *kcp, IUINT32 current)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否要调用 ikcp_update</span></span><br><span class="line">IUINT32 <span class="title function_">ikcp_check</span><span class="params">(<span class="type">const</span> ikcpcb *kcp, IUINT32 current)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收到的低层数据包（例如 UDP 包）。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_input</span><span class="params">(ikcpcb *kcp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">long</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将缓冲区可以发送的包发送出去，会在 ikcp_update 中被调用。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_flush</span><span class="params">(ikcpcb *kcp)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>ikcp_create</code>:</p><ul><li><code>conv</code>: 会话标识符，用于标识两个端点之间的连接。这个标识符在两个通信端点之间必须一致。</li><li><code>user</code>: 用户数据指针，可以传递任意用户数据，这个数据在 KCP 的 <code>output</code> 回调中会被传递回去。</li><li><strong>返回值</strong>: 一个指向新创建的 KCP 控制块（<code>ikcpcb</code>）的指针。</li></ul></li><li><p><code>ikcp_release</code>: 释放一个 KCP 控制对象。</p></li><li><p><code>ikcp_setoutput</code>: 设置 KCP 的输出回调函数。</p><ul><li><p><code>output</code>: 输出回调函数指针。这个回调函数在 KCP 需要发送数据时被调用。</p><ul><li><code>buf</code>: 要发送的数据缓冲区。</li><li><code>len</code>: 数据长度。</li><li><code>kcp</code>: 当前的 KCP 对象。</li><li><code>user</code>: 用户数据。</li></ul><p>通过这个回调，KCP 可以将要发送的数据传递给下层的网络层，比如 UDP 套接字。</p></li></ul></li><li><p><code>ikcp_recv</code>: 从 KCP 的接收队列中接收数据。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>buffer</code>: 用户提供的缓冲区，用于存储接收到的数据。</li><li><code>len</code>: 缓冲区的长度。</li><li><strong>返回值</strong>: 成功接收的数据大小；如果没有数据可接收，返回负值（例如，EAGAIN）。</li></ul><p>这个函数用于上层从 KCP 中读取数据。</p></li><li><p><code>ikcp_send</code>: 向 KCP 的发送队列中添加数据。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>buffer</code>: 要发送的数据缓冲区。</li><li><code>len</code>: 数据的长度。</li><li><strong>返回值</strong>: 成功发送的数据大小；如果发送失败，返回负值。</li></ul><p>这个函数用于上层向 KCP 发送数据，KCP 会管理这些数据并负责其可靠传输。</p></li><li><p><code>ikcp_update</code>: 更新 KCP 的内部状态，通常需要定期调用。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>current</code>: 当前的时间戳（以毫秒为单位）。</li></ul><p>这个函数负责处理 KCP 的超时、重传等操作，需要在一定的时间间隔内反复调用（通常每 10-100 毫秒）。</p></li><li><p><code>ikcp_input</code>: 处理接收到的低层数据包（例如 UDP 包）。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>data</code>: 收到的数据缓冲区。</li><li><code>size</code>: 数据的长度。</li><li><strong>返回值</strong>: 成功处理的数据大小；如果处理失败，返回负值。</li></ul></li><li><p><code>ikcp_flush</code>: 刷新待发送的数据。</p></li></ul><p>其中最重要的是这 4 个：</p><ul><li><code>ikcp_send</code>: 将数据放在发送队列中等待发送。</li><li><code>ikcp_recv</code>: 从接收队列中读取数据。</li><li><code>ikcp_input</code>: 读取下层协议输入数据，解析报文段，如果是数据，就将数据放入接收缓冲区，如果是 ACK，就在发送缓冲区中标记对应的报文段已送达。</li><li><code>ikcp_flush</code>: 调用输出回调将发送缓冲区的数据发送出去。</li></ul><p>这里就先简要介绍到这里，后面在源码分析篇章再对这些接口进行详细分析。</p><h2 id="报文段">报文段</h2><p>KCP 的报文段大小为 24 字节，结构如下图所示：</p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612172557464.png" alt="KCP 报文段" style="zoom: 33%;" /><p>每个字段的含义如下：</p><ul><li><code>conv</code>: 连接标识</li><li><code>cmd</code>：报文类型</li><li><code>frg</code>：分片数量，表示随后还有多少个报文属于同一个包</li><li><code>wnd</code>：发送方剩余接收窗口的大小</li><li><code>ts</code>：时间戳</li><li><code>sn</code>：报文编号</li><li><code>una</code>：发送方的接收缓冲区中最小还未收到的报文段的编号，也就是说，比它小的报文段都已全部接收</li><li><code>len</code>：数据段长度</li><li><code>data</code>：数据段，只有数据报文会有这个字段</li></ul><p>其中 <code>cmd</code> 共有 4 种报文类型：</p><ul><li>数据报文：IKCP_CMD_PUSH</li><li>确认报文：IKCP_CMD_ACK</li><li>窗口探测报文：IKCP_CMD_WASK 询问对端剩余接收窗口的大小</li><li>窗口通知报文：IKCP_CMD_WINS 通知对端剩余接收窗口的大小</li></ul><p>在 KCP 中，报文段结构定义在 <a href="https://github.com/skywind3000/kcp/blob/master/ikcp.h">kcp.h</a> 文件中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPSEG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">node</span>;</span></span><br><span class="line">IUINT32 conv;</span><br><span class="line">IUINT32 cmd;</span><br><span class="line">IUINT32 frg;</span><br><span class="line">IUINT32 wnd;</span><br><span class="line">IUINT32 ts;</span><br><span class="line">IUINT32 sn;</span><br><span class="line">IUINT32 una;</span><br><span class="line">IUINT32 len;</span><br><span class="line">IUINT32 resendts;</span><br><span class="line">IUINT32 rto;</span><br><span class="line">IUINT32 fastack;</span><br><span class="line">IUINT32 xmit;</span><br><span class="line"><span class="type">char</span> data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>IKCPSEG</code> 结构还多出了几个字段，这是为了支持 KCP 协议的可靠性和效率：</p><ul><li><code>resendts</code>: 记录报文的下次重传时间，用于实现重传机制。如果报文在一定时间内没有被确认收到，就会在这个时间戳之后被重新发送。</li><li><code>rto</code>: 表示当前报文的重传超时时间（RTT 的估计值）。用于计算每个报文的重传时间，如果超过 <code>rto</code> 时间没有收到 ACK，会触发重传。</li><li><code>fastack</code>: 快速重传计数，记录该报文被跳过的次数。如果一个报文的 ACK 连续接收到多个对同一报文的确认，而不是新的报文，会增加这个计数，用于实现快速重传机制。</li><li><code>xmit</code>: 记录报文已经被发送的次数。用于统计一个报文的重传次数，帮助判断传输的可靠性。如果操作 <code>dead_link</code> 次，则会判断为连接失效，KCP 会断开连接。</li><li><code>node</code>: 链表节点，用于将多个 <code>IKCPSEG</code> 结构体链接在一起。KCP 的队列和缓冲区都是循环双链表结构。</li></ul><p>这些字段共同作用，帮助 KCP 实现以下功能：</p><ul><li><strong>可靠性</strong>：通过 <code>sn</code>、<code>una</code> 和 <code>ack</code> 确保数据包按顺序接收和重传。</li><li><strong>流量控制</strong>：通过 <code>wnd</code> 控制数据流量，避免接收方过载。</li><li><strong>高效传输</strong>：通过 <code>resendts</code> 和 <code>rto</code> 进行超时和重传控制，<code>fastack</code> 提供快速重传机制。</li><li><strong>灵活管理</strong>：使用链表节点 <code>node</code> 组织数据，便于内部管理。</li></ul><h2 id="KCP-控制块-ikcpcb">KCP 控制块 ikcpcb</h2><p>上面我们提到的 <code>ikcp_create</code> 和 <code>ikcp_release</code> 就是对 KCP 控制块 <code>ikcpcb</code> 的创建和释放，每个 KCP 连接都对应一个 KCP 控制块。它定义在 <a href="https://github.com/skywind3000/kcp/blob/master/ikcp.h#L343">kcp.h</a> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPCB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">IUINT32 conv, mtu, mss, state;</span><br><span class="line">IUINT32 snd_una, snd_nxt, rcv_nxt;</span><br><span class="line">IUINT32 ts_recent, ts_lastack, ssthresh;</span><br><span class="line">IINT32 rx_rttval, rx_srtt, rx_rto, rx_minrto;</span><br><span class="line">IUINT32 snd_wnd, rcv_wnd, rmt_wnd, cwnd, probe;</span><br><span class="line">IUINT32 current, interval, ts_flush, xmit;</span><br><span class="line">IUINT32 nrcv_buf, nsnd_buf;</span><br><span class="line">IUINT32 nrcv_que, nsnd_que;</span><br><span class="line">IUINT32 nodelay, updated;</span><br><span class="line">IUINT32 ts_probe, probe_wait;</span><br><span class="line">IUINT32 dead_link, incr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_buf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_buf</span>;</span></span><br><span class="line">IUINT32 *acklist;</span><br><span class="line">IUINT32 ackcount;</span><br><span class="line">IUINT32 ackblock;</span><br><span class="line"><span class="type">void</span> *user;</span><br><span class="line"><span class="type">char</span> *buffer;</span><br><span class="line"><span class="type">int</span> fastresend;</span><br><span class="line"><span class="type">int</span> fastlimit;</span><br><span class="line"><span class="type">int</span> nocwnd, stream;</span><br><span class="line"><span class="type">int</span> logmask;</span><br><span class="line"><span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line"><span class="type">void</span> (*writelog)(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">log</span>, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字段的含义如下，读者可在后续分析过程回过来查阅：</p><table><thead><tr><th>字段名</th><th>含义</th></tr></thead><tbody><tr><td><code>conv</code></td><td>连接标识符，用于识别一个特定的会话。</td></tr><tr><td><code>mtu</code></td><td>最大传输单元（Maximum Transmission Unit），表示网络层传输数据包的最大字节数。</td></tr><tr><td><code>mss</code></td><td>最大报文段长度（Maximum Segment Size），表示应用层传输数据的最大字节数。</td></tr><tr><td><code>state</code></td><td>连接状态，标识当前的传输状态。</td></tr><tr><td><code>snd_una</code></td><td>未确认的发送序号，表示最早未确认的包的序号。</td></tr><tr><td><code>snd_nxt</code></td><td>下一个发送序号，表示即将发送的包的序号。</td></tr><tr><td><code>rcv_nxt</code></td><td>下一个接收序号，表示期望接收的下一个包的序号。</td></tr><tr><td><code>ts_recent</code></td><td>最近的时间戳，用于延迟测量。</td></tr><tr><td><code>ts_lastack</code></td><td>最近的确认时间戳，用于 RTT 计算。</td></tr><tr><td><code>ssthresh</code></td><td>拥塞避免的慢启动阈值。</td></tr><tr><td><code>rx_rttval</code></td><td>RTT 的偏差，用于计算 RTT 的波动。</td></tr><tr><td><code>rx_srtt</code></td><td>平滑的 RTT 值，用于计算平均 RTT。</td></tr><tr><td><code>rx_rto</code></td><td>重新传输超时时间，根据 RTT 动态调整。</td></tr><tr><td><code>rx_minrto</code></td><td>最小的重新传输超时时间。</td></tr><tr><td><code>snd_wnd</code></td><td>发送窗口大小，控制发送流量的窗口。</td></tr><tr><td><code>rcv_wnd</code></td><td>接收窗口大小，控制接收流量的窗口。</td></tr><tr><td><code>rmt_wnd</code></td><td>远端窗口大小，表示对方接收窗口的大小。</td></tr><tr><td><code>cwnd</code></td><td>拥塞窗口大小，控制发送流量的窗口，用于拥塞控制。</td></tr><tr><td><code>probe</code></td><td>探测标志，表示是否需要进行窗口探测。</td></tr><tr><td><code>current</code></td><td>当前的时间戳。</td></tr><tr><td><code>interval</code></td><td>刷新间隔时间，表示定期刷新 KCP 状态的间隔。</td></tr><tr><td><code>ts_flush</code></td><td>下次刷新时间戳，用于确定何时执行下一次状态刷新。</td></tr><tr><td><code>xmit</code></td><td>发送次数，表示数据包重传的次数。</td></tr><tr><td><code>nrcv_buf</code></td><td>接收缓冲区的数据包数量。</td></tr><tr><td><code>nsnd_buf</code></td><td>发送缓冲区的数据包数量。</td></tr><tr><td><code>nrcv_que</code></td><td>接收队列中的数据包数量。</td></tr><tr><td><code>nsnd_que</code></td><td>发送队列中的数据包数量。</td></tr><tr><td><code>nodelay</code></td><td>延迟模式标志，表示是否启用无延迟模式。</td></tr><tr><td><code>updated</code></td><td>更新标志，表示是否需要更新 KCP 状态。</td></tr><tr><td><code>ts_probe</code></td><td>下次探测时间戳，用于窗口探测。</td></tr><tr><td><code>probe_wait</code></td><td>探测等待时间，表示等待多长时间后进行下一次窗口探测。</td></tr><tr><td><code>dead_link</code></td><td>死链标志，表示连接是否已经失效。</td></tr><tr><td><code>incr</code></td><td>增量，用于控制流量的增加速率。</td></tr><tr><td><code>snd_queue</code></td><td>发送队列，用于存储待发送的数据包。</td></tr><tr><td><code>rcv_queue</code></td><td>接收队列，用于存储待处理的数据包。</td></tr><tr><td><code>snd_buf</code></td><td>发送缓冲区，用于存储已经发送但未确认的数据包。</td></tr><tr><td><code>rcv_buf</code></td><td>接收缓冲区，用于存储已经接收到但未处理的数据包。</td></tr><tr><td><code>acklist</code></td><td>确认列表，用于存储待发送的确认序号。</td></tr><tr><td><code>ackcount</code></td><td>确认计数，表示确认列表中的条目数量。</td></tr><tr><td><code>ackblock</code></td><td>确认块大小，表示确认列表的内存分配大小。</td></tr><tr><td><code>user</code></td><td>用户数据指针，用于存储用户自定义的数据。</td></tr><tr><td><code>buffer</code></td><td>缓冲区，用于临时存储发送的数据。</td></tr><tr><td><code>fastresend</code></td><td>快速重传标志，表示启用快速重传功能。</td></tr><tr><td><code>fastlimit</code></td><td>快速重传限制，表示在一个 RTT 内允许的最大重传次数。</td></tr><tr><td><code>nocwnd</code></td><td>无拥塞窗口控制标志，表示是否禁用拥塞窗口控制。</td></tr><tr><td><code>stream</code></td><td>流模式标志，表示是否启用流模式。</td></tr><tr><td><code>logmask</code></td><td>日志掩码，用于控制日志输出的级别。</td></tr><tr><td><code>output</code></td><td>发送数据回调函数，用于发送数据。</td></tr><tr><td><code>writelog</code></td><td>日志回调函数，用于输出日志。</td></tr></tbody></table><h2 id="队列和缓冲区">队列和缓冲区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPCB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_buf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_buf</span>;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>KCP 中队列和缓冲区都是循环双链表，链表由宏实现，笔者并不擅长，所以本文就不探讨该链表的实现了，有数据结构基础的笔者应该很好理解这一块。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612175626865.png" alt="队列和缓冲区的实现：循环双链表"></p><p>队列和缓冲区是 KCP 最核心的部分，它们的作用流程大概如下图所示，读者可以自行阅读尝试理解，后续我们会进行详细的分析。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612175950432.png" alt="KCP 队列和缓冲区作用流程"></p><h1>原理分析</h1><p>这一节我们详细讨论 KCP 的整个 ARQ 流程。首先我们会对整体流程进行简要概述，然后详细讨论滑动窗口中的发送和接收过程，接着讨论超时重传和快速重传，在这之后我们会将 KCP 和 TCP 的重传策略进行简单对比，最后介绍一下拥塞控制策略。</p><h2 id="1-整体流程">1. 整体流程</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612192523848.png" alt="KCP 全流程"></p><p>KCP 的全流程如上图所示：</p><ol><li>发送方调用 <code>ikcp_send</code> 将发送数据，这个时候会创建报文段实例，并放入 <code>snd_queue</code> 发送队列中。</li><li>KCP 会定时调用 <code>ikcp_update</code> 判断是否要调用 <code>ikcp_flush</code>。</li><li>调用 <code>ikcp_flush</code> 时会将合适的报文段放入 <code>snd_buf</code> 缓冲区中，具体包括：<ol><li>发送 ACK 列表中所有 ACK；</li><li>根据是否需要发送窗口探测和通知报文，需要则发；</li><li>根据发送窗口大小，将适量的报文段从 <code>snd_queue</code> 移入 <code>snd_buf</code> 中；</li><li>发送 <code>snd_buf</code> 中的报文，包括<strong>新加入的</strong>、<strong>RTO 内未收到 ACK</strong> 的和 <strong>ACK 失序若干次</strong>的；</li><li>根据丢包情况计算 <code>ssthresh</code> 和 <code>cwnd</code>。</li></ol></li><li>发送的时候会调用由 <code>ikcp_setoutput</code> 设置的回调函数，将数据发送到对端。</li><li>接收方收到数据后，会调用 <code>ikcp_input</code>，将数据放入 <code>rcv_buf</code> 缓冲区，具体包括：<ol><li>根据所有报文的 una 将相应的报文标记为已送达；</li><li>如果是 ACK，就将相应的报文标记为已送达；</li><li>如果是数据报文，就将它放入 <code>rcv_buf</code>，然后将 <code>rcv_buf</code> 中顺序正确的报文移入 <code>rcv_queue</code> 接收队列中，接着将相关信息插入 ACK 列表，在稍后的 <code>ikcp_flush</code> 中会发送相应的 ACK；</li><li>如果是窗口探测报文，就标记“需要发送窗口通知”，在稍后的 <code>ikcp_flush</code> 中会发送窗口通知报文；</li><li>包括窗口通知报文在内的所有报文都有 wnd 字段，据此更新 rmt_wnd；</li><li>根据 ACK 失序情况决定是否进行快速重传；</li><li>计算 cwnd。</li></ol></li><li>调用 <code>ikcp_recv</code> 从 <code>rcv_queue</code> 中接收数据。</li></ol><h2 id="2-滑动窗口">2. 滑动窗口</h2><p>发送缓冲区 <code>snd_buf</code> 和接收缓冲区 <code>rcv_buf</code> 中活动的报文都是在滑动窗口之中的。这对于我们理解 KCP 的发送和接收流程非常重要，所有我们先从滑动窗口开始介绍。</p><p>滑动窗口实际是一个抽象的概念, 不能简单地认为它是缓冲区的一部分，准确的说，滑动窗口是由队列加缓冲区共同组成的。</p><h3 id="2-1-发送">2.1 发送</h3><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612193023604.png" alt="发送窗口"></p><p><code>snd_una</code> 和 <code>snd_nxt</code> 会努力往<strong>右</strong>移动：</p><ol><li><code>ikcp_flush</code> 时，会从 <code>snd_queue</code> 中取出报文插入到 <code>snd_nxt</code> 的位置上；</li><li>如果 <code>snd_nxt - snd_una &gt;= cwnd</code>，则不允许新的报文插入；</li><li>当 <code>snd_una</code> 的 ACK 报文到达时，<code>snd_una</code> 就会右移到第一个没有收到 ACK 报文的位置；</li></ol><p>发送窗口中未确认到达的报文何时重传？</p><ul><li>报文在一个 RTO 时间内仍未确认到达，就会重传。报文 RTO 初始值是 rx_rto ，会持续增长，速率支持配置。</li></ul><h3 id="2-2-接收">2.2 接收</h3><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612193238859.png" alt="接收窗口"></p><ol><li>每收到一个数据报文, 都会根据它的编号将它插入到 <code>rcv_buf</code> 对应的位置中；</li><li>接着检查 <code>rcv_nxt</code> 能否向右移动, 只有当报文的顺序正确且连续才能移动；</li><li>在上图的例子中由于 4 号报文的缺失, <code>rcv_nxt</code> 只能处于 4 号位置等待，5, 6 号报文也不能移动到 <code>rcv_queue</code> 中；</li><li>等到 4 号报文到达后，才能将 4, 5, 6 号报文一并移动到 <code>rcv_queue</code> 中，同时 <code>rcv_nxt</code> 会右移到 7 号位置。</li></ol><h3 id="2-3-案例分析">2.3 案例分析</h3><p>我们举个简单的例子演示整个 ARQ 的流程。下图中实线箭头表示数据报文，虚线箭头表示 ACK。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/kcp_5.svg" alt="KCP ARQ 流程"></p><p>① t1 时刻发送方发送 1 号报文, 1 号报文放入发送缓冲区中, snd_una 指向 1, snd_nxt 指向 2.</p><p>② t2 至 t3 时刻发送方依次发送 2 至 3 号报文, snd_nxt 依次后移.</p><p>③ 1 号报文丢包.</p><p>④ t4, t5 时刻接收方收到 3 号和 2 号报文, 放入 rcv_buf 中; 随后回复 3 号和 2 号 ACK. 此时由于 1 号报文缺失, rcv_nxt 始终指向 1.</p><p>⑤ 3 号 ACK 丢包.</p><p>⑥ t7 时刻发送方收到 2 号 ACK, 将 2 号报文标记为已送达. 此时由于 3 号 ACK 丢包, 3 号报文未标记为已送达. 由于 1 号报文未确认送达, snd_una 亦指向 1.</p><p>⑦ t8 时刻 1 号报文超时, 重传.</p><p>⑧ t9 时刻接收方收到 1 号报文, 放入 rcv_buf 中; 这时 1, 2, 3 号报文顺序正确, rcv_nxt 右移到 4 号位置. 接收方回复 1 号 ACK, 同时带上 una = 4.</p><p>⑨ t10 时刻发送方收到 1 号 ACK, 将 1 号报文标记为已送达. 同时 una 表明 1, 2, 3 号报文均已送达, 因此也将 3 号报文标记为已送达. snd_una 移动到 4.</p><h2 id="3-超时重传">3. 超时重传</h2><p>超时重传是当发送的数据包在预定时间内未被确认时，重新发送该数据包的机制。在 KCP 中，这个时间由重新传输超时（RTO）决定。KCP 计算 RTO 初始值的方法是 TCP 的标准方法, 规定在 <a href="https://www.rfc-editor.org/rfc/rfc6298.html">RFC 6298</a> 中。</p><p>这里还是贴出源码讲比较直观：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ikcp_update_ack</span><span class="params">(ikcpcb *kcp, IINT32 rtt)</span></span><br><span class="line">&#123;</span><br><span class="line">IINT32 rto = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;rx_srtt == <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;rx_srtt = rtt;</span><br><span class="line">kcp-&gt;rx_rttval = rtt / <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">long</span> delta = rtt - kcp-&gt;rx_srtt;</span><br><span class="line"><span class="keyword">if</span> (delta &lt; <span class="number">0</span>) delta = -delta;</span><br><span class="line">kcp-&gt;rx_rttval = (<span class="number">3</span> * kcp-&gt;rx_rttval + delta) / <span class="number">4</span>;</span><br><span class="line">kcp-&gt;rx_srtt = (<span class="number">7</span> * kcp-&gt;rx_srtt + rtt) / <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;rx_srtt &lt; <span class="number">1</span>) kcp-&gt;rx_srtt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">rto = kcp-&gt;rx_srtt + _imax_(kcp-&gt;interval, <span class="number">4</span> * kcp-&gt;rx_rttval);</span><br><span class="line">kcp-&gt;rx_rto = _ibound_(kcp-&gt;rx_minrto, rto, IKCP_RTO_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个计算过程笔者就不做详细介绍了，代码里面的公式读者可以尝试自行画图进行理解，这里就不花大篇幅画公式了，下面我尝试以更通俗易懂的话语解释 RTO，只需要理解它在做什么，为什么这么做，就可以了，个人觉得对公式的细节可以暂且忽略。</p><h3 id="3-1-RTO-计算目的">3.1 RTO 计算目的</h3><p>KCP 的 RTO 计算是为了确定在多长时间内未收到确认（ACK）时，应该重新发送数据包。这段时间被称为重传超时时间（RTO）。计算 RTO 的目的是在网络条件变化的情况下，既能快速响应数据丢失，也能避免不必要的重传，从而保持高效的传输。</p><h3 id="3-2-RTO-计算涉及的变量解释">3.2 RTO 计算涉及的变量解释</h3><p><strong>RTT 和 SRTT 的概念:</strong></p><ul><li>RTT（Round-Trip Time）: 是从发送一个数据包到收到其确认（ACK）所花的时间。</li><li>SRTT（Smoothed RTT）: 是 RTT 的加权平均值，它代表了 RTT 的一个更稳定的估计值。SRTT 的目的是减少 RTT 的短期波动对 RTO 的影响。</li></ul><p><strong>RTT 变化值（RTT variance）</strong>：网络传输时间并不总是固定的，有时会因为网络拥塞或其他原因出现波动。我们通过计算 RTT 变化值（RTT variance）来估计这种波动的大小。</p><p><strong>为什么需要 SRTT 和 RTT 变化值：</strong></p><ul><li>SRTT 给我们一个平均的 RTT 估计值。</li><li>RTT 变化值告诉我们网络的波动性。如果波动很大，我们希望 RTO 更大，以免因为短暂的网络延迟就触发不必要的重传。</li></ul><h3 id="3-3-RTO-计算步骤">3.3 RTO 计算步骤</h3><p><strong>1. 初始化</strong>：初次计算时，我们没有历史 RTT 值，所以直接用第一次测量的 RTT 来初始化 SRTT，并将 RTT 变化值设为 RTT 的一半。</p><p><strong>2. 更新 SRTT 和 RTT 变化值</strong>:</p><ul><li>每次我们测量新的 RTT，就用它来更新 SRTT 和 RTT 变化值。</li><li>更新 SRTT：我们不直接替换旧的 SRTT，而是用一个平滑的方式（即加权平均），使得 SRTT 逐渐靠近新 RTT，但又不会剧烈变化。</li><li>更新 RTT 变化值：计算新的 RTT 与 SRTT 的差值，用这个差值来更新 RTT 变化值，使其反映当前网络波动的大小。</li></ul><p><strong>3. 计算 RTO</strong>:</p><ul><li>用 SRTT 加上四倍的 RTT 变化值来计算 RTO，这样可以确保 RTO 足够长，能涵盖大部分的网络波动。</li><li>我们还要确保 RTO 不小于一个最小值（<code>rx_minrto</code>），以防止 RTO 过小导致频繁重传；也不能大于一个最大值（<code>IKCP_RTO_MAX</code>），以防止 RTO 过大影响响应速度。</li></ul><h3 id="4-RTO-计算效果">4. RTO 计算效果</h3><ul><li><strong>稳定的传输</strong>: SRTT 提供了一个稳定的平均 RTT 估计，使得 RTO 能适应网络的长期变化。</li><li><strong>适应网络波动</strong>: RTT 变化值使得 RTO 能够应对网络的短期波动，减少因短暂延迟而导致的重传。</li><li><strong>快速响应</strong>: RTO 设置合理后，能够在数据丢失时快速重传，保持传输的高效和及时性。</li></ul><p>通过这样的计算方式，KCP 能够在不同的网络条件下，自动调整重传策略，从而在保证数据可靠性的同时，保持较高的传输效率。</p><h2 id="4-快速重传">4. 快速重传</h2><p>在网络传输中，数据包可能会由于网络拥塞、丢包等原因而丢失。超时重传依赖于重传超时时间（RTO）来判断是否需要重传，这可能会导致响应延迟。而快速重传通过检测重复的确认包（ACK）来快速判断数据包的丢失，并立即触发重传，显著缩短了数据丢失的恢复时间。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612200038895.png" alt="KCP 快速重传"></p><h3 id="4-1-何时快速重传？">4.1 何时快速重传？</h3><ul><li>每个报文的 <code>fastack</code> 记录了它检测到 ACK 失序的次数，每当 KCP 收到一个编号为 sn 的 ACK 时，就会检查 snd_buf 中编号小于 sn 且未确认送达的报文，并将其 <code>fastack</code> 加 1。</li><li>可以通过配置 <code>fastresend</code> 指定失序多少次就执行快速重传。</li><li>每次调用 ikcp_flush 都会重传 snd_buf 中 <code>fastask &gt;= fastresend</code> 的报文。</li></ul><h3 id="4-2-无限快速重传吗？">4.2 无限快速重传吗？</h3><ul><li>每个报文的 <code>xmit</code> 记录它被传输的次数，可以配置 <code>fastlimit</code> 规定传输次数小于 <code>fastlimit</code> 的报文才能执行快速重传。</li></ul><h2 id="5-比较-TCP-的超时重传和快速重传">5. 比较 TCP 的超时重传和快速重传</h2><p>TCP 也实现了类似的机制，但在复杂性和应用场景上有所不同。</p><h3 id="5-1-TCP-的超时重传">5.1 TCP 的超时重传</h3><p><strong>1. RTT 估算</strong>:</p><ul><li><p>TCP 通过接收确认包来估算 RTT，并使用 RTT 的变化范围来计算 RTO。</p></li><li><p>TCP 使用 Jacobson/Karels 算法进行 RTT 估算和 RTO 计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SRTT and RTTVAR calculation</span></span><br><span class="line">RTTVAR = (<span class="number">1</span> - β) * RTTVAR + β * |RTTsample - SRTT|</span><br><span class="line">SRTT = (<span class="number">1</span> - α) * SRTT + α * RTTsample</span><br><span class="line">RTO = SRTT + <span class="number">4</span> * RTTVAR</span><br></pre></td></tr></table></figure><p>其中，SRTT 是平滑的 RTT，RTTVAR 是 RTT 的变化范围，α 和 β 是权重因子。</p></li></ul><p><strong>2. 重传策略</strong>:</p><ul><li>如果在 RTO 时间内未收到 ACK，TCP 会重传未确认的数据包。</li><li>每次重传，RTO 值会按照指数增长（指数退避算法）。</li></ul><p><strong>3. 拥塞控制</strong>:</p><ul><li>TCP 使用复杂的拥塞控制机制，如慢启动、拥塞避免等，来调整发送窗口和传输速率。</li></ul><h3 id="5-2-TCP-的快速重传">5.2 TCP 的快速重传</h3><ul><li>当接收到三个重复的 ACK 时，TCP 会立即重传丢失的数据包，而不等待 RTO 超时。</li><li>快速重传后，TCP 进入快速恢复状态，调整拥塞窗口，避免拥塞窗口过度收缩。</li></ul><h3 id="5-3-比较分析">5.3 比较分析</h3><table><thead><tr><th>特性</th><th>KCP</th><th>TCP</th></tr></thead><tbody><tr><td><strong>RTT 估算</strong></td><td>基于加权移动平均，较为简单</td><td>使用 Jacobson/Karels 算法，复杂但精确</td></tr><tr><td><strong>RTO 计算</strong></td><td>简化的计算公式</td><td>基于 RTT 的复杂计算</td></tr><tr><td><strong>重传机制</strong></td><td>超时重传和快速重传</td><td>超时重传和快速重传</td></tr><tr><td><strong>拥塞控制</strong></td><td>简单的拥塞控制，适合低延迟应用</td><td>复杂的拥塞控制，适合广泛的传输场景</td></tr><tr><td><strong>适用场景</strong></td><td>实时应用，如游戏、视频会议</td><td>通用应用，如文件传输、HTTP</td></tr><tr><td><strong>实现复杂度</strong></td><td>较为简单，易于理解和实现</td><td>复杂，需处理更多的网络状态和控制</td></tr><tr><td><strong>可靠性</strong></td><td>依赖于用户自定义的重传和控制策略</td><td>内置可靠性和流控制机制</td></tr><tr><td><strong>响应速度</strong></td><td>高效快速，适用于低延迟和高吞吐量场景</td><td>可靠但响应速度较慢，适合稳定传输场景</td></tr></tbody></table><p>KCP 和 TCP 都提供了可靠的传输机制，但它们适用于不同的应用场景。KCP 设计简单，适合对延迟敏感的实时应用，而 TCP 拥有完善的拥塞控制和可靠性机制，适合广泛的网络应用。</p><h2 id="6-拥塞控制">6. 拥塞控制</h2><p>拥塞控制是网络传输协议中的一个重要机制，用于防止发送过多的数据包导致网络拥塞。在 KCP 中，拥塞控制相对简单，主要通过发送窗口（<code>snd_wnd</code>）和拥塞窗口（<code>cwnd</code>）来管理数据发送速率。</p><h3 id="6-1-三种策略">6.1 三种策略</h3><p>KCP 有 3 种拥塞控制的策略：</p><ul><li>慢启动（slow start）</li><li>拥塞避免（congestion avoidance）</li><li>快速恢复（fast recovery）</li></ul><p><strong>慢启动</strong>：先将 cwnd 设置为 1，随后平均每经过一个 RTT 时间，<code>cwnd = cwnd * 2</code>，直到阈值 <code>ssthresh</code>。</p><p><strong>拥塞避免</strong>：cwnd 到 <code>ssthresh</code> 后，cwnd 呈<strong>线性</strong>增长。</p><p>当慢启动或者拥塞避免造成 <strong>丢包</strong> 后，就采取相应的退让策略：</p><ol><li><code>fastack &gt;= fastresend</code> -&gt; 发生快速重传：将 <code>ssthresh = cwnd / 2</code>，<code>cwnd = ssthresh + fastresend</code> 进入<strong>快恢复</strong>。</li><li><code>current &gt;= resentts</code> -&gt; 超时重传：<code>ssthresh = ssthresh / 2</code>，<code>cwnd = 1</code>，进入<strong>慢启动</strong>。</li></ol><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/kcp_7.svg" alt="拥塞控制中 cwnd 和 ssthresh 的变化情况"></p><h3 id="6-2-核心概念">6.2 核心概念</h3><p>KCP 的拥塞控制基于以下几个核心概念：</p><ul><li><strong>发送窗口 (<code>snd_wnd</code>)</strong>：表示发送端在未收到接收端确认之前，允许发送的数据包的数量。它类似于 TCP 中的发送窗口，控制了数据流的速率。</li><li><strong>接收窗口 (<code>rcv_wnd</code>)</strong>：表示接收端能够处理的最大数据包数量。发送端通过接收端的窗口大小来调整自己的发送速率。</li><li><strong>远端窗口 (<code>rmt_wnd</code>)</strong>：表示接收端的窗口大小，发送端会根据这个值调整自己的发送窗口，以避免发送的数据超出接收端的处理能力。</li><li><strong>拥塞窗口 (<code>cwnd</code>)</strong>：用于控制传输中的数据包数量。它基于网络的拥塞情况动态调整，以避免网络拥塞。</li><li><strong>慢启动阈值 (<code>ssthresh</code>)</strong>：用于确定拥塞控制的模式。当 <code>cwnd</code> 小于 <code>ssthresh</code> 时，KCP 处于慢启动模式，否则进入拥塞避免模式。</li></ul><h3 id="6-3-窗口探测（Window-Probing）">6.3 窗口探测（Window Probing）</h3><p>在某些情况下，接收端的窗口可能会被关闭（即 <code>rmt_wnd</code> 为 0），这意味着接收端无法接收任何新的数据。为了应对这种情况，KCP 实现了窗口探测机制：</p><ul><li>当 <code>rmt_wnd</code> 为 0 时，KCP 不会立即停止发送数据，而是会定期发送一个探测包，以检测接收端窗口是否已经打开。</li><li>这个探测包会触发接收端返回一个 ACK，其中包含最新的接收窗口大小信息。</li></ul><h3 id="6-4-调节和配置">6.4 调节和配置</h3><p>KCP 的拥塞控制机制提供了一些配置参数，用户可以通过调整这些参数来优化传输性能：</p><ul><li><strong><code>snd_wnd</code></strong>: 发送窗口大小，用户可以根据应用的需求调整该值，以控制数据发送的最大量。</li><li><strong><code>rcv_wnd</code></strong>: 接收窗口大小，表示接收端能够处理的最大数据包数量。</li><li><strong><code>ssthresh</code></strong>: 慢启动阈值，初始值通常设置为较大的一个常量，用户可以根据网络情况调整。</li><li><strong><code>cwnd</code></strong>: 拥塞窗口大小，初始值通常设置为 1，随传输情况动态调整。</li></ul><h2 id="7-比较-TCP-的拥塞控制">7. 比较 TCP 的拥塞控制</h2><h3 id="7-1-四个阶段">7.1 四个阶段</h3><p>TCP 拥塞控制有四个关键阶段</p><p><strong>慢启动（Slow Start）</strong>：</p><ul><li><strong>目的</strong>：快速探测网络的可用带宽。</li><li><strong>机制</strong>：当一个连接刚建立或者从丢包恢复时，<code>cwnd</code>（拥塞窗口）从一个较小的值（通常是 1 个 MSS，即最大报文段大小）开始，并以指数增长的方式增加。</li><li><strong>过程</strong>：每次收到一个 ACK，<code>cwnd</code> 增加一个 MSS，使得 <code>cwnd</code> 每 RTT 增加一倍，直到 <code>cwnd</code> 达到慢启动阈值（<code>ssthresh</code>）。</li></ul><p><strong>拥塞避免（Congestion Avoidance）</strong>:</p><ul><li><strong>目的</strong>：逐步探测网络的最大容量，并避免拥塞。</li><li><strong>机制</strong>：当 <code>cwnd</code> 达到或超过 <code>ssthresh</code> 时，TCP 进入拥塞避免阶段，此时 <code>cwnd</code> 以线性增长的方式增加。</li><li><strong>过程</strong>：每个 RTT，<code>cwnd</code> 增加 <code>1/cwnd</code> 个 MSS，这种增长方式较为保守，旨在防止过度发送导致的拥塞。</li></ul><p><strong>快速重传（Fast Retransmit）</strong>:</p><ul><li><strong>目的</strong>：快速响应丢包，提高传输效率。</li><li><strong>机制</strong>：当发送端收到三个重复的 ACK 时，立即重传被确认丢失的数据包，而不等待 RTO 超时。</li><li><strong>过程</strong>：快速重传的目的是迅速恢复丢失的数据包，从而减少因丢包导致的等待时间。</li></ul><p><strong>快速恢复（Fast Recovery）</strong>:</p><ul><li><strong>目的</strong>：在拥塞后快速恢复到适当的传输速率。</li><li><strong>机制</strong>：在快速重传后，TCP 不会直接进入慢启动，而是保持 <code>cwnd</code> 的一部分，以较快的速度恢复到拥塞避免状态。</li><li><strong>过程</strong>：将 <code>ssthresh</code> 设置为当前 <code>cwnd</code> 的一半，<code>cwnd</code> 被临时减小，然后在接收新 ACK 时快速增加 <code>cwnd</code>，直到恢复到 <code>ssthresh</code> 为止。</li></ul><h3 id="7-2-比较分析">7.2 比较分析</h3><table><thead><tr><th>特性</th><th>TCP</th><th>KCP</th></tr></thead><tbody><tr><td><strong>实现复杂度</strong></td><td>复杂，包含多个阶段和算法</td><td>简单，主要通过窗口大小控制</td></tr><tr><td><strong>拥塞检测</strong></td><td>通过 RTT 估算和 ACK 检测丢包</td><td>主要通过 ACK 和窗口大小检测丢包</td></tr><tr><td><strong>响应速度</strong></td><td>响应相对较慢，适合稳定传输</td><td>响应较快，适合实时性高的传输</td></tr><tr><td><strong>适应性</strong></td><td>能适应广泛的网络条件</td><td>适应性较好，但更适合低延迟网络</td></tr><tr><td><strong>配置灵活性</strong></td><td>较为固定，依赖于系统配置和优化</td><td>提供更多的配置选项，用户可根据需求调整</td></tr><tr><td><strong>应用场景</strong></td><td>适用于各种需要可靠传输的应用</td><td>适用于实时性要求高的应用，如游戏和视频会议</td></tr><tr><td><strong>窗口调整</strong></td><td>慢启动、拥塞避免、快速重传、快速恢复等机制</td><td>主要通过发送窗口和拥塞窗口调整</td></tr><tr><td><strong>丢包响应</strong></td><td>丢包时通过减小 <code>cwnd</code> 和 <code>ssthresh</code> 来调整</td><td>丢包时迅速调整 <code>cwnd</code> 和重传</td></tr><tr><td><strong>拥塞控制策略</strong></td><td>慢启动、拥塞避免、快速重传、快速恢复等多种策略</td><td>主要通过调整 <code>cwnd</code> 和 <code>ssthresh</code> 进行简单控制</td></tr><tr><td><strong>优点</strong></td><td>稳定可靠、机制全面、应用广泛</td><td>实现简单、响应快、灵活性高、适合实时应用</td></tr><tr><td><strong>缺点</strong></td><td>复杂、响应慢、初始阶段保守</td><td>无法应对更加复杂的网络状况、应用场景有限</td></tr></tbody></table><p>TCP 和 KCP 都有各自的拥塞控制机制，适用于不同的应用场景。TCP 提供了复杂而全面的拥塞控制，适合于各种网络条件下的可靠传输，而 KCP 提供了简单高效的控制机制，适合于低延迟和高响应速度的实时应用。选择使用哪种协议取决于具体的应用需求和网络环境。</p><h1>源码分析</h1><h2 id="1-核心数据结构">1. 核心数据结构</h2><h3 id="1-1-IKCPSEG-报文段结构">1.1 IKCPSEG 报文段结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPSEG</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">node</span>;</span>  <span class="comment">// 链表节点</span></span><br><span class="line">    IUINT32 conv;     <span class="comment">// 会话ID</span></span><br><span class="line">    IUINT32 cmd;      <span class="comment">// 命令类型</span></span><br><span class="line">    IUINT32 frg;      <span class="comment">// 分片序号</span></span><br><span class="line">    IUINT32 wnd;      <span class="comment">// 窗口大小</span></span><br><span class="line">    IUINT32 ts;       <span class="comment">// 时间戳</span></span><br><span class="line">    IUINT32 sn;       <span class="comment">// 序列号</span></span><br><span class="line">    IUINT32 una;      <span class="comment">// 待接收的下一个包序号</span></span><br><span class="line">    IUINT32 len;      <span class="comment">// 数据长度</span></span><br><span class="line">    IUINT32 resendts; <span class="comment">// 重传时间戳</span></span><br><span class="line">    IUINT32 rto;      <span class="comment">// 超时重传时间</span></span><br><span class="line">    IUINT32 fastack;  <span class="comment">// 快速重传计数器</span></span><br><span class="line">    IUINT32 xmit;     <span class="comment">// 传输次数</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">1</span>];     <span class="comment">// 数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-IKCPCB-控制块">1.2 IKCPCB 控制块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPCB</span> &#123;</span></span><br><span class="line">    <span class="comment">// === 基础配置 ===</span></span><br><span class="line">    IUINT32 conv;          <span class="comment">// 会话ID，用于标识一个会话</span></span><br><span class="line">    IUINT32 mtu;          <span class="comment">// 最大传输单元，默认1400字节</span></span><br><span class="line">    IUINT32 mss;          <span class="comment">// 最大报文段大小，默认mtu-24字节</span></span><br><span class="line">    IUINT32 state;        <span class="comment">// 连接状态，0=正常，-1=断开</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 发送和接收序号 ===</span></span><br><span class="line">    IUINT32 snd_una;      <span class="comment">// 第一个未确认的包序号</span></span><br><span class="line">    IUINT32 snd_nxt;      <span class="comment">// 下一个待发送的包序号</span></span><br><span class="line">    IUINT32 rcv_nxt;      <span class="comment">// 待接收的下一个包序号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 时间戳相关 ===</span></span><br><span class="line">    IUINT32 ts_recent;    <span class="comment">// 最近一次收到包的时间戳</span></span><br><span class="line">    IUINT32 ts_lastack;   <span class="comment">// 最近一次收到ACK的时间戳</span></span><br><span class="line">    IUINT32 ssthresh;     <span class="comment">// 慢启动阈值，默认为IKCP_THRESH_INIT(2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === RTT相关 ===</span></span><br><span class="line">    IINT32 rx_rttval;     <span class="comment">// RTT的变化量</span></span><br><span class="line">    IINT32 rx_srtt;       <span class="comment">// 平滑后的RTT</span></span><br><span class="line">    IINT32 rx_rto;        <span class="comment">// 超时重传时间，初始为IKCP_RTO_DEF(200ms)</span></span><br><span class="line">    IINT32 rx_minrto;     <span class="comment">// 最小重传超时时间，默认为IKCP_RTO_MIN(100ms)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 窗口相关 ===</span></span><br><span class="line">    IUINT32 snd_wnd;      <span class="comment">// 发送窗口大小，默认32</span></span><br><span class="line">    IUINT32 rcv_wnd;      <span class="comment">// 接收窗口大小，默认128</span></span><br><span class="line">    IUINT32 rmt_wnd;      <span class="comment">// 远端窗口大小，默认128</span></span><br><span class="line">    IUINT32 cwnd;         <span class="comment">// 拥塞窗口大小，初始为0</span></span><br><span class="line">    IUINT32 probe;        <span class="comment">// 探测标志，用于窗口探测</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 时间相关 ===</span></span><br><span class="line">    IUINT32 current;      <span class="comment">// 当前时间</span></span><br><span class="line">    IUINT32 interval;     <span class="comment">// 内部更新时间间隔，默认100ms</span></span><br><span class="line">    IUINT32 ts_flush;     <span class="comment">// 下次刷新时间</span></span><br><span class="line">    IUINT32 xmit;         <span class="comment">// 总重传次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 队列计数器 ===</span></span><br><span class="line">    IUINT32 nrcv_buf;     <span class="comment">// 接收缓存中的包数量</span></span><br><span class="line">    IUINT32 nsnd_buf;     <span class="comment">// 发送缓存中的包数量</span></span><br><span class="line">    IUINT32 nrcv_que;     <span class="comment">// 接收队列中的包数量</span></span><br><span class="line">    IUINT32 nsnd_que;     <span class="comment">// 发送队列中的包数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 配置标志 ===</span></span><br><span class="line">    IUINT32 nodelay;      <span class="comment">// 是否启用nodelay模式，0=不启用</span></span><br><span class="line">    IUINT32 updated;      <span class="comment">// 是否调用过update</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 探测相关 ===</span></span><br><span class="line">    IUINT32 ts_probe;     <span class="comment">// 下次探测时间</span></span><br><span class="line">    IUINT32 probe_wait;   <span class="comment">// 探测等待时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 链路控制 ===</span></span><br><span class="line">    IUINT32 dead_link;    <span class="comment">// 最大重传次数，默认为IKCP_DEADLINK(20)</span></span><br><span class="line">    IUINT32 incr;         <span class="comment">// 可发送的最大数据量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 数据队列 ===</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_queue</span>;</span>  <span class="comment">// 发送队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_queue</span>;</span>  <span class="comment">// 接收队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">snd_buf</span>;</span>    <span class="comment">// 发送缓存</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> <span class="title">rcv_buf</span>;</span>    <span class="comment">// 接收缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === ACK相关 ===</span></span><br><span class="line">    IUINT32 *acklist;     <span class="comment">// ACK列表</span></span><br><span class="line">    IUINT32 ackcount;     <span class="comment">// ACK数量</span></span><br><span class="line">    IUINT32 ackblock;     <span class="comment">// ACK列表大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 用户相关 ===</span></span><br><span class="line">    <span class="type">void</span> *user;           <span class="comment">// 用户数据指针</span></span><br><span class="line">    <span class="type">char</span> *buffer;         <span class="comment">// 临时缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 快速重传相关 ===</span></span><br><span class="line">    <span class="type">int</span> fastresend;       <span class="comment">// 触发快速重传的重复ACK个数</span></span><br><span class="line">    <span class="type">int</span> fastlimit;        <span class="comment">// 快速重传次数限制，默认IKCP_FASTACK_LIMIT(5)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 其他配置 ===</span></span><br><span class="line">    <span class="type">int</span> nocwnd;          <span class="comment">// 是否关闭拥塞控制，0=不关闭</span></span><br><span class="line">    <span class="type">int</span> stream;          <span class="comment">// 是否为流模式，0=消息模式(默认)，1=流模式</span></span><br><span class="line">    <span class="type">int</span> logmask;        <span class="comment">// 日志掩码，控制日志输出级别</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 回调函数 ===</span></span><br><span class="line">    <span class="comment">// 数据输出回调，用于发送数据</span></span><br><span class="line">    <span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line">    <span class="comment">// 日志输出回调</span></span><br><span class="line">    <span class="type">void</span> (*writelog)(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">log</span>, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体可以大致分为几个主要部分：</p><ul><li>基础配置：包含基本的会话标识和传输单元大小设置</li><li>序号追踪：用于追踪发送和接收的包序号</li><li>时间管理：包含各种时间戳和定时器</li><li>窗口控制：实现流量控制和拥塞控制</li><li>队列管理：管理数据的发送和接收</li><li>ACK 处理：处理确认包</li><li>配置选项：各种功能开关和参数设置</li><li>回调函数：用于数据输出和日志记录</li></ul><h2 id="2-核心函数">2. 核心函数</h2><p>在进入具体的核心函数分析之前，需要先点明 2 点，<code>kcp</code> 的实现者期望其尽可能地简单和减少依赖，所以数据的输出甚至是当前时间都是由使用者来设置的，即 <code>kcp</code> 本身是不依赖于机器时钟的。具体体现在下面 2 个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// set output callback, which will be invoked by kcp</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_setoutput</span><span class="params">(ikcpcb *kcp, <span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">ikcpcb *kcp, <span class="type">void</span> *user))</span></span><br><span class="line">&#123;</span><br><span class="line">kcp-&gt;output = output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// update state (call it repeatedly, every 10ms-100ms), or you can ask</span></span><br><span class="line"><span class="comment">// ikcp_check when to call it again (without ikcp_input/_send calling).</span></span><br><span class="line"><span class="comment">// &#x27;current&#x27; - current timestamp in millisec.</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_update</span><span class="params">(ikcpcb *kcp, IUINT32 current)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-ikcp-send-发送数据">2.1 ikcp_send 发送数据</h3><p><code>ikcp_send</code> 是应用层接口，负责将用户数据分片并加入到发送队列（<code>snd_queue</code>）。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241129154115523.png" alt="ikcp_send"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// user/upper level send, returns below zero for error</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_send</span><span class="params">(ikcpcb *kcp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">IKCPSEG *seg;</span><br><span class="line"><span class="type">int</span> count, i;</span><br><span class="line"><span class="type">int</span> sent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mtu: 最大传输单元</span></span><br><span class="line"><span class="comment">// mss: 最大报文段大小</span></span><br><span class="line"><span class="comment">// mss = mtu - 包头长度(24)</span></span><br><span class="line">assert(kcp-&gt;mss &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// append to previous segment in streaming mode (if possible)</span></span><br><span class="line"><span class="comment">// 如果是流模式，则将数据追加到前一个分段中（如果可能）</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;stream != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 如果当前发送队列不为空，且前一个分段未满，则将数据追加到前一个分段中</span></span><br><span class="line"><span class="keyword">if</span> (!iqueue_is_empty(&amp;kcp-&gt;snd_queue)) &#123;</span><br><span class="line">IKCPSEG *old = iqueue_entry(kcp-&gt;snd_queue.prev, IKCPSEG, node);</span><br><span class="line"><span class="keyword">if</span> (old-&gt;len &lt; kcp-&gt;mss) &#123;</span><br><span class="line"><span class="type">int</span> capacity = kcp-&gt;mss - old-&gt;len;</span><br><span class="line"><span class="type">int</span> extend = (len &lt; capacity)? len : capacity;</span><br><span class="line">seg = ikcp_segment_new(kcp, old-&gt;len + extend);</span><br><span class="line">assert(seg);</span><br><span class="line"><span class="keyword">if</span> (seg == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将新的 seg-&gt;node 放入 snd_queue 中等待发送</span></span><br><span class="line">iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;snd_queue);</span><br><span class="line"><span class="comment">// 把上一个报文的数据拷贝过来</span></span><br><span class="line"><span class="built_in">memcpy</span>(seg-&gt;data, old-&gt;data, old-&gt;len);</span><br><span class="line"><span class="keyword">if</span> (buffer) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(seg-&gt;data + old-&gt;len, buffer, extend);</span><br><span class="line">buffer += extend;</span><br><span class="line">&#125;</span><br><span class="line">seg-&gt;len = old-&gt;len + extend;</span><br><span class="line">seg-&gt;frg = <span class="number">0</span>;</span><br><span class="line">len -= extend;</span><br><span class="line">iqueue_del_init(&amp;old-&gt;node);</span><br><span class="line"><span class="comment">// 释放之前老数据的 kcp node</span></span><br><span class="line">ikcp_segment_delete(kcp, old);</span><br><span class="line">sent = extend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> sent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 非流模式，不追加到上一个报文后面</span></span><br><span class="line"><span class="comment">// 2. 流模式，但是上一个报文已满，则创建新的报文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算需要的报文数量，kcp 会对数据进行分段传输</span></span><br><span class="line"><span class="keyword">if</span> (len &lt;= (<span class="type">int</span>)kcp-&gt;mss) count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> count = (len + kcp-&gt;mss - <span class="number">1</span>) / kcp-&gt;mss;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收窗口位置不够，则暂停发送</span></span><br><span class="line"><span class="keyword">if</span> (count &gt;= (<span class="type">int</span>)IKCP_WND_RCV) &#123;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;stream != <span class="number">0</span> &amp;&amp; sent &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> sent;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送所有的报文段</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"><span class="type">int</span> size = len &gt; (<span class="type">int</span>)kcp-&gt;mss ? (<span class="type">int</span>)kcp-&gt;mss : len;</span><br><span class="line">seg = ikcp_segment_new(kcp, size);</span><br><span class="line">assert(seg);</span><br><span class="line"><span class="keyword">if</span> (seg == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (buffer &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(seg-&gt;data, buffer, size);</span><br><span class="line">&#125;</span><br><span class="line">seg-&gt;len = size;</span><br><span class="line">seg-&gt;frg = (kcp-&gt;stream == <span class="number">0</span>)? (count - i - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">iqueue_init(&amp;seg-&gt;node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将报文段放入 snd_queue 中</span></span><br><span class="line">iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;snd_queue);</span><br><span class="line">kcp-&gt;nsnd_que++;</span><br><span class="line"><span class="keyword">if</span> (buffer) &#123;</span><br><span class="line">buffer += size;</span><br><span class="line">&#125;</span><br><span class="line">len -= size;</span><br><span class="line">sent += size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-ikcp-input-接收数据">2.2 ikcp_input 接收数据</h3><p><code>ikcp_input</code> 负责处理从网络接收到的原始 KCP 数据包，它会处理协议层面的数据，包括 ACK、窗口控制等协议信息，并将接收到的数据放入 KCP 的内部接收缓冲区（<code>rcv_buf</code> 和 <code>rcv_queue</code>）。</p><h3 id="2-3-ikcp-recv-获取数据">2.3 ikcp_recv 获取数据</h3><p><code>ikcp_recv</code> 是应用层函数，供上层应用调用以获取完整的消息数据，它从 KCP 的接收队列(rcv_queue)中读取已经排序好的数据，处理分片重组，确保返回完整的消息。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241129163431276.png" alt="ikcp_recv"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// user/upper level recv: returns size, returns below zero for EAGAIN</span></span><br><span class="line"><span class="comment">// 从 rcv_queue 中获取数据</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ikcp_recv</span><span class="params">(ikcpcb *kcp, <span class="type">char</span> *buffer, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="type">int</span> ispeek = (len &lt; <span class="number">0</span>)? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> peeksize;</span><br><span class="line"><span class="type">int</span> recover = <span class="number">0</span>;</span><br><span class="line">IKCPSEG *seg;</span><br><span class="line">assert(kcp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 rcv_queue 为空，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (iqueue_is_empty(&amp;kcp-&gt;rcv_queue))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 len &lt; 0，则说明是 peek 操作，准备只查看数据</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">0</span>) len = -len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 rcv_queue 中数据的大小</span></span><br><span class="line">peeksize = ikcp_peeksize(kcp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法获得大小，返回 -2</span></span><br><span class="line"><span class="keyword">if</span> (peeksize &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据过大，返回 -3</span></span><br><span class="line"><span class="keyword">if</span> (peeksize &gt; len)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nrcv_que: rcv_queue 的长度</span></span><br><span class="line"><span class="comment">// rcv_wnd: 接收窗口的大小</span></span><br><span class="line"><span class="comment">// 如果 nrcv_que &gt;= rcv_wnd，则需要进行快恢复</span></span><br><span class="line"><span class="comment">// 因为 nrcv_que &gt;= rcv_wnd，说明接收窗口已经满了，</span></span><br><span class="line"><span class="comment">// 这个时候需要发送 IKCP_CMD_WINS 告诉发送方窗口大小，</span></span><br><span class="line"><span class="comment">// 这个时候发送方需要进行快恢复，减小数据传输，以尽快释放接收窗口</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;nrcv_que &gt;= kcp-&gt;rcv_wnd)</span><br><span class="line">recover = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge fragment</span></span><br><span class="line"><span class="comment">// 将多个片段合并成一个完整的片段</span></span><br><span class="line"><span class="comment">// 合并后，将合并后的片段从 rcv_queue 中删除</span></span><br><span class="line"><span class="keyword">for</span> (len = <span class="number">0</span>, p = kcp-&gt;rcv_queue.next; p != &amp;kcp-&gt;rcv_queue; ) &#123;</span><br><span class="line"><span class="type">int</span> fragment;</span><br><span class="line">seg = iqueue_entry(p, IKCPSEG, node);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buffer) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(buffer, seg-&gt;data, seg-&gt;len);</span><br><span class="line">buffer += seg-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">len += seg-&gt;len;</span><br><span class="line">fragment = seg-&gt;frg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ikcp_canlog(kcp, IKCP_LOG_RECV)) &#123;</span><br><span class="line">ikcp_log(kcp, IKCP_LOG_RECV, <span class="string">&quot;recv sn=%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)seg-&gt;sn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ispeek == <span class="number">0</span>) &#123;</span><br><span class="line">iqueue_del(&amp;seg-&gt;node);</span><br><span class="line">ikcp_segment_delete(kcp, seg);</span><br><span class="line">kcp-&gt;nrcv_que--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fragment == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(len == peeksize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// move available data from rcv_buf -&gt; rcv_queue</span></span><br><span class="line"><span class="comment">// 尝试将 rcv_buf 中编号连续的数据，移动到 rcv_queue 中</span></span><br><span class="line"><span class="comment">// 移动后，将移动的数据从 rcv_buf 中删除</span></span><br><span class="line"><span class="keyword">while</span> (! iqueue_is_empty(&amp;kcp-&gt;rcv_buf)) &#123;</span><br><span class="line">seg = iqueue_entry(kcp-&gt;rcv_buf.next, IKCPSEG, node);</span><br><span class="line"><span class="keyword">if</span> (seg-&gt;sn == kcp-&gt;rcv_nxt &amp;&amp; kcp-&gt;nrcv_que &lt; kcp-&gt;rcv_wnd) &#123;</span><br><span class="line">iqueue_del(&amp;seg-&gt;node);</span><br><span class="line">kcp-&gt;nrcv_buf--;</span><br><span class="line">iqueue_add_tail(&amp;seg-&gt;node, &amp;kcp-&gt;rcv_queue);</span><br><span class="line">kcp-&gt;nrcv_que++;</span><br><span class="line">kcp-&gt;rcv_nxt++;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快恢复</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;nrcv_que &lt; kcp-&gt;rcv_wnd &amp;&amp; recover) &#123;</span><br><span class="line"><span class="comment">// 在ikcp_flush 中返回 IKCP_CMD_WINS</span></span><br><span class="line"><span class="comment">// 通知本段窗口大小给对端</span></span><br><span class="line">kcp-&gt;probe |= IKCP_ASK_TELL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-ikcp-update-定时时钟">2.4 ikcp_update 定时时钟</h3><p>前面我们看了 <code>ikcp_send</code> 、<code>ikcp_input</code> 和 <code>ikcp_recv</code> 三个核心流程的函数，其中的一些细节，你可以回到本文前面的「原理分析」再对照源码仔细阅读。</p><p>在前面的原理分析中，我们提到，为了提高传输和处理数据的效率，<code>kcp</code> 设计了队列和缓冲区，同时为了实现可靠性，<code>kcp</code> 也提供了 <code>ACK</code> 和重试、拥塞控制等机制，这些事情都是周期定时去处理的。这里是由 <code>ikcp_update</code> 函数去处理的。</p><p><code>ikcp_update</code> 是 KCP 的定时器函数，负责以固定间隔调用 <code>ikcp_flush</code> 处理数据发送和协议更新，是 KCP 的&quot;心跳&quot;机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// update state (call it repeatedly, every 10ms-100ms), or you can ask</span></span><br><span class="line"><span class="comment">// ikcp_check when to call it again (without ikcp_input/_send calling).</span></span><br><span class="line"><span class="comment">// &#x27;current&#x27; - current timestamp in millisec.</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ikcp_update</span><span class="params">(ikcpcb *kcp, IUINT32 current)</span></span><br><span class="line">&#123;</span><br><span class="line">IINT32 slap;</span><br><span class="line"></span><br><span class="line">kcp-&gt;current = current;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;updated == <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;updated = <span class="number">1</span>;</span><br><span class="line">kcp-&gt;ts_flush = kcp-&gt;current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算间隔</span></span><br><span class="line">slap = _itimediff(kcp-&gt;current, kcp-&gt;ts_flush);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slap &gt;= <span class="number">10000</span> || slap &lt; <span class="number">-10000</span>) &#123;</span><br><span class="line">kcp-&gt;ts_flush = kcp-&gt;current;</span><br><span class="line">slap = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 达到调用间隔，则执行 ikcp_flush 进行接收数据或发送数据</span></span><br><span class="line"><span class="keyword">if</span> (slap &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;ts_flush += kcp-&gt;interval;</span><br><span class="line"><span class="keyword">if</span> (_itimediff(kcp-&gt;current, kcp-&gt;ts_flush) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;ts_flush = kcp-&gt;current + kcp-&gt;interval;</span><br><span class="line">&#125;</span><br><span class="line">ikcp_flush(kcp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很简单，根据注释所说，通常情况下会每 <code>10ms~100ms</code> 执行一次，然后核心是去调用 <code>ikcp_flush</code> 函数，所有的逻辑都在里面。</p><h3 id="2-5-ikcp-flush-定时处理">2.5 ikcp_flush 定时处理</h3><p>如上所述，<code>ikcp_flush</code> 是 KCP 的核心发送函数，负责将发送队列 <code>snd_queue</code> 中的数据移入发送缓存 <code>snd_buf</code> 并通过 <code>output</code> 回调发送出去，同时处理 ACK 发送、快速重传、超时重传和窗口探测等协议细节。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241129170905325.png" alt="ikcp_flush"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ikcp_flush</span><span class="params">(ikcpcb *kcp)</span></span><br><span class="line">&#123;</span><br><span class="line">IUINT32 current = kcp-&gt;current;<span class="comment">// 当前时间</span></span><br><span class="line"><span class="type">char</span> *buffer = kcp-&gt;buffer;<span class="comment">// 临时缓冲区</span></span><br><span class="line"><span class="type">char</span> *ptr = buffer;</span><br><span class="line"><span class="type">int</span> count, size, i;</span><br><span class="line">IUINT32 resent, cwnd;</span><br><span class="line">IUINT32 rtomin;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IQUEUEHEAD</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="type">int</span> change = <span class="number">0</span>;<span class="comment">// 是否执行过快速重传</span></span><br><span class="line"><span class="type">int</span> lost = <span class="number">0</span>;<span class="comment">// 是否执行过超时重传</span></span><br><span class="line">IKCPSEG seg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否已调用 ikcp_update</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;updated == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个段用于构建各种控制包</span></span><br><span class="line">seg.conv = kcp-&gt;conv;  <span class="comment">// 连接标识</span></span><br><span class="line">seg.cmd = IKCP_CMD_ACK;<span class="comment">// 报文类型：IKCP_CMD_ACK 表示确认报文</span></span><br><span class="line">seg.frg = <span class="number">0</span>;<span class="comment">// 分片数量，表示随后还有多少个报文属于同一个包</span></span><br><span class="line">seg.wnd = ikcp_wnd_unused(kcp);<span class="comment">// 发送方剩余接收窗口的大小</span></span><br><span class="line">seg.una = kcp-&gt;rcv_nxt;<span class="comment">// 发送方的接收缓冲区中最小还未收到的报文段的编号，也就是说，编号比它小的报文段都已全部接收</span></span><br><span class="line">seg.len = <span class="number">0</span>;<span class="comment">// 数据段长度</span></span><br><span class="line">seg.sn = <span class="number">0</span>;<span class="comment">// 报文编号</span></span><br><span class="line">seg.ts = <span class="number">0</span>;<span class="comment">// 时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// flush acknowledges</span></span><br><span class="line"><span class="comment">// ① 发送 ACK 队列中的所有 ACK</span></span><br><span class="line">count = kcp-&gt;ackcount;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line"><span class="comment">// buffer 中累计的数据将要超过 mtu 的时候</span></span><br><span class="line"><span class="comment">// 就调用 ikcp_output 将数据发送出去</span></span><br><span class="line"><span class="keyword">if</span> (size + (<span class="type">int</span>)IKCP_OVERHEAD &gt; (<span class="type">int</span>)kcp-&gt;mtu) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">ptr = buffer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 ACK 列表中取出 sn(报文编号)和 ts(时间戳)</span></span><br><span class="line">ikcp_ack_get(kcp, i, &amp;seg.sn, &amp;seg.ts);</span><br><span class="line"><span class="comment">// 将 ACK 报文写入 buffer</span></span><br><span class="line">ptr = ikcp_encode_seg(ptr, &amp;seg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ② ACK 队列已清空</span></span><br><span class="line">kcp-&gt;ackcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// probe window size (if remote window size equals zero)</span></span><br><span class="line"><span class="comment">// 对端剩余接收窗口大小为 0，则意味着可能需要发送窗口探测报文：IKCP_CMD_WASK</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;rmt_wnd == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 根据 ts_probe 和 probe_wait 确定当前时刻是否需要发送探测报文</span></span><br><span class="line"><span class="comment">// probe_wait: 等待发送探测报文的时间，IKCP_PROBE_INIT=7s, IKCP_PROBE_LIMIT=</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe_wait == <span class="number">0</span>) &#123;</span><br><span class="line">kcp-&gt;probe_wait = IKCP_PROBE_INIT; <span class="comment">// 7s 后去发探测报文</span></span><br><span class="line">kcp-&gt;ts_probe = kcp-&gt;current + kcp-&gt;probe_wait;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (_itimediff(kcp-&gt;current, kcp-&gt;ts_probe) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe_wait &lt; IKCP_PROBE_INIT)</span><br><span class="line">kcp-&gt;probe_wait = IKCP_PROBE_INIT;</span><br><span class="line">kcp-&gt;probe_wait += kcp-&gt;probe_wait / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe_wait &gt; IKCP_PROBE_LIMIT)</span><br><span class="line">kcp-&gt;probe_wait = IKCP_PROBE_LIMIT;</span><br><span class="line">kcp-&gt;ts_probe = kcp-&gt;current + kcp-&gt;probe_wait;</span><br><span class="line">kcp-&gt;probe |= IKCP_ASK_SEND; <span class="comment">// 设置是否需要去发送 IKCP_ASK_SEND</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kcp-&gt;ts_probe = <span class="number">0</span>;</span><br><span class="line">kcp-&gt;probe_wait = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flush window probing commands</span></span><br><span class="line"><span class="comment">// ③ 如果需要，则发送窗口探测报文：IKCP_CMD_WASK</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe &amp; IKCP_ASK_SEND) &#123;</span><br><span class="line">seg.cmd = IKCP_CMD_WASK;</span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line"><span class="keyword">if</span> (size + (<span class="type">int</span>)IKCP_OVERHEAD &gt; (<span class="type">int</span>)kcp-&gt;mtu) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">ptr = buffer;</span><br><span class="line">&#125;</span><br><span class="line">ptr = ikcp_encode_seg(ptr, &amp;seg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flush window probing commands</span></span><br><span class="line"><span class="comment">// ④ 如果需要，则发送窗口通知报文：IKCP_CMD_WINS</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;probe &amp; IKCP_ASK_TELL) &#123;</span><br><span class="line">seg.cmd = IKCP_CMD_WINS;</span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line"><span class="keyword">if</span> (size + (<span class="type">int</span>)IKCP_OVERHEAD &gt; (<span class="type">int</span>)kcp-&gt;mtu) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">ptr = buffer;</span><br><span class="line">&#125;</span><br><span class="line">ptr = ikcp_encode_seg(ptr, &amp;seg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kcp-&gt;probe = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate window size</span></span><br><span class="line"><span class="comment">// ⑤ 计算当前窗口大小</span></span><br><span class="line">cwnd = _imin_(kcp-&gt;snd_wnd, kcp-&gt;rmt_wnd);</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;nocwnd == <span class="number">0</span>) cwnd = _imin_(kcp-&gt;cwnd, cwnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// move data from snd_queue to snd_buf</span></span><br><span class="line"><span class="comment">// 5.1 如果符合发送的条件，则创建新的 newseg 并放入 snd_buf 的尾部</span></span><br><span class="line"><span class="keyword">while</span> (_itimediff(kcp-&gt;snd_nxt, kcp-&gt;snd_una + cwnd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">IKCPSEG *newseg;</span><br><span class="line"><span class="keyword">if</span> (iqueue_is_empty(&amp;kcp-&gt;snd_queue)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">newseg = iqueue_entry(kcp-&gt;snd_queue.next, IKCPSEG, node);</span><br><span class="line"></span><br><span class="line">iqueue_del(&amp;newseg-&gt;node);</span><br><span class="line">iqueue_add_tail(&amp;newseg-&gt;node, &amp;kcp-&gt;snd_buf);</span><br><span class="line">kcp-&gt;nsnd_que--;</span><br><span class="line">kcp-&gt;nsnd_buf++;</span><br><span class="line"></span><br><span class="line">newseg-&gt;conv = kcp-&gt;conv;</span><br><span class="line">newseg-&gt;cmd = IKCP_CMD_PUSH;</span><br><span class="line">newseg-&gt;wnd = seg.wnd;</span><br><span class="line">newseg-&gt;ts = current;</span><br><span class="line">newseg-&gt;sn = kcp-&gt;snd_nxt++;</span><br><span class="line">newseg-&gt;una = kcp-&gt;rcv_nxt;</span><br><span class="line">newseg-&gt;resendts = current;</span><br><span class="line">newseg-&gt;rto = kcp-&gt;rx_rto;</span><br><span class="line">newseg-&gt;fastack = <span class="number">0</span>;</span><br><span class="line">newseg-&gt;xmit = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate resent</span></span><br><span class="line"><span class="comment">// 失序多少次就快速重传。如果 fastresend 大于 0，则取其值；否则，设为最大值 0xffffffff。</span></span><br><span class="line">resent = (kcp-&gt;fastresend &gt; <span class="number">0</span>)? (IUINT32)kcp-&gt;fastresend : <span class="number">0xffffffff</span>;</span><br><span class="line"><span class="comment">// 最小超时重传时间。如果 nodelay 为 0，则为 rx_rto 的八分之一，否则为 0。</span></span><br><span class="line">rtomin = (kcp-&gt;nodelay == <span class="number">0</span>)? (kcp-&gt;rx_rto &gt;&gt; <span class="number">3</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flush data segments</span></span><br><span class="line"><span class="keyword">for</span> (p = kcp-&gt;snd_buf.next; p != &amp;kcp-&gt;snd_buf; p = p-&gt;next) &#123;</span><br><span class="line"><span class="comment">// 从 snd_buf 取出一个报文</span></span><br><span class="line">IKCPSEG *segment = iqueue_entry(p, IKCPSEG, node);</span><br><span class="line"><span class="type">int</span> needsend = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 条件1：第一次发送的报文，直接发送</span></span><br><span class="line"><span class="keyword">if</span> (segment-&gt;xmit == <span class="number">0</span>) &#123;   <span class="comment">//  该报文的 xmit 传输次数</span></span><br><span class="line">needsend = <span class="number">1</span>;</span><br><span class="line">segment-&gt;xmit++;</span><br><span class="line">segment-&gt;rto = kcp-&gt;rx_rto;</span><br><span class="line">segment-&gt;resendts = current + segment-&gt;rto + rtomin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_itimediff(current, segment-&gt;resendts) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 条件2：且重传时间到了，则重传</span></span><br><span class="line">needsend = <span class="number">1</span>;</span><br><span class="line">segment-&gt;xmit++;</span><br><span class="line">kcp-&gt;xmit++;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;nodelay == <span class="number">0</span>) &#123;</span><br><span class="line">segment-&gt;rto += _imax_(segment-&gt;rto, (IUINT32)kcp-&gt;rx_rto);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">IINT32 step = (kcp-&gt;nodelay &lt; <span class="number">2</span>)?</span><br><span class="line">((IINT32)(segment-&gt;rto)) : kcp-&gt;rx_rto;</span><br><span class="line">segment-&gt;rto += step / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">segment-&gt;resendts = current + segment-&gt;rto;</span><br><span class="line">lost = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (segment-&gt;fastack &gt;= resent) &#123;</span><br><span class="line"><span class="comment">// 条件3：达到快速重传次数，则重传</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)segment-&gt;xmit &lt;= kcp-&gt;fastlimit ||</span><br><span class="line">kcp-&gt;fastlimit &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">needsend = <span class="number">1</span>;</span><br><span class="line">segment-&gt;xmit++;</span><br><span class="line">segment-&gt;fastack = <span class="number">0</span>;</span><br><span class="line">segment-&gt;resendts = current + segment-&gt;rto;</span><br><span class="line">change++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needsend) &#123;</span><br><span class="line"><span class="type">int</span> need;</span><br><span class="line">segment-&gt;ts = current;</span><br><span class="line">segment-&gt;wnd = seg.wnd;</span><br><span class="line">segment-&gt;una = kcp-&gt;rcv_nxt;</span><br><span class="line"></span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line">need = IKCP_OVERHEAD + segment-&gt;len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size + need &gt; (<span class="type">int</span>)kcp-&gt;mtu) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">ptr = buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ptr = ikcp_encode_seg(ptr, segment);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (segment-&gt;len &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(ptr, segment-&gt;data, segment-&gt;len);</span><br><span class="line">ptr += segment-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果某个数据包的重传次数超过阈值，则标记连接断开。</span></span><br><span class="line"><span class="keyword">if</span> (segment-&gt;xmit &gt;= kcp-&gt;dead_link) &#123;</span><br><span class="line">kcp-&gt;state = (IUINT32)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flash remain segments</span></span><br><span class="line">size = (<span class="type">int</span>)(ptr - buffer);</span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ikcp_output(kcp, buffer, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update ssthresh</span></span><br><span class="line"><span class="comment">// 1. 如果发生了快速重传，让 ssthresh 减半，进入快恢复</span></span><br><span class="line"><span class="keyword">if</span> (change) &#123;</span><br><span class="line">IUINT32 inflight = kcp-&gt;snd_nxt - kcp-&gt;snd_una;</span><br><span class="line">kcp-&gt;ssthresh = inflight / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;ssthresh &lt; IKCP_THRESH_MIN)</span><br><span class="line">kcp-&gt;ssthresh = IKCP_THRESH_MIN;</span><br><span class="line">kcp-&gt;cwnd = kcp-&gt;ssthresh + resent;</span><br><span class="line">kcp-&gt;incr = kcp-&gt;cwnd * kcp-&gt;mss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果发生了超时重传，则让 ssthresh 减半，然后 cwnd = 1，进入慢启动</span></span><br><span class="line"><span class="keyword">if</span> (lost) &#123;</span><br><span class="line">kcp-&gt;ssthresh = cwnd / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;ssthresh &lt; IKCP_THRESH_MIN)</span><br><span class="line">kcp-&gt;ssthresh = IKCP_THRESH_MIN;</span><br><span class="line">kcp-&gt;cwnd = <span class="number">1</span>;</span><br><span class="line">kcp-&gt;incr = kcp-&gt;mss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兜底，cwnd 至少为 1</span></span><br><span class="line"><span class="keyword">if</span> (kcp-&gt;cwnd &lt; <span class="number">1</span>) &#123;</span><br><span class="line">kcp-&gt;cwnd = <span class="number">1</span>;</span><br><span class="line">kcp-&gt;incr = kcp-&gt;mss;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>参考</h1><ul><li><a href="https://github.com/skywind3000/kcp">KCP repo</a></li><li><a href="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP 协议的原理和实现</a></li></ul>]]></content>
    
    
    <summary type="html">本文详细介绍了游戏开发中常用的网络协议 KCP 的底层原理和源码实现。通过大量图示和原理总结,帮助读者深入理解 KCP 协议的工作机制，包括其快速重传、选择性确认、流量控制等核心特性。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="KCP" scheme="https://hedon.top/tags/KCP/"/>
    
    <category term="TCP" scheme="https://hedon.top/tags/TCP/"/>
    
    <category term="网络" scheme="https://hedon.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
