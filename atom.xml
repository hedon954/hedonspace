<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HedonSpace</title>
  
  
  <link href="https://hedon.top/atom.xml" rel="self"/>
  
  <link href="https://hedon.top/"/>
  <updated>2024-05-28T07:42:52.811Z</updated>
  <id>https://hedon.top/</id>
  
  <author>
    <name>Hedon Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust 实战丨通过实现 json! 掌握声明宏</title>
    <link href="https://hedon.top/2024/05/28/rust-action-macro-json/"/>
    <id>https://hedon.top/2024/05/28/rust-action-macro-json/</id>
    <published>2024-05-28T07:37:23.000Z</published>
    <updated>2024-05-28T07:42:52.811Z</updated>
    
    <content type="html"><![CDATA[<p>在 Rust编程语言中，宏是一种强大的工具，可以用于在编译时生成代码。<code>json!</code>是一个在 Rust 中广泛使用的宏，它允许我们在 Rust 代码中方便地创建 JSON数据。</p><p>声明宏（declarative macros）是 Rust 中的一种宏，它们使用<code>macro_rules!</code> 关键字定义。</p><p>本文将参考《Rust 程序设计（第二版）》，通过实现 <code>json!</code>宏，深入理解声明宏的工作原理。</p><h1 id="结论先行">结论先行</h1><p>本文我们将构建一个 <code>json!</code> 宏，它支持我们以字符串 JSON风格的语法来编写 Json 值。如下面这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">students</span> = json![<br>&#123;<br><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Hedon Wang&quot;</span>,<br><span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">2022</span>,<br><span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Software engineering&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jun Lei&quot;</span>,<br><span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">1991</span>,<br><span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Computor science&quot;</span><br>&#125;<br>]<br></code></pre></td></tr></table></figure><blockquote><p><a href="#完整代码">完整代码</a></p></blockquote><h1 id="实现-json">实现 <code>json!</code></h1><h2 id="定义-json-enum">定义 Json enum</h2><p>首先我们需要思考一下 Json 结构是什么样子的？主要是以下 3 种模式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Wuhan University&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hubwi Wuhan&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;john&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-literal"><span class="hljs-keyword">null</span></span><br></code></pre></td></tr></table></figure><p>为此我们定义一个 Json 结构的枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone, PartialEq, Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Json</span> &#123;<br>    Null,<br>    <span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-type">bool</span>),<br>    <span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">String</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-type">Vec</span>&lt;Json&gt;),<br>    <span class="hljs-title function_ invoke__">Object</span>(HashMap&lt;<span class="hljs-type">String</span>, Json&gt;),<br>&#125;<br></code></pre></td></tr></table></figure><p>你应该可以感到非常奇妙，使用一个这么简单的枚举，居然就可以表示所有的Json 结构了。遗憾的是，现在这个结构编写 Json 值的语法相当冗长。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">people</span> = Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>    (<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hedon&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>    (<span class="hljs-string">&quot;age&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">10.0</span>)),<br>    (<span class="hljs-string">&quot;is_student&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)),<br>    (<br>        <span class="hljs-string">&quot;detail&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            (<span class="hljs-string">&quot;address&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;beijing&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>            (<span class="hljs-string">&quot;phone&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()))<br>        ]))<br>    )<br>]))<br></code></pre></td></tr></table></figure><p>我们期望可以以下面这种方式来声明 Json变量，这看起来就清爽许多了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">students</span> = json!([<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jim Blandy&quot;</span>,<br>        <span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">1926</span>,<br>        <span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Tibetan throat singing&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jason Orendorff&quot;</span>,<br>        <span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">1702</span>,<br>        <span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Knots&quot;</span><br>    &#125;<br>]);<br></code></pre></td></tr></table></figure><h2 id="猜想-json">猜想 <code>json!</code></h2><p>我们可以预见 Json 宏内部将会有多条规则，因为 JSON数据有多种类型：对象、数组、数值等。事实上，我们可以合理地猜测每种 JSON类型都将有一条规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null)    =&gt; &#123; Json::Null &#125;;<br>    ([ ... ]) =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Array</span>(...) &#125;;<br>    (&#123; ... &#125;) =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Object</span>(...) &#125;;<br>    (???)     =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Boolean</span>(...) &#125;;<br>    (???)     =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Number</span>(...) &#125;;<br>    (???)     =&gt; &#123; Json::<span class="hljs-title function_ invoke__">String</span>(...) &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而这不太正确，因为宏模式无法区分最后 3种情况，稍后我们会讨论如何处理。至于前 3种情况，显然它们是以不同的语法标记开始的，所以这几种情况比较好处理。</p><h2 id="实现-null">实现 Null</h2><p>我们先从最简单的 <code>Null</code> 分支开始，先编写如下测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_null_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(null);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::Null);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要通过上述测试用例非常简单，我们只需要在 <code>macro_rules!</code>支持中匹配这种情况即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>#[macro_export]</code> 注解是 Rust中的一个属性，用于指示这个宏应该被导出到调用者的作用域中，这样其他模块也可以使用它。</li><li><code>macro_rules!</code>宏定义了一个自定义的宏。在这里，它创建了一个名为 <code>json</code>的宏，用于生成 JSON 数据。</li><li>宏定义中 <code>(null)</code> 是匹配模式。这意味着当你调用<code>json!</code> 宏并传递 <code>null</code>作为参数时，将会触发这个规则。</li><li><code>=&gt;</code>符号用于指示匹配模式后的代码块。在这里，它指定了当匹配<code>(null)</code> 时应该生成的代码块。</li><li><code>Json::Null</code> 是一个 JSON 类型的枚举值，表示 JSON 中的null 值。这个宏的目的是将传入的 <code>null</code> 转换为<code>Json::Null</code>。</li></ul><h2 id="实现-booleannumberstring">实现 Boolean/Number/String</h2><p>我们先准备如下测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_boolean_number_string_json</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察分析，它们其实都是同一种模式：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240528114725679.png"alt="Boolean/Number/String 分析" /><figcaption aria-hidden="true">Boolean/Number/String 分析</figcaption></figure><p>现在需要解决的问题就是，如何将这 3 种模式进行统一，这样在<code>macro_rules!</code> 中才可以统一匹配模式并进行代码生成。</p><p>这里我们其实需要做的就是将 <code>bool</code>、<code>f64</code> 和<code>&amp;str</code> 转为对应的 <code>Json</code>类型。那就需要用到标准库中的 <code>From</code> trait 了。</p><p>做法很简单，我们实现如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">Boolean</span>(value)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;&amp;<span class="hljs-type">str</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">String</span>(value.<span class="hljs-title function_ invoke__">to_string</span>())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">f64</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">Number</span>(value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后完善我们的 <code>json!</code>，目前的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们使用 <code>$value</code>作 为变量来承接匹配到的元素，其类型为<code>tt</code> ，表示任意的语法标记树。具体可以参考：<ahref="#片段类型">片段类型</a>。</p><p>这时运行上述测试用例，是没有问题的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">PASS [   0.004s] json-macro tests::test_boolean_number_string_json<br>PASS [   0.004s] json-macro tests::test_null_json<br></code></pre></td></tr></table></figure><p>美中不足的是，JSON 结构中的数字类型，其实不一定是 f64，也可以是i32、u32、f32 或其他的数字类型，如果我们要为这全部的数字类型都实现到Json 的 <code>From</code> trait，那就多冗余。</p><p>这个时候我们又可以实现一个宏，用于快速生成<code>impl From&lt;T&gt; for Json</code>。这个实现比较简单，本文就不赘述了，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> impl_from_for_primitives &#123;<br>    (  $( $<span class="hljs-keyword">type</span>: ty ) * ) =&gt; &#123;<br>        $(<br>            <span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;$<span class="hljs-keyword">type</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>                <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: $<span class="hljs-keyword">type</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>                    Json::<span class="hljs-title function_ invoke__">Number</span>(value <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>)<br>                &#125;<br>            &#125;<br>        )*<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们只需要用下面这一行代码，就可以为所有的数字类型实现<code>From</code> trait 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">impl_from_for_primitives!(<span class="hljs-type">u8</span> <span class="hljs-type">u16</span> <span class="hljs-type">u32</span> <span class="hljs-type">u64</span> <span class="hljs-type">i8</span> <span class="hljs-type">i16</span> <span class="hljs-type">i32</span> <span class="hljs-type">i64</span> <span class="hljs-type">f32</span> <span class="hljs-type">f64</span> <span class="hljs-type">isize</span> <span class="hljs-type">usize</span>);<br></code></pre></td></tr></table></figure><p>记得这个时候你要删除上面手动实现的<code>impl From&lt;f64&gt; for Json</code>，不然会有 impl 冲突错误。</p><p>再次运行测试，也是可以通过的。</p><h2 id="实现-array">实现 Array</h2><p>准备如下测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_json</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!([<span class="hljs-number">1</span>, null, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-literal">true</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        json,<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<br>            Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>),<br>            Json::Null,<br>            Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>            Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)<br>        ])<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>要匹配<code>[1, null, "string", true]</code>这个模式，笔者的分析过程如下：</p><ol type="1"><li>首先是外面的两个中括号 <code>[</code> 和 <code>]</code> ；</li><li>再往里，是一个重复匹配的模式，以 <code>,</code> 分割，可以匹配 0到任意多个元素，所以是 <code>$(  ,*)</code> ，具体可以参考：<ahref="#重复模式">重复模式</a>；</li><li>最里面就是第 2 步要匹配的元素了，我们先用 <code>$element</code>作为变量来承接每一个元素，其类型为 <code>tt</code>，表示任意的语法标记树。</li></ol><p>分析完匹配的表达式后，我们就可以得到：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">([ $( $element:tt ), * ]) =&gt; &#123; <span class="hljs-comment">/* TODO */</span> &#125;<br></code></pre></td></tr></table></figure><p>我们要生成的代码长这个样子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust">Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<br>    Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>),<br>    Json::Null,<br>    Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>    Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)<br>])<br></code></pre></td></tr></table></figure><p>其实就是一个 <code>vec!</code>，然后里面每个元素都是一个<code>Json</code>，如此递归下去。</p><p>即可以得到代码生成部分的逻辑为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[$(json!($element)),* ])<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240528134133088.png"alt="Json::Array 宏分析" /><figcaption aria-hidden="true">Json::Array 宏分析</figcaption></figure><p>综上，我们实现的代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ([ $( $element: tt),* ]) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[ $( json!($element)), * ])<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试用例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">PASS [   0.003s] json-macro tests::test_null_json<br>PASS [   0.003s] json-macro tests::test_boolean_number_string_json<br>PASS [   0.004s] json-macro tests::test_array_json<br></code></pre></td></tr></table></figure><h2 id="实现-object">实现 Object</h2><p>写好如下测试用例，这次我们顺带把 Null、Boolean、Number 和 String带上了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_object_json</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(&#123;<br>        <span class="hljs-string">&quot;null&quot;</span>: null,<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hedon&quot;</span>,<br>        <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&quot;is_student&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;detail&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;beijing&quot;</span>,<br>            <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span><br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        json,<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            (<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hedon&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>            (<span class="hljs-string">&quot;age&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">10.0</span>)),<br>            (<span class="hljs-string">&quot;is_student&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)),<br>            (<br>                <span class="hljs-string">&quot;detail&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>                Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>                    (<span class="hljs-string">&quot;address&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;beijing&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>                    (<span class="hljs-string">&quot;phone&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()))<br>                ]))<br>            )<br>        ]))<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>对比预期的 <code>json!</code> 宏内容和展开后的代码：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240528133040062.png"alt="Json::Object 宏分析" /><figcaption aria-hidden="true">Json::Object 宏分析</figcaption></figure><p>完善我们的 <code>macro_rules! json</code> ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ([ $( $element: tt),* ]) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[ $( json!($element)), * ])<br>    &#125;;<br>    (&#123; $( $key:tt : $value:tt ),* &#125;) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            $(<br>                ( $key.<span class="hljs-title function_ invoke__">to_string</span>(), json!($value) )<br>            ), *<br>        ]))<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试用例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">PASS [   0.004s] json-macro tests::test_object_json<br>PASS [   0.005s] json-macro tests::test_array_json<br>PASS [   0.004s] json-macro tests::test_null_json<br>PASS [   0.005s] json-macro tests::test_boolean_number_string_json<br></code></pre></td></tr></table></figure><p>至此，我们就完成了 <code>json!</code> 宏的构建了！完整源码可见：<ahref="https://www.notion.so/e90c161d8e3743b2a4f788e3d7b75181?pvs=21">完整代码</a></p><p>Peace! Enjoy coding~</p><h1 id="附录">附录</h1><h2 id="重复模式">重复模式</h2><p>在 <ahref="https://www.notion.so/Array-c914526ab9474ccd9cb92c7eb17225b6?pvs=21">实现Array</a> 中，我们匹配了这样一个模式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">([ $( $element:tt ), * ]) =&gt; &#123; <span class="hljs-comment">/* TODO */</span> &#125;<br></code></pre></td></tr></table></figure><p>其中 <code>$($element:tt), *)</code>就是一个重复模式，其可以进一步抽象为 <code>$( ... ),*</code> ，表示匹配0 次或多次，以 <code>,</code> 分隔。</p><p>Rust 支持以下全部重复模式：</p><table><thead><tr class="header"><th>模式</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>$( … ) *</td><td>匹配 0 次或多次，没有分隔符</td></tr><tr class="even"><td>$( … ), *</td><td>匹配 0 次或多次，以逗号分隔</td></tr><tr class="odd"><td>$( … ); *</td><td>匹配 0 次或多次，以分号分隔</td></tr><tr class="even"><td>$( … ) +</td><td>匹配 1 次或多次，没有分隔符</td></tr><tr class="odd"><td>$( … ), +</td><td>匹配 1 次或多次，以逗号分隔</td></tr><tr class="even"><td>$( … ); +</td><td>匹配 1 次或多次，以分号分隔</td></tr><tr class="odd"><td>$( … ) ?</td><td>匹配 0 次或 1 次，没有分隔符</td></tr></tbody></table><p>即：</p><ul><li><code>*</code> 表示 0 次或多次</li><li><code>+</code> 表示 1 次或多次</li><li><code>?</code> 表示 0 次或 1 次</li><li>可在上述 3 者之前加入分隔符</li></ul><h2 id="片段类型">片段类型</h2><p>在 <a href="#实现-array">实现 Array</a>中，我们匹配了这样一个模式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">([ $( $element:tt ), * ]) =&gt; &#123; <span class="hljs-comment">/* TODO */</span> &#125;<br></code></pre></td></tr></table></figure><p>这里我们将 <code>$element</code> 指定为 <code>tt</code>，这个<code>tt</code> 就是宏中的一种片段类型。</p><p><code>tt</code> 能匹配单个语法标记树，包含：</p><ul><li>一对括号，如 <code>(..)</code>、<code>[..]</code>、或<code>&#123;..&#125;</code> ，以及位于其中的所有内容，包括嵌套的语法标记树。</li><li>单独的非括号语法标记，比如 <code>1926</code> 或 <code>Knots</code>。</li></ul><p>所以为了匹配任意类型的 <code>Json</code> ，我们选择了 <code>tt</code>作为 <code>$element</code> 的片段类型。</p><p><code>macro_rules!</code> 支持的片段类型如下所示：</p><table><thead><tr class="header"><th>片段类型</th><th>匹配（带例子）</th><th>后面可以跟 ······</th></tr></thead><tbody><tr class="odd"><td>expr</td><td>表达式：2 + 2, "udon", x.len()</td><td>=&gt;,;</td></tr><tr class="even"><td>stmt</td><td>表达式或声明，不包括任何尾随分号（很难用，请尝试使用 expr 或block）</td><td>=&gt;,;</td></tr><tr class="odd"><td>ty</td><td>类型：String, Vec<u8>, (&amp;str, bool), dyn Read + Send</td><td>=&gt;,; =</td></tr><tr class="even"><td>path</td><td>路径：ferns, ::std::sync::mpsc</td><td>=&gt;,; =</td></tr><tr class="odd"><td>pat</td><td>模式：_, Some(ref x)</td><td>=&gt;,=</td></tr><tr class="even"><td>item</td><td>语法项：struct Point { x: f64, y: f64 }, mod ferns;</td><td>任意</td></tr><tr class="odd"><td>block</td><td>块：{ s += "ok"; true }</td><td>任意</td></tr><tr class="even"><td>meta</td><td>属性的主体：inline, derive(Copy, Clone), doc="3D models."</td><td>任意</td></tr><tr class="odd"><td>literal</td><td>字面量值：1024, "Hello, world!", 1_000_000f64</td><td>任意</td></tr><tr class="even"><td>lifetime</td><td>生命周期：'a, 'item, 'static</td><td>任意</td></tr><tr class="odd"><td>vis</td><td>可见性说明符：pub, pub(crate), pub(in module::submodule)</td><td>任意</td></tr><tr class="even"><td>ident</td><td>标识符：std, Json, longish_variable_name</td><td>任意</td></tr><tr class="odd"><td>tt</td><td>语法标记树：;, &gt;=, {}, [0 1 (+ 0 1)]</td><td>任意</td></tr></tbody></table><h2 id="完整代码">完整代码</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-meta">#[derive(Debug, Clone, PartialEq)]</span><br><span class="hljs-meta">#[allow(unused)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Json</span> &#123;<br>    Null,<br>    <span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-type">bool</span>),<br>    <span class="hljs-title function_ invoke__">String</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-type">Vec</span>&lt;Json&gt;),<br>    <span class="hljs-title function_ invoke__">Object</span>(HashMap&lt;<span class="hljs-type">String</span>, Json&gt;),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">Boolean</span>(value)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;&amp;<span class="hljs-type">str</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">String</span>(value.<span class="hljs-title function_ invoke__">to_string</span>())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">String</span>(value)<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> impl_from_for_primitives &#123;<br>    (  $( $<span class="hljs-keyword">type</span>: ty ) * ) =&gt; &#123;<br>        $(<br>            <span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;$<span class="hljs-keyword">type</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>                <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: $<span class="hljs-keyword">type</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>                    Json::<span class="hljs-title function_ invoke__">Number</span>(value <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>)<br>                &#125;<br>            &#125;<br>        )*<br>    &#125;<br>&#125;<br><br>impl_from_for_primitives!(<span class="hljs-type">u8</span> <span class="hljs-type">u16</span> <span class="hljs-type">u32</span> <span class="hljs-type">u64</span> <span class="hljs-type">i8</span> <span class="hljs-type">i16</span> <span class="hljs-type">i32</span> <span class="hljs-type">i64</span> <span class="hljs-type">f32</span> <span class="hljs-type">f64</span> <span class="hljs-type">isize</span> <span class="hljs-type">usize</span>);<br><br><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ([ $( $element: tt),* ]) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[ $( json!($element)), * ])<br>    &#125;;<br>    (&#123; $( $key:tt : $value:tt ),* &#125;) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            $(<br>                ( $key.<span class="hljs-title function_ invoke__">to_string</span>(), json!($value) )<br>            ), *<br>        ]))<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_null_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(null);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::Null);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_boolean_number_string_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-literal">true</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>));<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-number">1.0</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>));<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()));<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_object_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(&#123;<br>            <span class="hljs-string">&quot;null&quot;</span>: null,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hedon&quot;</span>,<br>            <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">10</span>,<br>            <span class="hljs-string">&quot;is_student&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-string">&quot;detail&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;beijing&quot;</span>,<br>                <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-built_in">assert_eq!</span>(<br>            json,<br>            Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>                (<span class="hljs-string">&quot;null&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::Null),<br>                (<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hedon&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>                (<span class="hljs-string">&quot;age&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">10.0</span>)),<br>                (<span class="hljs-string">&quot;is_student&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)),<br>                (<br>                    <span class="hljs-string">&quot;detail&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>                    Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>                        (<span class="hljs-string">&quot;address&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;beijing&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>                        (<span class="hljs-string">&quot;phone&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()))<br>                    ]))<br>                )<br>            ]))<br>        )<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!([<span class="hljs-number">1</span>, null, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-literal">true</span>]);<br>        <span class="hljs-built_in">assert_eq!</span>(<br>            json,<br>            Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<br>                Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>),<br>                Json::Null,<br>                Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>                Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)<br>            ])<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文分步展示了实现 json! 宏的过程，包括定义 Json 枚举和不同类型的匹配规则。通过这个过程，读者可以掌握声明宏的基本概念和实现方法。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="宏" scheme="https://hedon.top/tags/%E5%AE%8F/"/>
    
    <category term="元编程" scheme="https://hedon.top/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>xgo 原理探索</title>
    <link href="https://hedon.top/2024/05/23/go-xgo-explore/"/>
    <id>https://hedon.top/2024/05/23/go-xgo-explore/</id>
    <published>2024-05-23T13:15:10.000Z</published>
    <updated>2024-05-27T11:44:43.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go-单测-mock-方案">Go 单测 mock 方案</h1><table><thead><tr class="header"><th>Mock 方法</th><th>原理</th><th>依赖</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>接口 Mock</td><td>为依赖项定义接口，并提供接口的 Mock 实现。</td><td>需要定义接口和 Mock 实现。</td><td>灵活，遵循 Go 的类型系统；易于替换实现。</td><td>需要更多的样板代码来定义接口和 Mock 实现。</td></tr><tr class="even"><td>Monkey Patching（bouk/moneky）</td><td>直接修改函数指针的内存地址来实现对函数的替换。</td><td>内存保护；汇编代码。</td><td>强大，可以 Mock 任何函数，甚至第三方库的函数。</td><td>复杂，容易出错；线程不安全；依赖系统指令集。</td></tr></tbody></table><h1 id="boukmonkey-弊端">bouk/monkey 弊端</h1><blockquote><p><a href="https://github.com/bouk/monkey">bouk/monkey</a> 🐒</p></blockquote><p>monkey 的核心功能是能够在运行时替换某个函数的实现。</p><p><strong>原理：</strong></p><ol type="1"><li><strong>函数指针替换</strong>：在 Go语言中，函数的地址存储在内存中。bouk/monkey通过直接修改函数指针的内存地址来实现对函数的替换。</li><li><strong>汇编代码</strong>：使用了汇编代码来实现对函数入口的跳转。这些汇编代码会在函数被调用时，将执行流重定向到新的函数实现。</li><li><strong>内存保护</strong>：为了修改内存中的函数指针，bouk/monkey需要临时修改内存页面的保护属性（例如，将页面设为可写）。在修改完毕后，它会恢复原来的保护属性。</li><li><strong>反射与 unsafe 包</strong>：利用 Go 的反射机制和 unsafe包，bouk/monkey 可以获取并操作函数的底层实现细节。</li></ol><p><strong>实现步骤：</strong></p><ol type="1"><li><strong>保存原函数</strong>：在替换函数之前，bouk/monkey会保存原始函数的指针，以便在需要时恢复或调用原始函数。</li><li><strong>生成跳转代码</strong>：bouk/monkey生成一段汇编跳转代码，这段代码会在函数调用时，将执行流跳转到新的函数实现。</li><li><strong>修改函数指针</strong>：使用 unsafe 包，bouk/monkey修改目标函数的入口地址，指向生成的跳转代码。</li><li><strong>恢复内存保护</strong>：在完成上述修改后，恢复内存页面的保护属性。</li></ol><p><strong>有以下几个弊端：</strong></p><ol type="1"><li>如果启用了内联，Monkey有时无法修补函数。尝试在禁用内联的情况下运行测试，例如:<code>go test -gcflags=-l</code>。同样的命令行参数也可以用于构建。</li><li>Monkey不能在一些面向安全的操作系统上工作，这些操作系统不允许同时写入和执行内存页。目前的方法并没有真正可靠的解决方案。</li><li>线程不安全的。</li><li>依赖指令集。</li></ol><h1 id="先看-xgo-怎么用">先看 xgo 怎么用</h1><blockquote><p><a href="https://github.com/xhd2015/xgo">xgo</a> 😈</p></blockquote><p>代码结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">.<br>├── greet.<span class="hljs-keyword">go</span><br>└── greet_test.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>现在在 <code>greet.go</code> 中有一个函数 <code>greet</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>在真实的生产环境中，<code>greet</code>可能要复杂得多，它可能会依赖各种第三方API，也可能会依赖数据库等多种外部组件。所以在测试的时候，我们希望对其进行<strong>mock</strong>，使其返回一个固定的值，便于我们撰写单元测试。</p><p><code>xgo</code> 参考了 <code>go-monkey</code> 的思想，但是不从<strong>修改指令</strong> 这个途径入手，而是另辟蹊径，从<strong>代码重写</strong> 的角度实现了 <strong>mock</strong>的能力。</p><p>为了使用 <code>xgo</code>，我们需要先安装 <code>xgo</code>这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install github.com/xhd2015/xgo/cmd/xgo@latest<br></code></pre></td></tr></table></figure><p>同时在我们的项目中需要引入 <code>xgo</code> 依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get <span class="hljs-string">&quot;github.com/xhd2015/xgo/runtime/mock&quot;</span><br></code></pre></td></tr></table></figure><p>我们编写的 <code>greet_test.go</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> xgo_use<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/xhd2015/xgo/runtime/mock&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestOriginGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMockGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.Patch(greet, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在 <code>TestMockGreet</code> 这个单元测试中，我们将<code>greet</code> 进行了 mock，返回 <code>"mock " + s</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mock.Patch(greet, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br></code></pre></td></tr></table></figure><p>为了使用 <code>xgo</code>的能力，我们在执行单元测试的时候，需要运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xgo <span class="hljs-built_in">test</span> -v ./<br></code></pre></td></tr></table></figure><p>输出大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  xgo-use git:(master) xgo <span class="hljs-built_in">test</span> -v ./<br>xgo is taking a <span class="hljs-keyword">while</span> to setup, please <span class="hljs-built_in">wait</span>...<br>=== RUN   TestOriginGreet<br>--- PASS: TestOriginGreet (0.00s)<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>PASS<br>ok      xgo-explore/xgo-use     (cached)<br></code></pre></td></tr></table></figure><h1 id="xgo-的核心原理">xgo 的核心原理</h1><p><code>xgo</code> 的核心原理是利用 <code>go build -toolexec</code>的能力。</p><p>运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">help</span> build<br></code></pre></td></tr></table></figure><p>找到 <code>toolexec</code> 的相关说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">-toolexec <span class="hljs-string">&#x27;cmd args&#x27;</span><br>        a program to use to invoke toolchain programs like vet and asm.<br>        For example, instead of running asm, the go <span class="hljs-built_in">command</span> will run<br>        <span class="hljs-string">&#x27;cmd args /path/to/asm &lt;arguments for asm&gt;&#x27;</span>.<br>        The TOOLEXEC_IMPORTPATH environment variable will be <span class="hljs-built_in">set</span>,<br>        matching <span class="hljs-string">&#x27;go list -f &#123;&#123;.ImportPath&#125;&#125;&#x27;</span> <span class="hljs-keyword">for</span> the package being built.<br></code></pre></td></tr></table></figure><p>一言以蔽之：<code>-toolexec</code> 允许对 go 工具链进行拦截，包括<code>vet</code>、<code>asm</code>、<code>compile</code> 和<code>link</code>。</p><p>这种技术也被称为：插桩（stubbing）、增强（instrumentation）和代码重写（rewriting）。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Km9eLWtYFJMiFYP0uC-B29J__5mGvLlSsrD52hWgS_S2nOGSx9PnMybHuqcQljAtTUr5QVVqaHGyyAEwqVPowhPqJvAZHLALdQpj6gzHzb60NLLe91tX87_sAerIGq2mwYMVdBcptglQpJ0QkfmDC-ZHoQ=s2048.png"alt="-toolexec 示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）" /><figcaption aria-hidden="true">-toolexec示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）</figcaption></figure><p>基于上述分析，<code>xgo</code> 提出了 <strong>代码重写</strong>的思路，实现了 <strong>在编译过程中插入拦截器代码</strong> 的功能：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240523164815047.png"alt="xgo 在 go build 中的作用位置（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）" /><figcaption aria-hidden="true">xgo 在 go build中的作用位置（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）</figcaption></figure><p>所以上述我们的 <code>greet.go</code> 文件中的源代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>经过 <code>xgo</code> 编译后最终实际编译的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;runtime&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (r0 <span class="hljs-type">string</span>) &#123;<br>  stop, post := runtime.__xgo_trap(Greet, &amp;s, &amp;r0)<br>  <span class="hljs-keyword">if</span> stop &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">defer</span> post()<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/5e020865-fd1d-49d3-be72-7ee2233a3c5f.png"alt="greet 函数重写变化示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）" /><figcaption aria-hidden="true">greet函数重写变化示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）</figcaption></figure><p>如图所示，一旦函数被调用，它的控制流首先转移到<code>Trap</code>，然后一系列拦截器将根据其目的检查当前调用是否应该被Mock、修改、记录或停止。</p><p>如果 <code>greet</code> 注册了 mock 函数，那么就会在<code>__xgo_trap</code> 中调用 mock 的函数，并将返回值设置到<code>r0</code> 上进行返回，而跳过原始的执行逻辑。</p><h1 id="第-1-步死代码实现">第 1 步：死代码实现</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  01-deadcode git:(master) tree<br>.<br>├── greet.go<br>├── greet_test.go<br>└── mock.go<br></code></pre></td></tr></table></figure><p>我们先从最简单的实现开始，采用侵入性代码实现 <code>xgo</code>的核心功能，这里我们还用不到 <code>-toolexec</code>。</p><p>代码结构如上所示，在 <code>mock.go</code> 中，我们有如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mockFuncs = sync.Map&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterMockFunc</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>, fun <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>mockFuncs.Store(funcName, fun)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>mockFuncs</code>: 用于承载函数与 mock 函数的对应关系，其中 key为函数名称，value 为 mock 函数。我们使用 <code>sync.Map</code>来保证并发安全。</li><li><code>RegisterMockFunc</code> 用于为指定的 funcName 注册 mock函数。</li></ul><p>在 <code>greet.go</code> 中，我们有一个 <code>Greet</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们要对其支持 mock，那么需要修改其实现为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fun, ok := mockFuncs.Load(<span class="hljs-string">&quot;Greet&quot;</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>f, ok := fun.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br><span class="hljs-keyword">return</span> f(s)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>在修改后的代码中，我们先判断是否存在 mock 函数，如果存在，则执行 mock函数，否则执行原始逻辑。</p><p>现在我们在 <code>greet_test.go</code> 中编写测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMockGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestOriginGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 单独执行 TestMockGreet</span><br>➜  01-deadcode git:(master) ✗ go <span class="hljs-built_in">test</span> -v -run TestMockGreet<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>PASS<br>ok      xgo-explore/01-deadcode 0.103s<br><br><span class="hljs-comment"># 单独执行 TestOriginGreet</span><br>➜  01-deadcode git:(master) ✗ go <span class="hljs-built_in">test</span> -v -run TestOriginGreet<br>=== RUN   TestOriginGreet<br>--- PASS: TestOriginGreet (0.00s)<br>PASS<br>ok      xgo-explore/01-deadcode 0.102s<br><br><span class="hljs-comment"># 一起执行</span><br>➜  01-deadcode git:(master) ✗ go <span class="hljs-built_in">test</span> -v -run $Test$<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>=== RUN   TestOriginGreet<br>    greet_test.go:20: Greet() = <span class="hljs-string">&quot;mock world&quot;</span>; want <span class="hljs-string">&quot;hello world&quot;</span><br>--- FAIL: TestOriginGreet (0.00s)<br>FAIL<br><span class="hljs-built_in">exit</span> status 1<br>FAIL    xgo-explore/01-deadcode 0.102s<br></code></pre></td></tr></table></figure><p>我们会发现单独执行都是 ok 的，不过一起执行的话<code>TestOriginGreet</code> 就失败了，这是因为先执行了<code>TestMockGreet</code>，这个时候已经往 <code>mockFunc</code>中注册了 mock 函数了，所以 <code>TessOriginGreet</code>就执行失败了。</p><p>这里需要在协程层面上做 mock 隔离，<code>xgo</code>的思路是在编译时注入 <code>getg()</code>函数来获取当前协程信息从而实现在注册 mock函数时进行协程隔离。本文将聚焦在 <code>xgo</code> 的核心原理<strong>代码重写</strong> 上，故暂时不考虑这一块。</p><p>Ok，那么短短几行代码，我们就将 <code>xgo</code>的最核心思想给展示出来了。可以看到，<code>xgo</code>的核心思想是往源代码中加入 <strong>合法的 Go代码</strong>，所以不涉及指令重写，故而只要你的机器能执行 Go程序，天然就支持 mock功能，这就天然达到了架构无关的兼容性了。同时我们也使用了<code>sync.Map</code> 来保证了并发安全。</p><h1 id="第-2-步死代码拦截器">第 2 步：死代码拦截器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  02-deadcode-interceptor git:(master) tree<br>.<br>├── greet.go<br>├── greet_test.go<br>└── mock.go<br></code></pre></td></tr></table></figure><p>在第 1 步中，这段代码我觉得有点冗长了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">fun, ok := mockFuncs.Load(<span class="hljs-string">&quot;Greet&quot;</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>  f, ok := fun.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<br>  <span class="hljs-keyword">if</span> ok &#123;<br>    <span class="hljs-keyword">return</span> f(s)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考 <code>xgo</code> 的函数签名，我们对其进行优化，在<code>mock.go</code> 中加入一个 <strong>丐版拦截器</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// mock.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InterceptMock</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>, arg <span class="hljs-type">string</span>, result *<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>fn, ok := mockFuncs.Load(funcName)<br><span class="hljs-keyword">if</span> ok &#123;<br>f, ok := fn.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>*result = f(arg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对应 <code>greet.go</code> 中 <code>Greet</code> 函数就修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>这看起来就清爽多了。再次执行测试代码，一样是可以通过的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  02-deadcode-interceptor git:(master) go <span class="hljs-built_in">test</span> -v -run TestOriginGreet<br>=== RUN   TestOriginGreet<br>--- PASS: TestOriginGreet (0.00s)<br>PASS<br>ok      xgo-explore/02-deadcode-interceptor     0.331s<br><br>➜  02-deadcode-interceptor git:(master) go <span class="hljs-built_in">test</span> -v -run TestMockGreet<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>PASS<br>ok      xgo-explore/02-deadcode-interceptor     0.103s<br></code></pre></td></tr></table></figure><h1 id="第-3-步toolexec-初探">第 3 步：toolexec 初探</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>这里 <code>mock.go</code> 没有任何变化。我们期望使用<code>-toolexec</code> 来修改源代码，以实现 mock无源代码侵入的特性，所以我们在 <code>greet.to</code> 中将<code>Greet</code> 函数恢复为只关注实际功能的样子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>同时为了更好地测试使用 <code>-toolexec</code>编译后的运行结果，这里将 <code>greet_test.go</code> 删除了并新增了<code>main.go</code> 文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>那么 <code>-toolexec</code> 要执行的命令怎么实现呢？在 Google 搜索<strong>go toolexec</strong> 你会看到官方给出的一个案例：<ahref="https://go.dev/src/cmd/go/testdata/script/toolexec.txt">toolexec.txt</a>。</p><p>核心部分在最下面，参考这个示例，我们来实现自己的<code>toolexec</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p cmd/mytool<br><span class="hljs-built_in">touch</span> cmd/mytool/mytool.go<br></code></pre></td></tr></table></figure><p>在<code>mytool.go</code>中，我们先写这么点代码，看一下会输出什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tool, args := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>:]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;-V=full&quot;</span> &#123;<br><span class="hljs-comment">// don&#x27;t do anything to infuence the version full output.</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;tool: %s\n&quot;</span>, tool)<br>fmt.Printf(<span class="hljs-string">&quot;args: %v\n&quot;</span>, args)<br>&#125;<br>  <span class="hljs-comment">// 继续执行之前的命令</span><br>cmd := exec.Command(tool, args...)<br>cmd.Stdout = os.Stdout<br>cmd.Stderr = os.Stderr<br><br><span class="hljs-keyword">if</span> err := cmd.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;run command error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们企图输出执行的工具 <code>tool</code> 及传给它的参数<code>args</code>。由于 <code>-V=full</code>的作用是在终端输出版本信息，所以我们要跳过它，避免产生干扰。输出日志后，我们暂且先继续执行原始的命令，不对编译过程做其他的干扰。</p><p>Ok，现在就来看看这个 <code>-toolexec</code> 到底做了什么，在<code>03-toolexec-static</code> 目录下执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清除缓存，一直使用最新的编译结果</span><br>go clean -cache -modcache -i -r<br><span class="hljs-comment"># 编译 mytool</span><br>go build ./cmd/mytool<br><span class="hljs-comment"># 编译业务程序</span><br>go build -toolexec=./mytool -o main<br></code></pre></td></tr></table></figure><p>因为这几个命令经常会用到，所以我们可以将其封装到<code>script.sh</code> 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> script.sh<br><span class="hljs-built_in">chmod</span> +x script.sh<br></code></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>go clean -cache -modcache -i -r<br>go build ./cmd/mytool<br>go build -toolexec=./mytool -o main<br></code></pre></td></tr></table></figure><p>执行上述命令后，可以看到以下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ./script.sh<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/compile<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/_pkg_.a -trimpath <span class="hljs-variable">$WORK</span>/b001=&gt; -p main -lang=go1.22 -complete -buildid PcS9clqF_ny_Ds5N0i_s/PcS9clqF_ny_Ds5N0i_s -goversion go1.22.3 -c=4 -shared -nolocalimports -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg -pack ./greet.go ./main.go ./mock.go]<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/link<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/exe/a.out -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg.link -buildmode=pie -buildid=KgnnCoU_6enHkOm-T62Z/PcS9clqF_ny_Ds5N0i_s/H80dtgGZw1L8mTtVqJBf/KgnnCoU_6enHkOm-T62Z -extld=cc <span class="hljs-variable">$WORK</span>/b001/_pkg_.a]<br></code></pre></td></tr></table></figure><p>可以看到执行了 <code>compile</code> 和 <code>link</code>两个工具，<code>compile</code> 是编译过程，将生成 <code>&#123;&#125;.out</code>文件，而 <code>link</code> 是将多个 <code>&#123;&#125;.out</code>文件链接成一个可执行文件。这是很经典的编译过程，如果对 Go语言的编译过程感兴趣，也可以参考官方的 <ahref="https://github.com/golang/go/tree/release-branch.go1.22/src/cmd/compile">GoCompile Readme</a>，或者笔者撰写的 <ahref="https://hedon.top/2023/11/29/go-compilation/">Go1.21.0程序编译过程</a>。</p><p>这里我们需要重点关注的是 <code>compile</code>命令，它是负责编译源代码的，涉及到的源代码文件会通过<code>-pack ./greet.go ./main.go ./mock.go</code> 传递给<code>compile</code> 命令。</p><p>结合 <code>-toolexec</code> 的帮助信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">-toolexec <span class="hljs-string">&#x27;cmd args&#x27;</span><br>        a program to use to invoke toolchain programs like vet and asm.<br>        For example, instead of running asm, the go <span class="hljs-built_in">command</span> will run<br>        <span class="hljs-string">&#x27;cmd args /path/to/asm &lt;arguments for asm&gt;&#x27;</span>.<br>        The TOOLEXEC_IMPORTPATH environment variable will be <span class="hljs-built_in">set</span>,<br>        matching <span class="hljs-string">&#x27;go list -f &#123;&#123;.ImportPath&#125;&#125;&#x27;</span> <span class="hljs-keyword">for</span> the package being built.<br></code></pre></td></tr></table></figure><p>我们只需要在执行 <code>compile</code> 命令之前，在<code>cmd args</code> 这个环节，进行 <strong>代码重写</strong>就可以实现我们想要的功能了。</p><p>我们现在是要对 <code>greet.go</code> 里面的 <code>Greet</code>函数进行重写，先看看之前的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>重写后的代码应该跟我们之前 <strong>第 2 步</strong> 是一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br> <span class="hljs-keyword">return</span> res<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有 n多种方式可以做到，现在笔者决定使用最暴力的方式，直接临时创建一个包含这段代码的文件<code>tmp.go</code>，并替换掉传给 <code>compile</code> 的参数，即将<code>-pack ./greet.go ./main.go ./mock.go</code> 替换为<code>-pack tmp.go ./main.go ./mock.go</code></p><p>综上，<code>cmd/mytool/mytool/go</code> 实现的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tool, args := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>:]<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;-V=full&quot;</span> &#123;<br><span class="hljs-comment">// don&#x27;t do anything to infuence the version full output.</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> filepath.Base(tool) == <span class="hljs-string">&quot;compile&quot;</span> &#123;<br>index := findGreetFile(args)<br><span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">-1</span> &#123;<br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><span class="hljs-keyword">defer</span> os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br>_, _ = f.WriteString(newCode)<br>args[index] = <span class="hljs-string">&quot;tmp.go&quot;</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;tool: %s\n&quot;</span>, tool)<br>fmt.Printf(<span class="hljs-string">&quot;args: %v\n&quot;</span>, args)<br>&#125;<br><span class="hljs-comment">// 继续执行之前的命令</span><br>cmd := exec.Command(tool, args...)<br>cmd.Stdout = os.Stdout<br>cmd.Stderr = os.Stderr<br><br><span class="hljs-keyword">if</span> err := cmd.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;run command error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findGreetFile</span><span class="hljs-params">(args []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br><span class="hljs-keyword">if</span> strings.Contains(arg, <span class="hljs-string">&quot;greet.go&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-keyword">var</span> newCode = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func Greet(s string) (res string) &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;Greet&quot;, s, &amp;res) &#123;</span><br><span class="hljs-string"> return res</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">return &quot;hello &quot; + s</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这里我先使用 <code>findGreetFile</code> 来查找 <code>greet.go</code>文件所处的参数位置，如果找到了，则生成新的 <code>tmp.go</code>文件，并替换参数，最后在 本次 <code>compile</code> 命令执行完毕后，删除<code>tmp.go</code>，“毁尸灭迹”。</p><p>执行 <code>./script.sh</code> 重新编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ✗ ./script.sh<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/compile<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/_pkg_.a -trimpath <span class="hljs-variable">$WORK</span>/b001=&gt; -p main -lang=go1.22 -complete -buildid PcS9clqF_ny_Ds5N0i_s/PcS9clqF_ny_Ds5N0i_s -goversion go1.22.3 -c=4 -shared -nolocalimports -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg -pack tmp.go ./main.go ./mock.go]<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/link<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/exe/a.out -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg.link -buildmode=pie -buildid=KgnnCoU_6enHkOm-T62Z/PcS9clqF_ny_Ds5N0i_s/H80dtgGZw1L8mTtVqJBf/KgnnCoU_6enHkOm-T62Z -extld=cc <span class="hljs-variable">$WORK</span>/b001/_pkg_.a]<br></code></pre></td></tr></table></figure><p>输出的结果中可以看到已经将 <code>compile</code> 的参数替换为<code>-pack tmp.go ./main.go ./mock.go</code> 了。</p><p>现在我们来执行生成的程序文件，可以看到是执行成功的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ✗ ./main<br>2024/05/23 17:53:52 run successfully<br></code></pre></td></tr></table></figure><p>如果我们不使用 <code>-toolexec</code>，是执行不成功的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ✗ go clean -cache -modcache -i -r<br>➜  03-toolexec-static git:(master) ✗ go build -o main<br>➜  03-toolexec-static git:(master) ✗ ./main<br>2024/05/23 17:54:33 Greet() = <span class="hljs-string">&quot;hello world&quot;</span>; want <span class="hljs-string">&quot;mock world&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第-4-步使用-ast-在函数前插入代码">第 4 步：使用 AST在函数前插入代码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  04-toolexec-ast git:(master) ✗ tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>暴力替换源代码文件的方式可能是不太优雅哈，假如我们的<code>greet.go</code> 内容改成下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet2</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 2 &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想对 <code>Greet2</code> 也进行<strong>代码重写</strong>，那就需要修改前面 <code>newCode</code>字段的内容，而且它是写死的，确实不太优雅。现在我们正式来面对这件事，对比修改后的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br> <span class="hljs-keyword">return</span> res<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是在每个函数前加上这么一段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>了解过编译原理的读者应该可以想到，我们可以通过操作源代码的 AST结构，往函数的开头插入这段代码即可。如果我们先不考虑参数和返回值的话，那这段代码我们需要替换的地方就是函数名称了，所以它的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;$&#123;funcName&#125;&quot;</span>, s, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们需要用到几个标准库工具：</p><ul><li><code>go/ast</code>: 包定义了 Go编程语言的抽象语法树（AST），核心有以下几种类型：<ul><li><code>File</code>: 表示一个 Go 源文件。</li><li><code>Decl</code>:表示一个声明，包括函数声明、变量声明、类型声明等。</li><li><code>Stmt</code>: 表示一个语句。</li><li><code>Expr</code>: 表示一个表达式。</li></ul></li><li><code>go/token</code>: 定义了处理 Go源代码的词法元素的基础设施，包括位置、标记和标识符等。这个包提供了用于管理源代码位置的信息，可以帮助定位代码中的特定部分。</li><li><code>go/parser</code>: 将一个 <code>.go</code> 文件以解析成 AST结构。</li><li><code>go/printer</code>: 提供了将 AST 格式化并输出为 Go源码的功能</li></ul><p>修改后的 <code>cmd/mytool/mytool.go</code> 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tool, args := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>:]<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;-V=full&quot;</span> &#123;<br><span class="hljs-comment">// don&#x27;t do anything to infuence the version full output.</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> filepath.Base(tool) == <span class="hljs-string">&quot;compile&quot;</span> &#123;<br>index := findGreetFile(args)<br><span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">-1</span> &#123;<br>filename := args[index]<br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()<br><span class="hljs-keyword">defer</span> os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(insertCode(filename))<br>args[index] = <span class="hljs-string">&quot;tmp.go&quot;</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;tool: %s\n&quot;</span>, tool)<br>fmt.Printf(<span class="hljs-string">&quot;args: %v\n&quot;</span>, args)<br>&#125;<br><span class="hljs-comment">// 继续执行之前的命令</span><br>cmd := exec.Command(tool, args...)<br>cmd.Stdout = os.Stdout<br>cmd.Stderr = os.Stderr<br><br><span class="hljs-keyword">if</span> err := cmd.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;run command error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findGreetFile</span><span class="hljs-params">(args []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br><span class="hljs-keyword">if</span> strings.Contains(arg, <span class="hljs-string">&quot;greet.go&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertCode</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fset := token.NewFileSet()<br>fast, err := parser.ParseFile(fset, filename, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse file error: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, decl := <span class="hljs-keyword">range</span> fast.Decls &#123;<br>fun, ok := decl.(*ast.FuncDecl)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>f, err := os.Create(<span class="hljs-string">&quot;tmp2.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp2.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(fmt.Sprintf(newCodeFormat, fun.Name.Name))<br>f.Close()<br><br>tmpFset := token.NewFileSet()<br>tmpF, err := parser.ParseFile(tmpFset, <span class="hljs-string">&quot;tmp2.go&quot;</span>, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse tmp2.go error: %v\n&quot;</span>, err)<br>&#125;<br>fun.Body.List = <span class="hljs-built_in">append</span>(tmpF.Decls[<span class="hljs-number">0</span>].(*ast.FuncDecl).Body.List, fun.Body.List...)<br>os.Remove(<span class="hljs-string">&quot;tmp2.go&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>printer.Fprint(&amp;buf, fset, fast)<br><br>fmt.Println(buf.String())<br><br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, s, &amp;res) &#123;</span><br><span class="hljs-string"> return res</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>核心的修改在于 <code>insertCode</code> 函数：</p><ol type="1"><li><p>使用 <code>parser.ParseFile</code> 将源代码文件解析成 AST结构；</p></li><li><p>遍历 AST 结构，找到所有的声明（Decl）结构，并使用<code>decl(.ast.FuncDecl)</code> 找到所有的函数；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">FuncDecl <span class="hljs-keyword">struct</span> &#123;<br>  Doc  *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span><br>  Recv *FieldList    <span class="hljs-comment">// receiver (methods); or nil (functions)</span><br>  Name *Ident        <span class="hljs-comment">// function/method name</span><br>  Type *FuncType     <span class="hljs-comment">// function signature: type and value parameters, results, and position of &quot;func&quot; keyword</span><br>  Body *BlockStmt    <span class="hljs-comment">// function body; or nil for external (non-Go) function</span><br>&#125;<br><br>BlockStmt <span class="hljs-keyword">struct</span> &#123;<br>  Lbrace token.Pos <span class="hljs-comment">// position of &quot;&#123;&quot;</span><br>  List   []Stmt<br>  Rbrace token.Pos <span class="hljs-comment">// position of &quot;&#125;&quot;, if any (may be absent due to syntax error)</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查看 <code>ast.FuncDecl</code> 的结构后，可以得出下一步就是往<code>FuncDecl.Body.List</code> 列表前面插入一些<code>Stmt</code>；</p></li><li><p>笔者没找到类似 <code>parseStmt</code>方法，所以取了个巧，我定义了一段代码的 <code>format</code>，里面的<code>%s</code> 会使用 <code>fun.Name.Name</code>获取函数名并进行替换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, s, &amp;res) &#123;</span><br><span class="hljs-string"> return res</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure></li><li><p>创建一个临时文件 <code>tmp2.go</code>并写入格式化后的代码，然后再次调用 <code>parser.ParseFile</code>得到解析这段代码的抽象语法树结构 <code>tmpF</code> 了；</p></li><li><p>然后通过 <code>tmpF.Decls[0].(*ast.FuncDecl).Body.List</code>就可以得到 <code>TmpFunc</code> 中的语句 <code>Stmt</code> 了；</p></li><li><p>将其加在源代码函数的前面即可：<code>fun.Body.List = append(tmpF.Decls[0].(*ast.FuncDecl).Body.List, fun.Body.List...)</code>；</p></li><li><p>然后再使用 <code>go/printer</code> 将修改后的 AST输出为新文件内容。</p></li></ol><p>通过上述步骤，我们就可以为 <code>greet.go</code>中的每个函数前面都插入打桩代码了。</p><p>修改 <code>main.go</code> 里面的内容，加入对 <code>Greet2</code>的测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s<br>&#125;)<br>res = Greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet2() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 2 successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>输出应该还是跟之前是一样的，我们运行生成的可执行函数，得到如下结果那就说明我们又成功进了一步了~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  04-toolexec-ast git:(master) ✗ ./main<br>2024/05/23 20:03:22 run greet 1 successfully<br>2024/05/23 20:03:22 run greet 2 successfully<br></code></pre></td></tr></table></figure><h1 id="第-5-步使用-reflect-反射动态获取参数和返回值名称">第 5 步：使用reflect 反射动态获取参数和返回值名称</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  05-toolexec-general git:(master) ✗ tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>接下来我们来处理函数签名中的参数和返回值部分，我们的样板代码中，写死了参数的名称和返回值的名称，现在我们需要来动态获取函数参数的名称和返回值的名称，如果返回值没有名称，那我们还需要手动设置名称。</p><p>我们将 <code>greet.to</code> 修改为以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet2</span><span class="hljs-params">(s2 <span class="hljs-type">string</span>)</span></span> (res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 2 &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet3</span><span class="hljs-params">(s3 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 3 &quot;</span> + s3<br>&#125;<br></code></pre></td></tr></table></figure><p>函数的信息当然都在前面获得的 <code>ast.FuncDecl</code>结构中，再次观察其结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">FuncDecl <span class="hljs-keyword">struct</span> &#123;<br>Doc  *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span><br>Recv *FieldList    <span class="hljs-comment">// receiver (methods); or nil (functions)</span><br>Name *Ident        <span class="hljs-comment">// function/method name</span><br>Type *FuncType     <span class="hljs-comment">// function signature: type and value parameters, results, and position of &quot;func&quot; keyword</span><br>Body *BlockStmt    <span class="hljs-comment">// function body; or nil for external (non-Go) function</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过注释就可以知道 <code>Type</code>字段就包含了参数和返回值的相关信息，查看 <code>FuncType</code>结构，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">FuncType <span class="hljs-keyword">struct</span> &#123;<br>  Func       token.Pos  <span class="hljs-comment">// position of &quot;func&quot; keyword (token.NoPos if there is no &quot;func&quot;)</span><br>  TypeParams *FieldList <span class="hljs-comment">// type parameters; or nil</span><br>  Params     *FieldList <span class="hljs-comment">// (incoming) parameters; non-nil</span><br>  Results    *FieldList <span class="hljs-comment">// (outgoing) results; or nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Params</code>：函数参数</li><li><code>Results</code>：函数返回值</li></ul><p>查看 <code>FieldList</code> 结构，可知参数列表和返回值列表都在相应的<code>List</code> 字段中，而其中的 <code>Names</code>字段就是参数的名称了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FieldList <span class="hljs-keyword">struct</span> &#123;<br>Opening token.Pos <span class="hljs-comment">// position of opening parenthesis/brace/bracket, if any</span><br>List    []*Field  <span class="hljs-comment">// field list; or nil</span><br>Closing token.Pos <span class="hljs-comment">// position of closing parenthesis/brace/bracket, if any</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Field <span class="hljs-keyword">struct</span> &#123;<br>Doc     *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span><br>Names   []*Ident      <span class="hljs-comment">// field/method/(type) parameter names; or nil</span><br>Type    Expr          <span class="hljs-comment">// field/method/parameter type; or nil</span><br>Tag     *BasicLit     <span class="hljs-comment">// field tag; or nil</span><br>Comment *CommentGroup <span class="hljs-comment">// line comments; or nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>补充一下，这里为什么 <code>Names</code> 类型是 <code>[]*Ident</code>呢？因为函数有以下的命名方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (r1, r1 <span class="hljs-type">string</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>那么在当下，只有 1 个参数和只有 1 个返回值的情况下，我们就可以通过<code>fun.Type.Params.List[0].Names[0].Name</code>来获取参数名称，也可以通过 <code>fun.Type.Results.List[0].Names</code>来获取返回值名称，如果返回值没有名称，那我们就为其设置名称<code>__xgo_res_1</code> 并写回源 AST结构。这样就都有名称，就很好处理了。</p><p>经上分析， <code>cmd/mytool/mytool.go</code> 中我们只需要修改<code>insertCode</code> 部分，修改的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertCode</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fset := token.NewFileSet()<br>fast, err := parser.ParseFile(fset, filename, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse file error: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, decl := <span class="hljs-keyword">range</span> fast.Decls &#123;<br>fun, ok := decl.(*ast.FuncDecl)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(newCode(fun))<br>f.Close()<br><br>tmpFset := token.NewFileSet()<br>tmpF, err := parser.ParseFile(tmpFset, <span class="hljs-string">&quot;tmp.go&quot;</span>, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>fun.Body.List = <span class="hljs-built_in">append</span>(tmpF.Decls[<span class="hljs-number">0</span>].(*ast.FuncDecl).Body.List, fun.Body.List...)<br>os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>printer.Fprint(&amp;buf, fset, fast)<br><br>fmt.Println(buf.String())<br><br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCode</span><span class="hljs-params">(fun *ast.FuncDecl)</span></span> <span class="hljs-type">string</span> &#123;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[s] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[res] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[s2] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[res2] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[s3] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 函数名称</span><br>funcName := fun.Name.Name<br><br><span class="hljs-comment">// 参数列表</span><br>argName := fun.Type.Params.List[<span class="hljs-number">0</span>].Names[<span class="hljs-number">0</span>].Name<br><br><span class="hljs-comment">// 返回值列表</span><br>resNames := fun.Type.Results.List[<span class="hljs-number">0</span>].Names<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(resNames) == <span class="hljs-number">0</span> &#123;<br>resNames = <span class="hljs-built_in">append</span>(resNames, &amp;ast.Ident&#123;Name: <span class="hljs-string">&quot;_xgo_res_1&quot;</span>&#125;)<br>fun.Type.Results.List[<span class="hljs-number">0</span>].Names = resNames<br>&#125;<br>resName := resNames[<span class="hljs-number">0</span>].Name<br><span class="hljs-keyword">return</span> fmt.Sprintf(newCodeFormat, funcName, argName, resName, resName)<br>&#125;<br><br><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, %s, &amp;%s) &#123;</span><br><span class="hljs-string"> return %s</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>现在我们就可以动态获取参数名称和返回值名称了。</p><p>修改我们的 <code>main.go</code>，以测试所有的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s<br>&#125;)<br>res = Greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet2() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 2 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 3 &quot;</span> + s<br>&#125;)<br>res = Greet3(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 3 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet3() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 3 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 3 successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行编译脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>执行编译产生的可执行程序，输出如下就说明我们又成功进了一大步~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  05-toolexec-general git:(master) ✗ ./main<br>2024/05/23 20:15:08 run greet 1 successfully<br>2024/05/23 20:15:08 run greet 2 successfully<br>2024/05/23 20:15:08 run greet 3 successfully<br></code></pre></td></tr></table></figure><h1 id="第-6-步支持多参数和多返回值">第 6 步：支持多参数和多返回值</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  06-toolexec-multi git:(master) ✗ tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>本文的最后一步，我们来面对一下多参数和多返回值的问题。假设我们又如下函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair1</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候我们 <strong>代码重写</strong>后应该长什么样子呢？可以是下面这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair1</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Pair1&quot;</span>, s1, s2, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>按照这个思路，下面这个函数呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>那就是这样的？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Pair2&quot;</span>, s1, s2, &amp;res1, &amp;res2) &#123;<br><span class="hljs-keyword">return</span> res1, res2<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>这种思路当然也能实现，换一种更优雅的思路呢？既然是一个列表，那么就可以用切片来承载，也就是可以是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Pair2&quot;</span>, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;s1, s2&#125;, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&amp;res1, &amp;res2&#125;) &#123;<br><span class="hljs-keyword">return</span> res1, res2<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>那我们就可以抽象出插入代码的模板了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;$&#123;funcName&#125;&quot;</span>, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;$&#123;paramList&#125;&#125;, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;$&#123;returnListWith&amp;&#125;&#125;) &#123;<br>  <span class="hljs-keyword">return</span> $&#123;returnListWithout&amp;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了实现这个，我们需要先修改一下 <code>mock.go</code> 中的<code>InterceptMock</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InterceptMock</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>, args []<span class="hljs-keyword">interface</span>&#123;&#125;, results []<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>mockFn, ok := mockFuncs.Load(funcName)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><br>in := <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-built_in">len</span>(args))<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br>in[i] = reflect.ValueOf(arg)<br>&#125;<br><br>  mockFnValue := reflect.ValueOf(mockFn)<br>out := mockFnValue.Call(in)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(out) != <span class="hljs-built_in">len</span>(results) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;mock function return value number is not equal to results number&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> i, result := <span class="hljs-keyword">range</span> results &#123;<br>reflect.ValueOf(result).Elem().Set(out[i])<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器的具体实现如下：</p><ol type="1"><li>判断是否注册了 mock 函数，没有则直接返回；</li><li>将所有参数都放到 <code>[]refect.Value</code> 中；</li><li>通过反射 <code>refect.ValueOf</code> 获取 mockFn 的值；</li><li>调用 <code>mockFnValue.Call()</code>来执行函数，并返回结果列表；</li><li>遍历传进来的返回值引用列表，调用<code>reflect.ValueOf(result).Elem().Set(out[i])</code>将返回值设置回去。</li></ol><p>现在我们来修改我们的 <code>-toolexec</code> 工具，来根据函数的 AST结构，获取参数列表和返回值列表，生成代插入的模板代码，并将其插入到每个函数的开头。这次在<code>cmd/mytool/mytool.go</code> 中，我们只需修改 <code>newCode</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertCode</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fset := token.NewFileSet()<br>fast, err := parser.ParseFile(fset, filename, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse file error: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, decl := <span class="hljs-keyword">range</span> fast.Decls &#123;<br>fun, ok := decl.(*ast.FuncDecl)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(newCode(fun))<br>f.Close()<br><br>tmpFset := token.NewFileSet()<br>tmpF, err := parser.ParseFile(tmpFset, <span class="hljs-string">&quot;tmp.go&quot;</span>, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>fun.Body.List = <span class="hljs-built_in">append</span>(tmpF.Decls[<span class="hljs-number">0</span>].(*ast.FuncDecl).Body.List, fun.Body.List...)<br>os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>printer.Fprint(&amp;buf, fset, fast)<br><br>fmt.Println(buf.String())<br><br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCode</span><span class="hljs-params">(fun *ast.FuncDecl)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// 函数名称</span><br>funcName := fun.Name.Name<br><br><span class="hljs-comment">// 参数列表</span><br>args := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> fun.Type.Params.List &#123;<br><span class="hljs-keyword">for</span> _, name := <span class="hljs-keyword">range</span> arg.Names &#123;<br>args = <span class="hljs-built_in">append</span>(args, name.Name)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 返回值列表</span><br>returns := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>returnRefs := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>returnNames := fun.Type.Results.List[<span class="hljs-number">0</span>].Names<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(returnNames) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; fun.Type.Results.NumFields(); i++ &#123;<br>fun.Type.Results.List[<span class="hljs-number">0</span>].Names = <span class="hljs-built_in">append</span>(fun.Type.Results.List[<span class="hljs-number">0</span>].Names,<br>&amp;ast.Ident&#123;Name: fmt.Sprintf(<span class="hljs-string">&quot;_xgo_res_%d&quot;</span>, i+<span class="hljs-number">1</span>)&#125;)<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> _, re := <span class="hljs-keyword">range</span> fun.Type.Results.List[<span class="hljs-number">0</span>].Names &#123;<br>returns = <span class="hljs-built_in">append</span>(returns, re.Name)<br>returnRefs = <span class="hljs-built_in">append</span>(returnRefs, <span class="hljs-string">&quot;&amp;&quot;</span>+re.Name)<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(newCodeFormat,<br>funcName,<br>strings.Join(args, <span class="hljs-string">&quot;,&quot;</span>),<br>strings.Join(returnRefs, <span class="hljs-string">&quot;,&quot;</span>),<br>strings.Join(returns, <span class="hljs-string">&quot;,&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, []interface&#123;&#125;&#123;%s&#125;, []interface&#123;&#125;&#123;%s&#125;) &#123;</span><br><span class="hljs-string">return %s</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>思路跟之前第 5步大同小异，不过是用遍历的方式来支持多个参数和多个返回值罢了。</p><p>现在我们为 <code>greet.go</code> 添加更多的测试函数，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet2</span><span class="hljs-params">(s2 <span class="hljs-type">string</span>)</span></span> (res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 2 &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet3</span><span class="hljs-params">(s3 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 3 &quot;</span> + s3<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair1</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Other</span><span class="hljs-params">(i <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, f <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;int: %d, string: %s, float: %f&quot;</span>, i, s, f)<br>&#125;<br></code></pre></td></tr></table></figure><p>为了测试，我们再次修改 <code>main.go</code>，使其覆盖所有的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Other&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, f <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;mock %d %s %.2f&quot;</span>, i, s, f)<br>&#125;)<br>res := Other(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">3.14</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 1 hello 3.14&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Other() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 1 hello 3.14&quot;</span>)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;run other successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Pair1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;)<br>res = Pair1(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 1 hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Pair1() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 1 hello world&quot;</span>)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;run pair1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Pair2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s1, <span class="hljs-string">&quot;mock 2 &quot;</span> + s2<br>&#125;)<br>res1, res2 := Pair2(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res1 != <span class="hljs-string">&quot;mock 2 hello&quot;</span> || res2 != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Pair2() = %q, %q; want %q, %q&quot;</span>, res1, res2, <span class="hljs-string">&quot;mock 2 hello&quot;</span>, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;run pair2 successfully&quot;</span>)<br><br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s<br>&#125;)<br>res = Greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet2() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 2 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 3 &quot;</span> + s<br>&#125;)<br>res = Greet3(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 3 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet3() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 3 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 3 successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>编译代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>执行生成的可执行程序，如果有以下输出，那我们就又成功进了一大大步了~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  06-toolexec-multi git:(master) ✗ ./main<br>2024/05/23 20:31:10 run other successfully<br>2024/05/23 20:31:10 run pair1 successfully<br>2024/05/23 20:31:10 run pair2 successfully<br>2024/05/23 20:31:10 run greet 1 successfully<br>2024/05/23 20:31:10 run greet 2 successfully<br>2024/05/23 20:31:10 run greet 3 successfully<br></code></pre></td></tr></table></figure><h1 id="更进一步">更进一步</h1><p>通过上面 6 个简单的小阶段，我们就已经把 <code>xgo</code>最最核心的功能给实现了，在一些小场景下还勉强能用？🤡</p><p>我们来看看包含测试代码和样例函数，总共用了多少代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  06-toolexec-multi git:(master) ✗ tokei .<br>===============================================================================<br> Language            Files        Lines         Code     Comments       Blanks<br>===============================================================================<br> Go                      4          281          224           11           46<br> Shell                   1            5            3            1            1<br>===============================================================================<br> Total                   5          286          227           12           47<br>===============================================================================<br></code></pre></td></tr></table></figure><p>短短 <strong>224</strong> 行代码，这是一个非常了不起的成就！</p><p>当然，优秀的读者肯定可以发现我们这个 <strong>丐版 xgo</strong>有太多的不足和缺陷了。这是必然的，我们来看看 <code>xgo</code> 截止<code>1.0.37</code> 版本，总共有多少行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">➜  xgo git:(master) tokei .<br>===============================================================================<br> Language            Files        Lines         Code     Comments       Blanks<br>===============================================================================<br> BASH                    <span class="hljs-number">1</span>          <span class="hljs-number">104</span>           <span class="hljs-number">81</span>           <span class="hljs-number">11</span>           <span class="hljs-number">12</span><br> CSS                     <span class="hljs-number">1</span>          <span class="hljs-number">153</span>          <span class="hljs-number">118</span>            <span class="hljs-number">5</span>           <span class="hljs-number">30</span><br> Go                    <span class="hljs-number">369</span>        <span class="hljs-number">33232</span>        <span class="hljs-number">26836</span>         <span class="hljs-number">2588</span>         <span class="hljs-number">3808</span><br> JavaScript              <span class="hljs-number">1</span>          <span class="hljs-number">170</span>          <span class="hljs-number">146</span>           <span class="hljs-number">10</span>           <span class="hljs-number">14</span><br> JSON                    <span class="hljs-number">2</span>          <span class="hljs-number">435</span>          <span class="hljs-number">435</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> PowerShell              <span class="hljs-number">1</span>           <span class="hljs-number">28</span>           <span class="hljs-number">16</span>            <span class="hljs-number">3</span>            <span class="hljs-number">9</span><br> Shell                   <span class="hljs-number">3</span>          <span class="hljs-number">288</span>          <span class="hljs-number">251</span>            <span class="hljs-number">4</span>           <span class="hljs-number">33</span><br> SVG                     <span class="hljs-number">1</span>           <span class="hljs-number">41</span>           <span class="hljs-number">41</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> Plain Text              <span class="hljs-number">7</span>          <span class="hljs-number">192</span>            <span class="hljs-number">0</span>          <span class="hljs-number">174</span>           <span class="hljs-number">18</span><br>-------------------------------------------------------------------------------<br> HTML                    <span class="hljs-number">1</span>           <span class="hljs-number">19</span>           <span class="hljs-number">16</span>            <span class="hljs-number">3</span>            <span class="hljs-number">0</span><br> |- JavaScript           <span class="hljs-number">1</span>            <span class="hljs-number">6</span>            <span class="hljs-number">6</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> (Total)                             <span class="hljs-number">25</span>           <span class="hljs-number">22</span>            <span class="hljs-number">3</span>            <span class="hljs-number">0</span><br>-------------------------------------------------------------------------------<br> Markdown               <span class="hljs-number">17</span>         <span class="hljs-number">1455</span>            <span class="hljs-number">0</span>         <span class="hljs-number">1083</span>          <span class="hljs-number">372</span><br> |- Go                   <span class="hljs-number">8</span>          <span class="hljs-number">820</span>          <span class="hljs-number">635</span>           <span class="hljs-number">72</span>          <span class="hljs-number">113</span><br> |- JSON                 <span class="hljs-number">1</span>           <span class="hljs-number">80</span>           <span class="hljs-number">80</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> (Total)                           <span class="hljs-number">2355</span>          <span class="hljs-number">715</span>         <span class="hljs-number">1155</span>          <span class="hljs-number">485</span><br>===============================================================================<br> Total                 <span class="hljs-number">404</span>        <span class="hljs-number">36117</span>        <span class="hljs-number">27940</span>         <span class="hljs-number">3881</span>         <span class="hljs-number">4296</span><br>===============================================================================<br></code></pre></td></tr></table></figure><p>光 Go 代码就有 <strong>26836</strong> 行了。所以可知 <code>xgo</code>的作者是做了很多的付出和努力的。不过我们用了不到百分之一的代码量，就将<code>xgo</code>最核心的原理展示得淋漓尽致了，感兴趣的读者可以进一步阅读<code>xgo</code> 的源码，可以进一步探索如何抽象出更通用更简洁更易扩展的interceptor，如何支持协程隔离，如何优化依赖管理，以及如何实现其他的trace、coverage 功能。再次为 <code>xgo</code> 打 call 👏！</p><h1 id="参考">参考</h1><ul><li><a href="https://github.com/xhd2015/xgo">xgo repo</a></li><li><ahref="https://docs.google.com/presentation/d/1U5yTdrUjnManxztzsMPGBAePrE3HvJcDtRjV6h3HelA/edit#slide=id.g2705943ae25_0_50">xgo:基于代码重写实现 Monkey Patch 和 Trace</a></li><li><ahref="https://github.com/golang/go/tree/release-branch.go1.22/src/cmd/compile">gocompile README</a></li><li><ahref="https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/">xgo:在 go 中使用-toolexec 实现猴子补丁</a></li></ul>]]></content>
    
    
    <summary type="html">xgo 是一个通过代码重写来实现 mock、trace 和 coverage 功能的单元测试框架。本文将探讨 xgo 最核心的底层原理 -toolexec，并通过 6 个简单的小阶段，一步步实现一个丐版 xgo，进一步展示 xgo 的设计理念。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="开源项目" scheme="https://hedon.top/categories/Go/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="开源项目" scheme="https://hedon.top/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>xgo 使用经验</title>
    <link href="https://hedon.top/2024/05/21/go-xgo-use/"/>
    <id>https://hedon.top/2024/05/21/go-xgo-use/</id>
    <published>2024-05-21T08:32:51.000Z</published>
    <updated>2024-05-21T11:58:06.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="patch">Patch</h1><h2 id="mock-函数">mock 函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPatchFunc</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.Patch(greet, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br><br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced mock world got %s&quot;</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mock-变量">mock 变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> value = <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> value + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPatchVar</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.Patch(&amp;value, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span><br>&#125;)<br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced mock world got %s&quot;</span>, res)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPatchVarByName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.PatchByName(<span class="hljs-string">&quot;learn-xgo/api&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span><br>&#125;)<br>res := greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced mock world got %s&quot;</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="mock">Mock</h1><blockquote><p>因此，当函数含有未导出类型时，<code>Patch</code>无法使用，此时可以使用 <code>Mock</code>。</p></blockquote><h2 id="mockbyname">MockByName</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// learn-xgo/funcs/funcs.go</span><br><span class="hljs-keyword">package</span> funcs<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CallUnexportedFunc</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> unexportedFunc(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unexportedFunc</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;origin unexported func, your msg is &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// learn-xgo/api/mock_test.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMockByName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.MockByName(<span class="hljs-string">&quot;learn-xgo/funcs&quot;</span>, <span class="hljs-string">&quot;unexportedFunc&quot;</span>,<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, fn *core.FuncInfo, args core.Object, results core.Object)</span></span> <span class="hljs-type">error</span> &#123;<br>results.GetFieldIndex(<span class="hljs-number">0</span>).Set(<span class="hljs-string">&quot;mock funcs &quot;</span> + args.GetFieldIndex(<span class="hljs-number">0</span>).Value().(<span class="hljs-type">string</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><br>msg := funcs.CallUnexportedFunc(<span class="hljs-string">&quot;hedon&quot;</span>)<br><span class="hljs-keyword">if</span> msg != <span class="hljs-string">&quot;mock funcs hedon&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced `mock funcs hedon` got %s&quot;</span>, msg)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">x</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="开源项目" scheme="https://hedon.top/categories/Go/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="开源项目" scheme="https://hedon.top/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="单元测试" scheme="https://hedon.top/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 负载均衡挑战及解决思路</title>
    <link href="https://hedon.top/2024/05/20/kafka-load-balance/"/>
    <id>https://hedon.top/2024/05/20/kafka-load-balance/</id>
    <published>2024-05-20T02:37:10.000Z</published>
    <updated>2024-05-20T08:15:56.804Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自 Agoda Engineering，介绍了在实际应用中，如何应对 Kafka负载均衡所遇到的各种挑战，并提出相应的解决思路。本文简要阐述了 Kafka的并行性机制、常用的分区策略以及在实际操作中遇到的异构硬件、不均匀工作负载等问题。通过深入分析这些挑战，并提供具体的解决方案，本文旨在帮助读者更好地理解和应用Kafka 的负载均衡技术，从而提高系统的整体性能和稳定性。</p><p>以下大部分内容翻译自原文 <ahref="https://medium.com/agoda-engineering/how-we-solve-load-balancing-challenges-in-apache-kafka-8cd88fdad02b">how-we-solve-load-balancing-challenges-in-apache-kafka</a>，并已获得原作者同意。</p><h1 id="思维导图">思维导图</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Kafka%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"alt="Kafka 负载均衡解决方案" /><figcaption aria-hidden="true">Kafka 负载均衡解决方案</figcaption></figure><h1 id="kafka-并行性">Kafka 并行性</h1><p>Kafka通过分区来实现并行性，如下图所示，生产者（Producer）产生的消息会按照一定的分区策略分配到多个分区（Partition）中，消费组中的每个消费者会分别负责消费其中的若干个分区。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*ixosAmhBDsyBBhoS.png"alt="Kafka 分区演示" /><figcaption aria-hidden="true">Kafka 分区演示</figcaption></figure><p>分区策略：</p><ul><li>轮询（Round Robin）：默认情况下，Kafka使用轮询策略将消息均匀地分配到所有分区。</li><li>哈希（Key Hashing）：如果消息有分区键，Kafka会对键进行哈希计算，将消息分配到特定的分区。</li><li>自定义分区策略：开发者可以实现自定义的分区器（Partitioner）逻辑，以满足特定需求。</li></ul><p>如果要使用轮询或者哈希策略来达到“负载均衡”的目的，那么需要满足以下 2个假设：</p><ol type="1"><li>消费者拥有相同的处理能力，</li><li>消息的工作量相等。</li></ol><p>然而，在实践中，这些假设往往不成立。</p><h1 id="现实挑战">现实挑战</h1><h2 id="异构硬件">1. 异构硬件</h2><p>不同代的服务器硬件性能不同，导致处理速率存在差异。例如，使用不同代硬件进行处理的基准显示性能存在显着差异：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1*B6svY0ZjYVy-uJ7ZA18Jtg.png"alt="不同服务器处理速率差异举例" /><figcaption aria-hidden="true">不同服务器处理速率差异举例</figcaption></figure><h2 id="每条-kafka-消息的工作负载不均匀">2. 每条 Kafka消息的工作负载不均匀</h2><p>下图显示了在一个时间窗口内到达的 12条消息。在这里，生产者向该主题中的六个分区中的每一个发布两条消息。因此，每个worker 消耗来自 2 个分区的数据，这意味着每个 worker 需要处理 4条消息。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*VwPda5gNsHRL2tJV.png"alt="使用循环分区器和循环分配器来分发消息的先前供应系统的演示。每个 worker 都分配有相同数量的消息。" /><figcaptionaria-hidden="true">使用循环分区器和循环分配器来分发消息的先前供应系统的演示。每个worker 都分配有相同数量的消息。</figcaption></figure><p>不同的消息可能需要不同的处理步骤集。例如，处理消息可能涉及调用第三方HTTP端点，并且不同的响应大小或延迟可能会影响处理速率。此外，对于涉及数据库操作的应用程序，其数据库查询的延迟可能会根据查询参数而波动，从而导致处理速率发生变化。</p><h2 id="过度配置问题">3. 过度配置问题</h2><p>由于工作负载和处理效率不同，为了达到系统吞吐量的需求，可能会出现过度配置问题，从而导致资源浪费。</p><p>假设我们的高吞吐量和低吞吐量的处理速率分别为 20 msg/s 和 10msg/s（根据表 1中的数据进行简化）。使用两个较快的处理器和一个较慢的处理器，我们预计总容量为20+20+10 = 50条消息/秒。但是，当保持消息的循环分配时，我们无法达到此容量。下图显示了如果流量持续达到每秒50 条消息时会发生什么情况。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*P-Qa3gyPgXtIeZMx.png"alt="如果传入流量保持在 50 条消息/秒，则慢速处理器无法处理总体消息 1/3 的负载，从而导致累积延迟。为了避免高延迟，向该系统添加了额外的资源以维持处理。" /><figcaption aria-hidden="true">如果传入流量保持在 50条消息/秒，则慢速处理器无法处理总体消息 1/3的负载，从而导致累积延迟。为了避免高延迟，向该系统添加了额外的资源以维持处理。</figcaption></figure><p>从这个例子中我们可以看到，我们的处理器服务一次最多只能接受 30条消息，以防止滞后并确保及时传递更新。</p><p>在这种情况下，要实际每秒处理 50 条消息，我们必须总共扩展到 5台机器，以保证及时处理所有消息。由于这种不适当的分配逻辑（66.7％的过度配置），我们会向该系统过度配置额外的两台机器。</p><p>为了每秒处理 50条消息，我们需要扩展到五台机器以确保及时处理所有消息。由于这种不适当的分配逻辑（66.7%的过度配置），这会导致向该系统过度配置两台额外的机器。</p><h1 id="静态解决方案">静态解决方案</h1><h2 id="在相同的-pod机器上部署">1. 在相同的 Pod（机器）上部署</h2><p>考虑控制服务部署中使用的硬件类型以缓解问题。如果您在虚拟机上部署服务并拥有充足的资源和性能相同的硬件，则此方法是可行的。</p><p>然而，由于成本效益和灵活性下降，在私有云环境中通常不建议采用这种策略，主要是因为同时升级所有现有硬件可能具有挑战性。如果它非常适合您的情况，则可以使用<ahref="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/">Kubernetes关联性将 Pod 分配给某些类型的节点。</a></p><h2 id="加权负载均衡">2. 加权负载均衡</h2><p>如果容量是可预测的并且大部分时间保持静态，则为不同的消费者分配不同的权重可以帮助最大限度地利用可用资源。例如，在为表现较好的消费者赋予更高的权重后，我们可以将更多流量路由给这些消费者。</p><h1 id="动态解决方案">动态解决方案</h1><p>虽然我们可以估计消息的容量和工作负载来设计静态规则来确定加权负载平衡策略，但由于以下几个因素，这种方法在实际生产环境中可能并不总是可行：</p><ul><li>消息的工作负载并不统一，这使得估计机器容量变得困难。</li><li>依赖关系（例如网络和第三方连接）不稳定，有时会导致实际处理中的容量发生变化。</li><li>该系统经常添加新功能，增加额外的维护工作以保持权重更新。</li></ul><p>为了解决这些问题，我们可以动态监控每个分区中的当前滞后并根据当前流量状况做出相应响应。</p><p>有 2 种思路：</p><ol type="1"><li><strong>生产者角度</strong>：使用自定义算法根据滞后的消息数量来确定每个分区的流量，这种生产者称为滞后感知生产者（Lag-awareProducer）。</li><li><strong>消费者角度</strong>：这些消费者旨在监控当前滞后的消息数量，并可以在必要时取消订阅以触发负载重新平衡。通常，可以采用自定义的重新平衡策略来调整分区分配。这种消费者称为滞后感知消费者（Lag-awareComsumer）。</li></ol><h2 id="从生产者角度出发">1. 从生产者角度出发</h2><p>如此图所示，生产者可以使用自定义算法根据滞后确定每个分区的流量。为了减少对Kafka代理的调用次数，系统可以维护一个内部延迟缓存，而不是在发布每条消息之前调用Kafka 代理。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*Mg1lxKzMTy7LRAXT.png"alt="在此示例中，分区 4 和 6 的延迟比其他分区高得多。应减少从内部生产者发送到这些分区的流量。" /><figcaption aria-hidden="true">在此示例中，分区 4 和 6的延迟比其他分区高得多。应减少从内部生产者发送到这些分区的流量。</figcaption></figure><p>使用滞后数据，定制的算法被设计为向经历高滞后的分区发布更少的流量，向低滞后的分区发布更多流量，以平衡每个分区上的工作负载。当滞后平衡且稳定时，此方法应确保消息的均匀分布。</p><p>不适用情况：</p><ol type="1"><li><strong>纯消费者应用程序</strong>：您的应用程序不控制消息生成。</li><li><strong>多个消费者组：</strong>当生成的消息被多个消费者组消费时，生产者可能会为其他消费者组产生不必要的倾斜负载，因为滞后只是特定于一个消费者组的信息。</li></ol><h3 id="相同队列长度算法">相同队列长度算法</h3><p>该算法将每个分区滞后视为处理的队列大小。获取滞后信息后，它会发布适当数量的消息以填充短队列。此方法更适合由于异构硬件而导致的倾斜滞后分布，其中高性能Pod（机器）在大多数情况下能够更快地处理。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*zp-S1Y_GbIzbjCX4.png"alt="相同队列长度算法的演示。最初，不同队列的长度不同。该算法尝试生成不同数量的消息，以在所有队列中实现相同的队列长度。这里，队列长度和 Kafka lag 是同一个概念，代表尚未处理的消息数量" /><figcaptionaria-hidden="true">相同队列长度算法的演示。最初，不同队列的长度不同。该算法尝试生成不同数量的消息，以在所有队列中实现相同的队列长度。这里，队列长度和Kafka lag 是同一个概念，代表尚未处理的消息数量</figcaption></figure><h3 id="异常值检测算法">异常值检测算法</h3><p>该算法利用统计方法来确定所有分区的上离群值，并暂时停止那些慢速离群值的发布过程。在原文章中，针对Agoda 的特定需求，他们提出了 IQR（四分位距）和STD（标准差）异常值检测算法。算法流程图如下所示。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*pjkj5kF6aFcWwBwU.png"alt="异常值检查算法流程" /><figcaption aria-hidden="true">异常值检查算法流程</figcaption></figure><ul><li><strong>慢速分区：</strong>（已关闭）由于存在延迟，这些分区的消息生成已停止。</li><li><strong>好的分区</strong>：（打开）照常发布并均匀分发到所有好的分区。</li><li><strong>OK分区：</strong>（观察/半开放）为了提高性能不佳的机器的性能，当系统尝试将慢速分区提升为良好分区时，会添加一个观察期。通过仅生成一小部分消息并进行观察，可以将该观察阶段优化为“半开放”状态。当滞后获取间隔相对较长时，半开放是有益的，因为它可以防止消费者延迟等待传入消息而更新的滞后数据尚未查询的情况。</li></ul><h2 id="从消费者角度出发">2. 从消费者角度出发</h2><p>这里 Adoga提出的思路是：<strong>遇到高延迟的实例可以主动取消订阅主题以触发重新平衡。在重新平衡期间，可以使用自定义的分配器来平衡所有消费者实例之间的分区。</strong></p><p>触发重新平衡的成本非常昂贵，因为急切的重新平衡会停止消费者组中的所有处理。Kafka2.4中引入的<ahref="https://www.confluent.io/blog/incremental-cooperative-rebalancing-in-kafka/">增量协作再平衡协议</a>已经最大限度地减少了性能影响，允许更频繁的再平衡以更好地分配每个分区上的负载。</p><p>为了增强重新分配的灵活性，分区的数量应该大于 worker的数量。这一比率应根据应用程序而有所不同，并假设一个工作线程至少可以处理来自一个分区的负载以避免饥饿。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*68P7QtdFGeIzwZSs.png"alt="在此示例中，工作程序 3 在速度较慢的硬件上运行，导致分区 5 和 6 出现更高的延迟。因此，工作程序 3 可能会主动取消订阅主题以触发重新平衡并更有效地重新分配分区。在此示例中，应实现自定义分配器以根据机器指标和滞后信息重新分配分区。" /><figcaption aria-hidden="true">在此示例中，工作程序 3在速度较慢的硬件上运行，导致分区 5 和 6 出现更高的延迟。因此，工作程序 3可能会主动取消订阅主题以触发重新平衡并更有效地重新分配分区。在此示例中，应实现自定义分配器以根据机器指标和滞后信息重新分配分区。</figcaption></figure><h1 id="总结">总结</h1><p>本文从 Kafka 并行性的一般实现出发，探讨了 Kafka实现负载均衡在现实实践中可能遇到的各种挑战，并从静态调整和动态调整两个方面给出了解决思路，特别注重讨论了动态调整策略，并分别从生产者和消费者的角度提出了解决方案。</p><p>总之，通过在 Kafka中实现负载均衡，可以有效地将工作负载分配到可用资源之间，从而显著提高服务性能。具体的算法和策略需要根据实际情况进行选择和调整。</p>]]></content>
    
    
    <summary type="html">本文转载自 Agoda Enginnering, 介绍了 Kafka 负载均衡的实际应用过程中的负载均衡挑战及解决思路。</summary>
    
    
    
    <category term="Kafka" scheme="https://hedon.top/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://hedon.top/tags/Kafka/"/>
    
    <category term="中间件" scheme="https://hedon.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="消息队列" scheme="https://hedon.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>学习记录：用 Go 自制解释器 Monkey</title>
    <link href="https://hedon.top/2024/05/12/monkey-language/"/>
    <id>https://hedon.top/2024/05/12/monkey-language/</id>
    <published>2024-05-11T19:44:15.000Z</published>
    <updated>2024-05-20T02:36:16.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="词法分析">词法分析</h1><p>TDD：测试驱动开发</p><p>先写测试用例，再进行词法分析逻辑的完善。</p><h1 id="语法分析">语法分析</h1><p>递归下降语法分析伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go">function parseProgram() &#123;<br>    program = newProgramASTNode()<br>    advanceTokens()<br>    <span class="hljs-keyword">for</span> (currentToken() != EOF_TOKEN) &#123;<br>        statement = null<br>        <span class="hljs-keyword">if</span> (currentToken() == LET_TOKEN) &#123;<br>            statement = parseLetStatement()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken() == RETURN_TOKEN) &#123;<br>            statement = parseReturnStatement()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken() == IF_TOKEN) &#123;<br>            statement = parseIfStatement()<br>        &#125;<br>        <span class="hljs-keyword">if</span> (statement != null) &#123;<br>            program.Statements.push(statement)<br>        &#125;<br>        advanceTokens()<br>    &#125;<br>    <span class="hljs-keyword">return</span> program<br>&#125;<br>function parseLetStatement() &#123;<br>    advanceTokens()<br>    identifier = parseIdentifier()<br>    advanceTokens()<br>    <span class="hljs-keyword">if</span> currentToken() != EQUAL_TOKEN &#123;<br>        parseError(<span class="hljs-string">&quot;no equal sign!&quot;</span>)<br>        <span class="hljs-keyword">return</span> null<br>    &#125;<br>    advanceTokens()<br>    value = parseExpression()<br>    variableStatement = newVariableStatementASTNode()<br>    variableStatement.identifier = identifier<br>    variableStatement.value = value<br>    <span class="hljs-keyword">return</span> variableStatement<br>&#125;<br>function parseIdentifier() &#123;<br>    identifier = newIdentifierASTNode()<br>    identifier.token = currentToken()<br>    <span class="hljs-keyword">return</span> identifier<br>&#125;<br>function parseExpression() &#123;<br>    <span class="hljs-keyword">if</span> (currentToken() == INTEGER_TOKEN) &#123;<br>        <span class="hljs-keyword">if</span> (nextToken() == PLUS_TOKEN) &#123;<br>            <span class="hljs-keyword">return</span> parseOperatorExpression()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextToken() == SEMICOLON_TOKEN) &#123;<br>            <span class="hljs-keyword">return</span> parseIntegerLiteral()<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken() == LEFT_PAREN) &#123;<br>        <span class="hljs-keyword">return</span> parseGroupedExpression()<br>    &#125;<br><span class="hljs-comment">// [...]</span><br>&#125;<br>function parseOperatorExpression() &#123;<br>    operatorExpression = newOperatorExpression()<br>    operatorExpression.left = parseIntegerLiteral()<br>    operatorExpression.operator = currentToken()<br>    operatorExpression.right = parseExpression()<br>    <span class="hljs-keyword">return</span> operatorExpression()<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512042659060.png"alt="递归下降分析法" /><figcaption aria-hidden="true">递归下降分析法</figcaption></figure><h2 id="let-x5">let x=5</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512035446100.png"alt="let stmt AST structure" /><figcaption aria-hidden="true">let stmt AST structure</figcaption></figure><h2 id="return-5">return 5</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512045650041.png"alt="return stmt AST structue" /><figcaption aria-hidden="true">return stmt AST structue</figcaption></figure><h2 id="普拉特解析">普拉特解析</h2>]]></content>
    
    
    <summary type="html">本文主要是记录笔者在学习《用 Go 自制解释器 Monkey》过程中涉及的重要设计理念和思考。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    <category term="Go 实战" scheme="https://hedon.top/categories/Go/Go-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
    <category term="编译原理" scheme="https://hedon.top/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>时间处理基础：Rust 的 chrono 库教程</title>
    <link href="https://hedon.top/2024/05/11/rust-crate-chrono/"/>
    <id>https://hedon.top/2024/05/11/rust-crate-chrono/</id>
    <published>2024-05-11T15:52:55.000Z</published>
    <updated>2024-05-20T02:36:16.099Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中，我们经常有对时间和日期处理的需求。不论是日历应用、日程安排、还是时间戳记录，准确的时间数据处理都是必不可少的。Rust社区提供的 <code>chrono</code> 库以其强大的功能和灵活的接口，在 Rust开发者中广受欢迎。本文将简单介绍 <code>chrono</code>库，展示如何利用它来精确处理和转换时间和日期，帮助你在任何 Rust项目中都能高效地管理时间。</p><h1 id="版本">版本</h1><ul><li><code>chrono</code>: 0.4.38</li></ul><h1 id="结论先行">结论先行</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512010241356.png"alt="chrono 各种时间类型转换图" /><figcaption aria-hidden="true">chrono 各种时间类型转换图</figcaption></figure><h1 id="时间相关概念">时间相关概念</h1><table><thead><tr class="header"><th>概念</th><th>理解</th></tr></thead><tbody><tr class="odd"><td>UNIX 时间戳（UNIX Timestamp）</td><td>也称为 POSIX 时间或 Epoch 时间，是自 1970 年 1 月 1 日（UTC时区）以来经过的秒数，不计入闰秒。这是一种非常通用的时间表示方法，在编程中广泛使用，因为它可以简化时间差的计算。</td></tr><tr class="even"><td>UTC（协调世界时）</td><td>全称为协调世界时（Coordinated UniversalTime），是目前国际上广泛采用的时间标准。它基本上与格林威治平均时（GMT）相同，但在技术上更加精确，因为它使用原子钟来保持时间准确。世界各地的时间都是以UTC 为基础，加上或减去一定的小时数来定义的。</td></tr><tr class="odd"><td>时区（Time Zone）</td><td>时区是地球上划分的标准时间区域。由于地球自西向东旋转，每向东移动一定角度，当地的太阳时间就会相应地提前。世界被分成了24个时区，每个时区通常相差一小时。时区允许地区内的人们能在大致相同的时间内，经历类似的日夜更替模式。</td></tr><tr class="even"><td>UTC+8</td><td>UTC+8 是 UTC 时间加上 8小时的时间区。中国大陆就是位于这个时区。例如，当 UTC 时间为 00:00时，UTC+8 的时间就是 08:00。</td></tr></tbody></table><h1 id="chrono-关键类型">chrono 关键类型</h1><table><thead><tr class="header"><th>类型</th><th>含义</th><th>适用场景</th></tr></thead><tbody><tr class="odd"><td>DateTime&lt;Tz&gt;</td><td>一个带有时区的日期和时间类型，其中 <code>Tz</code> 是实现了<code>TimeZone</code> 特质的类型，如 <code>Utc</code> 和<code>Local</code> 。这意味着 <code>DateTime</code>考虑了时区的影响，可以表示全球任意地点的精确时间。</td><td>广泛用于需要考虑时区转换的场景，如存储用户的本地时间或在不同地区之间转换时间。</td></tr><tr class="even"><td>NaiveDateTime</td><td>一个“天真的”日期和时间，即不包含任何时区信息的日期和时间。这种类型仅仅表示一个日历日期和一天中的时间，而没有任何关于地理或政治时区的数据。</td><td>对于一些时区不重要的场景非常有用，比如记录电影的发行日期或历史事件的日期。</td></tr><tr class="odd"><td>NaiveDate</td><td>仅表示一个日历日期，不包括时间或时区信息。</td><td>它用于处理只需要日期而不关心具体时间的场景，如生日、节日等。</td></tr><tr class="even"><td>NaiveTime</td><td>是一个只表示一天中时间的类型，它不包含日期或时区信息。</td><td>这个类型适用于需要处理具体某个时间点（如开会时间、日常活动的开始时间）但不需要日期数据的情景。</td></tr></tbody></table><h1 id="chrono-时区类型">chrono 时区类型</h1><p><code>chrono</code>支持多种时区类型，方便进行全球时间的转换和计算：</p><ul><li><strong><code>Utc</code></strong>: 用于处理协调世界时。</li><li><strong><code>Local</code></strong>:代表服务器或用户的本地时区。</li><li><strong><code>FixedOffset</code></strong>:允许定义任意的小时和分钟偏移量，适合固定偏移的时间计算。</li></ul><h1 id="常用功能">常用功能</h1><h2 id="获取当前时间">获取当前时间</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span>: DateTime&lt;Local&gt; = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">utc_datetime</span>: DateTime&lt;Utc&gt; = Utc::<span class="hljs-title function_ invoke__">now</span>();<br></code></pre></td></tr></table></figure><h2 id="datetime-转-string">DateTime 转 String</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">to_rfc2822</span>()); <span class="hljs-comment">// Sun, 12 May 2024 00:15:55 +0800</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">to_rfc3339</span>()); <span class="hljs-comment">// 2024-05-12T00:15:55.325058+08:00</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">to_string</span>()); <span class="hljs-comment">// 2024-05-12 00:15:55.325058 +08:00</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.format(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)) <span class="hljs-comment">// 2024-05-12 00:15:55</span><br></code></pre></td></tr></table></figure><h2 id="string-转-datetime">String 转 DateTime</h2><p>字符串带时区信息，使用<code>DateTime::parse_from_str(s, f)</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">format_withzone</span> = <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">datetime_withzone_str</span> = <span class="hljs-string">&quot;2024-01-01 00:00:00 +08:00&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span> =<br>    DateTime::<span class="hljs-title function_ invoke__">parse_from_str</span>(&amp;datetime_withzone_str, &amp;format_withzone).<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><p>字符串无时区信息，使用<code>NaiveDateTime::parse_from_str(s, f)</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">format</span> = <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">datetime_str</span> = <span class="hljs-string">&quot;2024-01-01 00:00:00&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span> = NaiveDateTime::<span class="hljs-title function_ invoke__">parse_from_str</span>(&amp;datetime_str, &amp;format)<br>    .<span class="hljs-title function_ invoke__">unwrap</span>()<br>    .<span class="hljs-title function_ invoke__">and_local_timezone</span>(Local) <span class="hljs-comment">// 转为带时区的 DateTime</span><br>    .<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><h2 id="datetime-转-timestamp">DateTime 转 timestamp</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span> = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;seconds: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp</span>()); <span class="hljs-comment">// 1715444324</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;millis: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp_millis</span>()); <span class="hljs-comment">// 1715444338610</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;micros: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp_micros</span>()); <span class="hljs-comment">// 1715444338610873</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;nacos: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp_nanos_opt</span>().<span class="hljs-title function_ invoke__">unwrap</span>()); <span class="hljs-comment">// 1715444338610873000</span><br></code></pre></td></tr></table></figure><h2 id="timestamp-转-datetime">timestamp 转 DateTime</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">utc_datetime</span>: DateTime&lt;Utc&gt; = DateTime::<span class="hljs-title function_ invoke__">from_timestamp</span>(<span class="hljs-number">1704139200</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// 默认是 Utc</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span>: DateTime&lt;Local&gt; = DateTime::<span class="hljs-title function_ invoke__">from_timestamp</span>(<span class="hljs-number">1704139200</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">into</span>(); <span class="hljs-comment">// 使用 into() 转为 Local</span><br></code></pre></td></tr></table></figure><h2 id="时区转换">时区转换</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> chrono::&#123;DateTime, FixedOffset, Utc&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">utc_date_time</span>: DateTime&lt;Utc&gt; = Utc::<span class="hljs-title function_ invoke__">now</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">fixed_offset</span> = FixedOffset::<span class="hljs-title function_ invoke__">east</span>(<span class="hljs-number">8</span> * <span class="hljs-number">3600</span>); <span class="hljs-comment">// 转为 utc+8 东八区</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">local_date_time</span> = utc_date_time.<span class="hljs-title function_ invoke__">with_timezone</span>(&amp;fixed_offset);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Local time in UTC+8: &#123;&#125;&quot;</span>, local_date_time);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间计算">时间计算</h2><p>时间加减：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> chrono::&#123;Duration, Local&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">now</span> = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">yesterday</span> = now - Duration::<span class="hljs-title function_ invoke__">hours</span>(<span class="hljs-number">24</span>);<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512002330526.png"alt="chrono time duration methods" /><figcaption aria-hidden="true">chrono time duration methods</figcaption></figure><p>时间间隔：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> chrono::&#123;Duration, Local&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">now</span> = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">yesterday</span> = now - Duration::<span class="hljs-title function_ invoke__">hours</span>(<span class="hljs-number">24</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">hour_interval</span> = (now - yesterday).<span class="hljs-title function_ invoke__">num_hours</span>();<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512002106738.png"alt="chrono time interval methods" /><figcaption aria-hidden="true">chrono time interval methods</figcaption></figure><h1 id="总结">总结</h1><p>通过本文的详细介绍和实用示例，我们了解了如何使用 Rust 的<code>chrono</code> 库来精确处理时间和日期。<code>chrono</code>不仅支持复杂的时区计算和全球时间管理，还提供了方便的日期时间解析和格式化工具，以及灵活的时间运算功能。掌握了这些技能后，你将能够在任何需要精确时间数据处理的Rust 应用中，提供稳定和高效的解决方案。</p><p>时间是每个程序的基石，而 <code>chrono</code>就是那把能够操纵时间的魔杖。</p><p>希望本文能对你有帮助，peace! enjoy coding~</p><blockquote><p>参考：</p><ul><li><a href="https://docs.rs/chrono/latest/chrono/">chronocrate</a></li><li><ahref="https://blog.stackademic.com/rust-working-with-date-and-time-30e003cd59e8">rust-working-with-date-and-time</a></li></ul><p>作图：</p><ul><li>https://excalidraw.com/</li></ul></blockquote>]]></content>
    
    
    <summary type="html">本文全面的指南深入介绍了如何在 Rust 中使用 chrono 库来精确处理和转换时间与日期。从基本概念到高级功能，本文提供了实用的代码示例和详尽的解释，帮助你在任何 Rust 项目中高效管理时间。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 常用库" scheme="https://hedon.top/categories/Rust/Rust-%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>epoll</title>
    <link href="https://hedon.top/2024/04/28/epoll/"/>
    <id>https://hedon.top/2024/04/28/epoll/</id>
    <published>2024-04-28T12:27:29.000Z</published>
    <updated>2024-05-20T02:36:16.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><code>epoll</code> 是一种 I/O多路复用技术，主要用于高性能的网络服务器中，特别是在处理大量并发连接时。它是Linux 特有的，自 Linux 内核 2.5.44版本引入，并在后续版本中不断优化。<code>epoll</code>能够帮助服务器高效地管理数以千计的客户端连接，是 <code>select</code> 和<code>poll</code> 方法的现代替代品。</p><p>本文不对 <code>epoll</code>的源码进行分析，仅做原理上的总结，方便快速查阅回顾。各大论坛很多大佬都对<code>epoll</code>的源码进行了详尽的分析，感兴趣的读者可以看「参考」篇章。</p><h1 id="主要特点">主要特点</h1><ol type="1"><li><strong>效率高</strong>: 相较于 <code>select</code> 和<code>poll</code>，<code>epoll</code>可以更高效地处理大量的并发连接。<code>select</code> 和 <code>poll</code>的效率随着监视的文件描述符数量增加而线性下降，而 <code>epoll</code>则不会因为监视的文件描述符数量增加而显著降低效率。</li><li><strong>扩展性好</strong>: <code>epoll</code>使用一种称为事件通知的机制，只会处理那些真正发生了事件的文件描述符。这意味着系统不必重新检查所有文件描述符，从而大大减少了不必要的CPU 开销。</li><li><strong>支持边缘触发和水平触发</strong>: <code>epoll</code> 支持<code>Edge Triggered</code> 和水平触发 <code>Level Triggered</code>两种模式。边缘触发模式只在文件描述符状态改变时才通知应用程序，适用于非阻塞I/O；而水平触发模式则在有事件可读或可写时都会通知应用程序，更容易使用但效率略低。</li></ol><h1 id="结论先行">结论先行</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240429121302958.png"alt="epoll flow chart" /><figcaption aria-hidden="true">epoll flow chart</figcaption></figure><h1 id="工作原理">工作原理</h1><p><code>epoll</code> 的工作可以分为三个主要步骤：</p><ol type="1"><li><strong>创建 epoll 实例</strong>: 使用 <code>epoll_create</code>函数创建一个 <code>epoll</code> 实例。</li><li><strong>添加/修改/删除文件描述符</strong>: 使用<code>epoll_ctl</code> 函数将新的文件描述符添加到 <code>epoll</code>实例中，或者修改、删除已存在的文件描述符。这些操作与文件描述符的数量无关，因此执行速度非常快。</li><li><strong>等待事件发生</strong>: 使用 <code>epoll_wait</code>函数等待事件的发生。这个函数可以同时监控多个文件描述符，当指定的文件描述符上发生了注册的事件时，函数返回，并告知哪些文件描述符上发生了事件。</li></ol><h1 id="et-lt">ET &amp; LT</h1><p>在 <code>epoll</code> 中，边缘触发（ET, EdgeTriggered）和水平触发（LT, LevelTriggered）是两种不同的事件通知方式，它们定义了操作系统如何通知应用程序文件描述符上的I/O 事件。</p><p>这两种模式的主要区别在于何时以及如何多次通知应用程序关于某个文件描述符的事件。</p><h2 id="水平触发level-triggered">水平触发（Level Triggered）</h2><ul><li><strong>定义</strong>: 在水平触发模式下，只要文件描述符上有未处理的I/O 事件存在，<code>epoll_wait</code>就会通知应用程序。这意味着，如果数据可读取但未被完全读取，<code>epoll_wait</code>会在下次调用时再次返回该文件描述符。</li><li><strong>行为</strong>:这种模式更容易编程，因为应用程序可以不用担心在一个操作中处理所有数据。如果数据还在，<code>epoll_wait</code>会继续通知你。</li><li><strong>适用场景</strong>:更适合那些简单的应用或者对实时性要求不是非常高的应用，因为它简化了处理逻辑。</li></ul><h2 id="边缘触发edge-triggered">边缘触发（Edge Triggered）</h2><ul><li><strong>定义</strong>:在边缘触发模式下，只有状态变化时（例如从无数据到有数据），<code>epoll_wait</code>才会通知应用程序。一旦通知了应用程序某事件发生，除非有新的数据到达或状态再次发生变化，否则不会再次通知应用程序该事件。</li><li><strong>行为</strong>:这要求应用程序必须立即处理所有事件，因为之后不会再收到关于这些事件的通知。这意味着应用程序必须循环读取或写入，直到数据被完全处理完，以确保不遗漏任何事件。</li><li><strong>适用场景</strong>:适合需要高性能的场景，因为它减少了事件处理的次数，但要求程序必须更加小心地管理I/O 操作。</li></ul><h2 id="比较和选择">比较和选择</h2><ul><li><strong>性能</strong>:边缘触发通常提供更高的性能，因为它减少了系统调用的次数和不必要的事件处理。</li><li><strong>编程复杂性</strong>:边缘触发模式编程比水平触发复杂，因为需要确保每次事件被彻底处理，并且更容易遇到如“惊群效应”（多个进程或线程被同一个事件唤醒）等问题。</li><li><strong>可靠性</strong>:水平触发因为其简单的行为模式，在可靠性处理上更为直接和容易。</li></ul><p>通常，选择哪种模式取决于应用的具体需求、预期的负载以及开发者对事件处理逻辑的控制程度。高性能服务器通常选择边缘触发模式，以最大化其效率，而简单的或者低负载应用可能会更倾向于使用水平触发，以简化开发和调试过程。</p><h1 id="数据结构">数据结构</h1><p><code>epoll</code> 使用 2种关键的数据结构来维护和跟踪文件描述符（FD）和事件：</p><ol type="1"><li><strong>红黑树（Red-Black Tree）</strong>:用于存储所有注册的文件描述符及其事件。红黑树是一种自平衡二叉搜索树，能够在对数时间内完成插入、删除和查找操作，这使得管理大量文件描述符变得高效。</li><li><strong>就绪列表（Ready List）</strong>:当事件发生（如可读、可写等）并被内核检测到时，相应的 FD会被添加到一个就绪列表中。这个列表仅包含实际有事件发生的文件描述符，从而减少了<code>epoll_wait</code> 调用的处理时间。</li></ol><h1 id="工作细节">工作细节</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/epoll_principle.jpg"alt="epoll data structure" /><figcaption aria-hidden="true">epoll data structure</figcaption></figure><ol type="1"><li>通过调用 <code>epoll_create()</code> 函数创建并初始化一个<code>eventpoll</code> 对象。</li><li>通过调用 <code>epoll_ctl()</code> 函数把被监听的文件句柄 (如 socket句柄) 封装成 <code>epitem</code> 对象并且添加到 <code>eventpoll</code>对象的红黑树中进行管理。</li><li>通过调用 <code>epoll_wait()</code>函数等待被监听的文件状态发生改变。</li><li>当被监听的文件状态发生改变时（如 socket接收到数据），会把文件句柄对应 <code>epitem</code> 对象添加到<code>eventpoll</code> 对象的就绪队列 <code>rdllist</code>中。并且把就绪队列的文件列表复制到 <code>epoll_wait()</code> 函数的<code>events</code> 参数中。</li><li>唤醒调用 <code>epoll_wait()</code> 函数被阻塞（睡眠）的进程。</li></ol><h1 id="事件监听">事件监听</h1><p>内核中的事件监听和回调机制是通过高效的事件驱动模型实现的，而不是简单的循环检查（如在用户空间中的轮询）。这种机制利用了现代操作系统的中断和回调系统，以及针对异步事件的优化处理策略。</p><p>以下是这个过程的详细解释：</p><h2 id="中断和中断处理">1. 中断和中断处理</h2><p>在硬件层面，大多数 I/O 操作（如网络通信、磁盘I/O）都是通过中断驱动的。当一个 I/O设备准备好数据或需要服务时，它会产生一个中断信号，这个信号被发送到CPU。CPU 响应中断，并执行一个预定的中断处理程序（Interrupt ServiceRoutine, ISR），该程序是由设备的驱动程序提供的。</p><h2 id="事件和回调">2. 事件和回调</h2><p>在 ISR中，与设备相关的事件（例如网络包的接收、硬盘读取完成）会被检测到，并且可以在此阶段调用特定的回调函数。这些回调函数是在设备驱动或相关的内核模块中定义的，用来通知内核其他部分或者相关的进程有关事件的发生。</p><h2 id="文件描述符的回调机制">3. 文件描述符的回调机制</h2><p>对于 <code>epoll</code> 等 I/O多路复用技术，内核为每个文件描述符维护了一个事件处理机制。当文件描述符被创建时，相关的设备或资源会注册一组回调函数，这些函数会在特定的操作（如读、写、错误）上被触发。例如，一个网络套接字可能会在数据到达时触发一个“可读”事件的回调。</p><h2 id="epoll-的事件绑定">4. <code>epoll</code> 的事件绑定</h2><p>当一个文件描述符被加入到 <code>epoll</code>监听队列中，<code>epoll</code>会利用这些回调来获得事件通知。<code>epoll</code>操作相关的代码会将一个额外的回调函数绑定到这些文件描述符上。当文件描述符的状态改变时（如数据可读），这个回调函数将被触发，然后它会将相应的文件描述符标记为“就绪”，并放入<code>epoll</code> 的就绪队列。</p><h2 id="事件通知和唤醒">5. 事件通知和唤醒</h2><p>当 <code>epoll_wait</code>被调用且有事件就绪时，内核会检查就绪队列，并将这些事件传递给等待的进程。如果没有事件就绪，进程将被挂起直到有事件发生。事件的发生会触发内核调度程序唤醒相应的进程。</p><h2 id="效率和性能">6. 效率和性能</h2><p>这种基于中断的事件通知机制意味着内核不需要不断循环检查每个文件描述符的状态，从而极大地提高了效率。事件只有在实际发生时才被处理，且处理通常是由硬件中断直接触发的，这使得整个系统更加响应快速，减少了无效的CPU 使用。</p><p>这种设计使得 Linux 内核在处理大量并发 I/O操作时能够保持高效和稳定，适合构建高性能的网络服务和应用。</p><h1 id="中断">中断</h1><p>中断机制是计算机硬件和操作系统核心功能之一，它允许外设或硬件异步地通知CPU 需要处理某些事件。中断机制的实现并不依赖于类似于 <code>for</code>循环的轮询检查，而是建立在更为直接和高效的硬件和处理器架构支持之上。</p><p>当 CPU接收到中断信号时，它是通过一套内建于硬件的协调机制来识别和响应中断的。这个过程涉及硬件电路设计、处理器架构和操作系统的中断管理功能。</p><p>以下是 CPU 如何知道有中断发生，并且如何处理这一中断的详细步骤：</p><h2 id="中断信号的检测和响应">中断信号的检测和响应</h2><ol type="1"><li><p><strong>中断请求线（IRQ）</strong>：外部设备通过连接到处理器的一个特定的硬件线路（IRQ）发送中断信号。这个线路直接与处理器内的中断控制单元（InterruptController）相连。</p></li><li><p><strong>中断控制器</strong>：大多数现代计算机系统使用一个或多个中断控制器来管理中断信号。中断控制器的任务是接收来自各种外部设备的中断请求，并将这些请求优先级排序后发送给CPU。</p></li><li><p><strong>中断向量</strong>：当中断控制器接收到一个中断信号后，它会根据中断源确定一个中断向量。这个向量是一个数字，指向中断向量表中对应的入口，该入口包含了处理该中断的中断服务例程（ISR）的地址。</p></li></ol><h2 id="cpu-如何处理中断">CPU 如何处理中断</h2><ol type="1"><li><p><strong>当前指令的完成</strong>：当 CPU接收到中断控制器发出的中断信号时，它首先会完成当前执行的指令。这是为了保证程序的状态能够正确保存，从而在中断处理完毕后可以无缝地恢复执行。</p></li><li><p><strong>保存上下文</strong>：一旦当前指令执行完毕，CPU会自动保存当前的程序状态，包括程序计数器（PC）、寄存器和其他必要的状态信息。这些信息通常被推送到当前的栈上。</p></li><li><p><strong>跳转到 ISR</strong>：CPU使用中断向量来访问中断向量表，找到与中断号对应的中断服务例程（ISR）的地址，并跳转到该地址开始执行ISR。这个过程是自动的，由处理器的内部机制控制。</p></li><li><p><strong>执行ISR</strong>：中断服务例程会执行必要的操作来处理中断，比如读取数据缓冲区、清除设备状态或发送信号等。</p></li><li><p><strong>恢复上下文并返回</strong>：一旦 ISR执行完成，处理器会从栈上恢复之前保存的程序状态，并将控制权返回到被中断的程序，继续执行。</p></li></ol><h2 id="硬件支持">硬件支持</h2><p>这一过程大量依赖于处理器的硬件支持，如中断向量表通常是固定在处理器的特定内存地址上的。此外，现代处理器如x86架构还提供了更高级的功能，比如支持多重中断控制器和高级可编程中断控制器（APIC）等。</p><p>这种基于硬件的中断响应机制允许 CPU快速有效地处理各种外部事件，确保系统的响应性和稳定性。</p><h1 id="参考">参考</h1><ul><li><ahref="https://blog.csdn.net/zhangyanfei01/article/details/114959103">图解| 深入揭秘 epoll 是如何实现 IO 多路复用的！</a></li><li><ahref="https://blog.csdn.net/zhpCSDN921011/article/details/125580548">一图总结epoll 的总体工作流程</a></li><li><ahref="https://thetechsolo.wordpress.com/2016/02/29/scalable-io-events-vs-multithreading-based/">scalable-io-events-vs-multithreading-based</a></li><li><ahref="https://github.com/liexusong/linux-source-code-analyze/blob/master/epoll-principle.md">Epoll实现原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/667412830">网络编程之 epoll源码深度剖析</a></li></ul>]]></content>
    
    
    <summary type="html">本文总结了高性能网络服务器中大量使用的 I/O 多路复用技术 epoll，涵盖工作原理、数据结构、事件监听和中断等相关内容。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="epoll" scheme="https://hedon.top/tags/epoll/"/>
    
    <category term="网络编程" scheme="https://hedon.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="非阻塞 I/0" scheme="https://hedon.top/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E-I-0/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨并发构建倒排索引</title>
    <link href="https://hedon.top/2024/04/23/rust-action-inverted-index-concurrency/"/>
    <id>https://hedon.top/2024/04/23/rust-action-inverted-index-concurrency/</id>
    <published>2024-04-23T15:13:27.000Z</published>
    <updated>2024-04-28T12:27:13.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>继上篇 <ahref="https://hedon.top/2024/04/15/rust-action-inverted-index-demo/">Rust实战丨倒排索引</a>，本篇我们将参考《Rust程序设计（第二版）》中并发编程篇章来实现高并发构建倒排索引。</p><p>本篇主要分为以下几个部分：</p><ol type="1"><li>功能展示：展示我们最终实现的 2个工具的效果（构建索引、搜索功能）</li><li>阅读源码：阅读书中源码的实现，理清大体思路。</li><li>构建索引：实战构建索引的每个具体环节，并对核心逻辑进行解释和阐述缘由。</li><li>搜索功能：这是书中未曾提供的功能，笔者根据自身理解，对齐上篇提供的功能，实现了一个搜索功能。</li></ol><p>能学到：</p><ul><li>Rust 各种迭代器的使用</li><li>Rust 文件常用操作</li><li>Rust 字符串常用操作</li><li>Rust channel 实战</li><li>Rust 并发编程</li><li>多路合并文件实际应用</li><li>使用 <code>byteorder</code> 进行位操作</li><li>使用 <code>clap</code> 进行 CLI 开发</li><li>终端高亮输出</li><li>深入理解倒排索引高性能的核心细节</li></ul><h1 id="阅读建议">阅读建议</h1><p>本篇内容较为冗长，涉及到的细节讲解可能比较啰嗦，推荐<strong>直接阅读源码，然后对不理解的地方再来本篇对应的章节进行阅读</strong>。</p><p>完成源码位于：https://github.com/hedon-rust-road/inverted-index-concurrency</p><h1 id="版本声明">版本声明</h1><ul><li>Rust: 1.76</li><li>byteordrr: 1.5.0</li><li>clap: 4.5.0</li><li>运行环境：macbookPro Apple M2 Max</li></ul><h1 id="功能展示">功能展示</h1><h2 id="create.rs">create.rs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: create [OPTIONS] &lt;FILENAMES&gt;...<br><br>Arguments:<br>  &lt;FILENAMES&gt;...<br><br>Options:<br>  -s, --single-threaded  Default <span class="hljs-literal">false</span><br>  -h, --<span class="hljs-built_in">help</span>             Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>指定文件目录，构建索引，可以使用 <code>-s</code>使用单线程构建，默认使用并发构建。</p><p>执行示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  inverted-index-concurrency git:(master) ✗ cargo run --bin create ./texts<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.08s<br>     Running `/Users/wangjiahan/rust-target/debug/create ./texts`<br>indexed document 0:<span class="hljs-string">&quot;./texts/text1.txt&quot;</span>, 22 bytes, 5 words<br>indexed document 1:<span class="hljs-string">&quot;./texts/text3.txt&quot;</span>, 27 bytes, 5 words<br>indexed document 2:<span class="hljs-string">&quot;./texts/text2.txt&quot;</span>, 39 bytes, 6 words<br>word count: 16<br>351 bytes main, 736 bytes total<br>wrote file <span class="hljs-string">&quot;./tmp00000001.dat&quot;</span><br></code></pre></td></tr></table></figure><h2 id="search.rs">search.rs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: search --index-file &lt;INDEX_FILE&gt; --term &lt;TERM&gt;<br><br>Options:<br>  -i, --index-file &lt;INDEX_FILE&gt;  Specify index file path<br>  -t, --term &lt;TERM&gt;              Specify search term<br>  -h, --<span class="hljs-built_in">help</span>                     Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>指定索引文件和搜索词来进行搜索。</p><p>执行示例如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423201406903.png"alt="search.rs 执行示例" /><figcaption aria-hidden="true">search.rs 执行示例</figcaption></figure><h1 id="阅读源码">阅读源码</h1><blockquote><p>书中的源码位于：<ahref="https://github.com/ProgrammingRust/fingertips/tree/master">fingertips</a></p></blockquote><p>第一部分我们先来阅读源码，书中展示了这样一张图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image00882.jpeg"alt="索引构建器管道，其中箭头表示通过通道将值从一个线程发送到另一个线程（未展示磁盘 I/O）" /><figcaptionaria-hidden="true">索引构建器管道，其中箭头表示通过通道将值从一个线程发送到另一个线程（未展示磁盘I/O）</figcaption></figure><p>从这张图我们大概可以猜想本案例中构建并发索引的过程可能是：</p><ol type="1"><li>读取文件内容；</li><li>根据文件内容构建索引；</li><li>多个索引进行合并；</li><li>将索引写入文件；</li><li>多个索引文件进行合并。</li></ol><p>按照这个思路的指引，我们打开源码，从 <code>main.rs</code> 的<code>main()</code> 出发：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">single_threaded</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">filenames</span> = <span class="hljs-built_in">vec!</span>[];<br><br>  <span class="hljs-comment">// 命令行参数解析</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ap</span> = ArgumentParser::<span class="hljs-title function_ invoke__">new</span>();<br>        ap.<span class="hljs-title function_ invoke__">set_description</span>(<span class="hljs-string">&quot;Make an inverted index for searching documents.&quot;</span>);<br>        ap.<span class="hljs-title function_ invoke__">refer</span>(&amp;<span class="hljs-keyword">mut</span> single_threaded).<span class="hljs-title function_ invoke__">add_option</span>(<br>            &amp;[<span class="hljs-string">&quot;-1&quot;</span>, <span class="hljs-string">&quot;--single-threaded&quot;</span>],<br>            StoreTrue,<br>            <span class="hljs-string">&quot;Do all the work on a single thread.&quot;</span>,<br>        );<br>        ap.<span class="hljs-title function_ invoke__">refer</span>(&amp;<span class="hljs-keyword">mut</span> filenames).<span class="hljs-title function_ invoke__">add_argument</span>(<br>            <span class="hljs-string">&quot;filenames&quot;</span>,<br>            Collect,<br>            <span class="hljs-string">&quot;Names of files/directories to index. \</span><br><span class="hljs-string">                           For directories, all .txt files immediately \</span><br><span class="hljs-string">                           under the directory are indexed.&quot;</span>,<br>        );<br>        ap.<span class="hljs-title function_ invoke__">parse_args_or_exit</span>();<br>    &#125;<br><br>  <span class="hljs-comment">// 构建索引</span><br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">run</span>(filenames, single_threaded) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(()) =&gt; &#123;&#125;<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error: &#123;&#125;&quot;</span>, err),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>解析命令行参数，这里使用 <code>argparse</code> 这个比较古老的 crate来解析，现在一般是使用 <code>clap</code>。<ul><li><code>single_threaded:</code> 是否使用单线程，默认是多线程。</li><li><code>filenames</code>: 指定的文本文件或目录。</li></ul></li><li><code>run</code> 函数执行构建索引。</li></ol><p>看一下 <code>run</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Generate an index for a bunch of text files.</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(filenames: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;, single_threaded: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">output_dir</span> = PathBuf::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">documents</span> = <span class="hljs-title function_ invoke__">expand_filename_arguments</span>(filenames)?;<br><br>    <span class="hljs-keyword">if</span> single_threaded &#123;<br>        <span class="hljs-title function_ invoke__">run_single_threaded</span>(documents, output_dir)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">run_pipeline</span>(documents, output_dir)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>单线程：run_single_threaded</li><li>多线程：run_pipeline</li></ul><p>先从简单看，单线程，忽略掉源码中定义的特殊数据结构，可以发现跟我们上篇介绍的简单版倒排索引思路基本是一致的，只不过本案例中数据是从文件中读，最后又会将索引写入到文件中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_single_threaded</span>(documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">accumulated_index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">merge</span> = FileMerge::<span class="hljs-title function_ invoke__">new</span>(&amp;output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp_dir</span> = TmpDir::<span class="hljs-title function_ invoke__">new</span>(&amp;output_dir);<br><br>    <span class="hljs-comment">// 迭代每个文本文件</span><br>    <span class="hljs-keyword">for</span> (doc_id, filename) <span class="hljs-keyword">in</span> documents.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>      <span class="hljs-comment">// 打开文件，并将内容读取到 `text` 上</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(filename)?;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>        f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> text)?;<br><br>        <span class="hljs-comment">// 构建索引</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_single_document</span>(doc_id, text);<br>        accumulated_index.<span class="hljs-title function_ invoke__">merge</span>(index);<br>        <span class="hljs-keyword">if</span> accumulated_index.<span class="hljs-title function_ invoke__">is_large</span>() &#123;<br>            <span class="hljs-comment">// 当索引足够大的时候，将其写到文件中</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(accumulated_index, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>            merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>            accumulated_index = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将最后一个索引写入到文件中</span><br>    <span class="hljs-keyword">if</span> !accumulated_index.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(accumulated_index, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>        merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>    &#125;<br>    merge.<span class="hljs-title function_ invoke__">finish</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看本文的重头戏，多线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_pipeline</span>(documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// 将构建索引分为 5 个过程</span><br>    <span class="hljs-keyword">let</span> (texts, h1) = <span class="hljs-title function_ invoke__">start_file_reader_thread</span>(documents);<br>    <span class="hljs-keyword">let</span> (pints, h2) = <span class="hljs-title function_ invoke__">start_file_indexing_thread</span>(texts);<br>    <span class="hljs-keyword">let</span> (gallons, h3) = <span class="hljs-title function_ invoke__">start_in_memory_merge_thread</span>(pints);<br>    <span class="hljs-keyword">let</span> (files, h4) = <span class="hljs-title function_ invoke__">start_index_writer_thread</span>(gallons, &amp;output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">merge_index_files</span>(files, &amp;output_dir);<br><br>    <span class="hljs-comment">// 等待所有线程执行完毕</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = h1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h3.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = h4.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    r1?;<br>    r4?;<br>    result<br>&#125;<br></code></pre></td></tr></table></figure><p>首先将索引构建分成 5 个阶段：</p><p><strong>1. start_file_reader_thread</strong></p><p>就是从文件中读取文本信息，并将其扔进<code>Receiver&lt;String&gt;</code> channel 中，传到下一个阶段。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_reader_thread</span>(<br>    documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;<span class="hljs-type">String</span>&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">filename</span> <span class="hljs-keyword">in</span> documents &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(filename)?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>          <span class="hljs-comment">// 读取文件内容</span><br>            f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> text)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(text).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. start_file_indexing_thread</strong></p><p>从第 1 步传过来的文本信息中调用<code>InMemoryIndex::from_single_document</code> 构建索引。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_indexing_thread</span>(<br>    texts: Receiver&lt;<span class="hljs-type">String</span>&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> (doc_id, text) <span class="hljs-keyword">in</span> texts.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>          <span class="hljs-comment">// 构建索引</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_single_document</span>(doc_id, text);<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. start_in_memory_merge_thread</strong></p><p>将第 2 步构建的单一索引进行合并，并将合并后的索引传到下一个阶段。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_in_memory_merge_thread</span>(<br>    file_indexes: Receiver&lt;InMemoryIndex&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">accumulated_index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">fi</span> <span class="hljs-keyword">in</span> file_indexes &#123;<br>          <span class="hljs-comment">// 将索引进行合并</span><br>            accumulated_index.<span class="hljs-title function_ invoke__">merge</span>(fi);<br>            <span class="hljs-keyword">if</span> accumulated_index.<span class="hljs-title function_ invoke__">is_large</span>() &#123;<br>              <span class="hljs-comment">// 如果索引大小到达阈值，则传到下一阶段</span><br>                <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                accumulated_index = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !accumulated_index.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index);<br>        &#125;<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. start_index_writer_thread</strong></p><p>将第 3 步传来的内存索引写入到临时文件中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_index_writer_thread</span>(<br>    big_indexes: Receiver&lt;InMemoryIndex&gt;,<br>    output_dir: &amp;Path,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;PathBuf&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp_dir</span> = TmpDir::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">index</span> <span class="hljs-keyword">in</span> big_indexes &#123;<br>          <span class="hljs-comment">// 将索引写入临时文件中</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(index, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(file).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5. merge_index_files</strong></p><p>将临时文件进行合并，生成最终的索引文件。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_index_files</span>(files: Receiver&lt;PathBuf&gt;, output_dir: &amp;Path) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">merge</span> = FileMerge::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">file</span> <span class="hljs-keyword">in</span> files &#123;<br>        merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>    &#125;<br>    merge.<span class="hljs-title function_ invoke__">finish</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>这 5 个步骤跟书中给出的示意图基本一致，我们再来看<code>run_pipeline</code> 是如何合并并行的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 join() 等待所有线程完成</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = h1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>h2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>h3.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = h4.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br><span class="hljs-comment">// 阶段 2 和阶段 3 都是纯内存操作，不会有错误</span><br><span class="hljs-comment">// 阶段 1 是读文件，阶段 4 是写文件，所以有可能会报错</span><br>r1?;<br>r4?;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240416001044618.png"alt="run_pipeline 示意图" /><figcaption aria-hidden="true">run_pipeline 示意图</figcaption></figure><p>源码阅读部分差不多就到这了，大的思想架构你应该都能 Get到了，其中每个数据结构的具体实现细节，我们在后面的实战中进行拆解。</p><h1 id="构建索引">构建索引</h1><h2 id="代码结构">代码结构</h2><p>书中源码代码结构如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  fingertips git:(master) ✗ tree<br>.<br>├── Cargo<span class="hljs-selector-class">.lock</span><br>├── Cargo<span class="hljs-selector-class">.toml</span><br>├── LICENSE-MIT<br>├── README<span class="hljs-selector-class">.md</span><br>├── <span class="hljs-attribute">src</span><br>│   ├── index<span class="hljs-selector-class">.rs</span><br>│   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.rs</span><br>│   ├── merge<span class="hljs-selector-class">.rs</span><br>│   ├── read<span class="hljs-selector-class">.rs</span><br>│   ├── tmp<span class="hljs-selector-class">.rs</span><br>│   └── write.rs<br></code></pre></td></tr></table></figure><p>书中给出的源码并没有实现使用构建好的索引文件进行搜索的功能，笔者将在此基础上实现该功能，所以对代码结构进行了简单的调整：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  inverted_index git:(master) ✗ tree<br>.<br>├── Cargo<span class="hljs-selector-class">.lock</span><br>├── Cargo<span class="hljs-selector-class">.toml</span><br>├── index<span class="hljs-selector-class">.bat</span><br>├── <span class="hljs-attribute">src</span><br>│   ├── bin<br>│   │   ├── create<span class="hljs-selector-class">.rs</span><br>│   │   └── search<span class="hljs-selector-class">.rs</span><br>│   ├── index<span class="hljs-selector-class">.rs</span><br>│   ├── lib<span class="hljs-selector-class">.rs</span><br>│   ├── merge<span class="hljs-selector-class">.rs</span><br>│   ├── read<span class="hljs-selector-class">.rs</span><br>│   ├── tmp<span class="hljs-selector-class">.rs</span><br>│   └── write<span class="hljs-selector-class">.rs</span><br>└── texts<br>    ├── text1<span class="hljs-selector-class">.txt</span><br>    ├── text2<span class="hljs-selector-class">.txt</span><br>    └── text3.txt<br></code></pre></td></tr></table></figure><p>可以看到我将核心代码从 <code>bin</code> 改成了 <code>lib</code>，这是为了支持我后面要实现的两个 <code>bin</code>:</p><ul><li><code>create</code>: 构建索引，基本上就是源代码中的<code>main.rs</code></li><li><code>search</code>: 基于生成的索引文件实现搜索功能</li></ul><p><code>texts</code> 是我提供的文本文件样例。</p><p><code>src</code> 目录中的代码阅读顺序及功能划分如下：</p><ul><li><code>index</code>: 定义了内存索引数据结构InMemoryIndex，实现了从文件内容中构建内存索引的基本逻辑，也实现了从索引文件重建内存索引的功能。</li><li><code>tmp</code>: 定义了临时目录数据结构TmpDir，用于存放临时索引文件。</li><li><code>write</code>: 定义了索引文件写入器 IndexFileWriter，实现了将InMemoryIndex 写入文件中的逻辑。</li><li><code>merge</code>: 定义了文件合并器 FileMerge，用于合并 TmpDir的所有索引文件。</li><li><code>read</code>: 定义了索引文件读取器IndexFileWrite，实现了解析索引文件的逻辑。</li></ul><h2 id="项目准备">项目准备</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new --lib inverted_index_concurrency<br></code></pre></td></tr></table></figure><p>Cargo.toml</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;inverted-index-concurrency&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><span class="hljs-attr">license</span> = <span class="hljs-string">&quot;mit&quot;</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">&quot;hedon&quot;</span>]<br><span class="hljs-attr">description</span> = <span class="hljs-string">&quot;a tool to concurrently build an inverted index.&quot;</span><br><br><span class="hljs-section">[[bin]]</span><br><span class="hljs-attr">name</span>=<span class="hljs-string">&quot;create&quot;</span><br><span class="hljs-attr">path</span>=<span class="hljs-string">&quot;src/bin/create.rs&quot;</span><br><br><span class="hljs-section">[[bin]]</span><br><span class="hljs-attr">name</span>=<span class="hljs-string">&quot;search&quot;</span><br><span class="hljs-attr">path</span>=<span class="hljs-string">&quot;src/bin/search.rs&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">byteorder</span> = <span class="hljs-string">&quot;1.5.0&quot;</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.4&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><h2 id="lib.rs">lib.rs</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> index;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> merge;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> read;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> tmp;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> write;<br></code></pre></td></tr></table></figure><p>在 <code>lib.rs</code> 中我们将这 5 个 mod 公开出去，这样就可以给<code>bin</code> 目录中的 <code>crate.rs</code> 和<code>search.rs</code> 使用了。</p><h2 id="index.rs">index.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/index.rs">index.rs</a></p></blockquote><p>第一部分是内存索引的构建。</p><h3 id="tokenize">tokenize</h3><p>我们先定义一个分词函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tokenize</span>(text: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;(&amp;<span class="hljs-type">str</span>, <span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>)&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">res</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">token_start</span> = <span class="hljs-literal">None</span>;<br>    <span class="hljs-keyword">for</span> (idx, ch) <span class="hljs-keyword">in</span> text.<span class="hljs-title function_ invoke__">char_indices</span>() &#123;<br>        <span class="hljs-keyword">match</span> (ch.<span class="hljs-title function_ invoke__">is_alphanumeric</span>(), token_start) &#123;<br>            (<span class="hljs-literal">true</span>, <span class="hljs-literal">None</span>) =&gt; token_start = <span class="hljs-title function_ invoke__">Some</span>(idx),  <span class="hljs-comment">// 每个单词的开始</span><br>            (<span class="hljs-literal">false</span>, <span class="hljs-title function_ invoke__">Some</span>(start)) =&gt; &#123;  <span class="hljs-comment">// 每个单词的结尾</span><br>                res.<span class="hljs-title function_ invoke__">push</span>((&amp;text[start..idx], start, idx - <span class="hljs-number">1</span>));<br>                token_start = <span class="hljs-literal">None</span><br>            &#125;<br>            _ =&gt; &#123;&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(start) = token_start &#123;<br>        res.<span class="hljs-title function_ invoke__">push</span>((&amp;text[start..], start, text.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>))<br>    &#125;<br>    res<br>&#125;<br></code></pre></td></tr></table></figure><p>这个分词函数跟书中源码提供的不一样，为了实现文本高亮，我们需要记录每个分词在原文本中的起始位置和结束位置。它的核心逻辑如下：</p><ol type="1"><li><p>通过 <code>char_indices()</code> 获取 <code>text</code>的字符迭代器，这是一种懒加载的方法，避免一次性将所有 char加载到内存中。</p></li><li><p>匹配 <code>(ch.is_alphanumeric(), token_start)</code>：</p><ul><li>如果是 <code>(true, None)</code>则表示这是一个单词的开始，我们纪录其开始的位置<code>Some(idx)</code>；</li><li>如果是 <code>(false, Some(idx))</code>则表示这是一个单词的结束，我们将其加入到 <code>res</code>中，并记录起始位置和结束位置。</li><li>其他情况，不做处理，要么是非法字符，要么是处于单词中间。</li></ul><p>从这个简单的理解中，你应该可以感受到 Rust 中 match pattern的强大和便捷了，666 👍🏻</p></li></ol><h3 id="struct-inmemoryindex">struct: InMemoryIndex</h3><p>在 <code>index.rs</code> 中，我们定义了三个数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">InMemoryIndex</span> &#123;<br>    <span class="hljs-keyword">pub</span> word_count: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> terms: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;Hit&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> docs: HashMap&lt;<span class="hljs-type">usize</span>, Document&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Document</span> &#123;<br>    <span class="hljs-keyword">pub</span> id: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> path: PathBuf,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Hit</span> = <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;;<br></code></pre></td></tr></table></figure><ul><li><p><code>Document</code>: 文档封装。</p><ul><li><code>id</code>: 文档 id，唯一标识符。</li><li><code>path</code>: 源文件路径。</li></ul></li><li><p><code>Hit</code>:它是一个字节数组，我们按照小端序进行存储，它的存储结构如下：</p><ul><li>[0..3] 存储一个 <code>HITS_SEPERATOR = -1</code>，表示一个<code>Hit</code> 的开始。</li><li>[4..7] 存储一个 u32 的 <code>document_id</code>。</li><li>后面每 8 个 u8 会存在一个 u32 的 <code>start_pos</code> 和一个 u32的 <code>end_pos</code>。</li></ul></li><li><p><code>InMemoryIndex</code>: 内存索引。</p><ul><li><code>word_count</code>:包含的单词（word/term）个数，记录它是为了判断索引是否过大，以便对索引进行分片存储。</li><li><code>terms</code>: 存储 word 到 Hits 的映射，每个 <code>word</code>是一个搜索项。</li><li><code>docs</code>: 存储了 document_id到文档的映射，用于查询原始文档信息。</li></ul></li></ul><p>接下来我们来为 <code>InMemoryIndex</code>实现一系列方法，因为我们期望使用小端序存储 <code>Hit</code>中的数据，所以我们需要引入 <code>byteorder</code> 这个 crate:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add byteorder<br></code></pre></td></tr></table></figure><p>具体实现可参考源码，核心逻辑是 <code>from_single_document</code> 和<code>merge</code>。</p><h3 id="from_single_document">from_single_document</h3><p><strong>from_single_document</strong>的核心逻辑在这一段，它其实跟我们之前实现的简易版倒排索引很相似：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> (token, start_pos, end_pos) <span class="hljs-keyword">in</span> tokens.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hits</span> = index.terms.<span class="hljs-title function_ invoke__">entry</span>(token.<span class="hljs-title function_ invoke__">to_string</span>()).<span class="hljs-title function_ invoke__">or_insert_with</span>(|| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hits</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span>);<br>        hits.write_i32::&lt;LittleEndian&gt;(<span class="hljs-keyword">Self</span>::HITS_SEPERATOR)<br>            .<span class="hljs-title function_ invoke__">unwrap</span>();<br>        hits.write_u32::&lt;LittleEndian&gt;(document_id).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-built_in">vec!</span>[hits]<br>    &#125;);<br><br>    hits[<span class="hljs-number">0</span>].write_u32::&lt;LittleEndian&gt;(*start_pos <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    hits[<span class="hljs-number">0</span>].write_u32::&lt;LittleEndian&gt;(*end_pos <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    index.word_count += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>遍历每个 <code>token</code> 和它在文本中的位置。</li><li>对于每个 <code>token</code>，尝试在索引的 <code>map</code>中查找一个现有的条目。如果不存在，则创建一个新的 <code>Hit</code>记录，并初始化它：<ul><li>创建一个新的 <code>Hit</code> 向量，预留 24字节的容量，这是因为至少要存储 1 个分隔符、1 个 document_id、1 个start_pos 和 1 个 end_pos。</li><li>首先写入 <code>HITS_SEPERATOR</code> 和<code>document_id</code>（使用小端序）。</li></ul></li><li>向对应的 <code>Hit</code> 向量中添加当前单词的位置。</li><li>累加处理的单词总数到 <code>index.word_count</code>。</li></ul><p>这里给个示例，希望可以帮助你理解 <code>InMemoryIndex</code>的内存结构：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">InMemoryIndex</span><br><span class="hljs-string">│</span><br><span class="hljs-string">├──</span> <span class="hljs-attr">word_count:</span> <span class="hljs-string">usize</span><br><span class="hljs-string">│</span><br><span class="hljs-string">├──</span> <span class="hljs-attr">terms:</span> <span class="hljs-string">HashMap&lt;String,</span> <span class="hljs-string">Vec&lt;Hit&gt;&gt;</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span><br><span class="hljs-string">│</span>   <span class="hljs-string">├──</span> <span class="hljs-attr">Key:</span> <span class="hljs-string">&quot;example&quot;</span> <span class="hljs-string">(String)</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Vec&lt;Hit&gt;</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span>       <span class="hljs-string">├──</span> [<span class="hljs-string">HITS_SEPERATOR</span>, <span class="hljs-attr">Document ID:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">Positions:</span> [<span class="hljs-number">10</span>, <span class="hljs-number">19</span>, <span class="hljs-number">30</span>, <span class="hljs-number">39</span>]] <span class="hljs-string">(Hit)</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span>       <span class="hljs-string">└──</span> [<span class="hljs-string">HITS_SEPERATOR</span>, <span class="hljs-attr">Document ID:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">Positions:</span> [<span class="hljs-number">15</span>, <span class="hljs-number">25</span>]] <span class="hljs-string">(Hit)</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span><br><span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-attr">Key:</span> <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-string">│</span>       <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Vec&lt;Hit&gt;</span><br><span class="hljs-string">│</span>           <span class="hljs-string">└──</span> [<span class="hljs-string">HITS_SEPERATOR</span>, <span class="hljs-attr">Document ID:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">Positions:</span> [<span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">50</span>, <span class="hljs-number">69</span>]] <span class="hljs-string">(Hit)</span><br><span class="hljs-string">│</span><br><span class="hljs-string">└──</span> <span class="hljs-attr">docs:</span> <span class="hljs-string">HashMap&lt;u32,</span> <span class="hljs-string">Document&gt;</span><br>    <span class="hljs-string">├──</span> <span class="hljs-attr">Key:</span> <span class="hljs-number">1</span> <span class="hljs-string">(u32)</span><br>    <span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Document</span> &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;path/to/file1.txt&quot;</span>&#125;<br>    <span class="hljs-string">└──</span> <span class="hljs-attr">Key:</span> <span class="hljs-number">2</span><br>        <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Document</span> &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;path/to/file2.txt&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="merge">merge</h3><p><strong>merge</strong> 是用于合并多个<code>InMemoryIndex</code>，起到批处理的目的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, other: InMemoryIndex) &#123;<br>    <span class="hljs-keyword">for</span> (term, hits) <span class="hljs-keyword">in</span> other.terms &#123;<br>        <span class="hljs-keyword">self</span>.terms.<span class="hljs-title function_ invoke__">entry</span>(term).<span class="hljs-title function_ invoke__">or_default</span>().<span class="hljs-title function_ invoke__">extend</span>(hits)<br>    &#125;<br>    <span class="hljs-keyword">self</span>.word_count += other.word_count;<br>    <span class="hljs-keyword">self</span>.docs.<span class="hljs-title function_ invoke__">extend</span>(other.docs);<br>&#125;<br></code></pre></td></tr></table></figure><p>实现完了 <code>InMemoryIndex</code> 后，我们就可以先来完成<code>create.rs</code> 的 <code>run_pipeline</code> 的前 3个阶段了。</p><h3 id="step1-start_file_reader_thread">step1:start_file_reader_thread</h3><ol type="1"><li>读取文件信息：我们需要在独立的线程中依次打开给定的文件列表，并将文件内容读取到一个String 中，并利用 channel 传送出去。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_reader_thread</span>(<br>    documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;(PathBuf, <span class="hljs-type">String</span>)&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handler</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">filename</span> <span class="hljs-keyword">in</span> documents &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(filename.<span class="hljs-title function_ invoke__">clone</span>())?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>            f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> text)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>((filename, text)).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br><br>    (receiver, handler)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="step2-start_file_indexing_thread">step2:start_file_indexing_thread</h3><ol start="2" type="1"><li>构建索引：通过 channel 从第 1 阶段中获取文档文本信息，通过from_single_document 构建索引 InMemoryIndex 后，将索引通过 channel传送出去。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_indexing_thread</span>(<br>    docs: Receiver&lt;(PathBuf, <span class="hljs-type">String</span>)&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handler</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> (doc_id, (path, text)) <span class="hljs-keyword">in</span> docs.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_single_document</span>(doc_id <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>, path, text);<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    (receiver, handler)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="step3-start_in_memory_merge_thread">step3:start_in_memory_merge_thread</h3><ol start="3" type="1"><li>合并索引：通过 channel 从第 2 阶段中获得构建的 InMemoryIndex并将其合并成大索引，然后通过 channel 传送出去。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_in_memory_merge_thread</span>(<br>    indexes: Receiver&lt;InMemoryIndex&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">accumulated_index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> indexes &#123;<br>            accumulated_index.<span class="hljs-title function_ invoke__">merge</span>(i);<br>            <span class="hljs-keyword">if</span> accumulated_index.<span class="hljs-title function_ invoke__">is_large</span>() &#123;<br>                <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                accumulated_index = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !accumulated_index.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index);<br>        &#125;<br>    &#125;);<br><br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><big><strong>补充：为什么采用这种“复杂”的方式来存储数据呢？可否使用JSON 或者 Protobuf 呢？</strong></big></p><p>选择如何组织和存储数据，特别是在实现一个搜索引擎或数据库索引时，是一个关键决策，这会直接影响到程序的性能、可维护性以及扩展性。在这些情况下，使用像<code>byteorder</code> 这样的低级数据格式存储索引信息可能比使用 JSON 或Protobuf 等高级格式更有优势。</p><p>读写速度：</p><ul><li><strong>二进制格式</strong>：直接操作二进制格式通常比解析文本或半结构化的数据格式（如JSON）要快，因为它减少了解析时间和内存使用。在二进制格式中，数据通常是紧密打包的，没有额外的格式标记（如JSON 中的花括号和逗号），这减少了磁盘 I/O 需求。</li><li><strong>文本/半结构化格式</strong>：例如JSON，每次读取时都需要解析文本，转换数据类型，这会增加 CPU的负担，尤其是在大规模数据处理时。</li></ul><p>空间效率：</p><ul><li><strong>二进制格式</strong>：使用最少的字节表示数据，例如使用定长的整数存储文档ID 和位置索引，不仅节省空间，还能提高缓存利用率。</li><li><strong>文本/半结构化格式</strong>：文本格式需要存储额外的字符来标识数据（例如引号和键名），这增加了存储需求。</li></ul><p>适用场景：</p><ul><li><strong>二进制格式</strong>：非常适合需要高性能和大数据处理的后端系统，如搜索引擎和数据库索引。这种格式可以有效地支持快速的数据读取和写入，特别是在资源受限的环境中（如嵌入式系统或低延迟应用）。</li><li><strong>JSON/Protobuf</strong>：更适合需要跨平台兼容性和易于调试的应用场景。例如，在Web 应用中使用 JSON 作为数据交换格式，可以简化前后端的集成和测试。</li></ul>          </div><h2 id="tmp.rs">tmp.rs</h2><p>完成内存索引的构建后，我们需要将构建过程中产生的大索引先临时落盘，后面再进行合并。为了临时存储这些数据文件，我们需要将他们放在一个临时目录中，为此，我们定义了<code>TmpDir</code> 数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TmpDir</span> &#123;<br>    dir: PathBuf,<br>    n: <span class="hljs-type">usize</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>dir</code>: 目录</li><li><code>n</code>: 自增器，用于区分临时文件命名</li></ul><p>接下来为 <code>TmpDir</code> 实现 2 个方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">TmpDir</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>&lt;P: <span class="hljs-built_in">AsRef</span>&lt;Path&gt;&gt;(dir: P) <span class="hljs-punctuation">-&gt;</span> TmpDir &#123;<br>        TmpDir &#123;<br>            dir: dir.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">to_owned</span>(),<br>            n: <span class="hljs-number">1</span>,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">create</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;(PathBuf, BufWriter&lt;File&gt;)&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">r</span>#<span class="hljs-keyword">try</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">filename</span> = <span class="hljs-keyword">self</span><br>                .dir<br>                .<span class="hljs-title function_ invoke__">join</span>(PathBuf::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;tmp&#123;:08x&#125;.dat&quot;</span>, <span class="hljs-keyword">self</span>.n)));<br>            <span class="hljs-keyword">self</span>.n += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">match</span> fs::OpenOptions::<span class="hljs-title function_ invoke__">new</span>()<br>                .<span class="hljs-title function_ invoke__">write</span>(<span class="hljs-literal">true</span>)<br>                .<span class="hljs-title function_ invoke__">create_new</span>(<span class="hljs-literal">true</span>)<br>                .<span class="hljs-title function_ invoke__">open</span>(&amp;filename)<br>            &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(f) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>((filename, BufWriter::<span class="hljs-title function_ invoke__">new</span>(f))),<br>                <span class="hljs-title function_ invoke__">Err</span>(exc) =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> r#<span class="hljs-keyword">try</span> &lt; <span class="hljs-number">999</span> &amp;&amp; exc.<span class="hljs-title function_ invoke__">kind</span>() == io::ErrorKind::AlreadyExists &#123;<br>                        <span class="hljs-comment">// keep going</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(exc);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            r#<span class="hljs-keyword">try</span> += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>new</strong> 方法是 <code>TmpDir</code>的构造函数，其中我们将 <code>n</code> 设置为 1，即文件名从 1开始生成。<code>dir.as_ref().to_owned()</code>接受一个可能是任何类型的路径，将其标准化为一个 <code>Path</code>类型的引用，然后再复制这个引用，创建一个完全独立的、拥有所有权的<code>PathBuf</code> 对象，</p><p><strong>create</strong> 方法是在 <code>TmpDir</code>目录下创建一个临时文件。</p><h2 id="write.rs">write.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/write.rs">write.rs</a></p></blockquote><p>准备好内存索引和临时文件，那我们就需要实现将内存索引写入到文件中的功能了。</p><h3 id="struct-inmemoryindex-1">struct: InMemoryIndex</h3><p>我们先来分析一下如何将 <code>InMemoryIndex</code> 落盘。首先<code>InMemoryIndex</code> 的结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">InMemoryIndex</span> &#123;<br>    <span class="hljs-keyword">pub</span> word_count: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> terms: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;Hit&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> docs: HashMap&lt;<span class="hljs-type">u32</span>, Document&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Document</span> &#123;<br>    <span class="hljs-keyword">pub</span> id: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> path: PathBuf,<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>word_count</code>不需要存储，我们可以计算出来。那我们就需要存储索引 <code>map</code>和文档原数据 <code>docs</code>。为了能精确定位到各个数据，我们需要：</p><p>terms:</p><ul><li>写入 Vec&lt;Hit&gt;</li></ul><p>docs:</p><ul><li>写入 docs 中的每个 Document<ul><li>写入 id</li><li>写入 path 大小</li><li>写入 path</li></ul></li></ul><p>而为了快速定位到每个 term 和 doc的位置，我们需要下面几个值，这几个值将组合起来辅助我们快速定位 terms 或docs，我们后面会将其称为 <strong>Entry</strong>，它包含以下几个值：</p><ul><li><code>term</code>: 索引单词。为了统一，如果 <code>term</code>为空，则表示当前表示的是 doc，否则为 terms。</li><li><code>df</code>: term 的出现次数。为了统一，如果 <code>df</code> 为0，则表示当前表示的是 doc，否则为 terms。</li><li><code>offset</code>: 对应的 terms 或 docs 在文件中的偏移。</li><li><code>nbytes</code>: 对应的 terms 或 docs 的总长度。</li></ul><p>所以文件的内存结构大概如下：</p><table><thead><tr class="header"><th>文件区域</th><th>描述</th><th>指向内容</th></tr></thead><tbody><tr class="odd"><td>头部 （8 字节）</td><td>包含一个指向目录表开始位置的偏移量。</td><td>header</td></tr><tr class="even"><td>主条目</td><td>这些条目按顺序紧密存储，没有额外的元数据。这部分包含实际的数据条目。</td><td>terms + docs</td></tr><tr class="odd"><td>目录表</td><td>存储在文件的最后，包括每个条目的术语信息、文档频率、偏移和大小。</td><td>entries</td></tr></tbody></table><p>示意图如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423194529529.png"alt="索引文件内存结构示意图" /><figcaption aria-hidden="true">索引文件内存结构示意图</figcaption></figure><p>为此我们定义了 <code>IndexFileWriter</code>，它专门用于将<code>InMemoryIndex</code> 写入到临时文件中，定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// A structure to manage writing to an index file efficiently.</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IndexFileWriter</span> &#123;<br>    offset: <span class="hljs-type">u64</span>,<br>    writer: BufWriter&lt;File&gt;,<br>    contents_buf: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>offset</code>: 用于追踪文件中当前的写入位置。</li><li><code>writer</code>:一个缓冲写入器，它包装了一个文件，用于输出操作。</li><li><code>contents_buf</code>:一个向量，用来存储内容条目，在全部写入文件之前暂存在这个缓冲区。</li></ul><p>接下来我们为 <code>IndexFileWriter</code> 实现几个方法：</p><ul><li><code>new</code>:这是一个构造函数，它初始化文件并设置初始偏移量。在文件的开始处写入一个占位符作为头部，这个头部最终会存储主数据区的大小。</li><li><code>write_document</code>:用于将一个文档以二进制格式写入到文件中，同时更新偏移量。</li><li><code>write_main</code>:这个方法接受一段数据，并将它写入文件中，同时更新偏移量。</li><li><code>write_contents_entry</code>: 将一个内容 Entry追加到内部的缓冲区中。Entry包括一个术语、文档频率、术语数据的起始偏移和大小，它用于快速定位 terms或 docs。</li><li><code>finish</code>:完成文件写入过程，将内部缓冲区的内容写入文件，并更新文件头部的主数据大小。</li></ul><h3 id="new">new</h3><p>我们先来看构造方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(<span class="hljs-keyword">mut</span> f: BufWriter&lt;File&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;IndexFileWriter&gt; &#123;<br>    <span class="hljs-keyword">const</span> HEADER_SIZE: <span class="hljs-type">u64</span> = <span class="hljs-number">8</span>;<br>    f.write_u64::&lt;LittleEndian&gt;(<span class="hljs-number">0</span>)?; <span class="hljs-comment">// content start</span><br>    <span class="hljs-title function_ invoke__">Ok</span>(IndexFileWriter &#123;<br>        offset: HEADER_SIZE,<br>        writer: f,<br>        contents_buf: <span class="hljs-built_in">vec!</span>[],<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>new</strong> 分为以下几步：</p><ol type="1"><li><strong>定义头部大小</strong>：<code>const HEADER_SIZE: u64 = 8;</code>：定义一个常量<code>HEADER_SIZE</code>，其值为 8字节，这表示文件头部的大小。这个头部将用于后续在文件的开始处写入主数据区的起始位置。</li><li><strong>写入头部占位符</strong>：<code>f.write_u64::&lt;LittleEndian&gt;(0)?;</code>：在文件的开始处写入一个8字节的占位符，这个值是以小端字节序（<code>LittleEndian</code>）存储的。初始时这里写入的是0，意味着“主数据区的起始位置未知”，这个值在后续的 <code>finish</code>函数中会被更新。</li><li><strong>返回一个新的 IndexFileWriter实例</strong>：<code>Ok(IndexFileWriter &#123; offset: HEADER_SIZE, writer: f, contents_buf: vec![], &#125;)</code>：构造并返回一个<code>IndexFileWriter</code> 实例。这个实例的 <code>offset</code>字段被初始化为 <code>HEADER_SIZE</code>（8字节），表示实际数据将从文件的第 17 个字节开始写入。<code>writer</code>字段就是传入的文件写入器，<code>contents_buf</code>是一个新的空向量，用于临时存储内容条目数据。</li></ol><div class="note note-info">            <p><big><strong>为什么这样设计？</strong></big></p><p>这个实现方式有几个设计上的考虑：</p><ol type="1"><li><strong>预留头部空间</strong>：通过在文件开始处预留 8字节空间来存储主数据区的大小，这样做可以在数据写入完成后，方便地回填这个信息。这是文件格式设计中常见的做法，允许读取者快速定位主数据区和内容索引区。</li><li><strong>使用小端字节序</strong>：小端字节序是一种在二进制文件中常用的字节序，尤其是在Windows平台下。使用小端字节序可以提高文件的兼容性，并且对于多数处理器架构来说，小端字节序的读写操作更为高效。</li><li><strong>灵活的数据写入</strong>：通过将 <code>writer</code> 和<code>contents_buf</code>组合使用，这个结构体可以灵活地处理不同的数据写入需求。<code>writer</code>直接写入文件，适合连续大块数据的写入；而 <code>contents_buf</code>用于聚集多个小片段的数据，可以在最后统一写入，减少磁盘操作次数。</li></ol><p>总的来说，这个构造函数的实现为高效和灵活的文件写操作提供了良好的基础，同时通过合理的错误处理和数据组织方式，确保了程序的健壮性和高性能。</p>          </div><h3 id="write_main">write_main</h3><p>Hit 本身就是一个 Vec&lt;u8&gt;， 将其写入文件很简单，调用<code>write_all</code>，即可，我们为其封装 <code>write_main</code>方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_main</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">write_all</span>(buf)?;<br>    <span class="hljs-keyword">self</span>.offset += buf.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="write_document">write_document</h3><p>为了将 Docuemnt本以二进制结构写入到文件中，我们需要拆分成几个部分：</p><ol type="1"><li>文件 id</li><li>文件路径大小</li><li>文件路径</li></ol><p>为此我们为 <code>IndexFileWriter</code> 封装了<code>write_document</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_document</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, doc: &amp;Document) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.writer.write_u32::&lt;LittleEndian&gt;(doc.id)?;<br>    <span class="hljs-keyword">self</span>.writer<br>        .write_u64::&lt;LittleEndian&gt;(doc.path.<span class="hljs-title function_ invoke__">as_os_str</span>().<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>)?;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">write_all</span>(doc.path.<span class="hljs-title function_ invoke__">as_os_str</span>().<span class="hljs-title function_ invoke__">as_bytes</span>())?;<br>    <span class="hljs-keyword">self</span>.offset += <span class="hljs-number">4</span> + <span class="hljs-number">8</span> + doc.path.<span class="hljs-title function_ invoke__">as_os_str</span>().<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="write_contents_entry">write_contents_entry</h3><p>Entry的数据量一般较小，我们会先写入缓冲中，后面再一次性刷盘，为此我们为<code>IndexFileWriter</code> 封装了<code>write_contents_entry</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Appends a content entry to the internal buffer.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// # Arguments</span><br><span class="hljs-comment">/// * `term` - The term associated with the entry</span><br><span class="hljs-comment">/// * `df` - Document frequency for the term</span><br><span class="hljs-comment">/// * `offset` - Offset where the term data starts in the file</span><br><span class="hljs-comment">/// * `nbytes` - Number of bytes of the term data</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_contents_entry</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, term: <span class="hljs-type">String</span>, df: <span class="hljs-type">u32</span>, offset: <span class="hljs-type">u64</span>, nbytes: <span class="hljs-type">u64</span>) &#123;<br>    <span class="hljs-keyword">self</span>.contents_buf.write_u64::&lt;LittleEndian&gt;(offset).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf.write_u64::&lt;LittleEndian&gt;(nbytes).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf.write_u32::&lt;LittleEndian&gt;(df).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = term.<span class="hljs-title function_ invoke__">bytes</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf<br>        .write_u32::&lt;LittleEndian&gt;(bytes.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>)<br>        .<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf.<span class="hljs-title function_ invoke__">extend</span>(bytes);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="finish">finish</h3><p>刷盘的过程我们封装在 <code>finish</code> 中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">finish</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contents_start</span> = <span class="hljs-keyword">self</span>.offset;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">write_all</span>(&amp;<span class="hljs-keyword">self</span>.contents_buf)?;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">seek</span>(SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(<span class="hljs-number">0</span>))?;<br>    <span class="hljs-keyword">self</span>.writer.write_u64::&lt;LittleEndian&gt;(contents_start)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="write_index_to_tmp_file">write_index_to_tmp_file</h3><p>综合下来，我们就可以实现最核心的函数<code>write_index_to_tmp_file</code> 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_index_to_tmp_file</span>(index: InMemoryIndex, tmp_dir: &amp;<span class="hljs-keyword">mut</span> TmpDir) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;PathBuf&gt; &#123;<br>    <span class="hljs-keyword">let</span> (filename, f) = tmp_dir.<span class="hljs-title function_ invoke__">create</span>()?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">writer</span> = IndexFileWriter::<span class="hljs-title function_ invoke__">new</span>(f)?;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index_as_vec</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = index.terms.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    index_as_vec.<span class="hljs-title function_ invoke__">sort_by</span>(|(a, _), (b, _)| a.<span class="hljs-title function_ invoke__">cmp</span>(b));<br><br>    <span class="hljs-keyword">for</span> (term, hits) <span class="hljs-keyword">in</span> index_as_vec &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">df</span> = hits.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span> = writer.offset;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">buffer</span> <span class="hljs-keyword">in</span> hits &#123;<br>            writer.<span class="hljs-title function_ invoke__">write_main</span>(&amp;buffer)?;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stop</span> = writer.offset;<br>        writer.<span class="hljs-title function_ invoke__">write_contents_entry</span>(term, df, start, stop - start);<br>    &#125;<br><br>    <span class="hljs-comment">// if term == &quot;&quot; &amp;&amp; df == 0 &#123; type = document &#125;</span><br>    <span class="hljs-keyword">for</span> (_, doc) <span class="hljs-keyword">in</span> index.docs &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span> = writer.offset;<br>        writer.<span class="hljs-title function_ invoke__">write_document</span>(&amp;doc)?;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stop</span> = writer.offset;<br>        writer.<span class="hljs-title function_ invoke__">write_contents_entry</span>(<span class="hljs-string">&quot;&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">0</span>, start, stop - start)<br>    &#125;<br><br>    writer.<span class="hljs-title function_ invoke__">finish</span>()?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;wrote file &#123;:?&#125;&quot;</span>, filename);<br>    <span class="hljs-title function_ invoke__">Ok</span>(filename)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>我们在临时目录中创建一个临时文件，并初始化 IndexFileWriter；</li><li>将索引的 <code>terms</code> 转换成一个向量并按照键排序；</li><li>对于每个<code>term</code>，计算文档频率（<code>df</code>），记录开始和结束位置，然后调用<code>write_main</code> 方法将数据写入文件，然后使用<code>write_contents_entry</code> 方法写入 <code>Entry</code>的元数据到目录表；</li><li>对于 <code>index.docs</code>中的每个文档，计算起止位置，并使用一个特殊的条目（空字符串作为条目名和 0作为文档频率）标记在文件中；</li><li>最后我们使用 <code>finish</code> 将缓存中所有的 <code>Entry</code>刷盘，并设置 <code>entries</code> 的起始位置。</li></ol><p>文件的内存结构如上面给出的图一样，这里我们可以再看一次：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423194529529-20240423195227516.png"alt="索引文件内存结构示意图" /><figcaption aria-hidden="true">索引文件内存结构示意图</figcaption></figure><h3 id="step4-start_index_writer_thread">step4:start_index_writer_thread</h3><p>实现了将内存索引写入到文件的功能后，我们就可以继续在<code>create.rs</code> 中实现下一个流程了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_index_writer_thread</span>(<br>    big_indexes: Receiver&lt;InMemoryIndex&gt;,<br>    output_dir: &amp;Path,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;PathBuf&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp_dir</span> = TmpDir::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> big_indexes &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;word count: &#123;&#125;&quot;</span>, i.word_count);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(i, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(file).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br><br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>start_index_writer_thread</code>流程中，我们将构建好的内存索引一个个写入到文件中，并将生成的文件句柄传入下一个流程。</p><h2 id="merge.rs">merge.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/merge.rs">merge.rs</a></p></blockquote><p>前面 <code>start_index_writer_thread</code> 是将一个个<code>InMemoryIndex</code> 写入到 <code>TmpDir</code>临时目录中。现在我们要将这些临时文件合并成一个最终的索引文件，以优化查询效率和节省存储空间。</p><h3 id="srtuct-filemerge">srtuct: FileMerge</h3><p>我们定义一下结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">FileMerge</span> &#123;<br>    output_dir: PathBuf,<br>    tmp_dir: TmpDir,<br>    stacks: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;PathBuf&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>output_dir</code>: 用于存储最终合并文件的输出目录。</li><li><code>tmp_dir</code>: 前面 <code>tmp.rs</code>定义的结构，用于管理合并过程中产生的临时文件。</li><li><code>stacks</code>:这是一个二维向量，每个内部向量代表一个合并“层”，存储了该层待合并的文件路径。</li></ul><p>关于 <code>stacks</code>，再多说两点：</p><ul><li><strong>多级合并策略</strong>: <code>FileMerge</code>使用一个多层合并策略，这种策略在处理大量文件时尤为有效。基本思想是，当一层的文件数量达到一个预设的阈值（<code>NSTREAMS</code>）时，这些文件会被合并成一个新的文件，新文件则被推送到上一层。这种层级式的处理方式可以显著减少最终合并步骤需要处理的文件数量，从而优化性能。</li><li><strong>动态扩展</strong>：使用<code>Vec&lt;Vec&lt;PathBuf&gt;&gt;</code>允许动态地添加新的合并层，这在处理不确定数量的文件时非常有用。向量的灵活性意味着无需预先知道将处理多少文件，它可以根据实际需要进行扩展。</li></ul><p>接下来我们会为 <code>FileMerge</code> 实现 2 个方法：</p><ul><li><code>add_file</code>:添加一个文件到合并栈中，并使用多级合并策略进行合并。</li><li><code>finish</code>: 执行最后的合并操作，生成最终的索引文件，输出到<code>output_dir</code> 中。</li></ul><h3 id="add_file">add_file</h3><p>首先我们来看<code>add_file</code>，它的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_file</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, <span class="hljs-keyword">mut</span> file: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><span class="hljs-comment">// 从第一层开始检查</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">level</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 使用循环来处理文件的添加和可能的合并。</span><br>    <span class="hljs-keyword">loop</span> &#123;<br><br>      <span class="hljs-comment">// 如果当前的 level （层级）不存在于 stacks 中，</span><br>        <span class="hljs-comment">// 就在 stacks 中添加一个新的空向量。</span><br>        <span class="hljs-comment">// 这是为了存放该层级的文件。</span><br>        <span class="hljs-keyword">if</span> level == <span class="hljs-keyword">self</span>.stacks.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-keyword">self</span>.stacks.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-built_in">vec!</span>[]);<br>        &#125;<br><br>        <span class="hljs-comment">// 将当前的文件添加到对应层级的向量中。</span><br>        <span class="hljs-keyword">self</span>.stacks[level].<span class="hljs-title function_ invoke__">push</span>(file);<br><br>        <span class="hljs-comment">// 如果这个级别的堆栈已满，就合并这个级别的文件。</span><br>      <span class="hljs-comment">// 如果没满，则不进行合并，直接退出。</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.stacks[level].<span class="hljs-title function_ invoke__">len</span>() &lt; NSTREAMS &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建一个新文件来存储合并结果，并更新堆栈。</span><br>        <span class="hljs-keyword">let</span> (filename, out) = <span class="hljs-keyword">self</span>.tmp_dir.<span class="hljs-title function_ invoke__">create</span>()?;<br><br>        <span class="hljs-comment">// 初始化一个空的 to_merge 向量，</span><br>      <span class="hljs-comment">// 然后使用 mem::swap 交换当前层级的文件列表和这个空向量，</span><br>        <span class="hljs-comment">// 这样 to_merge 向量就包含了需要合并的文件，</span><br>        <span class="hljs-comment">// 而当前层级变为空，可以用来存放新的合并文件。</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">to_merge</span> = <span class="hljs-built_in">vec!</span>[];<br>        mem::<span class="hljs-title function_ invoke__">swap</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.stacks[level], &amp;<span class="hljs-keyword">mut</span> to_merge);<br><br>        <span class="hljs-comment">// 调用 merge_streams 函数将 to_merge 中的文件合并到新创建的文件中。</span><br>        <span class="hljs-title function_ invoke__">merge_streams</span>(to_merge, out)?;<br><br>        <span class="hljs-comment">// 将合并后得到的新文件路径赋值给 file 变量，用于下一轮循环。</span><br>        file = filename;<br>        <span class="hljs-comment">// level 加一，表示移动到下一个层级。</span><br>        level += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法通过层级的方式管理文件合并，每个层级可以有多个文件，但数量上限为<code>NSTREAMS</code>。如果某层满了，就将该层的文件合并成一个新文件，并将这个新文件移动到上一层继续参与合并。这种设计有效地将多个文件逐步合并成一个文件，同时控制内存和I/O 资源的使用。</p><p>其中 <code>merge_streams</code>就是具体的合并过程，它的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_streams</span>(files: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, out: BufWriter&lt;File&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>  <span class="hljs-comment">// 从索引文件中构建 IndexFileReader 列表</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">streams</span>: <span class="hljs-type">Vec</span>&lt;IndexFileReader&gt; = files<br>        .<span class="hljs-title function_ invoke__">into_iter</span>()<br>        .<span class="hljs-title function_ invoke__">map</span>(|p| IndexFileReader::<span class="hljs-title function_ invoke__">open_and_delete</span>(p, <span class="hljs-literal">true</span>))<br>        .collect::&lt;io::<span class="hljs-type">Result</span>&lt;_&gt;&gt;()?;<br><br>  <span class="hljs-comment">// 针对输出文件生成一个 IndexFileWriter 用于写入索引信息</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">output</span> = IndexFileWriter::<span class="hljs-title function_ invoke__">new</span>(out)?;<br>  <span class="hljs-comment">// 用于记录当前写入的位置（或者数据偏移量）。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">point</span>: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 记录还有数据未处理的文件流数量，用 peek() 方法检查。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = streams.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|s| s.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">is_some</span>()).<span class="hljs-title function_ invoke__">count</span>();<br><br>  <span class="hljs-comment">// 只要 count 大于0，表示还有文件未完全处理，就继续循环。</span><br>    <span class="hljs-keyword">while</span> count &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">term</span> = <span class="hljs-literal">None</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">nbytes</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">df</span> = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 这段代码通过遍历每个文件流，使用 peek() 方法预览每个文件的当前数据条目</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> &amp;streams &#123;<br>            <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">peek</span>() &#123;<br>                <span class="hljs-literal">None</span> =&gt; &#123;&#125;<br>                <span class="hljs-title function_ invoke__">Some</span>(entry) =&gt; &#123;<br>                  <span class="hljs-comment">// term 是空的，则说明这是表示 doc 的 entry。</span><br>                  <span class="hljs-comment">// 直接退出 for 循环，因为 doc 的 entry 没有顺序且唯一，不会进行累加。</span><br>                    <span class="hljs-keyword">if</span> entry.term.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                        term = <span class="hljs-title function_ invoke__">Some</span>(entry.term.<span class="hljs-title function_ invoke__">clone</span>());<br>                        nbytes = entry.nbytes;<br>                        df = entry.df;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                  <span class="hljs-comment">// term 不是空的，则说明这是表示 terms 的 entry。</span><br>                    <span class="hljs-comment">// 选择词条最小的一个（字典序），并且累加其出现的频次和字节大小。</span><br>                    <span class="hljs-comment">// 这是多路归并的核心，确保输出文件是有序的。</span><br>                    <span class="hljs-keyword">if</span> term.<span class="hljs-title function_ invoke__">is_none</span>() || entry.term &lt; *term.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>() &#123;<br>                        term = <span class="hljs-title function_ invoke__">Some</span>(entry.term.<span class="hljs-title function_ invoke__">clone</span>());<br>                        nbytes = entry.nbytes;<br>                        df = entry.df<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> entry.term == *term.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>() &#123;<br>                        nbytes += entry.nbytes;<br>                        df += entry.df<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">term</span> = term.<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;bug in algorithm&quot;</span>);<br><br>      <span class="hljs-comment">// 对于每个文件流，如果当前数据条目与选择的 term 相同，</span><br>        <span class="hljs-comment">// 则将该条目写入输出文件，并更新该流的读取位置。</span><br>      <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> streams &#123;<br>            <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">is_at</span>(&amp;term) &#123;<br>                s.<span class="hljs-title function_ invoke__">move_entry_to</span>(&amp;<span class="hljs-keyword">mut</span> output)?;<br>                <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>                    count -= <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> term.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        output.<span class="hljs-title function_ invoke__">write_contents_entry</span>(term, df, point, nbytes);<br>        point += nbytes<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到了一个新的结构<code>IndexFileReader</code>，它是索引文件的读取器，我们将在<code>read.rs</code> 中实现它。这里先不展开，你只需要知道：</p><ul><li><code>IndexFileReader::open_and_delete(p, true)</code>:打开一个索引文件，并根据传入的参数判断是否要删除这个文件，在合并过程中，因为都是临时文件，所以我们会指定为删除文件。但是在后面从索引文件中重建<code>InMemoryIndex</code> 的时候，我们不希望删除原始的索引文件。</li><li><code>s.peek()</code>: 查看下一个 Entry，它的返回值是Option&lt;Entry&gt;。</li><li><code>s.move_entry_to(&amp;mut output)</code>: 将<code>s.peek()</code> 指向的 Entry 写入到 output 文件中，并移动到一下Entry。</li></ul><p>总结下来，这个函数实现多路归并的核心部分，它将多个索引文件合并成一个单一的有序文件。</p><h3 id="finish-1">finish</h3><p>我们再来看 <code>FileMerge</code> 的另外一个方法<code>finish</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">finish</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><br>    <span class="hljs-comment">// 初始化一个临时向量 tmp，用来暂存需要合并的文件路径。</span><br>    <span class="hljs-comment">// 这个向量的容量设置为 NSTREAMS，这是预先定义的常量，表示一次可以合并的最大文件数。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(NSTREAMS);<br><br>    <span class="hljs-comment">// 方法遍历 self.stacks 中的每个堆栈。每个堆栈代表一个合并层级，包含若干待合并的文件。</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stack</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.stacks &#123;<br>        <span class="hljs-comment">// 对于每个堆栈，方法使用 .into_iter().rev() 迭代器反向遍历文件，</span><br>      <span class="hljs-comment">// 以确保按正确的顺序处理（先进后出）。</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">file</span> <span class="hljs-keyword">in</span> stack.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>            <span class="hljs-comment">// 将文件逐个添加到 tmp 向量中。</span><br>            tmp.<span class="hljs-title function_ invoke__">push</span>(file);<br>            <span class="hljs-comment">// 当 tmp 的长度达到 NSTREAMS 时，</span><br>          <span class="hljs-comment">// 调用 merge_reversed 函数进行合并。</span><br>            <span class="hljs-keyword">if</span> tmp.<span class="hljs-title function_ invoke__">len</span>() == NSTREAMS &#123;<br>                <span class="hljs-title function_ invoke__">merge_reversed</span>(&amp;<span class="hljs-keyword">mut</span> tmp, &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.tmp_dir)?;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">// 对于剩余文件进行最终的合并。</span><br>    <span class="hljs-keyword">if</span> tmp.<span class="hljs-title function_ invoke__">len</span>() &gt; <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-title function_ invoke__">merge_reversed</span>(&amp;<span class="hljs-keyword">mut</span> tmp, &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.tmp_dir)?;<br>    &#125;<br><br>  <span class="hljs-comment">// 最后应该只有一个最终文件</span><br>    <span class="hljs-built_in">assert!</span>(tmp.<span class="hljs-title function_ invoke__">len</span>() == <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">match</span> tmp.<span class="hljs-title function_ invoke__">pop</span>() &#123;<br>      <span class="hljs-comment">// 对文件进行重命名</span><br>        <span class="hljs-title function_ invoke__">Some</span>(last_file) =&gt; fs::<span class="hljs-title function_ invoke__">rename</span>(last_file, <span class="hljs-keyword">self</span>.output_dir.<span class="hljs-title function_ invoke__">join</span>(MERGED_FILENAME)),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-title function_ invoke__">Err</span>(io::Error::<span class="hljs-title function_ invoke__">new</span>(<br>            io::ErrorKind::Other,<br>            <span class="hljs-string">&quot;no ducuments were parsed or none contained any words&quot;</span>,<br>        )),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到了另外一个函数 <code>merge_reversed</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_reversed</span>(filenames: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, tmp_dir: &amp;<span class="hljs-keyword">mut</span> TmpDir) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    filenames.<span class="hljs-title function_ invoke__">reverse</span>();<br>    <span class="hljs-keyword">let</span> (merge_filename, out) = tmp_dir.<span class="hljs-title function_ invoke__">create</span>()?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">to_merge</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(NSTREAMS);<br>    mem::<span class="hljs-title function_ invoke__">swap</span>(filenames, &amp;<span class="hljs-keyword">mut</span> to_merge);<br>    <span class="hljs-title function_ invoke__">merge_streams</span>(to_merge, out)?;<br>    filenames.<span class="hljs-title function_ invoke__">push</span>(merge_filename);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>它其实就是将 <code>filenames</code> 翻转，清空并将内容转移到<code>to_merge</code>，然后调用 <code>merge_streams</code>合并，并将合并后的文件重新放回被清空的<code>filenames</code>，也就是我们在 <code>finish</code> 中声明的<code>tmp</code> 变量。</p><div class="note note-info">            <p><big><strong>为什么这里需要翻转 filenames？</strong></big></p><p>假设 NSTREAMS = 3，我们执行 <code>add_file</code>，从<code>file1</code> 到 <code>file8</code>，那么过程如下：</p><table><thead><tr class="header"><th>Action</th><th>Stack 0</th><th>Stack 1</th><th>Notes</th></tr></thead><tbody><tr class="odd"><td>Add file1</td><td>file1</td><td></td><td></td></tr><tr class="even"><td>Add file2</td><td>file1, file2</td><td></td><td></td></tr><tr class="odd"><td>Add file3</td><td>file1, file2, file3</td><td></td><td></td></tr><tr class="even"><td>Merge S1</td><td>(empty)</td><td>merge1</td><td><code>merge1</code> is the result of merging file1-file3</td></tr><tr class="odd"><td>Add file4</td><td>file4</td><td>merge1</td><td></td></tr><tr class="even"><td>Add file5</td><td>file4, file5</td><td>merge1</td><td></td></tr><tr class="odd"><td>Add file6</td><td>file4, file5, file6</td><td>merge1</td><td></td></tr><tr class="even"><td>Merge S2</td><td>(empty)</td><td>merge1, merge2</td><td><code>merge2</code> is the result of merging file4-file6</td></tr><tr class="odd"><td>Add file7</td><td>file7</td><td>merge1, merge2</td><td></td></tr><tr class="even"><td>Add file8</td><td>file7, file8</td><td>merge1, merge2</td><td>Trigger merge because 8 files are reached</td></tr></tbody></table><p>最后我们获得的结果是：</p><table><thead><tr class="header"><th>stack0</th><th>stack1</th></tr></thead><tbody><tr class="odd"><td>file7, file8</td><td>merge1, merge2</td></tr></tbody></table><p>按照文件的添加顺序，我们期望在 <code>finish</code>中合并的顺序应该是：merge1, merge2, file7, file8。所以我们遍历<code>stacks</code> 的时候，从第 1 层开始遍历的话，我们就需要反向遍历<code>rev()</code>，这个时候我们组成的 <code>tmp</code> 就是：file8,file7, merge2, merge1。最后我们传入 <code>merge_reversed</code>的时候，再进行 <code>reverse()</code>，就可以获得我们期望的顺序 merge1,merge2, file7, file8。</p>          </div><p>回过头来，我们总结一下<code>finish</code>：这个方法通过多级合并的方式，逐层处理并最终合并所有文件到一个文件。这个方法确保在多个文件频繁合并的环境中，能有效地管理和减少临时存储使用，并保持合并操作的效率。通过最后的重命名操作，它还处理了文件的最终存放，确保合并结果的正确性和可用性。</p><p>实现了 <code>merge.rs</code> 的相关内容，我们就可以来实现<code>create.rs</code> 中的最后一步了。</p><h3 id="step5-merge_index_files">step5: merge_index_files</h3><p>我们将第 4 阶段构建的临时文件合并成一个最终的索引文件并输出到<code>output_dir</code> 目录中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_index_files</span>(files: Receiver&lt;PathBuf&gt;, output_dir: &amp;Path) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">merge</span> = FileMerge::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">file</span> <span class="hljs-keyword">in</span> files &#123;<br>        merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>    &#125;<br>    merge.<span class="hljs-title function_ invoke__">finish</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="run_pipeline">run_pipeline</h3><p>至此，我们就完成了并发构建倒排索引的 5个步骤了，对其进行组织，就可以实现我们的并发构建函数<code>run_pipeline</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_pipeline</span>(documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// Launch all five stages of the pipeline.</span><br>    <span class="hljs-keyword">let</span> (texts, h1) = <span class="hljs-title function_ invoke__">start_file_reader_thread</span>(documents);<br>    <span class="hljs-keyword">let</span> (pints, h2) = <span class="hljs-title function_ invoke__">start_file_indexing_thread</span>(texts);<br>    <span class="hljs-keyword">let</span> (gallons, h3) = <span class="hljs-title function_ invoke__">start_in_memory_merge_thread</span>(pints);<br>    <span class="hljs-keyword">let</span> (files, h4) = <span class="hljs-title function_ invoke__">start_index_writer_thread</span>(gallons, &amp;output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">merge_index_files</span>(files, &amp;output_dir);<br><br>    <span class="hljs-comment">// Wait for threads to finish, holding on to any errors that they encounter.</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = h1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h3.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = h4.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// Return the first error encountered, if any.</span><br>    <span class="hljs-comment">// (As it happens, h2 and h3 can&#x27;t fail: those threads</span><br>    <span class="hljs-comment">// are pure in-memory data processing.)</span><br>    r1?;<br>    r4?;<br>    result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="read.rs">read.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/read.rs">read.rs</a></p></blockquote><p>在 <code>merge.rs</code> 中，我们还剩最后一个结构没有解析，那就是<code>IndexFileReader</code>，它是索引文件的读取器。</p><h3 id="struct-indexfilereader">struct: IndexFileReader</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IndexFileReader</span> &#123;<br>    <span class="hljs-keyword">pub</span> terms_docs: BufReader&lt;File&gt;,<br>    entries: BufReader&lt;File&gt;,<br>    next: <span class="hljs-type">Option</span>&lt;Entry&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">pub</span> term: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> df: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> offset: <span class="hljs-type">u64</span>,<br>    <span class="hljs-keyword">pub</span> nbytes: <span class="hljs-type">u64</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 <code>IndexFileReader</code> 结构体中定义两个<code>BufReader&lt;File&gt;</code>，这是为了有效管理和操作索引文件中的不同数据段。具体来说，这种设计使得代码能够更加灵活和高效地处理索引文件中的“主数据区”和“内容表区”。</p><p>即用来分别处理下图的 <code>terms&amp;doc</code> 和<code>entries</code> 两个区域：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423194529529-20240423195227516.png"alt="索引文件内存结构示意图" /><figcaption aria-hidden="true">索引文件内存结构示意图</figcaption></figure><p>这有几个好处：</p><ul><li><strong>独立的文件指针</strong>：每个<code>BufReader&lt;File&gt;</code>维护自己的文件读取位置（文件指针）。这意味着读取或搜索内容表时，不会影响主数据区的文件指针，反之亦然。这样可以避免频繁地重新定位文件指针，提高文件操作的效率。</li><li><strong>缓冲读取</strong>：<code>BufReader</code>提供了缓冲读取功能，可以减少直接对硬盘的读取次数，从而优化读取性能。对于需要频繁读取小块数据的索引操作，使用缓冲读取可以显著提高效率。</li><li><strong>并行操作</strong>：在多线程环境中，可能需要同时读取主数据区和内容表区。使用两个独立的<code>BufReader</code>实例可以简化并行读取的管理，每个读取操作都可以在不干扰另一个操作的情况下独立进行。</li></ul><p><code>Entry</code> 就是我们在 <code>write.rs</code> 中<code>write_contents_entry</code> 时传入的参数，这里我们将其封装成一个struct，再次回顾下这几个字段的含义：</p><ul><li><code>term</code>: 索引单词。为了统一，如果 <code>term</code>为空，则表示当前表示的是 doc，否则为 terms。</li><li><code>df</code>: term 的出现次数。为了统一，如果 <code>df</code> 为0，则表示当前表示的是 doc，否则为 terms。</li><li><code>offset</code>: 对应的 terms 或 docs 在文件中的偏移。</li><li><code>nbytes</code>: 对应的 terms 或 docs 的总长度。</li></ul><h3 id="read_entry">read_entry</h3><p>这里我们重点解释一下 <code>read_entry</code>方法，其他的都比较简单，请在源码中查找。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_entry</span>(f: &amp;<span class="hljs-keyword">mut</span> BufReader&lt;File&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">Option</span>&lt;Entry&gt;&gt; &#123;<br>  <span class="hljs-comment">// 获取偏移值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">offset</span> = <span class="hljs-keyword">match</span> f.read_u64::&lt;LittleEndian&gt;() &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(value) =&gt; value,<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> err.<span class="hljs-title function_ invoke__">kind</span>() == io::ErrorKind::UnexpectedEof &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-literal">None</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(err);<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>  <span class="hljs-comment">// 读取 nbytes</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">nbytes</span> = f.read_u64::&lt;LittleEndian&gt;()?;<br>  <span class="hljs-comment">// 读取 df</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">df</span> = f.read_u32::&lt;LittleEndian&gt;()?;<br>  <span class="hljs-comment">// 读取 term_len，并初始化一块内存 bytes 用来读取完整的 term</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">term_len</span> = f.read_u32::&lt;LittleEndian&gt;()? <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">bytes</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; term_len];<br>    f.<span class="hljs-title function_ invoke__">read_exact</span>(&amp;<span class="hljs-keyword">mut</span> bytes)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">term</span> = <span class="hljs-keyword">match</span> <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(bytes) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(s) =&gt; s,<br>        <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(io::Error::<span class="hljs-title function_ invoke__">new</span>(io::ErrorKind::Other, <span class="hljs-string">&quot;unicode fail&quot;</span>)),<br>    &#125;;<br><br>  <span class="hljs-comment">// 返回构建的 Entry</span><br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">Some</span>(Entry &#123;<br>        term,<br>        df,<br>        offset,<br>        nbytes,<br>    &#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>结合下面这张图，很容易理解 <code>read_entry</code> 就是前面<code>write_contents_entry</code> 的逆向过程。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423224035544.png"alt="entries 区域布局，每个 entry 紧贴排布" /><figcaption aria-hidden="true">entries 区域布局，每个 entry紧贴排布</figcaption></figure><h2 id="create.rs-1">create.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/bin/create.rs">create.rs</a></p></blockquote><p>至此，我们就分析完并发构建索引的整个过程了，在 <code>create.rs</code>中，我们使用 <code>clap</code> 命令解析框架来构建一个 CLI工具用以支持构建索引，我们同时支持单线程构建和并发构建，具体可看完整源码。</p><p>如果对 <code>clap</code> 不熟悉的读者，可参考：<ahref="https://hedon.top/2024/03/02/rust-crate-clap/">深入探索 Rust 的clap 库：命令行解析的艺术</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Opts</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, default_value_t = false, help = <span class="hljs-string">&quot;Default false&quot;</span>)]</span><br>    single_threaded: <span class="hljs-type">bool</span>,<br><br>    <span class="hljs-meta">#[arg(required = true)]</span><br>    filenames: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">opts</span> = Opts::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">run</span>(opts.filenames, opts.single_threaded) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(()) =&gt; &#123;&#125;<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error: &#123;&#125;&quot;</span>, err),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="搜索功能">搜索功能</h1><p>在《Rust程序设计（第二版）》中，作者并没有实现搜索功能，笔者对其进行扩展，目标是对标我们前篇所构建的<ahref="https://hedon.top/2024/04/15/rust-action-inverted-index-demo/">Rust实战丨倒排索引</a>。这个搜索功能，会根据现有的索引文件重建内存索引<code>InMemoryIndex</code>，支持指定 <code>term</code>进行搜索，并将包含这个 <code>term</code>的文件在响应的位置中进行高亮显示并输出到终端。</p><h2 id="search.rs-1">search.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/bin/search.rs">search.rs</a></p></blockquote><p>程序入口如下所示，比较简单，就不赘述了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Opts</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, required = true, help = <span class="hljs-string">&quot;Specify index file path&quot;</span>)]</span><br>    index_file: <span class="hljs-type">String</span>,<br>    <span class="hljs-meta">#[arg(short, long, required = true, help = <span class="hljs-string">&quot;Specify search term&quot;</span>)]</span><br>    term: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">opts</span> = Opts::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_index_file</span>(opts.index_file)?;<br>    index.<span class="hljs-title function_ invoke__">search</span>(&amp;opts.term)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有 2 个核心逻辑：</p><ul><li><code>InMemoryIndex::from_index_file</code>:根据索引文件重建内存索引。</li><li><code>index.search(term)</code>: 搜索。</li></ul><h2 id="index.rs-1">index.rs</h2><p>我们在 <code>index.rs</code> 中为 <code>InMemoryIndex</code> 实现上述2 个方法。</p><h3 id="from_index_file">from_index_file</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_index_file</span>&lt;P: <span class="hljs-built_in">AsRef</span>&lt;Path&gt;&gt;(filename: P) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;InMemoryIndex&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br><br>  <span class="hljs-comment">// 获取 IndexFileReader</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">reader</span> = IndexFileReader::<span class="hljs-title function_ invoke__">open_and_delete</span>(filename, <span class="hljs-literal">false</span>)?;<br><br>  <span class="hljs-comment">// 依次解析每个 Entry</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(entry) = reader.<span class="hljs-title function_ invoke__">iter_next_entry</span>() &#123;<br>        <span class="hljs-keyword">if</span> entry.term.<span class="hljs-title function_ invoke__">is_empty</span>() &amp;&amp; entry.df == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 当前 Entry 指向的是一个 Document。</span><br>          <span class="hljs-comment">// 通过 terms_docs 读取 Document 所在位置并进行解析。</span><br>            reader.terms_docs.<span class="hljs-title function_ invoke__">seek</span>(io::SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(entry.offset))?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">doc_id</span> = reader.terms_docs.read_u32::&lt;LittleEndian&gt;()?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">path_len</span> = reader.terms_docs.read_u64::&lt;LittleEndian&gt;()?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">path</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0u8</span>; path_len <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];<br>            reader.terms_docs.<span class="hljs-title function_ invoke__">read_exact</span>(&amp;<span class="hljs-keyword">mut</span> path)?;<br>            index.docs.<span class="hljs-title function_ invoke__">insert</span>(<br>                doc_id,<br>                Document &#123;<br>                    id: doc_id,<br>                    path: <span class="hljs-title function_ invoke__">vec_to_pathbuf</span>(path),<br>                &#125;,<br>            );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当前 Entry 指向的是一个 terms。</span><br>          <span class="hljs-comment">// 通过 terms_docs 读取 terms 所在位置并进行解析。</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hits</span> = <span class="hljs-built_in">vec!</span>[];<br>            reader.terms_docs.<span class="hljs-title function_ invoke__">seek</span>(io::SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(entry.offset))?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">data</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0u8</span>; entry.nbytes <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];<br>            reader.terms_docs.<span class="hljs-title function_ invoke__">read_exact</span>(&amp;<span class="hljs-keyword">mut</span> data)?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cursor</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(data);<br><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = entry.df;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">has_hit</span> = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">quit</span> = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; !quit &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hit</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span>); <span class="hljs-comment">// cannot use vec![0;12]</span><br>                <span class="hljs-keyword">loop</span> &#123;<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(item) = cursor.read_i32::&lt;LittleEndian&gt;() &#123;<br>                        <span class="hljs-comment">// the start of next hit</span><br>                        <span class="hljs-keyword">if</span> item == <span class="hljs-keyword">Self</span>::HITS_SEPERATOR &amp;&amp; has_hit &#123;<br>                            hits.<span class="hljs-title function_ invoke__">push</span>(hit);<br>                            i -= <span class="hljs-number">1</span>;<br>                            index.word_count -= <span class="hljs-number">2</span>;<br>                            hit = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span>);<br>                        &#125;<br>                        has_hit = <span class="hljs-literal">true</span>;<br>                        hit.write_u32::&lt;LittleEndian&gt;(item <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>                        index.word_count += <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        quit = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">if</span> !hit.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                            hits.<span class="hljs-title function_ invoke__">push</span>(hit);<br>                            index.word_count -= <span class="hljs-number">2</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            index.terms.<span class="hljs-title function_ invoke__">insert</span>(entry.term, hits);<br>        &#125;<br>    &#125;<br>    index.word_count /= <span class="hljs-number">2</span>;<br>    <span class="hljs-title function_ invoke__">Ok</span>(index)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="search">search</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">self</span>, term: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>  <span class="hljs-comment">// 获取 term 出现的位置</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span>: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;&gt;&gt; = <span class="hljs-keyword">self</span>.terms.<span class="hljs-title function_ invoke__">get</span>(term);<br>    <span class="hljs-keyword">if</span> m.<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;can not found &#123;&#125; in all documents&quot;</span>, term);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(());<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hits</span> = m.<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>  <span class="hljs-comment">// 遍历每个出现的位置</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">hit</span> <span class="hljs-keyword">in</span> hits &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cursor</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(hit);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = cursor.read_i32::&lt;LittleEndian&gt;().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>      <span class="hljs-comment">// 获取文档原始信息</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">document_id</span> = cursor.read_u32::&lt;LittleEndian&gt;().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">doc</span> = <span class="hljs-keyword">self</span>.docs.<span class="hljs-title function_ invoke__">get</span>(&amp;document_id);<br>        <span class="hljs-keyword">if</span> doc.<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;cannot found document &#123;&#125;&quot;</span>, document_id);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">doc</span> = doc.<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>      <span class="hljs-comment">// hits 存储的内容：[HITS_SEPERATOR, document_id, start_pos1, end_pos1, ...]</span><br>      <span class="hljs-comment">// 解析 term 出现在 doc 中的每个位置</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">poss</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(hits.<span class="hljs-title function_ invoke__">len</span>() / <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">pos</span> = TokenPos::<span class="hljs-title function_ invoke__">default</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">has_pos</span> = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(p) = cursor.read_u32::&lt;LittleEndian&gt;() &#123;<br>            <span class="hljs-keyword">if</span> !has_pos &#123;<br>                pos.start_pos = p;<br>                has_pos = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pos.end_pos = p;<br>                poss.<span class="hljs-title function_ invoke__">push</span>(pos);<br>                pos = TokenPos::<span class="hljs-title function_ invoke__">default</span>();<br>                has_pos = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>      <span class="hljs-comment">// 对每个出现的位置进行高亮处理</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">highlight_file</span>(doc.path.<span class="hljs-title function_ invoke__">clone</span>(), &amp;<span class="hljs-keyword">mut</span> poss)?;<br>      <span class="hljs-comment">// 输出高亮后的结果</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;\n&#123;:?&#125;: \n&#123;&#125;&quot;</span>, doc.path, result);<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>至此，我们就实现了高并发构建索引和根据索引进行搜索的功能，本篇某些部分可能比较复杂，篇幅也比较冗长，笔者在阅读书中原实现的时候，也是获益颇丰，想不到一个简单的倒排索引竟涉及这么多的处理细节。也希望本篇文章能对感兴趣的读者有些许帮助。</p><p>peace! enjoy coding~</p><h1 id="绘图工具">绘图工具</h1><ul><li><ahref="https://link.zhihu.com/?target=https%3A//excalidraw.com/">https://excalidraw.com/</a></li></ul><h1 id="参考资料">参考资料</h1><ul><li><ahref="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Inverted_index">维基百科·倒排索引</a></li><li><ahref="https://link.zhihu.com/?target=https%3A//book.douban.com/subject/36547630/">Rust程序设计（第二版）</a></li></ul>]]></content>
    
    
    <summary type="html">本文详细阐述了使用 Rust channel 并发构建倒排索引的详细过程。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="倒排索引" scheme="https://hedon.top/tags/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    
    <category term="并发编程" scheme="https://hedon.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="通道" scheme="https://hedon.top/tags/%E9%80%9A%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨倒排索引</title>
    <link href="https://hedon.top/2024/04/15/rust-action-inverted-index-demo/"/>
    <id>https://hedon.top/2024/04/15/rust-action-inverted-index-demo/</id>
    <published>2024-04-15T02:24:17.000Z</published>
    <updated>2024-04-23T04:57:27.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>倒排索引（InvertedIndex）是一种索引数据结构，用于存储某个单词（词项）在一组文档中的所有出现情况的映射。它是搜索引擎执行快速全文搜索的核心技术，也广泛用于数据库中进行文本搜索。我们熟知的ElasticSearch 最核心底层原理便就是倒排索引。</p><p>倒排索引的基本原理是<strong>将文档中的词汇进行反转，形成倒排列表</strong>。在倒排列表中，每个词汇都对应一个文档标识符的列表，这些标识符指明了该词汇出现在哪些文档中。通过查询倒排列表，可以快速地找到包含特定词汇的文档。</p><p>本文将使用 Rust语言来实现一个简单的倒排索引，包括倒排索引的构建和搜索过程。在下一篇文章中，笔者会基于《Rust程序设计（第二版）》并发编程篇章，解读该书作者是如何基于 Rust通道实现更优秀、更高性能的倒排索引。</p><h1 id="可以学到">可以学到</h1><ol type="1"><li>倒排索引的原理、优势和使用</li><li>常用 crate：<code>colored</code>、<code>regex</code></li><li>Rust HashMap</li><li>Rust 迭代器</li></ol><h1 id="开发思路">开发思路</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240414112337590.png"alt="倒排索引构建过程" /><figcaption aria-hidden="true">倒排索引构建过程</figcaption></figure><p>一个简单的倒排索引开发思路大概如上图所示：</p><ol type="1"><li>读取文档</li><li>分词</li><li>构建每个词到每个文档的映射</li></ol><h1 id="开发过程">开发过程</h1><blockquote><p>完整源码位于：<ahref="https://github.com/hedon-rust-road/inverted-index">inverted_index</a>。</p></blockquote><h2 id="最终效果">最终效果</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index</span> = InvertedIndex::<span class="hljs-title function_ invoke__">new</span>();<br>    index.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Rust is safe and fast.&quot;</span>);<br>    index.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Rust is a systems programming language.&quot;</span>);<br>    index.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Programming in Rust is fun.&quot;</span>);<br><br>    <span class="hljs-comment">// query &quot;Rust&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">results</span> = index.<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;Rust&quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">result</span> <span class="hljs-keyword">in</span> results &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-comment">// query &quot;Programming&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">results</span> = index.<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;Programming&quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">result</span> <span class="hljs-keyword">in</span> results &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo run<br></code></pre></td></tr></table></figure><p>输出：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240414122848805.png"alt="inverted index 输出示例" /><figcaption aria-hidden="true">inverted index 输出示例</figcaption></figure><h2 id="版本声明">版本声明</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;inverted_index&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">colored</span> = <span class="hljs-string">&quot;2.1.0&quot;</span><br><span class="hljs-attr">regex</span> = <span class="hljs-string">&quot;1.10.4&quot;</span><br></code></pre></td></tr></table></figure><h2 id="项目准备">项目准备</h2><p>首先我们创建项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new inverted_index<br></code></pre></td></tr></table></figure><p>准备依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add regex<br>cargo add colored<br></code></pre></td></tr></table></figure><ul><li>colored:终端高亮，后面我们将实现搜索词的高亮显示，使结果更美观。</li><li>regex: 正则库，用于实现不区分大小写替换匹配到的搜索词。</li></ul><h2 id="实现过程">实现过程</h2><p>首先我们定义两个数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Document</span> &#123;<br>    id: <span class="hljs-type">usize</span>,<br>    content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>    indexes: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt;&gt;,<br>    documents: HashMap&lt;<span class="hljs-type">usize</span>, Document&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> InvertedIndex &#123;<br>        InvertedIndex &#123;<br>            indexes: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>            documents: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Document: 封装原始文档</li><li>IndexedIndex: 我们将构建的倒排索引</li></ul><p>接下来我们要实现 2 个辅助函数，一个是<code>tokenize</code>，用于将原始的文档信息拆分成独立的词（word/term），另一个是<code>hightlight</code>，用于将匹配到的文本进行替换，使其在中断可以以<font color="purple">紫色</font>输出。</p><p><code>tokenize</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tokenize</span>(text: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-type">str</span>&gt; &#123;<br>    text.<span class="hljs-title function_ invoke__">split</span>(|ch: <span class="hljs-type">char</span>| !ch.<span class="hljs-title function_ invoke__">is_alphanumeric</span>())<br>        .<span class="hljs-title function_ invoke__">filter</span>(|c| !c.<span class="hljs-title function_ invoke__">is_empty</span>())<br>        .<span class="hljs-title function_ invoke__">collect</span>()<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tokenize_test</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        <span class="hljs-title function_ invoke__">tokenize</span>(<span class="hljs-string">&quot;This is\nhedon&#x27;s tokenize function.&quot;</span>),<br>        <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;This&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;hedon&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;tokenize&quot;</span>, <span class="hljs-string">&quot;function&quot;</span>]<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>highlight</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">highlight</span>(term: &amp;<span class="hljs-type">str</span>, content: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">regex</span> = Regex::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-built_in">format!</span>(<span class="hljs-string">r&quot;(?i)&#123;&#125;&quot;</span>, term)).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">highlighted_content</span> = regex<br>        .<span class="hljs-title function_ invoke__">replace_all</span>(content, |caps: &amp;regex::Captures| &#123;<br>            caps[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">purple</span>().<span class="hljs-title function_ invoke__">to_string</span>()<br>        &#125;)<br>        .<span class="hljs-title function_ invoke__">to_string</span>();<br>    highlighted_content<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">highlight_test</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        <span class="hljs-title function_ invoke__">highlight</span>(<span class="hljs-string">&quot;programming&quot;</span>, <span class="hljs-string">&quot;I like programming with Rust Programming&quot;</span>),<br>        <span class="hljs-string">&quot;I like \u&#123;1b&#125;[35mprogramming\u&#123;1b&#125;[0m with Rust \u&#123;1b&#125;[35mProgramming\u&#123;1b&#125;[0m&quot;</span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以为 <code>InvertedIndex</code> 实现构建索引的方法<code>add</code>了，它会接收原始文档，对其进行分词，并将记录每个分词和文档 id的映射。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, doc_id: <span class="hljs-type">usize</span>, content: &amp;<span class="hljs-type">str</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">content_lowercase</span> = content.<span class="hljs-title function_ invoke__">to_lowercase</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">words</span> = <span class="hljs-title function_ invoke__">tokenize</span>(&amp;content_lowercase);<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> words &#123;<br>            <span class="hljs-keyword">self</span>.indexes<br>                .<span class="hljs-title function_ invoke__">entry</span>(word.<span class="hljs-title function_ invoke__">to_string</span>())<br>                .<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-built_in">vec!</span>[])<br>                .<span class="hljs-title function_ invoke__">push</span>(doc_id)<br>        &#125;<br><br>        <span class="hljs-keyword">self</span>.documents.<span class="hljs-title function_ invoke__">insert</span>(<br>            doc_id,<br>            Document &#123;<br>                id: doc_id,<br>                content: content.<span class="hljs-title function_ invoke__">to_string</span>(),<br>            &#125;,<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们再实现对应的根据分词 <code>term</code>搜索原始文档的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">query</span>(&amp;<span class="hljs-keyword">self</span>, term: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">term_lowercase</span> = term.<span class="hljs-title function_ invoke__">to_lowercase</span>();<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(doc_ids) = <span class="hljs-keyword">self</span>.indexes.<span class="hljs-title function_ invoke__">get</span>(&amp;term_lowercase) &#123;<br>            doc_ids<br>                .<span class="hljs-title function_ invoke__">iter</span>()<br>                .<span class="hljs-title function_ invoke__">filter_map</span>(|doc_id| &#123;<br>                    <span class="hljs-keyword">self</span>.documents<br>                        .<span class="hljs-title function_ invoke__">get</span>(doc_id)<br>                        .<span class="hljs-title function_ invoke__">map</span>(|doc| <span class="hljs-title function_ invoke__">highlight</span>(&amp;term_lowercase, &amp;doc.content))<br>                &#125;)<br>                .<span class="hljs-title function_ invoke__">collect</span>()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一个简单的倒排索引构建和搜索功能就完成了，具体的执行效果你可以回到前面的「最终效果」进行查阅。</p><h1 id="总结预告">总结预告</h1><p>本文实现的倒排索引虽然非常简单，但是也基本体现了倒排索引的最核心思想和应用方式了。在《Rust程序设计（第二版）》的并发编程篇章中，该书提出了使用通道 channel来并发构建倒排索引，同时给出了更加丰富和优雅的实现。在下篇文章中，笔者将阅读这部分的源码，解析并重现当中的实战过程，并进行适当扩展。</p><p>peace! enjoy coding~</p><h1 id="绘图工具">绘图工具</h1><ul><li>https://excalidraw.com/</li></ul><h1 id="参考资料">参考资料</h1><ul><li><ahref="https://en.wikipedia.org/wiki/Inverted_index">维基百科·倒排索引</a></li><li><a href="https://book.douban.com/subject/36547630/">Rust程序设计（第二版）</a></li></ul>]]></content>
    
    
    <summary type="html">本文将使用 Rust 实现一个简单的倒排索引。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="倒排索引" scheme="https://hedon.top/tags/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Go 语言的 defer 机制</title>
    <link href="https://hedon.top/2024/03/28/go-defer/"/>
    <id>https://hedon.top/2024/03/28/go-defer/</id>
    <published>2024-03-28T12:34:50.000Z</published>
    <updated>2024-04-14T02:23:53.351Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言以其简洁的语法和强大的并发支持而闻名。在这些特性中，<code>defer</code>语句是 Go语言提供的一项独特功能，它允许我们推迟函数的执行直到包含它的函数即将返回。这个简单而强大的机制不仅可以帮助我们处理资源释放和错误处理，还能让代码更加简洁和安全。本文将深入浅出地介绍<code>defer</code>的工作原理，探究其背后的机制，并通过丰富的案例来展示它的实际应用。</p><p>笔者本来以为 Go 语言的 <code>defer</code>其实东西不多，就是类似于“栈”的操作罢了，无非就是用于释放资源、后进先出而已。但是最近在阅读完《深入理解Go 语言》、《Go 底层原理剖析》和《Go 语言设计与实现》中关于<code>defer</code>的篇章。发现其中隐含的道道和坑还是比较有意思的，特此整理这篇文章，希望能对Go <code>defer</code> 原理感兴趣的读者带来一些帮助。</p><p>本文具体会包含以下内容：</p><ul><li><strong><code>defer</code> 机制简介</strong>：介绍<code>defer</code> 关键字的基本概念和它在 Go 语言中的作用。</li><li><strong><code>defer</code> 的工作原理</strong>：深入探讨<code>defer</code> 在函数执行结束时如何工作的细节。</li><li><strong><code>defer</code> 的执行顺序</strong>：解释<code>defer</code> 语句是如何按照后进先出（LIFO）的顺序执行的。</li><li><strong>参数预计算和值传递</strong>：讨论 <code>defer</code>语句中参数是如何被预先计算和传递的。</li><li><strong>环境变量和闭包</strong>：探讨 <code>defer</code>如何与闭包一起工作，以及如何捕获和影响环境变量。</li><li><strong><code>defer</code> 与错误处理</strong>：说明如何利用<code>defer</code> 和 <code>recover</code> 进行错误处理和异常捕获。</li><li><strong><code>defer</code> 的实现细节</strong>：深入分析<code>defer</code>的不同实现策略，包括堆上分配、栈上分配和开放编码。</li></ul><h1 id="版本声明">版本声明</h1><ul><li>Go1.22</li></ul><h1 id="思维导图">思维导图</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Go%20defer.png"alt="Go defer" /><figcaption aria-hidden="true">Go defer</figcaption></figure><h1 id="核心要点">核心要点</h1><p>对于后面将要分析的各种各样的情况，在分析的时候只要遵循以下几个核心点，基本上就不会跑偏：</p><ol type="1"><li>延迟执行：在函数结束时执行，包括正常返回或遭遇 panic。</li><li>栈式执行顺序：后定义的 <code>defer</code> 先执行（LIFO）。</li><li>参数预计算：<code>defer</code> 语句定义时即计算并固定参数值。</li><li>值传递原则：<code>defer</code> 拷贝参数，使用定义时的值。</li><li>环境变量捕获：在 <code>defer</code>中可以跟一个闭包，闭包可以捕获环境变量，当然这包括具名返回值。</li></ol><p>特别说明的是，虽然我们通常将 <code>defer</code>想象为使用栈进行管理，但是实际实现上，<code>defer</code>并不都是存放在栈上的，我们后面会具体分析到。这种实现细节通常对于编写正确的Go代码并不重要，但了解这一点对于深入理解语言内部机制可能是有帮助的。</p><h1 id="基本用法">基本用法</h1><p>在 Go 语言中，<code>defer</code>语句通常用于确保一个函数调用在程序执行结束时发生，常见的用例包括文件关闭、锁释放、资源回收等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    f, err := os.Open(filename)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-comment">// 确保文件在函数返回时关闭</span><br>    <span class="hljs-keyword">defer</span> f.Close()<br><br>    <span class="hljs-comment">// ... 处理文件 ...</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>defer f.Close()</code> 保证了无论<code>readFile</code>函数如何返回（正常返回或发生错误），<code>f.Close()</code>都会被调用，从而避免了资源泄露。</p><h1 id="执行顺序">执行顺序</h1><p><code>defer</code>的执行顺序是先进后出，即“栈”操作。这里借用刘丹冰老师的一张图来演示这个过程：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1651037338287-fd17c81d-a1ad-4bc7-ae7e-eec8a264af5f.jpeg"alt="Go defer 执行顺序" /><figcaption aria-hidden="true">Go defer 执行顺序</figcaption></figure><p>我们可以通过以下代码进行验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func1...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func2...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func3...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> func1()<br><span class="hljs-keyword">defer</span> func2()<br><span class="hljs-keyword">defer</span> func3()<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">func3</span></span>...<br><span class="hljs-function"><span class="hljs-title">func2</span></span>...<br><span class="hljs-function"><span class="hljs-title">func1</span></span>...<br></code></pre></td></tr></table></figure><h1 id="参数求值与陷阱">参数求值与陷阱</h1><p>关于 <code>defer</code>参数这一块，是一个比较容易出错的地方。我们先来看一个例子，你可以分析下它的输出会是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printI</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;printI i:&quot;</span>, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">10</span><br><span class="hljs-keyword">defer</span> printI(i * <span class="hljs-number">10</span>)<br>i = i + <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;main i:&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure><p>按照我们之前总结的核心点：<strong>参数预计算：<code>defer</code>语句定义时即计算并固定参数值</strong>。具体来说，在把 <code>defer</code>压入“栈”时，会同时压入<strong>函数地址</strong>和<strong>函数形参</strong>，也就是会在这个时候就把参数先算好。所以在执行到第7 行代码的时候，就会把 <code>i*10</code> 算好，然后同<code>printI</code> 一同压入到延迟执行栈中。</p><p>所以最后的结果就是：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">i</span>: <span class="hljs-number">11</span><br><span class="hljs-selector-tag">printI</span> <span class="hljs-selector-tag">i</span>: <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>关于<strong>参数值传递</strong>，笔者这里再举两个例子进行比较，体会后你应该就理解了。</p><p>第一个例子中，<code>defer</code>后面参数是指针，本质上<strong>值传递</strong>，但是拷贝的是指针，所以在<code>defer</code> 中修改的东西，最后会反馈到指针指向的对象，所以对<code>testUser</code> 的返回值是有影响的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span>&#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testUser</span><span class="hljs-params">()</span></span> *User &#123;<br>user := &amp;User&#123;&#125;<br>user.name = <span class="hljs-string">&quot;name-1&quot;</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u *User)</span></span> &#123;<br>u.name = <span class="hljs-string">&quot;name-defer&quot;</span><br>&#125;(user)<br><br>user.name = <span class="hljs-string">&quot;name-2&quot;</span><br><span class="hljs-keyword">return</span> user<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>user := testUser()<br>fmt.Println(user)<br>&#125;<br><span class="hljs-comment">// &amp;&#123;name-defer&#125;</span><br></code></pre></td></tr></table></figure><p>第二个例子中，我们传入的就是结构体示例本身了，因为值传递，即拷贝了一份新的<code>user</code>，所以闭包内的修改对外面是不产生影响的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testUser</span><span class="hljs-params">()</span></span> User &#123;<br>user := User&#123;&#125;<br>user.name = <span class="hljs-string">&quot;name-1&quot;</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u User)</span></span> &#123;<br>u.name = <span class="hljs-string">&quot;name-defer&quot;</span><br>&#125;(user)<br><br>user.name = <span class="hljs-string">&quot;name-2&quot;</span><br><span class="hljs-keyword">return</span> user<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>user := testUser()<br>fmt.Println(user)<br>&#125;<br><span class="hljs-comment">// &#123;name-2&#125;</span><br></code></pre></td></tr></table></figure><h1 id="环境变量捕获">环境变量捕获</h1><p>将上面的一个例子进行简单修改，会输出什么呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printI</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;printI i:&quot;</span>, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">10</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>printI(i * <span class="hljs-number">10</span>)<br>&#125;()<br>i = i + <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;main i:&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候其实没有参数，所以会直接将下面闭包压入延迟栈中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  printI(i * <span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>而闭包是可以捕获环境变量的，所以在 <code>main</code> return后，<code>defer</code> 可以捕获到 <code>i</code> 的值，为更新后的<code>i+1</code>，最后再进行 <code>printI(i * 10)</code>。</p><p>所以输出结果是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">main i: <span class="hljs-number">11</span><br>printI i: <span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>所以说，<code>defer</code>后面的闭包，是可以捕获环境变量的，如果这个变量是返回值的话，那么理所应当也是可以对其产生作用的，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getI</span><span class="hljs-params">()</span></span> (i <span class="hljs-type">int</span>) &#123;<br>i = <span class="hljs-number">1</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i *= <span class="hljs-number">10</span><br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(getI())<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，<code>getI</code> 的返回值是有名字的<code>i</code>，<code>getI</code> 执行了<code>return 20</code>，其实就是将 <code>i</code> 设置为<code>20</code>，所以在执行到 <code>defer</code> 闭包的时候，捕获到了<code>i=20</code>，并将其进行了修改。所以最终输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h1 id="错误处理与-defer">错误处理与 defer</h1><p>我们都知道 Go 程序中遇到 <code>panic</code>就会中断后面的执行流程直接返回，这个时候我们可以在 <code>defer</code>中结合 <code>recover</code> 来捕获这个<code>panic</code>，从而保护程序不崩溃。</p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panicAndRecover</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;函数中正常流程&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;出现异常&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;panic 后的语句永远执行不到&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>panicAndRecover()<br>fmt.Println(<span class="hljs-string">&quot;正常回到 main&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 函数中正常流程</span><br><span class="hljs-comment">// 出现异常</span><br><span class="hljs-comment">// 正常回到 main</span><br></code></pre></td></tr></table></figure><p>更进一步，如果我们在 <code>defer</code> 中也有 <code>panic</code>呢？请思考下列代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panicAndRecover</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;第 1 个入栈的 defer&quot;</span>)<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;最终捕获的 panic:&quot;</span>, err)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;第 2 个入栈的 defer&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;第 2 个入栈的 defer 发生 panic&quot;</span>)<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;panicAndRecover 函数中正常流程&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panicAndRecover 出现异常&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;panic 后的语句永远执行不到&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>panicAndRecover()<br>fmt.Println(<span class="hljs-string">&quot;正常回到 main&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们在 <code>panicAndRecover</code> 强行抛出<code>panic</code>，由于 <code>defer</code> 先进后出，所以我们会先执行第2 个 <code>defer</code>，其中也发生了 <code>panic</code>，我们在第 1 个<code>defer</code> 中对 <code>panic</code> 进行<code>recover</code>，最终的现象是只捕获到了后面抛出的<code>panic</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">panicAndRecover 函数中正常流程<br>第 <span class="hljs-number">2</span> 个入栈的 <span class="hljs-keyword">defer</span><br>第 <span class="hljs-number">1</span> 个入栈的 <span class="hljs-keyword">defer</span><br>最终捕获的 <span class="hljs-built_in">panic</span>: 第 <span class="hljs-number">2</span> 个入栈的 <span class="hljs-keyword">defer</span> 发生 <span class="hljs-built_in">panic</span><br>正常回到 main<br></code></pre></td></tr></table></figure><p>这是为什么呢？</p><p>在 Go 语言中，<code>panic</code> 函数实际上是创建了一个<code>panic</code> 对象，并抛出这个对象。</p><p>当一个 <code>panic</code> 发生并开始向上传播时，Go 运行时会检查每个<code>defer</code>。如果 <code>defer</code> 中包含 <code>recover</code>调用，并且它被执行，那么 <code>recover</code> 会捕获当前的<code>panic</code>，并且防止它继续向上传播。如果 <code>defer</code>中再次发生 <code>panic</code>，那么原来的 <code>panic</code> 就不会被<code>recover</code> 捕获，因为 <code>defer</code>函数已经退出了。在这种情况下，新的 <code>panic</code>会导致程序崩溃，因为没有更多的 <code>defer</code> 函数去<code>recover</code> 这个新的 <code>panic</code>。</p><p>这说明了 Go 程序中不允许同时有多个活跃的 <code>panic</code>存在，这个设计确保了在任何给定的时刻，只有一个 <code>panic</code>能够被处理。这样做有几个原因：</p><ol type="1"><li><strong>简化错误处理：</strong> 如果同时存在多个<code>panic</code>，就会变得非常复杂去确定如何处理它们，尤其是在它们之间存在依赖关系的时候。一个<code>panic</code>应该表示一个不可恢复的错误，如果有多个这样的错误同时存在，程序的状态可能会变得非常不确定。</li><li><strong>保持一致性：</strong> <code>panic</code>通常表示程序中出现了严重错误，可能会破坏程序的一致性或安全性。如果允许多个<code>panic</code> 同时存在，就很难保证程序状态的一致性，因为不同的<code>panic</code> 可能需要回退不同的操作。</li><li><strong>避免资源泄漏：</strong> <code>defer</code>语句用于确保资源被释放，例如文件和锁。如果在处理一个 <code>panic</code>的过程中，又发生了另一个 <code>panic</code>，可能会导致<code>defer</code> 语句中剩余的清理代码无法执行，从而引起资源泄漏。</li><li><strong>控制流程清晰：</strong> <code>panic</code> 和<code>recover</code> 的设计使得错误的控制流程清晰且可预测。一旦一个<code>panic</code> 被 <code>recover</code>捕获，程序可以选择是否继续执行，或者是通过重新 <code>panic</code>来终止程序。这种决策过程在多个 <code>panic</code>情况下会变得复杂且难以管理。</li></ol><p>因此，在 Go 的设计中，不允许同时存在多个活跃的<code>panic</code>。一旦发生 <code>panic</code>，它必须被<code>recover</code>处理，否则程序将会终止。这确保了错误处理的清晰性和程序的稳定性。</p><h1 id="defer-放在哪">defer 放在哪</h1><p><code>defer</code> 实际上不一定是放在栈上的，截止Go1.22，<code>defer</code> 其实用 3 种分配策略：</p><ul><li>堆上分配</li><li>栈上分配</li><li>开放编码</li></ul><h2 id="执行机制">执行机制</h2><p>在 <ahref="https://github.com/golang/go/blob/release-branch.go1.22/src/cmd/compile/internal/ssagen/ssa.go">ssa.go</a>文件中，我们可以找到 <code>state.stmt()</code>，这个函数是负责在 Go程序编译过程中中间代码生成阶段时对不同语句的处理过程，其中对于<code>ODEFER</code> 即 <code>defer</code> 语句的处理逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// stmt converts the statement n to SSA and adds it to s.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *state)</span></span> stmt(n ir.Node) &#123;<br>s.stmtList(n.Init())<br><span class="hljs-keyword">switch</span> n.Op() &#123;<br><span class="hljs-keyword">case</span> ir.ODEFER:<br>      n := n.(*ir.GoDeferStmt)<br>      <span class="hljs-keyword">if</span> base.Debug.Defer &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">var</span> defertype <span class="hljs-type">string</span><br>        <span class="hljs-keyword">if</span> s.hasOpenDefers &#123;<br>          defertype = <span class="hljs-string">&quot;open-coded&quot;</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n.Esc() == ir.EscNever &#123;<br>          defertype = <span class="hljs-string">&quot;stack-allocated&quot;</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          defertype = <span class="hljs-string">&quot;heap-allocated&quot;</span><br>        &#125;<br>        base.WarnfAt(n.Pos(), <span class="hljs-string">&quot;%s defer&quot;</span>, defertype)<br>      &#125;<br>...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，总共有 3 种分配策略：</p><ul><li><strong>open-coded</strong>: s.hasOpenDefers == true</li><li><strong>stack-allocated</strong>: n.Esc() == ir.EscNever</li><li><strong>heap-allocated</strong>: 默认</li></ul><p>默认是堆分配，在 Go1.13以前，也只有堆分配这一种策略，不过该实现的性能较差。Go 语言在 1.13中引入栈上分配的结构体，<ahref="https://go-review.googlesource.com/c/go/+/171758">减少了 30%的额外开销</a>，并在 1.14 中引入了基于开放编码的<code>defer</code>，使得该关键字的额外开销<ahref="https://go-review.googlesource.com/c/go/+/190098/6">几乎可以忽略不计</a>。</p><p>本文中不对具体的分配机制进行分析，这一块会比较复杂，笔者本身也不是很感兴趣，便决定对此不过分深究，感兴趣的读者推荐详细阅读《Go语言设计与实现》中关于 <code>defer</code>关键字的分析：https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/。</p><p>本文只讨论什么情况下会使用什么分配策略。由于堆分配是默认的，我们就不作分析了，具体来看看<code>s.hasOpenDefers == true</code> 和<code>n.Esc() == ir.EscNever</code> 什么时候会成立。</p><h2 id="栈上分配">栈上分配</h2><p>我们先来看栈上分配，要满足栈上分配，则需要满足<code>n.Esc() == ir.EscNever</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>EscUnknown = <span class="hljs-literal">iota</span><br>EscNone    <span class="hljs-comment">// Does not escape to heap, result, or parameters.</span><br>EscHeap    <span class="hljs-comment">// Reachable from the heap</span><br>EscNever   <span class="hljs-comment">// By construction will not escape.</span><br>)<br></code></pre></td></tr></table></figure><p>当 <code>n</code> 的逃逸分析结果是 <code>ir.EscNever</code>，则表明该<code>defer</code>语句从不逃逸（不会在函数调用结束后仍然被引用），这种情况下<code>defer</code> 将被分配到栈上（stack-allocated）。否则，如果<code>defer</code> 逃逸了，就会被分配到堆上（heap-allocated）。</p><p>那 <code>defer</code> 语句什么时候会逃逸呢？</p><blockquote><p>在 Go中，一个变量的逃逸意味着它的生命周期超出了当前函数的范围。在函数内定义的变量通常分配在栈上，而在堆上分配内存需要更复杂的管理。在一些情况下，编译器可能会选择将变量分配在堆上，这种情况下我们称之为逃逸。</p></blockquote><p>对于 <code>defer</code> 语句，如果它引用了函数外的变量，这个<code>defer</code> 就会逃逸。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(x) <span class="hljs-comment">// 这里引用了外部变量 x</span><br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>defer</code> 函数内部引用了 <code>x</code>这个外部变量，因此 <code>defer</code> 语句需要确保 <code>x</code> 在<code>defer</code> 函数执行时仍然有效。为了满足这个条件，编译器可能会将<code>x</code> 分配在堆上，而不是栈上。</p><h2 id="开放编码">开放编码</h2><p>先给结论，在开发过程中，要使用开放编码策略，你只需要关注以下 4点即可：</p><ol type="1"><li>函数的 <code>defer</code> 数量不能超过 8 个；</li><li>函数的 <code>defer</code> 关键字不能在循环中执行；</li><li>函数的 <code>defer</code> 中不能发生逃逸；</li><li>函数的 <code>return</code> 语句与 <code>defer</code>语句的乘积小于或者等于 15 个；</li></ol><hr /><p>Ok，下面是具体的分析过程。</p><p>借助 Goland 的能力，将鼠标光标放在 <code>s.hasOpenDefers</code>上，按住 <strong>Command</strong>加点击鼠标，可以看到该属性的使用情况：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328133312845-20240328202233278.png"alt="s.hasOpenDefers" /><figcaption aria-hidden="true">s.hasOpenDefers</figcaption></figure><p>可以看到该属性的判断逻辑都在 <ahref="https://github.com/golang/go/blob/release-branch.go1.22/src/cmd/compile/internal/ssagen/ssa.go">ssa.go</a>文件中的 <code>buildssa()</code>函数中。去掉一些无关的代码，核心逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// buildssa builds an SSA function for fn.</span><br><span class="hljs-comment">// worker indicates which of the backend workers is doing the processing.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildssa</span><span class="hljs-params">(fn *ir.Func, worker <span class="hljs-type">int</span>)</span></span> *ssa.Func &#123;<br>...<br>  <span class="hljs-comment">// ①</span><br>s.hasOpenDefers = base.Flag.N == <span class="hljs-number">0</span> &amp;&amp; s.hasdefer &amp;&amp; !s.curfn.OpenCodedDeferDisallowed()<br><span class="hljs-keyword">switch</span> &#123;<br>  <span class="hljs-comment">// ②</span><br><span class="hljs-keyword">case</span> base.Debug.NoOpenDefer != <span class="hljs-number">0</span>:<br>s.hasOpenDefers = <span class="hljs-literal">false</span><br><span class="hljs-keyword">case</span> s.hasOpenDefers &amp;&amp; (base.Ctxt.Flag_shared || base.Ctxt.Flag_dynlink) &amp;&amp; base.Ctxt.Arch.Name == <span class="hljs-string">&quot;386&quot;</span>:<br>    <span class="hljs-comment">// ③</span><br><span class="hljs-comment">// Don&#x27;t support open-coded defers for 386 ONLY when using shared</span><br><span class="hljs-comment">// libraries, because there is extra code (added by rewriteToUseGot())</span><br><span class="hljs-comment">// preceding the deferreturn/ret code that we don&#x27;t track correctly.</span><br>s.hasOpenDefers = <span class="hljs-literal">false</span><br>&#125;<br>  <span class="hljs-comment">// ④</span><br><span class="hljs-keyword">if</span> s.hasOpenDefers &amp;&amp; <span class="hljs-built_in">len</span>(s.curfn.Exit) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Skip doing open defers if there is any extra exit code (likely</span><br><span class="hljs-comment">// race detection), since we will not generate that code in the</span><br><span class="hljs-comment">// case of the extra deferreturn/ret segment.</span><br>s.hasOpenDefers = <span class="hljs-literal">false</span><br>&#125;<br>  <span class="hljs-comment">// ⑤</span><br><span class="hljs-keyword">if</span> s.hasOpenDefers &#123;<br><span class="hljs-comment">// Similarly, skip if there are any heap-allocated result</span><br><span class="hljs-comment">// parameters that need to be copied back to their stack slots.</span><br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> s.curfn.Type().Results().FieldSlice() &#123;<br><span class="hljs-keyword">if</span> !f.Nname.(*ir.Name).OnStack() &#123;<br>s.hasOpenDefers = <span class="hljs-literal">false</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br>  <span class="hljs-comment">// ⑥</span><br><span class="hljs-keyword">if</span> s.hasOpenDefers &amp;&amp;<br>s.curfn.NumReturns*s.curfn.NumDefers &gt; <span class="hljs-number">15</span> &#123;<br><span class="hljs-comment">// Since we are generating defer calls at every exit for</span><br><span class="hljs-comment">// open-coded defers, skip doing open-coded defers if there are</span><br><span class="hljs-comment">// too many returns (especially if there are multiple defers).</span><br><span class="hljs-comment">// Open-coded defers are most important for improving performance</span><br><span class="hljs-comment">// for smaller functions (which don&#x27;t have many returns).</span><br>s.hasOpenDefers = <span class="hljs-literal">false</span><br>&#125;<br>  ...<br><span class="hljs-keyword">return</span> s.f<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到总共有 6个条件，我已在注释中进行标注，我们来进行逐一分析：</p><h3 id="base.flag.n-0-s.hasdefer-s.curfn.opencodeddeferdisallowed">①base.Flag.N == 0 &amp;&amp; s.hasdefer &amp;&amp;!s.curfn.OpenCodedDeferDisallowed()</h3><blockquote><p>如果<code>base.Flag.N</code> 等于 0且当前函数有延迟调用且没有禁止开放式延迟，那么设置<code>s.hasOpenDefers</code>为<code>true</code>。</p></blockquote><p>在 Go编译器中，<code>-N</code>标志通常用于禁用优化。在这段代码中，如果<code>base.Flag.N</code>等于0，意味着没有禁用优化，因此编译器可能会尝试使用更高级的优化技术，比如开放式延迟（open-codeddefers）。</p><p><code>OpenCodedDeferDisallowed()</code>即禁用开放编码，它的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> funcOpenCodedDeferDisallowed <span class="hljs-comment">// can&#x27;t do open-coded defers</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Func)</span></span> OpenCodedDeferDisallowed() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> f.flags&amp;funcOpenCodedDeferDisallowed != <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p>按住 Command 后点击 <code>funcOpenCodedDeferDisallowed</code>可以看到只有 <code>funcOpenCodedDeferDisallowed(b)</code>可以修改它的值。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328140733594.png"alt="funcOpenCodedDeferDisallowed" /><figcaption aria-hidden="true">funcOpenCodedDeferDisallowed</figcaption></figure><p>我们来看看哪个地方会调用<code>funcOpenCodedDeferDisallowed()</code>，并将<code>funcOpenCodedDeferDisallowed</code> 设置为 <code>true</code>：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328140859879.png"alt="将 funcOpenCodedDeferDisallowed 设置为 true 的地方" /><figcaption aria-hidden="true">将 funcOpenCodedDeferDisallowed 设置为true 的地方</figcaption></figure><p>调用它的地方在 <ahref="https://github.com/golang/go/blob/release-branch.go1.22/src/cmd/compile/internal/walk/stmt.go">stmt.go</a>文件中的 <code>walkStmt()</code> 函数，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The max number of defers in a function using open-coded defers. We enforce this</span><br><span class="hljs-comment">// limit because the deferBits bitmask is currently a single byte (to minimize code size)</span><br><span class="hljs-keyword">const</span> maxOpenDefers = <span class="hljs-number">8</span><br><br><span class="hljs-comment">// The result of walkStmt MUST be assigned back to n, e.g.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//n.Left = walkStmt(n.Left)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkStmt</span><span class="hljs-params">(n ir.Node)</span></span> ir.Node &#123;<br>  ...<br><span class="hljs-keyword">switch</span> n.Op() &#123;<br>    ...<br>    <span class="hljs-keyword">case</span> ir.ODEFER:<br>      n := n.(*ir.GoDeferStmt)<br>      ir.CurFunc.SetHasDefer(<span class="hljs-literal">true</span>)<br>      ir.CurFunc.NumDefers++<br>      <span class="hljs-keyword">if</span> ir.CurFunc.NumDefers &gt; maxOpenDefers &#123;<br>        <span class="hljs-comment">// Don&#x27;t allow open-coded defers if there are more than</span><br>        <span class="hljs-comment">// 8 defers in the function, since we use a single</span><br>        <span class="hljs-comment">// byte to record active defers.</span><br>        ir.CurFunc.SetOpenCodedDeferDisallowed(<span class="hljs-literal">true</span>)<br>      &#125;<br>      <span class="hljs-keyword">if</span> n.Esc() != ir.EscNever &#123;<br>        <span class="hljs-comment">// If n.Esc is not EscNever, then this defer occurs in a loop,</span><br>        <span class="hljs-comment">// so open-coded defers cannot be used in this function.</span><br>        ir.CurFunc.SetOpenCodedDeferDisallowed(<span class="hljs-literal">true</span>)<br>      &#125;<br>      <span class="hljs-keyword">fallthrough</span><br>    ...<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>第一点是：当前函数中 <code>defer</code> 个数超过 8的话，则禁用开放编码。</p><p>第二点是当 <code>n.Esc() != ir.EscNever</code>使，就禁用开放编码。这个要求跟前面分析的“栈上分配”要求是一样的。</p><p>这里再补充一点：什么时候 <code>n.Esc()</code> 会被设置为<code>ir.EscNever</code> 呢？</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328192005520.png"alt="n.SetEsc(ir.EscNever)" /><figcaption aria-hidden="true">n.SetEsc(ir.EscNever)</figcaption></figure><p>这里面核心点是第一个，它对应的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *escape)</span></span> goDeferStmt(n *ir.GoDeferStmt) &#123;<br>k := e.heapHole()<br><span class="hljs-keyword">if</span> n.Op() == ir.ODEFER &amp;&amp; e.loopDepth == <span class="hljs-number">1</span> &#123;<br>...<br>n.SetEsc(ir.EscNever)<br>&#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>e.loopDepth == 1</code> 时就设置，换言之，<code>defer</code>不在循环中的时候，才允许开放编码。</p><p>总而言之，第 ① 个条件约束了要采用<code>open-coded 开放编码</code>策略的 3 个条件：</p><ol type="1"><li>函数中 <code>defer</code> 个数不能超过 <strong>8</strong>；</li><li><code>defer</code> 不能在循环中；</li><li><code>defer</code> 不能发生逃逸。</li></ol><h3 id="base.debug.noopendefer-0">② base.Debug.NoOpenDefer != 0</h3><blockquote><p>如果<code>base.Debug.NoOpenDefer</code>不为0，那么禁用开放式延迟。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">NoOpenDefer           <span class="hljs-type">int</span>    <span class="hljs-string">`help:&quot;disable open-coded defers&quot; concurrent:&quot;ok&quot;`</span><br></code></pre></td></tr></table></figure><h3id="base.ctxt.flag_shared-base.ctxt.flag_dynlink-base.ctxt.arch.name-386">③(base.Ctxt.Flag_shared || base.Ctxt.Flag_dynlink) &amp;&amp;base.Ctxt.Arch.Name == "386"</h3><blockquote><p>如果当前架构是<code>386</code>，并且使用共享库或动态链接，那么不支持开放式延迟，因为存在一些额外的代码（由<code>rewriteToUseGot()</code>添加）可能无法正确追踪。</p></blockquote><h3 id="lens.curfn.exit">④ len(s.curfn.Exit)</h3><blockquote><p>如果存在任何额外的退出代码（比如可能是竞态检测相关的代码），则跳过开放式延迟。</p></blockquote><h3 id="f.nname.ir.name.onstack">⑤ !f.Nname.(*ir.Name).OnStack()</h3><blockquote><p>如果有任何堆分配的结果参数需要复制回它们的栈槽，也跳过开放式延迟。</p></blockquote><h3 id="s.curfn.numreturnss.curfn.numdefers-15">⑥s.curfn.NumReturns*s.curfn.NumDefers &gt; 15</h3><blockquote><p>如果函数的返回数乘以延迟调用数大于<strong>15</strong>，考虑到每个退出点都要生成延迟调用，并且开放式延迟对于小函数（没有多个返回）的性能提升最为重要，所以在这种情况下也不使用开放式延迟。</p></blockquote><h2 id="堆上分配">堆上分配</h2><p>当不满足开放编码和栈上分配的时候，默认就是堆上分配（heap-allocated），性能最差，这里不做分析。</p><hr /><p>以上就是本文关于 Go 语言中 <code>defer</code> 关键字的具体分析，HappyCoding! Peace~</p><h1 id="参考">参考</h1><ul><li><a href="https://book.douban.com/subject/36403287/">深入理解 Go语言</a></li><li><a href="https://book.douban.com/subject/35556889/">Go语言底层原理剖析</a></li><li><ahref="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/">Go语言设计与实现</a></li><li>ChatGPT4</li></ul>]]></content>
    
    
    <summary type="html">本文将深入浅出地介绍 defer 的工作原理，探究其背后的机制，并通过丰富的案例来展示它的实际应用。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>深入 Go 语言核心：结构体的全方位解析</title>
    <link href="https://hedon.top/2024/03/09/go-struct/"/>
    <id>https://hedon.top/2024/03/09/go-struct/</id>
    <published>2024-03-09T08:59:34.000Z</published>
    <updated>2024-03-27T11:38:28.773Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言，作为一种高效、静态类型的编程语言，自其问世以来便以其并发处理能力和简洁的语法结构广受开发者欢迎。虽然Go不是传统意义上的面向对象语言，它却以独特的方式支持面向对象编程的核心概念，其中结构体扮演了非常关键的角色。</p><p>结构体在 Go语言中是一种复合数据类型，允许我们将不同类型的数据聚合到一起。它不仅提高了数据管理的效率和逻辑清晰度，还是Go语言中实现面向对象编程思想如封装、组合等概念的基石。了解和掌握结构体的使用，对于深入理解Go 语言的特性和编写高效、可维护的 Go 代码至关重要。</p><p>本文将带您全面深入地探索 Go语言中结构体的各个方面，从基本定义、初始化和使用，到高级特性如结构体的组合、方法定义、内存对齐等，每一个细节都将一一展开。无论您是Go语言的新手，还是有一定经验的开发者，相信本文都能为您提供有价值的见解和帮助。让我们一起探索Go结构体的奥秘，揭开其背后的原理，优化我们的代码结构，提升编程效率。</p><h1 id="版本声明">版本声明</h1><ul><li>Go 1.22.1</li><li>gopkg.in/yaml.v3 v3.0.1</li><li>os: m2max</li></ul><h1 id="全文概览">全文概览</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Go%20%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%20(1).png"alt="Go 语言结构体" /><figcaption aria-hidden="true">Go 语言结构体</figcaption></figure><h1 id="结构体的基本使用">1. 结构体的基本使用</h1><h2 id="定义结构体">1.1 定义结构体</h2><p>结构体类型的定义形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>  Field T1,<br>  Field T2,<br>  ....<br>  FieldN Tn,<br>&#125;<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  Name <span class="hljs-type">string</span><br>  Age <span class="hljs-type">int</span><br>  ExtraInfo <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体内部，也可以内嵌<strong>匿名结构体</strong>，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>  Age <span class="hljs-type">int</span><br>  School <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Address <span class="hljs-type">string</span><br>    Phone <span class="hljs-type">string</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但是！注意，如果 Person 中包含了 Person 呢？</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>person  Person<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会报错：不允许引用自身。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./main.go:5:6: invalid recursive <span class="hljs-built_in">type</span>: Person refers to itself<br></code></pre></td></tr></table></figure><p>这是因为 Go语言在编译时需要知道每个类型的确切大小，以便正确地分配内存。但在这个定义中，因为<code>Person</code> 包含自身，编译器无法确定 <code>Person</code>的大小，因此会报错。</p><p>如果你需要在一个结构体中引用相同类型的数据，你应该使用指针。指针的大小是固定的，因此编译器可以确定结构体的大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  person *Person<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化结构体">1.2 初始化结构体</h2><p>假设我们有以下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name      <span class="hljs-type">string</span><br>Age       <span class="hljs-type">int</span><br>ExtraInfo <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以有以下几种初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 逐个字段赋值，顺序不重要，也可以只赋值部分字段</span><br>person1 := Person&#123;<br>  Age:       <span class="hljs-number">18</span>,<br>  Name:      <span class="hljs-string">&quot;hedon&quot;</span>,<br>  ExtraInfo: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;),<br>&#125;<br>fmt.Println(person1) <span class="hljs-comment">// &#123;hedon 18 map[]&#125;</span><br><br><span class="hljs-comment">// 可以不指定字段，严格按照顺序</span><br>person2 := Person&#123;<span class="hljs-string">&quot;hedon2&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)&#125;<br>fmt.Println(person2) <span class="hljs-comment">// &#123;hedon2 19 map[]&#125;</span><br><br><span class="hljs-comment">// 默认初始化，则结构体中的每个字段都会被默认赋予其对应类型的“零值”</span><br><span class="hljs-keyword">var</span> person3 Person<br>fmt.Println(person3)                  <span class="hljs-comment">// &#123; 0 map[]&#125;</span><br>fmt.Println(person3.ExtraInfo == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 也可以使用 new() 或 &amp; 来初始化并返回指针</span><br>person3 := <span class="hljs-built_in">new</span>(Person)<br>fmt.Println(person3)  <span class="hljs-comment">// &amp;&#123; 0 map[]&#125;</span><br></code></pre></td></tr></table></figure><h2 id="空结构体">1.3 空结构体</h2><p>有一种特殊的结构体，它一个字段都没有，我们称之为“空结构体”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>空结构体非常特殊，它不占据任何空间！你可以自己验证一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;the size of empty:&quot;</span>, unsafe.Sizeof(Empty&#123;&#125;)) <span class="hljs-comment">// the size of empty: 0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而且，所有空结构体的地址都一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">type</span> Empty1 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>e := Empty&#123;&#125;<br>e1 := Empty1&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;the address of empty: %p\n&quot;</span>, &amp;e) <span class="hljs-comment">// the address of empty: 0x10460f520</span><br>fmt.Printf(<span class="hljs-string">&quot;the address of empty1: %p\n&quot;</span>, &amp;e1)  <span class="hljs-comment">// the address of empty1: 0x10460f520</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为 Go 语言为所有大小为 0 的变量都指向了同一个值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// base address for all 0-byte allocations</span><br><span class="hljs-keyword">var</span> zerobase <span class="hljs-type">uintptr</span><br></code></pre></td></tr></table></figure><p>好处就是减少了内存的浪费。典型的用法就是我们可以使用 map 来实现Set，这样就只花费了存储键的空间，而值不占用任何空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="访问和修改结构体">1.4 访问和修改结构体</h2><ul><li>结构体属性的可见性跟 Go包的可见性规则一样：大写对包外可见，小写仅包内可见。</li><li>使用 <code>.</code> 访问和修改结构体中的属性。</li><li>Go语言中只有“<strong>值传递</strong>”，所以如果你要将结构体示例传入一个func 进行修改，则需要传入其引用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>UpdatePersonName(p)<br>fmt.Println(<span class="hljs-string">&quot;1:&quot;</span>, p)<br>UpdatePersonNameWithRef(&amp;p)<br>fmt.Println(<span class="hljs-string">&quot;2:&quot;</span>, p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdatePersonName</span><span class="hljs-params">(p Person)</span></span> &#123;<br>p.Name = <span class="hljs-string">&quot;hedon-1&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdatePersonNameWithRef</span><span class="hljs-params">(p *Person)</span></span> &#123;<br>p.Name = <span class="hljs-string">&quot;hedon-2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">1: &#123;hedon 18&#125;<br>2: &#123;hedon-2 18&#125;<br></code></pre></td></tr></table></figure><h1 id="结构体的高级特性">2. 结构体的高级特性</h1><h2 id="结构体组合">2.1 结构体组合</h2><p>在 Go语言中，倡导的是“组合优于继承”的哲学，即倡导使用组合而不是继承来实现代码的复用。该理念鼓励开发者通过组合和接口来构建灵活、可维护的代码，而不是依赖于更严格、更易出错的继承关系。这种方式促进了代码的解耦，增强了代码的灵活性和可重用性，同时也使得代码更加清晰和易于理解。</p><p>在 Go中，组合是通过将一个或多个类型（通常是结构体）嵌入到另一个结构体中来实现的。这使得嵌入的类型的方法被“提升”到包含它的结构体中，允许你调用这些方法就像它们是外部结构体的一部分一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    Power <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Engine)</span></span> Start() &#123;<br>    <span class="hljs-comment">// 启动引擎的逻辑</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Car <span class="hljs-keyword">struct</span> &#123;<br>    Engine <span class="hljs-comment">// 通过组合的方式嵌入 Engine</span><br>&#125;<br><br><span class="hljs-comment">// 现在 Car 可以直接调用 Start 方法</span><br>car := Car&#123;Engine&#123;Power: <span class="hljs-number">100</span>&#125;&#125;<br>car.Start() <span class="hljs-comment">// 调用的是 Engine 的 Start 方法</span><br></code></pre></td></tr></table></figure><h2 id="结构体的方法">2.2 结构体的方法</h2><p>假设我们定义了一个结构体 Person：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Go 中，你可以为结构体的值或指针实现特定的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>  p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *Person)</span></span> SetName(name <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>  p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>这两者最核心的区别是：<strong>当你为结构体的指针类型定义方法时，该方法会在原始结构体实例上操作。这意味着方法内部对结构体的任何修改都会影响到原始结构体。</strong></p><p>所以这两段代码的输出是不一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(p.Name)   <span class="hljs-comment">// name_name</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(p.Name)  <span class="hljs-comment">// hedon</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这里我想再补充两个小点。请先思考一下下面这两段代码是否可以编译通过？如果可以输出是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;person name after set:&quot;</span>, p.Name)<br><br>pt := reflect.TypeOf(p)<br>fmt.Println(<span class="hljs-string">&quot;the number of person&#x27;s method: &quot;</span>, pt.NumMethod())<br><br>p2 := &amp;Person&#123;&#125;<br>pt = reflect.TypeOf(p2)<br>fmt.Println(<span class="hljs-string">&quot;the number of &amp;person&#x27;s method: &quot;</span>, pt.NumMethod())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;person name after set:&quot;</span>, p.Name)<br><br>pt := reflect.TypeOf(p)<br>fmt.Println(<span class="hljs-string">&quot;the number of person&#x27;s method: &quot;</span>, pt.NumMethod())<br><br>p2 := &amp;Person&#123;&#125;<br>pt = reflect.TypeOf(p2)<br>fmt.Println(<span class="hljs-string">&quot;the number of &amp;person&#x27;s method: &quot;</span>, pt.NumMethod())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显这两段代码的唯一区别就是，第一段代码我们是为<code>*Person</code> 实现了 <code>SetName</code>方法，而第二段代码我们是为 <code>Person</code> 实现了<code>SetName</code> 方法。两段代码我们都打印了调用 <code>SetName</code>后 <code>p.name</code> 的值，以及利用方式分别获取 <code>Person</code> 和<code>*Person</code> 实现的方法个数。</p><p>第一段代码的输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">person name after set: new<span class="hljs-built_in">_</span>name<br>the number of person&#x27;s method:  0<br>the number of <span class="hljs-built_in">&amp;</span>person&#x27;s method:  1<br></code></pre></td></tr></table></figure><p>第二段代码的输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">person name after set: hedon<br>the number of person&#x27;s method:  1<br>the number of <span class="hljs-built_in">&amp;</span>person&#x27;s method:  1<br></code></pre></td></tr></table></figure><p>这里我们可以得出 2 个结论：</p><p><strong>① 结构体的修改依赖于方法接收器的类型</strong>：</p><ul><li>当方法的接收器为值类型（<code>Person</code>）时，对结构体的修改不会影响原始结构体实例，因为方法作用于结构体的副本上。</li><li>当方法的接收器为指针类型（<code>*Person</code>）时，对结构体的修改会影响原始结构体实例，因为方法作用于结构体的引用上。</li></ul><p><strong>② 方法集依赖于接收器的类型</strong>：</p><ul><li>为值类型（<code>Person</code>）实现的方法，既属于值类型也属于指针类型（<code>*Person</code>）的方法集。</li><li>为指针类型（<code>*Person</code>）实现的方法，只属于指针类型的方法集。</li></ul><p>对于 ②，我们可以通过 Plan9 汇编代码一探究竟。</p><p>我们为第一段代码执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -gcflags -S main.go<br></code></pre></td></tr></table></figure><p>在输出的最上面，可以看到只有<code>main.(*Person).GetName</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"># command-line-arguments<br>main.main STEXT size=<span class="hljs-number">128</span> args=<span class="hljs-number">0x0</span> locals=<span class="hljs-number">0x48</span> funcid=<span class="hljs-number">0x0</span> align=<span class="hljs-number">0x0</span><br>        ...<br>main.(*Person).GetName STEXT size=<span class="hljs-number">16</span> args=<span class="hljs-number">0x8</span> locals=<span class="hljs-number">0x0</span> funcid=<span class="hljs-number">0x0</span> align=<span class="hljs-number">0x0</span> leaf<br>       ...<br></code></pre></td></tr></table></figure><p>我们再来为第二段代码执行相同的命令。可以在输出的最上面，看到不仅有<code>main.Person.GetName</code>，还可以发现编译器自动帮我们生成了<code>main.(*Person).GetName</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># command-line-arguments</span><br>main.main STEXT size=480 args=0x0 locals=0xe8 funcid=0x0 align=0x0<br>...<br>main.Person.SetName STEXT size=16 args=0x28 locals=0x0 funcid=0x0 align=0x0 leaf<br>   ...<br>main.(*Person).SetName STEXT dupok size=128 args=0x18 locals=0x8 funcid=0x16 align=0x0<br>...<br></code></pre></td></tr></table></figure><p>对于 ②，笔者其实有一个不太理解的地方，比如下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := &amp;Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;person name after set:&quot;</span>, p.Name) <span class="hljs-comment">// hedon</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>p</code> 是引用类型，下面实现的是<code>Person.SetName</code>，按照我们上面的结论，编译器会自动帮我们实现<code>(*Person).SetName</code>。按照这种思路，输出 <code>new_name</code>也是解释得通的。因为既然我们声明的是一个引用类型，那么 <code>p</code>完全可以去调用自动生成的<code>(*Person).SetName</code>。但是最终的结果还是输出<code>hedon</code>，所以这里编译器自动帮我们将 <code>p</code>进行解引用，然后调用了 <code>Person.SetName</code>。</p><p>这是比较困扰笔者的一个地方，欢迎评论区讨论~</p><p>可能编译器还是更希望对于开发者来说“所见即所得”，既然开发者实现的是<code>Person.SetName</code>，那么对于开发者来说，应该就是希望不影响原始结构体的值，所以编译器还是选择遵循这种“意愿”，不乱操作。</p><h2 id="结构体比较">2.3 结构体比较</h2><p>Go 允许直接比较两个结构体实例，但有一定的限制：</p><ol type="1"><li><strong>可比较性</strong>：只有当结构体中的所有字段都是可比较的时，结构体才是可比较的。基本数据类型（如int、string 等）是可比较的，但切片、映射、函数等类型不可比较。</li><li><strong>相等性检测</strong>：当两个结构体的对应字段都相等时，这两个结构体被认为是相等的。可以使用<code>==</code> 和 <code>!=</code> 操作符来进行比较。</li></ol><p>下面这段示例，<code>p3==p4</code> 返回了<code>true</code>，这符合我们上面总结的结论。<code>p1==p2</code> 返回了<code>false</code>，因为这其实不是结构体之间的比较了，这是指针的比较了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">p1 := &amp;Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>p2 := &amp;Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>fmt.Println(p1 == p2) <span class="hljs-comment">// false</span><br>p3 := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>p4 := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>fmt.Println(p3 == p4) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>结构体的比较只支持 <code>==</code> 和 <code>!=</code>，不支持<code>&lt;</code> 和 <code>&gt;</code> 等其他运算符的比较。而 Go语言又不支持比较符重载。所以如果你要比较两个结构体的大小，那么只能自行封装类型<code>compare</code>的函数。在这我们排序结构体数组或切片的时候，经常使用到，比如我们希望按<code>Age</code> 字段从小到大排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Slice(persons, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">return</span> persons[i].Age &lt; persons[j].Age<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="结构体复制">2.4 结构体复制</h2><p>在 Go中，结构体也是值类型，这意味着当它们被赋值给新的变量或作为函数参数传递时，实际上是进行了一次深拷贝：</p><ol type="1"><li><strong>值复制</strong>：当将一个结构体赋值给一个新变量时，新变量会获得原始结构体的一个副本，它们在内存中占有不同的位置。</li><li><strong>独立性</strong>：因为是深拷贝，所以原始结构体和副本结构体是完全独立的；修改其中一个不会影响另一个。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">int</span><br>&#125;<br><br>original := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><span class="hljs-built_in">copy</span> := original<br><span class="hljs-built_in">copy</span>.X = <span class="hljs-number">3</span><br><br>fmt.Println(original) <span class="hljs-comment">// &#123;1, 2&#125;</span><br>fmt.Println(<span class="hljs-built_in">copy</span>)     <span class="hljs-comment">// &#123;3, 2&#125;</span><br></code></pre></td></tr></table></figure><h1 id="结构体与接口">3. 结构体与接口</h1><p>在 Go语言中，如果一个类型实现了接口中所有的方法，则这个类型就实现了该接口。关于接口部分的知识点，比如接口定义、多态和断言等，本文就不赘述了。</p><p>在这里我主要想从另外一个角度继续来验证前面我们总结的：<strong>为值类型（<code>Person</code>）实现的方法，既属于值类型也属于指针类型（<code>*Person</code>）的方法集</strong>。</p><p>请看这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">interface</span> &#123;<br>GetName() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Man <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m Man)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> m.Name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintPersonName</span><span class="hljs-params">(p Person)</span></span> &#123;<br>fmt.Println(p.GetName())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m1 := Man&#123;Name: <span class="hljs-string">&quot;hedon1&quot;</span>&#125;<br>PrintPersonName(m1)<br>m2 := &amp;Man&#123;Name: <span class="hljs-string">&quot;hedon2&quot;</span>&#125;<br>PrintPersonName(m2)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码我们定义了 <code>Person</code> 接口，它只有一个方法<code>GetName</code>。然后我们定义了一个结构体<code>Man</code>，并为它的值类型实现了 <code>Person</code>接口。通过我们上面的结论，这里 <code>Man</code> 和 <code>*Man</code>其实都实现了 <code>Person</code>接口，所以上面的代码是可以编译通过的。</p><p>如果改成为指针类型实现接口呢？你可以试一下~</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Man)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> m.Name<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="泛型结构体">4. 泛型结构体</h1><p>Go 语言在其 1.18版本中引入了泛型支持，这包括了对泛型结构体的支持。通过使用泛型，你可以创建更灵活和可重用的数据结构和函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Container[T any] <span class="hljs-keyword">struct</span> &#123;<br>items []T<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 Go 语言用 <code>[]</code> 来实现泛型，而不像其他语言一样用<code>&lt;&gt;</code>，真是喜欢搞特殊啊 🤡，又丑又容易跟 map 和 slice混淆。</p><h1 id="结构体的标签tag">5. 结构体的标签（Tag）</h1><p>在结构体字段后面，我们可以用 <strong>``</strong>来指定标签，这允许我们对结构体定制化一些常用操作，最经典的就是序列化与反序列化。</p><h2 id="序列化与反序列化">5.1 序列化与反序列化</h2><p>对于常见的数据结构，如<code>json</code>、<code>yaml</code>、<code>xml</code> 或<code>toml</code>，我们都可以通过在结构体中指定标签，然后使用对应解析库进行序列化和反序列化。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>bs, _ := json.Marshal(p) <span class="hljs-comment">// 序列化</span><br>fmt.Println(<span class="hljs-type">string</span>(bs))  <span class="hljs-comment">// &#123;&quot;name&quot;:&quot;hedon&quot;,&quot;age&quot;:18&#125;</span><br>newP := Person&#123;&#125;<br>_ = json.Unmarshal(bs, &amp;newP) <span class="hljs-comment">// 反序列化</span><br>fmt.Println(newP)             <span class="hljs-comment">// &#123;hedon 18&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在笔者的实践过程中，在结构体组合的场景下，不同数据格式的解析会有一些小差别，这在实战过程中你需要重点关注和验证。比如<code>json</code> 和 <code>yaml</code> 就会有一些不同。</p><p>比如说我这里定义了下面 2 个结构体，其中 <code>Person</code> 组合了<code>School</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot; yaml:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot; yaml:&quot;age&quot;`</span><br>School<br>&#125;<br><br><span class="hljs-keyword">type</span> School <span class="hljs-keyword">struct</span> &#123;<br>SchoolName    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;school_name&quot; yaml:&quot;school_name&quot;`</span><br>SchoolAddress <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;school_address&quot; json:&quot;school_address&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它们都加上了 <code>json</code> 和 <code>yaml</code> 标签，对于<code>json</code> 类型，你可以用标准库的 <code>encoding/json</code>来进行序列化和反序列化，而 <code>yaml</code> 你可以使用第三方库：<ahref="https://github.com/go-yaml/yaml">go-yaml</a>。</p><p>先来看系列化结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>, School: School&#123;SchoolName: <span class="hljs-string">&quot;nb_school&quot;</span>, SchoolAddress: <span class="hljs-string">&quot;a_good_school_place&quot;</span>&#125;&#125;<br>bs, _ := json.Marshal(p)<br>fmt.Println(<span class="hljs-string">&quot;json:\n&quot;</span>, <span class="hljs-type">string</span>(bs))<br>bs, _ = yaml.Marshal(p)<br>fmt.Println(<span class="hljs-string">&quot;yaml:\n&quot;</span>, <span class="hljs-type">string</span>(bs))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">json:<br> &#123;&quot;name&quot;:&quot;hedon&quot;,&quot;age&quot;:18,&quot;school<span class="hljs-built_in">_</span>name&quot;:&quot;nb<span class="hljs-built_in">_</span>school&quot;,&quot;school<span class="hljs-built_in">_</span>address&quot;:&quot;a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>school<span class="hljs-built_in">_</span>place&quot;&#125;<br>yaml:<br> name: hedon<br> age: 18<br> school:<br>    school<span class="hljs-built_in">_</span>name: nb<span class="hljs-built_in">_</span>school<br>    school<span class="hljs-built_in">_</span>address: a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>school<span class="hljs-built_in">_</span>place<br></code></pre></td></tr></table></figure><p>通过观察你可以发现哈，在 <code>json</code> 中，组合的时候（没有给School 加标签）直接将 <code>School</code> 平铺在 <code>Person</code>中，所以在序列化的结果中，找不到 <code>"school": &#123;&#125;</code>。而在<code>yaml</code> 中，并不是直接平铺的。</p><p>这个区别在你解析配置文件的时候尤其重要，如果不注意，那么可能会导致配置解析失败。</p><p>我准备了 4 个配置文件，分别是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// person1.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon_json&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;school_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nb_json_school&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;school_address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_good_place_in_json&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># person1.yaml</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;hedon_yaml&quot;</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">school:</span><br>  <span class="hljs-attr">school_name:</span> <span class="hljs-string">&quot;nb_yaml_school&quot;</span><br>  <span class="hljs-attr">school_address:</span> <span class="hljs-string">&quot;a_good_price_in_yaml&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// person2.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon_json&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nb_json_school&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school_address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_good_place_in_json&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># person2.yaml</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;hedon_yaml&quot;</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">school_name:</span> <span class="hljs-string">&quot;nb_yaml_school&quot;</span><br><span class="hljs-attr">school_address:</span> <span class="hljs-string">&quot;a_good_price_in_yaml&quot;</span><br></code></pre></td></tr></table></figure><p>解析代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filenames := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;person1.json&quot;</span>, <span class="hljs-string">&quot;person1.yaml&quot;</span>, <span class="hljs-string">&quot;person2.json&quot;</span>, <span class="hljs-string">&quot;person2.yaml&quot;</span>&#125;<br><span class="hljs-keyword">for</span> i, fn := <span class="hljs-keyword">range</span> filenames &#123;<br>bs := readFileIntoBytes(fn)<br>p := Person&#123;&#125;<br><span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>_ = json.Unmarshal(bs, &amp;p)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>_ = yaml.Unmarshal(bs, &amp;p)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s -&gt; %v\n&quot;</span>, fn, p)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFileIntoBytes</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>f, err := os.Open(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>bs, _ := io.ReadAll(f)<br><span class="hljs-keyword">return</span> bs<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">person1.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123; &#125;&#125;<br>person1.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123;nb<span class="hljs-built_in">_</span>yaml<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>price<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>yaml&#125;&#125;<br>person2.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123;nb<span class="hljs-built_in">_</span>json<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>place<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>json&#125;&#125;<br>person2.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123; &#125;&#125;<br></code></pre></td></tr></table></figure><p>如果给 <code>School</code> 字段加上 <code>json tag</code>的话，结果又是不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot; yaml:&quot;name&quot;`</span><br>Age    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot; yaml:&quot;age&quot;`</span><br>School <span class="hljs-string">`json:&quot;school&quot; yaml:&quot;school&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">person1.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123;nb<span class="hljs-built_in">_</span>json<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>place<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>json&#125;&#125;<br>person1.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123;nb<span class="hljs-built_in">_</span>yaml<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>price<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>yaml&#125;&#125;<br>person2.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123; &#125;&#125;<br>person2.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123; &#125;&#125;<br></code></pre></td></tr></table></figure><p>可以看到受影响的只有 <code>json</code>。</p><p>到这里我们可以总结：<strong>在组合场景下，如果不明确指定<code>tag</code>，<code>yaml</code> 解析期望字段是嵌套的，而<code>json</code> 解析期望字段是平铺的</strong>。</p><h2 id="自定义-tag">5.2 自定义 Tag</h2><p>在 Go中，你可以为结构体字段定义任意的标签。这些标签在编译时会被存储，并且可以在运行时通过反射（reflection）来访问。</p><p>假设我们定义一个名为 <code>check</code>的标签，它用于我们对结构体字段的检查，假设我们这个标签支持以下功能：</p><ul><li><code>check:"strnoempty"</code>: 字符串不可以为空。</li></ul><p>假如加入 <code>check</code> 标签的 <code>Person</code>结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`check:&quot;strnoempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来为 <code>check</code> 实现解析函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckPerson</span><span class="hljs-params">(p Person)</span></span> <span class="hljs-type">error</span> &#123;<br>pt := reflect.TypeOf(p)<br>pv := reflect.ValueOf(p)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; pt.NumField(); i++ &#123;<br>field := pt.Field(i)<br>tagValue := field.Tag.Get(<span class="hljs-string">&quot;check&quot;</span>)<br><span class="hljs-keyword">if</span> tagValue == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> field.Type.Kind() == reflect.String &amp;&amp; tagValue == <span class="hljs-string">&quot;strnoempty&quot;</span> &#123;<br><span class="hljs-keyword">if</span> err := checkStrNoEmpty(field.Name, pv.Field(i).Interface()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkStrNoEmpty</span><span class="hljs-params">(fieldName <span class="hljs-type">string</span>, v any)</span></span> <span class="hljs-type">error</span> &#123;<br>s, ok := v.(<span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%v is not string&quot;</span>, v)<br>&#125;<br><span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;[check] %s should not be empty&quot;</span>, fieldName)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p1 := Person&#123;&#125;<br>p2 := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>fmt.Println(CheckPerson(p1)) <span class="hljs-comment">// [check] Name should not be empty</span><br>fmt.Println(CheckPerson(p2)) <span class="hljs-comment">// &lt;nil&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结构体内存对齐">6. 结构体内存对齐</h1><p>在本小节中，我们将探讨 Go 语言结构体的内存结构和对齐策略。</p><h2 id="问题引出">6.1 问题引出</h2><p>思考下面这段代码的输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num2 <span class="hljs-type">int8</span><br>num1 <span class="hljs-type">int16</span><br>flag <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S2 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int8</span><br>flag <span class="hljs-type">bool</span><br>num2 <span class="hljs-type">int16</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(unsafe.Sizeof(S1&#123;&#125;))<br>fmt.Println(unsafe.Sizeof(S2&#123;&#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么仅是字段顺序不同，<code>S1&#123;&#125;</code> 和 <code>S2&#123;&#125;</code>的大小就不一样了？</p><p>我们可以写个简单的程序来输出 <code>S1</code> 和 <code>S2</code>的内存结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := S1&#123;&#125;<br>s2 := S2&#123;&#125;<br>fmt.Print(<span class="hljs-string">&quot;s1: &quot;</span>)<br>printMemory(s1)<br>fmt.Print(<span class="hljs-string">&quot;s2: &quot;</span>)<br>printMemory(s2)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMemory</span><span class="hljs-params">(a any)</span></span> &#123;<br>t := reflect.TypeOf(a)<br>mem := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>(t.Size()))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>field := t.Field(i)<br>offset := <span class="hljs-type">int</span>(field.Offset)<br>size := <span class="hljs-type">int</span>(field.Type.Size())<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; size; j++ &#123;<br>mem[j+offset] = i + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>fmt.Println(mem)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s1: [<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span>]<br>s2: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>其中 <code>1</code>、<code>2</code>、<code>3</code>分别替代结构体中的第 1/2/3 个字段所占用的内存。这里可以看到<code>s1</code> 的长度是 6 字节，而 <code>s2</code> 是 4 字节。这里<code>s1</code> 比 <code>s2</code> 多出的 2 个字节就是这两个填充的<code>0</code>。这而 2个字节的填充，就是为了<strong>内存对齐</strong>。</p><h2 id="内存对齐">6.2 内存对齐</h2><p>如上分析，<code>s1</code> 的内存结构如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310154903219.png"alt="s1 内存结构" /><figcaption aria-hidden="true">s1 内存结构</figcaption></figure><p>如果没有内存对齐呢？<code>s1</code> 的结构可能如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310155353882.png"alt="没有内存对齐的 s1 内存结构" /><figcaption aria-hidden="true">没有内存对齐的 s1 内存结构</figcaption></figure><p>如果是 16 位系统的话，那么没有内存对齐的情况下，要访问<code>s1.num2</code> 字段，就需要跨过 2个系统字长的内存，效率就低了。具体来说，内存对齐是计算机内存分配的一种优化方式，用于确保数据结构的存储按照特定的字节边界对齐。这种对齐是为了提高计算机处理数据的效率。</p><h2 id="对齐系数">6.3 对齐系数</h2><ul><li>对齐系数：变量的内存地址必须被对齐系数整除。</li><li><code>unsafe.Alignof()</code>: 可以查看值在内存中的对齐系数。</li></ul><h2 id="基本类型对齐">6.4 基本类型对齐</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;bool size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">bool</span>(<span class="hljs-literal">true</span>)), unsafe.Alignof(<span class="hljs-type">bool</span>(<span class="hljs-literal">true</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;byte size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">byte</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">byte</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int8 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int8</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int8</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int16 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int16</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int16</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int32 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int64 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int64</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int64</span>(<span class="hljs-number">0</span>)))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">bool</span> size: <span class="hljs-number">1</span>, align: <span class="hljs-number">1</span><br><span class="hljs-type">byte</span> size: <span class="hljs-number">1</span>, align: <span class="hljs-number">1</span><br><span class="hljs-type">int8</span> size: <span class="hljs-number">1</span>, align: <span class="hljs-number">1</span><br><span class="hljs-type">int16</span> size: <span class="hljs-number">2</span>, align: <span class="hljs-number">2</span><br><span class="hljs-type">int32</span> size: <span class="hljs-number">4</span>, align: <span class="hljs-number">4</span><br><span class="hljs-type">int64</span> size: <span class="hljs-number">8</span>, align: <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>结论：基本类型的对齐系数跟它的长度一致。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310160412598.png"alt="基本类型内存对齐" /><figcaption aria-hidden="true">基本类型内存对齐</figcaption></figure><h2 id="结构体内部对齐">6.5 结构体内部对齐</h2><p>结构体内存对齐分为内部对齐和结构体之间对齐。</p><p>我们先来看结构体内部对齐：</p><ul><li>指的是结构体内部成员的相对位置（偏移量）；</li><li>每个成员的偏移量是 <strong>自身大小</strong> 和<strong>对齐系数</strong> 的较小值的倍数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br>  a <span class="hljs-type">bool</span><br>  b <span class="hljs-type">string</span><br>  c <span class="hljs-type">int16</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假如我们定义了上面的结构体 <code>Demo</code>，如果在 64位系统上（字长为 8 字节）通过上面的规则，可以判断出：（单位为字节）</p><ul><li>a: size=1, align=1</li><li>b: size=16, align=8</li><li>c: size=2, align=2</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310163126556.png"alt="Demo 内存结构" /><figcaption aria-hidden="true">Demo 内存结构</figcaption></figure><p>当然我们也可以通过程序输出来验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">bool</span>   <span class="hljs-comment">// size=1, align=1</span><br>b <span class="hljs-type">string</span> <span class="hljs-comment">// size=16, align=8</span><br>c <span class="hljs-type">int16</span>  <span class="hljs-comment">// size=2, align=2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>d := Demo&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(d.a), unsafe.Alignof(d.a))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(d.b), unsafe.Alignof(d.b))<br>fmt.Printf(<span class="hljs-string">&quot;c: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(d.c), unsafe.Alignof(d.c))<br>printMemory(d)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMemory</span><span class="hljs-params">(a any)</span></span> &#123;<br>t := reflect.TypeOf(a)<br>mem := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>(t.Size()))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>field := t.Field(i)<br>offset := <span class="hljs-type">int</span>(field.Offset)<br>size := <span class="hljs-type">int</span>(field.Type.Size())<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; size; j++ &#123;<br>mem[j+offset] = i + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>fmt.Println(mem)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>c: size=<span class="hljs-number">2</span>, align=<span class="hljs-number">2</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="结构体长度填充">6.6 结构体长度填充</h2><p>上面 Demo 结构体最后还填了 6 个字节的 0，这就是结构体长度填充：</p><ul><li>结构体通过填充长度，来对齐系统字长。</li><li>结构体长度是 <strong>最大成员长度</strong> 和<strong>系统字长</strong> 较小值的整数倍。</li></ul><p>我的系统环境是 m2max，系统字长是 8 字节，Demo 最大成员长度是<code>b string</code>，即 16 个字节，所以 <code>Demo</code> 的长度应该是<code>8</code> 的倍数，所以最后填充了 6 个字节的 0。</p><h2 id="结构体之间对齐">6.7 结构体之间对齐</h2><ul><li>结构体之间对齐，是为了确定结构体的第一个成员变量的内存地址，以让后面的成员地址都合法。</li><li>结构体的对齐系数是 <strong>其成员的最大对齐系数</strong>；</li></ul><h2 id="空结构体对齐">6.8 空结构体对齐</h2><p>前面我们专门讨论了空结构体<code>struct&#123;&#125;</code>，它们的内存地址统一指向<code>zerobase</code>，而且内存长度为0。这也导致了它的内存对齐规则，有一些不同。具体可以分为以下 4个情况。</p><h3 id="空结构体单独存在">6.8.1 空结构体单独存在</h3><p>空结构体单独存在时，其内存地址为<code>zerobase</code>，不额外分配内存。</p><h3 id="空结构体在结构体最前">6.8.2 空结构体在结构体最前</h3><p>空结构体是结构体第一个字段时，它的地址跟结构体本身及结构体第 2个字段一样，不占据内存空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestEmpty <span class="hljs-keyword">struct</span> &#123;<br>empty <span class="hljs-keyword">struct</span>&#123;&#125;<br>a     <span class="hljs-type">bool</span><br>b     <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>te := TestEmpty&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;address of te: %p\n&quot;</span>, &amp;te)<br>fmt.Printf(<span class="hljs-string">&quot;address of te.empty: %p\n&quot;</span>, &amp;(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;address of te.a: %p\n&quot;</span>, &amp;(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;empty: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.empty), unsafe.Alignof(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.a), unsafe.Alignof(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.b), unsafe.Alignof(te.b))<br>printMemory(te)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">address of te: <span class="hljs-number">0x140000ba000</span><br>address of te.empty: <span class="hljs-number">0x140000ba000</span><br>address of te.a: <span class="hljs-number">0x140000ba000</span><br>empty: size=<span class="hljs-number">0</span>, align=<span class="hljs-number">1</span><br>a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>[<span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="空结构体在结构体中间">6.8.3 空结构体在结构体中间</h3><p>空结构体出现在结构体中时，地址跟随前一个变量。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310165025700.png"alt="空结构体在结构体中间内存对齐" /><figcaption aria-hidden="true">空结构体在结构体中间内存对齐</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestEmpty <span class="hljs-keyword">struct</span> &#123;<br>a     <span class="hljs-type">bool</span><br>empty <span class="hljs-keyword">struct</span>&#123;&#125;<br>b     <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>te := TestEmpty&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;address of te: %p\n&quot;</span>, &amp;te)<br>fmt.Printf(<span class="hljs-string">&quot;address of te.a: %p\n&quot;</span>, &amp;(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;address of te.empty: %p\n&quot;</span>, &amp;(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.a), unsafe.Alignof(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;empty: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.empty), unsafe.Alignof(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.b), unsafe.Alignof(te.b))<br>printMemory(te)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">address of te: <span class="hljs-number">0x14000128000</span><br>address of te.a: <span class="hljs-number">0x14000128000</span><br>address of te.empty: <span class="hljs-number">0x14000128001</span><br>a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>empty: size=<span class="hljs-number">0</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="空结构体在结构体最后">6.8.4 空结构体在结构体最后</h3><p>空结构体出现在结构体最后，如果开启了一个新的系统字长，则需要补零，防止与其他结构体混用地址。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310164933867.png"alt="空结构体在结构体最后内存对齐" /><figcaption aria-hidden="true">空结构体在结构体最后内存对齐</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestEmpty <span class="hljs-keyword">struct</span> &#123;<br>a     <span class="hljs-type">bool</span><br>b     <span class="hljs-type">string</span><br>empty <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>te := TestEmpty&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;address of te: %p\n&quot;</span>, &amp;te)<br>fmt.Printf(<span class="hljs-string">&quot;address of te.a: %p\n&quot;</span>, &amp;(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;address of te.empty: %p\n&quot;</span>, &amp;(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.a), unsafe.Alignof(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.b), unsafe.Alignof(te.b))<br>fmt.Printf(<span class="hljs-string">&quot;empty: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.empty), unsafe.Alignof(te.empty))<br>printMemory(te)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">address of te: <span class="hljs-number">0x1400006a020</span><br>address of te.a: <span class="hljs-number">0x1400006a020</span><br>address of te.empty: <span class="hljs-number">0x1400006a038</span><br>a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>empty: size=<span class="hljs-number">0</span>, align=<span class="hljs-number">1</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="使用-fieldalignment--fix-工具优化结构体内存对齐">6.9 使用fieldalignment -fix 工具优化结构体内存对齐</h2><p>还记得我们最开始提出的问题吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num2 <span class="hljs-type">int8</span><br>num1 <span class="hljs-type">int16</span><br>flag <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S2 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int8</span><br>flag <span class="hljs-type">bool</span><br>num2 <span class="hljs-type">int16</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(unsafe.Sizeof(S1&#123;&#125;))<br>fmt.Println(unsafe.Sizeof(S2&#123;&#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p><code>S1</code> 和 <code>S2</code> 提供的程序功能是一样的，但是<code>S1</code> 却比 <code>S2</code>花费了更多的内存空间。所以有时候我们可以通过仅仅调整结构体内部字段的顺序就减少不少的内存空间消耗。在这个时候<code>fieldalignment</code> 可以帮助我们自动检测并优化。</p><p>你可以运行下面命令安装 <code>fieldalignment</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest<br></code></pre></td></tr></table></figure><p>然后在项目根目录下运行下面命令，对我们的代码进行检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go vet -vettool=$(<span class="hljs-built_in">which</span> fieldalignment) ./...<br></code></pre></td></tr></table></figure><p>这里会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./main.go:9:9: struct of size 6 could be 4<br></code></pre></td></tr></table></figure><p>这个时候可以执行 <code>fieldalignment -fix 目录|文件</code>，它会自动帮我们的代码进行修复，但是<strong>强烈建议你在运行之前，备份你的代码，因为注释会被删除！</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fieldalignment -fix ./...<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">/Users/hedon/GolandProjects/learn-<span class="hljs-keyword">go</span>-<span class="hljs-keyword">struct</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>:<span class="hljs-number">9</span>: <span class="hljs-keyword">struct</span> of size <span class="hljs-number">6</span> could be <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>这个时候 <code>S1</code> 已经被优化好了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int16</span><br>num2 <span class="hljs-type">int8</span><br>flag <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文将带您全面深入地探索 Go 语言中结构体的各个方面，从基本定义、初始化和使用，到高级特性如结构体的组合、方法定义、内存对齐等。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨HTTPie</title>
    <link href="https://hedon.top/2024/03/06/rust-action-httpie/"/>
    <id>https://hedon.top/2024/03/06/rust-action-httpie/</id>
    <published>2024-03-06T14:22:02.000Z</published>
    <updated>2024-03-27T11:38:28.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>之前学习过《陈天·Rust 编程第一课 - 04｜get hands dirty：来写个实用的CLI 小工具》，学的时候迷迷糊糊。后来在系统学习完 Rust后，重新回过头来看这个实战小案例，基本上都能掌握，并且有了一些新的理解。所以我决定以一个Rust 初学者的角度，并以最新版本的 Rust（1.7.6）和clap（4.5.1）来重新实现这个案例，期望能对 Rust感兴趣的初学者提供一些帮助。</p><p>本文将实现的应用叫 HTTPie，HTTPie 是一个用 Python 编写的命令行 HTTP客户端，其目标是使 CLI 与 web 服务的交互尽可能愉快。它被设计为一个<code>curl</code> 和 <code>wget</code>的替代品，提供易于使用的界面和一些用户友好的功能，如 JSON支持、语法高亮和插件。它对于测试、调试和通常与 HTTP 服务器或 RESTful API进行交云的开发人员来说非常有用。</p><p>HTTPie 的一些关键特性包括：</p><ol type="1"><li><strong>JSON 支持</strong>：默认情况下，HTTPie 会自动发送JSON，并且可以轻松地通过命令行发送 JSON 请求体。</li><li><strong>语法高亮</strong>：它会为 HTTP响应输出提供语法高亮显示，使得结果更加易于阅读。</li><li><strong>插件</strong>：HTTPie 支持插件，允许扩展其核心功能。</li><li><strong>表单和文件上传</strong>：可以很容易地通过表单上传文件。</li><li><strong>自定义 HTTP 方法和头部</strong>：可以发送任何 HTTP方法的请求，自定义请求头部。</li><li><strong>HTTPS、代理和身份验证支持</strong>：支持 HTTPS请求、使用代理以及多种 HTTP 身份验证机制。</li><li><strong>流式上传和下载</strong>：支持大文件的流式上传和下载。</li><li><strong>会话支持</strong>：可以保存和重用常用的请求和集合。</li></ol><p>本文我们将实现其中的 <code>1</code>、<code>2</code> 和<code>5</code>。我们会支持发送 GET 和 POST 请求，其中 POST支持设置请求头和 JSON 数据。</p><p>在本文中，你可以学习到：</p><ul><li>如何用 <code>clap</code> 解析命令行参数。</li><li>如何用 <code>tokio</code> 进行异步编程。</li><li>如何用 <code>reqwest</code> 发送 HTTP 请求。</li><li>如何用 <code>colored</code> 在终端输出带颜色的内容。</li><li>如何用 <code>jsonxf</code> 美化 json 字符串。</li><li>如何用 <code>anyhow</code> 配合 <code>?</code> 进行错误传播。</li><li>如何使用 <code>HTTPie</code> 来进行 HTTP 接口测试。</li></ul><p>在进行实际开发之前，推荐你先了解一下：</p><ul><li><a href="https://hedon.top/2024/03/02/rust-crate-reqwest/">Rustreqwest 简明教程</a></li><li><a href="https://hedon.top/2024/03/05/rust-crate-anyhow/">Rustanyhow 简明教程</a></li><li><a href="https://hedon.top/2024/03/02/rust-crate-clap/">深入探索Rust 的 clap 库：命令行解析的艺术</a></li></ul><p>本文完整代码：<ahref="https://github.com/hedon954/httpie">hedon954/httpie</a></p><h1 id="开发思路">开发思路</h1><h2 id="http-协议">HTTP 协议</h2><p>回顾一下 HTTP 协议的请求体和响应体结构。</p><p>请求结构：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240303131157545.png"alt="http request structure" /><figcaption aria-hidden="true">http request structure</figcaption></figure><p>响应结构：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240303131123618.png"alt="http response structure" /><figcaption aria-hidden="true">http response structure</figcaption></figure><h2 id="命令分析">命令分析</h2><p>在本文中，我们就实现 HTTPie cli 官方的这个<ahref="https://github.com/httpie/cli?tab=readme-ov-file#examples">示例</a>：即允许指定请求方法、携带headers 和 json 数据发送请求。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240303131445159.png"alt="HTTPie 官方示例" /><figcaption aria-hidden="true">HTTPie 官方示例</figcaption></figure><p>我们来拆解一下，这个命令可以分为以下几个部分：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">httpie &lt;METHOD&gt; &lt;URL&gt; [headers | params]...<br></code></pre></td></tr></table></figure><ul><li><code>&lt;METHOD&gt;</code>: 请求方法，本案例中，我们仅支持 GET 和POST。</li><li><code>&lt;URL&gt;</code>: 请求地址。</li><li><code>&lt;HEADERS&gt;</code>: 请求头，格式为<code>h1:v1</code>。</li><li><code>&lt;PARAMS&gt;</code>: 请求参数，格式为<code>k1=v1</code>，最终以 json 结构发送。</li></ul><h2 id="效果展示">效果展示</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  httpie git:(master) ✗ ./Httpie --<span class="hljs-built_in">help</span>                                              <br>Usage: Httpie &lt;COMMAND&gt;<br><br>Commands:<br>  get   <br>  post  <br>  <span class="hljs-built_in">help</span>  Print this message or the <span class="hljs-built_in">help</span> of the given subcommand(s)<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br></code></pre></td></tr></table></figure><p>其中 post 子命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: Httpie post &lt;URL&gt; &lt;BODY&gt;...<br><br>Arguments:<br>  &lt;URL&gt;      Specify the url you wanna request to<br>  &lt;BODY&gt;...  Set the request body. Examples: headers: header1:value1 params: key1=value1<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>  Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>请求示例：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240305225846224.png"alt="httpie response demo" /><figcaption aria-hidden="true">httpie response demo</figcaption></figure><h2 id="思路梳理">思路梳理</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240306223319742.png"alt="httpie 开发思路梳理" /><figcaption aria-hidden="true">httpie 开发思路梳理</figcaption></figure><p><strong>第 1 步：解析命令行参数</strong></p><p>本案例中 httpie 支持 2 个子命令：</p><ul><li>get 支持 url 参数</li><li>post 支持 url、body 参数，因为其中 headers 和 params是变长的，我们统一用 <code>Vec&lt;String&gt;</code> 类型的 body来接收，然后用 <code>:</code> 和 <code>=</code> 来区分它们。</li></ul><p><strong>第 2 步：发送请求</strong></p><ol type="1"><li>使用 reqwest 创建 http client；</li><li>设置 url；</li><li>设置 method；</li><li>设置 headers；</li><li>设置 params；</li><li>发送请求；</li><li>获取响应体。</li></ol><p><strong>第 3 步：打印响应</strong></p><ol type="1"><li>打印 http version 和 status，并使用 colored 赋予蓝色；</li><li>打印 response headers，并使用 colored 赋予绿色；</li><li>确定 content-type，如果是 json，我们就用 jsonxf 美化 json 串并使用colored 赋予蓝绿色输出，如果是其他类型，这里我们就输出原文即可。</li></ol><h1 id="实战过程">实战过程</h1><h2 id="创建项目">1. 创建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new httpie<br></code></pre></td></tr></table></figure><h2 id="添加依赖">2. 添加依赖</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;httpie&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">anyhow</span> = <span class="hljs-string">&quot;1.0.80&quot;</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.1&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;<br><span class="hljs-attr">colored</span> = <span class="hljs-string">&quot;2.1.0&quot;</span><br><span class="hljs-attr">jsonxf</span> = <span class="hljs-string">&quot;1.1.1&quot;</span><br><span class="hljs-attr">mime</span> = <span class="hljs-string">&quot;0.3.17&quot;</span><br><span class="hljs-attr">reqwest</span> = &#123; version = <span class="hljs-string">&quot;0.11.24&quot;</span>, features = [<span class="hljs-string">&quot;json&quot;</span>] &#125;<br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1.36.0&quot;</span>, features = [<span class="hljs-string">&quot;rt&quot;</span>, <span class="hljs-string">&quot;rt-multi-thread&quot;</span>, <span class="hljs-string">&quot;macros&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><ul><li><code>anyhow</code>: 用于简化异常处理。</li><li><code>clap</code>: 解析命令行参数。</li><li><code>colored</code>: 为终端输出内容赋予颜色。</li><li><code>jsonxf</code>: 美化 json 串。</li><li><code>mime</code>: 提供了各种 Media Type 的类型封装。</li><li><code>reqwest</code>: http 客户端。</li><li><code>tokio</code>: 异步库，本案例种我们使用 reqwest的异步功能。</li></ul><h2 id="完整源码">3. 完整源码</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// src/main.rs  为减小篇幅，省略了单元测试，读者可自行补充。</span><br><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">use</span> reqwest::&#123;Client, header, Response&#125;;<br><span class="hljs-keyword">use</span> std::<span class="hljs-type">str</span>::FromStr;<br><span class="hljs-keyword">use</span> anyhow::anyhow;<br><span class="hljs-keyword">use</span> clap::&#123;Args, Parser, Subcommand&#125;;<br><span class="hljs-keyword">use</span> colored::Colorize;<br><span class="hljs-keyword">use</span> mime::Mime;<br><span class="hljs-keyword">use</span> reqwest::header::&#123;HeaderMap, HeaderName, HeaderValue&#125;;<br><span class="hljs-keyword">use</span> reqwest::Url;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Httpie</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    methods: Method,<br>&#125;<br><br><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-title function_ invoke__">Get</span>(Get),<br>    <span class="hljs-title function_ invoke__">Post</span>(Post)<br>&#125;<br><br><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Get</span> &#123;<br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-comment">/// Specify the url you wanna request to.</span><br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-comment">/// Set the request body.</span><br>    <span class="hljs-comment">/// Examples:</span><br>    <span class="hljs-comment">///     headers:</span><br>    <span class="hljs-comment">///         header1:value1</span><br>    <span class="hljs-comment">///     params:</span><br>    <span class="hljs-comment">///         key1=value1</span><br>    <span class="hljs-meta">#[arg(required = true, value_parser = parse_kv_pairs)]</span><br>    body: <span class="hljs-type">Vec</span>&lt;KvPair&gt;<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    k: <span class="hljs-type">String</span>,<br>    v: <span class="hljs-type">String</span>,<br>    t: KvPairType,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug,Clone)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">KvPairType</span> &#123;<br>    Header,<br>    Param,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">FromStr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Err</span> = anyhow::Error;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_str</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::<span class="hljs-literal">Err</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pair_type</span>: KvPairType;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">split_char</span> = <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">contains</span>(<span class="hljs-string">&#x27;:&#x27;</span>) &#123;<br>            pair_type = KvPairType::Header;<br>            <span class="hljs-string">&#x27;:&#x27;</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pair_type = KvPairType::Param;<br>            <span class="hljs-string">&#x27;=&#x27;</span><br>        &#125;;<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">split</span> = s.<span class="hljs-title function_ invoke__">split</span>(split_char);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">err</span> = || anyhow!(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;failed to parse pairs &#123;&#125;&quot;</span>,s));<br>        <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-keyword">Self</span> &#123;<br>            k: (split.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">ok_or_else</span>(err)?).<span class="hljs-title function_ invoke__">to_string</span>(),<br>            v: (split.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">ok_or_else</span>(err)?).<span class="hljs-title function_ invoke__">to_string</span>(),<br>            t: pair_type,<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_url</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_url</span>: Url = s.<span class="hljs-title function_ invoke__">parse</span>()?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">into</span>())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_kv_pairs</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;KvPair&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">parse</span>()?)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(client: Client, args: &amp;Get) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">resp</span> = client.<span class="hljs-title function_ invoke__">get</span>(&amp;args.url).<span class="hljs-title function_ invoke__">send</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">print_resp</span>(resp).<span class="hljs-keyword">await</span>?)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">post</span>(client: Client, args: &amp;Post) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">body</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">header_map</span> = HeaderMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">pair</span> <span class="hljs-keyword">in</span> args.body.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">match</span> pair.t &#123;<br>            KvPairType::Param =&gt;  &#123;body.<span class="hljs-title function_ invoke__">insert</span>(&amp;pair.k, &amp;pair.v);&#125;<br>            KvPairType::Header =&gt; &#123;<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(name) = HeaderName::<span class="hljs-title function_ invoke__">from_str</span>(pair.k.<span class="hljs-title function_ invoke__">as_str</span>()) &#123;<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(value) = HeaderValue::<span class="hljs-title function_ invoke__">from_str</span>(pair.v.<span class="hljs-title function_ invoke__">as_str</span>()) &#123;<br>                        header_map.<span class="hljs-title function_ invoke__">insert</span>(name,value);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Invalid header value for key: &#123;&#125;&quot;</span>, pair.v);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Invalid header key: &#123;&#125;&quot;</span>, pair.k);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">resp</span> = client.<span class="hljs-title function_ invoke__">post</span>(&amp;args.url)<br>        .<span class="hljs-title function_ invoke__">headers</span>(header_map)<br>        .<span class="hljs-title function_ invoke__">json</span>(&amp;body).<span class="hljs-title function_ invoke__">send</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">print_resp</span>(resp).<span class="hljs-keyword">await</span>?)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_resp</span>(resp: Response) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-title function_ invoke__">print_status</span>(&amp;resp);<br>    <span class="hljs-title function_ invoke__">print_headers</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mime</span> = <span class="hljs-title function_ invoke__">get_content_type</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = resp.<span class="hljs-title function_ invoke__">text</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">print_body</span>(mime, &amp;body);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_status</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">status</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;:?&#125; &#123;&#125;&quot;</span>, resp.<span class="hljs-title function_ invoke__">version</span>(), resp.<span class="hljs-title function_ invoke__">status</span>()).<span class="hljs-title function_ invoke__">blue</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>, status);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_headers</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">for</span> (k,v) <span class="hljs-keyword">in</span> resp.<span class="hljs-title function_ invoke__">headers</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, k.<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">green</span>(), v);<br>    &#125;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_body</span>(mime: <span class="hljs-type">Option</span>&lt;Mime&gt;, resp: &amp;<span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-keyword">match</span> mime &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(v) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> v == mime::APPLICATION_JSON &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, jsonxf::<span class="hljs-title function_ invoke__">pretty_print</span>(resp).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">cyan</span>())<br>            &#125;<br>        &#125;<br>        _ =&gt; <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, resp),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_content_type</span>(resp: &amp;Response) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Mime&gt; &#123;<br>    resp.<span class="hljs-title function_ invoke__">headers</span>()<br>        .<span class="hljs-title function_ invoke__">get</span>(header::CONTENT_TYPE)<br>        .<span class="hljs-title function_ invoke__">map</span>(|v|v.<span class="hljs-title function_ invoke__">to_str</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>())<br>&#125;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt;&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">httpie</span> = Httpie::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">match</span> httpie.methods &#123;<br>        Method::<span class="hljs-title function_ invoke__">Get</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">get</span>(client, args).<span class="hljs-keyword">await</span>?,<br>        Method::<span class="hljs-title function_ invoke__">Post</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">post</span>(client, args).<span class="hljs-keyword">await</span>?,<br>    &#125;;<br>    <span class="hljs-title function_ invoke__">Ok</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，即使算上 <code>use</code> 部分，总代码也不过160行左右，Rust 的 <code>clap</code> 库在 CLI 开发上确实 yyds！</p><p>接下来我们来一一拆解这部分的代码，其中关于 <code>clap</code>的部分我不会过多展开，刚兴趣的读者可以参阅：<ahref="https://hedon.top/2024/03/02/rust-crate-clap/">深入探索 Rust 的clap 库：命令行解析的艺术</a>。</p><h3 id="命令行解析">3.1 命令行解析</h3><p>我们先从 <code>main()</code> 开始：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt;&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">httpie</span> = Httpie::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">match</span> httpie.methods &#123;<br>        Method::<span class="hljs-title function_ invoke__">Get</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">get</span>(client, args).<span class="hljs-keyword">await</span>?,<br>        Method::<span class="hljs-title function_ invoke__">Post</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">post</span>(client, args).<span class="hljs-keyword">await</span>?,<br>    &#125;;<br>    <span class="hljs-title function_ invoke__">Ok</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望使用 <code>clap</code> 的异步功能，所以使用了<code>async</code> 关键字，同时加上了 <code>tokio</code> 提供的属性宏<code>#[tokio::main]</code>，用于设置异步环境。为了能够使用<code>?</code> 快速传播错误，我们设置返回值为<code>anyhow::Result&lt;()&gt;</code>，本项目中我们不对错误进行过多处理，所以这种方式可以大大简化我们的错误处理过程。</p><p><code>main()</code> 中我们使用 <code>Httpie::parse()</code>解析命令行中的参数，使用 <code>Client::new()</code> 创建一个 httpclient，根据解析到的命令行参数，我们匹配子命令<code>methods</code>，分别调用 <code>get()</code> 和 <code>post()</code>来发送 GET 和 POST 请求。</p><p><code>Httpie</code> 的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Httpie</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    methods: Method,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Parser)]</code> 是一个过程宏（proceduralmacro），用于自动为结构体实现 <code>clap::Parser</code>trait。这使得该结构体可以用来解析命令行参数。</p><p>在 <code>Httpie</code> 中我们定义了子命令 <code>Method</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-title function_ invoke__">Get</span>(Get),<br>    <span class="hljs-title function_ invoke__">Post</span>(Post)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Subcommand)]</code>属性宏会自动为枚举派生一些代码，以便它可以作为子命令来解析命令行参数。目前支持<code>Get</code> 和 <code>Post</code> 两个子命令，它们分别接收<code>Get</code> 和 <code>Post</code> 参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Get</span> &#123;<br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br>  <br>    <span class="hljs-meta">#[arg(value_parser = parse_kv_pairs)]</span><br>    body: <span class="hljs-type">Vec</span>&lt;KvPair&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Args)]</code> 属性宏表明当前 struct 是命令的参数，其中<code>Get</code> 仅支持 <code>url</code> 参数，<code>Post</code> 支持<code>url</code> 和 <code>body</code> 参数。</p><p><code>url</code> 参数我们使用 <code>parse_url</code>函数来进行解析：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest::Url;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_url</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_url</span>: Url = s.<span class="hljs-title function_ invoke__">parse</span>()?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">into</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>reqwest::Url</code> 已经实现了 <code>FromStr</code>trait，所以这里我们可以直接调用 <code>s.parse()</code> 来解析<code>url</code>。</p><p>而 <code>body</code>，因为我们期望 CLI 使用起来像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">httpie url header1:value1 param1=v1<br></code></pre></td></tr></table></figure><p><code>body</code> 就是 <code>header1:value1 param1=v1</code>，一对 kv就代表着一个 header 或者 param，用 <code>:</code> 和 <code>=</code>来区分。因为 kv 对的个数的变长的，所以我们使用<code>Vec&lt;KvPair&gt;</code> 来接收 <code>body</code> 这个参数，并使用<code>parse_kv_pairs</code> 来解析 kv 对。</p><p><code>KvPair</code> 是我们自定义的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    k: <span class="hljs-type">String</span>,<br>    v: <span class="hljs-type">String</span>,<br>    t: KvPairType,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug,Clone)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">KvPairType</span> &#123;<br>    Header,<br>    Param,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>parse_kv_pairs</code> 的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_kv_pairs</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;KvPair&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">parse</span>()?)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，你可以在 <code>parse_kv_pairs()</code> 函数中，对<code>s</code> 进行解析并返回<code>anyhow::Result&lt;KvPair&gt;</code>。不过，更优雅，更统一的方式是什么呢？就是像<code>reqwest::Url</code> 一样，为 <code>KvPair</code> 实现<code>FromStr</code> trait，这样就可以直接调用 <code>s.parse()</code>来进行解析了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">FromStr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Err</span> = anyhow::Error;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_str</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::<span class="hljs-literal">Err</span>&gt; &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发送请求">3.2 发送请求</h3><p>参数解析完，就到了发送请求的地方了，这里使用 <code>reqwest</code>crate 就非常方便了，这里就不赘述了，具体可以参考：<ahref="https://hedon.top/2024/03/02/rust-crate-reqwest/">Rust reqwest简明教程</a>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(client: Client, args: &amp;Get) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123; ... &#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">post</span>(client: Client, args: &amp;Post) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="打印响应">3.3 打印响应</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240305225846224.png"alt="httpie response demo" /><figcaption aria-hidden="true">httpie response demo</figcaption></figure><p>响应分为 3 个部分：</p><ul><li>print_status()</li><li>print_headers()</li><li>print_body()</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_resp</span>(resp: Response) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-title function_ invoke__">print_status</span>(&amp;resp);<br>    <span class="hljs-title function_ invoke__">print_headers</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mime</span> = <span class="hljs-title function_ invoke__">get_content_type</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = resp.<span class="hljs-title function_ invoke__">text</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">print_body</span>(mime, &amp;body);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p><code>print_status()</code> 比较简单，就是打印 HTTP版本和响应状态码，然后我们使用 <code>colored</code> crate 的<code>blue()</code> 使其在终端以<font color="blue">蓝色</font>输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_status</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">status</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;:?&#125; &#123;&#125;&quot;</span>, resp.<span class="hljs-title function_ invoke__">version</span>(), resp.<span class="hljs-title function_ invoke__">status</span>()).<span class="hljs-title function_ invoke__">blue</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>, status);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>print_headers()</code> 中，我们使用 <code>green()</code> 使header_name 在终端以<font color="green">绿色</font>输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_headers</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">for</span> (k,v) <span class="hljs-keyword">in</span> resp.<span class="hljs-title function_ invoke__">headers</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, k.<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">green</span>(), v);<br>    &#125;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>响应体的格式（Media Type）有很多，本案例中我们仅支持<code>application/json</code>，所以在 <code>print_body()</code>之前，我们需要先读取 response header 中的 content-type：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_content_type</span>(resp: &amp;Response) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Mime&gt; &#123;<br>    resp.<span class="hljs-title function_ invoke__">headers</span>()<br>        .<span class="hljs-title function_ invoke__">get</span>(header::CONTENT_TYPE)<br>        .<span class="hljs-title function_ invoke__">map</span>(|v|v.<span class="hljs-title function_ invoke__">to_str</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>print_resp()</code> 中，对于<code>application/json</code>，我们使用 <code>jsonxf</code> crate对进行美化，并使用 <code>cyan()</code>使其在终端以<font color="cyan">蓝绿色</font>输出。对于其他类型，我们姑且照原文输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_body</span>(mime: <span class="hljs-type">Option</span>&lt;Mime&gt;, resp: &amp;<span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-keyword">match</span> mime &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(v) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> v == mime::APPLICATION_JSON &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, jsonxf::<span class="hljs-title function_ invoke__">pretty_print</span>(resp).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">cyan</span>())<br>            &#125;<br>        &#125;<br>        _ =&gt; <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, resp),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>在本文中，我们深入探讨了如何使用 Rust 语言来实现一个类似于 HTTPie的命令行工具。这个过程包括了对 HTTP 协议的理解、命令行参数的解析、HTTP客户端的创建和请求发送，以及对响应的处理和展示。通过本文，读者不仅能够获得一个实用的命令行工具，还能够学习到如何使用Rust 的库来构建实际的应用程序，包括<code>clap</code>、<code>reqwest</code>、<code>tokio</code> 和<code>colored</code> 等。此外，文章也说明了在 Rust中进行异步编程和错误处理的一些常见模式。尽管示例代码的错误处理较为简单，但它提供了一个良好的起点，开发者可以在此基础上进行扩展和改进，以适应更复杂的应用场景。</p>]]></content>
    
    
    <summary type="html">我们深入探讨了如何使用 Rust 语言来实现一个类似于 HTTPie 的命令行工具。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust anyhow 简明教程</title>
    <link href="https://hedon.top/2024/03/05/rust-crate-anyhow/"/>
    <id>https://hedon.top/2024/03/05/rust-crate-anyhow/</id>
    <published>2024-03-05T15:44:00.000Z</published>
    <updated>2024-05-20T02:36:16.099Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.rs/anyhow/latest/anyhow/index.html">anyhow</a>是 Rust 中的一个库，旨在提供灵活的、具体的错误处理能力，建立在<code>std::error::Error</code>基础上。它主要用于那些需要简单错误处理的应用程序和原型开发中，尤其是在错误类型不需要被严格区分的场景下。</p><p>以下是 <code>anyhow</code> 的几个关键特性：</p><ul><li><strong>易用性</strong>: <code>anyhow</code> 提供了一个<code>Error</code> 类型，这个类型可以包含任何实现了<code>std::error::Error</code> 的错误。这意味着你可以使用<code>anyhow::Error</code>来包装几乎所有类型的错误，无需担心具体的错误类型。</li><li><strong>简洁的错误链</strong>: <code>anyhow</code> 支持通过<code>?</code>操作符来传播错误，同时保留错误发生的上下文。这让错误处理更加直观，同时还能保留错误链，便于调试。</li><li><strong>便于调试</strong>: <code>anyhow</code> 支持通过<code>&#123;:#&#125;</code>格式化指示符来打印错误及其所有相关的上下文和原因，这使得调试复杂的错误链变得更加简单。</li><li><strong>无需关心错误类型</strong>:在很多情况下，特别是在应用程序的顶层，你可能不需要关心错误的具体类型，只需要知道出错了并且能够将错误信息传递给用户或日志。<code>anyhow</code>让这一过程变得简单，因为它可以包装任何错误，而不需要显式地指定错误类型。</li></ul><p>使用 <code>anyhow</code>的典型场景包括快速原型开发、应用程序顶层的错误处理，或者在库中作为返回错误类型的一个简便选择，尤其是在库的使用者不需要关心具体错误类型的时候。</p><h2 id="anyhowerror">anyhow::Error</h2><p><code>anyhow::Error</code> 是 <code>anyhow</code>库定义的一个错误类型。它是一个包装器（wrapper）类型，可以包含任何实现了<code>std::error::Error</code> trait的错误类型。这意味着你可以将几乎所有的错误转换为<code>anyhow::Error</code>类型，从而在函数之间传递，而不需要在意具体的错误类型。这在快速原型开发或应用程序顶层错误处理中特别有用，因为它简化了错误处理的逻辑。</p><p>它的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg_attr(not(doc), repr(transparent))]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Error</span> &#123;<br>    inner: Own&lt;ErrorImpl&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p>其中核心是 <code>ErrorImpl</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[repr(C)]</span><br><span class="hljs-title function_ invoke__">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ErrorImpl</span>&lt;E = ()&gt; &#123;<br>    vtable: &amp;<span class="hljs-symbol">&#x27;static</span> ErrorVTable,<br>    backtrace: <span class="hljs-type">Option</span>&lt;Backtrace&gt;,<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Don&#x27;t use directly. Use only through vtable. Erased type may have</span><br>    <span class="hljs-comment">// different alignment.</span><br>    _object: E,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ErrorImpl</code> 是一个内部结构体，用于实现<code>anyhow::Error</code> 类型的具体功能。它包含了三个主要字段：</p><ul><li><code>vtable</code>是一个指向静态虚拟表的指针，用于动态派发错误相关的方法。</li><li><code>backtrace</code>是一个可选的回溯（Backtrace）类型，用于存储错误发生时的调用栈信息。</li><li><code>_object</code>字段用于存储具体的错误对象，其类型在编译时被擦除以提供类型安全的动态错误处理。</li></ul><p>这种设计允许 <code>anyhow</code>错误封装并表示各种不同的错误类型，同时提供了方法动态派发和回溯功能，以便于错误调试。</p><p><code>anyhow::Error</code> 可以包含任何实现了<code>std::error::Error</code> trait 的错误类型，这里因为下面的<code>impl</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">impl&lt;E&gt; StdError <span class="hljs-keyword">for</span> ErrorImpl&lt;E&gt;<br>where<br>    E: StdError,<br>&#123;<br>    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn StdError + <span class="hljs-string">&#x27;static)&gt; &#123;</span><br><span class="hljs-string">        unsafe &#123; ErrorImpl::error(self.erase()).source() &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    #[cfg(error_generic_member_access)]</span><br><span class="hljs-string">    fn provide&lt;&#x27;</span>a&gt;(&amp;<span class="hljs-string">&#x27;a self, request: &amp;mut Request&lt;&#x27;</span>a&gt;) &#123;<br>        unsafe &#123; ErrorImpl::provide(self.erase(), request) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="anyhowresult">anyhow::Result</h2><p><code>anyhow::Result</code> 是一个别名（type alias），它是<code>std::result::Result&lt;T, anyhow::Error&gt;</code> 的简写。在使用<code>anyhow</code>库进行错误处理时，你会频繁地看到这个类型。它基本上是标准的<code>Result</code> 类型，但错误类型被固定为<code>anyhow::Error</code>。这使得你可以很容易地在函数之间传递错误，而不需要声明具体的错误类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span>&lt;T, E = Error&gt; = core::result::<span class="hljs-type">Result</span>&lt;T, E&gt;;<br></code></pre></td></tr></table></figure><p>使用 <code>anyhow::Result</code>的好处在于它提供了一种统一的方式来处理错误。你可以使用 <code>?</code>操作符来传播错误，同时保留错误的上下文信息和回溯。这极大地简化了错误处理代码，尤其是在多个可能产生不同错误类型的操作链中。</p><h2 id="个核心使用技巧">3 个核心使用技巧</h2><ul><li>使用 <code>Result&lt;T, anyhow::Error&gt;</code> 或者<code>anyhow::Result&lt;T&gt;</code> 作为返回值，然后利用 <code>?</code>语法糖无脑传播报错。</li><li>使用 with_context(f) 来附加错误信息。</li><li>使用 downcast 反解具体的错误类型。</li></ul><h2 id="实战案例">实战案例</h2><p>下面我们用一个案例来体会 <code>anyhow</code> 的使用方式：</p><p>我们的需求是：打开一个文件，解析文件中的数据并进行大写化，然后输出处理后的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> anyhow::&#123;<span class="hljs-type">Result</span>, Context&#125;;<br><span class="hljs-keyword">use</span> std::&#123;fs, io&#125;;<br><br><span class="hljs-comment">// 1. 读取文件、解析数据和执行数据操作都可能出现错误，</span><br><span class="hljs-comment">// 所以我们需要返回 Result 来兼容异常情况。</span><br><span class="hljs-comment">// 这里我们使用 anyhow::Result 来简化和传播错误。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_and_process_file</span>(file_path: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// 尝试读取文件</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">data</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(file_path)<br>        <span class="hljs-comment">// 2. 使用 with_context 来附加错误信息，然后利用 ? 语法糖传播错误。</span><br>        .<span class="hljs-title function_ invoke__">with_context</span>(||<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;failed to read file `&#123;&#125;`&quot;</span>, file_path))?;<br><br>    <span class="hljs-comment">// 解析数据</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">processed_data</span> = <span class="hljs-title function_ invoke__">parse_data</span>(&amp;data)<br>        .<span class="hljs-title function_ invoke__">with_context</span>(||<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;failed to parse data from file `&#123;&#125;`&quot;</span>, file_path))?;<br><br>    <span class="hljs-comment">// 执行数据操作</span><br>    <span class="hljs-title function_ invoke__">perform_some_operation</span>(processed_data)<br>        .<span class="hljs-title function_ invoke__">with_context</span>(|| <span class="hljs-string">&quot;failed to perform operation based on file data&quot;</span>)?;<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_data</span>(data: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(data.<span class="hljs-title function_ invoke__">to_uppercase</span>())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">perform_some_operation</span>(data: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;processed data: &#123;&#125;&quot;</span>, data);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">file_path</span> = <span class="hljs-string">&quot;./anyhow.txt&quot;</span>;<br>  <span class="hljs-comment">// 执行处理逻辑</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> =  <span class="hljs-title function_ invoke__">read_and_process_file</span>(file_path);<br>  <span class="hljs-comment">// 处理结果</span><br>    <span class="hljs-keyword">match</span> res &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;successfully!&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; &#123;<br>            <span class="hljs-comment">// 3. 使用 downcast 来反解出实际的错误实例，本案例中可能出现的异常是 io::Error。</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(my_error) = e.downcast_ref::&lt;io::Error&gt;() &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;has io error: &#123;:#&#125;&quot;</span>, my_error);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;unknown error: &#123;:?&#125;&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">探索 Rust 的 anyhow 库，它提供了一个简单而强大的方式来处理错误。本教程将引导你了解 anyhow 的核心特性，包括易用性、错误链、调试便利性，以及如何在不同场景下利用 anyhow 来简化错误处理。无论是快速原型开发还是应用程序顶层错误处理，anyhow 都是 Rust 开发者的得力助手。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 常用库" scheme="https://hedon.top/categories/Rust/Rust-%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>深入探索 Rust 的 clap 库：命令行解析的艺术</title>
    <link href="https://hedon.top/2024/03/02/rust-crate-clap/"/>
    <id>https://hedon.top/2024/03/02/rust-crate-clap/</id>
    <published>2024-03-02T12:08:59.000Z</published>
    <updated>2024-03-27T11:38:28.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="版本声明">版本声明</h1><ul><li>Rust: 1.76</li><li><a href="https://docs.rs/clap/4.5.1/clap/index.html">clap:4.5.1</a></li><li><ahref="https://docs.rs/clap_complete/4.5.1/clap_complete/index.html">clap_complete4.5.1</a></li><li><ahref="https://docs.rs/rpassword/7.3.1/rpassword/index.html">rpassword:7.3.1</a></li></ul><h1 id="结论先行">结论先行</h1><p>本文将从 CLI（Command LineInterface）命令行工具的概述讲起，介绍一个优秀的命令行工具应该具备的功能和特性。然后介绍Rust 中一个非常优秀的命令行解析工具 <code>clap</code>经典使用方法，并利用 <code>clap</code> 实现一个类似于 <code>curl</code>的工具 <code>httpie</code>。文章最后还将 <code>clap</code> 于 Go语言中同样优秀的命令行解析工具 <code>cobra</code>进行一个简单对比，便于读者进一步体会 <code>clap</code>的简洁和优秀。</p><p>本文将包含以下几个部分：</p><ol type="1"><li><strong>CLI 概述</strong>：从 CLI的基本概念出发，介绍优秀命令行工具应该具备的功能特性，并以 curl作为经典范例进行说明。</li><li><strong>详细介绍 clap</strong>：基于 clap 官方文档，分别详细介绍clap 以 derive 和 builder 两个方式构建 cli 的常用方法。</li><li><strong>实战 httpie</strong>：参考陈天老师的《Rust编程第一课》，用最新的 clap 版本（1.7.6）实现 httpie 工具。</li><li><strong>对比cobra</strong>：从设计理念和目标、功能特点、使用场景等方面简要对比 clap和 Go 流行的命令行解析库 cobra。</li></ol><p>特此声明，本文包含 AI 辅助生成内容，如有错误遗漏之处，敬请指出。</p><h1 id="cli-概述">CLI 概述</h1><p>CLI（Command LineInterface，命令行界面）是一种允许用户通过文本命令与计算机程序或操作系统进行交互的接口。与图形用户界面（GUI，GraphicalUser Interface）相比，CLI不提供图形元素，如按钮或图标，而是依赖于文本输入。用户通过键盘输入特定的命令行指令，命令行界面解释这些指令并执行相应的操作。</p><p>一款优秀的 CLI工具应该具备以下的功能和特性，以提升用户体验和效率：</p><p>一个优秀的命令行工具（CLI, Command LineInterface）应该具备以下功能和特性，以提升用户体验和效率：</p><ol type="1"><li><strong>直观易用</strong>：<ul><li><strong>简洁的命令语法</strong>：命令和参数的设计应直观易懂，方便用户记忆和使用。</li><li><strong>自动补全</strong>：支持命令和参数的自动补全功能，提高用户输入效率。</li><li><strong>命令别名</strong>：提供常用命令的简短别名，减少输入的工作量。</li></ul></li><li><strong>强大的帮助系统</strong>：<ul><li><strong>详细的帮助文档</strong>：每个命令和参数都应有清晰的说明文档。</li><li><strong>示例使用方式</strong>：提供常见的使用示例，帮助用户快速理解和应用。</li><li><strong>内置帮助命令</strong>：通过如<code>--help</code>或<code>-h</code>参数轻松访问帮助信息。</li></ul></li><li><strong>错误处理与反馈</strong>：<ul><li><strong>清晰的错误信息</strong>：出现错误时，提供明确、具体的错误信息，帮助用户快速定位问题。</li><li><strong>建议和解决方案</strong>：在可能的情况下，给出错误解决的建议或自动修复选项。</li></ul></li><li><strong>高效的执行和输出</strong>：<ul><li><strong>快速响应</strong>：命令执行应迅速，减少用户等待时间。</li><li><strong>格式化的输出</strong>：提供易于阅读和解析的输出格式，如表格、JSON或 XML 等。</li><li><strong>输出过滤和排序</strong>：允许用户根据需要过滤和排序输出结果，提高信息的查找效率。</li></ul></li><li><strong>跨平台兼容</strong>：<ul><li><strong>多平台支持</strong>：能够在不同的操作系统上运行，如Windows、macOS、Linux 等。</li><li><strong>环境适应性</strong>：自动适应不同的终端环境和字符编码，确保输出显示正确。</li></ul></li><li><strong>安全性</strong>：<ul><li><strong>安全的默认设置</strong>：默认配置应强调安全，避免暴露敏感信息。</li><li><strong>数据加密</strong>：在处理敏感信息（如密码）时，应使用加密手段保护数据安全。</li></ul></li><li><strong>版本管理</strong>：<ul><li><strong>版本控制</strong>：提供命令查看工具版本，支持多版本共存或升级。</li><li><strong>向后兼容</strong>：新版本应尽量保持与旧版本的兼容性，避免破坏用户现有的工作流程。</li></ul></li></ol><p>这些特性不仅能够提高用户的工作效率，还能增强用户体验，使命令行工具更加强大和易用。</p><p>下面我们以 <code>curl</code> 为例，看看优秀的 CLI工具大概长什么样子。</p><p><code>curl</code>是一种命令行工具和库，用于传输数据。它支持多种协议，包括HTTP、HTTPS、FTP、FTPS、SCP、SFTP、TFTP、TELNET、DICT、LDAP、LDAPS、IMAP、POP3、SMTP和 RTSP 等。<code>curl</code>是一个非常强大和灵活的工具，广泛应用于自动化脚本、系统测试、数据收集和许多其他用途。</p><p>进入终端，我们可以用下面命令查看 <code>curl</code> 的说明文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ curl --<span class="hljs-built_in">help</span><br>Usage: curl [options...] &lt;url&gt;<br> -d, --data &lt;data&gt;          HTTP POST data<br> -f, --fail                 Fail fast with no output on HTTP errors<br> -h, --<span class="hljs-built_in">help</span> &lt;category&gt;      Get <span class="hljs-built_in">help</span> <span class="hljs-keyword">for</span> commands<br> -i, --include              Include protocol response headers <span class="hljs-keyword">in</span> the output<br> -o, --output &lt;file&gt;        Write to file instead of stdout<br> -O, --remote-name          Write output to a file named as the remote file<br> -s, --silent               Silent mode<br> -T, --upload-file &lt;file&gt;   Transfer <span class="hljs-built_in">local</span> FILE to destination<br> -u, --user &lt;user:password&gt; Server user and password<br> -A, --user-agent &lt;name&gt;    Send User-Agent &lt;name&gt; to server<br> -v, --verbose              Make the operation more talkative<br> -V, --version              Show version number and quit<br><br>This is not the full <span class="hljs-built_in">help</span>, this menu is stripped into categories.<br>Use <span class="hljs-string">&quot;--help category&quot;</span> to get an overview of all categories.<br>For all options use the manual or <span class="hljs-string">&quot;--help all&quot;</span>.<br></code></pre></td></tr></table></figure><p>使用示例：</p><ul><li>下载文件： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -O http://example.com/file.txt<br></code></pre></td></tr></table></figure></li><li>发送 POST 请求： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&quot;param1=value1&amp;param2=value2&quot;</span> http://example.com/resource<br></code></pre></td></tr></table></figure></li><li>使用 HTTPS 并忽略证书验证： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -k https://example.com<br></code></pre></td></tr></table></figure></li><li>使用基本认证： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -u username:password http://example.com<br></code></pre></td></tr></table></figure></li></ul><p><code>curl</code>的这些特性使其成为开发者、系统管理员和自动化脚本中广泛使用的工具之一。</p><h1 id="clap">clap</h1><h2 id="概述">概述</h2><p><code>clap</code>，代表 <em>Command Line ArgumentParser</em>，是一个旨在创建直观、易用且功能强大的命令行界面的 Rust库。截至目前（2024.2），<code>clap</code> 已经发展到了 4.5.1版本，它通过简化命令行参数的处理，让开发者能更专注于应用逻辑的构建。</p><p><code>clap</code> 之所以在 Rust社区如此流行，得益于以下几个优点：</p><p><strong>1. 易于使用</strong></p><p><code>clap</code>的设计理念是让命令行参数的解析变得简单而直观。即使是没有经验的开发者也能快速上手，通过几行代码就能实现复杂的命令行参数解析。</p><p><strong>2. 功能丰富</strong></p><p><code>clap</code>提供了广泛的功能来满足各种命令行解析需求，包括但不限于：</p><ul><li><strong>自动生成的帮助信息</strong>：<code>clap</code>能根据定义的参数自动生成帮助信息，包括参数的说明、类型、默认值等。</li><li><strong>强大的错误提示</strong>：当用户输入无效的命令行参数时，<code>clap</code>会提供清晰且有用的错误提示，帮助用户快速定位问题。</li><li><strong>参数验证</strong>：开发者可以为参数设定验证规则，确保输入的参数符合预期。</li><li><strong>复杂的命令结构</strong>：支持子命令的嵌套，允许构建复杂的命令行应用结构。</li><li><strong>自定义派生</strong>：通过 <code>clap</code>的派生宏，可以简化命令行解析器的定义，使代码更加清晰。</li></ul><p><strong>3. 高度可定制</strong></p><p><code>clap</code>允许开发者高度定制命令行解析的行为和外观，包括自定义帮助信息的格式、控制错误消息的显示方式等。这种灵活性意味着你可以根据应用程序的需求调整<code>clap</code> 的行为。</p><p><strong>4. 性能优异</strong></p><p>尽管 <code>clap</code>功能强大，但它仍然非常注重性能。<code>clap</code>经过优化，以尽可能少的性能开销处理命令行参数。</p><p><strong>5. 活跃的社区支持</strong></p><p><code>clap</code> 有一个非常活跃的社区，在 GitHub上不断有新的贡献者加入。这意味着 <code>clap</code>不断地得到改进和更新，同时也有大量的社区资源可供参考。</p><h2 id="derive-vs-builder-1-初探">Derive vs Builder (1) 初探</h2><p><code>clap</code> 提供了 2 种构建命令行的方式，分别为<code>Derive</code> 和<code>Builder</code>。顾名思义，<code>Derive</code>就是利用宏强大的功能来构建命令行，而 <code>Builder</code>则采用构建者模式链式构建命令行工具。</p><p>在这里我们先给出示例来直观感受这 2 种构建方式的不同：</p><p>Derive:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-comment">/// Specify your name</span><br>    name: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-comment">/// Specify your age optionally</span><br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    age: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i8</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name: &#123;&#125;&quot;</span>, cli.name);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;age: &#123;:?&#125;&quot;</span>, cli.age);<br>&#125;<br></code></pre></td></tr></table></figure><p>Builder:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;myapp&quot;</span>)<br>  .<span class="hljs-title function_ invoke__">version</span>(<span class="hljs-string">&quot;1.0.0&quot;</span>)<br>  .<span class="hljs-title function_ invoke__">author</span>(<span class="hljs-string">&quot;hedon&quot;</span>)<br>  .<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;this is the short about&quot;</span>)<br>  .<span class="hljs-title function_ invoke__">long_about</span>(<span class="hljs-string">&quot;this is the long about&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!([NAME]).<span class="hljs-title function_ invoke__">required</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your name&quot;</span>))<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(-a --age &lt;AGE&gt;)<br>            .<span class="hljs-title function_ invoke__">value_parser</span>(clap::value_parser!(<span class="hljs-type">u8</span>))<br>            .<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your age optionally&quot;</span>))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name: &#123;:?&#125;&quot;</span>, matches.get_one::&lt;<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;NAME&quot;</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;age: &#123;:?&#125;&quot;</span>, matches.get_one::&lt;<span class="hljs-type">u8</span>&gt;(<span class="hljs-string">&quot;age&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这 2 个程序都实现了相同的功能，使用 <code>--help</code>，输出的内容大致都如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: derive [OPTIONS] &lt;NAME&gt;<br><br>Arguments:<br>  &lt;NAME&gt;  Specify your name<br><br>Options:<br>  -a, --age &lt;AGE&gt;  Specify your age optionally<br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>通过观察，可以发现 Derive 模式下，宏中的每一个属性，如<code>version</code>、<code>author</code> 等，都对应到 Builder模式下一个同名的函数。</p><p>下面我们将从<strong>「应用配置」</strong>、<strong>「参数类型」</strong>和<strong>「参数校验」</strong>三个方面，分别介绍<code>clap</code> 中 Derive 和 Builder 两种模式构建 CLI 的常用方法。</p><p>特别说明：后续的例子均在 <code>examples</code>目录下实现，故编译和执行命令都包含 example。</p><p>目录结构大概如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ tree         <br>.<br>├── Cargo.lock<br>├── Cargo.toml<br>├── examples<br>│   ├── optional.rs<br>├── src<br>│   └── main.rs<br>└── target<br>    └── release<br>        └── examples<br>        └── optional<br></code></pre></td></tr></table></figure><h2 id="derive">Derive</h2><p>要使用 <code>clap</code> 的 Derive 模式，需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add clap --features derive<br></code></pre></td></tr></table></figure><h3 id="应用配置">1. 应用配置</h3><p>我们需要定义一个 <code>strut</code> 来表示我们的<code>application</code>，利用它来承载应用的参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// The example of clap derive</span><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-comment">/// Specify your name</span><br>    name: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-comment">/// Specify your age optionally</span><br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    age: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i8</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name: &#123;&#125;&quot;</span>, cli.name);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;age: &#123;:?&#125;&quot;</span>, cli.age);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Parser)]</code> 是一个过程宏（proceduralmacro），用于自动为结构体实现 <code>clap::Parser</code>trait。这使得该结构体可以用来解析命令行参数。</p><ul><li>使用<code>#[derive(Parser)]</code>，你可以简化命令行解析的代码，因为<code>clap</code> 会根据结构体的字段自动生成命令行解析的逻辑。</li><li>每个字段都对应一个命令行参数，字段的类型和属性用来决定参数的解析方式和验证规则。</li></ul><p><code>#[command(version, about, long_about = None)]</code>属性用于为整个命令行程序提供元信息，它支持以下几个元素：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240301202114143.png"alt="#[command] 支持的元素" /><figcaption aria-hidden="true">#[command] 支持的元素</figcaption></figure><p><code>#[arg(short, long)]</code>属性用于配置命令参数的元信息，它支持以下几个属性：</p><table><thead><tr class="header"><th>属性</th><th>方法</th><th>默认值/行为</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>id</td><td>Arg::id</td><td>field’s name</td><td>当属性不存在时，使用字段名</td></tr><tr class="even"><td>value_parser</td><td>Arg::value_parser</td><td>auto-select based on field type</td><td>当属性不存在时，会基于字段类型自动选择实现</td></tr><tr class="odd"><td>action</td><td>Arg::action</td><td>auto-select based on field type</td><td>当属性不存在时，会基于字段类型自动选择动作</td></tr><tr class="even"><td>help</td><td>Arg::help</td><td>Doc comment summary</td><td>当属性不存在时，使用文档注释摘要</td></tr><tr class="odd"><td>long_help</td><td>Arg::long_help</td><td>Doc comment with blank line, else nothing</td><td>当属性不存在时，使用文档注释，如果有空行</td></tr><tr class="even"><td>verbatim_doc_comment</td><td>Minimizes preprocessing</td><td>-</td><td>将文档注释转换为 help/long_help 时最小化预处理</td></tr><tr class="odd"><td>short</td><td>Arg::short</td><td>no short set</td><td>当属性不存在时，没有短名称设置</td></tr><tr class="even"><td>long</td><td>Arg::long</td><td>no long set</td><td>当属性不存在时，没有长名称设置</td></tr><tr class="odd"><td>env</td><td>Arg::env</td><td>no env set</td><td>当属性不存在时，没有环境变量设置</td></tr><tr class="even"><td>from_global</td><td>Read Arg::global</td><td>-</td><td>无论在哪个子命令中，都读取 Arg::global 参数</td></tr><tr class="odd"><td>value_enum</td><td>Parse with ValueEnum</td><td>-</td><td>使用 ValueEnum 解析值</td></tr><tr class="even"><td>skip</td><td>Ignore this field</td><td>fills the field with Default::default()</td><td>忽略此字段，用 &lt;expr&gt; 或 Default::default() 填充</td></tr><tr class="odd"><td>default_value</td><td>Arg::default_value</td><td>Arg::required(false)</td><td>设置默认值，并将 Arg 设置为非必须</td></tr><tr class="even"><td>default_value_t</td><td>Arg::default_value</td><td>Arg::required(false)</td><td>要求 std::fmt::Display 与 Arg::value_parser 相匹配</td></tr><tr class="odd"><td>default_values_t</td><td>Arg::default_values</td><td>Arg::required(false)</td><td>要求字段类型为 Vec&lt;T&gt;，T 实现 std::fmt::Display</td></tr><tr class="even"><td>default_value_os_t</td><td>Arg::default_value_os</td><td>Arg::required(false)</td><td>要求 std::convert::Into&lt;OsString&gt;</td></tr><tr class="odd"><td>default_values_os_t</td><td>Arg::default_values_os</td><td>Arg::required(false)</td><td>要求字段类型为 Vec&lt;T&gt;，T实现std::convert::Into&lt;OsString&gt;</td></tr></tbody></table><h3 id="参数类型">2. 参数类型</h3><h4 id="arguments-options">2.1 Arguments &amp; Options</h4><p>从上面这个输出样例中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">the example of clap derive<br><br>Usage: derive [OPTIONS] &lt;NAME&gt;<br><br>Arguments:<br>  &lt;NAME&gt;  Specify your name<br><br>Options:<br>  -a, --age &lt;AGE&gt;  Specify your age optionally<br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>可以看到跟在命令后面有 2 中参数类型：</p><ul><li><strong>Arguments</strong>: 直接在命令后面指定值，如<code>cmd hedon</code>，有严格的顺序要求。</li><li><strong>Options</strong>: 需要用 <code>-&#123;short&#125;</code> 或<code>--&#123;long&#125;</code> 来指定是哪个参数，无严格的顺序要求。</li></ul><p>它们的定义区别就是是否使用了 <code>#[arg]</code>：</p><ul><li><strong>Options</strong>: 指定了 short 或 long。</li><li><strong>Arguments</strong>: 没有 short 和 long。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>  <span class="hljs-comment">/// 会被解析成 [NAME]</span><br>  name: <span class="hljs-type">String</span>,<br>  <br>  <span class="hljs-comment">/// 会被解析成 -a &lt;AGE&gt;</span><br>  <span class="hljs-meta">#[arg(short, long)]</span><br>  age: <span class="hljs-type">u8</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可选参数">2.2 可选参数</h4><p>可以使用 <code>Option</code> 来实现可选参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    name: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br><br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    age: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u8</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name: &#123;:?&#125;&quot;</span>, cli.name);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;age: &#123;:?&#125;&quot;</span>, cli.age);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build --example optional --release<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/target/release/examples/optional --<span class="hljs-built_in">help</span> <br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">this is the about from Cargo.toml<br><br>Usage: optional [OPTIONS] [NAME]<br><br>Arguments:<br>  [NAME]  <br><br>Options:<br>  -a, --age &lt;AGE&gt;  <br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br>  -V, --version    Print version<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/optional       <br>name: None<br>age: None<br>➜  learn-clap git:(master) ✗ ./target/release/examples/optional -a 1  <br>name: None<br>age: Some(1)<br>➜  learn-clap git:(master) ✗ ./target/release/examples/optional hedon  <br>name: Some(<span class="hljs-string">&quot;hedon&quot;</span>)<br>age: None<br>➜  learn-clap git:(master) ✗ ./target/release/examples/optional hedon -a 18<br>name: Some(<span class="hljs-string">&quot;hedon&quot;</span>)<br>age: Some(18)<br></code></pre></td></tr></table></figure><h4 id="枚举参数">2.3 枚举参数</h4><p>可以使用 <code>enum</code> 搭配 <code>value_enum</code>来实现多选一参数，并限制可选参数的取值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Parser, ValueEnum&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-comment">/// Choose the program mode run in</span><br>    <span class="hljs-meta">#[arg(value_enum)]</span><br>    mode: Mode,<br>&#125;<br><br><span class="hljs-meta">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Mode</span> &#123;<br>    <span class="hljs-comment">/// run in fast mode</span><br>    Fast,<br>    <span class="hljs-comment">/// run in slow mode</span><br>    Slow,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">match</span> cli.mode &#123;<br>        Mode::Fast =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;fast!!!!!&quot;</span>),<br>        Mode::Slow =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;slow......&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: enum &lt;MODE&gt;<br><br>Arguments:<br>  &lt;MODE&gt;<br>          Choose the program mode run <span class="hljs-keyword">in</span><br><br>          Possible values:<br>          - fast: run <span class="hljs-keyword">in</span> fast mode<br>          - slow: run <span class="hljs-keyword">in</span> slow mode<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span><br>          Print <span class="hljs-built_in">help</span> (see a summary with <span class="hljs-string">&#x27;-h&#x27;</span>)<br><br>  -V, --version<br>          Print version<br></code></pre></td></tr></table></figure><h4 id="累计参数">2.4 累计参数</h4><p>累积参数允许用户通过重复指定同一个标志（例如<code>-d</code>）来累加值或效果，通常用于控制命令行应用的详细级别（verbositylevel）或其他需要根据次数变化的行为。</p><p>在很多命令行工具中，累积参数常见于控制日志输出的详细程度。例如，一个<code>-v</code>（verbose）标志可能每被指定一次，就增加一层详细级别。所以，<code>-vvv</code>（等价于<code>-v -v -v</code>） 会比单个 <code>-v</code>提供更多的详细信息。</p><p>在 <code>clap</code> 中可以通过 <code>clap::ArgAction::Count</code>来实现这种累积参数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, action = clap::ArgAction::Count)]</span><br>    verbose: <span class="hljs-type">u8</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;verbose: &#123;&#125;&quot;</span>, cli.verbose);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/accurate --<span class="hljs-built_in">help</span><br>this is the about from Cargo.toml<br><br>Usage: accurate [OPTIONS]<br><br>Options:<br>  -v, --verbose...  <br>  -h, --<span class="hljs-built_in">help</span>        Print <span class="hljs-built_in">help</span><br>  -V, --version     Print version<br>➜  learn-clap git:(master) ✗ ./target/release/examples/accurate -v    <br>verbose: 1<br>➜  learn-clap git:(master) ✗ ./target/release/examples/accurate -vvvv<br>verbose: 4<br></code></pre></td></tr></table></figure><h4 id="变长参数">2.5 变长参数</h4><p>有时候我们希望接收变长参数，比如说：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">del file1 file2 file3<br></code></pre></td></tr></table></figure><p>这个时候可以使用 <code>Vec&lt;&gt;</code> 来实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    files: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;files: &#123;:?&#125;&quot;</span>, cli.files);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/var_length --<span class="hljs-built_in">help</span><br>this is the about from Cargo.toml<br><br>Usage: var_length [FILES]...<br><br>Arguments:<br>  [FILES]...  <br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br>➜  learn-clap git:(master) ✗ ./target/release/examples/var_length       <br>files: []<br>➜  learn-clap git:(master) ✗ ./target/release/examples/var_length file1 <br>files: [<span class="hljs-string">&quot;file1&quot;</span>]<br>➜  learn-clap git:(master) ✗ ./target/release/examples/var_length file1 file2<br>files: [<span class="hljs-string">&quot;file1&quot;</span>, <span class="hljs-string">&quot;file2&quot;</span>]<br>➜  learn-clap git:(master) ✗ ./target/release/examples/var_length file1 file2 file3<br>files: [<span class="hljs-string">&quot;file1&quot;</span>, <span class="hljs-string">&quot;file2&quot;</span>, <span class="hljs-string">&quot;file3&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="标志参数">2.6 标志参数</h4><p>对于标志参数，只要指定类型为<code>bool</code>，就可以自动实现了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    verbose: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;verbose: &#123;&#125;&quot;</span>, cli.verbose);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/flag --<span class="hljs-built_in">help</span><br>Usage: flag [OPTIONS]<br><br>Options:<br>  -v, --verbose  <br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br>➜  learn-clap git:(master) ✗ ./target/release/examples/flag       <br>verbose: <span class="hljs-literal">false</span><br>➜  learn-clap git:(master) ✗ ./target/release/examples/flag -v    <br>verbose: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="子命令">2.7 子命令</h4><p>在更复杂的命令行工具中，除了主命令，还有子命令，甚至子命令下面还有子命令，其实就是一颗命令树。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/hedon954/mapStorage/img/image-20240228183301763.png"alt="command tree" /><figcaption aria-hidden="true">command tree</figcaption></figure><p>在 <code>clap</code> 中可以使用 <code>#[command(subcommand)]</code>搭配 <code>#[derive(Subcommand)]</code> 实现子命令功能。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Parser, Subcommand&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    test: <span class="hljs-type">Option</span>&lt;Test&gt;,<br>&#125;<br><br><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-comment">/// Add a number</span><br>    Add &#123;<br>        <span class="hljs-meta">#[arg(short, long)]</span><br>        num: <span class="hljs-type">u16</span>,<br>    &#125;,<br>    <span class="hljs-comment">/// Sub a number</span><br>    Sub &#123;<br>        <span class="hljs-meta">#[arg(short, long)]</span><br>        num: <span class="hljs-type">u16</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(test) = cli.test &#123;<br>        <span class="hljs-keyword">match</span> test &#123;<br>            Test::Add &#123;num&#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;test add num: &#123;:?&#125;&quot;</span>, num),<br>            Test::Sub &#123;num&#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;test sub num: &#123;:?&#125;&quot;</span>, num),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/subcommand --<span class="hljs-built_in">help</span>      <br>this is the about from Cargo.toml<br><br>Usage: subcommand [COMMAND]<br><br>Commands:<br>  add   Add a number<br>  sub   Sub a number<br>  <span class="hljs-built_in">help</span>  Print this message or the <span class="hljs-built_in">help</span> of the given subcommand(s)<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br>➜  learn-clap git:(master) ✗ ./target/release/examples/subcommand add --<span class="hljs-built_in">help</span><br>Add a number<br><br>Usage: subcommand add --num &lt;NUM&gt;<br><br>Options:<br>  -n, --num &lt;NUM&gt;  <br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br>➜  learn-clap git:(master) ✗ ./target/release/examples/subcommand add -n 1  <br><span class="hljs-built_in">test</span> add num: 1<br>➜  learn-clap git:(master) ✗ ./target/release/examples/subcommand sub -n 2<br><span class="hljs-built_in">test</span> sub num: 2<br></code></pre></td></tr></table></figure><h3 id="参数校验">3. 参数校验</h3><h4 id="类型校验">3.1 类型校验</h4><p>可以发现，使用 Derive模式的时候，我们在参数后面指定参数类型的时候，<code>clap</code>就会对我们输入参数进行类型检查，不匹配的时候会输出丰富的报错信息和指导建议。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">error: invalid value <span class="hljs-string">&#x27;xxxx&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;--num &lt;NUM&gt;&#x27;</span>: invalid digit found <span class="hljs-keyword">in</span> string<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br></code></pre></td></tr></table></figure><p>默认支持：</p><ul><li>原生类型：<code>bool</code>, <code>String</code>,<code>OsString</code>,<code>PathBuf</code>、<code>usize</code>、<code>isize</code></li><li>范围数据：<code>u8</code>, <code>i8</code>, <code>u16</code>,<code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>,<code>i64</code></li><li>实现了 <code>ValueEnum</code> 的 enum 类型</li><li>实现了<code>From&lt;OsString&gt;</code>、<code>From&lt;&amp;OsStr&gt;</code>、<code>FromStr</code> 的类型</li></ul><p>这是因为他们都实现了 <code>TypedValueParser</code>trait，你自定义的类型也可以实现这个triat，这样就可以自动进行类型校验了。</p><p><code>clap</code> 还提供了一些更加严格的参数校验功能。👇🏻</p><h4 id="枚举校验">3.2 枚举校验</h4><p>对于实现 <code>ValueEnum</code>的枚举类型，如果输入的值不是枚举中定义的，则 <code>clap</code>会报错并提示可选值。</p><p>我们复用上面介绍「多选一参数」的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Parser, ValueEnum&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-comment">/// Choose the program mode run in</span><br>    <span class="hljs-meta">#[arg(value_enum)]</span><br>    mode: Mode,<br>&#125;<br><br><span class="hljs-meta">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Mode</span> &#123;<br>    <span class="hljs-comment">/// run in fast mode</span><br>    Fast,<br>    <span class="hljs-comment">/// run in slow mode</span><br>    Slow,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">match</span> cli.mode &#123;<br>        Mode::Fast =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;fast!!!!!&quot;</span>),<br>        Mode::Slow =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;slow......&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用错误的值进行尝试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/enum xxxx               <br>error: invalid value <span class="hljs-string">&#x27;xxxx&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;&lt;MODE&gt;&#x27;</span><br>  [possible values: fast, slow]<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br></code></pre></td></tr></table></figure><h4 id="范围校验">3.3 范围校验</h4><p>如果你想要实现数字类型范围限制的话，比如端口号参数的范围应该是 [1,65535]，那可以使用<code>value_parser! = clap::value_parser!(u16).range(1..)</code>来实现这个功能：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, value_parser = clap::value_parser!(u16).range(1..))]</span><br>    port: <span class="hljs-type">u16</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;port: &#123;:?&#125;&quot;</span>, cli.port);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/range --<span class="hljs-built_in">help</span>             <br>this is the about from Cargo.toml<br><br>Usage: range --port &lt;PORT&gt;<br><br>Options:<br>  -p, --port &lt;PORT&gt;  <br>  -h, --<span class="hljs-built_in">help</span>         Print <span class="hljs-built_in">help</span><br>  -V, --version      Print version<br>  <br>➜  learn-clap git:(master) ✗ ./target/release/examples/range -p 0  <br>error: invalid value <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;--port &lt;PORT&gt;&#x27;</span>: 0 is not <span class="hljs-keyword">in</span> 1..=65535<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/range -p 11111111<br>error: invalid value <span class="hljs-string">&#x27;11111111&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;--port &lt;PORT&gt;&#x27;</span>: 11111111 is not <span class="hljs-keyword">in</span> 1..=65535<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/range -p 1111    <br>port: 1111<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>value_parser = clap::value_parser!(u16).range(1..)</code>的含义可以分为两部分解释：</p><p><strong>1. clap::value_parser!(u16)</strong></p><p>这部分使用 <code>value_parser!</code> 宏为命令行参数指定了<code>u16</code> 类型的解析器。这意味着输入的参数值会被尝试解析为无符号16 位整数（<code>u16</code>）。如果输入不能被成功解析为 <code>u16</code>类型（例如，输入是非数字字符串或者数字过大/过小而不符合 <code>u16</code>的范围），<code>clap</code> 会报错并提示用户输入有效的参数值。</p><p><strong>2. .range(1..)</strong></p><p>这部分进一步限制了参数值的有效范围。<code>.range(1..)</code>指定了参数值必须大于或等于 1（包含 1），但没有上限。换句话说，任何小于 1的值都将被认为是无效的，<code>clap</code>会因此报错并要求用户输入一个符合范围要求的值。这在需要限定参数值为正数时非常有用。</p><p>结合起来，<code>value_parser = clap::value_parser!(u16).range(1..)</code>创建了一个规则，要求命令行参数必须是一个大于或等于 1 的 <code>u16</code>类型的数值。这在很多场景下都非常有用，比如当你需要用户指定一个正数端口号时。</p><p>在 RustRover 中，你可以在 Builder 模式，通过在<code>clap::value_parser!()</code> 中指定其他的类型，然后输入<code>.</code> 获得其他类型的内置校验规则。</p><h4 id="自定义校验">3.4 自定义校验</h4><p>对于更复杂的规则，<code>clap</code> 还支持自定义校验规则。比如上面对port 的校验，也可以自己实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::RangeInclusive;<br><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, value_parser = parse_port)]</span><br>    port: <span class="hljs-type">u16</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> PORT_RANGE: RangeInclusive&lt;<span class="hljs-type">usize</span>&gt; = <span class="hljs-number">1</span>..=<span class="hljs-number">65535</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_port</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u16</span>, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">port</span>: <span class="hljs-type">usize</span> = s<br>        .<span class="hljs-title function_ invoke__">parse</span>()<br>        .<span class="hljs-title function_ invoke__">map_err</span>(|_| <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;`&#123;s&#125;` isn&#x27;t a port number`&quot;</span>))?;<br><br>    <span class="hljs-keyword">if</span> PORT_RANGE.<span class="hljs-title function_ invoke__">contains</span>(&amp;port) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(port <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-built_in">format!</span>(<br>            <span class="hljs-string">&quot;port not in range &#123;&#125;-&#123;&#125;&quot;</span>,<br>            PORT_RANGE.<span class="hljs-title function_ invoke__">start</span>(),<br>            PORT_RANGE.<span class="hljs-title function_ invoke__">end</span>(),<br>        ))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;port: &#123;:?&#125;&quot;</span>, cli.port);<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码中，我们直接使用 <code>value_parser = parse_port</code>来指定自定义的校验规则。</p><p>我们自定义的校验规则为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_port</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u16</span>, <span class="hljs-type">String</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>它需要满足：</p><ul><li>入参是 &amp;str</li><li>出参是 Result&lt;参数类型, String&gt;</li></ul><p>可以测试输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/custom --<span class="hljs-built_in">help</span><br>this is the about from Cargo.toml<br><br>Usage: custom --port &lt;PORT&gt;<br><br>Options:<br>  -p, --port &lt;PORT&gt;  <br>  -h, --<span class="hljs-built_in">help</span>         Print <span class="hljs-built_in">help</span><br>  -V, --version      Print version<br>  <br>➜  learn-clap git:(master) ✗ ./target/release/examples/custom -p xxx<br>error: invalid value <span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;--port &lt;PORT&gt;&#x27;</span>: `xxx` isn<span class="hljs-string">&#x27;t a port number`</span><br><span class="hljs-string"></span><br><span class="hljs-string">For more information, try &#x27;</span>--<span class="hljs-built_in">help</span><span class="hljs-string">&#x27;.</span><br><span class="hljs-string"></span><br><span class="hljs-string">➜  learn-clap git:(master) ✗ ./target/release/examples/custom -p 0  </span><br><span class="hljs-string">error: invalid value &#x27;</span>0<span class="hljs-string">&#x27; for &#x27;</span>--port &lt;PORT&gt;<span class="hljs-string">&#x27;: port not in range 1-65535</span><br><span class="hljs-string"></span><br><span class="hljs-string">For more information, try &#x27;</span>--<span class="hljs-built_in">help</span><span class="hljs-string">&#x27;.</span><br><span class="hljs-string"></span><br><span class="hljs-string">➜  learn-clap git:(master) ✗ ./target/release/examples/custom -p 9527</span><br><span class="hljs-string">port: 9527</span><br></code></pre></td></tr></table></figure><h4 id="关联参数">3.5 关联参数</h4><p>有时候参数直接还有关联关系，比如说：</p><ul><li>依赖：必须存在 <code>-a</code> 参数，<code>-b</code>参数才有意义，即要使用 <code>-b</code> 参数时，必须指定 <code>-a</code>参数。</li><li>互斥：<code>-a</code> 和 <code>-b</code> 只能同时存在一个。</li></ul><p><strong>可以使用 requires 实现依赖关系：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    a: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br><br>    <span class="hljs-meta">#[arg(short, long,requires = <span class="hljs-string">&quot;a&quot;</span>)]</span><br>    b: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a: &#123;:?&#125;&quot;</span>, cli.a);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;b: &#123;:?&#125;&quot;</span>, cli.b);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们在参数 <code>b</code> 中加入了<code>requires = "a"</code>，表示要使用 <code>b</code> 参数必须要有<code>a</code> 参数。</p><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/relation      <br>a: None<br>b: None<br>➜  learn-clap git:(master) ✗ ./target/release/examples/relation -b 1 <br>error: the following required arguments were not provided:<br>  --a &lt;A&gt;<br><br>Usage: relation --a &lt;A&gt; --b &lt;B&gt;<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/relation -a 1<br>a: Some(<span class="hljs-string">&quot;1&quot;</span>)<br>b: None<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/relation -a 1 -b 2<br>a: Some(<span class="hljs-string">&quot;1&quot;</span>)<br>b: Some(<span class="hljs-string">&quot;2&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>可以使用 #[group(required = true, mutiple = false)]来实现互斥关系：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Args, Parser&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[command(flatten)]</span><br>    args: Only,<br>&#125;<br><br><span class="hljs-meta">#[derive(Args, Debug)]</span><br><span class="hljs-meta">#[group(required = true, multiple = false)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Only</span> &#123;<br>    <span class="hljs-meta">#[arg(long)]</span><br>    a: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>    <span class="hljs-meta">#[arg(long)]</span><br>    b: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>    <span class="hljs-meta">#[arg(long)]</span><br>    c: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>    <span class="hljs-meta">#[arg(long)]</span><br>    d: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;only: &#123;:?&#125;&quot;</span>, cli.args)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[command(flattern)]</code> 直接将结构体里面的参数平铺。</p><p><code>#[group]</code>用于将一组参数归为一个组，<code>required = true</code> 表示必须提供该group 中的参数，<code>multiple = false</code>表示只能有一个参数被提供。</p><p>测试输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/only_one --<span class="hljs-built_in">help</span><br>this is the about from Cargo.toml<br><br>Usage: only_one &lt;--a &lt;A&gt;|--b &lt;B&gt;|--c &lt;C&gt;|--d &lt;D&gt;&gt;<br><br>Options:<br>      --a &lt;A&gt;    <br>      --b &lt;B&gt;    <br>      --c &lt;C&gt;    <br>      --d &lt;D&gt;    <br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br>  <br>➜  learn-clap git:(master) ✗ ./target/release/examples/only_one       <br>error: the following required arguments were not provided:<br>  &lt;--a &lt;A&gt;|--b &lt;B&gt;|--c &lt;C&gt;|--d &lt;D&gt;&gt;<br><br>Usage: only_one &lt;--a &lt;A&gt;|--b &lt;B&gt;|--c &lt;C&gt;|--d &lt;D&gt;&gt;<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/only_one --a 1      <br>only: Only &#123; a: Some(<span class="hljs-string">&quot;1&quot;</span>), b: None, c: None, d: None &#125;<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/only_one --a 1 --b 2<br>error: the argument <span class="hljs-string">&#x27;--a &lt;A&gt;&#x27;</span> cannot be used with <span class="hljs-string">&#x27;--b &lt;B&gt;&#x27;</span><br><br>Usage: only_one &lt;--a &lt;A&gt;|--b &lt;B&gt;|--c &lt;C&gt;|--d &lt;D&gt;&gt;<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/only_one --b 2      <br>only: Only &#123; a: None, b: Some(<span class="hljs-string">&quot;2&quot;</span>), c: None, d: None &#125;<br></code></pre></td></tr></table></figure><h2 id="builder">Builder</h2><p>使用 <code>clap</code> 的 Builder模式，一般情况下不需要额外引入其他的 features：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add clap<br></code></pre></td></tr></table></figure><p>但是如果要使用 <code>command!</code> 来构建应用的话，需要引入<code>cargo</code> 这个 features：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add clap --features cargo<br></code></pre></td></tr></table></figure><h3 id="应用配置-1">1. 应用配置</h3><p>在 Builder 模式下，你可以使用 <code>command!()</code> 或<code>Command::new("appname")</code> 来构建一个命令行应用，其中<code>command!()</code> 默认将 appname 设置应用名称，而<code>Command::new()</code> 必须显示指定 appname。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, Arg, Command, command, value_parser&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// let matches = command!()</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;MyApp&quot;</span>)<br>        <span class="hljs-comment">// Application configuration</span><br>        .<span class="hljs-title function_ invoke__">version</span>(<span class="hljs-string">&quot;1.0.0&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">author</span>(<span class="hljs-string">&quot;hedon&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;This the intro of the cli application&quot;</span>)<br>        <span class="hljs-comment">// Application args</span><br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!([NAME]).<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your name&quot;</span>))<br>        .<span class="hljs-title function_ invoke__">arg</span>(<br>            Arg::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-title function_ invoke__">short</span>(<span class="hljs-string">&#x27;a&#x27;</span>).<span class="hljs-title function_ invoke__">long</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">u8</span>))<br>        )<br>    .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-comment">// Read and parse command args</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(name) = matches.get_one::&lt;<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;NAME&quot;</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value for name: &#123;name&#125;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(age) = matches.get_one::&lt;<span class="hljs-type">u8</span>&gt;(<span class="hljs-string">&quot;age&quot;</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value for age: &#123;age&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码分为以下几个部分：</p><p><strong>1. 创建命令行应用实例</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;MyApp&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里使用 <code>Command::new</code>方法创建了一个新的命令行应用实例，命名为 <code>"MyApp"</code>。</p><p><strong>2. 配置应用</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">version</span>(<span class="hljs-string">&quot;1.0.0&quot;</span>)<br>.<span class="hljs-title function_ invoke__">author</span>(<span class="hljs-string">&quot;hedon&quot;</span>)<br>.<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;This the intro of the cli application&quot;</span>)<br></code></pre></td></tr></table></figure><p>接下来，使用链式调用方法配置应用的版本号为<code>"1.0.0"</code>，作者为<code>"hedon"</code>，并添加了一个简短的描述。</p><p>这里等价于 Builder 模式下的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[command(version, author, about)]</span><br></code></pre></td></tr></table></figure><p><strong>3. 添加命令行参数</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!([NAME]).<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your name&quot;</span>))<br>.<span class="hljs-title function_ invoke__">arg</span>(<br>    Arg::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-title function_ invoke__">short</span>(<span class="hljs-string">&#x27;a&#x27;</span>).<span class="hljs-title function_ invoke__">long</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">u8</span>))<br>)<br></code></pre></td></tr></table></figure><p>这部分代码添加了两个命令行参数： -<code>.arg(arg!([NAME]).required(true).help("Specify your name"))</code>使用 <code>arg!</code> 宏添加了一个名为 <code>NAME</code>的必需参数，并提供了一些帮助信息。 -<code>.arg(Arg::new("age").short('a').long("age").value_parser(value_parser!(u8)))</code>创建了另一个参数 <code>age</code>，可以通过 <code>-a</code> 或<code>--age</code> 来指定。这个参数使用了 <code>value_parser</code>宏来指明它的值应被解析为 <code>u8</code> 类型的数字。</p><p><strong>4. 解析命令行参数</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">get_matches</span>();<br></code></pre></td></tr></table></figure><p>使用 <code>.get_matches()</code> 方法来解析命令行参数并将结果存储在<code>matches</code> 变量中。</p><p><strong>5. 读取并打印参数值</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(name) = matches.get_one::&lt;<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;NAME&quot;</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value for name: &#123;name&#125;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(age) = matches.get_one::&lt;<span class="hljs-type">u8</span>&gt;(<span class="hljs-string">&quot;age&quot;</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value for age: &#123;age&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，使用 <code>matches.get_one::&lt;T&gt;("arg_name")</code>方法尝试获取指定名称的参数值。如果成功找到，则将其打印出来。这里分别尝试获取<code>"NAME"</code> 和 <code>"age"</code> 参数的值，并使用<code>println!</code> 宏将它们打印到控制台。</p><p>使用 <code>-- help</code> 测试输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">This the intro of the cli application<br><br>Usage: app2 [OPTIONS] [NAME]<br><br>Arguments:<br>  [NAME]  Specify your name<br><br>Options:<br>  -a, --age &lt;AGE&gt;  <br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br>  -V, --version    Print version<br></code></pre></td></tr></table></figure><p>你可以将其与「Derive -应用配置」进行比较，应该很容易找到它们之间的对应关系。</p><p>在 Derive 中 <code>#[command]</code> 和 <code>#[arg]</code>支持的属性，都可以在 Builder中找到对应的同名的函数，这里就不赘述了。</p><h3 id="参数类型-1">2. 参数类型</h3><p>在 Builder 模式中，配置参数有两种方式：</p><ul><li>arg!([-short] [--long] id)</li><li>Args::new("id").short('s').long("long")</li></ul><h4 id="arguments-options-1">2.1 Arguments &amp; Options</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Arguments:<br>  [NAME]  Specify your name<br><br>Options:<br>  -a, --age &lt;AGE&gt;  <br></code></pre></td></tr></table></figure><ul><li><strong>Argument:</strong> 不包含 <code>-&#123;short&#125;</code> 和<code>--&#123;long&#125;</code>。</li><li><strong>Options:</strong> 包含 <code>-&#123;short&#125;</code> 或<code>--&#123;long&#125;</code>。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!([NAME]).<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your name&quot;</span>))<br>.<span class="hljs-title function_ invoke__">arg</span>(arg!(-a --age &lt;AGE&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">u16</span>)))<br></code></pre></td></tr></table></figure><h4 id="可选参数-1">2.2 可选参数</h4><p>根据约定，<code>&lt;&gt;</code> 表示必须，而 <code>[]</code>表示可选：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;NAME&gt;)   <span class="hljs-comment">// 必须</span><br>.<span class="hljs-title function_ invoke__">arg</span>(arg!([ADDRESS]))  <span class="hljs-comment">// 可选</span><br></code></pre></td></tr></table></figure><p>你也可以使用 <code>.required(bool)</code> 函数明确指出是否必须：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;NAME&gt;).<span class="hljs-title function_ invoke__">required</span>(<span class="hljs-literal">true</span>))<br></code></pre></td></tr></table></figure><p><code>.required()</code> 的优先级高于 <code>&lt;&gt;</code> 和<code>[]</code>，但是建议你在构建的时候还是遵循约定。</p><h4 id="枚举参数-1">2.3 枚举参数</h4><p><strong>第 1 种：在 value_parser()中直接指定可选的枚举参数</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;MODE&gt;).<span class="hljs-title function_ invoke__">value_parser</span>([<span class="hljs-string">&quot;fast, slow&quot;</span>]))<br></code></pre></td></tr></table></figure><p><strong>第 2 种：使用枚举，但是枚举需要实现 ValueEnumtrait</strong></p><p>这里又有 2 种方式，你可以向 Derive 一样引入 <code>derive</code>features，然后直接 <code>#[derive(ValueElem)]</code>使用默认实现，也可以手动实现。我更倾向于前者。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, command, value_parser, ValueEnum&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = command!()<br>        <span class="hljs-comment">// .arg(arg!(&lt;MODE&gt;).value_parser([&quot;fast, slow&quot;]))</span><br>        .<span class="hljs-title function_ invoke__">arg</span>(<br>            arg!(&lt;MODE&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(Mode)).<span class="hljs-title function_ invoke__">required</span>(<span class="hljs-literal">true</span>)<br>        )<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-keyword">match</span> matches.get_one::&lt;Mode&gt;(<span class="hljs-string">&quot;MODE&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;&#x27;Mode&#x27; is required and parsing will fail if its missing&quot;</span>)&#123;<br>        Mode::Fast =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;fast&quot;</span>),<br>        Mode::Slow =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;slow&quot;</span>),<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, ValueEnum)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Mode</span> &#123;<br>    <span class="hljs-comment">/// Run in fast mode</span><br>    Fast,<br>    <span class="hljs-comment">/// Run in slow mode</span><br>    Slow,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="累计参数-1">2.4 累计参数</h4><p>使用 <code>clap::ArgAction::Count</code> 设置参数为累计参数，然后使用<code>get_count(id)</code> 获取参数的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, command&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = command!()<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(-v --verbose...).<span class="hljs-title function_ invoke__">action</span>(clap::ArgAction::Count))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;v count: &#123;:?&#125;&quot;</span>, matches.<span class="hljs-title function_ invoke__">get_count</span>(<span class="hljs-string">&quot;verbose&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，<code>arg!()</code> 中参数的定义，也要符合累计参数的格式<code>-&#123;short&#125; --&#123;long&#125;...</code>。</p><h4 id="变长参数-1">2.5 变长参数</h4><p>使用 <code>clap::ArgAction::Append</code>设置参数为变长参数，然后使用 <code>get_many::&lt;类型&gt;("id")</code>获取参数的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, Command&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;append-application&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!([FILES]...).<span class="hljs-title function_ invoke__">action</span>(clap::ArgAction::Append))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">files</span> = matches<br>        .get_many::&lt;<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;FILES&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">unwrap_or_default</span>()<br>        .<span class="hljs-title function_ invoke__">map</span>(|v|v.<span class="hljs-title function_ invoke__">as_str</span>())<br>        .collect::&lt;<span class="hljs-type">Vec</span>&lt;_&gt;&gt;();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;files: &#123;:?&#125;&quot;</span>, files);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，<code>arg!()</code> 中参数的定义，也要符合变长参数的格式<code>[arg]|&lt;arg&gt;...</code>。</p><h4 id="标志参数-1">2.6 标志参数</h4><p>使用 <code>clap::ArgAction::SetTrue</code> 或<code>clap::ArgAction::SetFalse</code> 设置参数为标志参数，然后使用<code>get_flag()</code> 获取参数的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, command&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = command!()<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(-d --debug).<span class="hljs-title function_ invoke__">action</span>(clap::ArgAction::SetTrue))<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(-v --verbose).<span class="hljs-title function_ invoke__">action</span>(clap::ArgAction::SetFalse))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;debug: &#123;:?&#125;&quot;</span>, matches.<span class="hljs-title function_ invoke__">get_flag</span>(<span class="hljs-string">&quot;debug&quot;</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;verbose: &#123;:?&#125;&quot;</span>, matches.<span class="hljs-title function_ invoke__">get_flag</span>(<span class="hljs-string">&quot;verbose&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>clap::ArgAction::SetTrue</code> : 设置参数的话，则为true，否则 false（默认）。</li><li><code>clap::ArgAction::SetFalse</code> : 设置参数的话，则为false，否则 true（默认）。</li></ul><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap-builder git:(master) ✗ ./target/release/examples/flag      <br>debug: <span class="hljs-literal">false</span><br>verbose: <span class="hljs-literal">true</span><br>➜  learn-clap-builder git:(master) ✗ ./target/release/examples/flag -d   <br>debug: <span class="hljs-literal">true</span><br>verbose: <span class="hljs-literal">true</span><br>➜  learn-clap-builder git:(master) ✗ ./target/release/examples/flag -v   <br>debug: <span class="hljs-literal">false</span><br>verbose: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h4 id="子命令-1">2.7 子命令</h4><p>可以使用 <code>subcommand(sub_cmd)</code> 和<code>subcommand([sub_cmd1, sub_cmd2])</code>来添加子命令，解析的时候使用 <code>matches.subcommand()</code>匹配子命令，再按照之前的规则解析子命令中对应的参数即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, Command, value_parser&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;myapp&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">subcommands</span>([<br>            Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;add&quot;</span>)<br>                .<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;NUM&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">i16</span>))),<br>            Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;sub&quot;</span>)<br>                .<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;NUM&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">i16</span>))),<br>        ])<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-keyword">match</span> matches.<span class="hljs-title function_ invoke__">subcommand</span>() &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-string">&quot;add&quot;</span>, add_cmd)) =&gt; <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;&#x27;myapp add&#x27; was used, num is: &#123;:?&#125;&quot;</span>,<br>            add_cmd.get_one::&lt;<span class="hljs-type">i16</span>&gt;(<span class="hljs-string">&quot;NUM&quot;</span>),<br>        ),<br>        <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-string">&quot;sub&quot;</span>, sub_cmd)) =&gt; <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;&#x27;myapp sub&#x27; was used, num is: &#123;:?&#125;&quot;</span>,<br>            sub_cmd.get_one::&lt;<span class="hljs-type">i16</span>&gt;(<span class="hljs-string">&quot;NUM&quot;</span>),<br>        ),<br>        _ =&gt; <span class="hljs-built_in">unreachable!</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参数校验-1">3. 参数校验</h3><h4 id="类型校验-1">3.1 类型校验</h4><p>使用 <code>value_parser!()</code> 在括号中指定类型，<code>clap</code>就会自动帮我们对参数进行类型校验，当然你在获取参数值<code>get_one::&lt;类型&gt;()</code> 的时候，类型要对上，否则会panic。</p><p>默认支持：</p><ul><li>原生类型：<code>bool</code>, <code>String</code>,<code>OsString</code>,<code>PathBuf</code>、<code>usize</code>、<code>isize</code></li><li>范围数据：<code>u8</code>, <code>i8</code>, <code>u16</code>,<code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>,<code>i64</code></li><li>实现了 <code>ValueEnum</code> 的 enum 类型</li><li>实现了<code>From&lt;OsString&gt;</code>、<code>From&lt;&amp;OsStr&gt;</code>、<code>FromStr</code> 的类型</li></ul><h4 id="枚举校验-1">3.2 枚举校验</h4><p>2.3 中枚举参数的说明中，已经体现了枚举校验的功能了，这里不赘述。</p><h4 id="范围校验-1">3.3 范围校验</h4><p>对于上述提到的「范围数据」，可以使用<code>value_parser!(类型).range()</code> 进行范围校验。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">arg!(&lt;PORT&gt;)<br>  .<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">u16</span>).<span class="hljs-title function_ invoke__">range</span>(<span class="hljs-number">1</span>..))<br></code></pre></td></tr></table></figure><h4 id="自定义校验-1">3.4 自定义校验</h4><p><code>value_parser()</code>中也可以传自定义的校验函数，该函数的签名需要满足的条件跟我们在介绍Derive 时一样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::RangeInclusive;<br><span class="hljs-keyword">use</span> clap::&#123;arg, command&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = command!()<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;PORT&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(port_in_range))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;port: &#123;:?&#125;&quot;</span>, matches.get_one::&lt;<span class="hljs-type">u16</span>&gt;(<span class="hljs-string">&quot;PORT&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">const</span> PORT_RANGE: RangeInclusive&lt;<span class="hljs-type">usize</span>&gt; = RangeInclusive::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>, <span class="hljs-number">65535</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">port_in_range</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u16</span>, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">port</span>: <span class="hljs-type">usize</span> = s<br>        .<span class="hljs-title function_ invoke__">parse</span>()<br>        .<span class="hljs-title function_ invoke__">map_err</span>(|_|<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;`&#123;s&#125;` is not a port number&quot;</span>))?;<br>    <span class="hljs-keyword">if</span> PORT_RANGE.<span class="hljs-title function_ invoke__">contains</span>(&amp;port) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(port <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-built_in">format!</span>(<br>            <span class="hljs-string">&quot;port not in range &#123;&#125;-&#123;&#125;&quot;</span>,<br>            PORT_RANGE.<span class="hljs-title function_ invoke__">start</span>(),<br>            PORT_RANGE.<span class="hljs-title function_ invoke__">end</span>(),<br>        ))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关联参数-1">3.5 关联参数</h4><ul><li><strong>依赖关系：</strong>使用<code>requires(id | group)</code></li><li><strong>排斥关系</strong>：使用<code>group().multiple(false).required(true)</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">group</span>(<br>    ArgGroup::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;vers&quot;</span>)<br>  <span class="hljs-comment">// 表示 &quot;set-ver&quot;, &quot;major&quot;, &quot;minor&quot;, &quot;patch&quot; 必须有一个且只能有一个存在</span><br>        .<span class="hljs-title function_ invoke__">multiple</span>(<span class="hljs-literal">false</span>)<br>        .<span class="hljs-title function_ invoke__">required</span>(<span class="hljs-literal">true</span>)<br>        .<span class="hljs-title function_ invoke__">args</span>([<span class="hljs-string">&quot;set-ver&quot;</span>, <span class="hljs-string">&quot;major&quot;</span>, <span class="hljs-string">&quot;minor&quot;</span>, <span class="hljs-string">&quot;patch&quot;</span>]),<br>)<br>.<span class="hljs-title function_ invoke__">arg</span>(<br>    arg!([INPUT_FILE] <span class="hljs-string">&quot;some regular input&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(PathBuf))<br>        .<span class="hljs-title function_ invoke__">group</span>(<span class="hljs-string">&quot;input&quot;</span>),<br>)<br>.<span class="hljs-title function_ invoke__">arg</span>(<br>    arg!(config: -c &lt;CONFIG&gt;)<br>        .<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(PathBuf))<br>   <span class="hljs-comment">// 表示 -c 需要有 group 为 input 的命令存在才可以使用</span><br>        .<span class="hljs-title function_ invoke__">requires</span>(<span class="hljs-string">&quot;input&quot;</span>),<br>)<br></code></pre></td></tr></table></figure><h2 id="derive-vs-builder-2-对比">Derive vs Builder (2) 对比</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/screencapture-wepie-feishu-cn-wiki-Bdb3wl4cViE6hqkUuykctkrqn8i-2024-03-01-20_52_38.png"alt="Derive vs Builder" /><figcaption aria-hidden="true">Derive vs Builder</figcaption></figure><h2 id="clap-rpassword-实现加密输入">clap + rpassword 实现加密输入</h2><p>对于密码、密钥等关键信息的输入，为了信息安全，我们一般会使用加密输出，<code>clap</code>本身不支持加密输入功能。若你有这方面的需求，可以使用<code>rpassword</code> crate 辅助完成。</p><p>示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><span class="hljs-keyword">use</span> rpassword::read_password;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    username: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-meta">#[arg(short, long, required = true)]</span><br>    password: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">password</span> = <span class="hljs-keyword">if</span> cli.password &#123;<br>        <span class="hljs-comment">// Prompt user to enter password</span><br>        <span class="hljs-title function_ invoke__">read_password</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to read password&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-string">&quot;&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()<br>    &#125;;<br><br>    <span class="hljs-comment">// Use username and password to do something</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;username: &#123;&#125;, password: &#123;&#125;&quot;</span>, cli.username, password);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="clap_complete-实现自动补全">clap_complete 实现自动补全</h2><p>要实现自动补全，需要在 <code>.zshrc</code> 或 <code>.bashrc</code> 等<code>SHELL</code> 文件中加入命令自动补全脚本。这时候可以使用<code>clap_complete</code> 来实现这个功能。</p><p>下面的示例目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── Cargo.lock<br>├── Cargo.toml<br>├── build.rs<br>└── src<br>    ├── cli.rs<br>    └── main.rs<br></code></pre></td></tr></table></figure><p>首先我们需要引入 <code>clap</code> 和 <code>clap_complete</code>crate，其中 <code>clap_complete</code> 只需在 build环境下即可，所以我们的 <code>Cargo.tmol</code> 如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;myapp&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-attr">build</span> = <span class="hljs-string">&quot;build.rs&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.1&quot;</span> &#125;<br><span class="hljs-attr">dirs</span> = <span class="hljs-string">&quot;5.0.1&quot;</span><br><br><span class="hljs-section">[build-dependencies]</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.1&quot;</span>&#125;<br><span class="hljs-attr">clap_complete</span> = <span class="hljs-string">&quot;4.5.1&quot;</span><br></code></pre></td></tr></table></figure><p>我们先在 <code>src/cli.rs</code> 中实现一个简单的命令行程序<strong>myapp</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Arg, ArgAction, Command&#125;;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_cli</span>() <span class="hljs-punctuation">-&gt;</span> Command &#123;<br>    Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;myapp&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;Tests completions&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">arg</span>(Arg::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;file&quot;</span>)<br>            .<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;some input file&quot;</span>))<br>        .<span class="hljs-title function_ invoke__">subcommand</span>(Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;test&quot;</span>)<br>            .<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;tests things&quot;</span>)<br>            .<span class="hljs-title function_ invoke__">arg</span>(Arg::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;case&quot;</span>)<br>                .<span class="hljs-title function_ invoke__">long</span>(<span class="hljs-string">&quot;case&quot;</span>)<br>                .<span class="hljs-title function_ invoke__">action</span>(ArgAction::Set)<br>                .<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;the case to test&quot;</span>)))<br>&#125;<br></code></pre></td></tr></table></figure><p>我们主要是演示这个自动补全功能，为了省事，<code>src/main.rs</code>中就不实现具体逻辑了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> cli;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_m</span> = cli::<span class="hljs-title function_ invoke__">build_cli</span>().<span class="hljs-title function_ invoke__">get_matches</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们在项目根目录下实现<code>build.rs</code>，它将为我们指定的命令生成自动补全脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> build.rs<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap_complete::&#123;generate_to, shells::Bash&#125;;<br><span class="hljs-keyword">use</span> std::env;<br><span class="hljs-keyword">use</span> std::io::Error;<br><br>include!(<span class="hljs-string">&quot;src/cli.rs&quot;</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">outdir</span> = <span class="hljs-keyword">match</span> env::<span class="hljs-title function_ invoke__">var_os</span>(<span class="hljs-string">&quot;OUT_DIR&quot;</span>) &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(()),<br>        <span class="hljs-title function_ invoke__">Some</span>(outdir) =&gt; outdir,<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cmd</span> = <span class="hljs-title function_ invoke__">build_cli</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = <span class="hljs-title function_ invoke__">generate_to</span>(<br>        Bash,<br>        &amp;<span class="hljs-keyword">mut</span> cmd, <span class="hljs-comment">// We need to specify what generator to use</span><br>        <span class="hljs-string">&quot;myapp&quot;</span>,  <span class="hljs-comment">// We need to specify the bin name manually</span><br>        outdir,   <span class="hljs-comment">// We need to specify where to write to</span><br>    )?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;cargo:warning=completion file is generated: &#123;path:?&#125;&quot;</span>);<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>你需要把其中的 <strong>myapp</strong> 替换为你的命令。</p><p>执行构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build<br></code></pre></td></tr></table></figure><p>可以看到输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">warning: myapp@0.1.0: completion file is generated: <span class="hljs-string">&quot;/Users/hedon/RustroverProjects/learn-clap-complete/target/debug/build/myapp-42e401d08c044ca3/out/myapp.bash&quot;</span><br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 1.90s<br></code></pre></td></tr></table></figure><p>这里会输出生成脚本所在的位置，我这里是<code>/Users/hedon/RustroverProjects/learn-clap-complete/target/debug/build/myapp-42e401d08c044ca3/out/myapp.bash</code>。</p><p>我的终端使用的是 zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span>      <br>/bin/zsh<br></code></pre></td></tr></table></figure><p>所以我需要将这个文件的内容加到 <code>~/.zshrc</code> 文件的末尾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /Users/hedon/RustroverProjects/learn-clap-complete/target/debug/build/myapp-42e401d08c044ca3/out/myapp.bash &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure><p>重新加载配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><p>这个时候你使用 <strong>myapp</strong> 命令的时候，按 <code>tap</code>键，就有自动补全了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ./target/debug/myapp <br>--<span class="hljs-built_in">help</span>    -h        \[file\]  <span class="hljs-built_in">help</span>      <span class="hljs-built_in">test</span> <br></code></pre></td></tr></table></figure><h1 id="httpie">HTTPie</h1><p>由于篇幅原因，实战 HTTPie 部分请看：<ahref="https://hedon.top/2024/03/06/rust-action-httpie/">Rust实战丨HTTPie</a></p><h1 id="与-go-语言-cobra-比较">与 Go 语言 cobra 比较</h1><p>Go 的 <code>cobra</code> 也是用于构建命令行应用程序的库，它在 Go语言生态中非常受欢迎。</p><p>为了直观展示这 2个库构建命令行应用程序的区别，我们来设计一个简单的命令行程序，用<code>clap</code> 和 <code>cobra</code>分别实现，以展示如何用这两个库实现相同的功能。</p><p>让我们创建一个 CLI 程序，它有一个 <code>greet</code> 子命令，接受一个<code>-n</code> 或 <code>--name</code> 参数，并打印出一条欢迎信息。</p><h2 id="rust-clap-实现">Rust clap 实现</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123; Parser, Subcommand&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(bin_name = <span class="hljs-string">&quot;greet_app&quot;</span>)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    sub: <span class="hljs-type">Option</span>&lt;Sub&gt;,<br>&#125;<br><br><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Sub</span> &#123;<br>    Greet &#123;<br>        <span class="hljs-meta">#[arg(short, long)]</span><br>        name: <span class="hljs-type">String</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(sub) = cli.sub &#123;<br>        <span class="hljs-keyword">match</span> sub &#123;<br>            Sub::Greet&#123;name&#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;greeting: &#123;:?&#125;&quot;</span>, name),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="go-cobra-实现">Go cobra 实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><br><span class="hljs-string">&quot;github.com/spf13/cobra&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> rootCmd = &amp;cobra.Command&#123;<br>Use:   <span class="hljs-string">&quot;greet_app&quot;</span>,<br>Short: <span class="hljs-string">&quot;A simple greeting application&quot;</span>,<br>Long:  <span class="hljs-string">`This is a simple greeting application with a greet command.`</span>,<br>&#125;<br><br><span class="hljs-keyword">var</span> greetCmd = &amp;cobra.Command&#123;<br>Use:   <span class="hljs-string">&quot;greet&quot;</span>,<br>Short: <span class="hljs-string">&quot;Greets a user&quot;</span>,<br>Long:  <span class="hljs-string">`Prints a greeting message for the specified user.`</span>,<br>Run: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cmd *cobra.Command, args []<span class="hljs-type">string</span>)</span></span> &#123;<br>name, _ := cmd.Flags().GetString(<span class="hljs-string">&quot;name&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, name)<br>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>rootCmd.AddCommand(greetCmd)<br>greetCmd.Flags().StringP(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;Sets the name to greet&quot;</span>)<br>greetCmd.MarkFlagRequired(<span class="hljs-string">&quot;name&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := rootCmd.Execute(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">This is a simple greeting application with a greet <span class="hljs-built_in">command</span>.<br><br>Usage:<br>  greet_app [<span class="hljs-built_in">command</span>]<br><br>Available Commands:<br>  completion  Generate the autocompletion script <span class="hljs-keyword">for</span> the specified shell<br>  greet       Greets a user<br>  <span class="hljs-built_in">help</span>        Help about any <span class="hljs-built_in">command</span><br><br>Flags:<br>  -h, --<span class="hljs-built_in">help</span>   <span class="hljs-built_in">help</span> <span class="hljs-keyword">for</span> greet_app<br><br>Use <span class="hljs-string">&quot;greet_app [command] --help&quot;</span> <span class="hljs-keyword">for</span> more information about a <span class="hljs-built_in">command</span>.<br></code></pre></td></tr></table></figure><h2 id="对比">对比</h2><h3 id="设计哲学和易用性">设计哲学和易用性</h3><p><strong>clap</strong>:</p><ul><li>使用 Rust 的宏来提供强大的编译时功能，如参数解析、验证等。</li><li>利用 Rust 的类型安全特性，减少运行时错误。</li><li>支持通过派生宏自动从结构体生成命令行解析代码，简化开发流程。</li></ul><p><strong>cobra</strong>:</p><ul><li>采用更传统的命令式编程模型，直观且易于上手。</li><li>通过组合命令对象来构建复杂的命令行应用。</li><li>提供了一套完整的生成工具来创建命令和配置，促进了开发速度。</li></ul><h3 id="功能和特性">功能和特性</h3><p><strong>clap</strong>:</p><ul><li>自动生成帮助信息、版本信息等。</li><li>支持多级子命令。</li><li>支持自定义验证器和复杂的参数关系（如互斥、依赖等）。</li></ul><p><strong>cobra</strong>:</p><ul><li>支持自动生成帮助文档。</li><li><strong>内置命令自动补全脚本生成功能</strong>。</li><li><strong>支持持久化命令行标志到配置文件</strong>。</li><li>通过插件支持增加额外的子命令。</li><li>能够轻松地与其他 Go 库集成，如 Viper 用于配置管理。</li></ul><h3 id="性能">性能</h3><p><strong>clap</strong>:</p><ul><li>由于 Rust 的编译时优化，<code>clap</code>在解析命令行参数时通常会有更好的性能。</li><li>更少的运行时开销，尤其是在处理大量复杂命令行参数时。</li></ul><p><strong>cobra</strong>:</p><ul><li>性能对于大多数命令行应用来说已经足够，但可能不如 <code>clap</code>优化。</li><li>Go 的运行时可能会引入额外的开销，尤其是在并发处理时。</li></ul>]]></content>
    
    
    <summary type="html">本文将深入探索 Rust 中一个非常流行的命令行解析工具 clap，本文会先详细介绍 clap Derive 和 Builder 两种构建命令行工具的方式，并实战 httpie 工具，最后还将 clap 与 Go 语言中在命令行解析同样流行的 cargo 进行比较。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 常用库" scheme="https://hedon.top/categories/Rust/Rust-%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="clap" scheme="https://hedon.top/tags/clap/"/>
    
  </entry>
  
  <entry>
    <title>Rust reqwest 简明教程</title>
    <link href="https://hedon.top/2024/03/02/rust-crate-reqwest/"/>
    <id>https://hedon.top/2024/03/02/rust-crate-reqwest/</id>
    <published>2024-03-02T10:46:56.000Z</published>
    <updated>2024-05-20T02:36:16.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p><code>reqwest</code> 是 Rust 中一个非常流行和强大的 HTTP客户端库，它提供了一种简单的方式来发送 HTTP请求并处理响应。<code>reqwest</code>支持阻塞和非阻塞（异步）请求，使其适合于各种不同的应用场景。在这篇博文中，我们将详细介绍如何使用<code>reqwest</code> 发送各种 HTTP 请求，并处理返回的响应。</p><h2 id="开始之前">开始之前</h2><p>在开始编写代码之前，你需要在你的 Rust 项目中添加 <code>reqwest</code>依赖。打开你的 <code>Cargo.toml</code> 文件，并添加以下内容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">reqwest</span> = &#123; version = <span class="hljs-string">&quot;0.12.4&quot;</span>, features = [<span class="hljs-string">&quot;json&quot;</span>] &#125;<br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1&quot;</span>, features = [<span class="hljs-string">&quot;full&quot;</span>] &#125;<br><span class="hljs-attr">serde</span> = &#123; version = <span class="hljs-string">&quot;1.0.197&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;<br><span class="hljs-attr">serde_json</span> = <span class="hljs-string">&quot;1.0.114&quot;</span><br></code></pre></td></tr></table></figure><p>这里我们还添加了其他几个依赖：</p><ul><li><code>tokio</code>: 在后面的示例中，我们将使用 <code>reqwest</code>的异步功能。</li><li><code>serde</code>: 用于数据解析，在示例中，我们会演示 json数据的解析。</li><li><code>serde_json</code>: 便于使用 <code>json!</code> 宏快速构建 json数据。</li></ul><h2 id="发送-get-请求">发送 GET 请求</h2><p>发送一个 GET 请求是最基本的 HTTP 操作。以下是如何使用<code>reqwest</code> 发送 GET 请求并设置请求头的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest::header;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">params</span> = [(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>), (<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;values&quot;</span>)];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = reqwest::Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = client<br>        .<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;http://httpbin.org/get&quot;</span>)<br>        <span class="hljs-comment">// set query params</span><br>        .form(&amp;params)<br>        <span class="hljs-comment">// set request headers</span><br>        .<span class="hljs-title function_ invoke__">header</span>(header::USER_AGENT, <span class="hljs-string">&quot;My Rust Program&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">header</span>(header::CONTENT_TYPE, <span class="hljs-string">&quot;application/json&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">send</span>()<br>        .<span class="hljs-keyword">await</span>?<br>        .<span class="hljs-title function_ invoke__">text</span>()<br>        .<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;body = &#123;:?&#125;&quot;</span>, body);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用 <code>reqwest::get</code> 函数发送一个 GET请求到 "https://httpbin.org/get"，并通过 <code>text</code>方法获取响应的文本内容。</p><h2 id="发送-post---text-请求">发送 POST - text 请求</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest::Client;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = client.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&quot;http://httpbin.org/post&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">body</span>(<span class="hljs-string">&quot;the exact body that is sent&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">send</span>()<br>        .<span class="hljs-keyword">await</span>?<br>        .<span class="hljs-title function_ invoke__">text</span>()<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;body: &#123;:?&#125;&quot;</span>, res);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="发送-post---form-请求">发送 POST - form 请求</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">params</span> = [(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>), (<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;values&quot;</span>)];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = reqwest::Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = client.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&quot;http://httpbin.org/post&quot;</span>)<br>        .form(&amp;params)<br>        .<span class="hljs-title function_ invoke__">send</span>()<br>        .<span class="hljs-keyword">await</span>?<br>        .<span class="hljs-title function_ invoke__">text</span>()<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;body: &#123;:?&#125;&quot;</span>, res);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="发送-post---json-请求">发送 POST - json 请求</h2><p>发送 POST 请求通常用于向服务器提交数据。以下是如何使用<code>reqwest</code> 发送包含 JSON 数据的 POST 请求的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest;<br><span class="hljs-keyword">use</span> serde_json::json;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = reqwest::Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = client.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&quot;https://httpbin.org/post&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">json</span>(&amp;json!(&#123;<span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;value&quot;</span>&#125;))<br>        .<span class="hljs-title function_ invoke__">send</span>()<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = res.<span class="hljs-title function_ invoke__">text</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Body:\n&#123;&#125;&quot;</span>, body);<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们使用 <code>Client::post</code> 方法创建一个 POST 请求，并通过<code>json</code> 方法设置 JSON 负载。然后，我们调用 <code>send</code>方法发送请求。</p><h2 id="处理-json-响应">处理 JSON 响应</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest;<br><span class="hljs-keyword">use</span> serde::Deserialize;<br><br><span class="hljs-meta">#[derive(Deserialize)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ip</span> &#123;<br>    origin: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ip</span>: Ip = reqwest::<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;https://httpbin.org/ip&quot;</span>)<br>        .<span class="hljs-keyword">await</span>?<br>        .<span class="hljs-title function_ invoke__">json</span>()<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;IP: &#123;&#125;&quot;</span>, ip.origin);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个 <code>Ip</code> 结构体来表示 JSON响应，然后使用 <code>json</code> 方法将响应反序列化为 <code>Ip</code>类型。</p><h2 id="总结">总结</h2><p><code>reqwest</code> 库为 Rust 提供了一个功能丰富而灵活的 HTTP客户端，适用于各种网络编程任务。无论是简单的数据获取还是复杂的 API交互，<code>reqwest</code> 都能帮助你以简洁的 Rust代码完成任务。希望这篇博文能帮助你开始使用 <code>reqwest</code>来开发网络相关的 Rust 应用！</p>]]></content>
    
    
    <summary type="html">本文介绍了 Rust 一个非常流程和强大的 HTTP 客户端库 reqwest 的基本使用方法。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 常用库" scheme="https://hedon.top/categories/Rust/Rust-%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Go 语言的 GPM 模型（Go1.21）</title>
    <link href="https://hedon.top/2024/01/20/go-gpm/"/>
    <id>https://hedon.top/2024/01/20/go-gpm/</id>
    <published>2024-01-20T05:10:41.000Z</published>
    <updated>2024-01-29T07:32:00.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>在现代软件开发中，有效地利用并发是提高应用性能和响应速度的关键。随着多核处理器的普及，编程语言和框架如何高效、简便地支持并发编程，成为了软件工程师们评估和选择工具时的一个重要考量。在这方面，Go语言凭借其创新的并发模型—GPM（Goroutine, P,M）—在众多编程语言中脱颖而出，为开发者提供了强大的工具，以简单、高效的方式实现并发。</p><p>自从 2009 年首次发布以来，Go语言就以其出色的性能、简洁的语法和对并发的原生支持赢得了广泛的关注。尤其是其并发模型，被设计为能够充分利用现代多核处理器的能力，同时隐藏底层的线程管理和同步复杂性，让开发者能够以更直观、更高级的抽象来构建并发程序。GPM模型，作为 Go 语言并发编程的核心，通过Goroutine、P（processor）、M（machine）三者的协同工作，实现了一种高效且易于管理的并发机制。</p><p>本文将基于 <strong>Go1.21</strong> 深入浅出地探讨 Go 语言的 GPM模型，主要分为几个部分：</p><ul><li>首先从其设计理念出发，详细解析 Goroutine、P 和 M三者的角色、工作原理及其相互之间的交互方式。</li><li>然后引入几个关键问题，我们会从结论上先总结 GPM的核心要点，内容包括协程调度循环、调度策略和调度时机。</li><li>接着我们会深入源码，去一步步洞察 Go 语言设计者是如何实现 GPM模型中的各个要点的，这个过程会比较繁琐，但其实也比较有趣，感兴趣的读者可以阅读这一块，若只是想对GPM 模型有个大概了解，那么停留在上一步也足矣了。</li><li>最后我们基于前面的分析，总结 G、P、M 三大组件在 Go程序运行过程中的状态流转图。</li></ul><p>通过对 GPM 模型的探讨，我们不仅能够理解 Go语言如何在众多现代编程语言中以其并发编程能力脱颖而出，还能够洞察其设计背后的智慧，以及这一模型如何随着Go 语言版本的迭代而不断进化和优化。无论你是对 Go语言充满好奇的新手，还是希望深化理解其并发模型的经验开发者，本文都将为你提供宝贵的视角和深刻的洞见。</p><h1 id="结论先行">结论先行</h1><h2 id="gpm-调度原理图">GPM 调度原理图</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126214830929.png"alt="Goroutine 调度原理图" /><figcaption aria-hidden="true">Goroutine 调度原理图</figcaption></figure><h2 id="goroutine-底层结构">Goroutine 底层结构</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h569pjiiosj21cu0u040p.jpg"alt="Goroutine 底层结构示例" /><figcaption aria-hidden="true">Goroutine 底层结构示例</figcaption></figure><h2 id="调度器-p-底层结构">调度器 P 底层结构</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57sl36b40j20o40u8js7.jpg"alt="P 底层结构" /><figcaption aria-hidden="true">P 底层结构</figcaption></figure><h2 id="gpm-调度循环">GPM 调度循环</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57qxoptk4j21hm0simyy.jpg"alt="GPM 调度循环图" /><figcaption aria-hidden="true">GPM 调度循环图</figcaption></figure><h2 id="gpm-协程调度优先级与顺序">GPM 协程调度优先级与顺序</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240127161341751.png"alt="Go 协程调度优先级与顺序" /><figcaption aria-hidden="true">Go 协程调度优先级与顺序</figcaption></figure><h2 id="寻找可执行-g-过程">寻找可执行 G 过程</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240128212451142.png"alt="findRunnable()" /><figcaption aria-hidden="true">findRunnable()</figcaption></figure><h2 id="协程切换时机">协程切换时机</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240129000028727.png"alt="Go 协程切换时机" /><figcaption aria-hidden="true">Go 协程切换时机</figcaption></figure><h1 id="gpm-模型">GPM 模型</h1><h2 id="概览">1. 概览</h2><p>这里有一张很流行的 Goroutine 调度原理图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126214830929.png"alt="Goroutine 调度原理图" /><figcaption aria-hidden="true">Goroutine 调度原理图</figcaption></figure><table><thead><tr class="header"><th>代号</th><th>名称</th><th>定义位置</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>Sched</td><td>调度器</td><td>proc.c</td><td>维护有存储 M 和 G 的队列以及调度器的一些状态信息等。</td></tr><tr class="even"><td>M</td><td>Machine 系统线程</td><td>runtime.h</td><td>它由操作系统管理的，Goroutine 就是跑在 M 之上的；M是一个很大的结构，里面维护小对象内存 cache（mcache）、当前执行的Goroutine、随机数发生器等等非常多的信息。</td></tr><tr class="odd"><td>P</td><td>Processor 处理器</td><td>runtime.h</td><td>它的主要用途就是用来执行 Goroutine 的，它维护了一个 Goroutine队列，即 runqueue。Processor 是让我们从 N:1 调度到 M:N调度的重要部分。所有的 P 都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS（可配置）个。</td></tr><tr class="even"><td>G</td><td>Goroutine 实现的核心结构</td><td>runtime.h</td><td>它包含了栈，指令指针，以及其他对调度 Goroutine很重要的信息，例如其阻塞的 channel。</td></tr><tr class="odd"><td>Global Queue</td><td>全局队列</td><td>proc.h</td><td>存放等待运行的 G。全局队列可能被任意的 P 加锁去获取里面的 G。</td></tr><tr class="even"><td>P Local Queue</td><td>P 的本地队列</td><td>proc.h</td><td>同全局队列类似，存放的也是等待运行的 G，但存放的数据有限，不会超过256 个。新建 G 时，G会优先加入本地队列。如果队列满了，则会把本地队列中一半的 G 以及新 G一起移动到全局队列。</td></tr></tbody></table><p>通过这个原理图我们知道 Go 语言的 GPM模型的作用非常简单，它就是一个“精打细算”的工具。以前单进程无法充分利用CPU资源，所以引入了多进程。又因为进程拥有的资源太多，其创建、切换和销毁都会占用很长时间，所以引入了更小粒度的线程。随着计算机科学的进步，现在看来，线程拥有的资源也是“比较多”的，所以线程的创建、切换和销毁代价也是“相对大”的。所以很多编程语言就引入了协程这个概念，其核心目的就是应用层自己抽象一个比线程更小粒度的调度单元，应用层结合操作系统的多线程能力，自己来管理“调度单元”的创建、切换和销毁，从而尽可能减少由线程切换带来的开销，以做到更轻量级的并发。</p><p>不同的编程语言可能有不同的实现，而关键就在于如何让调度更快、开销更小。这便是我们本文要探讨的主要内容。</p><div class="note note-info">            <p><strong>Go 语言的实现：</strong></p><p>线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P的本地队列为空时，M 会尝试从全局队列获得一批 G 放到 P的本地队列，或者从其他 P 的本地队列中“偷”一半 G 放到自己的本地队列。然后M 运行 G，G 执行之后，再从 P 获取下一个 G，如此不断重复下去。</p>          </div><p>在进入更加具体深入的讨论之前，我们需要重点思考以下几个问题：</p><ol type="1"><li>G 我们可以随便创建，可能有成千上万个，那 P 和 M 有多少个呢？</li><li>P 和 M 什么时候被创建呢？</li><li>操作系统只知道线程，所以实际上还是线程在执行任务，那么 G是如何调度到线程上并执行的呢？</li><li>如何防止协程饥饿？</li><li>如何减少频繁地创建和销毁线程？</li><li>多个线程从全局队列拿 G如何解决并发问题？又如何减少这种数据竞争呢？</li><li>在整个 Go 调度协程的过程中，G、P、M有哪些状态？它们又是如何轮转的呢？</li></ol><p>如果你对这几个问题有兴趣，请继续阅读下文。</p><h2 id="p-和-m-的个数问题">2. P 和 M 的个数问题</h2><ol type="1"><li>P 的数量由启动时环境变量 <code>$GOMAXPROCS</code> 或者程序中<code>runtime.GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有 <code>GOMAXPROCS</code> 个Goroutine 在同时运行。</li><li>M 的数量由 Go 语言本身的限制决定，Go 程序启动时会设置 M 的最大数量为<strong>10000</strong>个，但是内核很难支持这么多的线程数，所以这个限制可以忽略。可以使用<code>runtime.SetMaxThreads()</code> 设置 M 的最大数量。</li></ol><h2 id="p-和-m-何时被创建">3. P 和 M 何时被创建</h2><ol type="1"><li>P 的创建时机在确定了 P 的最大数量 n 后，runtime 会根据这个数量创建 n个 P。</li><li>M 创建的时机是在当没有足够的 M 来关联 P 并运行其中可运行的 G的时候，如所有的 M 此时都阻塞住了，而 P中还有很多就绪任务，就会去寻找空闲的 M，如果没有空闲的 M，就会去创建新的M。</li></ol><h2 id="调度循环">4. 调度循环</h2><p>在讨论 G 是如何被调度到 M 去执行的时候，我们需要先介绍 GPM模型中两个比较特殊的角色：<code>m0</code> 和 <code>g0</code>。</p><h3 id="m0">4.1 m0</h3><ul><li><strong>定义</strong>：m0 是 Go 程序启动时创建的第一个 M。它是由 Go运行时系统直接从操作系统线程创建的，不是从线程池中获取的。</li><li><strong>作用</strong>：m0 负责初始化和启动 Go运行时环境，包括创建调度器、分配第一个P（p0），并创建其他系统级别的资源。在程序的整个生命周期中，m0会继续存在，即使它可能不执行任何 Go 代码。</li><li><strong>特点</strong>：m0 不同于其他M，因为它不是从线程池中获取的。它可能没有绑定任何 P，除非程序中只有一个P（即 GOMAXPROCS 设置为 1）。</li></ul><h3 id="g0">4.2 g0</h3><ul><li><strong>定义</strong>：g0 是每个 M 的特殊Goroutine，它不执行任何实际的 Go 代码。每个 M 在创建时都会分配一个g0。</li><li><strong>作用</strong>：g0 主要用于执行调度器代码和进行系统调用。当 M需要执行这些非用户代码时，会切换到 g0 的栈上运行。</li><li><strong>特点</strong>：g0拥有自己的栈，这个栈用于存放调度器函数和系统调用的数据。这意味着当执行这些操作时，不会影响当前运行的用户Goroutine 的栈。</li></ul><h3 id="协程栈切换">4.3 协程栈切换</h3><p>g0 是 M 中负责调度其他 g 的协程，所以一个 M 中的协程调度其实就是在 g和 g0 之间不断切换：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240127155030695.png"alt="协程 g 与 协程 g0 的对应关系" /><figcaption aria-hidden="true">协程 g 与 协程 g0 的对应关系</figcaption></figure><p>大致过程如下：</p><ol type="1"><li>当 M 执行一个 G（用户 Goroutine）时，它使用 G的栈来运行用户代码。</li><li>当需要执行系统调用或调度器相关的代码时，M 会切换到 g0。g0拥有自己的栈，专门用于执行系统调用和调度器代码，这样可以避免污染用户Goroutine 的栈空间。在 g0 上，M 可以执行如内存分配、调度决策、处理Goroutine 的创建和销毁等操作。</li><li>完成系统调用或调度器任务后，M 会切换回之前的G，继续执行用户代码。这个过程会从 g0 的栈切换回 G 的栈。</li></ol><p>详细细节我们留到后面的源码分析揭晓。</p><h2 id="调度策略">5. 调度策略</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240127161341751.png"alt="Go 协程调度优先级与顺序" /><figcaption aria-hidden="true">Go 协程调度优先级与顺序</figcaption></figure><h3 id="获取本地运行队列">5.1 获取本地运行队列</h3><p>P 会优先尝试从自己的本地队列中寻找就绪的G，它<strong>一般</strong>会优先调度最近加入的。</p><p>因为这个时候可能由其他 P 来窃取 G，所以这里是需要同步机制的，Go采用原子操作来降低同步开销。</p><p>本地队列 G 的个数不超过 <strong>256</strong> 个，<strong>如果在创建 G的时候本地队列满了，会将本地队列中 1/2 的 G 连同新创建的 G一起放入全局队列中。</strong></p><h3 id="获取全局运行队列">5.2 获取全局运行队列</h3><p>P 会优先本地队列，然后才全局队列，这有个好处：</p><ul><li>如果只有全局队列，那么所有的 P 都需要去竞争全局队列中的G，这个时候需要上锁，且数据竞争会比较激烈，性能较差。</li><li>通过每个 P维护一个自己的本地队列可以减少并发冲突，如果实在需要去全局队列拿G，也可以一次性拿多个，大大减少了并发冲突的情况发生。</li></ul><p>但这又带来了一个问题，全局队列中协程的饥饿问题，因为 P会优先调度最近加入到自己本地队列中的 G，那可能会一直有新的 G被创建，导致全局队列中的 G 没有机会被调度到。Go 的解决思路是：</p><ul><li>P 每调度 <strong>61</strong> 次后，就会从全局队列中获取一个 G来运行。</li></ul><h3 id="获取准备就绪的网络协程">5.3 获取准备就绪的网络协程</h3><p>如果本地队列和全局队列都找不到就绪的 G 可以执行的话。调度会通过<code>runtime.netpoll</code> 获取可以运行的网络协程。</p><p>Go 语言的网络模型是对不同操作系统平台上 I/O 多路复用技术的封装。</p><p>当 Goroutine 在进行网络 I/O 时，它会被挂起，线程会去执行其他Goroutine。一旦 I/O 操作完成，该 Goroutine会被唤醒并重新排队等待执行。</p><h3 id="系统调用">5.4 系统调用</h3><p>当一个 Goroutine执行系统调用时，它可能会被阻塞，这时它的执行线程（M）可能会释放当前绑定的处理器（P），以便其他Goroutine 可以在该 P 上运行。</p><h3 id="协程窃取">5.5 协程窃取</h3><p>空闲的 M 如果绑定了 P，那么它的 P 会一直尝试从其他 P 的队列中窃取Goroutine，以平衡负载和避免空闲。这个时候为了让每个 P 都有可能被窃取，Go没有直接顺序遍历 P 列表，而是采用了一种相对随机的方式去遍历 P列表，直到找到可以运行的协程就返回。M 不断寻找可执行 G的这段期间，它被称为<strong>自旋线程</strong>。</p><p>所以为减少创建、切换和销毁线程的开销，Go 做了至少两点努力：</p><ol type="1"><li><p>偷取（Work Stealing）机制</p><p>当本线程无可运行的 G 时，它所绑定的 P 会尝试从其他线程绑定的 P 窃取G，而不是销毁线程。</p></li><li><p>移交（Hand Off）机制</p><p>当本线程因为 G 进行系统调用而阻塞时，线程会释放绑定的 P，把 P移交给其他空闲的线程执行。</p></li></ol><h2 id="调度时机">6. 调度时机</h2><p>Go 语言的调度器结合了抢占式调度和协作式调度，以下是 Go中这两种调度方式的具体实现和特性：</p><h3 id="协作式调度cooperative-scheduling">6.1 协作式调度（CooperativeScheduling）</h3><p><strong>阻塞操作</strong>：</p><ul><li>当 Goroutine执行阻塞操作（如通道操作、等待锁、系统调用等）时，它会主动放弃 CPU控制权，允许调度器切换到其他 Goroutine。</li></ul><p><strong>显式调度</strong>：</p><ul><li>Goroutine 显式请求 <code>runtime.Gosched()</code>调用，调度器进行调度。</li><li>这个时候回从当前协程切换到 g0 协程，取消 G 与 M 之间的绑定关系，把 G放入全局队列中。</li></ul><h3 id="抢占式调度preemptive-scheduling">6.2 抢占式调度（PreemptiveScheduling）</h3><p><strong>基于时间的抢占</strong>：</p><ul><li>从 Go 1.14 开始，调度器引入了基于时间的抢占机制。如果一个 Goroutine运行时间超过 10 毫秒，或者在系统调用中超过了 20微妙，调度器会在安全点（如函数调用、循环迭代、阻塞操作等）尝试暂停该Goroutine。</li><li>这种抢占不依赖于 Goroutine的显式放弃控制，而是由调度器主动触发。</li><li>安全点的选择旨在减少对 Goroutine执行的干扰，同时确保调度的公平性和响应性。</li></ul><p><strong>基于信号的抢占：</strong></p><ul><li>当程序在执行过程中既无法主动挂起，也不能进行系统调用，且无法进行函数调用时，就可以使用信号来调度。</li><li>信号其实就是线程信号，在操作系统中有很多基于信号的底层通信方式（SIGPIPE/ SIGURG / SIGHUP），而我们的线程可以注册对应信号的处理函数。</li><li>当线程接收到抢占信号时，会进入一个专门的信号处理器。这个处理器会检查是否处于安全点，如果是，则暂停当前Goroutine 并进行上下文切换。</li></ul><h1 id="源码分析">源码分析</h1><p>前面我们对 Go 语言的 GPM模型在基本概念、调度循环、调度策略和调度时机各个方面都进行了详细的阐述。如果读者只是想简单了解一下GPM模型的一些概念和设计思想，那么阅读到这里就基本足够了。如果对其源码实现有兴趣的话，那么请继续往下阅读~</p><p>接下来我们会从以下几个方面来对 Go 语言的 GPM 模型进行源码分析：</p><ol type="1"><li>G、P、M 在 Go 语言中的表示。</li><li>G 的创建过程。</li><li>g 和 g0 的切换过程。</li><li>GPM 的调度机制。</li></ol><h2 id="g-的底层结构">1. G 的底层结构</h2><p>G 在 Go 里面就是 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime2.go">runtime2.go</a>里面定义的 <code>g</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 栈参数。</span><br><span class="hljs-comment">// stack 描述实际的栈内存：[stack.lo, stack.hi)。</span><br><span class="hljs-comment">// stackguard0 是在 Go 栈增长序言中比较的栈指针。</span><br><span class="hljs-comment">// 通常是 stack.lo+StackGuard，但可以是 StackPreempt 来触发抢占。</span><br><span class="hljs-comment">// stackguard1 是在 C 栈增长序言中比较的栈指针。</span><br><span class="hljs-comment">// 在 g0 和 gsignal 栈上是 stack.lo+StackGuard。</span><br><span class="hljs-comment">// 在其他 goroutine 栈上是 ~0，以触发对 morestackc 的调用（并崩溃）。</span><br>stack       stack   <span class="hljs-comment">// 运行时/CGO 已知的偏移</span><br>stackguard0 <span class="hljs-type">uintptr</span> <span class="hljs-comment">// liblink 已知的偏移</span><br>stackguard1 <span class="hljs-type">uintptr</span> <span class="hljs-comment">// liblink 已知的偏移</span><br><br>_panic    *_panic <span class="hljs-comment">// 最内层的 panic - liblink 已知的偏移</span><br>_defer    *_defer <span class="hljs-comment">// 最内层的 defer</span><br>m         *m      <span class="hljs-comment">// 当前 m；arm liblink 已知的偏移</span><br>sched     gobuf   <span class="hljs-comment">// 当前协程的运行现场</span><br>syscallsp <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 如果 status==Gsyscall, syscallsp = sched.sp 在 gc 期间使用</span><br>syscallpc <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 如果 status==Gsyscall, syscallpc = sched.pc 在 gc 期间使用</span><br>stktopsp  <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 栈顶的预期 sp，用于回溯检查</span><br><span class="hljs-comment">// param 是一个通用的指针参数字段，用于在特定上下文中传递值，</span><br><span class="hljs-comment">// 其他存储参数的方式难以找到。目前有三种用途：</span><br><span class="hljs-comment">// 1. 当通道操作唤醒一个阻塞的 goroutine 时，它将 param 设置为</span><br><span class="hljs-comment">//    指向已完成阻塞操作的 sudog。</span><br><span class="hljs-comment">// 2. 由 gcAssistAlloc1 使用，以向其调用者信号，表明 goroutine 完成了 GC 周期。</span><br><span class="hljs-comment">//    以任何其他方式这样做是不安全的，因为此时 goroutine 的栈可能已经移动。</span><br><span class="hljs-comment">// 3. 由 debugCallWrap 使用，以将参数传递给新的 goroutine，因为在运行时分配闭包是被禁止的。</span><br>param        unsafe.Pointer<br>atomicstatus atomic.Uint32<br>stackLock    <span class="hljs-type">uint32</span> <span class="hljs-comment">// sigprof/scang 锁；<span class="hljs-doctag">TODO:</span> 合并到 atomicstatus</span><br>goid         <span class="hljs-type">uint64</span><br>schedlink    guintptr<br>waitsince    <span class="hljs-type">int64</span>      <span class="hljs-comment">// g 变为阻塞的大致时间</span><br>waitreason   waitReason <span class="hljs-comment">// 如果 status==Gwaiting</span><br><br>preempt       <span class="hljs-type">bool</span> <span class="hljs-comment">// 抢占信号，复制 stackguard0 = stackpreempt</span><br>preemptStop   <span class="hljs-type">bool</span> <span class="hljs-comment">// 在抢占时转换为 _Gpreempted；否则，只是取消调度</span><br>preemptShrink <span class="hljs-type">bool</span> <span class="hljs-comment">// 在同步安全点缩小栈</span><br><br><span class="hljs-comment">// asyncSafePoint 设置为 true 表示 g 在异步安全点停止。</span><br><span class="hljs-comment">// 这意味着栈上有没有精确指针信息的帧。</span><br>asyncSafePoint <span class="hljs-type">bool</span><br><br>paniconfault <span class="hljs-type">bool</span> <span class="hljs-comment">// 在意外的故障地址上触发 panic（而不是崩溃）</span><br>gcscandone   <span class="hljs-type">bool</span> <span class="hljs-comment">// g 已扫描栈；由 _Gscan 位在状态中保护</span><br>throwsplit   <span class="hljs-type">bool</span> <span class="hljs-comment">// 必须不分割栈</span><br><span class="hljs-comment">// activeStackChans 表示有未锁定的通道指向这个 goroutine 的栈。</span><br><span class="hljs-comment">// 如果为 true，栈复制需要获取通道锁来保护这些栈区域。</span><br>activeStackChans <span class="hljs-type">bool</span><br><span class="hljs-comment">// parkingOnChan 表示 goroutine 即将在 chansend 或 chanrecv 上停车。</span><br><span class="hljs-comment">// 用于标记栈缩小的不安全点。</span><br>parkingOnChan atomic.Bool<br><br>raceignore    <span class="hljs-type">int8</span>  <span class="hljs-comment">// 忽略竞态检测事件</span><br>tracking      <span class="hljs-type">bool</span>  <span class="hljs-comment">// 是否跟踪此 G 以获取调度延迟统计</span><br>trackingSeq   <span class="hljs-type">uint8</span> <span class="hljs-comment">// 用于决定是否跟踪此 G</span><br>trackingStamp <span class="hljs-type">int64</span> <span class="hljs-comment">// G 最后开始被跟踪的时间戳</span><br>runnableTime  <span class="hljs-type">int64</span> <span class="hljs-comment">// 可运行时间，运行时清除，仅在跟踪时使用</span><br>lockedm       muintptr<br>sig           <span class="hljs-type">uint32</span><br>writebuf      []<span class="hljs-type">byte</span><br>sigcode0      <span class="hljs-type">uintptr</span><br>sigcode1      <span class="hljs-type">uintptr</span><br>sigpc         <span class="hljs-type">uintptr</span><br>parentGoid    <span class="hljs-type">uint64</span>          <span class="hljs-comment">// 创建此 goroutine 的 goroutine 的 goid</span><br>gopc          <span class="hljs-type">uintptr</span>         <span class="hljs-comment">// 创建此 goroutine 的 go 语句的 pc</span><br>ancestors     *[]ancestorInfo <span class="hljs-comment">// 创建此 goroutine 的祖先 goroutine 的信息（仅在 debug.tracebackancestors 使用）</span><br>startpc       <span class="hljs-type">uintptr</span>         <span class="hljs-comment">// goroutine 函数的 pc</span><br>racectx       <span class="hljs-type">uintptr</span><br>waiting       *sudog         <span class="hljs-comment">// 此 g 正在等待的 sudog 结构（具有有效的 elem 指针）；按锁顺序</span><br>cgoCtxt       []<span class="hljs-type">uintptr</span>      <span class="hljs-comment">// cgo 回溯上下文</span><br>labels        unsafe.Pointer <span class="hljs-comment">// 分析器标签</span><br>timer         *timer         <span class="hljs-comment">// 缓存的计时器，用于 time.Sleep</span><br>selectDone    atomic.Uint32  <span class="hljs-comment">// 我们是否参与 select 并且有人赢得了竞赛？</span><br><br><span class="hljs-comment">// goroutineProfiled 指示当前 goroutine 的栈状态</span><br>  <span class="hljs-comment">// 是否已经被记录在进行中的 goroutine 性能分析中。</span><br>goroutineProfiled goroutineProfileStateHolder<br><br><span class="hljs-comment">// 每个 G 的追踪状态。</span><br>trace gTraceState<br><br><span class="hljs-comment">// 每个 G 的 GC 状态</span><br><br><span class="hljs-comment">// gcAssistBytes 是此 G 的 GC 协助信用，以分配的字节为单位。</span><br><span class="hljs-comment">// 如果为正，则 G 有信用分配 gcAssistBytes 字节而不协助。</span><br><span class="hljs-comment">// 如果为负，则 G 必须通过执行扫描工作来纠正这一点。</span><br><span class="hljs-comment">// 我们以字节为单位跟踪这一点，以便在 malloc 热路径中快速更新和检查债务。</span><br><span class="hljs-comment">// 协助比率决定了这如何对应于扫描工作债务。</span><br>gcAssistBytes <span class="hljs-type">int64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 <code>g</code> 结构字段非常多，这个结构体的设计反映了 Go语言对并发和协程管理的底层机制，包括栈管理、调度、垃圾回收、异常处理等多个方面。通过这种抽象，Go语言能够有效地管理成千上万的<code>goroutine</code>，使得并发编程变得更加简单和高效。</p><p>这里我们只关注 GPM 模型相关的内容，需要重点关心以下几个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br>stack     stack   <span class="hljs-comment">// 当前协程的协程栈</span><br>m         *m      <span class="hljs-comment">// 当前线程</span><br>sched     gobuf  <span class="hljs-comment">// 保存协程的运行现场</span><br>atomicstatus atomic.Uint32<span class="hljs-comment">// 协程状态</span><br>goid         <span class="hljs-type">uint64</span><span class="hljs-comment">// 协程ID</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="协程栈-stack">1.1 协程栈 stack</h3><p>其中 <code>stack</code>结构如下，它存储了协程栈的低地址和高地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> stack <span class="hljs-keyword">struct</span> &#123;<br>lo <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 栈的低地址</span><br>hi <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 栈的高地址</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程抽象-m">1.2 线程抽象 m</h3><p>而 <code>m</code> 就是 Go语言对操作系统线程的抽象，这不是实际的线程，这只是 Go语言对线程相关信息的抽象，以方便更好地调度协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> m <span class="hljs-keyword">struct</span> &#123;<br>g0      *g     <span class="hljs-comment">// g0 协程，Go 中的主协程</span><br>curg    *g       <span class="hljs-comment">// 现在正在运行的协程</span><br>id      <span class="hljs-type">int64</span> <span class="hljs-comment">// 线程ID</span><br>mOS<span class="hljs-comment">// 当前操作系统对线程的额外描述信息</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>m</code>结构体包含了许多字段，这些字段涉及到线程管理、调度、信号处理、系统调用、锁管理等多个方面。这个结构体是Go 并发模型的核心部分之一，它与 <code>g</code>（goroutine）和<code>p</code>（processor）结构体一起，构成了 Go的调度系统的基础。通过这种设计，Go能够有效地在多个操作系统线程之间调度成千上万的goroutine，实现高效的并发执行。</p><h3 id="协程上下文-gobuf">1.3 协程上下文 gobuf</h3><p><code>gobuf</code> 结构体在 Go 语言的运行时系统中用于保存<code>Goroutine</code>的执行上下文，特别是在调度和系统调用中。这个结构体保存了足够的信息以便在<code>Goroutine</code> 被暂停后能够恢复执行。</p><p>下面是对 <code>gobuf</code> 结构体中各个字段的解释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// sp, pc 和 g 的偏移量是已知的（在 libmach 中硬编码）。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// ctxt 在 GC 方面比较特殊：它可能是一个堆分配的 funcval，</span><br><span class="hljs-comment">// 因此 GC 需要跟踪它，但它需要在汇编中设置和清除，</span><br><span class="hljs-comment">// 在那里实现写屏障比较困难。然而，ctxt 实际上是一个保存的、活跃的寄存器，</span><br><span class="hljs-comment">// 我们只在真实寄存器和 gobuf 之间交换它。因此，我们在栈扫描期间将其视为根，</span><br><span class="hljs-comment">// 这意味着保存和恢复它的汇编不需要写屏障。它仍然被类型化为指针，</span><br><span class="hljs-comment">// 以便任何其他从 Go 进行的写操作都会获得写屏障。</span><br>sp   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 栈指针</span><br>pc   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 程序计数器</span><br>g    guintptr       <span class="hljs-comment">// 指向当前 goroutine 的指针</span><br>ctxt unsafe.Pointer <span class="hljs-comment">// 上下文，用于保存额外的状态或信息</span><br>ret  <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 用于保存函数返回值</span><br>lr   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 链接寄存器（在某些架构中用于函数调用）</span><br>bp   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 基指针（在启用帧指针的架构中使用）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们重点需要关注 2 个字段：</p><ul><li><code>sp</code>：栈指针，表示当前协程运行到栈中的哪个位置了。</li><li><code>pc</code>：程序计数器，表示当前协程运行到哪一行代码了。</li></ul><h3 id="协程状态-atomicstatus">1.4 协程状态 atomicstatus</h3><p>我记得在 Go1.16 版本中，这个字段的类型还是 <code>uint32</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">atomicstatus <span class="hljs-type">uint32</span><br></code></pre></td></tr></table></figure><p>现在 Go1.21 版本中，已经用了原子操作来减少并发冲突了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">atomicstatus atomic.Uint32<br></code></pre></td></tr></table></figure><p>可以看到 Go 的底层也是随着版本更新不断优化中的。</p><p><ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime2.go">runtime2.go</a>定义了 G 的各种状态，如：</p><ul><li><code>_Gidle (0)</code>: 表示 G 刚刚被分配，尚未初始化。</li><li><code>_Grunnable (1)</code>: 表示 G在运行队列上。它当前没有执行用户代码。栈不被该 <code>goroutine</code>拥有。</li><li>...</li></ul><p>后面我们会给出 G 状态的流转图。</p><h3 id="举个例子">1.5 举个例子</h3><p>假设我们现在有以下 Go 代码：main() 调用 do1()，do1() 调用do2()，do2() 调用 do3()。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do3</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;here is do3&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do2</span><span class="hljs-params">()</span></span> &#123;<br>do3()<span class="hljs-comment">//&lt;---------------</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do1</span><span class="hljs-params">()</span></span> &#123;<br>do2()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>do1()<br>&#125;<br></code></pre></td></tr></table></figure><p>那么当这段程序运行到第 6 行的时候，它的底层结构大概如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h569pjiiosj21cu0u040p.jpg"alt="Goroutine 底层结构示例" /><figcaption aria-hidden="true">Goroutine 底层结构示例</figcaption></figure><p>至于为什么这里有个 <code>goexit()</code>，其实就是为了可以跳回到<code>g0</code> 协程，后面我们会具体分析到。</p><h2 id="p-的底层结构">2. P 的底层结构</h2><p>P 的本质是 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime2.go">runtime2.go</a>里面定义的 <code>p</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;<br>    id          <span class="hljs-type">int32</span>          <span class="hljs-comment">// P 的唯一标识符</span><br>    status      <span class="hljs-type">uint32</span>         <span class="hljs-comment">// P 的状态，如 pidle/prunning/...</span><br>    link        puintptr       <span class="hljs-comment">// P 链接</span><br>    schedtick   <span class="hljs-type">uint32</span>         <span class="hljs-comment">// 每次调度器调用时递增</span><br>    syscalltick <span class="hljs-type">uint32</span>         <span class="hljs-comment">// 每次系统调用时递增</span><br>    sysmontick  sysmontick     <span class="hljs-comment">// sysmon 观察到的最后一个 tick</span><br>    m           muintptr       <span class="hljs-comment">// 关联的 M 的反向链接（如果空闲则为 nil）</span><br>    mcache      *mcache        <span class="hljs-comment">// M 缓存</span><br>    pcache      pageCache      <span class="hljs-comment">// 页面缓存</span><br>    raceprocctx <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 用于竞态检测的上下文</span><br><br>    <span class="hljs-comment">// 延迟结构体池</span><br>    deferpool    []*_defer<br>    deferpoolbuf [<span class="hljs-number">32</span>]*_defer<br><br>    <span class="hljs-comment">// Goroutine ID 缓存，减少对 runtime·sched.goidgen 的访问</span><br>    goidcache    <span class="hljs-type">uint64</span><br>    goidcacheend <span class="hljs-type">uint64</span><br><br>    <span class="hljs-comment">// 可运行 goroutine 队列，无锁访问</span><br>    runqhead <span class="hljs-type">uint32</span><br>    runqtail <span class="hljs-type">uint32</span><br>    runq     [<span class="hljs-number">256</span>]guintptr<br>    runnext  guintptr <span class="hljs-comment">// 下一个要运行的 G</span><br><br>    <span class="hljs-comment">// 空闲 G 的列表（状态 == Gdead）</span><br>    gFree <span class="hljs-keyword">struct</span> &#123;<br>        gList<br>        n <span class="hljs-type">int32</span><br>    &#125;<br><br>    <span class="hljs-comment">// sudog 缓存</span><br>    sudogcache []*sudog<br>    sudogbuf   [<span class="hljs-number">128</span>]*sudog<br><br>    <span class="hljs-comment">// 堆上 mspan 对象的缓存</span><br>    mspancache <span class="hljs-keyword">struct</span> &#123;<br>        <span class="hljs-built_in">len</span> <span class="hljs-type">int</span><br>        buf [<span class="hljs-number">128</span>]*mspan<br>    &#125;<br><br>    <span class="hljs-comment">// pinner 对象的缓存</span><br>    pinnerCache *pinner<br><br>  <span class="hljs-comment">// P 状态跟踪</span><br>    trace pTraceState<br><br>    <span class="hljs-comment">// 每个 P 的持久分配，避免互斥</span><br>    palloc persistentAlloc <br><br>    <span class="hljs-comment">// 定时器相关字段</span><br>    timer0When             atomic.Int64<br>    timerModifiedEarliest  atomic.Int64<br>    timersLock             mutex<br>    timers                 []*timer<br>    numTimers              atomic.Uint32<br>    deletedTimers          atomic.Uint32<br>    timerRaceCtx           <span class="hljs-type">uintptr</span><br><br>    <span class="hljs-comment">// GC 相关字段</span><br>    gcAssistTime         <span class="hljs-type">int64</span><br>    gcFractionalMarkTime <span class="hljs-type">int64</span><br>    gcw                  gcWork<br>    wbBuf                wbBuf<br><br>    <span class="hljs-comment">// 指示是否在下一个安全点运行特定的函数</span><br>    runSafePointFn <span class="hljs-type">uint32</span><br>  <br>    <span class="hljs-comment">// 指示当前 P 是否正在写入任何统计数据。</span><br>  <span class="hljs-comment">// 偶数时表示没有写入，奇数时表示正在写入。</span><br>    statsSeq       atomic.Uint32<br>  <br>    <span class="hljs-comment">// 指示当前的 P 应该尽快进入调度器，无论其上运行的是哪个 G。</span><br><span class="hljs-comment">// 这是实现抢占式调度的一部分，允许调度器在必要时中断长时间运行的 goroutine，</span><br>    <span class="hljs-comment">// 以便其他 goroutine 有机会运行。</span><br>    preempt        <span class="hljs-type">bool</span><br>  <br>    <span class="hljs-comment">// 记录页面分配、释放和清理跟踪信息的缓冲区。</span><br>    pageTraceBuf   pageTraceBuf<br>&#125;<br></code></pre></td></tr></table></figure><p><code>p</code> 结构体在 Go语言的运行时系统中代表了一个处理器（processor），它是调度器的核心组成部分。每个<code>p</code> 负责管理一组 <code>goroutine</code>的运行。这个结构体包含了许多字段，涉及到 <code>goroutine</code>的调度、内存分配、垃圾回收和其他系统级别的操作。</p><p>我们重点关注以下几个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;<br>m           muintptr   <span class="hljs-comment">// 当前负责的线程</span><br>  <br><span class="hljs-comment">// 本地可运行的协程的队列，可无锁访问</span><br>runqhead <span class="hljs-type">uint32</span> <span class="hljs-comment">// 队头</span><br>runqtail <span class="hljs-type">uint32</span> <span class="hljs-comment">// 队尾</span><br>runq     [<span class="hljs-number">256</span>]guintptr   <span class="hljs-comment">// 长度为 256</span><br>runnext guintptr <span class="hljs-comment">// 下一个可用的协程的指针</span><br>  <br>  <span class="hljs-comment">// 抢占标识，指示当前的 P 应该尽快进入调度器，无论其上运行的是哪个 G。</span><br>  preempt <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57sl36b40j20o40u8js7.jpg"alt="P 底层结构" /><figcaption aria-hidden="true">P 底层结构</figcaption></figure><h2 id="goroutine-的创建">3. Goroutine 的创建</h2><p>Go 并发能力的优秀之处，就在于它启动一个新的协程实在是太方便了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; ... &#125;()<br></code></pre></td></tr></table></figure><p>那么底层究竟做了什么呢？</p><h3 id="newproc">3.1 newproc()</h3><p>Goroutine 通过 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a>中的 <code>newproc()</code> 创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc</span><span class="hljs-params">(fn *funcval)</span></span> &#123;<br>    gp := getg()<br>    pc := getcallerpc()<br>    systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        newg := newproc1(fn, gp, pc)<br><br>        pp := getg().m.p.ptr()<br>        runqput(pp, newg, <span class="hljs-literal">true</span>)<br><br>        <span class="hljs-keyword">if</span> mainStarted &#123;<br>            wakep()<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>获取当前 goroutine 和调用者 PC</strong>: <code>getg()</code>获取当前正在执行的 <code>goroutine</code>，<code>getcallerpc()</code>获取调用者的程序计数器地址。</li><li><strong>在系统栈上执行 <code>newproc1</code></strong>:<code>systemstack</code> 确保 <code>newproc1</code>在系统栈上执行，而不是当前 <code>goroutine</code> 的栈。这是因为新的<code>goroutine</code> 可能需要更多的栈空间。</li><li><strong>创建新的 goroutine</strong>: <code>newproc1</code>被调用来实际创建新的 <code>goroutine</code>。</li><li><strong>将新的 goroutine 放入运行队列</strong>: <code>runqput</code>将新创建的 <code>goroutine</code> 放入运行队列。</li><li><strong>唤醒处理器</strong>:如果主函数已经开始执行，<code>wakep</code> 用于唤醒一个空闲的 P来运行新的 <code>goroutine</code>。</li></ol><h3 id="newproc1">3.2 newproc1()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">(fn *funcval, callergp *g, callerpc <span class="hljs-type">uintptr</span>)</span></span> *g &#123;<br>    <span class="hljs-comment">// ... (省略了错误检查和获取 M 的代码)</span><br><br>  <span class="hljs-comment">// 尝试从 P 的空闲列表获取一个 G，如果没有则创建一个新的</span><br>    newg := gfget(pp)<br>    <span class="hljs-keyword">if</span> newg == <span class="hljs-literal">nil</span> &#123;<br>        newg = malg(stackMin)<br>        casgstatus(newg, _Gidle, _Gdead)<br>        allgadd(newg)<br>    &#125;<br><br>    <span class="hljs-comment">// 设置新 G 的栈</span><br>    totalSize := <span class="hljs-type">uintptr</span>(<span class="hljs-number">4</span>*goarch.PtrSize + sys.MinFrameSize)<br>    totalSize = alignUp(totalSize, sys.StackAlign)<br>    sp := newg.stack.hi - totalSize<br>  spArg := sp<br>  <br>    <span class="hljs-comment">// 清空并设置新 G 的调度器相关字段</span><br>    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))<br>    newg.sched.sp = sp<br>    newg.stktopsp = sp<br>    newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum<br>    newg.sched.g = guintptr(unsafe.Pointer(newg))<br>  <br>    <span class="hljs-comment">// 设置新 G 的其他字段</span><br>    gostartcallfn(&amp;newg.sched, fn)<br>    newg.parentGoid = callergp.goid<br>    newg.gopc = callerpc<br>    newg.startpc = fn.fn<br>    <br>  <span class="hljs-comment">// ... (省略了跟踪和调试相关的代码)</span><br><br>    casgstatus(newg, _Gdead, _Grunnable)<br><br>    <span class="hljs-keyword">return</span> newg<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>创建或获取一个新的 goroutine</strong>: <code>gfget</code>尝试从 P 的空闲列表中获取一个<code>goroutine</code>，如果没有可用的，则通过 <code>malg</code>分配一个新的。</li><li><strong>初始化 goroutine 的栈和调度器</strong>: 设置新<code>goroutine</code>的栈、程序计数器、调用函数等。这里有个非常核心的点<code>newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum</code>，我们前面留了个疑问，协程栈顶的<code>goexit</code> 是哪里来的，就是这里来的。这里设置新<code>goroutine</code> 的程序计数器（<code>pc</code>）指向<code>goexit</code> 函数。<code>goexit</code> 是每个<code>goroutine</code> 在退出时必须调用的函数，用于执行清理工作并切换到g0 栈。</li><li><strong>设置父 goroutine ID 和创建点</strong>: 记录创建这个新<code>goroutine</code> 的父 <code>goroutine</code> 的 ID 和<code>go</code> 语句的位置。</li><li><strong>更改 goroutine 状态</strong>: 将新 <code>goroutine</code>的状态从 <code>_Gdead</code> 改为<code>_Grunnable</code>，使其准备好被调度。</li><li><strong>返回新的 goroutine</strong>: 函数返回新创建的<code>goroutine</code>。</li></ol><h3 id="runqput">3.3 runqput()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runqput tries to put g on the local runnable queue.</span><br><span class="hljs-comment">// If next is false, runqput adds g to the tail of the runnable queue.</span><br><span class="hljs-comment">// If next is true, runqput puts g in the pp.runnext slot.</span><br><span class="hljs-comment">// If the run queue is full, runnext puts g on the global queue.</span><br><span class="hljs-comment">// Executed only by the owner P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqput</span><span class="hljs-params">(pp *p, gp *g, next <span class="hljs-type">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrandn(<span class="hljs-number">2</span>) == <span class="hljs-number">0</span> &#123;<br>next = <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">if</span> next &#123;<br>retryNext:<br>oldnext := pp.runnext<br><span class="hljs-keyword">if</span> !pp.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;<br><span class="hljs-keyword">goto</span> retryNext<br>&#125;<br><span class="hljs-keyword">if</span> oldnext == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>gp = oldnext.ptr()<br>&#125;<br><br>retry:<br>h := atomic.LoadAcq(&amp;pp.runqhead) <br>t := pp.runqtail<br><span class="hljs-keyword">if</span> t-h &lt; <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)) &#123;<br>pp.runq[t%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].set(gp)<br>atomic.StoreRel(&amp;pp.runqtail, t+<span class="hljs-number">1</span>) <br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> runqputslow(pp, gp, h, t) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">goto</span> retry<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>随机调度器</strong>：如果启用了调度器的随机化（<code>randomizeScheduler</code>），并且<code>next</code> 为 <code>true</code>（newproc 调用的时候永远都是传的true），则有一半的概率将 <code>next</code> 设置为<code>false</code>。这有助于防止调度器的行为过于可预测。</li><li><strong>处理 <code>runnext</code> 槽</strong>：如果<code>next</code> 为 <code>true</code>，函数尝试将 <code>gp</code> 放入<code>pp.runnext</code> 槽。如果该槽已被占用，则将原有的<code>goroutine</code> 移动到常规运行队列，并重试将新的 <code>gp</code>放入 <code>runnext</code>。</li><li><strong>放入本地运行队列</strong>：如果 <code>next</code> 为<code>false</code> 或 <code>runnext</code> 槽已满，函数尝试将<code>gp</code> 放入本地运行队列的尾部。如果队列未满，<code>gp</code>将被成功添加。</li><li><strong>处理队列满的情况</strong>：如果本地运行队列已满，<code>runqputslow</code>被调用，尝试将 <code>gp</code> 连同自己队列中一半的 g放入全局运行队列。如果这也失败了，函数会重试将 <code>gp</code>放入本地队列。</li><li><strong>原子操作</strong>：函数使用原子操作来加载和存储队列头（<code>runqhead</code>）和尾（<code>runqtail</code>）指针，以确保多线程环境下的数据一致性和线程安全。</li></ol><h3 id="runqputslow">3.4 runqputslow()</h3><p><code>runqputslow</code> 函数处理本地运行队列满的情况，将<code>goroutine</code>批量转移到全局队列。这个函数通过原子操作和锁来确保操作的原子性和线程安全。随机化调度器的使用增加了调度的随机性和公平性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Put g and a batch of work from local runnable queue on global queue.</span><br><span class="hljs-comment">// Executed only by the owner P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqputslow</span><span class="hljs-params">(pp *p, gp *g, h, t <span class="hljs-type">uint32</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><br>  <span class="hljs-comment">// 从 pp 的本地队列中获取一半的 goroutine</span><br>  <span class="hljs-keyword">var</span> batch [<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]*g<br>n := t - h<br>n = n / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> n != <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span>) &#123;<br>throw(<span class="hljs-string">&quot;runqputslow: queue is not full&quot;</span>)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i] = pp.runq[(h+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br>&#125;<br><span class="hljs-keyword">if</span> !atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>batch[n] = gp<br><br>  <span class="hljs-comment">// 随机打乱 goroutine 的顺序，以增加调度的随机性</span><br><span class="hljs-keyword">if</span> randomizeScheduler &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">1</span>); i &lt;= n; i++ &#123;<br>j := fastrandn(i + <span class="hljs-number">1</span>)<br>batch[i], batch[j] = batch[j], batch[i]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 串成队列</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i].schedlink.set(batch[i+<span class="hljs-number">1</span>])<br>&#125;<br><span class="hljs-keyword">var</span> q gQueue<br>q.head.set(batch[<span class="hljs-number">0</span>])<br>q.tail.set(batch[n])<br><br><span class="hljs-comment">// 放入全局队列中</span><br>lock(&amp;sched.lock)<br>globrunqputbatch(&amp;q, <span class="hljs-type">int32</span>(n+<span class="hljs-number">1</span>))<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>创建批处理数组</strong>：函数首先创建一个 <code>batch</code>数组，用于存储从本地队列中取出的 <code>goroutine</code>。</li><li><strong>从本地队列中获取一批<code>goroutine</code></strong>：函数计算出要从本地队列中取出多少个<code>goroutine</code>（通常是队列长度的一半），并将它们添加到<code>batch</code> 数组中。</li><li><strong>原子操作更新队列头部</strong>：使用原子操作<code>atomic.CasRel</code>更新本地运行队列的头部索引，这是一个释放（release）操作，确保之前的读取操作完成。</li><li><strong>将当前 <code>goroutine</code>添加到批处理中</strong>：将传入的 <code>gp</code> 添加到<code>batch</code> 数组的末尾。</li><li><strong>随机化调度器</strong>：如果启用了随机调度器，函数会随机打乱<code>batch</code> 数组中的 <code>goroutine</code>顺序，以增加调度的随机性。</li><li><strong>链接 <code>goroutine</code></strong>：将 <code>batch</code>数组中的 <code>goroutine</code> 链接起来，形成一个队列。</li><li><strong>准备全局队列</strong>：创建一个 <code>gQueue</code>结构，并设置其头部和尾部指向 <code>batch</code> 数组中的第一个和最后一个<code>goroutine</code>。</li><li><strong>将批处理放入全局队列</strong>：加锁访问全局调度器的锁，然后将整个<code>batch</code> 队列放入全局运行队列。</li></ol><h2 id="调度过程-schedule">4. 调度过程 schedule()</h2><p>Go 的调度器核心执行逻辑都在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a>的 <code>schedule()</code>函数中。我们先不探讨过多的细节，我们先把整个大体脉络理清楚再说。</p><p>简化后的 <code>schedule()</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 获取当前正在执行的 M</span><br>mp := getg().m<br>  ...<br>  <span class="hljs-comment">// 查找一个可运行的 G，会阻塞住直到返回。</span><br>gp, inheritTime, tryWakeP := findRunnable() <br>  ...<br><span class="hljs-comment">// 执行 g</span><br>execute(gp, inheritTime)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>execute()</code> 执行 g，它简化后如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">execute</span><span class="hljs-params">(gp *g, inheritTime <span class="hljs-type">bool</span>)</span></span> &#123;<br>mp := getg().m<br>..<br>gogo(&amp;gp.sched)<br>&#125;<br></code></pre></td></tr></table></figure><p>它调用了 <code>gogo()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gogo</span><span class="hljs-params">(buf *gobuf)</span></span><br></code></pre></td></tr></table></figure><p>一般这种格式说明函数是用汇编实现的，我们在 Goland 上可以双击 shift然后搜索 <code>runtime·gogo</code>：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240128130637007.png"alt="runtime·gogo" /><figcaption aria-hidden="true">runtime·gogo</figcaption></figure><p>不同的平台有不同的实现，但是核心逻辑都是一样的，它直接操作处理器的寄存器和栈，以实现从一个 <code>goroutine</code>切换到另一个 <code>goroutine</code> 的功能。</p><p>我们后面的发内心会发现 <code>goexit()</code> 最终会调用<code>schedule()</code>。</p><p>这就串起来了，Go 程序启动后会创建 m0 和g0，所以第一个<code>schedule()</code> 是 g0 调用的，最后通过<code>gogo</code> 切换到用户协程 g 上面执行业务方法，完事后 g 通过<code>goexit</code> 回到 <code>schedule()</code>，以此循环反复下去。</p><p>现在我们可以来总结一下 GPM 调度循环的过程，大概如下图表示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57qxoptk4j21hm0simyy.jpg"alt="GPM 调度循环图" /><figcaption aria-hidden="true">GPM 调度循环图</figcaption></figure><p>下面我们再对这个过程中的关键函数进行细致分析：</p><ul><li><code>schedule()</code>：调度入口。</li><li><code>findRunnable()</code>：寻找可执行的 G。</li><li><code>execute()</code>：执行 G。</li><li><code>gogo()</code>：切换协程栈 g0 到 g。</li><li><code>goexit()</code>：退出 g 协程，切换回 g0 栈。</li></ul><h3 id="schedule">4.1 schedule()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 获取当前正在执行的 M</span><br>mp := getg().m<br><br>  <span class="hljs-comment">// 有锁的话抛出异常，避免该情况下调度出现死锁或其他问题</span><br><span class="hljs-keyword">if</span> mp.locks != <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;schedule: holding locks&quot;</span>)<br>&#125;<br><br>  <span class="hljs-comment">// M 被锁定了特定的 G，这个时候直接执行这个锁定的 G。</span><br><span class="hljs-keyword">if</span> mp.lockedg != <span class="hljs-number">0</span> &#123;<br>stoplockedm()<br>execute(mp.lockedg.ptr(), <span class="hljs-literal">false</span>) <span class="hljs-comment">// Never returns.</span><br>&#125;<br><br><span class="hljs-comment">// CGO 调用需要 g0 栈，所以这个时候不继续调度了，抛出异常。</span><br><span class="hljs-keyword">if</span> mp.incgo &#123;<br>throw(<span class="hljs-string">&quot;schedule: in cgo&quot;</span>)<br>&#125;<br><br>top:<br>pp := mp.p.ptr()<br>pp.preempt = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// 安全点检查：如果当前 M 在自旋的话，应该是没有可执行 G 的。</span><br><span class="hljs-keyword">if</span> mp.spinning &amp;&amp; (pp.runnext != <span class="hljs-number">0</span> || pp.runqhead != pp.runqtail) &#123;<br>throw(<span class="hljs-string">&quot;schedule: spinning with local work&quot;</span>)<br>&#125;<br><br>  <span class="hljs-comment">// 查找一个可运行的 G，会阻塞住直到返回。</span><br>gp, inheritTime, tryWakeP := findRunnable() <br><br>  <span class="hljs-comment">// 调试的时候系统会处于“冻结”状态，</span><br>  <span class="hljs-comment">// 这里故意通过两次 lock 引入死锁使当前 M 陷入无限等待，</span><br>  <span class="hljs-comment">// 以在调试时保持当前的调度器和运行时状态不变。</span><br><span class="hljs-keyword">if</span> debug.dontfreezetheworld &gt; <span class="hljs-number">0</span> &amp;&amp; freezing.Load() &#123;<br>lock(&amp;deadlock)<br>lock(&amp;deadlock)<br>&#125;<br><br>  <span class="hljs-comment">// 如果当前 M 之前是自旋的，但是现在要准备执行 G 了，那就不是自旋了。</span><br><span class="hljs-keyword">if</span> mp.spinning &#123;<br>resetspinning()<br>&#125;<br><br>  <span class="hljs-comment">// 当用户级调度被禁用时，采用双重检查后如果确实被禁用了，</span><br>  <span class="hljs-comment">// 那么就把当前 g 放在 sched.disable.runnable 列表中，</span><br>  <span class="hljs-comment">// 等待调度重启启用时再处理。</span><br>  <span class="hljs-comment">// 在 gc 的时候会出现这种情况：</span><br>  <span class="hljs-comment">// gcStart()    -&gt;  schedEnableUser(false)</span><br>  <span class="hljs-comment">// gcMarkDone() -&gt;  schedEnableUser(true)</span><br><span class="hljs-keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;<br>lock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> schedEnabled(gp) &#123;<br>unlock(&amp;sched.lock)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>sched.disable.runnable.pushBack(gp)<br>sched.disable.n++<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">goto</span> top<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 检查是否需要唤醒一个 P。</span><br>  <span class="hljs-comment">// 如果返回的 g 比较特殊，比如要负责 gc，那么这个值会是 true。</span><br><span class="hljs-keyword">if</span> tryWakeP &#123;<br>wakep()<br>&#125;<br>  <br>  <span class="hljs-comment">// 如果 g 已经绑定了 M，则直接启动该 M 去执行 g。</span><br><span class="hljs-keyword">if</span> gp.lockedm != <span class="hljs-number">0</span> &#123;<br>startlockedm(gp)<br><span class="hljs-keyword">goto</span> top<br>&#125;<br><br>  <span class="hljs-comment">// 执行 g</span><br>execute(gp, inheritTime)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>schedule()</code> 函数是 Go 调度器的核心，负责管理<code>goroutine</code> 的执行。它包括多个步骤，如检查当前 M的状态，处理特殊情况（如 <code>goroutine</code> 被锁定到特定的 M，或者 M正在执行 CGO 调用），以及选择和执行可运行的 <code>goroutine</code>。</p><h3 id="findrunnable">4.2 findRunnable()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Finds a runnable goroutine to execute.</span><br><span class="hljs-comment">// Tries to steal from other P&#x27;s, get g from local or global queue, poll network.</span><br><span class="hljs-comment">// tryWakeP indicates that the returned goroutine is not normal (GC worker, trace reader) so the caller should try to wake a P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRunnable</span><span class="hljs-params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="hljs-type">bool</span>) &#123;<br></code></pre></td></tr></table></figure><p>通过注释就可以知道这个函数的作用：寻找一个可执行的 goroutine：</p><ol type="1"><li>尝试从其他 P 窃取 g、从本地获取 g、从全局队列获取g、从网络轮询器获取 g；</li><li>如果是一个特殊的 g，如要负责 gc 或 trace，那么会将<code>tryWakeP</code> 置为<code>true</code>，表示调度器需要尝试唤醒或启动一个新的 P 来运行这个g，以确保了即使在系统负载较低时，这些特殊的g 也能得到及时处理。</li></ol><p>我们只关心它的核心部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRunnable</span><span class="hljs-params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="hljs-type">bool</span>) &#123;<br>  <span class="hljs-comment">// 获取当前 M</span><br>mp := getg().m<br>top:<br>  <br>  <span class="hljs-comment">// 获取 M 绑定的 P</span><br>pp := mp.p.ptr()<br><br><span class="hljs-comment">// 1. 每 61 次循环调度，就会去全局队列中获取一个 g 来执行</span><br><span class="hljs-keyword">if</span> pp.schedtick%<span class="hljs-number">61</span> == <span class="hljs-number">0</span> &amp;&amp; sched.runqsize &gt; <span class="hljs-number">0</span> &#123;<br>lock(&amp;sched.lock)<br>gp := globrunqget(pp, <span class="hljs-number">1</span>)<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">// 2. 从本地队列中获取 g</span><br><span class="hljs-keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, inheritTime, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 3. 从全局队列中获取 g</span><br><span class="hljs-keyword">if</span> sched.runqsize != <span class="hljs-number">0</span> &#123;<br>lock(&amp;sched.lock)<br>gp := globrunqget(pp, <span class="hljs-number">0</span>)<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 4. 从网络轮询器中获取 g</span><br><span class="hljs-keyword">if</span> netpollinited() &amp;&amp; netpollWaiters.Load() &gt; <span class="hljs-number">0</span> &amp;&amp; sched.lastpoll.Load() != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> list := netpoll(<span class="hljs-number">0</span>); !list.empty() &#123; <span class="hljs-comment">// non-blocking</span><br>gp := list.pop()<br>injectglist(&amp;list)<br>casgstatus(gp, _Gwaiting, _Grunnable)<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoUnpark(gp, <span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 5. 自旋，从其他 P 窃取 g</span><br>  <span class="hljs-comment">// mp.spinning 这个条件检查当前 M（操作系统线程）是否应该进入自旋状态。</span><br>  <span class="hljs-comment">// 自旋状态意味着 M 会积极地寻找工作，而不是休眠。</span><br>  <span class="hljs-comment">// 2*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load()</span><br>  <span class="hljs-comment">// 这个条件确保系统中自旋的 M 的数量不会超过一定比例。</span><br>  <span class="hljs-comment">// 这是为了防止在低并发情况下过多的 CPU 使用。</span><br><span class="hljs-keyword">if</span> mp.spinning || <span class="hljs-number">2</span>*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load() &#123;<br><span class="hljs-keyword">if</span> !mp.spinning &#123;<br>mp.becomeSpinning()<br>&#125;<br> <br>gp, inheritTime, tnow, w, newWork := stealWork(now)<br><span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, inheritTime, <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> newWork &#123;<br><span class="hljs-keyword">goto</span> top<br>&#125;<br><br>now = tnow<br><span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; (pollUntil == <span class="hljs-number">0</span> || w &lt; pollUntil) &#123;<br>pollUntil = w<br>&#125;<br>&#125;<br>  ...<br><span class="hljs-keyword">goto</span> top<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个过程涉及到几个重要的函数：</p><ul><li><code>globrunqget()</code>：从全局队列中寻找可运行的 G。</li><li><code>runqget()</code>：从本地队列中寻找可运行的 G。</li><li><code>netpoll()</code>：寻找可以运行的网络协程。</li><li><code>stealWork()</code>：从其他 P 窃取可运行的 G。</li></ul><h3 id="globrunqget">4.3 globrunqget()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">globrunqget</span><span class="hljs-params">(pp *p, max <span class="hljs-type">int32</span>)</span></span> *g &#123;<br>  <span class="hljs-comment">// 抢全局列表的锁</span><br>    assertLockHeld(&amp;sched.lock)<br><br>  <span class="hljs-comment">// 如果为空则直接返回</span><br>    <span class="hljs-keyword">if</span> sched.runqsize == <span class="hljs-number">0</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>  <span class="hljs-comment">// 确定 n 的大小，即要从全局队列中获取的 g 的个数。</span><br>  <span class="hljs-comment">// 这里会结合入参 max 对边界值进行判断，以获得一个合理的 n。</span><br>  <span class="hljs-comment">// 一次性最多拿 len(pp.runq)/2 个 g。</span><br>    n := sched.runqsize/gomaxprocs + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> n &gt; sched.runqsize &#123;<br>       n = sched.runqsize<br>    &#125;<br>    <span class="hljs-keyword">if</span> max &gt; <span class="hljs-number">0</span> &amp;&amp; n &gt; max &#123;<br>       n = max<br>    &#125;<br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(pp.runq))/<span class="hljs-number">2</span> &#123;<br>       n = <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(pp.runq)) / <span class="hljs-number">2</span><br>    &#125;<br><br>    sched.runqsize -= n<br><br>  <span class="hljs-comment">// 通过 pop() 从全局队列中弹出 g</span><br>    gp := sched.runq.pop()<br>    n--<br>    <span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- &#123;<br>       gp1 := sched.runq.pop()<br>       <span class="hljs-comment">// 将 g 放入 pp 的本地队列中</span><br>       <span class="hljs-comment">// runqput 在前面创建协程的地方已经介绍过了，这里不赘述。</span><br>       runqput(pp, gp1, <span class="hljs-literal">false</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> gp<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runqget">4.4 runqget()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqget</span><span class="hljs-params">(pp *p)</span></span> (gp *g, inheritTime <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-comment">// runnext 的 g 会优先执行</span><br>next := pp.runnext<br><span class="hljs-keyword">if</span> next != <span class="hljs-number">0</span> &amp;&amp; pp.runnext.cas(next, <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> next.ptr(), <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 原子操作获取队头指针</span><br>h := atomic.LoadAcq(&amp;pp.runqhead) <br>t := pp.runqtail<br><span class="hljs-keyword">if</span> t == h &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br>    <span class="hljs-comment">// 从队头获取 g，并通过原子操作更新队头（即抢这个 g）</span><br>gp := pp.runq[h%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br><span class="hljs-keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+<span class="hljs-number">1</span>) &#123; <br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runqget()</code> 函数用于从本地运行队列中获取一个可运行的<code>goroutine</code>。这个函数只能由拥有该队列的处理器（P）执行。下面是对这个函数的详细解释：</p><p><strong>1. 检查 <code>runnext</code></strong>：</p><ul><li><code>runnext</code> 是一个特殊的字段，用于存储下一个要运行的<code>goroutine</code>。如果 <code>runnext</code>非零，并且能成功通过原子操作（CAS）将其设置为零，则直接返回这个<code>goroutine</code>。</li><li>如果成功获取 <code>runnext</code> 指向的<code>goroutine</code>，<code>inheritTime</code> 被设置为<code>true</code>，表示这个 <code>goroutine</code>应该继承当前时间片的剩余时间。</li><li>如果没成功，意味着 runnext 的这个 g 已经被其他 P给抢了，因为我们可以发现本 P 只可能将其设置为 0，只有其他 P才会将其设置以为非 0。</li></ul><p><strong>2. 从本地队列中获取 <code>goroutine</code></strong>：</p><ul><li>使用原子操作加载<code>runqhead</code>（队列头指针），<code>runqtail</code>（队列尾指针）。</li><li>如果 <code>runqhead</code> 等于<code>runqtail</code>，表示队列为空，返回 <code>nil</code>。</li><li>否则，从队列中获取 <code>runqhead</code> 指向的<code>goroutine</code>，并尝试通过原子操作（CAS）更新<code>runqhead</code>。</li><li>如果更新成功，返回获取到的<code>goroutine</code>，<code>inheritTime</code> 被设置为<code>false</code>，表示这个 <code>goroutine</code>应该开始一个新的时间片。</li></ul><p>两个问题：</p><p><strong>1. 为什么获取 runqhead 需要上锁，获取 runqtail就不需要？</strong></p><p><strong>单一生产者</strong>：每个本地运行队列只有一个生产者，即与之关联的当前P。只有这个 P 可以向队列尾部添加新的<code>goroutine</code>。由于不存在多个生产者的并发写入问题，因此不需要锁来保护队尾。</p><p><strong>2. inheritTime 有什么用？</strong></p><p><code>inheritTime</code> 的主要作用是决定新调度的<code>goroutine</code>是否应该立即开始一个新的时间片，或者继续使用当前时间片的剩余部分。这在以下两种情况下尤为重要：</p><ul><li><strong>继承时间片</strong> (<code>inheritTime == true</code>)：当<code>runqget</code> 从 <code>runnext</code> 字段获取<code>goroutine</code> 时，这个 <code>goroutine</code>被认为是特别优先的，因此它继承了当前时间片的剩余时间。这通常发生在<code>goroutine</code>通过特定的同步机制（如通道操作）被明确唤醒时。</li><li><strong>开始新的时间片</strong>(<code>inheritTime == false</code>)：当 <code>runqget</code>从本地运行队列中正常获取 <code>goroutine</code> 时，这个<code>goroutine</code>将开始一个全新的时间片。这确保了调度的公平性，使得每个<code>goroutine</code> 都有机会在给定的时间片内运行。</li></ul><h3 id="netpoll">4.5 netpoll()</h3><p><code>netpoll()</code> 函数是 Go语言运行时网络轮询机制的一部分，用于检查网络连接是否准备好进行非阻塞 I/O操作。这个函数返回一组已经变为可运行状态的 <code>goroutine</code>，这些<code>goroutine</code> 之前可能因等待网络 I/O 而被挂起。</p><p>这里涉及到 Go 语言网络编程原理，在本文中不细究，就简单带过了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">netpoll</span><span class="hljs-params">(delay <span class="hljs-type">int64</span>)</span></span> gList &#123;<br>  <span class="hljs-comment">// 检查轮询器是否初始化。</span><br><span class="hljs-keyword">if</span> kq == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> gList&#123;&#125;<br>&#125;<br>  <span class="hljs-comment">// 设置轮询超时。</span><br><span class="hljs-keyword">var</span> tp *timespec<br><span class="hljs-keyword">var</span> ts timespec<br><span class="hljs-keyword">if</span> delay &lt; <span class="hljs-number">0</span> &#123;<br>tp = <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> delay == <span class="hljs-number">0</span> &#123;<br>tp = &amp;ts<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ts.setNsec(delay)<br><span class="hljs-keyword">if</span> ts.tv_sec &gt; <span class="hljs-number">1e6</span> &#123;<br>ts.tv_sec = <span class="hljs-number">1e6</span><br>&#125;<br>tp = &amp;ts<br>&#125;<br>  <span class="hljs-comment">// 使用 kevent 进行轮询操作，结果放在 events 中。</span><br><span class="hljs-keyword">var</span> events [<span class="hljs-number">64</span>]keventt<br>retry:<br>n := kevent(kq, <span class="hljs-literal">nil</span>, <span class="hljs-number">0</span>, &amp;events[<span class="hljs-number">0</span>], <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(events)), tp)<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> n != -_EINTR &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;runtime: kevent on fd&quot;</span>, kq, <span class="hljs-string">&quot;failed with&quot;</span>, -n)<br>throw(<span class="hljs-string">&quot;runtime: netpoll failed&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> delay &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> gList&#123;&#125;<br>&#125;<br><span class="hljs-keyword">goto</span> retry<br>&#125;<br>  <span class="hljs-comment">// 遍历 events 处理轮询事件。</span><br><span class="hljs-keyword">var</span> toRun gList<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">int</span>(n); i++ &#123;<br>ev := &amp;events[i]<br><br>    <span class="hljs-comment">// netpollBreakRd 用于唤醒轮询，即唤醒等待中的 goroutine。</span><br><span class="hljs-keyword">if</span> <span class="hljs-type">uintptr</span>(ev.ident) == netpollBreakRd &#123;<br><span class="hljs-keyword">if</span> ev.filter != _EVFILT_READ &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;runtime: netpoll: break fd ready for&quot;</span>, ev.filter)<br>throw(<span class="hljs-string">&quot;runtime: netpoll: break fd ready for something unexpected&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> delay != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> tmp [<span class="hljs-number">16</span>]<span class="hljs-type">byte</span><br>read(<span class="hljs-type">int32</span>(netpollBreakRd), noescape(unsafe.Pointer(&amp;tmp[<span class="hljs-number">0</span>])), <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(tmp)))<br>netpollWakeSig.Store(<span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>    <span class="hljs-comment">// 根据轮询事件的类型（读或写），唤醒相应等待网络 I/O 的 groutine。</span><br><span class="hljs-keyword">var</span> mode <span class="hljs-type">int32</span><br><span class="hljs-keyword">switch</span> ev.filter &#123;<br><span class="hljs-keyword">case</span> _EVFILT_READ:<br>mode += <span class="hljs-string">&#x27;r&#x27;</span><br><span class="hljs-keyword">if</span> ev.flags&amp;_EV_EOF != <span class="hljs-number">0</span> &#123;<br>mode += <span class="hljs-string">&#x27;w&#x27;</span><br>&#125;<br><span class="hljs-keyword">case</span> _EVFILT_WRITE:<br>mode += <span class="hljs-string">&#x27;w&#x27;</span><br>&#125;<br><span class="hljs-keyword">if</span> mode != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> pd *pollDesc<br><span class="hljs-keyword">var</span> tag <span class="hljs-type">uintptr</span><br><span class="hljs-keyword">if</span> goarch.PtrSize == <span class="hljs-number">4</span> &#123;<br>pd = (*pollDesc)(unsafe.Pointer(ev.udata))<br>tag = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tp := taggedPointer(<span class="hljs-type">uintptr</span>(unsafe.Pointer(ev.udata)))<br>pd = (*pollDesc)(tp.pointer())<br>tag = tp.tag()<br><span class="hljs-keyword">if</span> pd.fdseq.Load() != tag &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>pd.setEventErr(ev.flags == _EV_ERROR, tag)<br>      <span class="hljs-comment">// 标记 goroutine 可执行。</span><br>netpollready(&amp;toRun, pd, mode)<br>&#125;<br>&#125;<br>  <br>  <span class="hljs-comment">// 返回可运行的 goroutine 列表。</span><br><span class="hljs-keyword">return</span> toRun<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stealwork">4.6 stealWork()</h3><p><code>stealWork()</code> 函数用于尝试从其他处理器（P）窃取可运行的<code>goroutine</code> 或定时器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stealWork</span><span class="hljs-params">(now <span class="hljs-type">int64</span>)</span></span> (gp *g, inheritTime <span class="hljs-type">bool</span>, rnow, pollUntil <span class="hljs-type">int64</span>, newWork <span class="hljs-type">bool</span>) &#123;<br>  <br>  <span class="hljs-comment">// 获取当前 M 绑定的 P。</span><br>pp := getg().m.p.ptr()<br><br>ranTimer := <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment">// 尝试 4 次。</span><br><span class="hljs-keyword">const</span> stealTries = <span class="hljs-number">4</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; stealTries; i++ &#123;<br>    <span class="hljs-comment">// 前 3 次尝试窃取 g。</span><br>    <span class="hljs-comment">// 第 4 次尝试窃取 timer，并且尝试获取其他 P 的 runnext 中的 g。</span><br>stealTimersOrRunNextG := i == stealTries<span class="hljs-number">-1</span><br><br>    <span class="hljs-comment">// 随机选一个 P。</span><br><span class="hljs-keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;<br><span class="hljs-comment">// 如果系统正在 GC，则可以直接返回 true，因为可能要负责 gc 了，有事干了。</span><br>      <span class="hljs-keyword">if</span> sched.gcwaiting.Load() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>, now, pollUntil, <span class="hljs-literal">true</span><br>&#125;<br>      <br>      <span class="hljs-comment">// 获取选中的 P，如果是当前 P 则直接 continue，重试。</span><br>p2 := allp[enum.position()]<br><span class="hljs-keyword">if</span> pp == p2 &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>      <span class="hljs-comment">// 第 4 次尝试去窃取 p2 的 timer。</span><br><span class="hljs-keyword">if</span> stealTimersOrRunNextG &amp;&amp; timerpMask.read(enum.position()) &#123;<br>        <span class="hljs-comment">// 检查并可能执行 timer。</span><br>tnow, w, ran := checkTimers(p2, now)<br>now = tnow<br><span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; (pollUntil == <span class="hljs-number">0</span> || w &lt; pollUntil) &#123;<br>pollUntil = w<br>&#125;<br>        <span class="hljs-comment">// 如果执行了 timer，则检查本地队列是否有 g 可以运行，</span><br>        <span class="hljs-comment">// 因为 timer 会唤醒被挂起的 g。</span><br><span class="hljs-keyword">if</span> ran &#123;<br><span class="hljs-keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, inheritTime, now, pollUntil, ranTimer<br>&#125;<br>ranTimer = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br>      <span class="hljs-comment">// 前 3 次尝试或者第 4 次尝试没有窃取到 timer 的时候，</span><br>      <span class="hljs-comment">// 就从其他非空闲 P 的本地队列中尝试窃取 g。</span><br><span class="hljs-keyword">if</span> !idlepMask.read(enum.position()) &#123;<br>        <span class="hljs-comment">// 如果 stealTimersOrRunNextG 为 true，</span><br>        <span class="hljs-comment">// 那么会在窃取的时候，尝试窃取 p2 的 runnext。</span><br><span class="hljs-keyword">if</span> gp := runqsteal(pp, p2, stealTimersOrRunNextG); gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, now, pollUntil, ranTimer<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>, now, pollUntil, ranTimer<br>&#125;<br></code></pre></td></tr></table></figure><p>阅读源码的好处这就体现了，所有人都告诉我们 P 找不到可运行 G的时候就会去窃取其他 P 的G，但没人告诉我们，在这个过程<strong>还可能会去窃取其他 P 的 timer 和runnext</strong>。</p><p>所谓<code>timer</code>，即定时器，用于在指定的时间后执行某些操作。这些操作通常包括唤醒等待特定时间的<code>goroutine</code>，或执行与时间相关的任务。定时器在 Go的并发模型中扮演着重要的角色，特别是在涉及到时间延迟或周期性任务的场景中。在调度器层面，定时器的管理对于确保及时响应时间相关的事件和维持高效的调度至关重要。通过合理地处理定时器事件，Go能够在保持高并发性的同时，有效地管理时间延迟和周期性任务。</p><p>在 Go 语言的调度器中，跨 P 的定时器窃取是一种优化机制，它有 2个好处：</p><ul><li><strong>保持处理器活跃</strong>：当一个 P没有足够的本地工作时，它可以尝试从其他 P窃取定时器任务。这样做可以保持该 P活跃，避免它进入休眠状态，从而提高整体系统的效率。</li><li><strong>平衡系统负载</strong>：在多核系统中，不同的 P可能会有不同的负载。跨 P 的定时器窃取有助于在 P之间平衡负载，特别是在一些 P 非常忙碌而其他 P 相对空闲的情况下。</li></ul><p>好的，回过头来，为什么我们会说窃取的时候会从队头窃取呢？为什么是窃取p2 一半的 g 呢？这个过程就在 <code>runqsteal()</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqsteal</span><span class="hljs-params">(pp, p2 *p, stealRunNextG <span class="hljs-type">bool</span>)</span></span> *g &#123;<br>t := pp.runqtail<br>  <br>  <span class="hljs-comment">// 从 p2 中获取 n 个 g。</span><br>n := runqgrab(p2, &amp;pp.runq, t, stealRunNextG)<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>  <br>  <span class="hljs-comment">// 返回第 1 个 g，因为它可以直接执行了。</span><br>n--<br>gp := pp.runq[(t+n)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> gp<br>&#125;<br>  <span class="hljs-comment">// 如果还有剩下的 g，那么就加入到本地队列中。</span><br>  <span class="hljs-comment">// 这里可以看到是从队头加入的，所以需要使用原子操作获取队头。</span><br>h := atomic.LoadAcq(&amp;pp.runqhead)<br><span class="hljs-keyword">if</span> t-h+n &gt;= <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)) &#123;<br>throw(<span class="hljs-string">&quot;runqsteal: runq overflow&quot;</span>)<br>&#125;<br>atomic.StoreRel(&amp;pp.runqtail, t+n)<br><span class="hljs-keyword">return</span> gp<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runqgrab()</code> 是窃取 n 个 g 的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqgrab</span><span class="hljs-params">(pp *p, batch *[256]guintptr, batchHead <span class="hljs-type">uint32</span>, stealRunNextG <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">uint32</span> &#123;<br>  <span class="hljs-comment">// 使用无限循环来尝试窃取工作，直到成功或确定没有可窃取的工作。</span><br><span class="hljs-keyword">for</span> &#123;<br>h := atomic.LoadAcq(&amp;pp.runqhead) <br>t := atomic.LoadAcq(&amp;pp.runqtail) <br>n := t - h<br>    <br>    <span class="hljs-comment">// 这里可以看到，要窃取的个数，就是 pp 本地队列中 g 个数的一半</span><br>n = n - n/<span class="hljs-number">2</span><br>    <br>    <span class="hljs-comment">// 如果 n 为 0，且 stealRunNextG == true，</span><br>    <span class="hljs-comment">// 那么就尝试窃取 pp 的 runnext 中的 g。</span><br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> stealRunNextG &#123;<br><span class="hljs-keyword">if</span> next := pp.runnext; next != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> !pp.runnext.cas(next, <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>batch[batchHead%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(batch))] = next<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>    <br>    <span class="hljs-comment">// 如果 n 不为队列长度的一半，则说明队列发生了变化，</span><br>    <span class="hljs-comment">// 这个时候重新尝试窃取。</span><br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span>) &#123; <br><span class="hljs-keyword">continue</span><br>&#125;<br>    <span class="hljs-comment">// 将要窃取的 g 从 pp.runq 中转移到 batch 中。</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>g := pp.runq[(h+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))]<br>batch[(batchHead+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(batch))] = g<br>&#125;<br>    <span class="hljs-comment">// 使用原子操作尝试更新 pp 的队列头部，即将 g 从 pp.runq 中移除。</span><br><span class="hljs-keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123; <br><span class="hljs-keyword">return</span> n<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>findRunnable()</code>的全部过程我们总算是梳理完了，这个过程确实非常精彩，Go调度器在提高调度性能、确保调度的公平性、平衡系统负载、降低同步开销、减少资源再分配等方面都做了很多的努力，这才让Go 语言的并发又强大又易用。</p><p>下面是对 <code>findRunnable()</code> 一个简单的总结：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240128212451142.png"alt="findRunnable()" /><figcaption aria-hidden="true">findRunnable()</figcaption></figure><h3 id="execute">4.7 execute()</h3><p><code>findRunnable()</code> 之后就是<code>execute()</code>，它的核心过程如下（有删减）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">execute</span><span class="hljs-params">(gp *g, inheritTime <span class="hljs-type">bool</span>)</span></span> &#123;<br>mp := getg().m<br><span class="hljs-comment">// 将 g0 d 线程信息复制到即将要调用的协程 gp 中。</span><br>mp.curg = gp<br>gp.m = mp<br>  <span class="hljs-comment">// 修改 gp 的状态为 _Grunning，即运行中。</span><br>casgstatus(gp, _Grunnable, _Grunning)<br>gp.waitsince = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 标记为非抢占</span><br>gp.preempt = <span class="hljs-literal">false</span><br>  <span class="hljs-comment">// 用于栈保护，检测栈溢出</span><br>gp.stackguard0 = gp.stack.lo + stackGuard<br>  <span class="hljs-comment">// gogo 会完成 g0 到 g 的协程栈的切换，并从 gp.sched 开始执行。</span><br>  <span class="hljs-comment">// sched 字段我们前面介绍过，它是 gobuf 结构体，存储了 sp 和 pc。</span><br>gogo(&amp;gp.sched)<br>&#125;<br></code></pre></td></tr></table></figure><p>所以 <code>execute()</code> 的工作非常简单，其实就是将 g0的线程信息复制到 gp 上，并修改状态和一些元数据，核心部分其实在<code>gogo()</code> 中。</p><h3 id="gogo">4.8 gogo()</h3><p>前面我们说过，<code>gogo()</code> 会完成 g0 栈到 g栈的切换，且在不同平台下有不同的视线，这里我们以 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/asm_arm64.s">asm_arm64.s</a>为代表来看一下 <code>gogo()</code> 的汇编实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">TEXT runtime·gogo(SB), NOSPLIT|NOFRAME, $0-8<br>MOVDbuf+0(FP), R5<br>MOVDgobuf_g(R5), R6<br>MOVD0(R6), R4// make sure g != nil<br>Bgogo&lt;&gt;(SB)<br><br>TEXT gogo&lt;&gt;(SB), NOSPLIT|NOFRAME, $0<br>MOVDR6, g<br>BLruntime·save_g(SB)<br><br>MOVDgobuf_sp(R5), R0<br>MOVDR0, RSP<br>MOVDgobuf_bp(R5), R29<br>MOVDgobuf_lr(R5), LR<br>MOVDgobuf_ret(R5), R0<br>MOVDgobuf_ctxt(R5), R26<br>MOVD$0, gobuf_sp(R5)<br>MOVD$0, gobuf_bp(R5)<br>MOVD$0, gobuf_ret(R5)<br>MOVD$0, gobuf_lr(R5)<br>MOVD$0, gobuf_ctxt(R5)<br>CMPZR, ZR // set condition codes for == test, needed by stack split<br>MOVDgobuf_pc(R5), R6<br>B(R6)<br></code></pre></td></tr></table></figure><p>具体过程如下：</p><ol type="1"><li><strong><code>runtime·gogo</code>函数</strong>：这个函数用于设置新的 <code>goroutine</code>上下文。它接收一个指向 <code>gobuf</code>结构的指针（<code>buf+0(FP)</code>），该结构包含了<code>goroutine</code> 的上下文信息。</li><li><strong>加载 <code>gobuf</code> 并检查 <code>g</code></strong>：加载<code>gobuf</code> 结构，并检查 <code>g</code> 是否为<code>nil</code>。</li><li><strong>跳转到 <code>gogo&lt;&gt;</code></strong>：执行无条件跳转到<code>gogo&lt;&gt;</code> 函数。</li><li><strong><code>gogo&lt;&gt;</code>函数</strong>：这个函数实际上完成了上下文切换。<ul><li>设置当前 <code>goroutine</code>：将 <code>R6</code>寄存器中的值（新的 <code>goroutine</code>）设置为当前<code>goroutine</code>。</li><li>保存当前 <code>goroutine</code>：调用 <code>runtime·save_g</code>保存当前 <code>goroutine</code> 的状态。</li><li>恢复栈指针和其他寄存器：从 <code>gobuf</code>结构中恢复栈指针（<code>RSP</code>）、基指针（<code>R29</code>）、链接寄存器（<code>LR</code>）、返回值（<code>R0</code>）和上下文（<code>R26</code>）。</li><li>清空 <code>gobuf</code> 结构：将 <code>gobuf</code>结构中的字段清零。</li><li>准备跳转到新的程序计数器位置：从 <code>gobuf</code>中加载新的程序计数器地址（<code>gobuf_pc(R5)</code>）到<code>R6</code>。</li><li>跳转执行：通过 <code>B (R6)</code>跳转到新的程序计数器地址，继续执行新 <code>goroutine</code>的代码。</li></ul></li></ol><p>这段汇编代码是 Go 运行时中处理 <code>goroutine</code>上下文切换的关键部分。它直接操作处理器的寄存器和栈，以实现从一个<code>goroutine</code> 切换到另一个 <code>goroutine</code> 的功能。</p><p>在 <code>execute()</code> 中是这么调用 <code>gogo()</code> 的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">gogo(&amp;gp.sched)<br></code></pre></td></tr></table></figure><p>所以完成栈的切换后会从 <code>gp.sched</code>开始，执行代码，前面我们介绍过 <code>sched</code> 是一个<code>gobuf</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;<br>sp   <span class="hljs-type">uintptr</span><br>pc   <span class="hljs-type">uintptr</span><br>g    guintptr<br>ctxt unsafe.Pointer<br>ret  <span class="hljs-type">uintptr</span><br>lr   <span class="hljs-type">uintptr</span><br>bp   <span class="hljs-type">uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以会从 pc 处开始执行业务代码，前面在 <code>newproc()</code>的时候，我们提过一行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum<br></code></pre></td></tr></table></figure><p>这行代码的作用，是在协程创建的时候插入一个 <code>goexit</code>函数的地址，因为这个时候 <code>g</code>刚创建，所以其实就是往协程栈顶插入了 <code>goexit</code> 的地址。所以当<code>g</code> 执行完业务代码后，当栈中元素不断弹出后，最终就会弹出<code>goexit</code> 的地址，然后执行 <code>goexit()</code>函数，退出当前 <code>g</code>，切换回 <code>g0</code>。</p><h3 id="goexit">4.9 goexit()</h3><p><code>goexit</code> 定义在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/stubs.go">runtime/stubs.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// goexit is the return stub at the top of every goroutine call stack.</span><br><span class="hljs-comment">// Each goroutine stack is constructed as if goexit called the</span><br><span class="hljs-comment">// goroutine&#x27;s entry point function, so that when the entry point</span><br><span class="hljs-comment">// function returns, it will return to goexit, which will call goexit1</span><br><span class="hljs-comment">// to perform the actual exit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function must never be called directly. Call goexit1 instead.</span><br><span class="hljs-comment">// gentraceback assumes that goexit terminates the stack. A direct</span><br><span class="hljs-comment">// call on the stack will cause gentraceback to stop walking the stack</span><br><span class="hljs-comment">// prematurely and if there is leftover state it may panic.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit</span><span class="hljs-params">(neverCallThisFunction)</span></span><br></code></pre></td></tr></table></figure><p>通过注释我们可以得到 2 个信息：</p><ul><li><code>goexit</code> 的位于每个 goroutine 调用栈的顶部。每个goroutine 的栈被构造得好像 <code>goexit</code> 调用了 goroutine的入口函数。这意味着当入口函数返回时，它实际上返回到<code>goexit</code>。</li><li>不要直接调用 <code>goexit</code>，应该调用<code>goexit1</code>。</li></ul><p><code>goexit1</code> 位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Finishes execution of the current goroutine.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit1</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racegoend()<br>&#125;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoEnd()<br>&#125;<br>mcall(goexit0)<br>&#125;<br></code></pre></td></tr></table></figure><p>好吧，它调用了<code>goexit0</code>，原来这才是真正的退出入口，它也位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit0</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>  <span class="hljs-comment">// 获取当前的 M 和 P</span><br>mp := getg().m<br>pp := mp.p.ptr()<br><br>  <span class="hljs-comment">// 修改 gp 的状态为 _Gdead，标志它的终止</span><br>casgstatus(gp, _Grunning, _Gdead)<br>  <span class="hljs-comment">// 标记 gc 的栈内存是可以进行 gc 扫描的</span><br>gcController.addScannableStack(pp, -<span class="hljs-type">int64</span>(gp.stack.hi-gp.stack.lo))<br><span class="hljs-comment">// 如果 gp 是系统 goroutine，则将系统 goroutine 的计数减少</span><br>  <span class="hljs-keyword">if</span> isSystemGoroutine(gp, <span class="hljs-literal">false</span>) &#123;<br>sched.ngsys.Add(<span class="hljs-number">-1</span>)<br>&#125;<br>  <span class="hljs-comment">// 清理 gp 的状态</span><br>gp.m = <span class="hljs-literal">nil</span><br>locked := gp.lockedm != <span class="hljs-number">0</span><br>gp.lockedm = <span class="hljs-number">0</span><br>mp.lockedg = <span class="hljs-number">0</span><br>gp.preemptStop = <span class="hljs-literal">false</span><br>gp.paniconfault = <span class="hljs-literal">false</span><br>gp._defer = <span class="hljs-literal">nil</span> <br>gp._panic = <span class="hljs-literal">nil</span><br>gp.writebuf = <span class="hljs-literal">nil</span><br>gp.waitreason = waitReasonZero<br>gp.param = <span class="hljs-literal">nil</span><br>gp.labels = <span class="hljs-literal">nil</span><br>gp.timer = <span class="hljs-literal">nil</span><br><br>  <span class="hljs-comment">// 如果启用了垃圾回收（GC）并且 gp.gcAssistBytes 大于 0，</span><br>  <span class="hljs-comment">// 则将辅助信用归还给全局池。这有助于更好地控制垃圾回收进程。</span><br><span class="hljs-keyword">if</span> gcBlackenEnabled != <span class="hljs-number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="hljs-number">0</span> &#123;<br>assistWorkPerByte := gcController.assistWorkPerByte.Load()<br>scanCredit := <span class="hljs-type">int64</span>(assistWorkPerByte * <span class="hljs-type">float64</span>(gp.gcAssistBytes))<br>gcController.bgScanCredit.Add(scanCredit)<br>gp.gcAssistBytes = <span class="hljs-number">0</span><br>&#125;<br><br>  <span class="hljs-comment">// 将当前 g 从 P 的运行队列中移除</span><br>dropg()<br><br>  <span class="hljs-comment">// WebAssembly 平台特殊处理</span><br><span class="hljs-keyword">if</span> GOARCH == <span class="hljs-string">&quot;wasm&quot;</span> &#123; <br>gfput(pp, gp)<br>schedule() <br>&#125;<br><br>  <span class="hljs-comment">// 将 gp 放回处理器的可用队列中，这样可以复用 g</span><br>gfput(pp, gp)<br><br>  <span class="hljs-comment">// 如果 goroutine 被绑定到当前线程上，</span><br>  <span class="hljs-comment">// 那可能是在做系统调用，cgo 调用或其他特殊任务，</span><br>  <span class="hljs-comment">// 那么就需要切到 g0，让 g0 来完成后面的调度。</span><br>  <span class="hljs-keyword">if</span> locked &#123;<br><span class="hljs-comment">// 如果 goroutine 在终止前曾锁定当前线程，</span><br>    <span class="hljs-comment">// 则根据不同的操作系统执行不同的处理。</span><br>    <span class="hljs-comment">// 在大多数操作系统上，会跳转到 mstart 函数，释放 P 并退出线程。</span><br>    <span class="hljs-comment">// 但在 Plan 9 操作系统上，会清除 lockedExt。</span><br><span class="hljs-keyword">if</span> GOOS != <span class="hljs-string">&quot;plan9&quot;</span> &#123; <span class="hljs-comment">// See golang.org/issue/22227.</span><br>gogo(&amp;mp.g0.sched)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mp.lockedExt = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>  <br>  <span class="hljs-comment">// 继续调度</span><br>  <span class="hljs-comment">// 如果执行了 gogo，那就是 g0 在调度。</span><br>  <span class="hljs-comment">// 如果没有执行 gogo，那就是 gp 在调度。</span><br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里我们就完成了对 GPM 调度循环的全过程源码分析了，你可以回到 <ahref="##4.%20调度过程%20schedule()">4. 调度过程 schedule()</a>看一下我总结的那张图，这回你应该会有更加深入的理解了。</p><h2 id="协程切换">5. 协程切换</h2><p>如果要一个协程要一直到执行完毕才退出的话，那很可能会造成其他协程饥饿的问题。所以Go其实会在一些特殊的时机对协程进行切换，这个过程有抢占式调度，也有协作式的调度。</p><p>协程切换的时候，最核心的就是要保存当前协程的现场，以方便回到该协程的时候继续执行剩下的内容。大致过程如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57vi6wrdqj21ho0sqjtn.jpg"alt="Go 协程切换" /><figcaption aria-hidden="true">Go 协程切换</figcaption></figure><p>有哪些时机会触发切换呢，这里我直接给出结论：</p><p>基于协作的抢占式调度</p><ul><li>主动挂起：<code>runtime.gopark()</code></li><li>系统调用结束时：<code>exitsyscall()</code></li><li>函数跳转时：<code>morestack()</code></li></ul><p>基于信号的抢占式调度</p><ul><li>信号调度：<code>doSigPreempt()</code></li></ul><h3 id="主动挂起-runtime.gopack">5.1 主动挂起 runtime.gopack()</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57vq4flf5j21j20s4jto.jpg"alt="gopack 协程切换" /><figcaption aria-hidden="true">gopack 协程切换</figcaption></figure><p>这个函数位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gopark</span><span class="hljs-params">(unlockf <span class="hljs-keyword">func</span>(*g, unsafe.Pointer)</span></span> <span class="hljs-type">bool</span>, lock unsafe.Pointer, reason waitReason, traceReason traceBlockReason, traceskip <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> reason != waitReasonSleep &#123;<br>checkTimeouts() <br>&#125;<br>mp := acquirem()<br>gp := mp.curg<br>status := readgstatus(gp)<br><span class="hljs-keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;<br>throw(<span class="hljs-string">&quot;gopark: bad g status&quot;</span>)<br>&#125;<br>mp.waitlock = lock<br>mp.waitunlockf = unlockf<br>gp.waitreason = reason<br>mp.waitTraceBlockReason = traceReason<br>mp.waitTraceSkip = traceskip<br>releasem(mp)<br>mcall(park_m)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>gopark</code> 函数的主要目的是使 G进入休眠状态，等待被唤醒。</p><p>最后它调用了 <code>mcall()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// mcall switches from the g to the g0 stack and invokes fn(g)</span><br><span class="hljs-comment">// mcall 切换到 g0，并执行 fn。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mcall</span><span class="hljs-params">(fn <span class="hljs-keyword">func</span>(*g)</span></span>)<br></code></pre></td></tr></table></figure><p>所以这里切换回 <code>g0</code>，并执行了 <code>pack_m</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">park_m</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pack_m()</code> 其实就是调用了 <code>schedule()</code>去进行下一轮调度，这就完成了协程的切换。</p><p>当协程被阻塞的时候，就会去调用 <code>runtime.gopark()</code> 主动让出CPU，切回 <code>g0</code>，等待被唤醒，以此保证最大化利用 CPU资源。比如以下几种情况：</p><ul><li>休眠</li><li>channel 通道阻塞</li><li>网络 I/O 阻塞</li><li>因为执行垃圾回收而暂停</li></ul><h3 id="系统调用结束时-exitsyscall">5.2 系统调用结束时exitsyscall()</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h57vx0tfayj21g60r4tb4.jpg"alt="exitsyscall 协程切换" /><figcaption aria-hidden="true">exitsyscall 协程切换</figcaption></figure><p>Go 通过 <code>entersyscall()</code> 进行系统调用，完事后会执行<code>exitsyscall()</code>，它也位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exitsyscall</span><span class="hljs-params">()</span></span> &#123;<br>...<br>mcall(exitsyscall0)<br>&#125;<br></code></pre></td></tr></table></figure><p>其实它最终也是调用 <code>mcall()</code> 切换到 <code>g0</code>，我们不难猜出，它这里让 <code>g0</code> 去执行 <code>exitsyscall0</code>函数，做完系统调用的善后后，肯定还是会执行 <code>schedule()</code>函数进行协程调度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exitsyscall0</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数跳转时-morestack">5.3 函数跳转时 morestack()</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57w74gg19j21iq0smwgs.jpg"alt="morestack 协程切换" /><figcaption aria-hidden="true">morestack 协程切换</figcaption></figure><p>因为函数跳转意味着“压栈”，函数跳转时都会调用这个方法，它的本意在于检查当前协程栈空间是否有足够内存，如果不够就要扩大该栈空间。</p><p>为了让每个协程都有执行的机会，并且最大化利用 CPU 资源，Go语言在初始化时会启动一个特殊的线程来执行系统监控任务，系统监控在一个独立的M 上运行，不用绑定逻辑处理器 P。当系统监控到协程运行超过<code>10ms</code>，就将 <code>g.stackguard0</code> 置为<code>stackPreempt</code>（该值是一个抢占标志）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> forcePreemptNS = <span class="hljs-number">10</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> <span class="hljs-comment">// 10ms</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">retake</span><span class="hljs-params">(now <span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">uint32</span> &#123;<br><span class="hljs-comment">// 遍历所有的 P</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(allp); i++ &#123;<br>pp := allp[i]<br>pd := &amp;pp.sysmontick<br>s := pp.status<br>sysretake := <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> s == _Prunning || s == _Psyscall &#123;<br>t := <span class="hljs-type">int64</span>(pp.schedtick)<br><span class="hljs-keyword">if</span> <span class="hljs-type">int64</span>(pd.schedtick) != t &#123;<br>pd.schedtick = <span class="hljs-type">uint32</span>(t)<br>pd.schedwhen = now<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now &#123;<br>        <span class="hljs-comment">// 如果 G 运行时间过长，超过了 forcePreemptNS(10ms)，</span><br>        <span class="hljs-comment">// 则标记抢占</span><br>preemptone(pp)<br>sysretake = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> s == _Psyscall &#123;<br>      <span class="hljs-comment">// 如果是系统调用，且已经超过了一个系统监控的 tick(20us)，</span><br>      <span class="hljs-comment">// 则从系统调用中抢占 p。</span><br>      t := <span class="hljs-type">int64</span>(pp.syscalltick)<br><span class="hljs-keyword">if</span> !sysretake &amp;&amp; <span class="hljs-type">int64</span>(pd.syscalltick) != t &#123;<br>pd.syscalltick = <span class="hljs-type">uint32</span>(t)<br>pd.syscallwhen = now<br><span class="hljs-keyword">continue</span><br>&#125;<br>...<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 标记抢占</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preemptone</span><span class="hljs-params">(pp *p)</span></span> <span class="hljs-type">bool</span> &#123;<br>mp := pp.m.ptr()<br>gp := mp.curg<br>gp.preempt = <span class="hljs-literal">true</span><br>gp.stackguard0 = stackPreempt<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>巧的就是，Go 设计者，让程序在执行 <code>morestack()</code>函数时顺便判断一下 <code>g</code> 中的 <code>stackguard</code>是否已经被置为抢占 <code>stackPreempt</code>，如果的确被标记抢占，就回到<code>schedule()</code> 方法，并将当前协程放回队列中。</p><p><code>morestack</code> 是汇编实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">TEXT runtime·morestack(SB),NOSPLIT|NOFRAME,$0-0<br>...<br>BLruntime·newstack(SB)<br></code></pre></td></tr></table></figure><p>它最终会调用 <code>newstack()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newstack</span><span class="hljs-params">()</span></span> &#123;<br>  thisg := getg()<br>  gp := thisg.m.curg<br>  <span class="hljs-comment">// 1. 判断 gp.stackguard0 是否被标记为抢占</span><br>  stackguard0 := atomic.Loaduintptr(&amp;gp.stackguard0)<br>preempt := stackguard0 == stackPreempt<br>  <span class="hljs-comment">// 2. 如果被标记位抢占，调用 gopreempt_m()</span><br>  <span class="hljs-keyword">if</span> preempt &#123;<br><span class="hljs-comment">// 3. 最终会去调用  schedule() 去调新的协程执行</span><br>gopreempt_m(gp) <span class="hljs-comment">// never return</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gopreempt_m</span><span class="hljs-params">(gp *g)</span></span> &#123;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoPreempt()<br>&#125;<br>goschedImpl(gp)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goschedImpl</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号调度-dosigpreempt">5.4 信号调度 doSigPreempt()</h3><p>当程序在执行过程中既无法主动挂起，也不能进行系统调用，且无法进行函数调用时，就可以使用信号来调度。</p><p>信号其实就是线程信号，在操作系统中有很多基于信号的底层通信方式（SIGPIPE/ SIGURG / SIGHUP），而我们的线程可以注册对应信号的处理函数。</p><p>Go 中是注册了 <code>SIGURG</code> 信号的处理函数<code>doSigPreempt()</code>，在 GC工作时，向目标线程发送信号。线程收到信号后，会触发调度。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57wecvgwdj21hk0ssgny.jpg"alt="doSigPreempt 协程切换" /><figcaption aria-hidden="true">doSigPreempt 协程切换</figcaption></figure><p><code>doSigPreempt</code> 位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/signal_unix.go">runtime.signal_unix.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSigPreempt</span><span class="hljs-params">(gp *g, ctxt *sigctxt)</span></span> &#123;<br><span class="hljs-comment">// 检查此 g 是否要被抢占并且安全抢占</span><br><span class="hljs-keyword">if</span> wantAsyncPreempt(gp) &#123;<br><span class="hljs-keyword">if</span> ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok &#123;<br><span class="hljs-comment">// 2. 调整程序计数器 PC 并异步调用 asyncPreempt</span><br>ctxt.pushCall(abi.FuncPCABI0(asyncPreempt), newpc)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>asyncPreempt</code> 的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncPreempt</span><span class="hljs-params">()</span></span><br><br><span class="hljs-comment">// </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncPreempt2</span><span class="hljs-params">()</span></span> &#123;<br>gp := getg()<br>gp.asyncSafePoint = <span class="hljs-literal">true</span><br>  <span class="hljs-comment">// </span><br><span class="hljs-keyword">if</span> gp.preemptStop &#123;<br>mcall(preemptPark)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mcall(gopreempt_m)<br>&#125;<br>gp.asyncSafePoint = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>asyncPreempt</code> 是汇编实现，最终是调的<code>asyncPreempt2</code>，它会调用 <code>mcall</code> 切回<code>g0</code>，并执行 <code>preemptPark</code> 或<code>gopreempt_m</code>， <code>gopreempt_m</code> 就是前面<code>morestack</code> 最后调的！不出意外，<code>preemptPack</code>最后肯定还是调的 <code>schedule()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preemptPark</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runtime.gosched">5.5 runtime.Gosched()</h3><p>在我们实际编程中，你可以通过显式调用 <code>runtime.Gosched()</code>来主动让出 CPU，促进 Go 的下一轮调度，我们来看它的具体实现，肯定还是调的<code>schedule()</code>，没有意外！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Gosched</span><span class="hljs-params">()</span></span> &#123;<br>checkTimeouts()<br>mcall(gosched_m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gosched_m</span><span class="hljs-params">(gp *g)</span></span> &#123;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoSched()<br>&#125;<br>goschedImpl(gp)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goschedImpl</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>status := readgstatus(gp)<br><span class="hljs-keyword">if</span> status&amp;^_Gscan != _Grunning &#123;<br>dumpgstatus(gp)<br>throw(<span class="hljs-string">&quot;bad g status&quot;</span>)<br>&#125;<br>casgstatus(gp, _Grunning, _Grunnable)<br>dropg()<br>lock(&amp;sched.lock)<br>globrunqput(gp)<br>unlock(&amp;sched.lock)<br><br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结">5.6 总结</h3><p>Go 语言为了确保 P 不会因为 G运行时间过长或系统调用阻塞时间过长而导致性能下降。它会尝试进行协程切换，以确保任务可以适时地被分配和执行。这有助于保持Go程序的并发性能和响应性。而协程切换的方式有基于协作的抢占式调度（主动挂起<code>runtime.gopark()</code>，系统调用结束时<code>exitsyscall()</code>，函数跳转时<code>morestack()</code>），也有基于信号的抢占式调度<code>doSigPreempt()</code>，他们都无一例外的最终调用了<code>schedule()</code>。</p><p>所以总结下来其实还是这张图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57vi6wrdqj21ho0sqjtn.jpg"alt="Go 协程切换" /><figcaption aria-hidden="true">Go 协程切换</figcaption></figure><h1 id="gpm-状态流转">G、P、M 状态流转</h1><p>经过我们前面的分析，你可以自行整理 G、P、M状态的流转，这里我给出几张图供你参考：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126224853429.png"alt="Go 协程（G）状态转换图" /><figcaption aria-hidden="true">Go 协程（G）状态转换图</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126225021035.png"alt="Go 处理器（P）状态转换图" /><figcaption aria-hidden="true">Go 处理器（P）状态转换图</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126225849169.png"alt="Go M（操作系统线程）状态转换" /><figcaption aria-hidden="true">Go M（操作系统线程）状态转换</figcaption></figure><h1 id="总结-1">总结</h1><p>以上便是对 Go 语言 GPM 模型的全部分享啦！GPM 模型使得 Go语言能够并发执行成千上万个协程。</p><p>为了减少线程“相对昂贵”的切换代价，Go 引入了 GPM，将大量的 Goroutine分配到少量的系统线程上去执行，并利用多核并行，实现更强大的并发。</p><p>为了减小并发冲突，Go 在全局队列的基础上引入了本地队列。</p><p>为了避免协程饥饿，Go 又引入了多种协程调度的策略。</p><p>为了避免协程阻塞浪费 CPU，Go 引入了多种协程切换的方式。</p><p>Go 语言设计者进行了如此复杂的调度器实现，最终交付给 Gopher的，仅仅是一个 <code>go</code>关键字这么简单，真的是大道至简，这也是充分印证了那句话：“Go为并发而生”。</p><p>希望本文能对你有所帮助，enjoy~ happy coding~</p><h1 id="参考">参考</h1><ul><li><a href="https://book.douban.com/subject/36403287/">深入理解 Go语言</a></li><li><a href="https://book.douban.com/subject/35556889/">Go语言底层原理剖析</a></li><li><a href="https://coding.imooc.com/class/576.html">深入 Go底层原理</a></li><li>ChatGPT4</li></ul><h1 id="作图工具">作图工具</h1><ul><li><a href="https://excalidraw.com/">excalidraw</a></li><li><a href="https://whimsical.com/">whimsical</a></li></ul>]]></content>
    
    
    <summary type="html">本文基于 Go1.21.0 版本详细介绍了 Go 语言的 GPM 模型。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Rust 实战丨绘制曼德博集</title>
    <link href="https://hedon.top/2024/01/17/rust-action-mandelbrot/"/>
    <id>https://hedon.top/2024/01/17/rust-action-mandelbrot/</id>
    <published>2024-01-17T14:39:05.000Z</published>
    <updated>2024-04-15T04:51:44.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="曼德博集">曼德博集</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/2560px-Mandelset_hires-20240118170914026.png"alt="曼德博集" /><figcaption aria-hidden="true">曼德博集</figcaption></figure><p>曼德博集其实是一个“没什么用”的发现。</p><p>曼德博集（MandelbrotSet）是一种在复平面上形成独特且复杂图案的点的集合。这个集合是以数学家本华·曼德博（BenoitMandelbrot）的名字命名的，他在研究复杂结构和混沌理论时发现了这个集合。曼德博集是分形几何的一个经典例子，显示了一个简单的数学公式如何能产生无限复杂和美丽的图案。</p><p>曼德博集的定义相对简单。对于每一个复数 <spanclass="math inline">\(c\)</span>，我们考虑以下迭代序列： <spanclass="math display">\[Z_{n+1} = z_n^2 + c \;\;\\ 其中 \;\; (z_0 = 0)\]</span> <strong>曼德博集合由那些使得上述序列不趋于无限大的复数 <spanclass="math inline">\(c\)</span>组成</strong>。在复平面上，这些点形成了一种独特的图案，通常以一种美丽且艺术的方式呈现。这个图案的边界非常复杂，包含了无限的细节和自相似的结构。这意味着无论你放大图案的哪一部分，你都会发现越来越精细的结构，这些结构在形式上与整体图案相似。</p><p>曼德博集合不仅在数学上有意义，也在艺术和科学中有广泛的应用，尤其是在研究混沌理论和复杂系统时。</p><p>具体可以看</p><ul><li><ahref="https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%BE%B7%E5%8D%9A%E9%9B%86%E5%90%88">维基百科-曼德博集</a></li><li><a href="https://www.bilibili.com/video/BV1kA411T7at">bilibili -2000亿倍放大曼德博集</a></li></ul><h1 id="目标功能">目标功能</h1><p>最终我们将实现一个命令行工具，它会根据我们输入的参数生成曼德博集图，使用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./mandelbrot &lt;FILE&gt; &lt;PIXELS&gt; &lt;UPPERLEFT&gt; &lt;LOWERRIGHT&gt;<br></code></pre></td></tr></table></figure><ul><li><code>FILE</code>: 曼德博集图生成的图片路经。</li><li><code>PIXELS</code>: 图片分辨率，如 <code>4x3</code>。</li><li><code>UPPERLEFT</code>: 指定在复平面中图片覆盖的左上角，如<code>4.0,3.0</code>。</li><li><code>LOWERRIGHT</code>: 制定在复平面中图片覆盖的右下角。</li></ul><p>所以我们最终会根据指定的图片范围，截取 <code>PIXELS</code>分辨率大小的曼德博集图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240118171322832.png"alt="截取曼德博集示意图" /><figcaption aria-hidden="true">截取曼德博集示意图</figcaption></figure><p>基于以上目标，我们拆分成几个问题：</p><ol type="1"><li>如何表示复数？</li><li>如何解析分辨率和坐标？</li><li>如何将图上像素映射到复数？</li><li>如何生成曼德博集图？即如何找到那些符合曼德博集的点，并将其进行着色标注？</li><li>如何写入图片文件？</li><li>如何渲染曼德博集？</li><li>如何解析命令行参数？</li><li>如何并发写入图片文件？</li></ol><h1 id="能学到什么">能学到什么</h1><ol type="1"><li>曼德博集是什么？</li><li>Rust 中的复数的原理与应用。</li><li>Rust 泛型初探。</li><li>Rust 中的 Option 和 Result 初探。</li><li>Rust 并发初探。</li><li>Rust 中如何解析命令行参数？</li><li>Rust 如何写入图像文件？</li><li>Rust 如何写测试用例？</li><li>Rust 实用 crate<code>num</code>、<code>image</code>、<code>crossbeam</code>。</li></ol><h1 id="版本">版本</h1><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;mandelbrot&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">image</span> = &#123;version = <span class="hljs-string">&quot;0.13.0&quot;</span>, features = [<span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;png&quot;</span>]&#125;<br><span class="hljs-attr">num</span> = <span class="hljs-string">&quot;0.4.1&quot;</span><br><span class="hljs-attr">crossbeam</span> = <span class="hljs-string">&quot;0.8&quot;</span><br><span class="hljs-attr">rayon</span> = <span class="hljs-string">&quot;1.10.0&quot;</span><br></code></pre></td></tr></table></figure><p>完整代码：https://github.com/hedon954/mandelbrot/blob/master/src/main.rs</p><h1 id="编码实现">编码实现</h1><h2 id="创建项目">0. 创建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new mandelbrot<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> mandelbrot<br></code></pre></td></tr></table></figure><h2 id="复数表示">1. 复数表示</h2><p>使用复数，我们需要引入一个 crete：<code>num</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add num<br></code></pre></td></tr></table></figure><p>其中定义了一个复数类型 <code>Complex</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/// 复数的实部</span><br>    <span class="hljs-keyword">pub</span> re: T,<br>    <span class="hljs-comment">/// 复数的虚部</span><br>    <span class="hljs-keyword">pub</span> im: T,<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>T</code> 是 Rust 中的泛型功能，表示任意类型<code>T</code>，确定好这个结构体的 <code>T</code> 的类型后，其中的属性<code>re</code> 和 <code>im</code> 的类型也就随之确定了。</p><h2 id="解析分辨率和坐标">2. 解析分辨率和坐标</h2><ul><li>分辨率格式为：4000x3000</li><li>坐标格式为：-1.0,2.0</li></ul><h3 id="解析数对">2.1 解析数对</h3><p>我们要做的就是，将分辨率拆成 (4000,3000)，将坐标拆为 (-1.0,2.0)。这里：</p><ul><li>带解析的元素 <code>s</code> 是一个字符串<code>&amp;str</code>。</li><li>分隔符 <code>separator</code> 是一个字符 <code>char</code>。</li><li>返回值是一个元组 <code>(T, T)</code>，其中 <code>T</code> 这里可以是u64/f32 等数字，它们都需要能从字符串转化而来，即<code>&lt;T:FromStr&gt;</code>。</li><li>因为解析可能出错，所以我们使用 <code>Option</code> 来承载。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 把字符串 `s`（形如 `&quot;400×600&quot;` 或 ``&quot;1.0,0.5&quot;）解析成一个坐标对</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// 具体来说，`s` 应该具有&lt;left&gt;&lt;sep&gt;&lt;right&gt;的格式，其中&lt;sep&gt;是由`separator`</span><br><span class="hljs-comment">/// 参数给出的字符，而&lt;left&gt;和&lt;right&gt;是可以被 `T:from_str` 解析的字符串。</span><br><span class="hljs-comment">/// `separator` 必须是 ASCII 字符</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// 如果 `s` 具有正确的格式，就返回 `Some(x,y)`，否则返回 `None`</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pair</span>&lt;T: FromStr&gt;(s: &amp;<span class="hljs-type">str</span>, separator: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;(T, T)&gt; &#123;<br>    <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">find</span>(separator) &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>        <span class="hljs-title function_ invoke__">Some</span>(index) =&gt; <span class="hljs-keyword">match</span> (T::<span class="hljs-title function_ invoke__">from_str</span>(&amp;s[..index]), T::<span class="hljs-title function_ invoke__">from_str</span>(&amp;s[index + <span class="hljs-number">1</span>..])) &#123;<br>            (<span class="hljs-title function_ invoke__">Ok</span>(l), <span class="hljs-title function_ invoke__">Ok</span>(r)) =&gt; <span class="hljs-title function_ invoke__">Some</span>((l, r)),<br>            _ =&gt; <span class="hljs-literal">None</span>,<br>        &#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以写几个测试用例来验证一下这个函数的正确性，这里我们用到<code>#[test]</code> 和 <code>assert_eq!</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_parse_pair</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;10,&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;,10&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;10,20&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)));<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;10,20xy&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">f64</span>&gt;(<span class="hljs-string">&quot;0.5x&quot;</span>, <span class="hljs-string">&#x27;x&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">f64</span>&gt;(<span class="hljs-string">&quot;0.5x1.5&quot;</span>, <span class="hljs-string">&#x27;x&#x27;</span>), <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-number">0.5</span>, <span class="hljs-number">1.5</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="转为复数">2.2 转为复数</h3><p>我们需要的参数 <code>upper_left</code> 和 <code>lower_right</code>都是复平面中的一个点，所以从字符串中将数对解析完毕后，我们将其赋值到复数的实部和虚部，转为复数实例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 把一对用逗号隔开的浮点数解析为复数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_complex</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Complex&lt;<span class="hljs-type">f64</span>&gt;&gt; &#123;<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">parse_pair</span>(s, <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>((re, im)) =&gt; <span class="hljs-title function_ invoke__">Some</span>(Complex &#123; re, im &#125;),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="将像素点映射成复数">3. 将像素点映射成复数</h2><p>第 2 步我们其实确定了两件事：</p><ol type="1"><li>确定截取曼德博集的哪一部分。</li><li>要在这个部分中画多少个点。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240118174407537.png"alt="目标区域中的像素点" /><figcaption aria-hidden="true">目标区域中的像素点</figcaption></figure><p>这一步我们需要把 <code>x</code>点转为复数，即确定它的横坐标和纵坐标。这部分可能需要发挥一下你的几何数学能力了（🤡🤡🤡）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 给定输出图像重像素的行和列，返回复平面中对应的坐标</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// `pixed` 是表示给图片中特定像素的 (column, row) 二元组。</span><br><span class="hljs-comment">/// `upper_left` 参数和 `lower_right` 参数是在复平面中表示指定图像覆盖范围的点。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">pixed_to_point</span>(<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    ·--------------------&gt; bounds.0  re</span><br><span class="hljs-comment">    丨</span><br><span class="hljs-comment">    丨</span><br><span class="hljs-comment">    丨</span><br><span class="hljs-comment">    bounds.1  im</span><br><span class="hljs-comment">     */</span><br>    bounds: (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>),<br>    pixed: (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>),<br>    upper_left: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>    lower_right: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> Complex&lt;<span class="hljs-type">f64</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> (width, height) = (<br>        lower_right.re - upper_left.re, <span class="hljs-comment">// 右-左</span><br>        upper_left.im - lower_right.im, <span class="hljs-comment">// 上-下</span><br>    );<br><br>    Complex &#123;<br>        re: upper_left.re + pixed.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> * width / bounds.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>,<br>        im: upper_left.im - pixed.<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> * height / bounds.<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_pixed_to_point</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        <span class="hljs-title function_ invoke__">pixed_to_point</span>(<br>            (<span class="hljs-number">100</span>, <span class="hljs-number">200</span>),<br>            (<span class="hljs-number">25</span>, <span class="hljs-number">175</span>),<br>            Complex &#123; re: -<span class="hljs-number">1.0</span>, im: <span class="hljs-number">1.0</span> &#125;,<br>            Complex &#123; re: <span class="hljs-number">1.0</span>, im: -<span class="hljs-number">1.0</span> &#125;<br>        ),<br>        Complex &#123;<br>            re: -<span class="hljs-number">0.5</span>,<br>            im: -<span class="hljs-number">0.75</span>,<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="寻找曼德博集点">4. 寻找曼德博集点</h2><p>什么是曼德博集点？看看上面的定义：<strong>曼德博集合由那些使得上述序列不趋于无限大的复数<span class="math inline">\(c\)</span> 组成</strong>。</p><p>现在我们可以来表示上述的公式 <span class="math inline">\(Z_{n+1} =z_n^2 + c\)</span> 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">complex_square_add_loop</span>(c: Complex&lt;<span class="hljs-type">f64</span>&gt;) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> = Complex &#123; re: <span class="hljs-number">0.0</span>, im: <span class="hljs-number">0.0</span> &#125;;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        z = z * z + c<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中我们将泛型结构体 <code>Complex</code> 的 <code>T</code> 确定为<code>f64</code>，并使用 <code>loop</code> 关键字进行无限循环。</p><p>所以我们的目标是什么？<strong>找到令 <code>z</code>不会“飞到”无穷远的 <code>c</code></strong>。</p><p>由于复数 <span class="math inline">\(c\)</span> 具有实部 re 和虚部im，因此可以把它们视为笛卡尔平面上某个点的 x 坐标和 y 坐标，如果 <spanclass="math inline">\(c\)</span>在曼德博集中，就在其中用黑色着色，否则就用浅色。因此，对于图像中的每个像素，必须在复平面上相应点位运行前面的循环，看看它是否逃逸到无穷远还是永远绕着原点运行，并相应将其着色。</p><p>无限循环肯定是不现实的，我们总要找到退出循环的机会，有 2 个思路：</p><ol type="1"><li>进行有限次数的迭代，这样可以获得该集合的一个不错的近似值，迭代的次数取决了精度的需要；</li><li>业界已证明，<strong>一旦 <code>z</code> 离开了以原点为中心的半径 2的圆，它最终一定会“飞到”无穷远</strong>。</li></ol><p>所以我们最终确定的函数如下，其中 <code>norm_sqr()</code> 会返回<code>z</code> 跟复平面原点的距离的平方：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 尝试测试 `c` 是否位于曼德博集中，使用最多 `limit` 次迭代来判定</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// 如果 `c` 不是集合成员之一，则返回 `Some(i)`，其中 `i` 是 `c` 离开以原点</span><br><span class="hljs-comment">/// 为中心的半径为 2 的圆时所需的迭代次数。如果 `c` 似乎是集群成员之一（确</span><br><span class="hljs-comment">/// 切而言是达到了迭代次数限制但仍然无法证明 `c` 不是成员），则返回 `None`</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">escape_time</span>(c: Complex&lt;<span class="hljs-type">f64</span>&gt;, limit: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">usize</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> = Complex &#123; re: <span class="hljs-number">0.0</span>, im: <span class="hljs-number">0.0</span> &#125;;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..limit &#123;<br>        <span class="hljs-keyword">if</span> z.<span class="hljs-title function_ invoke__">norm_sqr</span>() &gt; <span class="hljs-number">4.0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Some</span>(i);<br>        &#125;<br>        z = z * z + c<br>    &#125;<br>    <span class="hljs-literal">None</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写入图片文件">5. 写入图片文件</h2><p>我们可以使用 <code>image</code> 这个 crate来写入图片文件，它支持多种格式图片的读写，并内置了多种颜色色值。</p><p>这里我们准备生成 png图片，且需要对图片进行不同颜色的着色，所以我们引入 <code>default</code>和 <code>png</code> 这两个 feature。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add image --features default,png<br></code></pre></td></tr></table></figure><h3 id="创建文件-filecreate">5.1 创建文件 File::create()</h3><p>我们可以用标准库中的 <code>File::create(filename)</code>来创建一个文件，成功的话会返回一个文件句柄：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">output</span> = File::<span class="hljs-title function_ invoke__">create</span>(filename)?;<br></code></pre></td></tr></table></figure><h3 id="写入图片-pngencoder">5.2 写入图片 PNGEncoder</h3><p><code>image</code> 中提供了 <code>PNGEncoder</code> 用于写入 png图片，它有两个核心方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;W: Write&gt; PNGEncoder&lt;W&gt; &#123;<br>    <span class="hljs-comment">/// Create a new encoder that writes its output to ```w```</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(w: W) <span class="hljs-punctuation">-&gt;</span> PNGEncoder&lt;W&gt; &#123;<br>        PNGEncoder &#123;<br>            w: w<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/// Encodes the image ```image```</span><br>    <span class="hljs-comment">/// that has dimensions ```width``` and ```height```</span><br>    <span class="hljs-comment">/// and ```ColorType``` ```c```</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">encode</span>(<span class="hljs-keyword">self</span>, data: &amp;[<span class="hljs-type">u8</span>], width: <span class="hljs-type">u32</span>, height: <span class="hljs-type">u32</span>, color: ColorType) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>        <span class="hljs-keyword">let</span> (ct, bits) = color.<span class="hljs-title function_ invoke__">into</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">encoder</span> = png::Encoder::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">self</span>.w, width, height);<br>        encoder.<span class="hljs-title function_ invoke__">set</span>(ct).<span class="hljs-title function_ invoke__">set</span>(bits);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">writer</span> = <span class="hljs-built_in">try!</span>(encoder.<span class="hljs-title function_ invoke__">write_header</span>());<br>        writer.<span class="hljs-title function_ invoke__">write_image_data</span>(data).<span class="hljs-title function_ invoke__">map_err</span>(|e| e.<span class="hljs-title function_ invoke__">into</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>new(w)</code>: 传进目标 writer，即我们上面创建的<code>output</code>。</li><li><code>encode()</code>: 写入图片信息，这里有几个参数：<ul><li><code>width: u32</code>: 图片宽度。</li><li><code>height: u32</code>: 图片高度。</li><li><code>color: ColorType</code>: 颜色类型，可以是 RGB, Gray(8)等。</li><li><code>data: &amp;[u8]</code>: 像素色值列表，它的长度应该由上面 3个字段共同决定，如果选取的颜色是 RGB，意味着需要 3 个 u8才能表示一个像素点的颜色，所以长度为 width * height *3，如果选取的颜色是 Gray(8)，那么我们用 1 个 u8就可以表示一个像素点的灰度值，所以长度为 width * height *1。本文中我们会采用 Gray(8) 来汇总曼德博集的黑白图。</li></ul></li></ul><h2 id="渲染曼德博集">6. 渲染曼德博集</h2><p>这一步我们需要来确定上述 <code>PNGEncoder::encode()</code> 的 4个参数：</p><ul><li><p><code>width: u32</code>:图片宽度由命令行参数中指定即可。</p></li><li><p><code>height: u32</code>:图片高度由命令行参数中指定即可。</p></li><li><p><code>color: ColorType</code>: 本文我们只绘制黑白图，这里使用<code>ColorType::Gray(8)</code>，它表示图像是一个灰度（单色）图像，每个像素用8位（即1个字节）来表示。在这种格式中，每个像素的灰度值范围是0 到 255，其中 0 通常表示黑色，255表示白色，中间值表示不同的灰度。</p></li><li><p><code>data: &amp;[u8]</code>: 像素色值列表，我们需要确定 width *height 个像素的灰度值。</p><p>首先我们根据第 3 步将像素点映射成复数 <spanclass="math inline">\(c\)</span>，然后使用第 4 步中的<code>escape_time()</code> 函数来判断复数 <spanclass="math inline">\(c\)</span>是否位于曼德博集中，如果是，则着黑色，即赋值<code>0</code>，如果不是，则看它迭代了多少次才失败，次数越多，则越接近曼德博集，颜色越深，即越靠近0，所以赋值 <code>255-time</code>。</p></li></ul><p>最终我们实现的函数如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 将曼德博集对应的矩形渲染到像素缓冲区中</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// `bounds` 参数会给缓冲区 `pixels` 的宽度和高度，此缓冲区的每个字节都</span><br><span class="hljs-comment">/// 包含一个灰度像素。`upper_left` 和 `lower_right` 参数分别指定了</span><br><span class="hljs-comment">/// 复平面中对应于像素缓冲区左上角和右上角的点。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">render</span>(<br>    pixels: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>],<br>    bounds: (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>),<br>    upper_left: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>    lower_right: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>) &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(pixels.<span class="hljs-title function_ invoke__">len</span>(), bounds.<span class="hljs-number">0</span> * bounds.<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">raw</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..bounds.<span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">column</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..bounds.<span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">point</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (column, raw), upper_left, lower_right);<br>            pixels[raw * bounds.<span class="hljs-number">0</span> + column] = <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">escape_time</span>(point, <span class="hljs-number">255</span>) &#123;<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-number">0</span>,<br>                <span class="hljs-title function_ invoke__">Some</span>(count) =&gt; <span class="hljs-number">255</span> - count <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>,<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解析命令行参数">7. 解析命令行参数</h2><p>核心逻辑部分到这里其实就完成了，现在我们要做最后一步，就是解析命令行参数，让程序可以根据我们的要求绘制曼德博集图。</p><h3 id="解析-stdenvargs">7.1 解析 std::env::args()</h3><p>在 Rust中解析命令行参数的一个常用方法是使用<code>std::env::args</code>函数，这个函数返回一个迭代器，它包含了命令行上传递给程序的所有参数。对于更复杂的命令行参数解析，可以使用像<code>clap</code>或<code>structopt</code>这样的第三方库，这些库提供了更高级的功能和更好的错误处理。</p><p>下面是一个使用<code>std::env::args</code>的基本例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::env;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">args</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">arg</span> <span class="hljs-keyword">in</span> args.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基础版程序">7.2 基础版程序</h3><p>到这里，我们就可以实现完整的基础版程序了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 读取参数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">args</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>  <span class="hljs-comment">// 参数个数 = 1 + 4，其中第 1 个是应用程序名</span><br>    <span class="hljs-keyword">if</span> args.<span class="hljs-title function_ invoke__">len</span>() != <span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">eprintln!</span>(<span class="hljs-string">&quot;Usage: &#123;&#125; FILE PIXELS UPPERLEFT LOWERRIGHT&quot;</span>, args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">eprintln!</span>(<br>            <span class="hljs-string">&quot;Example: &#123;&#125; mandel.png 1000x700 -1.20,0.35 -1,0.20&quot;</span>,<br>            args[<span class="hljs-number">0</span>]<br>        );<br>        std::process::<span class="hljs-title function_ invoke__">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">// 解析参数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bounds</span> = <span class="hljs-title function_ invoke__">parse_pair</span>(&amp;args[<span class="hljs-number">2</span>], <span class="hljs-string">&#x27;x&#x27;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error parsing image dimensions&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">upper_left</span> = <span class="hljs-title function_ invoke__">parse_complex</span>(&amp;args[<span class="hljs-number">3</span>]).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error parsing upper left corner point&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lower_right</span> = <span class="hljs-title function_ invoke__">parse_complex</span>(&amp;args[<span class="hljs-number">4</span>]).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error parsing lower right corner point&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">pixels</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; bounds.<span class="hljs-number">0</span> * bounds.<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 渲染曼德博集</span><br>    <span class="hljs-title function_ invoke__">render</span>(&amp;<span class="hljs-keyword">mut</span> pixels, bounds, upper_left, lower_right);<br>  <span class="hljs-comment">// 输出图片</span><br>    <span class="hljs-title function_ invoke__">write_image</span>(&amp;args[<span class="hljs-number">1</span>], &amp;pixels, bounds).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error writing PNG file&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在项目根目录下编译一下程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build --release<br></code></pre></td></tr></table></figure><p>会在 target/release 下生成可执行文件，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20<br></code></pre></td></tr></table></figure><p>执行后你应该可以看到我们生成的曼德博集图如下：</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/mandel.png"alt="程序生成的曼德博集" /><figcaption aria-hidden="true">程序生成的曼德博集</figcaption></figure><p>大概是处于这个位置：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240118191624303.png"alt="程序截取的局部曼德博集处于整个曼德博集中的位置" /><figcaptionaria-hidden="true">程序截取的局部曼德博集处于整个曼德博集中的位置</figcaption></figure><h2 id="并发渲染">8. 并发渲染</h2><p>在 macOS 或 linux 系统下，我们可以使用 <code>time</code>来输出程序的执行时间：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">time ./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20<br>./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20  3.30s user 0.01s system 98% cpu 3.341 total<br></code></pre></td></tr></table></figure><p>笔者使用的电脑为 macbook Pro m2 max 芯片 32 G 内存 12核，可以看到在单核模式下，差不多需要 3~4s 的时间。</p><p>几乎所有的现代机器都有多个处理器核心，而当前这个程序只使用了一个。如果可以把此工作分派个机器提供的多个处理器核心，则应该可以更快地画完图像。</p><p>为此，我们可以将图像划分成多个部分，每个处理器负责其中的一个部分，并让每个处理器为分派给它的像素着色。为简单起见，可以将其分成一些水平条带，如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/CleanShot%202024-01-18%20at%2021.28.20.jpg"alt="将像素缓冲区划分为一些条带以进行并发渲染" /><figcaptionaria-hidden="true">将像素缓冲区划分为一些条带以进行并发渲染</figcaption></figure><p>crossbeam 是 Rust中的一个并发编程工具箱，它广泛用于提供各种并发和多线程编程的组件。</p><p><code>crossbeam::scope</code> 是 crossbeam提供的一个非常有用的功能，它允许你安全地创建临时的线程，并确保这些线程在离开作用域之前结束。</p><p>这里我们引入 crossbeam：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add crossbeam<br></code></pre></td></tr></table></figure><p>我们将 <code>fn main()</code> 中的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-title function_ invoke__">render</span>(&amp;<span class="hljs-keyword">mut</span> pixels, bounds, upper_left, lower_right);<br></code></pre></td></tr></table></figure><p>替换成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 8 个线程来并发执行</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">threads</span> = <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 计算每个线程负责渲染的高度，向上取整</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">rows_per_band</span> = bounds.<span class="hljs-number">1</span> / threads + <span class="hljs-number">1</span>;<br>&#123;<br>  <span class="hljs-comment">// chunks_mut() 会返回一个迭代器，该迭代器会生成此缓冲区的可变且不可迭代的切片</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bands</span>: <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>]&gt; = pixels.<span class="hljs-title function_ invoke__">chunks_mut</span>(rows_per_band * bounds.<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">collect</span>();<br>  <span class="hljs-comment">// crossbeam::scope 确保所有子线程在作用域结束之前完成，</span><br>  <span class="hljs-comment">// 这防止了悬垂指针和其他数据竞争问题。</span><br>    crossbeam::<span class="hljs-title function_ invoke__">scope</span>(|spawner| &#123;<br>      <span class="hljs-comment">// 遍历像素缓冲区的各个条带，</span><br>      <span class="hljs-comment">// 这里 into_iter() 迭代器会为循环体的每次迭代赋予独占一个条带的所有权，</span><br>      <span class="hljs-comment">// 确保一次只有一个线程可以写入它。</span><br>        <span class="hljs-keyword">for</span> (i, band) <span class="hljs-keyword">in</span> bands.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>          <span class="hljs-comment">// 确定每个条带的参数</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">top</span> = rows_per_band * i;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">height</span> = band.<span class="hljs-title function_ invoke__">len</span>() / bounds.<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">band_bounds</span> = (bounds.<span class="hljs-number">0</span>, height);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">band_upper_left</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (<span class="hljs-number">0</span>, top), upper_left, lower_right);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">band_lower_right</span> =<br>                <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (bounds.<span class="hljs-number">0</span>, top + height), upper_left, lower_right);<br>          <span class="hljs-comment">// 创建一个线程，渲染图像</span><br>          <span class="hljs-comment">// move 表示这个闭包会接手它所用遍历的所有权，</span><br>          <span class="hljs-comment">// 所以只有此闭关，即只有此线程可以使用可变切片 band。</span><br>            spawner.<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> |_| &#123;<br>                <span class="hljs-title function_ invoke__">render</span>(band, band_bounds, band_upper_left, band_lower_right);<br>            &#125;);<br>        &#125;<br>    &#125;)<br>    .<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>再次执行：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">time ./<span class="hljs-keyword">target</span>/<span class="hljs-keyword">release</span>/mandelbrot mandel.png <span class="hljs-number">4000</span><span class="hljs-keyword">x</span><span class="hljs-number">3000</span> <span class="hljs-number">-1.20</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.35</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.20</span><br>./<span class="hljs-keyword">target</span>/<span class="hljs-keyword">release</span>/mandelbrot mandel.png <span class="hljs-number">4000</span><span class="hljs-keyword">x</span><span class="hljs-number">3000</span> <span class="hljs-number">-1.20</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.35</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.20</span>  <span class="hljs-number">3.57</span>s user <span class="hljs-number">0.01</span>s system <span class="hljs-number">335</span>% cpu <span class="hljs-number">1.067</span> total<br></code></pre></td></tr></table></figure><p>可以看到虽然总共使用的 CPU 时间还是3~4s，但是整个程序的执行时间只缩短到 1s 左右了。</p><h2 id="rayon-工作窃取">9. rayon 工作窃取</h2><p>前面我们使用 8 个工作线程优化了曼德博集的绘制速度，大概是 4倍的速度提升。其实这还不够快。</p><p>问题的根源在于我们没有平均分配工作量。计算图像的一个像素相当于运行一个循环。事实上，图像的浅灰色部分（循环会快速退出的地方）比黑色部分（循环会运行整整255次迭代的地方）渲染速度要快得多。因此，虽然我们将整个区域划分成了大小相等的水平条带，但创建了不均等的工作负载，</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image00879.jpeg"alt="曼德博集程序中的工作分配不均等" /><figcaptionaria-hidden="true">曼德博集程序中的工作分配不均等</figcaption></figure><p>使用 rayon很容易解决这个问题。我们可以为输出中的每一行像素启动一个并行任务。这会创建数百个任务，而rayon可以在其线程中分配这些任务。有了工作窃取机制，任务的规模是无关紧要的。rayon会对这些工作进行平衡。</p><p>我们先引入 <code>rayon</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add rayon<br></code></pre></td></tr></table></figure><p>在 <code>main.rs</code> 中引入 <code>rayon</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rayon::prelude::*;<br></code></pre></td></tr></table></figure><p>然后 <code>main</code> 中并发绘制的部分替换为下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">bands</span>: <span class="hljs-type">Vec</span>&lt;(<span class="hljs-type">usize</span>, &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>])&gt; = pixels.<span class="hljs-title function_ invoke__">chunks_mut</span>(bounds.<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">enumerate</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><br>bands.<span class="hljs-title function_ invoke__">into_par_iter</span>().for_each(|(i, band)| &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">top</span> = i;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">band_bounds</span> = (bounds.<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">band_upper_left</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (<span class="hljs-number">0</span>, top), upper_left, lower_right);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">band_lower_right</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (bounds.<span class="hljs-number">0</span>, top + <span class="hljs-number">1</span>), upper_left, lower_right);<br>    <span class="hljs-title function_ invoke__">render</span>(band, band_bounds, band_upper_left, band_lower_right);<br>&#125;);<br></code></pre></td></tr></table></figure><p>首先，创建 bands，也就是要传给 rayon的任务集合。每个任务只是一个元组类型 (usize, &amp;mut[u8])：第一个是计算所需的行号，第二个是要填充的 pixels 切片。我们使用chunks_mut 方法将图像缓冲区分成一些行，enumerate则会给每一行添加行号，然后 collect会将所有数值切片对放入一个向量中。（这里需要一个向量，因为 rayon只能从数组和向量中创建并行迭代器。）</p><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build --release<br></code></pre></td></tr></table></figure><p>再次执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">time ./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20<br>./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20  3.96s user 0.01s system 973% cpu 0.408 total<br></code></pre></td></tr></table></figure><p>可以看到，这次速度提升更加明显，总共只用了 0.4s 左右的时间。</p><p>以上就是实用 Rust 绘制曼德博集实战的全部内容，enjoy，happycoding~</p>]]></content>
    
    
    <summary type="html">本文参考《Rust 程序设计（第二版）》中第二章的示例，与读者分享**曼德博集**的绘制过程。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="Rust 实战" scheme="https://hedon.top/categories/Rust/Rust-%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust Web 框架 Axum 指南</title>
    <link href="https://hedon.top/2024/01/14/rust-axum/"/>
    <id>https://hedon.top/2024/01/14/rust-axum/</id>
    <published>2024-01-13T16:28:03.000Z</published>
    <updated>2024-01-29T07:31:47.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结论先行">结论先行</h1><h1 id="hello-world">Hello World</h1><p>先来看看 Axum 的 Hello World：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> axum::Router;<br><span class="hljs-keyword">use</span> axum::routing::get;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 创建一个应用，带一个 / 路由，输出 Hello World</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(|| <span class="hljs-keyword">async</span> &#123; <span class="hljs-string">&quot;Hello World!&quot;</span> &#125;));<br><br>    <span class="hljs-comment">// 监听 3000 端口</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = tokio::net::TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;0.0.0.0:3000&quot;</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// 启动服务</span><br>    axum::<span class="hljs-title function_ invoke__">serve</span>(listener, app).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面这个例子，可以得到的第一个信息就是：<code>Axum</code> 是<code>tokic</code> 生态下的一员。</p><blockquote><p>本文默认读者对 <code>tokio</code> 具有基本的了解。</p></blockquote><p>所以这里我们需要引入两个组件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add tokio --features macros,rt-multi-thread<br>cargo add axum<br></code></pre></td></tr></table></figure><p>这个例子我们定义了一个路由，下面我们就先从 Axum 的路由开始介绍。</p><h1 id="routing-路由">Routing 路由</h1><h2 id="单个路由">单个路由</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">Router::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(|| <span class="hljs-keyword">async</span> &#123; <span class="hljs-string">&quot;Hello World!&quot;</span> &#125;));<br></code></pre></td></tr></table></figure><p>实际上它等价于：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(handler_hello_world));<br> ...<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handler_hello_world</span> () <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">IntoResponse</span> &#123;<br>    <span class="hljs-string">&quot;Hello World&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>路由注册部分为为 <code>path</code>、<code>method</code> 和<code>handler</code> 三个部分。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240114141604009.png"alt="路由注册部分" /><figcaption aria-hidden="true">路由注册部分</figcaption></figure><p>其中 <code>get</code> 可以替换为<code>post</code>、<code>patch</code>、<code>delete</code>、<code>head</code>和 <code>options</code> 等 http method。</p><p>其中 <code>handler</code>的返回值需要满足：<code>impl IntoResponse</code>，常用的<code>字符串</code>、<code>json</code> 和 <code>html</code> 都已经实现了<code>IntoResponse</code>，所以都是可以直接返回的。</p><h2 id="路由分组">路由分组</h2><p>你可以使用 <code>merge()</code> 和 <code>nest()</code>来进行路由分组，其中 <code>nest()</code> 可以指定统一路由前缀：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">merge</span>(<span class="hljs-title function_ invoke__">todo_routers</span>())<br>        .<span class="hljs-title function_ invoke__">nest</span>(<span class="hljs-string">&quot;/v2/todo&quot;</span>, <span class="hljs-title function_ invoke__">todo_routers_v2</span>());<br>...<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">todo_routers</span>() <span class="hljs-punctuation">-&gt;</span> Router &#123;<br>    Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/todo/delete/:id&quot;</span>, <span class="hljs-title function_ invoke__">delete</span>(handler_todo_delete))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/todo/list&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(handler_todo_list))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/todo/create&quot;</span>, <span class="hljs-title function_ invoke__">post</span>(handler_todo_create))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/todo/update&quot;</span>, <span class="hljs-title function_ invoke__">put</span>(handler_todo_update))<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">todo_routers_v2</span>() <span class="hljs-punctuation">-&gt;</span> Router &#123;<br>    Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/delete/:id&quot;</span>, <span class="hljs-title function_ invoke__">delete</span>(handler_todo_delete))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/list&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(handler_todo_list))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/create&quot;</span>, <span class="hljs-title function_ invoke__">post</span>(handler_todo_create))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/update&quot;</span>, <span class="hljs-title function_ invoke__">put</span>(handler_todo_update))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态路由">静态路由</h2><p>可以使用同 <code>tokio</code> 生态下的 <code>tower-http</code>来实现静态路由：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_routers</span>() <span class="hljs-punctuation">-&gt;</span> Router &#123;<br>    Router::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">nest_service</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-title function_ invoke__">get_service</span>(ServeDir::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;./&quot;</span>)))<br>&#125;<br></code></pre></td></tr></table></figure><p>这里你需要添加 <code>tower-http</code> 组件，至少需要载入<code>fs</code> 特性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add tower-http --features fs<br></code></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://docs.rs/axum/latest/axum/">Rust-Axum</a></li></ul>]]></content>
    
    
    <summary type="html">本文详细介绍了 Rust 中的 Web 框架 Axum，包含了 Axum 的基础和高阶功能，文中包含了大量示例，希望能对读者了解 Axum 带来一点帮助。</summary>
    
    
    
    <category term="Rust" scheme="https://hedon.top/categories/Rust/"/>
    
    <category term="web 框架" scheme="https://hedon.top/categories/Rust/web-%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Rust" scheme="https://hedon.top/tags/Rust/"/>
    
    <category term="Axum" scheme="https://hedon.top/tags/Axum/"/>
    
  </entry>
  
  <entry>
    <title>一文彻底掌握浮点数</title>
    <link href="https://hedon.top/2023/12/23/floating-point-number/"/>
    <id>https://hedon.top/2023/12/23/floating-point-number/</id>
    <published>2023-12-23T13:51:52.000Z</published>
    <updated>2024-03-27T11:38:28.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典问题">经典问题</h2><p>0.1 + 0.2 = ？</p><p>我们写个 Go 程序来测试一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f1 <span class="hljs-type">float64</span> = <span class="hljs-number">0.1</span><br><span class="hljs-keyword">var</span> f2 <span class="hljs-type">float64</span> = <span class="hljs-number">0.2</span><br>fmt.Println(f1+f2 == <span class="hljs-number">0.3</span>)<br>fmt.Println(f1 + f2)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-literal">false</span><br>0.30000000000000004<br></code></pre></td></tr></table></figure><p>如此违背 “常识”的结果，其实是因为当下计算机体系中小数的表示方式是浮点数，而计算机中对浮点数的表示并非百分百精确的，在表示和计算过程中都有可能会丢失精度。</p><p>这迫使必须深入理解浮点数在计算机中的存储方式及性质，才能正确处理关于数字的计算问题。</p><h2 id="结论先行">结论先行</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/IEEE-754%20%E6%B5%AE%E7%82%B9%E6%95%B0.jpg"alt="IEEE-754 浮点数" /><figcaption aria-hidden="true">IEEE-754 浮点数</figcaption></figure><h2 id="定点数">定点数</h2><p>要理解浮点数的第一步是考虑含有小数值的二进制数字。在这之前，我们来看看更加熟悉的十进制表示法：</p><p><span class="math display">\[d_md_{m-1} ··· d_1d_0 . d_{-1}d_{-2}··· d_{-n}\]</span></p><p>小数点 <code>.</code>左边是整数部分，右边是小数部分。其中每个十进制数 <code>di</code>的取值范围是 0~9。</p><p>如十进制的 <code>12.34</code> 即可以表示为：</p><p><span class="math display">\[1×10^1+2×10^0+3×10^{-1}+4×10^{-2}\]</span></p><p>那其实二进制也是一样的道理，只不过把其中的 <code>10</code> 换成<code>2</code>，而 <code>di</code> 的取值范围为 0~1。</p><p>如二进制的 <code>101.11</code> 可以表示为：</p><p><span class="math display">\[1×2^2+0×2^1+1×2^0+1×2^{-1}+1×2^{-2}\]</span></p><p>如果我们仅考虑有限长度的编码，那么十进制表示法不能准确表达像 1/3 和5/7这样的数。类似的，小数的二进制表示法只能表示那些能够被写成以下形式的数：</p><p><span class="math display">\[x × 2^y\]</span></p><p>其他的值就只能近似地表示。</p><p>定点数的整数部分是小数部分的位数是固定不变的，在位数有限的情况下，定点数的取值范围和精度都比较差。于是就有了IEEE-754 提出的浮点数表示法。</p><h2 id="浮点数">浮点数</h2><p>所谓“浮点数”（Floating-pointnumbers），即小数点可以“<strong>浮动</strong>”，即小数点的位置不是固定的，而是可以根据数值的大小和精度需求移动的。这种表示法允许在广泛的范围内表示数值，同时保持相对恒定的精度。</p><p>在计算机中，浮点数通常遵循 IEEE-754标准。这个标准定义了浮点数的存储和运算方式，确保了不同计算机系统之间的一致性。IEEE-754用以下形式来表示一个数：</p><p><span class="math display">\[V = (-1)^s×M×2^E\]</span></p><p>其中：</p><ul><li><strong>s 符号位（Sign bit）</strong>：表示数值的正负。</li><li><strong>M 尾数（Mantissa）</strong>：表示数值的有效数字。</li><li><strong>E 指数（Exponent）</strong>：决定小数点的位置。</li></ul><p>IEEE-754将浮点数的位表示划分成三个部分，分别对各个部分进行编码，对应上面公式右边的3 个字母：</p><ul><li>一个单独的符号位 <code>s</code> 直接编码符号 <code>s</code>。</li><li><span class="math inline">\(k\)</span> 位的阶码字段 <spanclass="math inline">\(exp=e_{k-1}\cdots e_1e_0\)</span> 编码阶码<code>E</code>。</li><li><span class="math inline">\(n\)</span> 位小数字段 <spanclass="math inline">\(frac=f_{n-1}\cdots f_1f_0\)</span> 编码尾数<code>M</code>，但是编码出来的值也依赖于阶码字段的值是否等于 0。</li></ul><p>在 IEEE-754 标准中，定义了两种精度的浮点数，分别是单精度浮点数（32位）和双精度浮点数（64 位）。</p><p>单精度：</p><ul><li>1 位符号位 s</li><li>8 位指数 exp</li><li>23 位尾数 frac</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224102703581.png"alt="单精度浮点数" /><figcaption aria-hidden="true">单精度浮点数</figcaption></figure><p>双精度：</p><ul><li>1 位符号位 s</li><li>11 位指数 exp</li><li>52 位尾数 frac</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224102756244.png"alt="双精度浮点数" /><figcaption aria-hidden="true">双精度浮点数</figcaption></figure><p>根据 <code>exp</code> 的值，浮点数又可以分成三类：</p><ol type="1"><li>规格化的</li><li>非规格化的</li><li>特殊的</li></ol><p>其中第三类“特殊的”又可以根据 <code>frac</code> 分成两类：</p><ol type="1"><li>无穷大</li><li>不是一个数 NaN（Not a Number）</li></ol><p>具体如下表所示：</p><table><thead><tr class="header"><th></th><th style="text-align: center;">exp</th><th style="text-align: center;">frac</th></tr></thead><tbody><tr class="odd"><td>规格化的</td><td style="text-align: center;">≠0 &amp; ≠ 255</td><td style="text-align: center;">f</td></tr><tr class="even"><td>非规格化的</td><td style="text-align: center;">0</td><td style="text-align: center;">f</td></tr><tr class="odd"><td>特殊的</td><td style="text-align: center;">1</td><td style="text-align: center;">f</td></tr><tr class="even"><td>- 无穷大</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr class="odd"><td>- NaN</td><td style="text-align: center;">1</td><td style="text-align: center;">≠0</td></tr></tbody></table><p>对于不同类型的浮点数，在计算公式 <spanclass="math inline">\(V=(-1)^s×M×2^E\)</span>中，<code>exp -&gt; E</code> 和 <code>frac -&gt; M</code>的方式有所不同。</p><p>下面我们来对这几种不同类型进行详细讨论，其中不乏有一些很有趣且充满智慧的设计理念。</p><h3 id="特殊值-special-values">特殊值 Special Values</h3><ul><li><strong>指数部分</strong>：全为 0。</li><li><strong>尾数部分</strong>：全为 0 则表示无穷大，不全为 0 则表示NaN。</li><li><strong>作用</strong>：特殊值用于表示那些无法用常规数值表示的情况，如无穷大、非数（NaN）等。这些值通常用于操作的错误或特殊情况的结果，如除以0、无效操作等。</li></ul><h3 id="规格化的值-normalize-values">规格化的值 Normalize Values</h3><ul><li><strong>指数部分</strong>：不全为 0 且不全为 1。</li><li><strong>尾数部分</strong>：可以是任意值。</li><li><strong>作用</strong>：用于表示大多数非零数值</li></ul><p>在规格化值中：</p><ul><li><span class="math inline">\(E=e-bias\)</span></li><li><span class="math inline">\(M=1+f\)</span></li></ul><p>其中 <code>e</code> 即为 <code>exp</code>，，<code>bias</code>是偏置量，它的值为 <span class="math inline">\(2^{k-1} -1\)</span>，其中<code>k</code> 为 <code>exp</code> 的位数，故：</p><ul><li>在单精度中，<spanclass="math inline">\(bias=2^{8-1}-1=2^7-1=128-1=127\)</span></li><li>在双精度中，<spanclass="math inline">\(bias=2^{11-1}-1=2^{10}-1=1024-1=1023\)</span></li></ul><p>其中 <code>f</code> 为 <code>frac</code> 表示的数，范围 <spanclass="math inline">\(0≤f&lt;1\)</span>。</p><p>所以一个规格化数，具体可以表示为：</p><p><span class="math display">\[V=(-1)^{sign}×1.frac×2^{(exp-bias)}\]</span></p><p>这里有 4 个问题：</p><ol type="1"><li>这个 <code>bias</code> 是什么？</li><li>为什么 <code>E</code> 要 <code>e</code> 去减掉一个<code>bias</code>？</li><li><code>bias</code> 的值是怎么定下的，如单精度为什么是 127，不是 126或 128？</li><li><code>M</code> 为什么需要 <code>f</code> 去加上一个<code>1</code>？</li></ol><p>下面我们来对这 4 个问题进行一一解答。</p><p><strong>第 1 个问题，这个 bias 是什么？</strong></p><blockquote><p><code>bias</code>是一个预设的偏移量，用于将指数部分的值偏移到全正数，从而简化处理。</p></blockquote><p><strong>第 2 个问题：为什么 E 要 e 去减去一个 bias？</strong></p><blockquote><p>先说结论：使用 bias（偏置指数，biasedexponent）可以允许浮点数以统一的方式表示，同时也使得浮点数的排序和比较变得简单。</p></blockquote><p>首先指数肯定得支持正负形式的出现，那么直接使用无符号整型来表示指数肯定是不行的，因为它无法表示负指数。暂时先抛开IEEE-754 定下的标准，我们可以尝试用补码来表示指数。</p><p>假设我们有两个 32 位的浮点数 <code>A</code> 和<code>B</code>，并且我们假设它们的指数部分使用 8 位二进制补码表示（这与IEEE-754 标准不同）。</p><ul><li><code>A</code>的二进制表示：<code>0 0000010 00000000000000000000000</code></li><li><code>B</code>的二进制表示：<code>0 1111110 00000000000000000000000</code></li></ul><p>在这里，第一位是符号位（0 表示正数），接下来的 8位是以补码形式表示的指数，剩下的 23 位是尾数。</p><p>我们想要比较这两个数的大小，需要怎么做呢？</p><p>我们先解析这 2 个数：</p><ul><li>符号位：对于 <code>A</code> 和 <code>B</code>，符号位都是0，表示这是两个正数。</li><li>指数部分（使用补码表示）<ul><li><code>A</code> 的指数为 <code>0000010</code>，解读为正数 +2。</li><li><code>B</code> 的指数为<code>1111110</code>，在补码表示中，这是一个负数。先加取反后加 1转换为正数 <code>00000010</code>，它表示 -2。</li></ul></li></ul><p>要比较这 2 个数：</p><ul><li>当我们比较 <code>A</code> 和 <code>B</code>时，首先需要考虑它们的指数。</li><li>指数 <code>A</code> 为 +2，而 <code>B</code> 为-2。即使它们的尾数部分相同（在这个例子中都是 0），<code>A</code>的实际值要大于<code>B</code>，因为正指数表示的数值范围远大于负指数。</li></ul><p>可以看出：使用补码表示指数增加了比较过程的复杂性，因为我们需要解读补码并考虑其正负。特别是在涉及到负指数的情况下，我们不能仅仅比较二进制表示的大小，而必须将补码转换为实际的数值，然后再进行比较。</p><p>现在回过头来看看 IEEE-754 的设计，假设我们有两个单精度（32 位）浮点数<code>A</code> 和 <code>B</code>：</p><ul><li><code>A</code>的二进制表示为：<code>0 10000010 00000000000000000000000</code></li><li><code>B</code>的二进制表示为：<code>0 01111110 00000000000000000000000</code></li></ul><p>解析这两个数：</p><ul><li><code>A</code>：符号位为 0（正数），指数部分为<code>10000010</code>（二进制，对应十进制的 130），尾数部分为全 0。</li><li><code>B</code>：符号位为 0（正数），指数部分为<code>01111110</code>（二进制，对应十进制的 126），尾数部分为全 0。</li></ul><p>计算实际指数值：单精度浮点数的偏置值 <code>bias</code> 为127，故：</p><ul><li><code>A</code> 的实际指数 <code>E = 130 - 127 = 3</code>。</li><li><code>B</code> 的实际指数 <code>E = 126 - 127 = -1</code>。</li></ul><p>比较这两个数：</p><ul><li>在减去 <code>bias</code>后，我们可以直接比较指数部分的二进制表示来确定数值的大小。</li><li>由于 <code>10000010</code>（130）大于<code>01111110</code>（126），因此我们可以直接得出 <code>A</code> 大于<code>B</code>，而无需考虑负指数的复杂表示问题。</li></ul><p>这个例子说明了通过减去偏置值，IEEE-754标准能够简化浮点数的比较和排序操作。偏置后的指数表示方法允许计算机以统一和高效的方式处理浮点数，无论它们的实际数值大小如何。</p><p><strong>第 3 个问题：bias 的值是怎么定下的，如单精度为什么是127，而不是 126 或 128？</strong></p><blockquote><p><code>bias</code>值的选择，是为了平衡正负指数的表示范围，并且充分利用指数部分的存储空间。</p></blockquote><p>以单精度为例，<code>exp</code> 占了 8 位，8位二进制可以表示的值的范围是 <spanclass="math inline">\([0,255]\)</span>。如果我们选择 127 作为<code>bias</code>，则存储的指数范围就是 <spanclass="math inline">\([-127,128]\)</span>。这样可以使得指数部分可以均匀地表示从负大数到正大数的范围（对称）。</p><p>在 IEEE-754 标准中，全 0 的指数表示为非规格化数或 0，而全 1的指数用于表示无穷大或 NaN）。选择 127 作为 <code>bias</code>可以在保留这些特殊值的同时，提供最大的有效指数范围。</p><p><strong>第 4 个问题：M 为什么需要 f 去加上一个 1？</strong></p><blockquote><p>在规格化数中隐含最高位 1是为了提高尾数部分的表示效率，从而增加精度。</p></blockquote><p>其实这跟科学计数法的很像的，为了确保浮点数表示的<strong>唯一性</strong>，IEEE-754规定规格化浮点数最高位一定是非零的。如果不规定最高位非零，同一个数可以有多种不同的浮点表示，例如，在二进制中<code>0.5</code> 可以表示为 <spanclass="math inline">\(1.0×2^{-1}\)</span>，也可以表示位 <spanclass="math inline">\(0.1×2^0\)</span> 或 <spanclass="math inline">\(0.01×2^1\)</span>等等。这种多重表示会使浮点运算变得复杂且低效。</p><p>那既然最高位总是 1，那就没必要显示存储了，还可以使尾数部分中多 1位的存储空间，从而允许存储更多的有效数字，以<strong>提高精度</strong>。</p><h3 id="非规格化的值-denormalized-values">非规格化的值 DenormalizedValues</h3><ul><li><strong>指数部分</strong>：全为 0。</li><li><strong>尾数部分</strong>：可以是任意值。</li><li><strong>作用</strong>：<ul><li>提供表示数值 0 的方法。因为规格化中 <spanclass="math inline">\(M≥1\)</span>，所以无法表示 0。</li><li>用于表示非常接近于 0的数值，这些数值太小，无法用规格化格式表示。它们填补了 0和最小规格化正数之间的间隙，提供了渐近于 0的连续表示，防止了所谓的“下溢”。</li></ul></li></ul><p>在非规格化值中：</p><ul><li><span class="math inline">\(E=1-bias\)</span></li><li><span class="math inline">\(M=f\)</span></li></ul><p>所以一个规格化数，具体可以表示为：</p><p><span class="math display">\[V=(-1)^{sign}×0.frac×2^{(1-bias)}\]</span></p><p>那这里又有 2 个问题了：</p><ol type="1"><li>为什么指数部分不是 <span class="math inline">\(0-bias\)</span> 而是<span class="math inline">\(1-bias\)</span>？</li><li>为什么 M 不需要隐含的 1 了？</li></ol><p><strong>第 1 个问题：为什么指数部分不是 0-bias 而是1-bias？</strong></p><blockquote><p>这是一个特殊的设计，旨在使非规格化数能够平滑地连接到规格化数的最小正值。</p></blockquote><p>最小的规格化数的指数为<code>1 - bias</code>。为了在数值上平滑地过渡到非规格化数，非规格化数的实际指数也被设定为<code>1 - bias</code>。这样，非规格化数就可以代表那些小于最小规格化正数的数值，而不会出现一个数值的“间隙”。</p><p><strong>第 2 个问题：为什么 M 不需要隐含的 1 了？</strong></p><blockquote><p>不包含隐含的 1 使得非规格化数能够在浮点数表示中填补 0和最小规格化数之间的空隙，提供对极小数值的连续表示。</p></blockquote><ul><li><strong>避免下溢</strong>：非规格化数通过允许尾数部分不以隐含的 1开始（而是以显式的 0开始），使得它们可以表示比最小规格化数还要小的数值。这对于避免数值下溢至0 非常重要，尤其是在累积了多次运算后的场合。</li><li><strong>精度牺牲</strong>：使用非规格化数的代价是牺牲了一些精度。由于没有隐含的最高位1，非规格化数的精度较低。但这是为了在非常小的数值范围内提供数值的连续性所做的必要妥协。</li></ul><h3 id="总结">总结</h3><p>规格化值、非规格化值和特殊值三种类型共同构成了 IEEE-754浮点数标准的完整表示体系，使得浮点数能够在计算机中有效低处理从非常小到非常大的数值范围，同时还能应对特殊的计算情况。</p><h3 id="举例">举例</h3><p>参考《深入理解计算机系统》，我们以 8 位浮点数为例，其中：</p><ul><li>1 位符号 s</li><li>4 位指数 exp</li><li>3 位尾数 frac</li></ul><p>可以算出 <spanclass="math inline">\(bias=2^{4-1}-1=2^3-1=8-1=7\)</span>。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/544558-20211104211145834-189368139.png"alt="8 位浮点数（≥0部分）" /><figcaption aria-hidden="true">8 位浮点数（≥0部分）</figcaption></figure><p>其中靠近 0 的是非规格化值：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224130157112.png"alt="8 位浮点数 - 非规格化值" /><figcaption aria-hidden="true">8 位浮点数 - 非规格化值</figcaption></figure><p>以 <code>0 0000 001</code> 为例：</p><p><span class="math display">\[V = (-1)^s×M×2^E \\= (-1)^s×0.frac×2^{1-bias} \\= (-1)^0×(0+(1/8))×2^{1-7} \\= 1×1/8×2^{-6} \\=2^{(-9)} \\= 1/512\]</span></p><p>再往下，就是规格化值：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224130849986.png"alt="8 位浮点数 - 规格化值" /><figcaption aria-hidden="true">8 位浮点数 - 规格化值</figcaption></figure><p>以 <code>0 0110 110</code> 为例：</p><p><span class="math display">\[V = (-1)^s×M×2^E \\= (-1)^s×1.frac×2^{e-bias} \\= (-1)^0×(1+6/8)×2^{6-7} \\=1×14/8×2^{-1} \\= 14/16 \\=7/8\]</span></p><h2 id="整型转为浮点型">整型转为浮点型</h2><p>下面以一个例子来直观感受一下一个整型是如何转为浮点型的。</p><p>现在我们有一个 int32 的整型<code>123</code>，我们希望将其转为单精度浮点型 <code>123.0</code>。</p><p><strong>1. 将整型用二进制表示出来</strong></p><p><span class="math display">\[12345_{(10)} = 1111011_{(2)}\]</span></p><p><strong>2. 规范化表示</strong></p><p><span class="math display">\[1111011= 1.111011×2^6\]</span></p><p><strong>3. 计算指数</strong></p><p><span class="math display">\[exp = 6 + 127 = 133_{(10)} = 10000101_{(2)}\]</span></p><p><strong>4. 确定尾数**</strong></p><p>这是个规范化值，所以 <code>1.frac</code> 的 <code>1</code>省略，又因为单精度浮点数 <code>frac</code> 占 23 位，所以我们需要在<code>111011</code> 后面再填 17 个 0，即：</p><p><span class="math display">\[frac = 111011 0000 0000 0000 0000 0\]</span></p><p><strong>5. 确定符号位</strong></p><p><span class="math display">\[s = 0_{(2)}\]</span></p><p><strong>6. 组合起来</strong></p><p><code>12345.0</code> =<code>0  10000101 11101100000000000000000</code></p><h2 id="浮点数舍入">浮点数舍入</h2><p>由于浮点数的表示具有固定的精度，在进行运算或表示时，经常会遇到无法精确表示的数值，这就需要采用舍入方法来近似表示这些数值。IEEE-754标准定义了几种不同的舍入模式，以适应不同的计算需求。</p><h3 id="舍入模式">舍入模式</h3><p><strong>最近舍入（Round to Nearest）</strong>:</p><ul><li>这是最常用的舍入模式，也是默认的模式。</li><li>规则是向最接近的可表示值舍入。如果精确结果位于两个可表示值的中点，通常舍入到最近的偶数（即尾数的最后一位为0）。</li><li>这种方法减少了累积误差，确保了在多次运算后的总体精度。</li></ul><p><strong>向零舍入（Round Toward Zero）</strong>:</p><ul><li>这种模式总是舍入到零的方向，即舍去小数部分。</li><li>对于正数，这相当于取下限，对于负数，相当于取上限。</li></ul><p><strong>向上舍入（Round Up）</strong>:</p><ul><li>无论正负，都向远离零的方向舍入。</li><li>对于正数，舍入后的值不小于原值；对于负数，舍入后的值不大于原值。</li></ul><p><strong>向下舍入（Round Down）</strong>:</p><ul><li>无论正负，都向接近零的方向舍入。</li><li>对于正数，舍入后的值不大于原值；对于负数，舍入后的值不小于原值。</li></ul><h3 id="舍入的影响">舍入的影响</h3><ul><li><strong>精度损失</strong>：由于固定的尾数位数，舍入可能导致精度的损失。</li><li><strong>舍入误差</strong>：舍入操作本身可能引入误差，这些误差在连续运算中可能会累积。</li><li><strong>选择合适的舍入模式</strong>：不同的舍入模式适合不同的应用场景。例如，金融计算可能更倾向于使用向零舍入，而科学计算通常使用最近舍入以减少累积误差。</li></ul><h3 id="实例">实例</h3><table><thead><tr class="header"><th>Mode</th><th style="text-align: center;">1.40</th><th style="text-align: center;">1.60</th><th style="text-align: center;">1.50</th><th style="text-align: center;">2.50</th><th style="text-align: center;">-1.50</th></tr></thead><tbody><tr class="odd"><td>最近舍入</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">-2</td></tr><tr class="even"><td>向零舍入</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">-1</td></tr><tr class="odd"><td>向上舍入</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">-1</td></tr><tr class="even"><td>向下舍入</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">-2</td></tr></tbody></table><h2 id="浮点数运算">浮点数运算</h2><p>因为浮点数本身就存在精度问题，所以浮点数运算在计算机中是一个近似过程，涉及到精确度的权衡、特殊值的处理、错误的传播，以及舍入规则的应用。</p><h3 id="浮点数加减">浮点数加减</h3><ol type="1"><li>浮点数加法和减法首先需要对操作数进行对齐，使得它们的指数相同。这可能涉及将尾数的二进制表示向右移位，可能导致精度损失。</li><li>然后执行加法或减法操作。</li><li>对结果进行规范化和舍入。</li></ol><p>注意，浮点数的加减法<strong>不满足</strong>结合律、交换律和分配律，这你简单分析下应该就可以理解了，这里不赘述了。</p><p>假设我们要在单精度浮点数格式下计算：</p><p><span class="math display">\[12.375 + 0.1 = ?\]</span></p><p><strong>第 1 步：转为二进制表示</strong></p><p>其中 12.375 我们可以用二进制精确表示：</p><p><span class="math display">\[12.375_{(10)} = 1100.011_{(2)}\]</span></p><p>而 0.1 就比较特殊了，用二进制表示的话它会无限循环。</p><blockquote><p>将十进制小数转换为二进制表示涉及到重复乘以 2的过程，并提取每次乘法后整数部分作为二进制位。这个过程是一个不断重复的过程，直到小数部分变为0 或开始循环。</p></blockquote><ol type="1"><li><p>取 <code>0.1</code> 的小数部分乘以 2（即<code>0.1 × 2 = 0.2</code>），整数部分是 <code>0</code>，小数部分是<code>0.2</code>。</p></li><li><p>再次取小数部分乘以 2（即 <code>0.2 × 2 = 0.4</code>），整数部分是<code>0</code>，小数部分是 <code>0.4</code>。</p></li><li><p>继续这个过程，我们得到以下序列：</p><p><code>0.4 × 2 = 0.8</code> → 整数部分 <code>0</code></p><p><code>0.8 × 2 = 1.6</code> → 整数部分 <code>1</code></p><p><code>0.6 × 2 = 1.2</code> → 整数部分 <code>1</code></p><p><code>0.2 × 2 = 0.4</code> → 整数部分 <code>0</code></p><p>…（循环开始）</p></li></ol><p>所以，<code>0.1</code> 的二进制表示开始为<code>0.0001100110011…</code>，并且这个模式会无限循环下去。</p><p><strong>第 2 步：规格化</strong></p><p>回顾一下这张图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224102703581.png"alt="单精度浮点数" /><figcaption aria-hidden="true">单精度浮点数</figcaption></figure><p>所以 12.375 规格化表示为：</p><ul><li>先规范化为 1.xxxx 形式： <span class="math inline">\(1100.011_{(2)}= 1.100011 × 2^3\)</span></li><li>指数为：<span class="math inline">\(3 + 127 = 130 =10000010_{(2)}\)</span></li><li>尾数为：<spanclass="math inline">\(10001100000000000000000（23\;位，右边补\;0）\)</span></li><li>汇总：<spanclass="math inline">\(0\;10000010\;10001100000000000000000\)</span></li></ul><p>而 0.1 由于无限循环，我们在单精度下只能保留 23位，并采用<strong>最近舍入</strong>，所以 0.1 规格化表示为：</p><ul><li>先规范为 1.xxxx 形式：<spanclass="math inline">\(0.00011001100110011001100(循环) =1.10011001100110011001100 × 2^-4\)</span></li><li>指数为：<span class="math inline">\(-4 + 127 = 123 =01111011_{(2)}\)</span></li><li>尾数为：<spanclass="math inline">\(10011001100110011001100\)</span></li><li>汇总：<spanclass="math inline">\(0\;01111011\;10011001100110011001100\)</span></li></ul><p><strong>第 3 步：对齐指数</strong></p><p>先把 2 个浮点表示放在一起，好对比：</p><ul><li><spanclass="math inline">\(0\;10000010\;10001100000000000000000\)</span></li><li><spanclass="math inline">\(0\;01111011\;10011001100110011001100\)</span></li></ul><p>将两个数的指数对齐，较小的指数增加，同时相应地调整尾数。</p><p>这里需要调整将 <code>0.1</code> 的指数从 <code>01111011</code> 调整到<code>10000010</code>，这里加了 <code>7</code>，所以 <code>0.1</code>的尾数 <code>1.10011001100110011001100</code>需要右移 <code>7</code>位，即：<code>0.00000011001100110011001</code>。</p><p><strong>第 4 步：相加</strong></p><p>现在两个数的指数相同了，我们可以直接把它们的尾数相加：</p><p><span class="math display">\[\;\;\;1.10001100000000000000000 \\+\;0.00000011001100110011001 \\=\;1.10001111001100110011001\]</span></p><p><strong>第 5 步：规范化结果</strong></p><p>这里无需规范化。</p><p><strong>第 6 步：舍入</strong></p><p>这里没有进位，不需要舍入。</p><p><strong>第 7 步：浮点化表示</strong></p><p><span class="math display">\[0\;10000010\;10001111001100110011001\]</span></p><p><strong>第 8 步：转为十进制</strong></p><p><span class="math display">\[V =(-1)^s×M×2^E \\= (-1)^s×1.frac×2^{e-bias} \\= 1.10001111001100110011001 × 2^3 \\= 1100.01111001100110011001_{(2)} \\= 12.47499942779541015625_{(10)} \\≈ 12.475_{(10)}\]</span></p><h3 id="浮点数乘法">浮点数乘法</h3><ol type="1"><li><strong>符号位计算</strong>：结果的符号由两个操作数的符号位决定。如果符号位相同（都是正数或都是负数），结果为正；如果符号位不同，结果为负。</li><li><strong>指数相加</strong>：两个数的指数相加，并减去偏置值（单精度浮点数中为127，双精度为 1023）。</li><li><strong>尾数相乘</strong>：两个数的尾数相乘。这里的尾数包括隐含的最高位1。</li><li><strong>结果规范化</strong>：如果乘法的结果需要规范化（即调整为<code>1.xxxx</code> 的形式），则相应调整指数。</li><li><strong>舍入处理</strong>：如果需要，对结果进行舍入以适应目标格式。</li><li><strong>检查溢出或下溢</strong>：如果指数超出了表示范围，则发生溢出（结果可能为无穷大或特殊值）；如果指数太小，发生下溢（结果可能为0 或非规格化数）。</li></ol><p>假设我们要在单精度浮点数格式下计算：</p><p><span class="math display">\[2.0 × 3.0 = ?\]</span></p><p><strong>第 1 步：转为二进制表示</strong></p><p><span class="math display">\[2.0_{(10)} = 1_{(2)} \\3.0_{(10)} = 11_{(2)}\]</span></p><p><strong>第 2 步：规范化</strong></p><p><span class="math display">\[1 = 1.0 × 2^0 \\11 = 1.1 × 2^1\]</span></p><p><strong>第 3 步：浮点化</strong></p><p><span class="math display">\[2.0 = 0\;00000001\;00000000000000000000000 \\3.0 = 0\;00000001\;10000000000000000000000\]</span></p><p><strong>第 4 步：乘法操作</strong></p><ul><li>符号位：正正得正：<span class="math inline">\(0_{(2)} × 0_{(2)} =0_{(2)}\)</span></li><li>指数相加并减去偏置值：<spanclass="math inline">\((127+1)+(127+1)-127=129\)</span></li><li>尾数相乘：<span class="math inline">\(1.0_{(2)}×1.1_{(2)} =1.1_{(2)}\)</span></li></ul><p><strong>第 5 步：规范化</strong></p><p>这里无需规范化。</p><p><strong>第 6 步：舍入</strong></p><p>这里无需舍入。</p><p><strong>第 7 步：浮点化结果</strong></p><p><span class="math display">\[0\;00000010\;10000000000000000000000\]</span></p><p><strong>第 8 步：转为十进制</strong></p><p><span class="math display">\[V = (-1)^s×1.frac×2^{(e-127)} \\= 0 × 1.1 × 2^2 \\= 110_{(2)} \\= 6.0_{(10)}\]</span></p><h3 id="浮点数除法">浮点数除法</h3><p>浮点数除法类似于乘法，但有一些不同：</p><ol type="1"><li><strong>符号位计算</strong>：与乘法类似，结果的符号由两个操作数的符号位决定。</li><li><strong>指数相减</strong>：被除数的指数减去除数的指数，再加上偏置值。</li><li><strong>尾数相除</strong>：被除数的尾数除以除数的尾数。</li><li><strong>结果规范化</strong>：如果必要，调整结果使其规范化。</li><li><strong>舍入处理</strong>：如果需要，对结果进行舍入。</li><li><strong>检查溢出或下溢</strong>：与乘法类似的检查。</li></ol><p>假设我们要在单精度浮点数格式下计算：</p><p><span class="math display">\[6.0 ÷ 3.0 =?\]</span></p><p><strong>第 1 步：转为二进制表示</strong></p><p><span class="math display">\[6.0_{(10)} = 110_{(2)} \\3.0_{(10)} = 11_{(2)}\]</span></p><p><strong>第 2 步：规范化</strong></p><p><span class="math display">\[6.0 = 110 = 1.10 × 2^2 \\3.0 = 11 = 1.1 × 2^1\]</span></p><p><strong>第 3 步：浮点化</strong></p><p><span class="math display">\[6.0 = 0\;00000020\;10000000000000000000000 \\3.0 = 0\;00000001\;10000000000000000000000\]</span></p><p><strong>第 4 步：除法操作</strong></p><ul><li>符号位：正正得正：<span class="math inline">\(0_{(2)} × 0_{(2)} =0_{(2)}\)</span></li><li>指数减并加上偏置值：<spanclass="math inline">\((127+2)-(127+1)+127=128\)</span></li><li>尾数相除：<span class="math inline">\(1.1_{(2)}×1.1_{(2)} =1.0_{(2)}\)</span></li></ul><p><strong>第 5 步：规范化</strong></p><p>这里无需规范化。</p><p><strong>第 6 步：舍入</strong></p><p>这里无需舍入。</p><p><strong>第 7 步：浮点化结果</strong></p><p><span class="math display">\[0\;00000001\;00000000000000000000000\]</span></p><p><strong>第 8 步：转为十进制</strong></p><p><span class="math display">\[V = (-1)^s×1.frac×2^{(e-127)} \\= 0 × 1.0 × 2^1 \\= 10_{(2)} \\= 2.0_{(10)}\]</span></p><h2 id="go-语言输出浮点数">Go 语言输出浮点数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> number <span class="hljs-type">float32</span> = <span class="hljs-number">12.375</span><br>fmt.Printf(<span class="hljs-string">&quot;浮点数：%f\n&quot;</span>, number)<br>fmt.Printf(<span class="hljs-string">&quot;科学计数法：%e\n&quot;</span>, number)<br>fmt.Printf(<span class="hljs-string">&quot;保留 2 位小数：%.2f\n&quot;</span>, number)<br><br>bits := math.Float32bits(number)<br>bitsStr := fmt.Sprintf(<span class="hljs-string">&quot;%.32b&quot;</span>, bits)<br>fmt.Printf(<span class="hljs-string">&quot;输出32位浮点表示：%s %s %s\n&quot;</span>, bitsStr[:<span class="hljs-number">1</span>], bitsStr[<span class="hljs-number">1</span>:<span class="hljs-number">9</span>], bitsStr[<span class="hljs-number">9</span>:])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mathbig">math/big</h2><p>Go 语言的 <code>math/big</code>包提供了对大数的精确计算支持，这些大数的大小超出了标准整数类型（如<code>int64</code>）或浮点类型（如<code>float64</code>）的范围。这个包主要用于需要高精度计算的领域，如加密、科学计算等。</p><p>主要功能：</p><ul><li><strong>算术运算</strong>：支持基本的加、减、乘、除等算术运算。</li><li><strong>比较操作</strong>：可以比较两个大数的大小。</li><li><strong>位操作</strong>：对大整数进行位操作，如位移、与、或、异或等。</li><li><strong>解析和格式化</strong>：可以从字符串解析大数，也可以将大数格式化为字符串。</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := big.NewFloat(math.MaxFloat64)<br>b := big.NewFloat(math.MaxFloat64)<br>sum := big.NewFloat(<span class="hljs-number">0</span>)<br>sum.Add(a, b)<br>fmt.Println(<span class="hljs-string">&quot;a:&quot;</span>, a)<br>fmt.Println(<span class="hljs-string">&quot;sum:&quot;</span>, sum)<br>sum2 := big.NewFloat(<span class="hljs-number">0</span>).<br>SetPrec(<span class="hljs-number">15</span>).        <span class="hljs-comment">// 设置精度，prec 越大，精度越高，计算越复杂</span><br>SetMode(big.ToZero) <span class="hljs-comment">// 设置舍入策略</span><br>sum2.Add(a, b)<br>fmt.Println(<span class="hljs-string">&quot;sum2:&quot;</span>, sum2)<br>&#125;<br><br><span class="hljs-comment">// a: 1.7976931348623157e+308</span><br><span class="hljs-comment">// sum: 3.5953862697246314e+308</span><br><span class="hljs-comment">// sum2: 3.5953e+308</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li><strong>性能考虑</strong>：由于 <code>math/big</code>提供的是任意精度计算，其性能通常低于原生的固定大小数值类型。</li><li><strong>内存使用</strong>：大数运算可能会消耗更多的内存。</li><li><strong>方法链式调用</strong>：<code>math/big</code>的许多方法返回接收者本身，支持链式调用。</li></ul><h2 id="参考资料">参考资料</h2><ul><li><ahref="https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">IEEE-754</a></li><li>深入理解计算机系统</li><li>Go 语言底层原理剖析</li><li>https://www.bilibili.com/video/BV1zK4y1j7Cn</li><li>ChatGPT-4</li></ul>]]></content>
    
    
    <summary type="html">本文从一个经典问题 0.1+0.2 != 0.3 出发，详细介绍了 IEEE-754 标准下的浮点数表示方法，细致阐述了 3 种浮点数类型的表示逻辑，包括规格化值、非规格化值和特殊值。还介绍了浮点数舍入的 4 种模式，以及浮点数的基本运算。最后，本文结合 Go 语言给出了浮点数不同的输出方式的例子，以及简单介绍了 Go 语言中的 math/big 库在大数运算和精度更高的运算场景中的应用。本文包含大量实例和推演过程，希望能帮助读者彻底掌握浮点数。</summary>
    
    
    
    <category term="计算机基础" scheme="https://hedon.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机原理" scheme="https://hedon.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    <category term="浮点数" scheme="https://hedon.top/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go1.21.0 程序启动过程</title>
    <link href="https://hedon.top/2023/12/07/go-start/"/>
    <id>https://hedon.top/2023/12/07/go-start/</id>
    <published>2023-12-07T13:45:13.000Z</published>
    <updated>2023-12-25T03:23:46.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><ul><li>Go 1.21.0</li><li>操作系统：Windows11 Intel64</li></ul><h2 id="结论先行">结论先行</h2><h3 id="开发关注版">开发关注版</h3><p>在 Go 语言中，启动顺序通常如下：</p><ol type="1"><li><strong>导入包</strong>：首先，Go 编译器按照源文件中的<code>import</code> 语句导入所有需要的包。</li><li><strong>初始化常量和变量</strong>：接着，编译器会初始化包级别（全局）的常量和变量。它们的初始化顺序按照它们在源文件中出现的顺序进行。</li><li><strong>执行 init 函数</strong>：然后，编译器会执行包级别的<code>init</code> 函数。如果一个包有多个 <code>init</code>函数，它们的执行顺序和它们在源文件中出现的顺序一致。</li><li><strong>执行 main.main 函数</strong>：最后，编译器会执行<code>main</code> 函数。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/710735-20211213134644475-1604352048.png"alt="Go 程序启动流程 - 开发关注版" /><figcaption aria-hidden="true">Go 程序启动流程 - 开发关注版</figcaption></figure><h3 id="深入原理版">深入原理版</h3><ol type="1"><li><strong>命令行参数复制</strong>：读取命令行参数，复制到 argc 和argv。</li><li><strong>初始化 g0 栈</strong>：g0 是运行时系统的一个特殊的goroutine，它在程序启动时被创建，用于执行系统调用和协程调度。</li><li><strong>runtime.check 运行时检查</strong>：<ol type="1"><li>类型长度</li><li>指针操作</li><li>结构体字段偏移量</li><li>CAS</li><li>atomic 操作</li><li>栈大小是否为 2 的幂次。</li></ol></li><li><strong>runtime.args 参数初始化</strong>：将 argc 和 argv的参数赋值到 Go 的变量中。</li><li><strong>runtime.osinit初始化操作系统特点的设置</strong>：主要是判断系统字长和 CPU 核数。</li><li><strong>runtime.schedinit 初始化调度器</strong>：<ol type="1"><li>锁初始化</li><li>竞态检测器初始化</li><li>调度器设置，设置调度器可以管理的最大线程（M）数目</li><li>系统初始化，初始化内存管理、CPU设置、算法等，这些都是调度器正常工作的基础</li><li>设置当前 M 的信号掩码</li><li>解析程序参数和环境变量</li><li>垃圾收集器初始化</li><li>设置 process 的数量</li></ol></li><li><strong>runtime.newproc 创建主协程 g0并将其放入队列中等待执行</strong>。</li><li><strong>runtime. mstart 启动调度器</strong>：初始化 m0，并调度 g0去执行 <code>runtime.main</code>。</li><li><strong>runtime.main 程序真正入口</strong>：<ol type="1"><li>runtime.init</li><li>启动 gc</li><li>执行用户包 init</li><li>执行用户函数 main.main</li></ol></li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231210224929126.png"alt="Go 程序启动流程 - 深入原理版" /><figcaption aria-hidden="true">Go 程序启动流程 - 深入原理版</figcaption></figure><blockquote><p>如果只是想对 Go语言程序的启动过程有一个简单的了解，那么阅读到这里就可以结束了。</p></blockquote><h2 id="runtime">Runtime</h2><p>在分析 Go 程序的启动过程之前，我们需要先了解一下 Go 中的Runtime。所谓 Runtime，即 Go 的运行时环境，可以理解为 Java 的JVM、JavaScript 依赖的浏览器内核。</p><p>Go 的 Runtime是一份代码，它会随着用户程序一起打包成二进制文件，随着程序一起运行。</p><p>Runtime 具有内存管理、GC、协程、屏蔽不同操作系统调用等能力。</p><p>综上，Go 程序的运行都依赖于 Runtime 运行，所以我们在分析 Go语言程序的启动过程的时候，首先要确定程序的入口，即 Runtime。</p><p>这部分代码位于 go 源码中 <ahref="https://github.com/golang/go/tree/go1.21.0/src/runtime">src/runtime</a>目录下，当你在本机安装 go 后，你可以进入相应的代码目录下，在 Windows上，你可以在该目录下运行下面命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">dir</span> | findstr <span class="hljs-string">&quot;rt0&quot;</span> |  findstr <span class="hljs-string">&quot;amd&quot;</span><br></code></pre></td></tr></table></figure><p>这里我们输出 go 官方为多种 <code>amd</code>处理器架构的操作系统所实现的 runtime，如：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">754</span> rt0_android_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">399</span> rt0_darwin_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">448</span> rt0_dragonfly_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">442</span> rt0_freebsd_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">311</span> rt0_illumos_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">425</span> rt0_ios_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">307</span> rt0_linux_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">309</span> rt0_netbsd_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">311</span> rt0_openbsd_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">481</span> rt0_plan9_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">311</span> rt0_solaris_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>           <span class="hljs-number">1166</span> rt0_windows_amd64.s<br></code></pre></td></tr></table></figure><p>到这里也就明白了，前面所说的 Go Runtime 能力之“屏蔽不同操作系统调用能力”的方式便是针对每一种操作系统单独做实现，最后在编译的时候根据操作系统选择对应的实现即可。</p><p>这里我们以 <ahref="https://github.com/golang/go/blob/go1.21.0/src/runtime/rt0_windows_amd64.s">rt0_windows_amd64.s</a>为例，看看这个文件写了些什么：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">TEXT</span> _rt0_amd64_windows(<span class="hljs-built_in">SB</span>),NOSPLIT<span class="hljs-title">|NOFRAME,$-8</span><br><span class="hljs-title">JMP_rt0_amd64(SB)</span><br></code></pre></td></tr></table></figure><p>这里我们可以看到它会直接跳到 <code>_rt0_amd64(SB)</code> 这里，在Goland IDE 中，你可以双击 Shift 键打开搜索，搜索<code>TEXT _rt0_amd64</code>，就可以发现这个函数位于 <ahref="https://github.com/golang/go/blob/go1.21.0/src/runtime/asm_amd64.s">asm_amd64.s</a>文件中，查看该文件：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// _rt0_amd64 is common startup code for most amd64 systems when using</span><br><span class="hljs-comment">// internal linking. This is the entry point for the program from the</span><br><span class="hljs-comment">// kernel for an ordinary -buildmode=exe program. The stack holds the</span><br><span class="hljs-comment">// number of arguments and the C-style argv.</span><br><span class="hljs-symbol">TEXT</span> _rt0_amd64(<span class="hljs-built_in">SB</span>),NOSPLIT,$-<span class="hljs-number">8</span><br>MOVQ<span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>), DI<span class="hljs-comment">// argc</span><br>LEAQ<span class="hljs-number">8</span>(<span class="hljs-built_in">SP</span>), SI<span class="hljs-comment">// argv</span><br>JMPruntime·rt0_go(<span class="hljs-built_in">SB</span>)<br></code></pre></td></tr></table></figure><p>翻译一下上面的注释：<code>_rt0_amd64</code> 是大多数<code>amd64</code> 系统在使用内部链接时的通用启动代码。这是<code>exe</code> 程序从内核进入程序的入口点。堆栈保存了参数的数量和 C语言风格的 argv。</p><p>到这里我们就可以非常确定地找到了对应操作系统的 Go语言程序启动入口了，接下来只需要沿着该入口继续分析即可。</p><h2 id="runtimert0_go">runtime·rt0_go</h2><p>上面我们分析到 <code>_rt0_adm64</code> 会 JMP 到<code>runtime·rt0_go</code> 执行，这个函数也位于 <ahref="https://github.com/golang/go/blob/go1.21.0/src/runtime/asm_amd64.s">asm_amd64.s</a>文件中，通过分析这个函数，我们可以了解到 Go 语言程序的整个启动过程。</p><p>下面将对这整个函数进行一个概览，后面会对重点过程逐个详述。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">TEXT</span> runtime·rt0_go(<span class="hljs-built_in">SB</span>),NOSPLIT<span class="hljs-title">|NOFRAME|</span>TOPFRAME,<span class="hljs-number">$0</span><br><span class="hljs-comment">// 读取命令行参数，复制参数变量 argc 和 argv 到栈上</span><br>MOVQDI, AX<span class="hljs-comment">// argc</span><br>MOVQSI, <span class="hljs-keyword">BX</span><span class="hljs-comment">// argv</span><br>SUBQ$(<span class="hljs-number">5</span>*<span class="hljs-number">8</span>), <span class="hljs-built_in">SP</span><br>ANDQ$~<span class="hljs-number">15</span>, <span class="hljs-built_in">SP</span><br>MOVQAX, <span class="hljs-number">24</span>(<span class="hljs-built_in">SP</span>)<br>MOVQBX, <span class="hljs-number">32</span>(<span class="hljs-built_in">SP</span>)<br><br><span class="hljs-comment">// 从给定的（操作系统）堆栈创建istack。</span><br><span class="hljs-comment">// 这是在设置 g0 的堆栈，g0 是运行时系统的一个特殊的 goroutine。</span><br><span class="hljs-comment">// 它在程序启动时被创建，用于执行系统调用和协程调度。</span><br><span class="hljs-comment">// 这里只是初始化 g0 的堆栈，还没有启动 g0。</span><br>MOVQ$runtime·g0(<span class="hljs-built_in">SB</span>), DI<br>LEAQ(-<span class="hljs-number">64</span>*<span class="hljs-number">1024</span>)(<span class="hljs-built_in">SP</span>), <span class="hljs-keyword">BX</span><br>MOVQBX, g_stackguard0(DI)<br>MOVQBX, g_stackguard1(DI)<br>MOVQBX, (g_stack+stack_lo)(DI)<br>MOVQ<span class="hljs-built_in">SP</span>, (g_stack+stack_hi)(DI)<br><br><span class="hljs-comment">// 检查 CPU 的厂商 ID：</span><br><span class="hljs-comment">//如果没有 CPU 信息，则跳转到 nocpuinfo；</span><br><span class="hljs-comment">//如果是 Intel 的 CPU，就设置 runtime·isIntel=1，否则跳到 notintel。</span><br>MOVL<span class="hljs-number">$0</span>, AX<br>CPUID<br>CMPLAX, <span class="hljs-number">$0</span><br>JEnocpuinfo<br>CMPLBX, <span class="hljs-number">$0x756E6547</span>  <span class="hljs-comment">// &quot;Genu&quot;</span><br>JNEnotintel<br>CMPLDX, <span class="hljs-number">$0x49656E69</span>  <span class="hljs-comment">// &quot;ineI&quot;</span><br>JNEnotintel<br>CMPLCX, <span class="hljs-number">$0x6C65746E</span>  <span class="hljs-comment">// &quot;ntel&quot;</span><br>JNEnotintel<br>MOVB<span class="hljs-number">$1</span>, runtime·isIntel(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-symbol">notintel:</span>  <span class="hljs-comment">// 加载 EXA=1 的 cpuid 标志和版本信息</span><br>MOVL<span class="hljs-number">$1</span>, AX<br>CPUID<br>MOVLAX, runtime·processorVersionInfo(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-symbol">nocpuinfo:</span>  <br><span class="hljs-comment">// 如果有 _cgo_init 就调用它</span><br>MOVQ_cgo_init(<span class="hljs-built_in">SB</span>), AX<br>TESTQAX, AX<br><span class="hljs-comment">// 如果 _cgo_init 不存在，那么跳过后面的代码，</span><br><span class="hljs-comment">// 直接进入到 needtls 进行 TLS 的初始化。</span><br><span class="hljs-comment">// TLS，全称为Thread-Local Storage（线程局部存储），</span><br><span class="hljs-comment">// 是操作系统提供的一种机制，允许每个线程拥有一份自己的数据副本。</span><br><span class="hljs-comment">// 这些数据在同一线程的所有函数中都是可见的，但对其他线程是不可见的。</span><br><span class="hljs-comment">// 这样，每个线程可以访问和修改自己的数据，而不会影响其他线程。</span><br>JZneedtls<br><span class="hljs-comment">// 将 setg_gcc 函数的地址加载到 SI 寄存器中。</span><br><span class="hljs-comment">// 这是 _cgo_init 函数的第二个参数。</span><br>MOVQ$setg_gcc&lt;&gt;(<span class="hljs-built_in">SB</span>), SI <span class="hljs-comment">// arg 2: setg_gcc</span><br><span class="hljs-comment">// 在使用平台的TLS时不使用这第3和第4个参数。</span><br>MOVQ<span class="hljs-number">$0</span>, DX<br>MOVQ<span class="hljs-number">$0</span>, CX<br><span class="hljs-comment">#ifdef GOOS_android</span><br>MOVQ$runtime·tls_g(<span class="hljs-built_in">SB</span>), DX <span class="hljs-comment">// arg 3: &amp;tls_g</span><br><span class="hljs-comment">// arg 4: TLS base, stored in slot 0 (Android&#x27;s TLS_SLOT_SELF).</span><br><span class="hljs-comment">// Compensate for tls_g (+16).</span><br>MOVQ-<span class="hljs-number">16</span>(TLS), CX<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_windows</span><br>MOVQ$runtime·tls_g(<span class="hljs-built_in">SB</span>), DX <span class="hljs-comment">// arg 3: &amp;tls_g</span><br><span class="hljs-comment">// 调整 Win64 的调用约定。</span><br>MOVQCX, <span class="hljs-built_in">R9</span> <span class="hljs-comment">// arg 4</span><br>MOVQDX, <span class="hljs-built_in">R8</span> <span class="hljs-comment">// arg 3</span><br>MOVQSI, DX <span class="hljs-comment">// arg 2</span><br>MOVQDI, CX <span class="hljs-comment">// arg 1</span><br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">// 前面 MOVQ_cgo_init(SB), AX，这里就是调用 _cgo_init</span><br>CALLAX<br><span class="hljs-comment">// 在 _cgo_init 之后更新 stackguard</span><br>MOVQ$runtime·g0(<span class="hljs-built_in">SB</span>), CX<br>MOVQ(g_stack+stack_lo)(CX), AX<br>ADDQ$const_stackGuard, AX<br>MOVQAX, g_stackguard0(CX)<br>MOVQAX, g_stackguard1(CX)<br><br><span class="hljs-comment">#ifndef GOOS_windows</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">// 针对不同操作系统对 TLS 进行设置</span><br><span class="hljs-symbol">needtls:</span>  <br><span class="hljs-comment">#ifdef GOOS_plan9</span><br><span class="hljs-comment">// skip TLS setup on Plan 9</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_solaris</span><br><span class="hljs-comment">// skip TLS setup on Solaris</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_illumos</span><br><span class="hljs-comment">// skip TLS setup on illumos</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_darwin</span><br><span class="hljs-comment">// skip TLS setup on Darwin</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_openbsd</span><br><span class="hljs-comment">// skip TLS setup on OpenBSD</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef GOOS_windows</span><br>CALLruntime·wintls(<span class="hljs-built_in">SB</span>)<br><span class="hljs-comment">#endif</span><br><br>LEAQruntime·m0+m_tls(<span class="hljs-built_in">SB</span>), DI<br>CALLruntime·settls(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-comment">// 检查 TLS 是否正常工作</span><br>get_tls(BX)<br>MOVQ<span class="hljs-number">$0x123</span>, g(BX)<br>MOVQruntime·m0+m_tls(<span class="hljs-built_in">SB</span>), AX<br>CMPQAX, <span class="hljs-number">$0x123</span><br>JEQ <span class="hljs-number">2</span>(<span class="hljs-built_in">PC</span>)<br>CALLruntime·abort(<span class="hljs-built_in">SB</span>)<br><span class="hljs-symbol">ok:</span><br><span class="hljs-comment">//设置 g0 和 m0 和 TLS</span><br>get_tls(BX)<br>LEAQruntime·g0(<span class="hljs-built_in">SB</span>), CX<br>MOVQCX, g(BX)<br>LEAQruntime·m0(<span class="hljs-built_in">SB</span>), AX<br>MOVQCX, m_g0(AX)<br>MOVQAX, g_m(CX)<br>CLD<br><br><span class="hljs-comment">// 下面的 ifdef NEED_xxx 主要是在检查 CPU 是否支持 Go 运行时系统需要的特性。</span><br><span class="hljs-comment">// 我们需要在设置了 TLS 之后做这个，</span><br><span class="hljs-comment">// 如果失败就跳转到 bad_cpu 报告错误。</span><br><span class="hljs-comment">#ifdef NEED_FEATURES_CX</span><br>MOVL<span class="hljs-number">$0</span>, AX<br>CPUID<br>CMPLAX, <span class="hljs-number">$0</span><br>JEbad_cpu<br>MOVL<span class="hljs-number">$1</span>, AX<br>CPUID<br>ANDL$NEED_FEATURES_CX, CX<br>CMPLCX, $NEED_FEATURES_CX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_MAX_CPUID</span><br>MOVL<span class="hljs-number">$0x80000000</span>, AX<br>CPUID<br>CMPLAX, $NEED_MAX_CPUID<br>JLbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_EXT_FEATURES_BX</span><br>MOVL<span class="hljs-number">$7</span>, AX<br>MOVL<span class="hljs-number">$0</span>, CX<br>CPUID<br>ANDL$NEED_EXT_FEATURES_BX, <span class="hljs-keyword">BX</span><br>CMPLBX, $NEED_EXT_FEATURES_BX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_EXT_FEATURES_CX</span><br>MOVL<span class="hljs-number">$0x80000001</span>, AX<br>CPUID<br>ANDL$NEED_EXT_FEATURES_CX, CX<br>CMPLCX, $NEED_EXT_FEATURES_CX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_OS_SUPPORT_AX</span><br>XORL    CX, CX<br>XGETBV<br>ANDL$NEED_OS_SUPPORT_AX, AX<br>CMPLAX, $NEED_OS_SUPPORT_AX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_DARWIN_SUPPORT</span><br>MOVQ$commpage64_version, <span class="hljs-keyword">BX</span><br>CMPW(BX), <span class="hljs-number">$13</span>  <span class="hljs-comment">// cpu_capabilities64 undefined in versions &lt; 13</span><br>JLbad_cpu<br>MOVQ$commpage64_cpu_capabilities64, <span class="hljs-keyword">BX</span><br>MOVQ(BX), <span class="hljs-keyword">BX</span><br>MOVQ$NEED_DARWIN_SUPPORT, CX<br>ANDQCX, <span class="hljs-keyword">BX</span><br>CMPQBX, CX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">// 检查完 AMD64 不同操作系统是否支持 Go 运行时系统需要的特性后，</span><br><span class="hljs-comment">// 这里执行 runtime·check 对代码做一下运行时检查。</span><br>CALLruntime·check(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-comment">// 复制 argc（命令行参数的数量）到 AX 寄存器，</span><br><span class="hljs-comment">// 然后把 AX 寄存器的值存到栈上。</span><br>MOVL<span class="hljs-number">24</span>(<span class="hljs-built_in">SP</span>), AX<br>MOVLAX, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)<br><span class="hljs-comment">// 复制 argv（命令行参数的数组）到 AX 寄存器，</span><br><span class="hljs-comment">// 然后把 AX 寄存器的值存到栈上。</span><br>MOVQ<span class="hljs-number">32</span>(<span class="hljs-built_in">SP</span>), AX<br>MOVQAX, <span class="hljs-number">8</span>(<span class="hljs-built_in">SP</span>)<br><span class="hljs-comment">// 调用 runtime·args 函数处理命令行参数。</span><br>CALLruntime·args(<span class="hljs-built_in">SB</span>)<br><span class="hljs-comment">// 调用 runtime·osinit 函数初始化操作系统特定的设置。</span><br>CALLruntime·osinit(<span class="hljs-built_in">SB</span>)<br><span class="hljs-comment">// 调用 runtime·schedinit 函数初始化调度器。</span><br>CALLruntime·schedinit(<span class="hljs-built_in">SB</span>)<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">   补充：这是该文件下面对 runtime·mainPC 的声明</span><br><span class="hljs-comment">    // mainPC is a function value for runtime.main, to be passed to newproc.</span><br><span class="hljs-comment">    // The reference to runtime.main is made via ABIInternal, since the</span><br><span class="hljs-comment">    // actual function (not the ABI0 wrapper) is needed by newproc.</span><br><span class="hljs-comment">    DATAruntime·mainPC+0(SB)/8,$runtime·main&lt;ABIInternal&gt;(SB)</span><br><span class="hljs-comment">    */</span><br>        <br>    <span class="hljs-comment">// 取 runtime·mainPC 的地址，这其实就是 runtime 包下的 main() 方法。</span><br>    <span class="hljs-comment">// 它是 Go 语言程序的真正入口，而不是 main.main()。</span><br>MOVQ$runtime·mainPC(<span class="hljs-built_in">SB</span>), AX<br>PUSHQAX<br>    <span class="hljs-comment">// 创建一个新的 goroutine 来运行程序的主函数。</span><br>    <span class="hljs-comment">// 这里还没有正在的运行，因为调度器还没有启动，</span><br>    <span class="hljs-comment">// 只是将 runtime.main 放进 goroutine 的 queue 中等待执行。</span><br>CALLruntime·newproc(<span class="hljs-built_in">SB</span>)<br>POPQAX<br><br><span class="hljs-comment">// 调用 runtime·mstart 函数启动 M（machine，代表一个操作系统线程），</span><br><span class="hljs-comment">// 开始执行 goroutines。</span><br>CALLruntime·mstart(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-comment">//  如果 runtime·mstart 函数返回，那么就调用 runtime·abort 函数终止程序。</span><br><span class="hljs-comment">// 因为 runtime·mstart 函数在正常情况下是不应该返回的，如果返回了，说明有错误发生。</span><br>CALLruntime·abort(<span class="hljs-built_in">SB</span>)<span class="hljs-comment">// mstart should never return</span><br>RET<br><br><span class="hljs-symbol">bad_cpu:</span> <span class="hljs-comment">// 当前 CPU 不支持 Go 运行时系统需要的时候的错误报告。</span><br>MOVQ<span class="hljs-number">$2</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)<br>MOVQ$bad_cpu_msg&lt;&gt;(<span class="hljs-built_in">SB</span>), AX<br>MOVQAX, <span class="hljs-number">8</span>(<span class="hljs-built_in">SP</span>)<br>MOVQ<span class="hljs-number">$84</span>, <span class="hljs-number">16</span>(<span class="hljs-built_in">SP</span>)<br>CALLruntime·write(<span class="hljs-built_in">SB</span>)<br>MOVQ<span class="hljs-number">$1</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)<br>CALLruntime·exit(<span class="hljs-built_in">SB</span>)<br>CALLruntime·abort(<span class="hljs-built_in">SB</span>)<br>RET<br><br><span class="hljs-comment">// Prevent dead-code elimination of debugCallV2, which is</span><br><span class="hljs-comment">// intended to be called by debuggers.</span><br>MOVQ$runtime·debugCallV2&lt;ABIInternal&gt;(<span class="hljs-built_in">SB</span>), AX<br>RET<br></code></pre></td></tr></table></figure><p>整理一下，<code>runtime·rt0_go</code> 的大体过程如下：</p><ol type="1"><li>读取命令行参数，复制参数变量 argc 和 argv 到栈上。</li><li>初始化 g0 栈，g0 是为了调度协程而产生的协程，是 g0是运行时系统的一个特殊的goroutine，它在程序启动时被创建，用于执行系统调用和协程调度。</li><li>获取 CPU 信息。</li><li>如果存在 <code>_cgo_init</code>，这调用它。</li><li>检查并设置线性局部存储（TLS）。</li><li>检查 CPU 是否支持 Go 运行时系统需要的特性。</li><li>完成运行时系统检查和初始化：<ul><li>调用 <code>runtime·check</code> 对代码进行运行时检查。</li><li>调用 <code>runtime·args</code> 函数处理命令行参数。</li><li>调用 <code>runtime·osinit</code> 函数初始化操作系统特定的设置。</li><li>调用 <code>runtime·schedinit</code> 函数初始化调度器。</li></ul></li><li>调用 <code>runtime·newproc</code> 创建一个新的 goroutine来运行程序的主函数。</li><li>调用 <code>runtime·mstart</code> 启动当前的 machine，执行goroutines，执行程序。</li></ol><p>一句话：<code>runtime·rt0_go</code> 是 Go语言运行时的入口点，它负责设置和初始化运行时环境，然后创建 g0 和 m0来运行程序的主函数。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/3EGyo5Q3LRKr4XdNg1dHFr.png"alt="Go 运行时系统初始化流程" /><figcaption aria-hidden="true">Go 运行时系统初始化流程</figcaption></figure><p>了解完 Go 程序的整体启动流程后，我们重点来分析一下其中的<code>runtime·check</code>、<code>runtime·args</code>、<code>runtime·osinit</code>、<code>runtime·schedinit</code>、<code>runtime·newproc</code>和 <code>runtime·mstart</code>。</p><blockquote><p>对了，充分理解 Go 启动流程，可能需要你对 Go 的 GMP 模型有一定的了解。// TODO</p></blockquote><h2 id="runtimecheck">runtime·check</h2><p>在 Goland IDE 上，我们双击 Shift，全局搜索 <code>runtime·check</code>会发现找不到函数的实现。</p><p>Go 语言的运行时系统大部分是用 Go自己编写的，但是有一部分，特别是与平台相关的部分，是用汇编语言编写的。在汇编语言中，调用Go 函数的一种方式是使用 <code>CALL</code>指令和函数的全名，包括包名和函数名。在这种情况下，<code>runtime·check</code>就是调用 <code>runtime</code> 包下的 <code>check()</code> 函数。</p><p>所以我们需要双击 Shift，搜索 <code>runtine.check</code>，即将<code>·</code> 换成<code>.</code>（后面所有函数均是这个道理）。我们会发现<code>check()</code> 位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime1.go">runtime/runtime1.go</a>中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>a     <span class="hljs-type">int8</span><br>b     <span class="hljs-type">uint8</span><br>c     <span class="hljs-type">int16</span><br>d     <span class="hljs-type">uint16</span><br>e     <span class="hljs-type">int32</span><br>f     <span class="hljs-type">uint32</span><br>g     <span class="hljs-type">int64</span><br>h     <span class="hljs-type">uint64</span><br>i, i1 <span class="hljs-type">float32</span><br>j, j1 <span class="hljs-type">float64</span><br>k     unsafe.Pointer<br>l     *<span class="hljs-type">uint16</span><br>m     [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span><br>)<br><span class="hljs-keyword">type</span> x1t <span class="hljs-keyword">struct</span> &#123;<br>x <span class="hljs-type">uint8</span><br>&#125;<br><span class="hljs-keyword">type</span> y1t <span class="hljs-keyword">struct</span> &#123;<br>x1 x1t<br>y  <span class="hljs-type">uint8</span><br>&#125;<br><span class="hljs-keyword">var</span> x1 x1t<br><span class="hljs-keyword">var</span> y1 y1t<br>    <span class="hljs-comment">// 检查各种类型的变量的大小是否符合预期</span><br><span class="hljs-keyword">if</span> unsafe.Sizeof(a) != <span class="hljs-number">1</span> &#123;<br>throw(<span class="hljs-string">&quot;bad a&quot;</span>)<br>&#125;<br>    ...<br>    <span class="hljs-comment">// 检查指针操作</span><br><span class="hljs-keyword">if</span> unsafe.Sizeof(k) != goarch.PtrSize &#123;<br>throw(<span class="hljs-string">&quot;bad k&quot;</span>)<br>&#125;<br>    ...<br><span class="hljs-comment">// 检查结构体中字段的偏移量是否符合预期 </span><br><span class="hljs-keyword">if</span> unsafe.Offsetof(y1.y) != <span class="hljs-number">1</span> &#123;<br>throw(<span class="hljs-string">&quot;bad offsetof y1.y&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// timediv 函数的目的是在 32 位处理器上实现 64 位的除法运算。</span><br>    <span class="hljs-comment">// 由于在 32 位处理器上，64 位的除法运算会被转换为 _divv() 函数调用，</span><br>    <span class="hljs-comment">// 这可能会超出 nosplit 函数的栈限制，所以需要这个特殊的函数来进行处理。</span><br>    <span class="hljs-comment">// //go:nosplit 是一个编译器指令，它告诉编译器不要在这个函数中插入栈分割检查。</span><br>    <span class="hljs-comment">// 这意味着这个函数必须在当前的栈帧中运行，不能增加栈的大小。</span><br>    <span class="hljs-comment">// 如果这个函数需要更多的栈空间，那么它将会导致栈溢出。</span><br><span class="hljs-keyword">if</span> timediv(<span class="hljs-number">12345</span>*<span class="hljs-number">1000000000</span>+<span class="hljs-number">54321</span>, <span class="hljs-number">1000000000</span>, &amp;e) != <span class="hljs-number">12345</span> || e != <span class="hljs-number">54321</span> &#123;<br>throw(<span class="hljs-string">&quot;bad timediv&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// CAS 操作检查</span><br><span class="hljs-keyword">var</span> z <span class="hljs-type">uint32</span><br>z = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> !atomic.Cas(&amp;z, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &#123;<br>throw(<span class="hljs-string">&quot;cas1&quot;</span>)<br>&#125;<br>...<br>    <span class="hljs-comment">// 检查 atomic 原子操作</span><br>m = [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br>atomic.Or8(&amp;m[<span class="hljs-number">1</span>], <span class="hljs-number">0xf0</span>)<br><span class="hljs-keyword">if</span> m[<span class="hljs-number">0</span>] != <span class="hljs-number">1</span> || m[<span class="hljs-number">1</span>] != <span class="hljs-number">0xf1</span> || m[<span class="hljs-number">2</span>] != <span class="hljs-number">1</span> || m[<span class="hljs-number">3</span>] != <span class="hljs-number">1</span> &#123;<br>throw(<span class="hljs-string">&quot;atomicor8&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 测试浮点数 NaN（Not a Number）的行为</span><br>*(*<span class="hljs-type">uint64</span>)(unsafe.Pointer(&amp;j)) = ^<span class="hljs-type">uint64</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> j == j &#123;<br>throw(<span class="hljs-string">&quot;float64nan&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> !(j != j) &#123;<br>throw(<span class="hljs-string">&quot;float64nan1&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 测试 64 位原子操作</span><br>testAtomic64()<br>    <span class="hljs-comment">// 检查栈大小是否是 2 的 n 次幂</span><br><span class="hljs-keyword">if</span> fixedStack != round2(fixedStack) &#123;<br>throw(<span class="hljs-string">&quot;FixedStack is not power-of-2&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 上报编代码的运行时检查中是否有异常</span><br><span class="hljs-keyword">if</span> !checkASM() &#123;<br>throw(<span class="hljs-string">&quot;assembly checks failed&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上：<code>runtime·check</code> 主要是做一些运行时的检查。</p><ol type="1"><li>使用 <code>unsafe.Sizeof</code>函数检查各种类型的变量的大小是否符合预期。</li><li>使用 <code>unsafe.Offsetof</code>函数检查结构体中字段的偏移量是否符合预期。</li><li>测试 <code>timediv</code> 函数检查在 32 位机器上进行 64位除法运算的结果是否符合预期。</li><li>使用 <code>atomic.Cas</code> 函数（Compare andSwap）进行原子比较和交换测试。</li><li>使用 <code>atomic.Or8</code> 和 <code>atomic.And8</code>函数进行原子位操作测试。</li><li>测试浮点数 NaN（Not a Number）的行为。</li><li>调用 <code>testAtomic64</code> 函数测试 64 位的原子操作。</li><li>检查 <code>fixedStack</code> 栈大小是否是 2 的幂。</li><li>调用 <code>checkASM</code>函数检查汇编代码检查运行时中是否有异常。</li></ol><h2 id="runtimeargs">runtime·args</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> runtime<br><br><span class="hljs-keyword">var</span> (<br>argc <span class="hljs-type">int32</span><br>argv **<span class="hljs-type">byte</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">args</span><span class="hljs-params">(c <span class="hljs-type">int32</span>, v **<span class="hljs-type">byte</span>)</span></span> &#123;<br>argc = c<br>argv = v<br>sysargs(c, v)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数比较简单，就是将命令行参数拷贝到 <code>runtime</code>包下的全局变量 <code>argc</code> 和 <code>argv</code> 上。后面在<code>shcedinit()</code> 函数中会调用 <code>goargs()</code> 来遍历 argv将参数复制到 slice 上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goargs</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> GOOS == <span class="hljs-string">&quot;windows&quot;</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>argslice = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, argc)<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">int32</span>(<span class="hljs-number">0</span>); i &lt; argc; i++ &#123;<br>argslice[i] = gostringnocopy(argv_index(argv, i))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runtimeosinit">runtime·osinit</h2><p>这里函数主要是初始化操作系统特点的设置，可以看到这里针对不同操作系统都做了实现：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231209131939116.png"alt="osinit" /><figcaption aria-hidden="true">osinit</figcaption></figure><p>这里我们以 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/os_windows.go">os_windows.go</a>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">osinit</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 获取 asmstdcall 函数的地址，并将其转换为一个不安全的指针。</span><br>    <span class="hljs-comment">// 这通常在需要直接操作内存或进行系统调用的时候使用。</span><br>asmstdcallAddr = unsafe.Pointer(abi.FuncPCABI0(asmstdcall))<br><br>    <span class="hljs-comment">// 加载一些可选的系统调用。</span><br>loadOptionalSyscalls()<br><br>    <span class="hljs-comment">// 阻止显示错误对话框。这可能是为了防止在出现错误时打断用户。</span><br>preventErrorDialogs()<br><br>    <span class="hljs-comment">// 初始化异常处理器，用于处理运行时发生的异常。</span><br>initExceptionHandler()<br><br>    <span class="hljs-comment">// 初始化高分辨率计时器，用于精确的时间测量。</span><br>initHighResTimer()<br>timeBeginPeriodRetValue = osRelax(<span class="hljs-literal">false</span>)<br><br>    <span class="hljs-comment">// 初始化系统目录</span><br>initSysDirectory()<br>    <br>    <span class="hljs-comment">// 启用长路径支持。</span><br>    <span class="hljs-comment">// 在 Windows 中，路径的长度通常限制为 260 个字符。启用长路径支持可以突破这个限制。</span><br>initLongPathSupport()<br><br>    <span class="hljs-comment">// 码获取处理器的数量并将其赋给 ncpu。</span><br>    ncpu = getproccount()<br><br>    <span class="hljs-comment">// 获取内存页的大小并将其赋给 physPageSize，为了后面进行内存管理。</span><br>physPageSize = getPageSize()<br><br>    <span class="hljs-comment">// 调用 SetProcessPriorityBoost 函数，禁用动态优先级提升。</span><br>    <span class="hljs-comment">// 在 Windows 中，动态优先级提升是一种机制，可以根据线程的类型和行为自动调整其优先级。</span><br>    <span class="hljs-comment">// 但在 Go 的环境中，所有的线程都是等价的，都可能进行 GUI、IO、计算等各种操作，</span><br>    <span class="hljs-comment">// 所以动态优先级提升可能会带来问题，因此这里选择禁用它。</span><br>stdcall2(_SetProcessPriorityBoost, currentProcess, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runtimeschedinit">runtime·schedinit ★</h2><p>这个函数就非常重要了，从名字就可以看出来，这是 Go语言调度器的初始化过程。这个函数位于：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>。</p><p>我们可以先来看看 <code>schedinit()</code> 的函数注释，这里也透露了 Go语言程序的启动流程的核心顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The bootstrap sequence is:启动流程顺序：</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//call osinit  1. 调用 osinit</span><br><span class="hljs-comment">//call schedinit2. 调用 schedinit</span><br><span class="hljs-comment">//make &amp; queue new G3. 创建一个协程 G</span><br><span class="hljs-comment">//call runtime·mstart4. 调用 mstart</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The new G calls runtime·main. 5. G 执行 runtime.main</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedinit</span><span class="hljs-params">()</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>接下来我们详细来看看 <code>schedinit()</code> 都做了些什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedinit</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 初始化各种锁，其中 lockRankXXX 指定锁的级别。</span><br>lockInit(&amp;sched.lock, lockRankSched)<br>lockInit(&amp;sched.sysmonlock, lockRankSysmon)<br>lockInit(&amp;sched.deferlock, lockRankDefer)<br>lockInit(&amp;sched.sudoglock, lockRankSudog)<br>lockInit(&amp;deadlock, lockRankDeadlock)<br>lockInit(&amp;paniclk, lockRankPanic)<br>lockInit(&amp;allglock, lockRankAllg)<br>lockInit(&amp;allpLock, lockRankAllp)<br>lockInit(&amp;reflectOffs.lock, lockRankReflectOffs)<br>lockInit(&amp;finlock, lockRankFin)<br>lockInit(&amp;cpuprof.lock, lockRankCpuprof)<br>traceLockInit()<br>lockInit(&amp;memstats.heapStats.noPLock, lockRankLeafRank)<br><br><span class="hljs-comment">// 如果启用了竞态检测，则初始化竞态检测器，</span><br>    <span class="hljs-comment">// 即我们使用 -race 的时候会执行这里。</span><br>gp := getg()<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>gp.racectx, raceprocctx0 = raceinit()<br>&#125;<br><br>    <span class="hljs-comment">// 限制 M 的数量，即线程的数量。</span><br>    <span class="hljs-comment">// maxmcount    int32    // maximum number of m&#x27;s allowed (or die)</span><br>sched.maxmcount = <span class="hljs-number">10000</span><br><br><span class="hljs-comment">// 将调度器设置为初始暂停状态，在必要的初始化完成之前不调度任何协程。</span><br>worldStopped()<br><br>    <span class="hljs-comment">// 进行一系列的系统初始化（内存管理、CPU 设置、栈、算法等）</span><br>moduledataverify()<br>stackinit()<br>mallocinit()<br>godebug := getGodebugEarly()<br>initPageTrace(godebug) <span class="hljs-comment">// must run after mallocinit but before anything allocates</span><br>cpuinit(godebug)       <span class="hljs-comment">// must run before alginit</span><br>alginit()              <span class="hljs-comment">// maps, hash, fastrand must not be used before this call</span><br>fastrandinit()         <span class="hljs-comment">// must run before mcommoninit</span><br>mcommoninit(gp.m, <span class="hljs-number">-1</span>)<br>modulesinit()   <span class="hljs-comment">// provides activeModules</span><br>typelinksinit() <span class="hljs-comment">// uses maps, activeModules</span><br>itabsinit()     <span class="hljs-comment">// uses activeModules</span><br>stkobjinit()    <span class="hljs-comment">// must run before GC starts</span><br><br>    <span class="hljs-comment">// 设置和保存当前 M 的信号掩码</span><br>sigsave(&amp;gp.m.sigmask)<br>initSigmask = gp.m.sigmask<br><br>    <span class="hljs-comment">// 解析程序参数和环境变量</span><br>goargs()<br>goenvs()<br>secure()<br>parsedebugvars()<br>    <br>    <span class="hljs-comment">// 初始化垃圾回收器</span><br>gcinit()<br><br><span class="hljs-comment">// 如果设置了 disableMemoryProfiling，即禁用内存分析，</span><br>    <span class="hljs-comment">// 则将 MemProfileRate 置为 0，关闭内存分析。</span><br><span class="hljs-keyword">if</span> disableMemoryProfiling &#123;<br>MemProfileRate = <span class="hljs-number">0</span><br>&#125;<br><br>    <span class="hljs-comment">// 锁定调度器，处理环境变量 GOMAXPROCS，这是开发者可以设置的允许的最多的 P 的数量。</span><br>lock(&amp;sched.lock)<br>sched.lastpoll.Store(nanotime())<br>procs := ncpu<br><span class="hljs-keyword">if</span> n, ok := atoi32(gogetenv(<span class="hljs-string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="hljs-number">0</span> &#123;<br>procs = n<br>&#125;<br><span class="hljs-keyword">if</span> procresize(procs) != <span class="hljs-literal">nil</span> &#123;<br>throw(<span class="hljs-string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)<br>&#125;<br>unlock(&amp;sched.lock)<br><br><span class="hljs-comment">// 将调度器设置为开始状态。</span><br>worldStarted()<br><br>    <span class="hljs-comment">// 确保构建版本和模块信息被保留在最终的二进制文件中。</span><br><span class="hljs-keyword">if</span> buildVersion == <span class="hljs-string">&quot;&quot;</span> &#123;<br>buildVersion = <span class="hljs-string">&quot;unknown&quot;</span><br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(modinfo) == <span class="hljs-number">1</span> &#123;<br>modinfo = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：<code>schedinit</code> 是 Go语言运行时中的一个函数，负责初始化调度器及其相关组件，如锁、信号掩码、内存分配、以及其他系统级别的设置，确保并发执行环境的正确配置和高效运作。</p><p>具体过程如下：</p><ol type="1"><li><strong>锁初始化</strong>:<ul><li>函数开始时，通过 <code>lockInit</code> 调用初始化了多个锁。在 Go的调度器中，锁用于保护共享资源和调度数据结构，确保在多个线程或协程中的安全访问。每个锁都有一个特定的级别，这有助于防止死锁。</li></ul></li><li><strong>竞态检测器初始化</strong>:<ul><li>如果启用了竞态检测(<code>raceenabled</code>)，则初始化竞态上下文。这对于在开发阶段检测和避免竞态条件非常重要。</li></ul></li><li><strong>调度器设置</strong>:<ul><li><code>sched.maxmcount = 10000</code>设置调度器可以管理的最大线程（M）数目，这对于控制资源使用和性能调优很重要。</li><li><code>worldStopped()</code>将调度器设置为初始暂停状态，在必要的初始化完成之前不调度任何协程。</li></ul></li><li><strong>系统初始化</strong>:<ul><li>接下来调用一系列函数（如 <code>moduledataverify</code>,<code>mallocinit</code>, <code>cpuinit</code>, <code>alginit</code>等）来初始化内存管理、CPU设置、算法等，这些都是调度器正常工作的基础。</li></ul></li><li><strong>环境和调试变量设置</strong>:<ul><li>解析程序参数、环境变量、安全设置和调试变量。</li></ul></li><li><strong>垃圾收集器初始化</strong>:<ul><li><code>gcinit()</code> 初始化垃圾收集器，这是 Go运行时的关键组成部分，负责自动内存管理。</li></ul></li><li><strong>内存分析设置</strong>:<ul><li>根据 <code>disableMemoryProfiling</code>标志决定是否关闭内存分析功能。</li></ul></li><li><strong>处理器数量设置和调度器锁</strong>:<ul><li>锁定调度器来安全地基于环境变量 <code>GOMAXPROCS</code>设置处理器（<code>procs</code>）数量。</li><li>使用 <code>procresize</code>函数根据处理器数量调整调度器的内部结构。</li></ul></li><li><strong>最终步骤和错误检查</strong>:<ul><li>调用 <code>worldStarted()</code>表示调度器已准备好开始调度协程。</li><li>检查和设置构建版本和模块信息，保证这些信息在最终的二进制文件中。</li></ul></li></ol><p>这里有几个地方比较有趣，我们来做一下简单的了解。（可跳过）</p><h3 id="初始化锁-lockinitmutex-rank">初始化锁 lockInit(mutex, rank)</h3><p>我们知道 <code>lockInit(mutex,rank)</code> 是用来初始化锁的，第 2个参数 <code>rank</code> 便是锁的等级。如果这个时候你链接到<code>lcokInit</code> 实现的地方，你会发现默认会跳到 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/lockrank_off.go">lockrank_off.go</a>，而且你会发现，它的实现是空的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:build !goexperiment.staticlockranking</span><br><br><span class="hljs-keyword">package</span> runtime<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lockInit</span><span class="hljs-params">(l *mutex, rank lockRank)</span></span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实 <code>lockInit</code> 还有另外一个实现，在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/lockrank_on.go">lockrank_on.go</a>文件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:build goexperiment.staticlockranking</span><br><br><span class="hljs-keyword">package</span> runtime<br><br><span class="hljs-keyword">const</span> staticLockRanking = <span class="hljs-literal">true</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLockRank</span><span class="hljs-params">(l *mutex)</span></span> lockRank &#123;<br><span class="hljs-keyword">return</span> l.rank<br>&#125;<br></code></pre></td></tr></table></figure><p>这什么意思呢？通过文件名称我们其实就可以猜到了，<code>lockrank_off.go</code>是提供了无锁级别的锁，而 <code>lockrank_on.go</code>是提供了有锁级别的锁。至于应该采用哪一个，是通过 go build 中的<code>goexperiment.staticlockranking</code> 参数来控制的。</p><p>这里涉及一个概念，叫做锁排序（Lock Ranking）：</p><ul><li>锁排序是一种用于避免死锁的技术。在这种机制中，每个锁都被赋予一个等级（或称为“rank”），并且有规则确保锁的获取遵循这些等级的顺序。</li><li>通常，这意味着一个线程在获取等级较低的锁之前，必须先释放所有等级较高的锁。这样可以防止死锁，因为它避免了循环等待条件的发生。</li><li>Go 语言中锁的等级和顺序定义在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/lockrank.go">lockrank.go</a>文件中。</li></ul><p>锁排序的作用：</p><ul><li>在 Go的并发模型中，锁是同步共享资源访问的重要机制。<code>lockInit</code>函数在运行时初始化锁，为其分配等级，有助于维护程序的稳定性和性能。</li><li>锁排序功能的开启或关闭取决于是否需要额外的死锁检测。在开发和调试阶段，开启锁排序可以帮助发现死锁问题。然而，它可能引入额外的性能开销，因此在生产环境中可能会被关闭。</li></ul><p>最后我们来看一下 <code>schedinit()</code> 都初始化了哪些锁：</p><table><thead><tr class="header"><th>Lock</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>sched.lock</td><td>初始化调度器的主锁。这个锁用于控制对调度器的访问，保证调度过程的正确性。</td></tr><tr class="even"><td>sched.sysmonlock</td><td>系统监控锁，用于保护系统监控相关的数据结构。</td></tr><tr class="odd"><td>sched.deferlock</td><td>用于控制延迟执行函数列表的锁。</td></tr><tr class="even"><td>sched.sudoglock</td><td>sudog 是 Go 中表示等待通信的 goroutine 的结构。这个锁保护与 sudog相关的操作。</td></tr><tr class="odd"><td>deadlock</td><td>可能用于检测或防止死锁的锁。</td></tr><tr class="even"><td>paniclk</td><td>在处理 panic 时使用的锁。</td></tr><tr class="odd"><td>allglock</td><td>用于控制对所有 goroutine 列表的访问。</td></tr><tr class="even"><td>allpLock</td><td>控制对所有处理器（P）的访问。</td></tr><tr class="odd"><td>reflectOffs.lock</td><td>用于反射操作的锁。</td></tr><tr class="even"><td>finlock</td><td>管理终结器列表的锁。</td></tr><tr class="odd"><td>cpuprof.lock</td><td>用于 CPU 分析数据的锁。</td></tr><tr class="even"><td>traceLockInit()</td><td>专门用于追踪系统的锁初始化函数。</td></tr><tr class="odd"><td>memstats.heapStats.noPLock</td><td>这是一个特殊的锁，被标记为<code>lockRankLeafRank</code>，意味着它应该是锁层级中的最末端（leaf）。这样的锁应该只在非常短的关键部分中使用，以避免成为死锁的源头。</td></tr></tbody></table><h3 id="信号掩码-initsigmask">信号掩码 initSigmask</h3><p>这两行代码是在搞啥呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">sigsave(&amp;gp.m.sigmask)<br>initSigmask = gp.m.sigmask<br></code></pre></td></tr></table></figure><ul><li><code>sigmask</code> 的中文意思是 <code>信号掩码</code>。</li></ul><p>先看一下源码中 <code>initSigmast</code> 的注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Value to use for signal mask for newly created M&#x27;s.</span><br><span class="hljs-keyword">var</span> initSigmask sigset<br></code></pre></td></tr></table></figure><ul><li><code>initSigmask</code> 是一个变量，存储着用于新创建的M（Machine，即操作系统线程）的初始信号掩码。</li></ul><p>什么是信号掩码：</p><ul><li>信号掩码是操作系统中用于控制信号传递给进程或线程的一种机制。它允许进程或线程指定哪些信号可以被阻塞（暂时忽略）或允许。在多线程环境中，这个机制尤其重要，因为它帮助确保线程安全地处理信号。</li></ul><p>信号掩码的作用：</p><ul><li>信号掩码定义了一组信号，这些信号在特定时间内不会传递给进程或线程，即使这些信号发生了也会被系统挂起。这允许进程或线程在一个稳定的状态下运行，不被特定信号中断。</li><li>这种机制对于处理那些可能在关键操作期间导致不稳定状态的信号特别重要。</li></ul><p>信号掩码的重要性：</p><ul><li>在多线程程序中，不同的线程可能需要响应不同的信号或以不同方式处理相同的信号。通过为每个线程设置适当的信号掩码，可以确保线程只处理对它们来说重要的信号。</li><li>这有助于防止线程在执行关键代码时被不相关的信号打断。</li></ul><p><strong>sigsave(&amp;gp.m.sigmask)</strong>：</p><ul><li><code>sigsave(&amp;gp.m.sigmask)</code> 这个调用是在保存当前 M的信号掩码。<code>gp</code> 指的是当前的 goroutine，<code>gp.m</code>是该 goroutine 正在运行的 M（操作系统线程）。</li><li><code>sigsave</code> 函数的作用是将 <code>gp.m</code>的当前信号掩码保存到提供的地址（在这里是<code>&amp;gp.m.sigmask</code>）。这对于恢复线程的信号掩码到一个已知状态是非常有用的。</li></ul><p><strong>initSigmask = gp.m.sigmask</strong>：</p><ul><li>这一行将 <code>gp.m</code> 的信号掩码赋值给<code>initSigmask</code>。这意味着 <code>initSigmask</code>现在保存了当前 M 的信号掩码，这个掩码将被用作新创建的 M的初始信号掩码。</li><li>这是一个重要的步骤，因为它确保了所有新创建的 M 都将具有与当前 M相同的信号处理行为。</li><li>这意味着所有新线程都会以一致的信号掩码启动，这有助于避免由于不同线程处理信号的不一致性导致的问题。</li></ul><p>总体来说，Go语言在其运行时中这样处理信号掩码，是为了确保在并发执行和线程调度中能够安全、一致地处理信号，这对于维护高效和稳定的运行时环境至关重要。</p><h3 id="初始化垃圾回收器-gcinit">初始化垃圾回收器 gcinit()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcinit</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 检查 workbuf 结构体的大小是否等于预期的 _WorkbufSize。</span><br>    <span class="hljs-comment">// 如果不是，抛出异常。这是为了确保 workbuf 的大小是最优的，</span><br>    <span class="hljs-comment">// workbuf 用于垃圾回收过程中的内部工作。</span><br>    <span class="hljs-keyword">if</span> unsafe.Sizeof(workbuf&#123;&#125;) != _WorkbufSize &#123;<br>       throw(<span class="hljs-string">&quot;size of Workbuf is suboptimal&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 第一个垃圾回收周期不进行扫描操作。</span><br>    <span class="hljs-comment">// 在 Go 的垃圾回收过程中，扫描是回收前清理内存的重要步骤。</span><br>    sweep.active.state.Store(sweepDrainedMask)<br><br>    <span class="hljs-comment">// 使用环境变量 GOGC 和 GOMEMLIMIT 来设置初始的垃圾回收百分比和内存限制。</span><br>    gcController.init(readGOGC(), readGOMEMLIMIT())<br><br>    <span class="hljs-comment">// 初始化用于控制垃圾回收工作流程的信号量。</span><br>    <span class="hljs-comment">// 这些信号量用于同步垃圾回收过程中的不同阶段。</span><br>    work.startSema = <span class="hljs-number">1</span><br>    work.markDoneSema = <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment">// 初始化了用于垃圾回收过程中的各种锁。</span><br>    <span class="hljs-comment">// 这些锁用于保护垃圾回收相关数据结构的并发访问，确保垃圾回收过程的线程安全。</span><br>    lockInit(&amp;work.sweepWaiters.lock, lockRankSweepWaiters)<br>    lockInit(&amp;work.assistQueue.lock, lockRankAssistQueue)<br>    lockInit(&amp;work.wbufSpans.lock, lockRankWbufSpans)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *gcControllerState)</span></span> init(gcPercent <span class="hljs-type">int32</span>, memoryLimit <span class="hljs-type">int64</span>) &#123;<br>    <span class="hljs-comment">// 设置 heapMinimum 为默认的最小堆大小。</span><br>    <span class="hljs-comment">// 这是垃圾回收器考虑启动新回收周期前的最小堆内存大小。</span><br>c.heapMinimum = defaultHeapMinimum<br>    <br>    <span class="hljs-comment">// 将 triggered 设置为 uint64 的最大值。</span><br>    <span class="hljs-comment">// 这个字段用于表示触发垃圾回收的内存阈值，</span><br>    <span class="hljs-comment">// 这里的设置意味着在初始状态下不会自动触发垃圾回收</span><br>c.triggered = ^<span class="hljs-type">uint64</span>(<span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-comment">// 设置垃圾回收的百分比阈值。</span><br>    <span class="hljs-comment">// gcPercent 参数表示触发垃圾回收的内存增长百分比。</span><br>    <span class="hljs-comment">// 这个设置控制了堆内存增长到多少百分比时会触发垃圾回收。</span><br>c.setGCPercent(gcPercent)<br>    <br>    <span class="hljs-comment">// 设置内存限制。</span><br>    <span class="hljs-comment">// memoryLimit 参数可能表示堆内存的最大限制，</span><br>    <span class="hljs-comment">// 用于控制垃圾回收器在内存使用方面的行为。</span><br>c.setMemoryLimit(memoryLimit)<br>    <br>    <span class="hljs-comment">// 提交垃圾回收控制器的当前设置，并指示第一次垃圾回收周期没有扫描（sweep）阶段。</span><br>    <span class="hljs-comment">// 在 Go 的垃圾回收中，扫描是回收周期的一部分，这里指明在第一次垃圾回收时跳过扫描阶段。</span><br>c.commit(<span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runtimenewproc">runtime·newproc ★</h2><p>初始化完调度器后，就进入到创建 g0的阶段了，我们需要一个协程来运行程序的入口：<code>runtime.main</code>。</p><p><code>newproc()</code> 的作用如注释所说：<strong>创建一个新的goroutine 来执行 <code>fn</code>，并将它放入等待运行的 g队列中。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create a new g running fn.</span><br><span class="hljs-comment">// Put it on the queue of g&#x27;s waiting to run.</span><br><span class="hljs-comment">// The compiler turns a go statement into a call to this.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc</span><span class="hljs-params">(fn *funcval)</span></span> &#123;<br>gp := getg()<span class="hljs-comment">// 获取当前协程</span><br>pc := getcallerpc()<span class="hljs-comment">// 获取当前程序计数器</span><br>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 在系统栈上执行新 goroutine 的创建</span><br>newg := newproc1(fn, gp, pc)<span class="hljs-comment">// 创建新 goroutine</span><br><br>pp := getg().m.p.ptr()<span class="hljs-comment">// 获取当前 M 绑定的 P</span><br>runqput(pp, newg, <span class="hljs-literal">true</span>)<span class="hljs-comment">// 将新创建的 goroutine 放入 P 的本地队列中</span><br><br><span class="hljs-keyword">if</span> mainStarted &#123;<br>wakep()<span class="hljs-comment">// 如果主程序已经启动，则唤醒或启动一个 M，以确保新的 goroutine 有机会被执行</span><br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>重点来看一下 <code>newproc1()</code> 和 <code>runqput()</code>。</p><h3 id="创建协程-newproc1">创建协程 newproc1()</h3><p>这段代码的主要作用是创建一个新的 goroutine并设置其初始状态，以便它可以被调度器安排运行。它处理了从分配 goroutine的内存到设置其栈空间和调度信息等一系列步骤。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个新的 goroutine，状态为 _Grunnable，从函数 fn 开始执行。</span><br><span class="hljs-comment">// callerpc 是创建此 goroutine 的 go 语句的地址。</span><br><span class="hljs-comment">// 调用者负责将新的 g 添加到调度器中。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">(fn *funcval, callergp *g, callerpc <span class="hljs-type">uintptr</span>)</span></span> *g &#123;<br><span class="hljs-keyword">if</span> fn == <span class="hljs-literal">nil</span> &#123;<br>fatal(<span class="hljs-string">&quot;go of nil func value&quot;</span>) <span class="hljs-comment">// 如果 fn 是 nil，抛出致命错误</span><br>&#125;<br><br>mp := acquirem() <span class="hljs-comment">// 禁用抢占，因为我们在局部变量中持有 M 和 P</span><br>pp := mp.p.ptr()<br>newg := gfget(pp) <span class="hljs-comment">// 尝试从 P 的空闲列表中获取一个 g</span><br><span class="hljs-keyword">if</span> newg == <span class="hljs-literal">nil</span> &#123;<br>newg = malg(stackMin) <span class="hljs-comment">// 如果没有空闲的 g，创建一个新的</span><br>casgstatus(newg, _Gidle, _Gdead) <span class="hljs-comment">// 将 g 的状态从 _Gidle 改为 _Gdead</span><br>allgadd(newg) <span class="hljs-comment">// 将新的 g 添加到所有 goroutine 的列表中</span><br>&#125;<br><span class="hljs-keyword">if</span> newg.stack.hi == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;newproc1: newg missing stack&quot;</span>) <span class="hljs-comment">// 如果新的 g 没有栈，抛出异常</span><br>&#125;<br><br><span class="hljs-keyword">if</span> readgstatus(newg) != _Gdead &#123;<br>throw(<span class="hljs-string">&quot;newproc1: new g is not Gdead&quot;</span>) <span class="hljs-comment">// 确保新的 g 的状态为 _Gdead</span><br>&#125;<br><br>totalSize := <span class="hljs-type">uintptr</span>(<span class="hljs-number">4</span>*goarch.PtrSize + sys.MinFrameSize) <span class="hljs-comment">// 计算额外的栈空间大小</span><br>totalSize = alignUp(totalSize, sys.StackAlign) <span class="hljs-comment">// 栈空间对齐</span><br>sp := newg.stack.hi - totalSize <span class="hljs-comment">// 设置栈指针</span><br>spArg := sp<br><span class="hljs-keyword">if</span> usesLR &#123;<br>*(*<span class="hljs-type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="hljs-number">0</span> <span class="hljs-comment">// 针对 LR 架构，设置调用者的 LR</span><br>prepGoExitFrame(sp)<br>spArg += sys.MinFrameSize<br>&#125;<br><br>memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched)) <span class="hljs-comment">// 清除调度器的内存</span><br>newg.sched.sp = sp <span class="hljs-comment">// 设置调度器的栈指针</span><br>newg.stktopsp = sp <span class="hljs-comment">// 设置栈顶指针</span><br><span class="hljs-comment">// 设置调度器的程序计数器，+PCQuantum 使得前一个指令在同一函数中</span><br>newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum <br>newg.sched.g = guintptr(unsafe.Pointer(newg)) <span class="hljs-comment">// 设置调度器的 g 指针</span><br>gostartcallfn(&amp;newg.sched, fn) <span class="hljs-comment">// 启动新的 g 执行函数 fn</span><br>newg.parentGoid = callergp.goid <span class="hljs-comment">// 设置新 g 的父 goroutine ID</span><br>newg.gopc = callerpc <span class="hljs-comment">// 设置新 g 的创建位置</span><br>newg.ancestors = saveAncestors(callergp) <span class="hljs-comment">// 保存祖先信息</span><br>newg.startpc = fn.fn <span class="hljs-comment">// 设置新 g 的起始函数地址</span><br><span class="hljs-keyword">if</span> isSystemGoroutine(newg, <span class="hljs-literal">false</span>) &#123;<br>sched.ngsys.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 如果是系统 goroutine，增加计数</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> mp.curg != <span class="hljs-literal">nil</span> &#123;<br>newg.labels = mp.curg.labels <span class="hljs-comment">// 只有用户 goroutines 继承 pprof 标签</span><br>&#125;<br><span class="hljs-keyword">if</span> goroutineProfile.active &#123;<br>newg.goroutineProfiled.Store(goroutineProfileSatisfied) <span class="hljs-comment">// 标记不需要纳入 goroutine 分析</span><br>&#125;<br>&#125;<br>newg.trackingSeq = <span class="hljs-type">uint8</span>(fastrand()) <span class="hljs-comment">// 设置追踪序列号</span><br><span class="hljs-keyword">if</span> newg.trackingSeq%gTrackingPeriod == <span class="hljs-number">0</span> &#123;<br>newg.tracking = <span class="hljs-literal">true</span> <span class="hljs-comment">// 是否启用追踪</span><br>&#125;<br>casgstatus(newg, _Gdead, _Grunnable) <span class="hljs-comment">// 将新 g 的状态从 _Gdead 改为 _Grunnable</span><br>gcController.addScannableStack(pp, <span class="hljs-type">int64</span>(newg.stack.hi-newg.stack.lo)) <span class="hljs-comment">// 将新 g 的栈添加到可扫描栈列表</span><br><br><span class="hljs-keyword">if</span> pp.goidcache == pp.goidcacheend &#123;<br>pp.goidcache = sched.goidgen.Add(_GoidCacheBatch) <span class="hljs-comment">// 分配新的 goroutine ID</span><br>pp.goidcache -= _GoidCacheBatch - <span class="hljs-number">1</span><br>pp.goidcacheend = pp.goidcache + _GoidCacheBatch<br>&#125;<br>newg.goid = pp.goidcache <span class="hljs-comment">// 设置新 g 的 ID</span><br>pp.goidcache++<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>newg.racectx = racegostart(callerpc) <span class="hljs-comment">// 设置竞态检测上下文</span><br>newg.raceignore = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> newg.labels != <span class="hljs-literal">nil</span> &#123;<br>racereleasemergeg(newg, unsafe.Pointer(&amp;labelSync)) <span class="hljs-comment">// 同步竞态检测和信号处理</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoCreate(newg, newg.startpc) <span class="hljs-comment">// 记录追踪信息</span><br>&#125;<br>releasem(mp) <span class="hljs-comment">// 释放当前 M</span><br><br><span class="hljs-keyword">return</span> newg <span class="hljs-comment">// 返回新创建的 goroutine</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231210231623561.png"alt="newproc1() 函数概述" /><figcaption aria-hidden="true">newproc1() 函数概述</figcaption></figure><p>有几个地方比较有趣，我们可以来研究一下。</p><h4 id="获取-g">获取 g</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The minimum size of stack used by Go code</span><br>stackMin = <span class="hljs-number">2048</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">()</span></span> &#123;<br>    ...<br>    newg := gfget(pp) <span class="hljs-comment">// 尝试从 P 的空闲列表中获取一个 g</span><br>    <span class="hljs-keyword">if</span> newg == <span class="hljs-literal">nil</span> &#123;<br>        newg = malg(stackMin) <span class="hljs-comment">// 如果没有空闲的 g，创建一个新的</span><br>        casgstatus(newg, _Gidle, _Gdead) <span class="hljs-comment">// 将 g 的状态从 _Gidle 改为 _Gdead</span><br>        allgadd(newg) <span class="hljs-comment">// 将新的 g 添加到所有 goroutine 的列表中</span><br>    &#125;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里可以看出，Go 语言每个新创建的协程分配的默认大小就是<code>stackMin</code>，即 <code>2KB</code>。</p><p>其实 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/stack.go">statck.go</a>还定义了另外一个字段，即栈最大为 <code>2GB</code>，所以我们可以知道，Go协程栈大小 <code>[2KB, 2GB]</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> maxstacksize <span class="hljs-type">uintptr</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span> <span class="hljs-comment">// enough until runtime.main sets it for real</span><br></code></pre></td></tr></table></figure><p>另外我们可以看出来，Go 语言会尽可能重用现有的空闲goroutine，以减少内存分配的开销，提供创建新 goroutine 的效率。</p><p>重用的具体逻辑在 <code>gfget(pp)</code> 中，这个函数的作用是从与当前M 绑定的 P 的空闲列表中获取一个空闲的g，如果没有，则尝试从全局空闲列表中获取 g。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get from gfree list.</span><br><span class="hljs-comment">// If local list is empty, grab a batch from global list.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gfget</span><span class="hljs-params">(pp *p)</span></span> *g &#123;<br>retry:<br>    <span class="hljs-comment">// 如果当前 P 的空闲队列为空，并且全局空闲队列中有可用的 goroutine，则进行下列操作。</span><br><span class="hljs-keyword">if</span> pp.gFree.empty() &amp;&amp; (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) &#123;<br>        <span class="hljs-comment">// 枷锁全局空闲列表</span><br>lock(&amp;sched.gFree.lock)<br><span class="hljs-comment">// 将最多 32 个空闲的 g 从全局列表中移动到当前 P 的空闲列表</span><br><span class="hljs-keyword">for</span> pp.gFree.n &lt; <span class="hljs-number">32</span> &#123;<br><span class="hljs-comment">// 优先选择有栈的 g</span><br>gp := sched.gFree.stack.pop()<br><span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-comment">// 实在没有栈，也可以接受</span><br>gp = sched.gFree.noStack.pop()<br><span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>sched.gFree.n--<br>pp.gFree.push(gp)<br>pp.gFree.n++<br>&#125;<br>unlock(&amp;sched.gFree.lock)<br>        <span class="hljs-comment">// 一直尝试，知道 P 有空闲 g，或者全局列表也没有空闲 g 了，就退出 for 循环，进行下面的操作。</span><br><span class="hljs-keyword">goto</span> retry<br>&#125;<br>    <br>    <span class="hljs-comment">// 从 P 的空闲列表中取出一个 g</span><br>gp := pp.gFree.pop()<br><span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>pp.gFree.n--<br>    <br>    <span class="hljs-comment">// 检查获取到的 g 是否有一个有效的栈，如果栈不符合预期的大小，则释放旧栈</span><br><span class="hljs-keyword">if</span> gp.stack.lo != <span class="hljs-number">0</span> &amp;&amp; gp.stack.hi-gp.stack.lo != <span class="hljs-type">uintptr</span>(startingStackSize) &#123;<br>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>stackfree(gp.stack)<br>gp.stack.lo = <span class="hljs-number">0</span><br>gp.stack.hi = <span class="hljs-number">0</span><br>gp.stackguard0 = <span class="hljs-number">0</span><br>&#125;)<br>&#125;<br>    <span class="hljs-comment">// 如果 g 没有有效的栈，或者刚刚被释放了，则分配新栈给 g</span><br><span class="hljs-keyword">if</span> gp.stack.lo == <span class="hljs-number">0</span> &#123;<br>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>gp.stack = stackalloc(startingStackSize)<br>&#125;)<br>gp.stackguard0 = gp.stack.lo + stackGuard<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racemalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &#123;<br>msanmalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)<br>&#125;<br><span class="hljs-keyword">if</span> asanenabled &#123;<br>asanunpoison(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> gp<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>startingStackSize</code> 表示新创建的 goroutine开始时的栈大小。它被初始化为 <code>fixedStack</code>的值。<code>startingStackSize</code>在每次垃圾回收（GC）后可能会更新，以反映在 GC过程中扫描的栈的平均大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> startingStackSize <span class="hljs-type">uint32</span> = fixedStack<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcComputeStartingStackSize</span><span class="hljs-params">()</span></span> &#123;<br>...<br>    <span class="hljs-comment">// 求出栈平均大小</span><br>avg := scannedStackSize/scannedStacks + stackGuard<br><br><span class="hljs-keyword">if</span> avg &gt; <span class="hljs-type">uint64</span>(maxstacksize) &#123;<br>avg = <span class="hljs-type">uint64</span>(maxstacksize)<br>&#125;<br><span class="hljs-keyword">if</span> avg &lt; fixedStack &#123;<br>avg = fixedStack<br>&#125;<br>    <span class="hljs-comment">// 更新 startingStackSize</span><br>startingStackSize = <span class="hljs-type">uint32</span>(round2(<span class="hljs-type">int32</span>(avg)))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="初始化协程栈">初始化协程栈</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">totalSize := <span class="hljs-type">uintptr</span>(<span class="hljs-number">4</span>*goarch.PtrSize + sys.MinFrameSize) <span class="hljs-comment">// 计算额外的栈空间大小</span><br>totalSize = alignUp(totalSize, sys.StackAlign) <span class="hljs-comment">// 栈空间对齐</span><br>sp := newg.stack.hi - totalSize <span class="hljs-comment">// 设置栈指针</span><br>spArg := sp<br><span class="hljs-keyword">if</span> usesLR &#123;<br>    *(*<span class="hljs-type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="hljs-number">0</span> <span class="hljs-comment">// 针对 LR 架构，设置调用者的 LR</span><br>    prepGoExitFrame(sp)<br>    spArg += sys.MinFrameSize<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1. 计算额外的栈空间大小</strong>:</p><p><code>totalSize := uintptr(4*goarch.PtrSize + sys.MinFrameSize)</code>这行代码计算新 goroutine 需要的额外栈空间大小。</p><p><code>4*goarch.PtrSize</code>是为了留出足够的空间来存储函数调用过程中的一些额外信息（例如返回地址、寄存器保存等）。</p><p><code>sys.MinFrameSize</code>：是系统为每个栈帧保留的最小空间，用于存储一些特定于架构的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MinFrameSize is the size of the system-reserved words at the bottom</span><br><span class="hljs-comment">// of a frame (just above the architectural stack pointer).</span><br><span class="hljs-comment">// It is zero on x86 and PtrSize on most non-x86 (LR-based) systems.</span><br><span class="hljs-comment">// On PowerPC it is larger, to cover three more reserved words:</span><br><span class="hljs-comment">// the compiler word, the link editor word, and the TOC save word.</span><br><span class="hljs-keyword">const</span> MinFrameSize = goarch.MinFrameSize<br></code></pre></td></tr></table></figure><p><code>goarch.PtrSize</code>：指针大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PtrSize is the size of a pointer in bytes - unsafe.Sizeof(uintptr(0)) but as an ideal constant.</span><br><span class="hljs-comment">// It is also the size of the machine&#x27;s native word size (that is, 4 on 32-bit systems, 8 on 64-bit).</span><br><span class="hljs-keyword">const</span> PtrSize = <span class="hljs-number">4</span> &lt;&lt; (^<span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">63</span>)<br></code></pre></td></tr></table></figure><p><strong>2. 栈空间对齐</strong>:</p><p><code>totalSize = alignUp(totalSize, sys.StackAlign)</code>:根据系统的栈对齐要求调整 <code>totalSize</code>的大小。栈对齐是为了确保栈上的数据按照硬件要求的边界对齐，这通常是为了提高访问效率或满足特定的硬件要求。</p><p><strong>3. 设置栈指针 (<code>sp</code>)</strong>:</p><p><code>sp := newg.stack.hi - totalSize</code>: 计算新 goroutine的栈顶指针。<code>newg.stack.hi</code> 是分配给这个 goroutine的栈的高地址（栈顶），从这里向下分配空间。通过从栈顶地址减去计算出的<code>totalSize</code>，设置新的栈顶位置。</p><p><strong>4. 处理链接寄存器（LR）架构</strong>:</p><p>在某些架构上（如ARM、PowerPC），函数调用的返回地址不是存储在栈上，而是存储在一个名为链接寄存器（LR）的特殊寄存器中。这几行代码检查是否在这种架构上运行(<code>usesLR</code>)。</p><ul><li>如果是，则在栈上的适当位置存储一个 0 值作为返回地址，并调用<code>prepGoExitFrame</code> 来准备 goroutine退出时的栈帧。这是为了模拟在非 LR 架构上的栈帧结构。</li><li><code>spArg</code>是一个辅助变量，用于记录参数传递时应该使用的栈地址。在 LR架构上，它需要根据 <code>sys.MinFrameSize</code>进行调整，以保证函数参数的正确位置。</li></ul><h3 id="放入队列-runqput">放入队列 runqput()</h3><p><code>runqput()</code> 负责将 goroutine (<code>gp</code>)放入到本地可运行队列或全局队列中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runqput 尝试将 g 放入当前的执行队列中</span><br><span class="hljs-comment">// 如果 next=false，则将 g 放在队列末尾，</span><br><span class="hljs-comment">// 如果 next=true，则将 g 放在 pp.runnext，即下一个要执行的 goroutine。</span><br><span class="hljs-comment">// 如果本地队列满了，则加入到全局队列。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqput</span><span class="hljs-params">(pp *p, gp *g, next <span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 如果启用了随机调度器 (randomizeScheduler)，</span><br>    <span class="hljs-comment">// 并且调用者指示将 goroutine 放入 runnext 位置 (next 为 true)，</span><br>    <span class="hljs-comment">// 则有 50% 的概率将 next 设置为 false，以随机地将 goroutine 放入队列尾部。</span><br><span class="hljs-keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrandn(<span class="hljs-number">2</span>) == <span class="hljs-number">0</span> &#123;<br>next = <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">if</span> next &#123;<br>retryNext:<br>        <span class="hljs-comment">// 如果为 next，则尝试将 p 放入 pp.runnext 插槽</span><br>oldnext := pp.runnext<br><span class="hljs-keyword">if</span> !pp.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;<br><span class="hljs-keyword">goto</span> retryNext<br>&#125;<br>        <span class="hljs-comment">// 如果这个槽之前没有被占用，则直接返回</span><br><span class="hljs-keyword">if</span> oldnext == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>        <span class="hljs-comment">// 如果这个槽之前已经被占用了，则剔除旧 goroutine，</span><br>        <span class="hljs-comment">// 然后进行下面的逻辑，即将其放入常规的运行队列中</span><br>gp = oldnext.ptr()<br>&#125;<br><br>retry:<br>h := atomic.LoadAcq(&amp;pp.runqhead) <span class="hljs-comment">// 取出队列头部</span><br>t := pp.runqtail<span class="hljs-comment">// 取出队列尾部</span><br>    <span class="hljs-comment">// 如果还没满，则将 gp 放入本地队列中（可能是新 g，也可能是之前在 runnext 的 g</span><br><span class="hljs-keyword">if</span> t-h &lt; <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)) &#123;<br>pp.runq[t%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].set(gp)<br>atomic.StoreRel(&amp;pp.runqtail, t+<span class="hljs-number">1</span>) <span class="hljs-comment">// store-release, makes the item available for consumption</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">// 如果本地队列满了，则尝试将其放入全局队列中</span><br><span class="hljs-keyword">if</span> runqputslow(pp, gp, h, t) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">goto</span> retry<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>runqputslow()</code> 不仅会尝试将 <code>gp</code>放入全局队列中，还会尝试将本地队列的部分 g放入全局队列中，因为这个时候本地队列已经满了，放入全局队列中就有机会被其他P 所调度，减少饥饿。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Put g and a batch of work from local runnable queue on global queue.</span><br><span class="hljs-comment">// Executed only by the owner P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqputslow</span><span class="hljs-params">(pp *p, gp *g, h, t <span class="hljs-type">uint32</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <br>    <span class="hljs-comment">// 初始化一个数组 batch，大小为本地队列的一半，</span><br>    <span class="hljs-comment">// 它用来存储将要移动到全局队列的 goroutine。</span><br><span class="hljs-keyword">var</span> batch [<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]*g<br><br>n := t - h<br>n = n / <span class="hljs-number">2</span><br>    <span class="hljs-comment">// 只有本地队列满才这么操作</span><br><span class="hljs-keyword">if</span> n != <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span>) &#123;<br>throw(<span class="hljs-string">&quot;runqputslow: queue is not full&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 将本地队列一半的 g 复制到 batch 中</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i] = pp.runq[(h+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br>&#125;<br>    <span class="hljs-comment">// CAS 更新本地队列头指针，如果失败，则返回</span><br><span class="hljs-keyword">if</span> !atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123; <span class="hljs-comment">// cas-release, commits consume</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>    <span class="hljs-comment">// 将当前要调度的 gp 放入 batch 的末尾</span><br>batch[n] = gp<br><br>    <span class="hljs-comment">// 如果启动了随机调度器，则随机化 batch 数组</span><br><span class="hljs-keyword">if</span> randomizeScheduler &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">1</span>); i &lt;= n; i++ &#123;<br>j := fastrandn(i + <span class="hljs-number">1</span>)<br>batch[i], batch[j] = batch[j], batch[i]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 链接 goroutine，以便它们可以作为一个连续的队列被处理</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i].schedlink.set(batch[i+<span class="hljs-number">1</span>])<br>&#125;<br><span class="hljs-keyword">var</span> q gQueue<br>q.head.set(batch[<span class="hljs-number">0</span>])<br>q.tail.set(batch[n])<br><br><span class="hljs-comment">// 将 batch 放入全局队列中</span><br>lock(&amp;sched.lock)<br>globrunqputbatch(&amp;q, <span class="hljs-type">int32</span>(n+<span class="hljs-number">1</span>))<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231210231353833.png"alt="runqput() 函数概述" /><figcaption aria-hidden="true">runqput() 函数概述</figcaption></figure><h3 id="总结">总结</h3><p>到这里我们可以总结，<code>runtime·newproc</code>的核心功能就是初始化一个新的goroutine，并将其放入队列中进行调度。其中</p><ul><li><code>newproc1()</code> 会新建或复用空闲的goroutine，然后初始化其栈空间和调度信息；</li><li><code>runqput()</code> 会优先将 g放入本地队列中调度，如果本地队列满了，会连带本地队列中一半的 goroutine一起转移到全局队列中调度。</li></ul><h2 id="runtimemstart">runtime·mstart</h2><p>调度器 m0 和主协程 g0都初始化完毕了，这个时候就可以启动调度器来调度协程工作了。</p><p>我们找到 <code>mstart()</code> 函数的声明，位于：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// mstart is the entry-point for new Ms.</span><br><span class="hljs-comment">// It is written in assembly, uses ABI0, is marked TOPFRAME, and calls mstart0.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstart</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>可以看到，这里 <code>mstart()</code>是没用函数体的，通过注释我们可以知道这个函数的实现部分是用汇编实现的，Go编译器会在编译的时候往这个函数里面插入相关指令。另外注释也告诉我们，这里最终其实就是调用<code>mstart0()</code> 函数。我们找到相关的汇编代码，果然是如此：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">TEXT</span> runtime·mstart(<span class="hljs-built_in">SB</span>),NOSPLIT<span class="hljs-title">|TOPFRAME,$0</span><br><span class="hljs-title">CALLruntime·mstart0(SB)</span><br><span class="hljs-title">RET // not reached</span><br></code></pre></td></tr></table></figure><p><code>mstart0()</code> 就在 <code>mstart()</code> 的下面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstart0</span><span class="hljs-params">()</span></span> &#123;<br>gp := getg()<br>osStack := gp.stack.lo == <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> osStack &#123;<br><span class="hljs-comment">// Initialize stack bounds from system stack.</span><br><span class="hljs-comment">// Cgo may have left stack size in stack.hi.</span><br><span class="hljs-comment">// minit may update the stack bounds.</span><br>size := gp.stack.hi<br><span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> &#123;<br>size = <span class="hljs-number">8192</span> * sys.StackGuardMultiplier<br>&#125;<br>gp.stack.hi = <span class="hljs-type">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))<br>gp.stack.lo = gp.stack.hi - size + <span class="hljs-number">1024</span><br>&#125;<br><span class="hljs-comment">// Initialize stack guard so that we can start calling regular</span><br><span class="hljs-comment">// Go code.</span><br>gp.stackguard0 = gp.stack.lo + stackGuard<br><span class="hljs-comment">// This is the g0, so we can also call go:systemstack</span><br><span class="hljs-comment">// functions, which check stackguard1.</span><br>gp.stackguard1 = gp.stackguard0<br>mstart1()<br><span class="hljs-comment">// Exit this thread.</span><br><span class="hljs-keyword">if</span> mStackIsSystemAllocated() &#123;<br><span class="hljs-comment">// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate</span><br><span class="hljs-comment">// the stack, but put it in gp.stack before mstart,</span><br><span class="hljs-comment">// so the logic above hasn&#x27;t set osStack yet.</span><br>osStack = <span class="hljs-literal">true</span><br>&#125;<br>mexit(osStack)<br>&#125;<br></code></pre></td></tr></table></figure><p>简单过一下 <code>mstart0()</code> 后，我们会发现其实<code>mstart0()</code> 也不是关键，关键是 <code>mstart1()</code>。</p><p>我们先对 <code>mstart0()</code> 做一个简单的总结：它是 Go语言运行时中新M（操作系统线程）的入口点。这个函数负责初始化新线程的栈和一些其他设置，然后调用<code>mstart1</code> 来继续线程的初始化过程。</p><p>我们继续来看<code>mstart1()</code>，它用于进一步设置新线程并最终将控制权交给调度器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstart1</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 获取当前协程</span><br>gp := getg()<br>    <span class="hljs-comment">// 只有 g0 协程可以执行 mstart1()，即启动 m0。</span><br>    <span class="hljs-comment">// 每一个 M 都有一个特殊的 goroutine，其被称为 g0，它用于执行系统级任务。</span><br><span class="hljs-keyword">if</span> gp != gp.m.g0 &#123;<br>throw(<span class="hljs-string">&quot;bad runtime·mstart&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 设置 gp.sched 调度信息，以便 goroutine 能够在未来被正确调度。</span><br>gp.sched.g = guintptr(unsafe.Pointer(gp))<span class="hljs-comment">// goroutine 指针</span><br>gp.sched.pc = getcallerpc()<span class="hljs-comment">// 程序计数器</span><br>gp.sched.sp = getcallersp()<span class="hljs-comment">// 栈指针</span><br><br>    <span class="hljs-comment">// 初始化于汇编相关的设置。</span><br>asminit()<br>    <span class="hljs-comment">// 初始化当前 M 的线程局部存储和其他线程相关的数据。</span><br>minit()<br><br><span class="hljs-comment">// 如果是 m0，则安装信号处理器</span><br><span class="hljs-keyword">if</span> gp.m == &amp;m0 &#123;<br>mstartm0()<br>&#125;<br><br>    <span class="hljs-comment">// 如果 M 启动时配置了函数，则调用它</span><br><span class="hljs-keyword">if</span> fn := gp.m.mstartfn; fn != <span class="hljs-literal">nil</span> &#123;<br>fn()<br>&#125;<br><br>    <span class="hljs-comment">// 如果当前现场不是 m0（主线程），则获取一个 P，准备开始执行 goroutine</span><br><span class="hljs-keyword">if</span> gp.m != &amp;m0 &#123;<br>acquirep(gp.m.nextp.ptr())<br>gp.m.nextp = <span class="hljs-number">0</span><br>&#125;<br>    <span class="hljs-comment">// 调用 schedule() 将控制权交给调度器，开始执行 goroutine</span><br>schedule()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstartm0</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> (iscgo || GOOS == <span class="hljs-string">&quot;windows&quot;</span>) &amp;&amp; !cgoHasExtraM &#123;<br>cgoHasExtraM = <span class="hljs-literal">true</span><br>newextram()<br>&#125;<br>    <span class="hljs-comment">// 安装信号处理器</span><br>initsig(<span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>schedule()</code> 是调度器的具体调度过程，这部分会在 GMP篇章进行展开（TODO 😁）。</p><p>注意这里：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如果 M 启动时配置了函数，则调用它</span><br><span class="hljs-keyword">if</span> fn := gp.m.mstartfn; fn != <span class="hljs-literal">nil</span> &#123;<br>    fn()<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们提到 <code>runtime·newproc</code> 的时候，获取并设置了<code>runtime.main</code> 的函数地址：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 取 runtime·mainPC 的地址，这其实就是 runtime 包下的 main() 方法。</span><br><span class="hljs-comment">// 它是 Go 语言程序的真正入口，而不是 main.main()。</span><br><span class="hljs-symbol">MOVQ</span>$runtime·mainPC(<span class="hljs-built_in">SB</span>), AX<br><span class="hljs-symbol">PUSHQ</span>AX<br><span class="hljs-comment">// 创建一个新的 goroutine 来运行程序的主函数。</span><br><span class="hljs-comment">// 这里还没有正在的运行，因为调度器还没有启动，</span><br><span class="hljs-comment">// 只是将 runtime.main 放进 goroutine 的 queue 中等待执行。</span><br><span class="hljs-symbol">CALL</span>runtime·newproc(<span class="hljs-built_in">SB</span>)<br><span class="hljs-symbol">POPQ</span>AX<br></code></pre></td></tr></table></figure><p>所以这里其实就是调用<code>runtime.main()</code>，到这里，我们终于开始执行程序的主函数了。</p><h2 id="runtime.main">runtime.main ★</h2><p>终于我们到了 <code>runtime.main</code> 这个 Go 语言世界中 “真正”的主函数了，它位于：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The main goroutine.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 获取当前的 M</span><br>mp := getg().m<br><br>mp.g0.racectx = <span class="hljs-number">0</span><br><br><span class="hljs-comment">// 限制栈大小的上限，64 位系统为 1G，32 位系统为 250M</span><br><span class="hljs-keyword">if</span> goarch.PtrSize == <span class="hljs-number">8</span> &#123;<br>maxstacksize = <span class="hljs-number">1000000000</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>maxstacksize = <span class="hljs-number">250000000</span><br>&#125;<br><br><span class="hljs-comment">// 这里就将栈的上限提升 2 倍，用于避免在分配过大的栈时崩溃。</span><br>    <span class="hljs-comment">// 所以其实 64 位系统最大栈 2G，32 位系统最大栈 500M。</span><br>maxstackceiling = <span class="hljs-number">2</span> * maxstacksize<br><br><span class="hljs-comment">// 将 mainStarted 置为 true，允许 newproc 启动新的 M。</span><br>mainStarted = <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// WebAssemby 上暂时没有线程和系统监视器，所以这里过滤掉。</span><br><span class="hljs-keyword">if</span> GOARCH != <span class="hljs-string">&quot;wasm&quot;</span> &#123; <br>        <span class="hljs-comment">// 其他架构就启动系统监视器。</span><br>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>newm(sysmon, <span class="hljs-literal">nil</span>, <span class="hljs-number">-1</span>)<br>&#125;)<br>&#125;<br><br><span class="hljs-comment">// 在初始化期间将 g0 锁定在 m0 上。</span><br>lockOSThread()<br><br>    <span class="hljs-comment">// 只有 m0 可以运行 runtime.main</span><br><span class="hljs-keyword">if</span> mp != &amp;m0 &#123;<br>throw(<span class="hljs-string">&quot;runtime.main not on m0&quot;</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 记录 runtime 的开始时间，需要在 doInit() 之前，因为这样才把 init 也追踪上。</span><br>runtimeInitTime = nanotime()<br><span class="hljs-keyword">if</span> runtimeInitTime == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;nanotime returning zero&quot;</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 初始化 trace</span><br><span class="hljs-keyword">if</span> debug.inittrace != <span class="hljs-number">0</span> &#123;<br>inittrace.id = getg().goid<br>inittrace.active = <span class="hljs-literal">true</span><br>&#125;<br><br>    <span class="hljs-comment">// 执行 runtime 的 init() 方法</span><br>doInit(runtime_inittasks) <span class="hljs-comment">// Must be before defer.</span><br>    <br><span class="hljs-comment">// defer 解锁，以便在初始化期间调用 runtime.Goexit 时也能解锁。</span><br>needUnlock := <span class="hljs-literal">true</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> needUnlock &#123;<br>unlockOSThread()<br>&#125;<br>&#125;()<br><br>    <span class="hljs-comment">// 启动垃圾回收期</span><br>gcenable()<br><br>    <span class="hljs-comment">// 监听初始化完成的信号</span><br>main_init_done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br>    <br>    <span class="hljs-comment">// 如果使用 cgo，则进行相关的初始化</span><br><span class="hljs-keyword">if</span> iscgo &#123;<br>...<br>cgocall(_cgo_notify_runtime_init_done, <span class="hljs-literal">nil</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 执行所有模块的 init()</span><br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> activeModules() &#123;<br>doInit(m.inittasks)<br>&#125;<br><br><span class="hljs-comment">// 初始化任务都完成后，则禁用初始化 trace。</span><br>inittrace.active = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">// 关闭初始化完成的信号通道</span><br><span class="hljs-built_in">close</span>(main_init_done)<br><br>    <span class="hljs-comment">// 解锁 m0 线程</span><br>needUnlock = <span class="hljs-literal">false</span><br>unlockOSThread()<br><br>    <span class="hljs-comment">// 以 -buildmode=(c-archive|c-shared) 方式进行构建程序的话，则不执行 main.main</span><br><span class="hljs-keyword">if</span> isarchive || islibrary &#123;<br><span class="hljs-comment">// A program compiled with -buildmode=c-archive or c-shared</span><br><span class="hljs-comment">// has a main, but it is not executed.</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <br>    <span class="hljs-comment">// 执行 main.main() 函数，也就是我们自己写的 main()</span><br>fn := main_main <br>fn()  <span class="hljs-comment">// 如果我们启动了一个 server 服务，这里就会被阻塞住，直到我们的 main 返回。</span><br>    <br>    <span class="hljs-comment">// 静态检测输出</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>runExitHooks(<span class="hljs-number">0</span>) <span class="hljs-comment">// run hooks now, since racefini does not return</span><br>racefini()<br>&#125;<br><br><span class="hljs-comment">// 处理在 main 返回时同时存在的其他 goroutine 的 panic</span><br><span class="hljs-keyword">if</span> runningPanicDefers.Load() != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">1000</span>; c++ &#123;<br>            <span class="hljs-comment">// 执行 defer</span><br><span class="hljs-keyword">if</span> runningPanicDefers.Load() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>Gosched()<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// 阻塞 g0 的执行，直到所有的 panic 都处理完毕</span><br><span class="hljs-keyword">if</span> panicking.Load() != <span class="hljs-number">0</span> &#123;<br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonPanicWait, traceBlockForever, <span class="hljs-number">1</span>)<br>&#125;<br>    <br>    <span class="hljs-comment">// 执行 hook 退出函数</span><br>runExitHooks(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 退出程序，0 表示正常退出</span><br>exit(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 理论上 exit(0) 应该退出程序的，</span><br>    <span class="hljs-comment">// 如果还没退出，使用 nil 指针强行赋值，引发崩溃，强行退出程序。</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">var</span> x *<span class="hljs-type">int32</span><br>*x = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，<code>runtime.main()</code> 干这么几件事：</p><ol type="1"><li>首先进行一些基本的设置和检查，包括设置栈大小限制和锁定主 goroutine到主 OS 线程。</li><li>然后，函数执行一系列初始化操作，包括启动垃圾回收器、处理 CGo交互、执行包的 init()。</li><li>在完成所有 init() 后，函数调用用户定义的 <code>main.main</code>函数。</li><li>最后，函数处理程序退出，包括执行 defer、等待 panic处理完成，并正式退出程序。</li></ol><p>所以这里我们就知道了为什么 <code>init()</code> 会在<code>main.main()</code> 之前被执行，而且如果一个 package在整个程序路径都没有被 import 的时候，<code>init()</code>是不会被执行的，就是因为 <code>runtime.main()</code> 只处理了<code>activeModules()</code> 的 <code>initTasks()</code>。</p><div class="note note-info">            <p>到这里，还有个遗留问题，开发时我们需要关注的 <code>init()</code> 和<code>main.main()</code>可以讨论过了，那全局变量的初始化是在哪里做的呢？</p><p>在 Go语言的编译过程中，全局变量的初始化主要发生在链接阶段。编译器首先编译每个包，生成对象文件。然后在链接阶段，编译器或链接器将这些对象文件合并成一个可执行文件。在这个过程中，编译器或链接器负责生成初始化全局变量的代码，并安排这些代码在程序启动时执行。</p><p>这些初始化代码通常嵌入在程序的启动序列中，确保在执行任何包级<code>init</code> 函数或用户定义的 <code>main</code>函数之前，所有全局变量已经被初始化。由于这些操作是编译器在内部执行的，它们不会直接显示在源代码或运行时代码中。</p>          </div><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231210232155964.png"alt="runtime.main 函数概述" /><figcaption aria-hidden="true">runtime.main 函数概述</figcaption></figure><hr /><p>至此，我们就分析完 Go语言程序的整个启动过程了。具体的启动流程总结，可以回到开头的 “结论先行”查看。</p><h2 id="参考">参考</h2><ul><li><ahref="https://coding.imooc.com/class/576.html">慕课网-深入Go底层原理</a></li><li>Go1.21.0 官方源码</li><li>ChatGPT-4</li></ul>]]></content>
    
    
    <summary type="html">本文基于 Go1.21.0 版本详细介绍了 Go 语言程序的启动过程。开头有总结，方便读者快速浏览或回顾，后面是对整个 Go 启动过程的详细讨论，感兴趣的读者可以深入阅读这一部分。</summary>
    
    
    
    <category term="Go" scheme="https://hedon.top/categories/Go/"/>
    
    
    <category term="Go" scheme="https://hedon.top/tags/Go/"/>
    
  </entry>
  
</feed>
