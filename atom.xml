<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HedonWang</title>
  
  <subtitle>君子求诸己，律己则安。</subtitle>
  <link href="https://hedon.top/atom.xml" rel="self"/>
  
  <link href="https://hedon.top/"/>
  <updated>2025-08-13T15:52:21.881Z</updated>
  <id>https://hedon.top/</id>
  
  <author>
    <name>Hedon Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大白话解释交叉熵损失</title>
    <link href="https://hedon.top/2025/08/13/llm/cross-entropy-loss/"/>
    <id>https://hedon.top/2025/08/13/llm/cross-entropy-loss/</id>
    <published>2025-08-13T11:30:20.000Z</published>
    <updated>2025-08-13T15:52:21.881Z</updated>
    
    <content type="html"><![CDATA[<h1>LLM 训练过程概述</h1><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250813193726179.png" alt="LLM 训练过程概述"></p><p>在介绍交叉熵损失之前，我们先参考 <a href="https://github.com/rasbt/LLMs-from-scratch/blob/main/ch05/01_main-chapter-code/ch05.ipynb">Build a Large Language Model</a> 一书梳理一下训练 LLM 的核心过程。笔者并非这个方向的专业人士，只能尝试从自己理解的角度来尽可能用大白话阐述这个过程在做什么、为什么这么做、能达到什么效果。</p><p>为了便于理解，我们可以把整个过程想象成<strong>教一个学徒如何写文章</strong>。</p><h3 id="1-文本生成（Text-generation）">1. 文本生成（Text generation）</h3><blockquote><p>这就像让你的学徒开始写文章。一开始，它什么都不懂，只会胡乱地写一些词语。你给它一个开头，比如&quot;从前有座山…“，它可能随便接上”…山里有只大象在跳舞。&quot;完全不合逻辑。</p></blockquote><p>这是模型还没有训练好时，它根据一些输入，随机生成的一段文本。它生成的文本质量很差，毫无章法。</p><h3 id="2-文本评估（Text-evaluation）">2. 文本评估（Text evaluation）</h3><blockquote><p>你现在需要一个**&quot;老师&quot;<strong>来给这个学徒写的文章打分。你拿着学徒写的文章，和一篇</strong>标准答案（正确文章）<strong>进行对比。这个“老师”会告诉你，学徒写的文章和标准答案之间有多大的差距。这个打分的过程，就是我们本文将提到的</strong>交叉熵损失（Cross-Entropy Loss）**。</p></blockquote><p>这个步骤是计算模型生成的文本与真实文本之间的损失值。模型会计算出它对下一个词的预测概率，并用交叉熵损失来衡量这个预测概率与真实词的“独热编码”概率有多大差距。<font color="red"><strong>损失值越大，说明模型预测得越差</strong></font>。</p><h3 id="3-训练集和验证集的损失（Training-set-and-validation-set-losses）">3. 训练集和验证集的损失（Training set and validation set losses）</h3><blockquote><p>你的学徒现在开始正式学习了。你给他一大堆文章（<strong>训练集</strong>）让他模仿学习，然后定期拿出一小部分它没看过的文章（<strong>验证集</strong>）给他做测试。</p><ul><li><strong>训练集损失：</strong> 衡量学徒在学习过程中，对那些它看过的文章模仿得有多像。</li><li><strong>验证集损失：</strong> 衡量学徒在面对新文章时，能不能把学到的东西举一反三，而不是只会死记硬背。</li></ul></blockquote><p>如果训练集损失一直下降，但验证集损失不降反升，那就说明学徒只会&quot;死记硬背&quot;了，这在机器学习里叫做<strong>过拟合（Overfitting）</strong>。</p><h3 id="4-大语言模型训练函数（LLM-training-function）">4. 大语言模型训练函数（LLM training function）</h3><p>这就是学徒的**“大脑”<strong>，也是整个学习的核心。它根据&quot;老师&quot;给出的分数（损失值），调整自己的&quot;大脑结构&quot;（模型参数/权重）。如果某篇文章写得不好，它就会&quot;反思&quot;自己为什么写不好，然后调整下一次的写作方式，争取写得更好。这个调整的过程叫做<a href="https://hedon.top/2025/07/27/llm/back-propagation/"><strong>反向传播（Backpropagation）</strong></a>和</strong>梯度下降（Gradient Descent）**。</p><h3 id="5-训练模型生成类似人类的文本（Train-the-model-to-generate-human-like-text）">5. 训练模型生成类似人类的文本（Train the model to generate human-like text）</h3><p>这就是整个训练的目的：通过不断地重复第 1-4 步，让学徒的写作能力越来越强，最终写出来的文章，就像人类写的一样自然、流畅。</p><h3 id="6-文本生成策略（Text-generation-strategies）">6. 文本生成策略（Text generation strategies）</h3><blockquote><p>学徒学得差不多了，但有时候会变得特别死板，只会把训练集里的东西原封不动地背出来。为了让它更有创意，更像人，你需要教它一些“写作技巧”。</p><p>例如： 有时候，你不要总是选那个最有可能出现的词，可以偶尔选一些稍微不那么确定，但也很合理的词。</p></blockquote><p>这就是像<strong>Top-k 采样</strong>、<strong>Top-p（核）采样</strong>、**温度（Temperature）**调节等技术。这些方法会让模型在生成文本时，增加一些随机性，避免总是生成重复、机械化的内容，减少过拟合的风险。</p><h3 id="7-权重保存和加载（Weight-saving-loading）">7. 权重保存和加载（Weight saving &amp; loading）</h3><p>学徒经过了长期的学习，终于成才了！现在你需要把它的&quot;大脑&quot;状态（也就是模型参数）保存下来。这样，下次再用的时候，就不用从头开始教了，直接把这个保存好的&quot;大脑&quot;拿出来用就行。</p><h3 id="8-来自-OpenAI-的预训练权重（Pretrained-weights-from-OpenAI）">8. 来自 OpenAI 的预训练权重（Pretrained weights from OpenAI）</h3><p>这就像你不是从一个零基础的学徒开始教，而是直接找一个已经很有经验的&quot;天才学徒&quot;来培养。OpenAI 训练了海量的数据，已经把一个 GPT 模型训练得非常强大了。我们直接拿来用，再结合自己的任务，在它的基础上继续微调。这样不仅省时省力，还能得到一个更好的模型。</p><h3 id="总结">总结</h3><p>GPT 的训练过程就是，让一个初出茅庐的学徒（模型）写文章，找一个老师（损失函数）给它打分，然后根据分数调整它的大脑（参数）。反复这个过程，直到它写出来的文章像人类一样。为了让它更有创意，我们还教它一些写作技巧。最后，我们会把它的&quot;大脑&quot;保存下来，或者直接用一个&quot;天才学徒&quot;的大脑，在上面继续学习。</p><h1>交叉熵损失</h1><p>接下来我们回到本文的主题：<font color="red"><strong>交叉熵损失（Cross-Entropy Loss）</strong></font>。</p><blockquote><p>交叉熵损失是一种衡量模型预测结果与真实结果之间差异的指标。在分类任务中，模型通常会输出一个预测概率分布，而真实标签也可以被看作一个“理想”的概率分布。交叉熵损失的作用就是比较这两个概率分布的相似程度。<strong>如果模型的预测概率分布和真实概率分布越接近，交叉熵损失就越小，反之则越大。</strong> 我们的目标就是通过训练，不断减小这个损失值，从而让模型学会做出更准确的预测。</p></blockquote><p>是不是一头雾水？哈哈，没关系，下面笔者将从概念、由来、原理和计算四个部分进行展开，尽可能以大白话的方式进行阐述，相信你阅读后回来再看一段定义的时候，会有不一样的理解~</p><h3 id="1-概念：交叉熵损失，就是给-猜词-打分">1. 概念：交叉熵损失，就是给&quot;猜词&quot;打分</h3><p>想象一下，你正在教一个学徒写一句话。你告诉他句子的开头是：“今天天气真…”，然后你让他猜下一个词应该是什么。</p><ul><li><p><strong>学徒的预测：</strong> 他可能会给出一些预测，比如：</p><ul><li>“好” （他觉得最可能）</li><li>“差” （也有一点可能）</li><li>“棒” （可能性更小）</li><li>“猫” （几乎不可能）</li></ul><p>这些预测，可以被看作一个<strong>概率分布</strong>。比如，他可能认为&quot;好&quot;的概率是 80%，&quot;差&quot;的概率是 15%，&quot;棒&quot;的概率是 4%，&quot;猫&quot;的概率是 1%。</p></li><li><p><strong>正确的答案：</strong> 实际上，正确的下一个词是**“好”**。</p></li><li><p><strong>交叉熵损失的作用：</strong> 交叉熵损失就像一个严厉的老师，它只关注学徒对<strong>正确答案</strong>的预测。它会说：“你对’好’这个词的预测概率是多少？<strong>这个概率越大，你这次的表现就越好，你的’惩罚’（损失）就越小。反之，你的表现越差，你的’惩罚’就越大。</strong>”</p></li></ul><p>简单来说，交叉熵损失的计算公式可以简化为：<br>$$<br>损失值 = -log(模型对正确答案的预测概率)<br>$$</p><ul><li>如果学徒对“好”的预测概率是 <strong>0.8</strong>，那么损失值大约是 $−log(0.8)≈0.223$。</li><li>如果学徒对“好”的预测概率是 <strong>0.01</strong>（很差），那么损失值大约是 $−log(0.01)≈4.605$。</li><li>如果学徒猜中率是 <strong>1.0</strong>（完美），那么损失值是 $ −log(1)=0$。</li></ul><p>由此可见，交叉熵损失完美地实现了我们的教学目标：<strong>预测对了，损失就小；预测错了，损失就大。</strong></p><h3 id="2-由来：从信息论到机器学习的-迁移">2. 由来：从信息论到机器学习的&quot;迁移&quot;</h3><p>要理解交叉熵损失的原理，我们需要追溯到它的老家：<strong>信息论</strong>。</p><h4 id="2-1-熵（Entropy）">2.1 熵（Entropy）</h4><p>信息论中有一个概念叫&quot;熵&quot;，它衡量的是一个事件的<strong>不确定性</strong>。一个越不确定的事件，它的熵就越高，包含的信息量就越大。</p><ul><li>比如，我告诉您&quot;太阳从东边升起&quot;，这几乎是 100% 确定的事，您没有获得任何新信息，所以它的熵很低。</li><li>但如果我告诉您&quot;今天股市大涨&quot;，这本身是一个不确定的事件，您就获得了新信息，所以它的熵很高。</li></ul><h4 id="2-2-交叉熵（Cross-Entropy）">2.2 交叉熵（Cross-Entropy）</h4><p>现在我们有两个概率分布：一个是真实的、完美的概率分布（记为 $p$），另一个是我们模型的预测概率分布（记为 $q$）。</p><p>交叉熵衡量的就是，用我们模型的预测分布 $q$ 来表示真实的分布 $p$，需要多少额外的&quot;信息量&quot;或者说&quot;代价&quot;。</p><p><strong>理论公式：</strong> 交叉熵的理论公式是 $H(p,q)=−∑_ip_ilog(q_i)$。</p><ul><li>这里的 $p_i$ 是真实事件的概率。</li><li>$q_i$ 是我们模型预测的概率。</li></ul><p><strong>独热编码（One-hot）的简化</strong>：</p><p>在机器学习的分类任务中，我们的真实标签通常是独热编码的，比如正确答案是&quot;猫’'，那么真实分布 $p$ 就是<br>$$<br>[0, 1, 0, …]<br>$$<br>现在，让我们把独热编码的 $p$ 代入到上面的公式中：<br>$$<br>H(p,q)=−(0⋅log(q_1)+1⋅log(q_2)+0⋅log(q_3)+…)<br>$$<br>你会发现，求和公式里，只有<strong>正确类别（猫）<strong>对应的 $p_i$ 是 1，其他都是 $0$。所以，整个求和公式就只剩下了一项：<br>$$<br>H(p,q)=−log(q_{正确类别})<br>$$<br>这就是交叉熵损失的最终形式。它之所以这样计算，完全是因为在分类任务中，我们</strong>只关心模型对正确答案的预测概率</strong>，而信息论中的交叉熵公式在遇到独热编码时，正好简化成了这个形式。</p><h3 id="3-原理：为什么-−log-p-是一个好的损失函数？">3. 原理：为什么 −log(p) 是一个好的损失函数？</h3><p>让我们从数学和直觉两个角度来理解，为什么 $−log(p)$ 是一个完美的损失函数。</p><h4 id="3-1-数学角度">3.1 数学角度</h4><p><strong>梯度：</strong> 我们的目标是通过梯度下降法来最小化损失。对于 $−log(p)$，它的导数是 $−1/p$。</p><ul><li>当 $p$ 接近 1 时（预测得很准），$1/p$ 接近 1，损失的梯度就很小。这意味着模型参数调整的幅度不大，因为它已经做得不错了。</li><li>当 $p$ 接近 0 时（预测得很差），$1/p$ 趋近于无穷大，损失的梯度就变得非常大。这意味着模型参数调整的幅度会非常大，因为它犯了一个严重的错误，需要大力纠正。</li></ul><p>这种特性使得模型在犯错时能快速学习，而在预测准确时则能稳定下来，这非常符合我们对训练过程的期望。</p><h4 id="3-2-直觉角度">3.2 直觉角度</h4><p><strong>不确定性：</strong> 让我们回到信息论。$−log(p)$ 实际上就是正确事件的信息量。</p><ul><li>如果模型预测正确事件的概率 $p$ 很低，说明模型对正确答案非常不确定，那么这个正确答案的出现就包含了大量信息。交叉熵损失就用这个巨大的信息量来惩罚模型。</li><li>如果模型预测正确事件的概率 $p$ 很高，说明模型很确定答案，那么这个正确答案的出现就包含很少信息。交叉熵损失就用这个很小的信息量来奖励模型。</li></ul><p>这种**“用信息量来惩罚”**的机制，确保了模型会努力去减少它对正确答案的不确定性，从而让它的预测结果越来越接近真实情况。</p><h3 id="4-计算">4. 计算</h3><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250813200501445.png" alt="交叉熵损失计算过程"></p><p>参考 <a href="https://github.com/rasbt/LLMs-from-scratch/blob/main/ch05/01_main-chapter-code/ch05.ipynb">Build a Large Language Model</a> 一书，交叉熵损失的计算过程大概分成上面所示的 6 个步骤。</p><p><strong>步骤 1：Logits（对数几率）</strong></p><p>Logits 是模型在 Softmax 层之前的原始输出值，它可以是任意实数。这些值代表了模型对每个类别的&quot;置信度&quot;，但还没有归一化为概率。图片中的 <code>[[0.1113, -0.1057, -0.3666, ...]]</code> 就是一个样本的 Logits 输出。</p><p><strong>步骤 2：Probabilities（概率）</strong></p><p>通过 Softmax 函数将 Logits 转换为概率分布。这个函数的作用是将一组任意实数转换成一个概率分布，使得所有值都在 0 到 1 之间，并且总和为 1。它的公式是 $q_i=\frac{e^{z_i}}{∑_j^{e^{z_j}}}$， (其中 $z_i$ 是第 $i$ 个类别的 Logit)。<code>[[1.8849e-05, 1.5172e-05, 1.1687e-05, ...]]</code> 就是经过 Softmax 转换后的概率分布。</p><p><strong>步骤 3：Target probabilities（目标概率）</strong></p><p>这一步的核心是从模型的预测中，提取出与真实答案相对应的概率值。在理论上，我们用独热编码（One-Hot Encoding）来表示真实标签，例如 <code>[0, 1, 0, ...]</code>。图片中的 <code>[7.4541e-05, ...]</code> 正是模型根据这个独热编码所指示的正确索引，给出的预测概率。这些值通常很小，因为在训练初期，模型对正确答案的预测能力还很弱。在计算交叉熵时，我们只关心真实类别对应的预测概率。</p><p><strong>步骤 4：Log probabilities（对数概率）</strong></p><p>这一步是计算每个目标概率值的自然对数，即 $log(q_i)$。例如，<code>[-9.5042, -10.3796, -11.3677, ...]</code> 就是对目标概率取自然对数的结果。</p><p><strong>步骤 5：Average log probability（平均对数概率）</strong></p><p>这一步是计算<strong>所有对数概率的平均值</strong>。在步骤 4 中，我们已经得到了模型对每个正确答案的预测概率的对数值。这一步就是将这些值加起来，然后除以样本或序列的长度，以得到一个平均值。</p><p><strong>步骤 6：Negative average log probability（负平均对数概率）</strong></p><p><strong>这是计算</strong>最终损失值的步骤。在步骤 5 的基础上，我们对平均对数概率取负号。这是为了<strong>将一个衡量模型错误程度的负数，转换成一个衡量模型错误程度的正数</strong>。这个操作没有复杂的数学含义，它只是为了让损失值的符号符合我们的直觉和约定。损失值越小代表模型表现越好。在图片中，对 <code>-10.7940</code> 取负号后，得到的值是 <code>10.7940</code>。这个值就是我们最终要最小化的损失（Loss）。在模型训练中，我们通过反向传播和梯度下降来不断减小这个损失值，从而迫使模型提高对正确答案的预测概率。</p><blockquote><p>上面 6 个步骤，可以直接使用 pytorch 的 <code>cross_entropy</code> 计算，一步到位！</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = torch.nn.functional.cross_entropy(logits_flat, targets_flat)</span><br></pre></td></tr></table></figure><p>总结一下，整个计算流程可以概括为：</p><ol><li>模型输出原始分数（Logits）。</li><li>通过 Softmax 函数将分数转换为概率分布。</li><li>找出真实类别对应的预测概率。</li><li>对这个概率取负对数，得到损失值。</li><li>在训练时，我们会对所有样本的损失值求平均，然后进行反向传播更新模型参数。</li></ol><p>这个计算方式之所以合理，正是因为它完美地结合了信息论和机器学习的目标：<strong>通过最小化这个损失值，我们实际上是在最大化模型对正确类别的预测概率，从而让模型的预测分布越来越接近真实的分布。</strong> 这是一种非常高效且理论基础坚实的训练方法。</p>]]></content>
    
    
    <summary type="html">本篇...</summary>
    
    
    
    <category term="大模型" scheme="https://hedon.top/categories/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="机器学习" scheme="https://hedon.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://hedon.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大模型" scheme="https://hedon.top/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>大白话解释 GPT 架构中的权重共享</title>
    <link href="https://hedon.top/2025/08/13/llm/weight-typing/"/>
    <id>https://hedon.top/2025/08/13/llm/weight-typing/</id>
    <published>2025-08-13T08:30:20.000Z</published>
    <updated>2025-08-13T14:40:45.962Z</updated>
    
    <content type="html"><![CDATA[<p>在当今的大模型时代，GPT 架构以其强大的能力席卷了整个 AI 领域。当你深入探究其内部结构时，会发现许多精妙的设计。其中一个看似简单、却能带来巨大效益的工程技巧，就是我们今天要讨论的——<strong>权重共享（Weight Tying）</strong>。</p><h2 id="1-什么是权重共享？">1. 什么是权重共享？</h2><p>想象一下你在学习一门外语。有两个过程：</p><ol><li><strong>听写</strong>：听到一个词后，你需要在脑海中构建它的意思。</li><li><strong>表达</strong>：你想表达一个意思时，需要从词库中挑出最合适的词。</li></ol><p>一个高效的学习者会发现，这两个过程是相辅相成的。你对一个词理解得越深（听写），就越能准确地使用它（表达）。反之亦然。</p><p>在 GPT 模型中，权重共享就是将这两个过程的&quot;记忆&quot;绑定在一起。</p><p>具体来说，模型有两个关键的权重矩阵：</p><ul><li><strong>输入嵌入（Input Embedding）</strong>：将输入的离散 Token（如单词 “cat”）转换成连续的向量表示。这就像是你的&quot;听写记忆&quot;。</li><li><strong>输出线性层（Output Linear Layer）</strong>：将模型内部的向量表示转换回离散的 Token，用于预测下一个词。这就像是你的&quot;表达记忆&quot;。</li></ul><p>更具体来说：</p><ul><li><strong>输入嵌入矩阵（Input Embedding Matrix） Wemb</strong>：这是一个将离散的 Token（词汇表中的 ID）映射到连续向量空间（Token Embedding）的矩阵。它的维度是 <code>[词汇表大小, 模型维度]</code>。当一个 Token ID 比如 <code>5234</code> 进来时，模型会查找这个矩阵的第 <code>5234</code> 行，将其作为这个 Token 的向量表示。</li><li><strong>输出词表线性层（Output Vocabulary Linear Layer）Wout</strong>：这是模型在最后一步用来预测下一个 Token 的矩阵。它的维度是 <code>[模型维度, 词汇表大小]</code>。模型经过一系列 Transformer Block 处理后，会得到一个 <code>[1, 模型维度]</code> 的输出向量，这个向量会与 Wout 进行矩阵乘法，得到一个 <code>[1, 词汇表大小]</code> 的 Logits 向量。这个向量的每个值代表了词汇表中相应 Token 的概率分数，通过 Softmax 归一化后，就可以得到下一个词的概率分布。</li></ul><p>权重共享的精髓在于，它<strong>将输出线性层的权重矩阵，设置为输入嵌入矩阵的转置</strong>。这意味着，模型在学习如何编码（理解）一个词时，也在同步学习如何解码（生成）这个词。</p><h2 id="2-为什么要这样做？">2. 为什么要这样做？</h2><h3 id="浅层原因：参数效率">浅层原因：参数效率</h3><p>这是最直观的好处。一个典型的 GPT 模型，词汇表大小可能达到 5 万，模型维度（<code>d_model</code>）可能达到 4096。</p><ul><li><strong>不共享参数</strong>：<ul><li>输入嵌入矩阵参数量：<code>50000 * 4096</code></li><li>输出线性层参数量：<code>4096 * 50000</code></li><li>总参数量：<code>2 * 50000 * 4096 ≈ 4.1 亿</code></li></ul></li><li><strong>共享参数</strong>：<ul><li>总参数量：<code>50000 * 4096 ≈ 2.05 亿</code></li></ul></li></ul><p>通过共享参数，我们直接将这两部分的参数量减少了一半。这对于模型整体的参数规模来说，是一个显著的节省。在大规模模型中，这能有效降低显存占用，让训练和部署更具可行性。</p><h3 id="深层原因：泛化能力与语义对称性">深层原因：泛化能力与语义对称性</h3><p><strong>更好的梯度信号</strong>：当模型学习将一个 Token 映射为有意义的向量时（输入嵌入），这些向量也会通过转置操作，影响到模型对下一个 Token 的预测（输出线性层）。反之，当模型预测某个 Token 概率的梯度回传时，也会同时更新输入嵌入矩阵。</p><p>这形成了一种&quot;双向学习&quot;的机制：模型在学习如何编码 Token 的同时，也在学习如何解码 Token，这两个过程相互强化。这就像一个人在学习如何说一个词（输出）时，也在不断加深对这个词的理解（输入）。</p><p><strong>增强泛化能力</strong>：</p><ul><li><strong>处理生僻词</strong>：对于训练语料中出现频率很低的词，模型可能没有足够的样本来学习其精确的向量表示。但通过权重共享，如果这个词作为&quot;输出&quot;被预测过，它的梯度也会回传到输入嵌入矩阵，让其向量表示得到更新。反之亦然。这使得模型对低频词的理解能力和预测能力都能得到提升，从而增强了模型的泛化能力。</li><li><strong>语义对称性</strong>：权重共享本质上假设了 Token 的&quot;编码&quot;和&quot;解码&quot;过程应该具有某种对称性。一个 Token 的向量表示，应该直接反映其作为输出时的&quot;预测向量&quot;。这可以看作是一种正则化，迫使模型学习更紧凑、更高效、更具语义一致性的向量空间。</li></ul><h2 id="3-落地实践要点与启示">3. 落地实践要点与启示</h2><p>在实际的 GPT 实现中，权重共享是一个常见的技巧。例如，OpenAI 的 GPT-2 和许多基于其架构的开源模型都采用了这种做法。</p><ul><li><p><strong>实现细节</strong>：在 PyTorch 等深度学习框架中，实现非常简单，通常只需要将 <code>nn.Linear(d_model, vocab_size)</code>层的 <code>weight</code> 参数设置为 <code>nn.Embedding(vocab_size, d_model)</code> 层的 <code>weight.T</code> 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设我们已经定义好了嵌入层</span></span><br><span class="line">embedding_layer = nn.Embedding(vocab_size, d_model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个线性层，用于预测下一个词</span></span><br><span class="line">output_layer = nn.Linear(d_model, vocab_size, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重共享的魔法就在这里：</span></span><br><span class="line"><span class="comment"># 将输出层的权重，设置为嵌入层权重的转置</span></span><br><span class="line">output_layer.weight = embedding_layer.weight</span><br></pre></td></tr></table></figure></li><li><p><strong>效果评估</strong>：在早期的研究中，例如在 Transformer 架构中，研究人员就通过消融实验（ablation study）发现，权重共享能够带来约 0.5 到 1 个百分点的精度提升，同时大幅减少参数量。这证明了它在实践中的有效性。</p></li></ul><h2 id="总结">总结</h2><p>权重共享并非 GPT 的&quot;核心&quot;创新，但它是一个非常精巧且有效的工程与理论结合。它通过一个简单的参数绑定，实现了：</p><ul><li><strong>工程上</strong>：显著减少模型参数量，提升训练和推理效率。</li><li><strong>理论上</strong>：建立输入和输出之间的双向学习机制，增强了模型对词汇表（特别是低频词）的泛化能力，并鼓励模型学习更具语义一致性的向量表示。</li></ul>]]></content>
    
    
    <summary type="html">本篇用外语学习的比喻，深入浅出地解释 GPT 架构中的权重共享技术，从听写记忆到表达记忆，帮助你理解这个提升大模型效率的核心优化策略</summary>
    
    
    
    <category term="大模型" scheme="https://hedon.top/categories/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="机器学习" scheme="https://hedon.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://hedon.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大模型" scheme="https://hedon.top/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rust 多态的两种实现：Trait Bound 与 Trait Object 深度解析</title>
    <link href="https://hedon.top/2025/08/05/rust/rust-polymorphism/"/>
    <id>https://hedon.top/2025/08/05/rust/rust-polymorphism/</id>
    <published>2025-08-05T03:00:00.000Z</published>
    <updated>2025-08-13T14:40:45.962Z</updated>
    
    <content type="html"><![CDATA[<p>在 Rust 编程中，实现多态（Polymorphism）主要有两种核心机制：<strong>Trait Bound</strong> 和 <strong>Trait Object</strong>。虽然两者都基于 <code>trait</code>，但它们的设计理念、底层实现和适用场景却截然不同。本文将带你从概念到具体的内存布局，深入探究这两种多态方式的本质。</p><h3 id="1-从一个基本问题说起">1. 从一个基本问题说起</h3><p>设想我们有一个 <code>trait Draw</code>，它定义了绘制的方法。<code>Square</code> 结构体实现了这个 <code>trait</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">bounds</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> (<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>); <span class="comment">// 假设定义了边界方法</span></span><br><span class="line">    <span class="comment">// ... 其他绘制相关方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    top_left: Point,</span><br><span class="line">    size: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">bounds</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> (<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>) &#123;</span><br><span class="line">        (<span class="keyword">self</span>.top_left.x, <span class="keyword">self</span>.top_left.y, <span class="keyword">self</span>.size, <span class="keyword">self</span>.size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们如何编写一个函数来处理 <code>Square</code>，并调用它的 <code>bounds</code> 方法呢？这就是 <strong>Trait Bound</strong> 和 <strong>Trait Object</strong> 登场的时机。</p><h3 id="2-Trait-Bound：编译期的静态多态">2. Trait Bound：编译期的静态多态</h3><p><strong>Trait Bound</strong> 的核心思想是<strong>编译期特化（Monomorphization）</strong>。它通过泛型参数 <code>T</code> 来约束类型，确保该类型实现了某个 <code>trait</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_bounds</span>&lt;T: Draw&gt;(item: T) &#123;</span><br><span class="line">    <span class="keyword">let</span> (x, y, w, h) = item.<span class="title function_ invoke__">bounds</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;边界: x=&#123;&#125;, y=&#123;&#125;, width=&#123;&#125;, height=&#123;&#125;&quot;</span>, x, y, w, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">square</span> = Square &#123; top_left: Point &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;, size: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="title function_ invoke__">print_bounds</span>(square); <span class="comment">// T 被特化为 Square</span></span><br></pre></td></tr></table></figure><p><strong>底层原理：静态分发（Static Dispatch）</strong></p><p>在编译时，编译器会为 Square 类型生成一份 print_bounds 函数的独立代码。当调用 print_bounds(square) 时，程序直接调用为 Square 特化的版本，无需在运行时查找。</p><p><strong>优点与缺点</strong></p><ul><li><strong>零运行时开销</strong>：性能极致，与直接调用具体函数无异。</li><li><strong>代码膨胀（Code Bloat）</strong>：如果有很多不同的类型都实现了 <code>Draw</code>，编译器就会生成多份 <code>print_bounds</code> 的代码。</li><li><strong>语法糖</strong>：<code>fn print_bounds(item: impl Draw)</code> 是 <code>fn print_bounds&lt;T: Draw&gt;(item: T)</code> 的语法糖，两者在底层实现和性能上是完全等价的。</li></ul><hr><h3 id="3-Trait-Object：运行时的动态多态">3. Trait Object：运行时的动态多态</h3><p>现在，我们面临一个新问题：如果想把不同类型但都可绘制的对象放入同一个 <code>Vec</code> 集合中怎么办？例如，我们有一个 <code>Square</code> 和一个 <code>Circle</code>（假设 <code>Circle</code> 也实现了 <code>Draw</code>），我们不能直接 <code>vec![square, circle]</code>，因为 <code>Vec</code> 要求所有元素是<strong>同一种具体类型</strong>。</p><p><strong>Trait Object</strong> 的核心思想是<strong>类型擦除（Type Erasure）</strong>，它允许我们将实现了相同 <code>trait</code> 的不同类型实例统一处理。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 Circle 也实现了 Draw trait</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">circle</span> = Circle &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">square</span> = Square &#123;</span><br><span class="line">  top_left: Point &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;,</span><br><span class="line">  size: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 `dyn` 关键字表示动态类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">draw_object</span>: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(square);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以将不同类型但都实现了 Draw 的对象放入 Vec 中</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">drawable_items</span>: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt; = <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(square), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(circle)];</span><br></pre></td></tr></table></figure><p><strong>底层原理：动态分发（Dynamic Dispatch）</strong></p><p>Box&lt;dyn Draw&gt; 是一个胖指针（Fat Pointer）。它包含两个部分：</p><ol><li><strong>数据指针</strong>：指向堆上实际的对象（例如 <code>Square</code> 实例）。</li><li><strong>虚表指针</strong>：指向一张静态生成的<strong>虚函数表（vtable）</strong>。</li></ol><p>当调用 <code>draw_object.bounds()</code> 时，程序会在<strong>运行时</strong>通过胖指针找到虚表，再从虚表中找到正确的方法地址并执行。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250805124423615.png" alt="trait object layout"></p><p>上图展示了 <code>&amp;dyn Draw</code> 这个 <code>trait object</code> 的内存布局：</p><p><strong>栈（Stack）</strong>：</p><ul><li><code>square</code>：原始的 <code>Square</code> 实例，其数据（<code>top_left.x</code>, <code>top_left.y</code>, <code>size</code>）直接存储在栈上，大小在编译时可知。</li><li><code>draw</code>：这是一个 <code>&amp;dyn Draw</code> 类型的 <strong>胖指针</strong>。它也存储在栈上，但其大小是固定的（两个指针的大小，通常是 16 字节在 64 位系统上）。<ul><li>胖指针的<strong>第一个部分</strong>指向 <code>square</code> 实例的实际数据地址。</li><li>胖指针的<strong>第二个部分</strong>指向 <code>Draw for Square vtable</code>。</li></ul></li></ul><p><strong>虚表（Vtable）</strong>：</p><ul><li><code>Draw for Square vtable</code>：这是一个在编译时为 <code>Square</code> 类型和 <code>Draw</code> <code>trait</code> 的组合而生成的<strong>静态只读表</strong>。它包含了 <code>Square</code> 实现 <code>Draw</code> <code>trait</code> 所需的所有信息，其中最重要的是 <code>Square::bounds()</code> 方法的实际内存地址。</li></ul><p>通过 <code>draw</code> 胖指针调用 <code>draw.bounds()</code> 时，Rust 运行时会：</p><ol><li>读取 <code>draw</code> 胖指针中的虚表指针。</li><li>通过虚表指针找到 <code>Draw for Square vtable</code>。</li><li>从虚表中找到 <code>bounds()</code> 方法的地址（即 <code>Square::bounds()</code> 的地址）。</li><li>调用该地址处的函数，并将胖指针中的数据指针作为 <code>self</code> 参数传递。</li></ol><blockquote><p><strong>虚表是与类型-trait 组合绑定的，而不是与实例绑定的。</strong> 无论有多少个 <code>&amp;dyn Draw</code> 类型的胖指针，只要它们都引用同一个 <code>Square</code> 实例，或者不同的 <code>Square</code> 实例，它们的虚表指针都会指向<strong>同一张</strong>静态生成的 <code>Draw for Square vtable</code>。虚表是全局唯一的，为每种类型-trait 组合只生成一份。</p></blockquote><h3 id="4-复杂场景下的内存布局：组合-Trait-Object">4. 复杂场景下的内存布局：组合 Trait Object</h3><p>当 <code>trait object</code> 组合多个 <code>trait</code> 时，比如 <code>&amp;dyn Draw + Shape</code>，底层机制会更加精巧。</p><ul><li><strong>单 Trait Object</strong>：<code>&amp;dyn Draw</code> 和 <code>&amp;dyn Shape</code> 是两个独立的胖指针，分别指向为 <code>Square</code>-<code>Draw</code> 和 <code>Square</code>-<code>Shape</code> 组合生成的<strong>独立虚表</strong>。</li><li><strong>组合 Trait Object</strong>：<code>&amp;dyn Draw + Shape</code> 是一个<strong>单一的胖指针</strong>。它指向一张包含了<strong>所有组合 <code>trait</code> 方法地址的联合虚表</strong>。</li></ul><p>假如说我们定义的 <code>Shape</code> trait 如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Anything that implements `Shape` must also implement `Draw`.</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Shape</span>: Draw &#123;</span><br><span class="line">  <span class="comment">/// Render that portion of the shape that falls within `bounds`.</span></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">render_in</span>(&amp;<span class="keyword">self</span>, bounds: Bounds);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Render the shape.</span></span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="comment">// Default implementation renders that portion of the shape</span></span><br><span class="line">      <span class="comment">// that falls within the screen area.</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(visible) = <span class="title function_ invoke__">overlap</span>(SCREEN_BOUNDS, <span class="keyword">self</span>.<span class="title function_ invoke__">bounds</span>()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">render_in</span>(visible);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现有如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">square</span> = Square &#123;</span><br><span class="line">  top_left: Point &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;,</span><br><span class="line">  size: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">draw</span>: &amp;<span class="keyword">dyn</span> Draw = &amp;square;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">shape</span>: &amp;<span class="keyword">dyn</span> Shape = &amp;square;</span><br></pre></td></tr></table></figure><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250805125330619.png" alt="组合 trait objects layout"></p><p><strong>栈（Stack）</strong>：</p><ul><li><code>square</code>：原始 <code>Square</code> 实例，不变。</li><li><code>draw</code>：<code>&amp;dyn Draw</code> 胖指针，指向 <code>Square</code> 数据和 <code>Draw for Square vtable</code>。</li><li><code>shape</code>：这是一个<strong>新的、独立的</strong> <code>&amp;dyn Shape</code> 胖指针。它同样指向 <code>Square</code> 数据，但其虚表指针指向的是 <code>Shape for Square vtable</code>。</li></ul><p><strong>虚表（Vtable）</strong>：</p><ul><li><code>Draw for Square vtable</code>：为 <code>Square</code> 和 <code>Draw</code> 组合生成的虚表，它包含了 <code>bounds()</code> 方法的指针。</li><li><code>Shape for Square vtable</code>：为 <code>Square</code> 和 <code>Shape</code> 组合生成的<strong>另一个独立的虚表</strong>。它包含了 <code>Square::render_in()</code> 、<code>Square::bounds()</code>和  <code>Shape::render()</code> 方法的地址。</li></ul><blockquote><p>总结：如果你有<strong>多个独立的 <code>trait object</code> 类型</strong>（如 <code>&amp;dyn Draw</code> 和 <code>&amp;dyn Shape</code>），即使它们引用的是<strong>同一个底层数据</strong>，它们各自的胖指针也会指向<strong>各自独立的虚表</strong>。</p></blockquote><h3 id="5-Trait-Object-的安全约束">5. Trait Object 的安全约束</h3><p>为了在实现动态多态的同时保证内存安全，Rust 对 <strong>trait object</strong> 施加了严格的限制：</p><ul><li><strong><code>Sized</code> 约束</strong>：<code>dyn Trait</code> 是一个 DST，其大小在编译时未知。因此，它必须通过指针（<code>&amp;</code>、<code>Box</code>、<code>Rc</code>、<code>Arc</code> 等）引用。</li><li><strong>方法限制</strong>：<code>trait object</code> 的 <code>trait</code> 方法不能是泛型方法，也不能返回 <code>Self</code>。这是因为编译器无法为泛型方法生成虚表条目，也无法确定返回 <code>Self</code> 的返回值大小。例如，<code>Clone</code> <code>trait</code> 因为其 <code>clone</code> 方法返回 <code>Self</code>，所以不能直接作为 <code>trait object</code>。</li><li><strong>生命周期</strong>：<code>trait object</code> 的生命周期会与它所引用的数据的生命周期绑定，防止悬空指针（<code>use-after-free</code>）问题。</li></ul><h3 id="总结">总结</h3><table><thead><tr><th>特性</th><th>Trait Bound (泛型)</th><th>Trait Object (动态)</th></tr></thead><tbody><tr><td><strong>多态类型</strong></td><td><strong>静态多态</strong></td><td><strong>动态多态</strong></td></tr><tr><td><strong>分发方式</strong></td><td><strong>静态分发</strong> (编译时)</td><td><strong>动态分发</strong> (运行时)</td></tr><tr><td><strong>性能开销</strong></td><td><strong>零开销</strong></td><td><strong>轻微开销</strong> (虚表查找)</td></tr><tr><td><strong>底层原理</strong></td><td><strong>编译期特化</strong></td><td><strong>类型擦除 + 胖指针/虚表</strong></td></tr><tr><td><strong>大小类型</strong></td><td><code>Sized</code></td><td><code>Unsized</code> (必须通过指针引用)</td></tr><tr><td><strong>典型应用</strong></td><td>极致性能、类型已知</td><td>异构集合、插件化、通用接口</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Rust 多态的两种实现：Trait Bound 与 Trait Object 深度解析</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>大白话解释反向传播算法</title>
    <link href="https://hedon.top/2025/07/27/llm/back-propagation/"/>
    <id>https://hedon.top/2025/07/27/llm/back-propagation/</id>
    <published>2025-07-27T04:30:20.000Z</published>
    <updated>2025-08-13T14:40:45.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、核心思想：一个-“分锅”-大会">一、核心思想：一个 “分锅” 大会</h3><p>想象一下，你是一个大公司的 CEO，你的公司有一个很长的流水线，用来生产一个精密的产品。这条流水线有很多道工序，每道工序都有一个工人负责。</p><ol><li><strong>最终产品出问题了</strong>：产品下线后，你发现最终的成品和设计图纸有偏差 (比如，要求重 100 克，结果做出来重 110 克)。这个 “10 克的偏差” 就是 <strong>误差 (Error)</strong>。</li><li><strong>你作为 CEO 开始追责</strong>：你肯定不会把所有人都骂一顿，或者随机开除一个工人。最科学的方法是 <strong>从后往前</strong>追查。</li><li><strong>追责第一步</strong>：你首先找到 <strong>最后一道工序</strong> 的工人。因为他是直接影响成品的人。你对他说：“产品重了 10 克，你的操作对最终重量影响最大，你先调整一下你的机器参数。”</li><li><strong>追责第二步</strong>：这个工人会说：“老板，我这道工序的产出，也受到 <strong>上一道工序</strong> 给我的半成品的影响啊。根据我的机器参数，我可以计算出，上一个工人交给我的半成品大概是重了 8 克导致的。”</li><li><strong>追责第三步</strong>：于是，你又拿着这个 “8 克的偏差” 去找 <strong>倒数第二个工人</strong>。这个工人也同样会计算他受到了他上游工序的影响。</li><li><strong>一路向前追溯</strong>：就这样，这个 “锅” (误差) 从最后一个工人开始，一层一层地 <strong>向前传递</strong>，每个工人都根据自己的 “责任” 大小，领走一部分 “锅”，并对自己的机器参数做出微小的调整。</li></ol><p>这个从后往前追责、分锅、调整的过程，就是 <strong>反向传播</strong> 的核心思想。</p><h3 id="二、从比喻到神经网络">二、从比喻到神经网络</h3><p>现在，我们把上面的比喻翻译成神经网络的术语：</p><table><thead><tr><th>大白话比喻</th><th>神经网络术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>流水线</strong></td><td><strong>神经网络 (Neural Network)</strong></td><td>由多个层级组成，数据从输入层流向输出层。</td></tr><tr><td><strong>工人</strong></td><td><strong>神经元 (Neuron)</strong></td><td>网络中的计算单元。</td></tr><tr><td><strong>工人的机器参数</strong></td><td><strong>权重 (Weights) 和 偏置 (Biases)</strong></td><td>每个神经元里需要学习和调整的参数，就像机器的旋钮。</td></tr><tr><td><strong>最终产品</strong></td><td><strong>网络的预测输出 (Prediction)</strong></td><td>比如，给一张猫的图片，网络输出 “90% 是狗”。</td></tr><tr><td><strong>设计图纸</strong></td><td><strong>真实标签 (True Label)</strong></td><td>正确答案，比如 “100% 是猫”。</td></tr><tr><td><strong>产品偏差</strong></td><td><strong>损失/误差 (Loss / Error)</strong></td><td>预测输出和真实标签之间的差距。由 <strong>损失函数 (Loss Function)</strong> 计算得出。</td></tr><tr><td><strong>从后往前追责分锅</strong></td><td><strong>反向传播 (Backpropagation)</strong></td><td>将总误差从输出层开始，一层层向输入层传播，计算出每一层权重对总误差的“贡献度”。</td></tr><tr><td><strong>调整机器参数</strong></td><td><strong>权重更新 (Weight Update)</strong></td><td>使用一种叫做 <strong>梯度下降 (Gradient Descent)</strong> 的方法，根据计算出的“贡献度”来微调网络中所有的权重，目的是让总误差变小。</td></tr></tbody></table><h3 id="三、核心工具：微积分里的-“链式法则”">三、核心工具：微积分里的 “链式法则”</h3><p>你可能会问，每个工人是怎么精确计算出他应该背多大的“锅”呢？</p><p>这里的“锅”在数学上，就是 <strong>梯度 (Gradient)</strong>，简单理解就是 <strong>导数</strong>。导数衡量的是 “如果我稍微动一下这个参数，最终的误差会改变多少”。</p><ul><li>如果导数很大 (无论是正还是负)，说明这个参数对最终误差的影响很大，是“主要责任人”，需要大幅调整。</li><li>如果导数很小，接近 0，说明它基本没啥影响，是“吃瓜群众”，基本不用动。</li></ul><p>反向传播算法的数学精髓，就是应用了微积分里的 <strong>链式法则 (Chain Rule)</strong>。</p><p><strong>链式法则通俗解释</strong>：如果 C 的变化依赖于 B，而 B 的变化又依赖于 A，那么链式法则可以帮助我们计算出 A 的微小变化最终会对 C 产生多大的影响。</p><p>在神经网络里，最终的误差 (Loss) 是输出层 (Output Layer) 的函数，输出层又是前一个隐藏层 (Hidden Layer) 的函数，以此类推，直到输入层。反向传播正是利用链式法则，高效地计算出 <strong>总误差</strong> 相对于 <strong>网络中每一个权重</strong>的梯度 (导数)。它就像一套完美的公式，能精确地把“锅”不多不少、恰如其分地分配给每一个相关的参数。</p><h3 id="四、总结：反向传播的完整流程">四、总结：反向传播的完整流程</h3><p>所以，神经网络的学习过程（训练）可以总结为以下循环往复的步骤：</p><ol><li><strong>正向传播 (Forward Pass)</strong>：<ul><li>给网络一个输入数据 (例如一张图片)。</li><li>数据从输入层开始，经过每一层神经元的计算 (乘以权重，加上偏置，再通过激活函数)，最后到达输出层，得到一个预测结果。</li><li>这就像把原材料放上传送带，走完整条流水线，得到最终产品。</li></ul></li><li><strong>计算损失 (Calculate Loss)</strong>：<ul><li>用损失函数比较网络的预测结果和真实的正确答案，计算出它们之间的差距，即总误差 (Loss)。</li><li>这就像质检员检查最终产品，看它和设计图纸差了多少。</li></ul></li><li><strong>反向传播 (Backward Pass / Backpropagation)</strong>：<ul><li>这是最关键的一步。从总误差出发，利用链式法则，从输出层开始，反向逐层计算出网络中 <strong>每一个权重</strong> 对这个总误差的“贡献度”(梯度)。</li><li>这就像 CEO 拿着质检报告，从后往前追责，精确地给每个工序“分锅”。</li></ul></li><li><strong>更新权重 (Update Weights)</strong>：<ul><li>根据反向传播计算出的“贡献度”(梯度)，使用梯度下降等优化算法，对网络中所有的权重进行微小的调整。调整的方向是 <strong>让总误差变小</strong> 的方向。</li><li>这就像每个工人接到“整改通知”后，都去微调自己的机器旋钮。</li></ul></li></ol><p>通过成千上万次地重复以上 4 个步骤，网络中的所有权重会逐渐被调整到最优状态，使得网络在接收新的输入时，能够做出非常准确的预测。</p><p>简单来说，<strong>反向传播就是神经网络高效学习的秘诀，它通过一个巧妙的“从后往前分锅”机制，告诉网络里的每一个参数应该如何自我调整，才能让最终的预测结果越来越准。</strong></p>]]></content>
    
    
    <summary type="html">本篇用 CEO 追责分锅的比喻，深入浅出地解释反向传播算法的工作原理，从流水线管理到神经网络训练，帮助你理解这个深度学习的核心算法</summary>
    
    
    
    <category term="大模型" scheme="https://hedon.top/categories/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="机器学习" scheme="https://hedon.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://hedon.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="大模型" scheme="https://hedon.top/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《Fundamentals of Software Architecture》</title>
    <link href="https://hedon.top/2025/07/24/note-fosa/"/>
    <id>https://hedon.top/2025/07/24/note-fosa/</id>
    <published>2025-07-24T03:01:24.000Z</published>
    <updated>2025-07-27T07:52:18.067Z</updated>
    
    <content type="html"><![CDATA[<h1>聊架构设计的时候，我们在谈什么？</h1><p><strong>第一步：理解商业与组织上下文 (Understand Business &amp; Organizational Context)</strong></p><ul><li><strong>利益相关方 (Stakeholders)</strong>: 他们的核心诉求和期望是什么？</li><li><strong>用户视角 (User Perspective)</strong>: 我们要为用户解决什么核心痛点？</li><li><strong>商业目标 (Business Goals)</strong>: 这个项目要达成什么商业指标？（例如：降低成本、提升转化率）</li><li><strong>组织能力 (Organizational Capabilities)</strong>:<ul><li>公司文化 (Company Culture): 我们的文化是拥抱变化还是追求稳定？</li><li>团队现状 (Team Status): 团队的技术栈、技能水平和规模如何？</li></ul></li></ul><p><strong>第二步：定义架构特性与约束 (Define Architectural Characteristics &amp; Constraints)</strong></p><p>这一步的目标是将第一步中模糊的需求，转化为具体、可度量的技术目标。</p><ul><li><strong>识别架构特性 (Identify Architectural Characteristics / -ilities)</strong>:<ul><li>从性能、可伸缩性、可用性、容错性、可维护性、安全性、成本等特性中，识别出本次设计<strong>最关键</strong>的 3-5 个。</li><li><strong>对它们进行排序</strong>。例如，对于一个后台管理系统，“可维护性”的优先级可能就高于“性能”。</li></ul></li><li><strong>明确约束条件 (Define Constraints)</strong>:<ul><li>有哪些不可逾越的红线？例如：预算上限、上线日期 (Time to Market)、必须使用公司内某技术平台、法律合规要求等。</li></ul></li></ul><p><strong>第三步：探索方案与决策 (Explore Solutions &amp; Make Decisions)</strong></p><p>有了第二步清晰的目标和边界，我们现在可以带着这些标准去评估方案。</p><ul><li><strong>探索可选方案 (Explore Options)</strong>: 至少寻找 2-3 个备选方案。</li><li><strong>进行权衡分析 (Analyze Trade-offs)</strong>: 基于第二步定义的<strong>架构特性优先级</strong>，系统地对比各方案的优劣。</li><li><strong>评估风险 (Assess Risks)</strong>: 每个方案可能引入哪些短期或长期的技术、成本、人员风险？</li><li><strong>记录决策 (Document Decisions)</strong>: 使用 ADR (Architecture Decision Record) 记录最终选择和放弃的原因。</li></ul><p><strong>第四步：设计实施路径与验证机制 (Design Implementation Path &amp; Verification)</strong></p><p>在真正开始大规模编码前，设计好如何走，以及如何验证我们走在正确的路上。</p><ul><li><strong>实施计划 (Implementation Plan)</strong>:<ul><li>是否需要技术原型 (PoC) 来验证关键难点？</li><li>如何进行任务拆解和里程碑规划？</li></ul></li><li><strong>构建适应度函数 (Build Fitness Functions)</strong>:<ul><li>针对第二步定义的关键架构特性，设计具体的“检验尺”。</li><li>例如：为保证“模块解耦”，设计一个静态代码检查规则，禁止模块间的非法调用。</li></ul></li><li><strong>知识沉淀 (Knowledge Sedimentation)</strong>: 准备好核心的架构图、设计文档等。</li></ul><p><strong>第五步：部署、观测与效果衡量 (Deploy, Observe &amp; Measure Effectiveness)</strong></p><p>将架构推向真实世界，并通过数据验证其价值。</p><ul><li><strong>持续交付 (CI/CD)</strong>: 作为将设计快速、可靠地部署到生产环境的手段。</li><li><strong>系统监控 (System Monitoring)</strong>: 观测系统的健康状况（CPU、内存、延迟、错误率等）。</li><li><strong>业务指标验证 (Business Metrics Verification)</strong>: <strong>（闭环关键）</strong> 验证是否达成了第一步定义的商业目标？例如，新架构上线后，用户转化率是否真的提升了？</li></ul><p><strong>第六步：复盘、沉淀与演进 (Retrospect, Internalize &amp; Evolve)</strong></p><ul><li><strong>问题记录与根因分析 (Problem Record &amp; Root Cause Analysis)</strong>: 发生了什么？为什么会发生？</li><li><strong>流程与原则改进 (Process &amp; Principle Improvement)</strong>: 如何优化我们的设计流程、技术原则，避免未来再犯？</li><li><strong>人员与组织成长 (Personnel &amp; Organizational Growth)</strong>: 团队通过这次项目学到了什么？需要组织哪些培训？</li></ul><h1>Fundamentals of Software Architectrue 笔记梳理</h1><blockquote><p>本章笔者将打散 FOSA 书中的各个知识点，并将它们贯穿在我们上面提到的整个架构设计闭环中，同时会添加一些书中没有的内容进行补充扩展。</p></blockquote><h2 id="1-理解商业与组织上下文">1. 理解商业与组织上下文</h2><blockquote><p>利益相关方：他们的核心诉求和期望是什么？</p><p>用户视角：我们要为用户解决什么核心痛点？</p><p>商业目标：这个项目要达成什么商业指标？</p><p>组织能力：我们的文化是拥抱变化还是追求稳定？团队的技术栈、技能水平和规模如何？</p></blockquote><h3 id="1-1-谈判技巧">1.1 谈判技巧</h3><p>FOSA 指出，架构师必须理解并驾驭企业的<strong>政治环境</strong>。几乎每一个架构决策都会受到挑战，这可能来自产品负责人、项目经理、业务利益相关方（因为成本或时间增加），甚至是开发者（认为有更好的方法）。</p><p>因此，架构师需要具备卓越的<strong>谈判和引导技能</strong> (Negotiation and Facilitation)，以理解各方诉求，并在分歧出现时达成共识。</p><p>FOSA 给出了几种谈判思路：</p><ol><li><strong>利用语法和流行语更好地理解情况。</strong> 软件架构师应注意业务利益相关者在沟通中使用的短语和流行语。例如，像“我们需要零停机时间”或“我昨天就需要这些功能”这样的表述，虽然可能不精确，但却能揭示出对可用性或上市时间等方面的真正关注。通过利用这些“废话语法”，架构师可以更好地理解对方真正的担忧和需求，从而在谈判中占据优势。</li><li><strong>在进入谈判之前收集尽可能多的信息。</strong> 在谈判之前，架构师应尽可能多地收集相关信息。例如，如果业务利益相关者坚持“五个九”的可用性（99.999%），架构师应提前研究这意味着什么，并将其转化为实际的停机时间（例如，每年约 31.5 秒的计划外停机时间）。充分掌握事实和数据有助于进行基于现实的讨论。</li><li><strong>当一切都失败时，说明成本和时间。</strong> 这是最后的谈判策略。尽管成本和时间（投入的工作量）是任何谈判中的关键因素，但应作为最后的手段使用。过早提及这些可能会使谈判陷入僵局，因为它们可能会被视为阻止或拒绝的借口。</li><li><strong>利用“分而治之”的原则来限定需求。</strong> 这一策略借鉴了孙子兵法中的思想，即“其力合者，离之”。当面临不合理或范围过大的要求时（例如，整个系统都需要“五个九”的可用性），架构师可以通过提问来缩小范围，确定哪些特定部分或功能真正需要这种高水平的特性。这样做可以减少困难且昂贵需求的范围，从而简化谈判。</li><li><strong>永远记住演示胜于讨论。</strong> 当与同事或开发人员在技术方法上存在分歧时，与其争论不休，不如通过实际的演示来证明你的观点。例如，如果你认为消息队列比 REST 更适合特定的服务间通信，可以在模拟生产环境中进行 A/B 测试，用数据和实际结果来说服对方。实际操作的证据通常比理论争论更有说服力。</li><li>**在谈判中避免过于争辩或让事情变得过于个人化——冷静的领导力结合清晰简洁的推理总能赢得谈判。**在讨论中，如果气氛变得过于激烈或个人化，最好的做法是暂停谈判，待双方冷静后再重新进行。作为领导者，保持冷静和专业的态度，并用清晰、简洁的逻辑进行推理，往往能够有效化解冲突，促使对方退让，最终达成共识。</li><li><strong>在说服开发人员采纳架构决策或执行特定任务时，提供理由而不是“高高在上地发号施令”。</strong> 架构师不应凭借职位来命令开发人员，而应通过提供充分的理由来说明为什么需要某个架构决策或任务。例如，解释“所有数据库调用都需要通过业务层”是为了“更好地控制变更”，这比单纯命令“你必须通过业务层”更容易被接受。理解背后的原因能促使开发人员更积极地接受并实施决策。</li><li><strong>如果开发人员不同意某个决策，让他们自己找到解决方案。</strong> 当开发人员对某个技术决策有异议时，与其直接反驳，不如挑战他们，让他们自己去探索并证明他们的替代方案。例如，如果开发人员坚持使用某个框架但你认为它不符合安全要求，可以让他们自行研究并展示如何解决安全问题。这不仅能促进开发人员的学习和思考，也能让架构师在最终解决方案上获得团队的认可和支持，形成双赢局面。</li></ol><h3 id="1-2-业务理解">1.2 业务理解</h3><p>架构决策必须<strong>提供业务价值</strong>。如果一个架构决策没有业务价值，它可能就不是一个好的决策，需要重新考虑。</p><p>FOSA 强调，架构决策的<strong>商业合理性</strong>至关重要。常见的商业合理性包括：<strong>成本</strong> (Cost)、<strong>上市时间</strong> (Time to Market)、<strong>用户满意度</strong> (User Satisfaction) 和<strong>战略定位</strong> (Strategic Positioning)。在与业务利益相关方谈判时，要重点关注他们最看重的指标。</p><p>这里面的一大难点就是：<strong>业务方与开发方使用的不是同一种&quot;语言&quot;</strong>。双方对同一件事情的关注点是不一样的，所以表述出来的述求，也是不同的。所以架构师的职责就是需要将业务领域的关注点和架构特性进行对应。</p><p>比如：</p><table><thead><tr><th>Domain Concern</th><th>Architecture characteristics</th></tr></thead><tbody><tr><td>Mergers and acquisitions 合并与收购</td><td>互操作性 interoperability<br>可扩展性 scalability<br>适配性 adaptability<br>可扩展性 extensibility</td></tr><tr><td>Time to market 上市时间</td><td>灵活性 agility<br/>可测试性 testability<br/>可部署性 deployability</td></tr><tr><td>User satisfaction 用户满意度</td><td>性能 performance<br/>可用性 availability<br/>容错性 fault tolerance<br/>可测试性 testability<br/>可部署性 deployability<br/>灵活性 agility<br/>安全性 security</td></tr><tr><td>Competitive advantage 竞争优势</td><td>灵活性 agility<br/>可测试性 testability<br/>可部署性 deployability<br/>可扩展性 scalability<br/>可用性 availability<br/>容错性 fault tolerance</td></tr><tr><td>Time and budget 时间和预算</td><td>简单性 simplicity<br/>可行性 feasibility</td></tr></tbody></table><p>另外， 随着业务的发展，关注点也是在不断发生变化的，这个时候，架构所侧重的架构特性也是随之改变。</p><h2 id="2-定义架构特性与约束">2. 定义架构特性与约束</h2><blockquote><p>识别架构特性：从性能、可伸缩性、可用性、容错性、可维护性、安全性、成本等特性中，识别出本次设计最关键的 3-5 个。</p><p>明确约束条件：有哪些不可逾越的红线？</p></blockquote><h3 id="2-1-架构特性定义">2.1 架构特性定义</h3><p>架构师的核心职责之一就是识别和定义系统的<strong>架构特性</strong> (Architecture Characteristics)。这些特性定义了系统的<strong>成功标准</strong>，并且通常与系统的<strong>功能性</strong> (Functionality) 正交。</p><p>一个属性要成为架构特性（Architecture Characteristics），需至少满足 3 个条件：</p><ol><li><strong>指定非领域设计考量</strong>：架构特性关注的是应用程序&quot;如何&quot;实现需求以及做出某些选择&quot;为何&quot;的原因，而不是应用程序&quot;应该做什么&quot;的业务需求。例如，性能水平通常不会出现在需求文档中，但却是重要的架构特性。</li><li><strong>影响设计的某个结构方面</strong>：如果一个架构特性需要特殊结构考虑才能成功，那么它就会上升到架构特性的层面。例如，一般的安全性对于几乎所有项目都是必需的，但当需要设计特定的模块、组件或服务来隔离关键安全问题时，安全才成为一个架构特性。</li><li><strong>对应用程序的成功至关重要</strong>：应用程序可以支持大量的架构特性，但并非所有都应该被支持。支持每个架构特性都会增加设计的复杂性，因此，架构师的关键任务是选择最少的、对应用程序成功至关重要或重要的架构特性，而不是尽可能多的。</li></ol><h3 id="2-2-架构特性类型">2.2 架构特性类型</h3><ul><li><strong>显性架构特性</strong>：是在需求规范中明确列出的，作为必要设计的一部分。它们通常直接出现在需求文档或其他具体说明中。</li><li><strong>隐性架构特性</strong>：很少出现在需求文档中，但它们对于项目的成功是必需的。架构师必须利用他们对问题领域的知识，在分析阶段发现这些特征。</li></ul><p>可进一步细分为：操作特性、结构特性和交叉特性。</p><p>操作性架构特性涵盖了系统的<strong>运行能力</strong>，例如性能、可伸缩性、弹性、可用性和可靠性等。这些特性通常与运营和 DevOps 关注点高度重叠。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>Availability</td><td>系统需要保持可用的时间长度；例如，如果需要 24/7 可用，则需要采取措施确保系统始终可用。它指的是软件可操作和可访问的程度。</td></tr><tr><td>Continuity</td><td>灾难恢复能力。</td></tr><tr><td>Performance</td><td>衡量应用程序请求和响应周期所需的时间。它包括压力测试、高峰分析、功能使用频率分析、所需容量和响应时间。它也可以是更具体的度量，例如首屏渲染时间，即网页首次可见的时间。</td></tr><tr><td>Recoverability</td><td>业务连续性要求（例如，发生灾难时，系统需要多快才能重新上线？）这将影响备份策略和对复制硬件的要求。它也指软件从故障中恢复的能力，通过恢复任何受影响的数据并重新建立系统的所需状态。</td></tr><tr><td>Reliability/Safety</td><td>评估系统是否需要具备故障安全能力，或者其任务关键性是否影响生命。如果系统发生故障，是否会给公司带来巨额损失。它指系统在指定条件下和指定时间内运行的程度。</td></tr><tr><td>Robustness</td><td>在互联网连接中断、断电或硬件故障时，处理错误和边界条件的能力。</td></tr><tr><td>Scalability</td><td>系统随着用户或请求数量的增加而执行和运行的能力。这意味着处理大量并发用户而不会出现严重的性能下降。</td></tr></tbody></table><p>结构性架构特性关注<strong>代码结构</strong>。在许多情况下，架构师对代码质量问题负有独立或共同的责任，例如良好的模块化、组件间的受控耦合、可读性强的代码以及其他内部质量评估。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>Configurability</td><td>最终用户通过可用界面轻松更改软件配置方面的能力。</td></tr><tr><td>Extensibility</td><td>系统的可扩展性。</td></tr><tr><td>Installability</td><td>系统在所有必要平台上安装的便捷性。它指软件在指定环境中安装和/或卸载的程度。</td></tr><tr><td>Leverageability/Reuse</td><td>跨多个产品利用通用组件的能力。它指开发人员在多个系统或构建其他资产中重复使用资产的程度。</td></tr><tr><td>Maintainability</td><td>开发人员修改、纠正或使其适应环境和/或需求变化的有效性和效率程度。</td></tr><tr><td>Portability</td><td>系统是否需要在多个平台上运行。它指开发人员将系统、产品或组件从一个硬件、软件或其他操作或使用环境转移到另一个环境的程度。</td></tr><tr><td>Supportability</td><td>应用程序所需的技术支持级别。系统中调试错误所需的日志记录及其他设施的级别。</td></tr><tr><td>Upgradeability</td><td>从该应用程序/解决方案的旧版本轻松/快速升级到新版本的能力。</td></tr></tbody></table><p>交叉架构特性指的是那些难以归类或超出传统类别，但却形成重要设计约束和考虑的特性。</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>Accessibility</td><td>确保所有用户（包括色盲或听力障碍等残障用户）能够访问系统。它指使软件可供具有最广泛特征和能力的人使用。</td></tr><tr><td>Archivability</td><td>数据是否需要在一段时间后归档或删除。</td></tr><tr><td>Authentication</td><td>确保用户是其所声称的身份的安全要求。</td></tr><tr><td>Authorization</td><td>确保用户只能访问应用程序内特定功能（按用例、子系统、网页、业务规则、字段级别等）的安全要求。</td></tr><tr><td>Legal</td><td>系统在哪些法律约束下运行（数据保护、萨班斯-奥克斯利法案、GDPR 等）？公司需要哪些保留权利？关于应用程序构建或部署方式的任何规定。</td></tr><tr><td>Privacy</td><td>隐藏内部公司员工交易信息的能力（加密交易，甚至数据库管理员和网络架构师都无法查看）。</td></tr><tr><td>Security</td><td>数据是否需要在数据库中加密？内部系统之间网络通信是否需要加密？远程用户访问需要何种类型的认证？它指软件保护信息和数据的程度，以便人员或其他产品或系统具有与其授权类型和级别相称的数据访问程度。</td></tr><tr><td>Supportability</td><td>应用程序所需的技术支持级别。系统中调试错误所需的日志记录及其他设施的级别。</td></tr><tr><td>Usability/Achievability</td><td>用户使用应用程序/解决方案实现目标所需的培训水平。它指用户可以有效、高效、满意地使用系统达到预期目的。</td></tr></tbody></table><h3 id="2-3-架构特性选择">2.3 架构特性选择</h3><p>架构特性不是越多越好：</p><ul><li><strong>增加系统设计的复杂性</strong>：每增加一个架构特性，都会使整个系统设计变得更加复杂。支持过多的架构特性会导致在架构师和开发人员开始解决核心业务问题之前，系统就变得越来越复杂。</li><li><strong>分散对核心问题的关注</strong>：架构特性定义了系统的成功标准，通常与系统的功能性正交，关注的是“如何”实现需求以及“为什么”做出某些选择。然而，如果过度追求特性数量，可能会导致偏离原始的业务问题，即开发软件的最初动机。</li><li><strong>每个特性都涉及权衡</strong>：软件架构中的每一个方面都存在权衡，有优点也有缺点。例如，在拍卖系统中，选择使用主题（topic）进行通信可能带来架构可扩展性的优势和服务的解耦，但会引入数据访问和数据安全方面的潜在问题，并且不支持异构契约。而使用队列（queue）则允许每个消费者拥有自己的契约，但不具备可扩展性，并且会增加服务间的耦合。架构师需要分析这些权衡，并根据业务驱动因素和环境选择最重要的特性。</li><li><strong>过度规范的危害</strong>：架构师过度规范架构特性是常见的陷阱，其破坏性不亚于规范不足，因为它会使系统设计过于复杂。历史案例“瓦萨号”战舰的失败就是一个例证，它是因为过度追求建造最宏伟的战舰（即过度规范架构特性）而最终导致沉没。</li><li><strong>陷入“意外复杂性”陷阱</strong>：架构师有时会为解决方案、图表和文档添加不必要的复杂性。正如一位作者所言，“开发者被复杂性吸引，就像飞蛾扑火一样——结果往往相同”。这种“意外复杂性”是由于人为地使问题复杂化，而不是问题本身固有的复杂性。通过识别子领域类型并根据其业务逻辑的复杂性选择合适的实现模式（例如，事务脚本和活动记录适用于简单业务逻辑，而领域模型和事件溯源领域模型适用于复杂的核心子领域），可以避免引入不必要的复杂性。</li><li><strong>设计应由业务驱动</strong>：领域驱动设计（DDD）的核心思想在于让业务领域驱动软件设计决策。这意味着设计决策应该基于业务领域的需求和战略，而非盲目地堆砌所有可能的架构特性。</li></ul><p>因此，与领域利益相关者合作时，架构师应努力使最终的架构特性列表尽可能短，因为每个特性都会增加总体系统设计的复杂性。</p><h2 id="3-探索方案与决策">3. 探索方案与决策</h2><blockquote><p>探索可选方案 ：至少寻找 2-3 个备选方案。</p><p>进行权衡分析：基于第二步定义的架构特性优先级，系统地对比各方案的优劣。</p><p>评估风险：每个方案可能引入哪些短期或长期的技术、成本、人员风险？</p><p>记录决策：使用 ADR (Architecture Decision Record) 记录最终选择和放弃的原因。</p></blockquote><h3 id="3-1-架构风格">3.1 架构风格</h3><h4 id="3-1-1-分层架构-Layered-Architecture">3.1.1 分层架构 Layered Architecture</h4><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/layer.png" alt="3.1.1 分层架构"></p><p>分层架构的<strong>核心驱动力</strong>是<strong>关注点分离（Separation of Concerns）</strong>。它将一个复杂的系统按照不同的职责或技术关注点，垂直地划分成若干个水平的“层（Layer）”。</p><p>这些层之间存在一个至关重要的约束：<strong>依赖关系是单向的</strong>。通常来说，上层可以依赖下层，但下层绝对不能依赖上层。例如，表现层可以调用业务逻辑层，但业务逻辑层不应该知道任何关于表现层的具体实现细节。</p><p>优点：</p><ul><li><strong>简单性（Simplicity）和低成本（Cost）</strong>：分层架构模式非常成熟，广为人知，开发团队的学习成本极低。对于中小型项目、预算有限的初创公司或内部管理系统，它是一个&quot;足够好&quot;的、性价比极高的起点。</li><li><strong>可维护性（Maintainability）</strong>：如前所述，只要遵循了隔离层原则，系统的维护和迭代会非常清晰。对于那些业务逻辑相对稳定、变更不频繁的系统，这是一个巨大的优势。</li><li><strong>整体可部署性（Deployability）</strong>：分层架构天然倾向于构建<strong>单体应用（Monolith）</strong>。整个应用被打包成一个单元（例如一个 WAR 包或一个可执行文件）进行部署。这极大地简化了部署和运维的复杂度，尤其是在项目早期或运维能力有限的团队中。</li></ul><p>缺点：</p><ul><li><strong>技术分区而非领域分区</strong>：分层架构是一种技术分区架构。这意味着它的组件是根据其在架构中的技术角色（如表示层、业务层、持久层），而不是根据业务领域（如客户、订单）进行分组的。这会导致任何特定的业务领域（例如“客户”领域）的逻辑都会分散在架构的所有层中。同时，当需要对特定业务领域的需求进行更改时，由于其逻辑分散在多个技术层中，开发人员必须在所有相关层中进行修改，这降低了开发的敏捷性。</li><li><strong>部署风险高</strong>：在分层架构中，即使是对少量代码的更改（例如，一个类文件中简单的三行更改），也需要重新部署整个部署单元。这种部署往往会捆绑数十个其他更改，从而显著增加了部署风险，且部署频率受到限制。</li><li><strong>测试范围大且不完整</strong>：由于整个应用程序是作为一个大型单体单元部署的，开发人员通常不会为简单的三行更改花费数小时执行完整的回归测试套件。这导致测试覆盖范围不完整，并且难以确保更改不会影响看似不相关的部分。</li></ul><h4 id="3-1-2-管道架构-Pipeline-Architecture">3.1.2 管道架构 Pipeline Architecture</h4><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250715105907327.png" alt="3.1.2 管道架构"></p><p>管道架构，又称为管道与过滤器架构（Pipes and Filters Architecture），是一种用于处理数据流的强大模式。它的核心思想非常直观，就像一条工厂的流水线：原材料从一端进入，经过一系列独立工站的加工、处理、检验，最终在另一端形成成品。</p><p>要理解管道架构，首先要理解它的两个基本构件：</p><ul><li><strong>过滤器 (Filter)</strong>：它是一个独立的、可执行的处理单元，负责接收数据、执行单一任务（例如转换格式、过滤内容、扩充信息），然后将处理后的数据传递出去。关键在于，每个过滤器都是**自包含（Self-Contained）<strong>和</strong>无状态（Stateless）**的，它不关心上一个过滤器是谁，也不关心下一个过滤器是谁。</li><li><strong>管道 (Pipe)</strong>：代表流水线上的&quot;传送带&quot;。它是一个<strong>单向</strong>的数据通道，负责将一个过滤器处理完的数据传递给下一个过滤器。</li></ul><p>过滤器一般又分为 4 种：</p><ul><li><strong>生产者 (Producer / Source)</strong>：作为整条管道的<strong>起点</strong>。它不接收来自管道的数据，而是负责创建数据，并将这些初始数据泵入管道。</li><li><strong>转换器 (Transformer)</strong>：它从上游管道接收数据，对其进行某种形式的<strong>修改或转换</strong>，然后将结果发送到下游管道。</li><li><strong>测试器 (Tester)</strong>：它接收数据，并根据一个或多个条件对数据进行<strong>检验</strong>。如果数据满足条件，就将其传递到下游管道；如果不满足，则数据流在此处被中断（或被导向另一条错误处理管道）。</li><li><strong>消费者 (Consumer / Sink)</strong>：作为整条管道的<strong>终点</strong>。它从上游管道接收最终处理好的数据，并将其消费掉，通常不会再将数据传递出去。</li></ul><p>优点:</p><ul><li><strong>成本低且简单</strong>：作为一种单体架构，管道架构不具备分布式架构风格所带来的复杂性，因此它简单易懂，并且构建和维护成本相对较低。</li><li><strong>高模块化</strong>：通过不同过滤器类型之间关注点的分离，实现了架构的模块化。任何过滤器都可以修改或替换而不影响其他过滤器。</li><li><strong>部署性和可测试性较好</strong>：由于其模块化程度较高，部署性和可测试性略优于分层架构，但仍受单体应用固有的部署仪式、风险和测试完整性等因素的影响。</li></ul><p>缺点:</p><ul><li><strong>单体特性带来的限制</strong>：尽管在模块化方面有所改进，但它仍然是一种单体应用。这意味着部署的仪式感、风险、部署频率以及测试的完整性都会受到单体特性的影响。例如，对任何更改都需要测试和部署整个单体应用。</li><li><strong>弹性低</strong>：由于其单体部署和缺乏架构模块化，管道架构的弹性评级非常低（一星）。尽管可以在单体内部实现某些功能的伸缩，但这通常需要复杂的设计技术，而管道架构并不擅长此道。</li><li><strong>可伸缩性差</strong>：与弹性类似，由于是单体架构且缺乏模块化，可伸缩性也评级很低。应用程序的伸缩能力受限于单一系统量子。</li><li><strong>性能一般</strong>：管道架构不适合高性能系统，因为它缺乏并行处理能力、存在闭合分层（closed layering）以及可能出现&quot;架构下沉&quot;（sinkhole anti-pattern）问题。</li></ul><h4 id="3-1-3-微核架构-Microkernel-Architecture">3.1.3 微核架构 Microkernel Architecture</h4><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250716105151041.png" alt="3.1.3 微核架构"></p><p>微核架构，也被称为<strong>插件化架构（Plug-in Architecture）</strong>，是一种能够提供极高扩展性、灵活性和演化能力的系统设计模式。它的核心思想是将系统功能划分为两部分：一个最小化的、稳定的**核心系统（Core System）<strong>和一个由独立</strong>插件组件（Plug-in Components）**构成的可扩展生态。</p><ul><li><strong>核心系统 (Core System)</strong>：这是架构的&quot;微核&quot;。它的职责被严格限制在最小且必要的范围内，通常只包含：<ol><li>系统运行所必需的通用业务逻辑（例如，一个 IDE 的文件管理和基础编辑器）。</li><li>一个至关重要的<strong>插件管理机制</strong>，包括插件的注册、发现、生命周期管理等。这是连接核心与插件的桥梁。</li></ol></li><li><strong>插件组件 (Plug-in Components)</strong>：这些是独立的、可插拔的模块，用于实现<strong>扩展功能或特定业务逻辑</strong>。每个插件都通过一个由核心系统定义的**标准契约（Standard Contract）**来与核心交互。这个契约通常是一个接口或一组 API。</li></ul><p>优点：</p><ul><li><strong>高模块化与扩展性</strong>：微内核架构通过插件组件实现了高度模块化和扩展性。应用程序逻辑被划分为核心系统和独立的插件组件，从而提供了可扩展性、适应性以及应用程序特性和自定义处理逻辑的隔离。任何插件都可以修改或替换而不影响其他组件，例如，添加一个新的电子设备评估逻辑只需添加一个新的插件组件并更新注册表。</li><li><strong>成本较低且相对简单</strong>：作为一种单体架构，微内核架构避免了分布式架构风格所带来的复杂性，因此它简单易懂，并且构建和维护成本相对较低。</li><li><strong>部署性和可测试性较好</strong>：由于其模块化程度较高，功能可以隔离到独立的插件组件中。如果做得好，这可以减少整体测试范围并降低部署风险，尤其是在运行时部署插件组件的情况下。因此，可部署性和可测试性略优于分层架构。</li><li><strong>领域与架构的同构性</strong>：微内核架构可以<strong>同时进行领域分区和技术分区</strong>。对于需要针对每个位置或客户端进行不同配置的问题，或者那些强调用户定制和功能扩展性的产品（例如 Jira 或Eclipse IDE），这种架构风格非常适用。</li></ul><p>缺点：</p><ul><li><strong>单体特性带来的限制</strong>：尽管在模块化方面有所改进，但它<strong>仍然是一种单体应用</strong>。这意味着部署的仪式感、风险、部署频率以及测试的完整性都会受到单体特性的影响。</li><li><strong>弹性低</strong>：由于其单体部署和缺乏架构模块化，微内核架构的<strong>弹性评级非常低</strong>（一星）。尽管可以在单体内部实现某些功能的伸缩，但这通常需要复杂的设计技术。</li><li><strong>可伸缩性差</strong>：与弹性类似，由于是单体架构且缺乏模块化，可伸缩性也<strong>评级很低</strong>（一星）。所有请求都必须<strong>通过核心系统才能到达独立的插件组件</strong>。</li></ul><h4 id="3-1-4-基于服务的架构-Service-Based-Architecture">3.1.4 基于服务的架构 Service-Based Architecture</h4><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250717114456233.png" alt="3.1.4 基于服务的架构 SBA"></p><p>如果说单体（Monolith）和微服务（Microservices）是两个广为人知的端点，那么基于服务的架构（Service-Based Architecture, SBA）就是它们之间那个常常被忽略，却又极具现实意义的&quot;务实中间派&quot;。它既非庞大到笨拙，也非精细到繁杂，为许多成长中的系统提供了一条平滑的演进路径。</p><p>SBA 的本质是一种将一个大型的单体应用，<strong>分解为少数几个、逻辑独立的、可独立部署的&quot;服务&quot;</strong> 的架构风格。SBA 的服务数量通常不多，一般在 <strong>4 到 12 个</strong>之间。它不像微服务那样追求极致的拆分（可能会有几十上百个服务），而是将应用按照**核心的业务领域（Domain）**进行划分。</p><p>与微服务不同的是 SBA 的典型实现是，所有服务共享<strong>同一个数据库</strong>。这种设计的初衷是为了在享受独立部署带来的好处的同时，最大限度地<strong>降低数据层面的复杂性</strong>。共享数据库可以：</p><ul><li><strong>简化开发</strong>：开发者无需处理复杂的分布式事务和跨服务数据同步问题。</li><li><strong>保证数据一致性</strong>：传统的 ACID 事务可以在数据库层面轻松实现。</li><li><strong>降低技术门槛</strong>：团队无需掌握复杂的分布式数据管理技术。</li></ul><p>随着业务发展，共享数据库的弊端会逐渐显现。在以下情况下，拆分数据库就成了合理的选择：</p><ol><li><strong>服务资源争用 (Service Contention)</strong>：某个服务（如高流量的商品浏览服务）对数据库产生巨大压力，影响了其他关键服务（如订单服务）的性能。</li><li><strong>数据隔离与安全 (Data Isolation and Security)</strong>：某个服务处理的数据高度敏感（如支付服务中的金融信息），需要从主数据库中物理隔离出来，以满足合规性或安全要求。</li><li><strong>技术栈不匹配 (Technology Mismatch)</strong>：某个服务有特殊的数据存储需求。例如，搜索服务最适合使用 Elasticsearch，而核心业务数据则存储在关系型数据库中。</li></ol><p>当这些情况发生时，SBA 允许你&quot;渐进式&quot;地将某个服务连同其数据一起剥离出去，赋予它独立的数据库。</p><p>优点：</p><ul><li><strong>可部署性 (Deployability)</strong>：这是最大的优势之一。每个服务都可以独立部署，使得发布更加频繁、风险更低。</li><li><strong>模块化 (Modularity)</strong>：通过按领域划分服务，实现了清晰的业务模块边界。</li><li><strong>可维护性 (Maintainability)</strong>：每个服务的代码库规模远小于整个单体，更易于理解、修改和维护。</li><li><strong>容错性 (Fault Tolerance)</strong>：一个服务的崩溃不会导致整个应用程序宕机（尽管共享数据库可能成为共同的故障点）。</li><li><strong>保留ACID事务</strong>：这是其相对于其他细粒度分布式架构（如微服务）的一大优势。由于领域服务是粗粒度的，事务通常限制在一个服务内部，可以利用传统的 ACID 事务来保证<strong>数据完整性和一致性</strong>。</li></ul><p>缺点：</p><ul><li><strong>弹性低</strong>：尽管可以在单体内部实现某些功能的伸缩，但由于其单体部署和缺乏架构模块化，弹性评级仍然较低。</li><li><strong>可伸缩性受限</strong>：虽然可以扩展，但由于服务粒度较粗，与微服务等细粒度服务相比，在机器资源方面效率不高，成本效益也较低。</li><li><strong>部署风险</strong>：虽然比传统单体应用有所改进，但由于部署的代码量仍然较大，其<strong>部署风险</strong>仍然高于微服务架构。</li></ul><h4 id="3-1-5-事件驱动架构-Event-Driven-Architecture">3.1.5 事件驱动架构 Event-Driven Architecture</h4><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718110824820.png" alt="3.1.5 事件驱动架构"></p><p>在传统的<strong>请求驱动模型</strong>中，系统接收请求后会确定性地、同步地将请求路由到各个请求处理器来处理数据。而事件驱动模型则不同，它<strong>对特定情况做出反应，并根据该事件采取行动</strong>。</p><p>EDA 的力量源泉来自于异步通信，它有以下优点：</p><ol><li><strong>极高的系统韧性与可用性 (Resiliency and Availability)</strong>：在同步调用中，如果服务 B 宕机，服务 A 的调用会立刻失败，导致整个链路中断。但在异步模式下，服务 A 将事件发送给一个中间人（消息代理），然后就可继续自己的工作。即使服务 B 此时宕机，事件也会被安全地存放在代理中，待 B 恢复后再进行处理。这使得系统能够优雅地处理局部故障，整体可用性大大提高。</li><li><strong>卓越的可伸缩性与弹性 (Scalability and Elasticity)</strong>：生产者和消费者被完全解耦，可以独立进行伸缩。如果事件产生的速度突然加快，我们只需要增加消费者实例的数量即可，而无需对生产者做任何改动。这种按需、独立伸缩的能力是构建高弹性系统的关键。</li></ol><p>典型的 EDA 有 2 种拓扑，分别为代理模式（broker）和中介者模式（mediator），二者最大的区别在于后者具有一个统一的协调者，这会对异常处理、全局统筹有很好的管控手段，当同时也牺牲了系统的解耦程度、灵活度和性能。</p><p>在 EDA 中，有几个典型的问题需要关注：</p><ul><li><p><strong>异常处理</strong>：可采用 workflow event pattern 工作流事件模式。事件处理后，如果失败了，就告知 <code>workflow process</code>。<code>workflow processor</code> 识别错误，如果能自动处理，就自动处理，并丢回原始队列中，重新执行。如果不能处理，就放到 dashbord 上，人工检查、校正或重试。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250725163511396.png" alt="workflow event pattern 工作流事件模式"></p></li><li><p><strong>数据丢失</strong>：发送事件到 channel 的路上、channel 转发事件到处理器的路上和处理器处理完持久化到 db 的路上都有可能发生数据的丢失。可以通过同步发送、持久化队列、ACK 机制和事务型 DB 来解决这个问题。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250725163644273.png" alt="防止 EDA 数据丢失的思路"></p></li><li><p><strong>返回响应</strong>：如果希望在事件驱动架构中实现请求-响应的能力，可以消息的两个元数据字段：<strong>回复地址 (Reply-To)</strong> 和 <strong>关联标识 (Correlation ID)</strong> 来通过回传通道返回响应数据。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718132839093.png" alt="EDA 返回响应数据的处理思路"></p></li></ul><p>优点：</p><ul><li><strong>可伸缩性与弹性 (Scalability &amp; Elasticity)</strong>：独立伸缩组件的能力是其核心优势。</li><li><strong>可扩展性 (Extensibility)</strong>：系统极易扩展。当需要增加新功能时，只需开发一个新的服务来订阅感兴趣的现有事件即可，完全无需改动已有服务。</li><li><strong>响应性 (Responsiveness)</strong>：对于需要快速响应用户的系统，可以将耗时任务异步化。例如，用户提交视频后，系统立即返回&quot;上传成功，正在处理中&quot;，然后通过事件驱动后台的转码、审核等一系列复杂流程。</li></ul><p>缺点：</p><ul><li><strong>简单性 (Simplicity)</strong>：EDA 显著增加了系统的复杂性。你需要管理消息代理，处理异步编程的挑战（如调试、错误处理），并应对最终一致性带来的心智负担。</li><li><strong>事务性 (Transactional)</strong>：实现跨多个服务的原子性操作（即分布式事务）变得异常困难。虽然可以通过 Saga 等模式来模拟长事务，但其实现复杂，且只能保证最终一致性而非强一致性。</li><li><strong>工作流的可观测性 (Observability of Workflow)</strong>：尤其是在代理拓扑中，业务流程被分散到各个独立的处理器中，没有一个集中的地方可以让你直观地看到一个完整的业务流程是如何执行的，这给监控和排错带来了巨大挑战。</li></ul><h4 id="3-1-6-空间架构-Space-Based-Architecture">3.1.6 空间架构 Space-Based Architecture</h4><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250721175147426.png" alt="3.1.6 空间架构"></p><p>传统三层 Web 拓扑在用户量剧增时呈倒三角：Web 层易横向扩容，数据库层最难扩容，最终成为性能上限。为削弱数据库瓶颈，业界先用本地缓存，再出现集中式分布式缓存，但网络跳转仍是热点。把数据直接放到每个处理节点的 <strong>复制型内存网格</strong> 并实时同步，才真正让数据库从&quot;同步路径&quot;上消失，空间架构由此成形。</p><p>空间架构的名称来源于**元组空间（Tuple Space）**多个并行处理器通过共享内存进行通信。SBA 的核心理念便是将应用数据保存在内存中（in-memory），并在所有活跃的处理单元（Processing Units）复制，从而移除中心数据库作为同步约束，实现近乎无限的伸缩性。</p><p>空间架构由以下几个部分组成：</p><ul><li><p><strong>处理单元 Processing Unit：</strong></p><ul><li><p>处理单元包含了<strong>应用逻辑</strong>（包括基于 Web 的组件和后端业务逻辑）。</p></li><li><p>它还包含一个<strong>内存数据网格</strong>和<strong>复制引擎</strong>，通常由 Hazelcast、Apache Ignite 或 Oracle Coherence 等产品实现。</p></li><li><p>处理单元可以包含小型、单一用途的服务，类似于微服务</p></li></ul></li><li><p>**虚拟化中间件 Virtualized Middleware：**虚拟化中间件负责处理架构中的基础设施问题，控制数据同步和请求处理。它由以下四个关键组件组成：</p><ul><li><p><strong>消息网格（Messaging Grid）</strong>：它负责将请求转发到任何可用的处理单元。</p></li><li><p><strong>数据网格（Data Grid）</strong>：它是 SBA 中最重要和关键的组件，通常在处理单元内部以复制缓存的形式实现。它确保每个处理单元都包含完全相同的数据，数据复制是异步且快速的。</p></li><li><p><strong>处理网格（Processing Grid）</strong>：这是一个可选组件，用于管理<strong>协调请求处理</strong>，当一个业务请求涉及多个处理单元时，它会协调这些处理单元之间的请求。</p></li><li><p><strong>部署管理器（Deployment Manager）</strong>：该组件根据负载条件管理处理单元实例的<strong>动态启动和关闭</strong>，对于实现应用的弹性伸缩至关重要。</p></li></ul></li><li><p><strong>数据泵 Data Pumps：<strong>数据泵是</strong>将数据发送到另一个处理器，然后该处理器更新数据库</strong>的方式。它们总是<strong>异步</strong>的，提供内存缓存与数据库之间的<strong>最终一致性（Eventual Consistency）</strong>。消息机制是数据泵的常用实现方式，因为它支持异步通信、保证消息传递和维护消息顺序。</p></li><li><p>**数据写入器 Data Writers：**数据写入器（Data Writers）负责接收来自数据泵的消息，并用消息中包含的信息更新数据库。它们可以是服务、应用或数据中心（如 Ab Initio）。写入器的粒度可以根据数据泵和处理单元的范围而变化，例如，领域驱动的数据写入器可以处理特定领域（如客户）内的所有更新。</p></li><li><p>**数据读取器 Data Readers：**负责从数据库读取数据，并通过反向数据泵将其发送到处理单元。服务需要通过数据读取器访问数据的情况有三种：</p><ol><li>所有相同命名缓存的处理单元实例都崩溃时。</li><li>所有相同命名缓存的处理单元需要重新部署时。</li><li>需要检索复制缓存中不包含的归档数据时。</li></ol></li></ul><p>空间架构最大的一个问题就是<strong>数据冲突</strong>，不同的 processing unit 处理同一个业务逻辑相关的数据时，由于数据同步存在时序问题，所以很容易出现数据不一致的情况。</p><p>可以从以下几个因素进行冲突概率的评估：</p><ul><li>N：处理相同缓存的 processing unit 的数量</li><li>UR：缓存更新频率</li><li>S：缓存大小</li><li>RL：缓存复制的延迟</li></ul><blockquote><p>CollisitionRate = N × (UR^2^/S)  × RL</p></blockquote><p>如果估算出来的冲突概率无法接受，或者需要缓存在内存中的业务数据过多而超过单机负载时，也可以使用<strong>分布式缓存</strong>来替代复制缓存。</p><p>优点：</p><ul><li><strong>弹性（Elasticity）</strong>：处理单元可以根据负载动态启停，实现高度弹性。</li><li><strong>伸缩性（Scalability）</strong>：通过内存数据缓存和移除数据库约束，支持处理数百万并发用户。</li><li><strong>性能（Performance）</strong>：移除了数据库瓶颈，提供了极高的性能。</li></ul><p>缺点：</p><ul><li><strong>简洁性（Simplicity）</strong>：SBA 是一种<strong>非常复杂的架构风格</strong>，因为它涉及到缓存、最终一致性以及众多动态组件。</li><li><strong>可测试性（Testability）</strong>：由于需要模拟极高的伸缩性和弹性负载，<strong>测试复杂且成本高昂</strong>，许多高负载测试甚至需要在生产环境中进行，带来巨大风险。</li><li><strong>成本（Cost）</strong>：由于缓存产品许可费和高资源利用率，SBA 通常相对昂贵。</li></ul><h4 id="3-1-7-面向服务架构-Orchestration-Driven-Service-Oriented-Architecture">3.1.7 面向服务架构 Orchestration-Driven Service-Oriented Architecture</h4><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250722110031795.png" alt="3.1.7 面向服务架构"></p><p>编排驱动的面向服务架构（Orchestration-Driven Service-Oriented Architecture，简称 SOA）是一种在特定时代背景下演变而来的软件架构风格。它在 20 世纪 90 年代末企业快速扩张、需要更复杂的 IT 系统来适应增长的背景下出现。</p><ul><li><strong>资源稀缺性</strong>：在开源操作系统尚未被认为足够可靠用于严肃工作之前，操作系统和商业数据库服务器的许可费用昂贵且按机器收费。这导致架构师们被要求尽可能地实现<strong>重用</strong>，以优化成本。</li><li><strong>企业级重用</strong>：SOA 的一个主要目标是实现服务层面的重用，即逐步构建可随时间增量重用的业务行为。大型公司厌倦了重复编写软件，因此采取了逐步解决这个问题的策略。</li><li><strong>技术分层</strong>：这种架构风格也将<strong>技术分层</strong>理念推向了极致。其驱动哲学围绕着企业级的重用展开。</li></ul><p>这个架构在历史进程中是一个反面教材，它是核心思想就俩字：<strong>复用</strong>！</p><p>失败的最核心原因：过度重视技术，以技术为导向进行模块划分和复用尝试，而业务是不断演进变化的，最终技术与业务之间的隔阂无法弥补，功亏一篑。</p><p>其他原因还有：</p><ul><li>过度追求复用导致的高度耦合</li><li>编排引擎成为巨大的耦合点和瓶颈</li><li>技术分区带来的业务流程碎片化</li></ul><h4 id="3-1-8-微服务架构-Microservice-Architecture">3.1.8 微服务架构 Microservice Architecture</h4><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250723111539943.png" alt="3.1.8 微服务架构"></p><p>微服务架构的核心在于<strong>高度解耦</strong>。它<strong>倾向于复制而非耦合</strong>。这意味着，如果架构师的目标是高度解耦，那么他们会选择复制而不是重用。微服务通过物理上建模限界上下文（Bounded Context）的逻辑概念来实现高度解耦。</p><p>限界上下文（Bounded Context）是微服务设计理念的核心驱动力。这是一个愿与领域驱动设计（DDD）的概念。限界上下文代表了一种<strong>解耦</strong>风格。在限界上下文内，与特定领域相关的所有内部组件（如代码和数据库模式）都是紧密耦合的，但它们与外部限界上下文的任何内容（如其他数据库或类定义）是<strong>解耦</strong>的。</p><p>这种隔离使得每个服务可以<strong>独立演进</strong>，定义其自身所需的一切，而不必适应其他部分的约束。它<strong>避免了传统单体架构中常见的共享类和数据库作为集成点导致的紧密耦合问题</strong>。</p><p>所以微服务也是一个典型的领域分区架构，并且它倾向于将领域分区推到极致。</p><p>在划分微服务粒度时，以下三个方面是需要重点考虑的：</p><ol><li><strong>目的（Purpose）</strong>：微服务的首要目的应该是<strong>捕获一个领域或工作流</strong>。理想情况下，每个微服务都应该具有<strong>极高的功能内聚性</strong>，为整个应用程序贡献一个<strong>重要的行为</strong>。这意味着，服务应该专注于一个单一的、明确的业务功能。</li><li><strong>事务（Transactions）</strong>：限界上下文是业务工作流，通常需要<strong>在事务中协作的实体</strong>可以为服务边界提供良好的指示。由于分布式事务在分布式架构中会带来复杂性，架构师应尽量设计系统以<strong>避免跨服务的事务</strong>。如果需要跨服务事务，这可能表明服务粒度过细。事务边界通常是服务粒度的常见指标。</li><li><strong>通信（Communication）</strong>：如果一组服务为了完成功能而需要<strong>大量通信</strong>，那么将这些服务捆绑成一个更大的服务可能有助于<strong>避免过度的通信开销</strong>。换句话说，如果服务变得过于“多话”（chatty），频繁地相互调用，那么它们的边界可能需要重新评估，以减少不必要的<strong>全局复杂性</strong>。</li></ol><p>此外，业界也有一些其他的常用的判断方法：</p><ol><li><strong>变更频率</strong>：把一起变更/部署的东西放在一个服务，频率不同的拆开。</li><li><strong>耦合指标</strong>：如果拆分后跨服务调用暴增，说明拆太细；反之，如果内部复杂度过高且团队协作困难，可能太粗。</li><li><strong>认知负荷</strong>：一个团队能完全理解并独立维护的范围通常就是一个合理服务边界。</li></ol><p>在微服务架构中，有几个典型的问题需要关注：</p><ul><li><p><strong>基础设施复用</strong>：虽然微服务倾向于复制而非耦合，不过这更多是在业务层面，对于运维层面的基础设施，包括但不限于：<strong>监控（Monitoring）</strong>、<strong>日志记录（Logging）</strong>、<strong>断路器（Circuit Breakers）<strong>和</strong>服务发现（Service Discovery）</strong>，微服务是主张进行统一建设和复用的。</p></li><li><p><strong>服务协作方式</strong>：一般有编舞和编排 2 种协作方式：</p><ul><li><strong>编舞（Choreography）</strong>：是指多个服务<strong>相互之间直接通信</strong>，而<strong>没有中央协调器</strong>。服务（如同舞者）根据彼此发出的事件或信息自主响应和行动。</li><li><strong>编排（Orchestration）</strong>：是指通过一个<strong>单独的协调器服务</strong>来管理和控制工作流中多个服务的协调。协调器（如同乐队指挥）负责指导每个服务的执行顺序，并处理整个业务流程的状态和错误。在微服务中，架构师可以创建<strong>局部化的协调器服务</strong>来处理复杂的业务流程。</li></ul><p>微服务两者都支持。 不过编舞方式更符合微服务的高度解耦哲学，因为它不依赖于中央协调器，而是通过解耦的事件来实现通信，使用起来更简便。当然，在复杂的业务流程中，<strong>编舞环境下的错误处理和协调会变得更加复杂</strong>。如果业务流程<strong>本质上是耦合的</strong>，此时编排可能更为适合。</p></li><li><p>**数据一致性：**微服务主张尽可能避免分布式事务的问题，如果多个服务经常需要处理分布式事务问题，那最好将它们合而为一，直接在一个 ACID 事务中完成。在万不得已的时候，也可以采用如 saga 和最终一致性、人工补偿等方式来缓解数据一致性问题。</p></li></ul><p>优点：</p><ul><li><strong>高度解耦与小部署单元</strong>：微服务架构极力推崇<strong>高度解耦</strong>。每个服务都是<strong>极小的部署单元</strong>，且具备<strong>高度的独立性</strong>。这种解耦使得团队可以独立地开发、测试和部署服务，大大减少了对其他服务的依赖，从而提高了敏捷性。</li><li><strong>DevOps 革命与自动化</strong>：微服务架构的成功离不开 <strong>DevOps 革命和对操作关注点的自动化</strong>。自动化部署、自动化测试等现代工程实践是微服务存在的基础，它们极大地提高了部署频率、降低了部署风险，并保证了测试的完整性。</li><li><strong>更快的变更响应速度</strong>：由于服务范围小且高度解耦，当业务需求发生变化时，团队只需修改受影响的少量服务，而不是整个大型单体。这种<strong>增量式的演进</strong>能力使得组织能够<strong>更快地响应市场变化，提高时间到市场（time-to-market）的速度</strong>。</li><li><strong>单一职责与清晰边界</strong>：每个微服务都专注于一个<strong>单一的业务功能或领域</strong>。这种清晰的职责边界使得开发人员更容易理解、测试和维护代码，因为他们不必处理与服务无关的复杂性</li></ul><p>缺点：</p><ul><li><strong>网络调用开销（Network Call Overhead）</strong>：微服务是分布式架构。这意味着服务之间（乃至用户界面与服务之间）的通信需要通过网络进行。网络调用比本地方法调用耗时更长。当一个业务请求需要链式调用多个微服务时，累积的网络延迟会显著影响整体响应时间。</li><li><strong>安全验证开销（Security Verification Overhead）</strong>：在微服务架构中，由于每个服务都是独立的部署单元，因此每个服务端点都需要进行安全验证。这增加了额外的处理时间。这种“在每个入口处进行安全检查”的模式进一步降低了同步、高度分布式架构（如微服务）的性能。</li><li><strong>高复杂性（Complexity）</strong>：作为一种分布式架构，微服务固有的缺点在于运行时连接各个部分所带来的复杂性，为了解决由此带来了一系列问题，需要学习、使用甚至开发一系列的组件，会给团队带来更大的心智负担和运维难度。</li><li><strong>数据一致性（Data Consistency）</strong>：如上所述，但无法避免分布式事务时，为了处理数据一致性问题，会引入很大的非业务复杂性。</li></ul><h3 id="3-2-架构选择">3.2 架构选择</h3><p>软件架构第一原理：<font color="red"><strong>一切都是权衡</strong></font>。</p><p>软件架构第二原理：<font color="red"><strong>为什么比如何更重要</strong></font>。</p><p>在选择架构时，最典型的 3 个问题：</p><ol><li>单体还是分布式架构？</li><li>数据存在哪里？</li><li>异步还是同步通信？</li></ol><h4 id="3-2-1-单体-vs-分布式">3.2.1 单体 vs 分布式</h4><p>当团队规模有限、需求节奏温和，而且必须尽快交付可用版本时，单体依旧是上市速度最快且认知成本最低的形态：所有模块共用同一进程，Debug、部署、回滚都异常直接。</p><p>然而，随着业务子域越来越多、发布节奏愈发碎片化，巨石应用往往演变成&quot;所有人都必须一起上线或一起停机&quot;的瓶颈。此时把系统拆成若干服务，允许各自独立发布，能显著缓解排期冲突；同时也可以针对流量热点的子域单独扩容，而非整包扩容。</p><p>带来的复杂度在于网络调用、链路追踪、容错和 DevOps 自动化，一旦这些配套不到位，分布式的优势就会被运维复杂度和认知成本抵消。换言之，拆分前要先确认组织是否具备持续交付、自动化监控、故障演练等能力，否则分布式只会把&quot;技术债&quot;换成&quot;组织债&quot;。</p><h4 id="3-2-2-数据存储">3.2.2 数据存储</h4><p>如果系统只处理核心交易并且对强一致性要求极高，一体化的关系数据库依旧能提供最成熟、最易掌控的事务保障。随着并发数和存储量攀升，分库分表成为横向扩展的常规做法，但需要额外的分布式事务模式或 Saga 来保证业务完整性。</p><p>如果读写模式呈现极强的峰谷或结构多变，就非常适合引入键值、文档、列式乃至时序、图数据库等多模型共存策略。这样做的关键在于为每一类数据访问场景挑选最经济的存储形式，同时在数据治理层面清晰定义数据主权、法务合规和生命周期。</p><h4 id="3-2-3-同步-vs-异步">3.2.3 同步 vs 异步</h4><blockquote><p><strong>一般原则：优先使用同步通信，必要时使用异步通信。</strong></p></blockquote><p><strong>同步调用</strong>（如 REST 或 gRPC）带来的是即时反馈和易于调试的调用链，适用于用户交互需要立刻响应的场合。然而它也拉高了两个服务在时间维度上的耦合：只要任意环节超时或故障，整个链路都会受影响。</p><p><strong>异步消息</strong>则通过中间件把调用方与被调用方解耦，让系统可以削峰填谷并获得天然的弹性缓冲区；代价是业务体验不再“即时”，而且需要额外处理幂等、重复消费、消息顺序、死信等问题。通常情况下，读取或修改单一资源这一类“命令/查询”仍倾向同步；任务排队、事件通知、工作流编排与数据集成则更适合异步。若核心场景必须保证强一致性，仍可采用同步事务或锁；而能够容忍短暂的不一致时，则转而采用事件驱动的最终一致模式。</p><h3 id="3-3-风险评估">3.3 风险评估</h3><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250725170843538.png" alt="架构风险评估矩阵"></p><p><strong>风险的影响面（Impact）</strong>：这个维度主要评估一旦风险发生，会对系统、业务、用户产生多大程度的负面影响。</p><ul><li><strong>低影响（Low）：</strong> 影响范围小，可控性强。例如，某个非核心模块的性能略有下降，只影响少量用户，且有明确的降级方案。或者，故障恢复时间短，对整体业务影响微乎其微。</li><li><strong>中影响（Medium）：</strong> 影响范围较大，但可控。例如，系统某个核心功能出现短暂不可用，影响部分用户，但可以通过人工干预或备用方案快速恢复。业务运营会受到一定影响，但不会造成灾难性的损失。</li><li><strong>高影响（High）：</strong> 影响范围广，失控性强。例如，系统核心服务大面积宕机，导致业务全面停止。或者，数据出现严重损坏，造成不可挽回的损失。</li></ul><p><strong>风险出现的可能性（Likelihood）</strong>：这个维度主要评估风险发生的概率。</p><ul><li><strong>低可能性（Low）：</strong> 发生概率很小。例如，系统依赖的某个成熟、稳定的第三方服务，过去几年从未出现过故障。或者，经过充分的测试和验证，某个技术方案的潜在问题已经被基本排除。</li><li><strong>中可能性（Medium）：</strong> 发生概率一般。例如，某个新技术或新组件，虽然经过了小规模测试，但在大规模生产环境下的表现还未得到充分验证。或者，架构依赖的某个外部系统，其 SLA（服务等级协议）历史记录显示偶尔会出现短暂的抖动。</li><li><strong>高可能性（High）：</strong> 发生概率很高。例如，在高峰期对数据库进行无主键大批量更新操作，必然会导致锁表和性能问题。或者，系统设计存在明显的单点故障，一旦该节点出现问题，整个系统就会瘫痪。</li></ul><p>在分析时，不要企图一次性对所有的架构特性进行分析，拆开了，逐一击破，避免一次性关注点太多，从而不知所向。</p><h3 id="3-4-架构决策">3.4 架构决策</h3><h4 id="3-4-1-Anti-Pattern1-Covering-Your-Assets">3.4.1 Anti-Pattern1: Covering Your Assets</h4><blockquote><p>害怕承担责任，总是希望有更高级别的人来拍板。决策过程变得极其缓慢，甚至为了规避风险而选择最保守、最平庸的技术方案，而不是最合适的方案。</p></blockquote><p>应对方案：</p><ul><li><strong>Fact（事实）:</strong> 聚焦于客观事实和数据。在做技术选型或架构决策时，不要只凭感觉或经验，而是要基于事实，如性能测试报告、技术预研结果、业界最佳实践、开源社区活跃度等。当所有人都基于事实说话时，决策的对错就更容易被评估和追溯，而非个人责任。</li><li><strong>Options（可选方案）:</strong> 明确列出所有可行的备选方案，并分析它们的优缺点、成本、风险和收益。当一个决策有多个清晰的选项时，团队可以共同讨论和权衡，而不是只盯着一个保守方案不放。</li></ul><p>实践建议：</p><ul><li><strong>建立决策评审机制：</strong> 明确谁是最终的决策者（DRI - Directly Responsible Individual），并设立评审环节。评审会上，每个人都应基于数据和事实来论证自己的观点。</li><li><strong>鼓励小步快跑和 PoC：</strong> 对于有争议的技术方案，可以先用小规模的 PoC（概念验证）项目来验证其可行性。用实际结果说话，而不是让大家停留在理论争辩。</li></ul><h4 id="3-4-2-Anti-Pattern2-Groundhog-Day">3.4.2 Anti-Pattern2: Groundhog Day</h4><blockquote><p>团队成员在每次会议上都重复同样的讨论，无法达成共识。由于没有明确的决策记录或决策依据，导致下一次讨论又回到原点。</p></blockquote><p>应对方案：</p><ul><li><strong>Subject（主题）:</strong> 在每次讨论前，都必须有一个明确的、聚焦的 <strong>Subject</strong>。这次会议要讨论什么？目标是什么？是决定数据库选型？还是讨论消息队列的方案？有了明确的主题，才能避免讨论跑偏。</li><li><strong>Decision（决策）:</strong> 讨论结束后，必须得出一个明确的 <strong>Decision</strong>。决策是什么？为什么做出这个决策？这个决策有哪些局限性？明确记录下来，并让所有人都知晓。</li></ul><p>实践建议：</p><ul><li><strong>会议纪要：</strong> 每次关键的架构讨论后，都必须有正式的会议纪要。纪要中要包含：<strong>讨论主题、所有备选方案、最终决策、决策依据以及未被采纳方案的理由</strong>。</li><li><strong>设立时间限制：</strong> 在讨论时，可以为每个议题设定一个时间限制。如果超过时间仍无法达成一致，可以先暂停，让大家会后去搜集更多数据，再进行下一轮讨论。</li></ul><h4 id="3-4-3-Anti-Pattern3-Email-Driven-Architecture">3.4.3 Anti-Pattern3: Email-Driven Architecture</h4><blockquote><p>重要的架构决策都散落在团队成员的邮件、聊天记录或者 Wiki 的各个角落，没有一个集中的、可检索的知识库。当新成员加入或需要回顾历史决策时，很难找到完整的信息。</p></blockquote><p>应对方案：</p><ul><li><strong>Subject（主题） 和 Decision（决策）:</strong> 这两个元素是解决这个问题的核心。架构决策不应该只是一个口头或邮件的结论，而是一个完整的 <strong>ADR（Architecture Decision Record）</strong>。ADR 本身就是一个以主题和决策为核心的文档。</li></ul><p>实践建议：</p><ul><li><strong>建立 ADR 制度：</strong> 强烈建议引入 ADR 机制。</li><li><strong>使用统一的知识管理平台：</strong> 将所有 ADR 存放在一个统一的、可检索的知识管理平台（如飞书文档, Wiki 或 Git）。这样，团队成员可以轻松地查阅历史决策，新成员也能快速理解系统的演进过程。</li></ul><h4 id="3-4-4-架构决策记录-ADR">3.4.4 架构决策记录 ADR</h4><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/fosa-adr.png" alt="架构决策记录 ADR" style="zoom:33%;" /><p><strong>TITLE（标题）</strong></p><ul><li><strong>解释：</strong> 标题应该简短、清晰地描述这个 ADR 的核心决策是什么。</li><li><strong>示例：</strong> “使用 RabbitMQ 替代 Kafka 作为消息队列” 或 “将数据库从 MySQL 切换到 PostgreSQL”。</li><li><strong>作用：</strong> 让读者一眼就能明白这份文档的主题。一个好的标题本身就包含了 <strong>Subject</strong>。</li></ul><p><strong>STATUS（状态）</strong></p><ul><li><strong>解释：</strong> ADR 的生命周期状态。通常包括以下几种：<ul><li><strong>Proposed（提案中）：</strong> 决策还在讨论阶段，尚未被团队接受。</li><li><strong>Accepted（已接受）：</strong> 决策已经通过，可以开始实施。</li><li><strong>Superseded（已废弃）：</strong> 这个决策已经被新的 ADR 替代。这对于追踪架构演变历史非常重要。这样要<u><strong>链接到新的 ADR</strong></u>，方便追溯！</li></ul></li><li><strong>作用：</strong> 帮助团队成员了解该决策的当前状态，避免对过时或仍在讨论中的方案产生误解。</li></ul><p><strong>CONTEXT（背景）</strong></p><ul><li><strong>解释：</strong> 为什么要做出这个决策？它试图解决什么问题？这里应该详细描述问题的来龙去脉、约束条件以及技术或业务驱动因素。</li><li><strong>示例：</strong> “我们现有的系统在处理高并发订单时，MySQL 数据库的写入性能出现了瓶颈，导致订单处理延迟。”</li><li><strong>作用：</strong> 提供决策的 <strong>Fact</strong>（事实），让读者理解决策背后的原因，而不是孤立地看待决策本身。</li></ul><p><strong>DECISION（决策）</strong></p><ul><li><strong>解释：</strong> 明确描述最终的决策是什么，并给出相应的理由。这个部分是整个 ADR 的核心。</li><li><strong>示例：</strong> “我们决定将订单处理服务从同步调用改为异步消息队列。备选方案是采用 Kafka，但我们最终选择了 RabbitMQ，原因是 RabbitMQ 具有更完善的路由机制和更稳定的交付保障，更适合我们对消息可靠性的高要求。”</li><li><strong>作用：</strong> 记录决策的 <strong>Decision</strong> 和 <strong>Options</strong>。它清晰地表明我们做了什么选择，以及为什么没有选择其他方案。</li></ul><p><strong>CONSEQUENCES（影响）</strong></p><ul><li><strong>解释：</strong> 这个决策会带来什么后果？包括积极的和消极的。</li><li><strong>示例：</strong><ul><li><strong>积极影响：</strong> “订单处理性能将得到显著提升，系统的可扩展性增强。”</li><li><strong>消极影响：</strong> “引入 RabbitMQ 会增加运维复杂性，团队需要学习新的技术栈。需要额外投入人力进行开发和部署。”</li></ul></li><li><strong>作用：</strong> 帮助团队全面评估决策的利弊，提前预见潜在的风险和挑战。这与我们之前讨论的风险评估中的「风险的影响面」有异曲同工之妙。</li></ul><p><strong>COMPLIANCE（遵循）</strong></p><ul><li><strong>解释：</strong> 如何确保团队会遵循这个决策？这个部分更多是关于实践和治理。</li><li><strong>示例：</strong> “新开发的订单服务必须通过 RabbitMQ 进行异步通信。代码评审时，需要检查是否遵守此规范。运维团队需要负责 RabbitMQ 集群的部署和监控。”</li><li><strong>作用：</strong> 将抽象的决策转化为具体的行动和规范，确保决策能够真正落地。</li></ul><p><strong>NOTES（备注）</strong></p><ul><li><strong>解释：</strong> 用于记录一些额外的元数据，例如：文档的作者、创建日期、链接到相关的 Jira 工单或会议记录等。</li><li><strong>作用：</strong> 便于管理和追溯文档。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"><span class="strong">**ADR #001 - 使用 RabbitMQ 替代 Kafka 作为消息队列**</span></span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"><span class="strong">**TITLE（标题）**</span></span><br><span class="line"></span><br><span class="line">将消息队列从 Kafka 切换至 RabbitMQ</span><br><span class="line"></span><br><span class="line"><span class="strong">**STATUS（状态）**</span></span><br><span class="line"></span><br><span class="line">Accepted（已接受）</span><br><span class="line"></span><br><span class="line"><span class="strong">**CONTEXT（背景）**</span></span><br><span class="line"></span><br><span class="line">我们现有的订单服务在业务高峰期时，订单创建和扣减库存的同步处理流程出现了严重的性能瓶颈。MySQL 数据库的写入操作成为单点瓶颈，导致订单处理延迟增加，甚至出现超时。为了解决这一问题，我们决定引入消息队列，将订单创建的后续流程（如库存扣减、积分发放）改为异步处理。</span><br><span class="line"></span><br><span class="line">在技术选型阶段，团队提出了两个主要的备选方案：Kafka 和 RabbitMQ。我们希望找到一个能满足以下需求的消息队列：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span>  <span class="strong">**高可靠性：**</span> 消息不能丢失，即使在消费者故障或重启时。</span><br><span class="line"><span class="bullet">2.</span>  <span class="strong">**消息时效性：**</span> 消息需要被及时处理，不接受长时间的延迟。</span><br><span class="line"><span class="bullet">3.</span>  <span class="strong">**灵活的路由：**</span> 能够根据不同的业务场景，将消息发送到不同的消费者。</span><br><span class="line"><span class="bullet">4.</span>  <span class="strong">**易于运维：**</span> 团队需要能快速上手，运维成本不能过高。</span><br><span class="line"></span><br><span class="line"><span class="strong">**DECISION（决策）**</span></span><br><span class="line"></span><br><span class="line">我们决定采用 <span class="strong">**RabbitMQ**</span> 作为新的消息队列，用于实现订单处理流程的异步化。</span><br><span class="line"></span><br><span class="line"><span class="strong">**核心理由：**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> <span class="strong">**消息路由的灵活性：**</span> RabbitMQ 提供了多种 exchange 类型（如 direct, fanout, topic），可以实现非常灵活的消息路由。这使得我们可以轻松地根据不同的订单类型或业务事件（例如，秒杀订单、普通订单）将消息发送到不同的消费者队列，满足未来的业务扩展需求。</span><br><span class="line"><span class="bullet">*</span> <span class="strong">**消息的可靠性：**</span> RabbitMQ 提供了成熟的持久化机制（Durable Queues）和消息确认机制（Publisher Confirms），能确保即使在 RabbitMQ 本身或消费者故障时，消息也不会丢失。这对订单处理这种核心业务至关重要。</span><br><span class="line"><span class="bullet">*</span> <span class="strong">**团队学习曲线：**</span> 团队成员在内部技术分享中对 RabbitMQ 的概念（exchange, queue, binding）有了一定的了解，学习成本相对可控。</span><br><span class="line"></span><br><span class="line"><span class="strong">**备选方案的局限性：**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> <span class="strong">**Kafka：**</span> Kafka 的核心设计思想是基于日志和分区，其路由能力相对较弱，主要通过 topic 和分区来实现消息分发。虽然可以通过消费者组来实现负载均衡，但在某些复杂路由场景下，需要额外的开发工作来适配。同时，Kafka 在保证单条消息的精确可靠投递方面，实现起来比 RabbitMQ 复杂一些，而这正是我们当前业务最关注的点。</span><br><span class="line"></span><br><span class="line"><span class="strong">**CONSEQUENCES（影响）**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> <span class="strong">**积极影响：**</span></span><br><span class="line"><span class="bullet">    *</span> 显著提升订单处理的并发能力和吞吐量，缓解数据库写入瓶颈。</span><br><span class="line"><span class="bullet">    *</span> 提升系统的可扩展性，未来可以方便地增加更多异步消费者服务。</span><br><span class="line"><span class="bullet">    *</span> 系统的响应时间将大大缩短，提升用户体验。</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> <span class="strong">**消极影响：**</span></span><br><span class="line"><span class="bullet">    *</span> 引入 RabbitMQ 会增加系统的运维复杂性，需要额外的监控和维护工作。</span><br><span class="line"><span class="bullet">    *</span> 团队需要投入时间学习和掌握 RabbitMQ 的相关知识，尤其是如何处理消费者故障、消息死信等问题。</span><br><span class="line"><span class="bullet">    *</span> 系统架构复杂度增加，需要重新设计和实现订单服务与消息队列的集成部分。</span><br><span class="line"></span><br><span class="line"><span class="strong">**COMPLIANCE（遵循）**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 所有与订单相关的异步化处理流程，必须通过 RabbitMQ 进行通信。</span><br><span class="line"><span class="bullet">*</span> 新的服务代码必须严格遵循消息持久化和确认机制，以确保消息不丢失。</span><br><span class="line"><span class="bullet">*</span> 运维团队负责 RabbitMQ 集群的部署、监控和维护，并确保其高可用性。</span><br><span class="line"><span class="bullet">*</span> 在代码评审时，需要确保新引入的异步化服务遵循此 ADR 的设计规范。</span><br><span class="line"></span><br><span class="line"><span class="strong">**NOTES（备注）**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> <span class="strong">**作者：**</span> Gemini AI</span><br><span class="line"><span class="bullet">*</span> <span class="strong">**创建日期：**</span> 2025-07-26</span><br><span class="line"><span class="bullet">*</span> <span class="strong">**关联工单：**</span> PROJECT-1234 - 订单服务高并发性能优化</span><br><span class="line"><span class="bullet">*</span> <span class="strong">**相关会议记录：**</span> 架构评审会议 [2025-07-25]</span><br></pre></td></tr></table></figure><h2 id="4-设计实施路径与验证机制">4. 设计实施路径与验证机制</h2><blockquote><p>实施计划：是否需要技术原型 (PoC) 来验证关键难点？如何进行任务拆解和里程碑规划？</p><p>构建适用度函数：针对第二步定义的关键架构特性，设计具体的检验尺。</p><p>知识沉淀：准备好核心的架构图、设计文档等。</p></blockquote><h3 id="4-1-实施计划">4.1 实施计划</h3><p><strong>技术原型 (PoC) 来验证关键难点</strong>：架构师应频繁进行概念验证 (PoC)，以验证架构决策的可行性，并深入了解实施细节。PoC有助于比较不同解决方案，并评估性能、可伸缩性等架构特性。建议架构师在进行PoC时编写生产质量的代码，这是架构师可以用于保持编码手感的有效手段，同时一次性的 PoC 代码往往会成为团队的参考架构。</p><p><strong>任务拆解和里程碑规划</strong>：组件识别和架构设计是一个迭代过程，通过反馈不断优化。<strong>敏捷方法论</strong>支持迭代开发和快速反馈，有助于架构师在实践中调整决策。架构师还需要平衡架构工作和实际编码，通过<strong>委派核心路径代码</strong>，避免成为团队瓶颈。</p><h3 id="4-2-适应度函数">4.2 适应度函数</h3><p><strong>适应度函数是架构治理的核心工具</strong>。它是一种<strong>客观的函数</strong>，用于衡量代码复杂度和架构特性，并<strong>自动化验证</strong>开发团队是否遵循了架构决策和设计原则。适应度函数应<strong>集成到 CI/CD 流程中</strong>，在代码集成时自动检查合规性，从而避免问题积累。</p><ul><li><strong>检测循环依赖</strong>：可编写适应度函数来检测并防止组件之间的循环依赖，因为这会损害模块化（例如，使用 <strong>JDepend</strong> 工具）。这有助于维护架构中“重要但不紧急”的实践。</li><li><strong>分层架构合规性</strong>：利用<strong>ArchUnit</strong>（Java）或<strong>NetArchTest</strong>（.NET）等工具，可以确保分层架构中各层之间的访问限制被遵守。例如，限制表现层不能直接访问数据库，而必须通过业务层和持久层。</li><li><strong>验证距主序列距离</strong>：通过适应度函数验证代码抽象性与不稳定性之间的平衡。</li><li><strong>自动化编码标准合规性</strong>：例如，检查特定类是否包含必需的注解。</li></ul><h3 id="4-3-知识沉淀">4.3 知识沉淀</h3><ul><li><strong>ADR</strong>：将每一次关键决策及其动机、权衡、后果记录下来，形成可检索的决策日志。</li><li><strong><a href="https://c4model.com/">C4 架构图</a></strong>：在每个里程碑输出更新后的系统上下文、容器、组件图，配合 ADR 链接。</li></ul><h3 id="4-4-管理松紧度">4.4 管理松紧度</h3><p>架构师需要根据团队实际情况采用恰到好处的管理松紧度，才能发挥团队的最大潜力。</p><p>采取哪种管理松紧度，可以从几个方面进行考量：</p><ul><li><strong>team familiarity</strong>：团队内部的熟悉程度，越不熟悉，越需要更多投入。</li><li><strong>team size</strong>：团队大小，团队越大， 越需要投入。</li><li><strong>overall experience</strong>：团队经验，新人越多，越需要投入。</li><li><strong>project complexity</strong>：项目越复杂，越需要投入。</li><li><strong>project duration</strong>：项目周期，周期越长，越需要投入。</li></ul><p>按照这 5 个方面，极限 tight 是 20 分，极限 loose 是 -20 分，进行综合评价，看看自己是应该扮演什么角色。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250727144525753.png" alt="管理松紧度计算表盘"></p><h2 id="5-部署、观测与效果衡量">5. 部署、观测与效果衡量</h2><blockquote><p>持续交付：作为将设计快速、可靠地部署到生产环境的手段。</p><p>系统监控：观测系统的健康状况（CPU、内存、延迟、错误率等）。</p><p>业务指标验证：验证是否达成了第一步定义的商业目标？例如，新架构上线后，用户转化率是否真的提升了？</p></blockquote><h3 id="5-1-持续交付与部署自动化">5.1 持续交付与部署自动化</h3><p>持续交付 (CI/CD) 是架构落地的关键环节。FOSA 强调，现代软件架构的成功离不开 DevOps 革命和对操作关注点的自动化。持续交付不仅仅是技术实践，更是组织文化的体现。</p><p>核心要素：</p><ul><li><p>自动化构建与测试：每次代码提交都触发自动化的构建、单元测试、集成测试流程，确保代码质量。</p></li><li><p>环境一致性：通过容器化技术（如 Docker）和基础设施即代码（IaC）确保开发、测试、生产环境的一致性。</p></li><li><p>渐进式部署：采用蓝绿部署、金丝雀发布等策略，降低部署风险，实现零停机时间。</p></li><li><p>快速回滚机制：当新版本出现问题时，能够快速回滚到上一个稳定版本。</p></li></ul><p>架构师职责：</p><ul><li><p>设计适合团队规模的 CI/CD 流水线</p></li><li><p>确保架构决策能够通过自动化流程得到验证</p></li><li><p>平衡部署频率与系统稳定性</p></li></ul><h3 id="5-2-系统监控与可观测性">5.2 系统监控与可观测性</h3><p>可观测性 (Observability) 是现代分布式系统的生命线。FOSA 指出，在分布式架构中，一个请求可能会流经数十个甚至上百个服务，要诊断一个问题，需要建立复杂的可观测性体系。</p><p>三大支柱：</p><ol><li><p>指标 (Metrics)：量化系统性能的关键指标</p><ul><li><p>RED 方法：Rate（请求率）、Error（错误率）、Duration（延迟）</p></li><li><p>USE 方法：Utilization（利用率）、Saturation（饱和度）、Errors（错误）</p></li><li><p>业务指标：用户转化率、订单成功率、收入增长率</p></li></ul></li><li><p>日志 (Logs)：记录系统运行时的详细信息</p><ul><li><p>结构化日志：使用 JSON 格式，便于机器解析</p></li><li><p>日志聚合：集中收集、存储和分析日志</p></li><li><p>日志级别：根据重要性设置不同的日志级别</p></li></ul></li><li><p>追踪 (Tracing)：追踪请求在分布式系统中的完整路径</p><ul><li><p>分布式追踪：为每个请求分配唯一 ID，追踪其在整个调用链中的路径</p></li><li><p>链路追踪：记录服务间的调用关系和耗时</p></li><li><p>性能分析：识别系统瓶颈和性能热点</p></li></ul></li></ol><p>监控策略：</p><ul><li><p>分层监控：从基础设施层到应用层，建立完整的监控体系</p></li><li><p>告警策略：设置合理的告警阈值，避免告警疲劳</p></li><li><p>可视化仪表板：为不同角色提供定制化的监控视图</p></li></ul><h3 id="5-3-业务指标验证与闭环反馈">5.3 业务指标验证与闭环反馈</h3><p>业务指标验证是架构设计的闭环关键。FOSA 强调，技术架构的最终目标是服务于业务价值，因此必须验证是否达成了第一步定义的商业目标。</p><p>验证流程：</p><ol><li>建立基线：在架构变更前，记录关键业务指标的当前状态</li><li>设定目标：基于第一步的商业目标，设定具体的量化指标</li><li>持续监控：在架构部署后，持续跟踪业务指标的变化</li><li>效果评估：定期评估架构变更对业务指标的实际影响</li></ol><p>常见业务指标：</p><ul><li><p>用户相关：日活跃用户数、用户留存率、用户满意度</p></li><li><p>业务相关：订单转化率、客单价、复购率</p></li><li><p>技术相关：系统可用性、响应时间、错误率</p></li></ul><p>A/B 测试策略：</p><ul><li><p>在架构变更时，可以考虑 A/B 测试来验证效果</p></li><li><p>对比新旧架构在相同条件下的业务表现</p></li><li><p>基于数据做出是否全面推广的决策</p></li></ul><h3 id="5-4-性能监控与容量规划">5.4 性能监控与容量规划</h3><p>性能监控是架构健康度的重要指标。FOSA 指出，架构师需要持续监控系统的性能表现，并基于趋势进行容量规划。</p><p>关键性能指标：</p><ul><li><p>响应时间：P50、P95、P99 延迟</p></li><li><p>吞吐量：每秒处理的请求数</p></li><li><p>资源利用率：CPU、内存、磁盘、网络使用率</p></li><li><p>错误率：4xx、5xx 错误的比例</p></li></ul><p>容量规划方法：</p><ul><li><p>趋势分析：基于历史数据预测未来需求</p></li><li><p>压力测试：通过模拟高负载验证系统极限</p></li><li><p>弹性规划：设计自动扩缩容机制应对流量波动</p></li></ul><h2 id="6-复盘、沉淀与演进">6. 复盘、沉淀与演进</h2><blockquote><p>问题记录与根因分析：发生了什么？为什么会发生？</p><p>流程与原则改进：如何优化我们的设计流程、技术原则，避免未来再犯？</p><p>人员与组织成长：团队通过这次项目学到了什么？需要组织哪些培训？</p></blockquote><h3 id="6-1-问题记录与根因分析">6.1 问题记录与根因分析</h3><p>根因分析 (Root Cause Analysis, RCA) 是架构演进的基础。FOSA 强调，架构师需要建立系统性的问题记录和分析机制，避免同样的问题重复发生。</p><p>分析框架：</p><ol><li><p>5W1H 分析法</p><ul><li><p>What：发生了什么问题？</p></li><li><p>When：什么时候发生的？</p></li><li><p>Where：在哪个组件/服务中发生的？</p></li><li><p>Who：谁发现了这个问题？</p></li><li><p>Why：为什么会发生？</p></li><li><p>How：如何避免再次发生？</p></li></ul></li><li><p>鱼骨图分析</p><ul><li><p>人员因素：技能不足、沟通不畅</p></li><li><p>流程因素：流程缺陷、决策不当</p></li><li><p>技术因素：架构设计问题、技术选型错误</p></li><li><p>环境因素：基础设施问题、外部依赖故障</p></li></ul></li><li><p>时间线分析</p><ul><li><p>按时间顺序记录事件发展过程</p></li><li><p>识别关键决策点和转折点</p></li><li><p>分析因果关系链</p></li></ul></li></ol><p>问题分类：</p><ul><li><p>架构设计问题：组件划分不当、接口设计不合理</p></li><li><p>技术选型问题：技术栈不匹配、性能瓶颈</p></li><li><p>流程管理问题：决策流程不清晰、沟通机制缺失</p></li><li><p>人员技能问题：团队技能不足、知识传递不畅</p></li></ul><h3 id="6-2-流程与原则改进">6.2 流程与原则改进</h3><p>持续改进是架构师的核心职责。FOSA 指出，架构师需要基于实践经验，不断优化设计流程和技术原则。</p><p>流程改进方法：</p><ol><li><p>回顾会议 (Retrospective)</p><ul><li><p>定期组织团队回顾会议</p></li><li><p>识别流程中的痛点和改进机会</p></li><li><p>制定具体的改进行动计划</p></li></ul></li><li><p>架构评审机制</p><ul><li><p>建立正式的架构评审流程</p></li><li><p>邀请相关方参与评审</p></li><li><p>记录评审决策和后续行动</p></li></ul></li><li><p>决策记录 (ADR) 更新</p><ul><li><p>定期回顾和更新 ADR</p></li><li><p>记录决策的后续影响和教训</p></li><li><p>为未来类似决策提供参考</p></li></ul></li></ol><p>原则演进：</p><ul><li><p>技术原则：基于实践经验更新技术选型原则</p></li><li><p>设计原则：优化组件划分和接口设计原则</p></li><li><p>流程原则：改进决策流程和沟通机制</p></li><li><p>质量原则：更新代码质量和测试策略</p></li></ul><h3 id="6-3-持续学习与团队领导">6.3 持续学习与团队领导</h3><p>组织学习是架构成功的关键。FOSA 强调，架构师不仅要关注技术架构，更要关注团队和组织的成长。优秀的架构师通过培养团队能力和建立学习型组织，实现技术债务的持续偿还和架构能力的持续提升。</p><h4 id="6-3-1-20-分钟法则">6.3.1 20 分钟法则</h4><p>架构师需要持续学习以保持技术广度。FOSA 指出，技术发展日新月异，架构师必须建立系统化的学习机制，避免技术视野的固化。</p><p><strong>20分钟法则</strong>：建议每天至少投入20分钟学习新知识或深入特定主题，以系统化地拓展技术广度。这种持续的小剂量学习比偶尔的集中学习更有效，能够保持技术敏锐度。</p><p>学习策略：</p><ul><li><p>技术深度与广度平衡：在保持一个技术领域的深度基础上，系统性地拓展技术广度</p></li><li><p>问题驱动学习：将实际工作中遇到的问题作为学习的起点</p></li><li><p>理论与实践结合：通过概念验证（PoC）验证新技术的适用性</p></li><li><p>跨领域学习：不仅学习技术，还要了解业务、管理、心理学等相关领域</p></li></ul><h4 id="6-3-2-个人技术雷达">6.3.2 个人技术雷达</h4><p>建立&quot;个人雷达&quot;可以帮助架构师系统化地评估和追踪新兴技术和实践，类似于 ThoughtWorks 的技术雷达。</p><p>雷达分类：</p><ul><li><p>采用 (Adopt)：经过验证的技术，可以安全地在生产环境中使用</p></li><li><p>试用 (Trial)：有前景的技术，可以在非关键项目中尝试</p></li><li><p>评估 (Assess)：值得关注的技术，需要进一步研究和评估</p></li><li><p>保持 (Hold)：暂时不推荐使用的技术，但保持关注</p></li></ul><p>雷达维护：</p><ul><li><p>定期更新：每季度更新一次技术雷达</p></li><li><p>团队共享：与团队分享技术雷达，促进集体学习</p></li><li><p>决策参考：将技术雷达作为技术选型的重要参考</p></li></ul><h4 id="6-3-3-知识分享">6.3.3 知识分享</h4><p>架构师应通过以身作则而非仅仅凭借头衔来领导团队。他们可以通过主持&quot;午餐分享会&quot; (brown-bag lunches) 来分享技术知识和经验，从而提升在团队中的领导力和影响力。</p><h4 id="6-3-4-团队健康监控与预警">6.3.4 团队健康监控与预警</h4><p>当出现以下 3 个问题时，意味着团队已经开始进入不健康状态了，作为架构师，需要及时发现和解决团队协作中的问题。</p><p><strong>Process Loss（过程损失）</strong>：随着人数的增加，团队效率却在降低。</p><ul><li><p>表现：团队规模扩大后，沟通成本激增，决策效率下降</p></li><li><p>原因：信息传递链条过长，协调成本超过协作收益</p></li><li><p>解决方案：</p><ul><li><p>建立清晰的信息传递机制</p></li><li><p>采用敏捷方法，保持小团队结构</p></li><li><p>定期评估团队规模与效率的关系</p></li></ul></li></ul><p><strong>Pluralistic Ignorance（多元无知）</strong>：当团队成员因为觉得自己没掌握某些信息的时候，对提出的方案不好提出拒绝，而只能在表面进行同意。</p><ul><li><p>表现：会议上大家都点头同意，但会后执行时遇到各种问题</p></li><li><p>原因：团队成员缺乏安全感，不敢提出质疑</p></li><li><p>解决方案：</p><ul><li><p>营造安全的讨论环境，鼓励质疑和提问</p></li><li><p>建立&quot;魔鬼代言人&quot;机制，专门负责提出反对意见</p></li><li><p>定期进行匿名反馈收集</p></li></ul></li></ul><p><strong>Diffusion of Responsibility（责任扩散）</strong>：职责混乱，大家不知道谁应该为哪些东西负责任。</p><ul><li><p>表现：任务推诿，问题无人负责，决策无人执行</p></li><li><p>原因：角色定义不清晰，责任边界模糊</p></li><li><p>解决方案：</p><ul><li><p>建立明确的 RACI 矩阵（Responsible, Accountable, Consulted, Informed）</p></li><li><p>定期回顾和更新团队职责分工</p></li><li><p>建立问责机制，确保每个决策都有明确的责任人</p></li></ul></li></ul><h2 id="总结">总结</h2><p>架构设计一个系统性的六步工程过程，从商业理解到组织成长形成闭环。它强调&quot;为什么&quot;比&quot;怎么做&quot;更重要，要求架构师在理解利益相关方诉求和用户痛点的基础上，将模糊需求转化为可度量的技术目标，通过多方案权衡分析选择&quot;最不差&quot;而非&quot;最佳&quot;的架构方案，并建立持续交付、监控验证和复盘演进的机制，最终实现技术债务的持续偿还和团队能力的持续提升。整个方法论的核心是权衡取舍的艺术，以及架构师在技术决策中始终提供技术和业务双重理由的能力。</p>]]></content>
    
    
    <summary type="html">基于《Fundamentals of Software Architecture》内容，梳理出六步架构设计方法论，从商业理解到组织成长形成闭环，探讨架构师如何在权衡取舍中做出&quot;最不差&quot;的决策，以及如何通过持续交付、监控验证和复盘演进构建可持续的架构能力。</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨17丨微服务架构</title>
    <link href="https://hedon.top/2025/07/23/fosa/fosa-ch17/"/>
    <id>https://hedon.top/2025/07/23/fosa/fosa-ch17/</id>
    <published>2025-07-23T03:02:00.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十七章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>Why is the bounded context concept so critical for microservices architecture?</p><p>为什么限界上下文的概念对于微服务来说如此重要？</p></li><li><p>What are three ways of determining if you have the right level of granularity in a microservice?</p><p>在划分微服务粒度的时候，哪三个方面是你需要重点考虑的？</p></li><li><p>What functionality might be contained within a sidecar?</p><p>sidecar 有哪些功能？</p></li><li><p>What is the difference between orchestration and choreography? Which does microservices support? Is one communication style easier in microservices?</p><p>编舞（orchestration）和编排（choreography）的区别是什么？微服务支持哪种模式？在微服务中，哪种通信方式更简便？</p></li><li><p>What is a saga in microservices?</p><p>在微服务中，saga 是什么?</p></li><li><p>Why are agility, testability, and deployability so well supported in microservices?</p><p>为什么敏捷性、可测试性和可部署性在微服务架构中表现良好？</p></li><li><p>What are two reasons performance is usually an issue in microservices?</p><p>在微服务中，性能问题的两个核心因素是什么？</p></li><li><p>Is microservices a domain-partitioned architecture or a technically partitioned one?</p><p>微服务架构是领域分区还是技术分区？</p></li><li><p>Describe a topology where a microservices ecosystem might be only a single quantum.</p><p>描述一种拓扑结构，其中微服务生态系统可能仅有一个架构量子。</p></li><li><p>How was domain reuse addressed in microservices? How was operational reuse addressed?</p><p>微服务中是如何解决领域复用问题的？又是如何解决运维复用问题的呢？</p></li></ol><hr><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250723111539943.png" alt="FOSA Figure 17-1. The topologu of the microservices architecture style"></p><h2 id="业务边界">业务边界</h2><blockquote><ol><li><p>Why is the bounded context concept so critical for microservices architecture?</p><p>为什么限界上下文的概念对于微服务来说如此重要？</p></li><li><p>Is microservices a domain-partitioned architecture or a technically partitioned one?</p><p>微服务架构是领域分区还是技术分区？</p></li></ol></blockquote><p>限界上下文（Bounded Context）是微服务设计理念的核心驱动力。微服务架构与领域驱动设计（DDD）紧密相关，尤其是受限界上下文概念的深刻影响。限界上下文代表了一种<strong>解耦</strong>风格。在限界上下文内，与特定领域相关的所有内部组件（如代码和数据库模式）都是紧密耦合的，但它们与外部限界上下文的任何内容（如其他数据库或类定义）是<strong>解耦</strong>的。</p><p>微服务架构的首要目标是<strong>高度解耦</strong>。它通过物理地建模限界上下文的逻辑概念来实现这一目标。这意味着，微服务架构鼓励将系统分解为<strong>独立的、自包含的服务</strong>，每个服务都对应一个特定的限界上下文。</p><p>这种隔离使得每个服务可以<strong>独立演进</strong>，定义其自身所需的一切，而不必适应其他部分的约束。它<strong>避免了传统单体架构中常见的共享类和数据库作为集成点导致的紧密耦合问题</strong>。</p><p>所以微服务也是一个典型的领域分区架构，并且它倾向于将领域分区推到极致。</p><h2 id="服务粒度">服务粒度</h2><blockquote><ol start="2"><li><p>What are three ways of determining if you have the right level of granularity in a microservice?</p><p>在划分微服务粒度的时候，哪三个方面是你需要重点考虑的？</p></li></ol></blockquote><p>在划分微服务粒度时，以下三个方面是需要重点考虑的：</p><ol><li><strong>目的（Purpose）</strong>：微服务的首要目的应该是<strong>捕获一个领域或工作流</strong>。理想情况下，每个微服务都应该具有<strong>极高的功能内聚性</strong>，为整个应用程序贡献一个<strong>重要的行为</strong>。这意味着，服务应该专注于一个单一的、明确的业务功能。</li><li><strong>事务（Transactions）</strong>：限界上下文是业务工作流，通常需要<strong>在事务中协作的实体</strong>可以为服务边界提供良好的指示。由于分布式事务在分布式架构中会带来复杂性，架构师应尽量设计系统以<strong>避免跨服务的事务</strong>。如果需要跨服务事务，这可能表明服务粒度过细。事务边界通常是服务粒度的常见指标。</li><li><strong>通信（Communication）</strong>：如果一组服务为了完成功能而需要<strong>大量通信</strong>，那么将这些服务捆绑成一个更大的服务可能有助于<strong>避免过度的通信开销</strong>。换句话说，如果服务变得过于“多话”（chatty），频繁地相互调用，那么它们的边界可能需要重新评估，以减少不必要的<strong>全局复杂性</strong>。</li></ol><p>书中还强调，<strong>迭代</strong>是确保良好服务设计的唯一途径，架构师很少能在第一次尝试时就发现完美的粒度、数据依赖和通信风格，只有不断适配业务发展、不断思考改善，才能设计出良好的架构。</p><p>此外，业界也有一些其他的常用的判断方法：</p><ol><li><strong>变更与部署频率一致性</strong>：把一起变更/部署的东西放在一个服务，频率不同的拆开。</li><li><strong>耦合/通信“积分器 vs. 解耦器”指标</strong>：如果拆分后跨服务调用暴增（“chattiness”），说明拆太细；反之，如果内部复杂度过高且团队协作困难，可能太粗。</li><li><strong>团队/认知负荷</strong>：一个团队能完全理解并独立维护的范围通常就是一个合理服务边界。</li></ol><h2 id="基础设施">基础设施</h2><blockquote><ol start="3"><li><p>What functionality might be contained within a sidecar?</p><p>sidecar 有哪些功能？</p></li><li><p>How was domain reuse addressed in microservices? How was operational reuse addressed?</p><p>微服务中是如何解决领域复用问题的？又是如何解决运维复用问题的呢？</p></li></ol></blockquote><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250723111700037.png" alt="FOSA Figure 17-3. The service plane connects the sidecars in a service mesh"></p><p>Sidecar 模式用于处理微服务中的<strong>通用运维关注点（operational concerns）</strong>，包括但不限于：<strong>监控（Monitoring）</strong>、<strong>日志记录（Logging）</strong>、<strong>断路器（Circuit Breakers）<strong>和</strong>服务发现（Service Discovery）</strong>。这些功能由一个独立的组件处理，该组件可以由单个团队拥有，也可以由共享的基础设施团队拥有，从而实现了运维方面的复用。</p><p>而在领域复用中，由于微服务架构的主要目标是<strong>高度解耦</strong>。为了实现这一目标，微服务<strong>倾向于复制（duplication）而不是传统意义上的复用（reuse）</strong>。这意味着，对于通用实体（如 <code>Address</code> 类），微服务会<strong>避免共享公共类或数据库模式</strong>。相反，每个服务会在其自己的限界上下文内定义和管理其所需的数据和行为，即使这意味着某些概念的重复实现。这种策略牺牲了代码级别的复用，以换取服务之间更高的解耦度和独立演进的能力。</p><h2 id="服务协作">服务协作</h2><blockquote><ol start="4"><li><p>What is the difference between orchestration and choreography? Which does microservices support? Is one communication style easier in microservices?</p><p>编舞（orchestration）和编排（choreography）的区别是什么？微服务支持哪种模式？在微服务中，哪种通信方式更简便？</p></li></ol></blockquote><ul><li><p><strong>编舞（Choreography）</strong>：是指多个服务<strong>相互之间直接通信</strong>，而<strong>没有中央协调器</strong>。服务（如同舞者）根据彼此发出的事件或信息自主响应和行动。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250723112521618.png" alt="FOSA Figure 17-7. Using choreography in microservices to manage coordination"></p></li><li><p><strong>编排（Orchestration）</strong>：是指通过一个<strong>单独的协调器服务</strong>来管理和控制工作流中多个服务的协调。协调器（如同乐队指挥）负责指导每个服务的执行顺序，并处理整个业务流程的状态和错误。在微服务中，架构师可以创建<strong>局部化的协调器服务</strong>来处理复杂的业务流程。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250723112551443.png" alt="FOSA Figure 17-8. Using orchestration in microservices"></p></li></ul><p>微服务两者都支持。 不过编舞方式更符合微服务的高度解耦哲学，因为它不依赖于中央协调器，而是通过解耦的事件来实现通信，使用起来更简便。当然，在复杂的业务流程中，<strong>编舞环境下的错误处理和协调会变得更加复杂</strong>。如果业务流程<strong>本质上是耦合的</strong>，此时编排可能更为适合。</p><h2 id="一致性">一致性</h2><blockquote><ol start="5"><li><p>What is a saga in microservices?</p><p>在微服务中，saga 是什么?</p></li></ol></blockquote><p>在微服务中，<strong>Saga</strong> 是一种<strong>分布式事务模式</strong>，用于管理跨多个服务的业务事务，因为在微服务中，跨服务边界的传统 ACID 事务是不推荐的（甚至不可能的）。</p><p>Saga 模式通过将一个业务流程分解为一系列<strong>本地事务</strong>来实现，每个本地事务由一个服务执行。</p><ul><li>如果某个本地事务失败，Saga 会通过执行**补偿事务（compensating transactions）**来撤销之前已成功的本地事务所做的更改，从而确保数据的一致性。</li><li>Saga 可以通过**事件溯源（event sourcing）<strong>或</strong>有限状态机（finite state machines）**来管理事务的状态。</li></ul><p>虽然 Saga 可以用于解决分布式事务问题，但也应<strong>谨慎使用 Saga 模式</strong>，因为它会增加系统的复杂性，并且如果它成为架构中的主导特性，则可能表明服务粒度划分不当，违反了微服务解耦的核心原则。</p><h2 id="优点">优点</h2><blockquote><ol start="6"><li><p>Why are agility, testability, and deployability so well supported in microservices?</p><p>为什么敏捷性、可测试性和可部署性在微服务架构中表现良好？</p></li></ol></blockquote><p>敏捷性（Agility）、可测试性（Testability）和可部署性（Deployability）在微服务架构中得到良好支持的原因主要有以下几点：</p><ul><li><strong>高度解耦与小部署单元</strong>：微服务架构极力推崇<strong>高度解耦</strong>。每个服务都是<strong>极小的部署单元</strong>，且具备<strong>高度的独立性</strong>。这种解耦使得团队可以独立地开发、测试和部署服务，大大减少了对其他服务的依赖，从而提高了敏捷性。</li><li><strong>DevOps 革命与自动化</strong>：微服务架构的成功离不开 <strong>DevOps 革命和对操作关注点的自动化</strong>。自动化部署、自动化测试等现代工程实践是微服务存在的基础，它们极大地提高了部署频率、降低了部署风险，并保证了测试的完整性。</li><li><strong>更快的变更响应速度</strong>：由于服务范围小且高度解耦，当业务需求发生变化时，团队只需修改受影响的少量服务，而不是整个大型单体。这种<strong>增量式的演进</strong>能力使得组织能够<strong>更快地响应市场变化，提高时间到市场（time-to-market）的速度</strong>。</li><li><strong>单一职责与清晰边界</strong>：每个微服务都专注于一个<strong>单一的业务功能或领域</strong>。这种清晰的职责边界使得开发人员更容易理解、测试和维护代码，因为他们不必处理与服务无关的复杂性</li></ul><h2 id="缺点">缺点</h2><blockquote><ol start="7"><li><p>What are two reasons performance is usually an issue in microservices?</p><p>在微服务中，性能问题的两个核心因素是什么？</p></li></ol></blockquote><p>在微服务中，性能问题通常由以下两个核心因素导致：</p><ol><li><strong>网络调用开销（Network Call Overhead）</strong>：微服务是分布式架构。这意味着服务之间（乃至用户界面与服务之间）的通信需要通过网络进行。网络调用比本地方法调用耗时更长。当一个业务请求需要链式调用多个微服务时，累积的网络延迟会显著影响整体响应时间。</li><li><strong>安全验证开销（Security Verification Overhead）</strong>：在微服务架构中，由于每个服务都是独立的部署单元，因此每个服务端点都需要进行安全验证。这增加了额外的处理时间。这种“在每个入口处进行安全检查”的模式进一步降低了同步、高度分布式架构（如微服务）的性能。</li></ol><p>尽管性能是微服务常见的问题，但可以通过**数据缓存（caching）和数据复制（replication）**等模式来减少不必要的网络调用，从而提高性能。</p><h2 id="架构量子">架构量子</h2><blockquote><ol start="9"><li><p>Describe a topology where a microservices ecosystem might be only a single quantum.</p><p>描述一种拓扑结构，其中微服务生态系统可能仅有一个架构量子。</p></li></ol></blockquote><p>通常来讲，微服务架构都意味着存在多个架构量子。但如果其部署或通信模型导致了上述的紧密耦合，例如<strong>共享数据库</strong>或<strong>中央同步协调器</strong>，那么整个微服务生态系统仍可能被归类为一个单一量子。</p><p><strong>1. 共享单一数据库</strong>：</p><ul><li>如果<strong>所有微服务都共享一个单一的、中央化的数据库实例</strong>，那么整个系统很可能构成一个单一量子。在这种情况下，尽管服务是独立的部署单元，但数据库模式的任何更改都可能影响所有服务，导致它们<strong>无法独立演进和部署</strong>。这使得系统在部署和数据一致性方面表现得像一个整体。</li><li>例如，传统的**分层单体（layered monolith）**即使有多个逻辑层，但由于共享一个数据库，它也是一个单一量子。</li></ul><p><strong>2. 强制同步通信与中央协调器</strong>：</p><ul><li>在某些情况下，即使服务是分离的，如果它们之间存在<strong>大量强制的同步通信依赖（synchronous connascence）</strong>，或者存在一个**中央编排引擎（orchestration engine）**作为所有行为的巨大耦合点，那么整个系统也可能被视为一个单一量子。在这种拓扑中，如果一个服务调用另一个服务是同步的，那么这些服务的操作架构特性（例如，性能和可用性）必须在调用期间保持一致。中央协调器会限制架构中任何部分具有不同架构特性的能力。</li><li>例如，<strong>编排驱动的服务导向架构（Orchestration-Driven Service-Oriented Architecture, SOA）</strong>，即使是分布式架构，也通常只有一个量子，因为它普遍使用单一或少量数据库，并且其编排引擎作为巨大的耦合点，阻止了各个部分独立拥有不同的架构特性。</li></ul><h2 id="架构全貌">架构全貌</h2><p><strong>边界设计</strong>：限界上下文、团队边界。</p><p><strong>粒度与组件识别</strong>：功能内聚 vs. 通信复杂度；量子范围思维。</p><p><strong>数据拥有权</strong>：每服务独立数据存储（数据库多样性）；避免共享表。</p><p><strong>通信风格</strong>：同步 vs. 异步；编排 vs. 编舞。</p><p><strong>一致性策略</strong>：最终一致性、Saga、补偿事务。</p><p><strong>弹性与可观测性</strong>：Sidecar/Service Mesh、熔断、限流、Tracing。</p><p><strong>部署与运营</strong>：CI/CD、容器编排（K8s）、自动化测试策略。</p><p><strong>性能与成本权衡</strong>：网络开销、数据复制、缓存策略。</p><p><strong>治理与演化</strong>：契约测试、架构健身函数、可观测指标驱动重构。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十七章的课后思考题，深入探讨微服务架构中限界上下文的核心作用、服务粒度划分的三大原则、sidecar模式的功能特性，以及编排与编舞的通信机制差异、saga分布式事务模式、微服务的敏捷性优势与性能挑战，帮助理解微服务架构的领域驱动设计理念和分布式系统复杂性，提升架构师在构建现代分布式系统时的微服务拆分能力和架构治理水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨16丨面向服务架构</title>
    <link href="https://hedon.top/2025/07/22/fosa/fosa-ch16/"/>
    <id>https://hedon.top/2025/07/22/fosa/fosa-ch16/</id>
    <published>2025-07-22T03:02:00.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十六章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>What was the main driving force behind service-oriented architecture?</p><p>SOA 的主要驱动力是什么？</p></li><li><p>What are the four primary service types within a service-oriented architecture?</p><p>SOA 的四种主要服务类型是什么？</p></li><li><p>List some of the factors that led to the downfall of service-oriented architecture.</p><p>列举一些导致 SOA 衰落的因素。</p></li><li><p>Is service-oriented architecture technically partitioned or domain partitioned?</p><p>SOA 是技术分层还是领域分层？</p></li><li><p>How is domain reuse addressed in SOA? How is operational reuse addressed?</p><p>SOA 中如何解决领域复用和操作复用问题？</p></li></ol><hr><h2 id="背景">背景</h2><blockquote><ol><li><p>What was the main driving force behind service-oriented architecture</p><p>SOA 的主要驱动力是什么？</p></li><li><p>Is service-oriented architecture technically partitioned or domain partitioned?</p><p>SOA 是技术分层还是领域分层？</p></li></ol></blockquote><p>编排驱动的面向服务架构（Orchestration-Driven Service-Oriented Architecture，简称 SOA）是一种在特定时代背景下演变而来的软件架构风格。它在 20 世纪 90 年代末企业快速扩张、需要更复杂的 IT 系统来适应增长的背景下出现。</p><ul><li><strong>资源稀缺性</strong>：在开源操作系统尚未被认为足够可靠用于严肃工作之前，操作系统和商业数据库服务器的许可费用昂贵且按机器收费。这导致架构师们被要求尽可能地实现<strong>重用</strong>，以优化成本。</li><li><strong>企业级重用</strong>：SOA 的一个主要目标是实现服务层面的重用，即逐步构建可随时间增量重用的业务行为。大型公司厌倦了重复编写软件，因此采取了逐步解决这个问题的策略。</li><li><strong>技术分层</strong>：这种架构风格也将<strong>技术分层</strong>理念推向了极致。其驱动哲学围绕着企业级的重用展开。</li></ul><h2 id="拓扑">拓扑</h2><blockquote><ol start="2"><li><p>What are the four primary service types within a service-oriented architecture?</p><p>SOA 的四种主要服务类型是什么？</p></li></ol></blockquote><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250722110031795.png" alt="FOSA Figure 16-1. Topology of orchestration-driven service-oriented architecture"></p><p>围绕企业级复用的目标，SOA 定义了以下几种服务类型：</p><ul><li><strong>业务服务（Business Services）</strong>：位于架构顶层，提供入口点，代表领域行为（例如 ExecuteTrade 或 PlaceOrder）。这些服务定义通常不包含代码，只包含输入、输出和模式信息，并由业务用户定义。</li><li><strong>企业服务（Enterprise Services）</strong>：包含细粒度的共享实现，是构成粗粒度业务服务的构建块，并通过编排引擎连接起来（例如 CreateCustomer、CalculateQuote）。其目标是构建可复用的原子行为，从而逐步建立可复用的企业资产集合。</li><li><strong>应用服务（Application Services）</strong>：一次性、单一实现的服务，不要求与企业服务同等程度的复用和粒度。通常由单一应用团队拥有，用于解决特定应用需求。</li><li><strong>基础设施服务（Infrastructure Services）</strong>：提供操作层面的关注点，如监控、日志记录、身份验证和授权。这些服务通常是具体的实现，由共享的基础设施团队与运维团队紧密协作拥有。</li><li><strong>编排引擎（Orchestration Engine）</strong>：作为分布式架构的核心，负责将业务服务实现通过编排串联起来，包括事务协调和消息转换等功能。它还充当集成中心，允许集成自定义代码、软件包和传统软件系统。由于这个机制是架构的核心，负责这个引擎的集成架构团队往往会成为组织内部的政治力量和官僚瓶颈**…**。</li></ul><h2 id="失败原因">失败原因</h2><blockquote><ol start="3"><li><p>List some of the factors that led to the downfall of service-oriented architecture.</p><p>列举一些导致 SOA 衰落的因素。</p></li><li><p>How is domain reuse addressed in SOA? How is operational reuse addressed?</p><p>SOA 中如何解决领域复用和操作复用问题？</p></li></ol></blockquote><p>这个架构在历史进程中是一个反面教材，它是核心思想就俩字：复用！reuse。</p><p>失败的最核心原因：过度重视技术，以技术为导向进行模块划分和复用尝试，而业务是不断演进变化的，最终技术与业务之间的隔阂无法弥补，功亏一篑。其他原因还有：</p><ul><li>过度追求复用导致的高度耦合</li><li>编排引擎成为巨大的耦合点和瓶颈</li><li>技术分区带来的业务流程碎片化</li></ul><p>这里谈到了一对矛盾：复用和耦合。复用必定会带来耦合，解耦，会带来更多的重复。</p><p>在 SOA 中，复用是其核心目标，但其实现方式也导致了架构的显著副作用：<strong>紧密耦合</strong>。</p><ul><li><strong>领域复用（Domain Reuse）</strong>：SOA 通过抽象共享的业务概念（例如 <code>Customer</code> 客户）为可重用服务来解决领域重用问题。其他服务会引用这些&quot;规范的（canonical）&quot;客户服务。</li><li><strong>操作复用（Operational Reuse）</strong>：通过基础设施服务（Infrastructure Services）尽可能地重用所有功能，无论是领域功能还是操作功能。</li></ul><p>然而，这种设计也带来了负面影响：当一个系统主要围绕重用构建时，组件之间也会产生大量的耦合。例如，对规范客户服务的更改可能会波及到所有其他引用该服务的服务，使得变更变得高风险和复杂。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十六章的课后思考题，深入探讨面向服务架构的历史驱动力与核心理念、四种主要服务类型的特征与职责、SOA衰落的关键因素分析，以及技术分层与领域分层的架构特性、领域复用与操作复用的实现机制，帮助理解面向服务架构的企业级设计原理和服务编排思想，提升架构师在构建大型企业系统时的服务化架构选择能力和SOA设计水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨15丨空间架构</title>
    <link href="https://hedon.top/2025/07/21/fosa/fosa-ch15/"/>
    <id>https://hedon.top/2025/07/21/fosa/fosa-ch15/</id>
    <published>2025-07-21T03:02:00.000Z</published>
    <updated>2025-07-27T04:29:14.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十五章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>Where does space-based architecture get its name from?</p><p>空间架构的名字从何而来？</p></li><li><p>What is a primary aspect of space-based architecture that differentiates it from other architecture styles?</p><p>空间架构区别与其他架构的主要方面是什么？</p></li><li><p>Name the four components that make up the virtualized middleware within a space-based architecture.</p><p>说出空间架构的虚拟化中间层的 4 个组成结构。</p></li><li><p>What is the role of the messaging grid?</p><p>消息网格的作用是什么？</p></li><li><p>What is the role of a data writer in space-based architecture?</p><p>数据写入器在空间架构中的作用是什么？</p></li><li><p>Under what conditions would a service need to access data through the data reader?</p><p>一个服务在什么情况下需要通过数据读取器去获取数据？</p></li><li><p>Does a small cache size increase or decrease the chances for a data collision?</p><p>缓存越小，数据冲突概率是增大还是减小？</p></li><li><p>What is the difference between a replicated cache and a distributed cache? Which one is typically used in space-based architecture?</p><p>复制缓存和分布式缓存的区别是什么？空间架构更倾向于使用哪个？</p></li><li><p>List three of the most strongly supported architecture characteristics in space- based architecture.</p><p>列出 3 个空间架构中非常优秀的架构特性。</p></li><li><p>Why does testability rate so low for space-based architecture?</p><p>为什么空间架构的可测性较差？</p></li></ol><hr><h2 id="背景">背景</h2><p>基于空间的架构（SBA）是一种专门为解决<strong>高伸缩性（Scalability）</strong>、<strong>高弹性（Elasticity）</strong>、<strong>高并发（High Concurrency）</strong>、<strong>变动剧烈且不可预测</strong>的应用场景，例如在线票务系统或在线拍卖系统。</p><p>传统三层 Web 拓扑在用户量剧增时呈倒三角：Web 层易横向扩容，数据库层最难扩容，最终成为性能上限。为削弱数据库瓶颈，业界先用本地缓存，再出现集中式分布式缓存，但网络跳转仍是热点。把数据直接放到每个处理节点的 <strong>复制型内存网格</strong> 并实时同步，才真正让数据库从&quot;同步路径&quot;上消失，空间架构由此成形。</p><p>空间架构的名称来源于**元组空间（Tuple Space）**多个并行处理器通过共享内存进行通信。SBA 的核心理念便是将应用数据保存在内存中（in-memory），并在所有活跃的处理单元（Processing Units）复制，从而移除中心数据库作为同步约束，实现近乎无限的伸缩性。</p><h2 id="拓扑">拓扑</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250721175147426.png" alt="FOSA Figure 15-2. Space-based architecture basic topology"></p><h3 id="处理单元-Processing-Unit">处理单元 Processing Unit</h3><ul><li>处理单元包含了<strong>应用逻辑</strong>（包括基于 Web 的组件和后端业务逻辑）。</li><li>它还包含一个<strong>内存数据网格</strong>和<strong>复制引擎</strong>，通常由 Hazelcast、Apache Ignite 或 Oracle Coherence 等产品实现。</li><li>处理单元可以包含小型、单一用途的服务，类似于微服务</li></ul><h3 id="虚拟化中间件-Virtualized-Middleware">虚拟化中间件 Virtualized Middleware</h3><p>虚拟化中间件负责处理架构中的基础设施问题，控制数据同步和请求处理。它由以下四个关键组件组成：</p><ul><li><strong>消息网格（Messaging Grid）</strong>：它负责将请求转发到任何可用的处理单元。</li><li><strong>数据网格（Data Grid）</strong>：它是 SBA 中最重要和关键的组件，通常在处理单元内部以复制缓存的形式实现。它确保每个处理单元都包含完全相同的数据，数据复制是异步且快速的。</li><li><strong>处理网格（Processing Grid）</strong>：这是一个可选组件，用于管理<strong>协调请求处理</strong>，当一个业务请求涉及多个处理单元时，它会协调这些处理单元之间的请求。</li><li><strong>部署管理器（Deployment Manager）</strong>：该组件根据负载条件管理处理单元实例的<strong>动态启动和关闭</strong>，对于实现应用的弹性伸缩至关重要。</li></ul><h3 id="数据泵-Data-Pumps">数据泵 Data Pumps</h3><p>数据泵是<strong>将数据发送到另一个处理器，然后该处理器更新数据库</strong>的方式。它们总是<strong>异步</strong>的，提供内存缓存与数据库之间的<strong>最终一致性（Eventual Consistency）</strong>。消息机制是数据泵的常用实现方式，因为它支持异步通信、保证消息传递和维护消息顺序。</p><h3 id="数据写入器-Data-Writers">数据写入器 Data Writers</h3><p>数据写入器（Data Writers）负责接收来自数据泵的消息，并用消息中包含的信息更新数据库。它们可以是服务、应用或数据中心（如 Ab Initio）。写入器的粒度可以根据数据泵和处理单元的范围而变化，例如，领域驱动的数据写入器可以处理特定领域（如客户）内的所有更新。</p><h3 id="数据读取器-Data-Readers">数据读取器 Data Readers</h3><p>负责从数据库读取数据，并通过反向数据泵将其发送到处理单元。服务需要通过数据读取器访问数据的情况有三种：</p><ol><li>所有相同命名缓存的处理单元实例都崩溃时。</li><li>所有相同命名缓存的处理单元需要重新部署时。</li><li>需要检索复制缓存中不包含的归档数据时。</li></ol><h2 id="数据冲突">数据冲突</h2><blockquote><p>不同的 processing unit 处理同一个业务逻辑相关的数据时，由于数据同步存在时序问题，所以很容易出现数据不一致的情况。</p></blockquote><p>可以从以下几个因素进行冲突概率的评估：</p><ul><li>N：处理相同缓存的 processing unit 的数量</li><li>UR：缓存更新频率</li><li>S：缓存大小</li><li>RL：缓存复制的延迟</li></ul><p>CollisitionRate = N* (UR^2^/S) *RL</p><p>其中<strong>缓存大小越小，意味着缓存能够容纳的数据量越少，因此在给定的更新速率和复制延迟下，数据被频繁覆盖和发生冲突的几率就越高。</strong></p><h2 id="分布式缓存">分布式缓存</h2><p><strong>复制缓存</strong>：每个处理单元包含一个自己的内存数据网格，与其他共享相同命名缓存的处理单元同步。这是 SBA 通常采用的缓存模式，因为它提供高性能和高容错性。适用于小缓存大小（&lt;100MB）、低更新率和相对静态数据。</p><p><strong>分布式缓存</strong>：需要一个外部服务器或服务专门用于存放集中式缓存。它支持高水平的数据一致性，但性能较低（需要远程访问），且容错性存在问题（如果缓存服务器宕机）。适用于大缓存大小（&gt;500MB）、高度动态数据和高更新率。</p><h2 id="优点">优点</h2><ul><li><strong>弹性（Elasticity）</strong>：处理单元可以根据负载动态启停，实现高度弹性。</li><li><strong>伸缩性（Scalability）</strong>：通过内存数据缓存和移除数据库约束，支持处理数百万并发用户。</li><li><strong>性能（Performance）</strong>：移除了数据库瓶颈，提供了极高的性能。</li></ul><h2 id="缺点">缺点</h2><ul><li><strong>简洁性（Simplicity）</strong>：SBA 是一种<strong>非常复杂的架构风格</strong>，因为它涉及到缓存、最终一致性以及众多动态组件。</li><li><strong>可测试性（Testability）</strong>：由于需要模拟极高的伸缩性和弹性负载，<strong>测试复杂且成本高昂</strong>，许多高负载测试甚至需要在生产环境中进行，带来巨大风险。</li><li><strong>成本（Cost）</strong>：由于缓存产品许可费和高资源利用率，SBA 通常相对昂贵。</li></ul>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十五章的课后思考题，深入探讨空间架构的命名来源与核心特征、虚拟化中间层的组件构成、消息网格与数据读写器的协作机制，以及缓存策略选择、数据冲突管理和架构特性评估分析，帮助理解空间架构的分布式计算原理和高可扩展性设计思路，提升架构师在构建高性能分布式系统时的架构选择能力和空间化设计水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨14丨事件驱动架构</title>
    <link href="https://hedon.top/2025/07/18/fosa/fosa-ch14/"/>
    <id>https://hedon.top/2025/07/18/fosa/fosa-ch14/</id>
    <published>2025-07-18T02:30:00.000Z</published>
    <updated>2025-07-27T04:29:14.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十四章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>What are the primary differences between the broker and mediator topologies?</p><p>代理拓扑（broker）和中介者拓扑（mediator）两种拓扑的根本区别是什么？</p></li><li><p>For better workflow control, would you use the mediator or broker topology?</p><p>为了更好的流程控制，你会选择代理拓扑还是中介者拓扑？</p></li><li><p>Does the broker topology usually leverage a publish-and-subscribe model with topics or a point-to-point model with queues?</p><p>在代理拓扑中，是经常使用基于主题的发布订阅模式还是基于队列的点到点模式？</p></li><li><p>Name two primary advantage of asynchronous communications.</p><p>列出 2 个异步通信的主要优势。</p></li><li><p>Give an example of a typical request within the request-based model.</p><p>举一个 request-based 模式的典型例子。</p></li><li><p>Give an example of a typical request in an event-based model.</p><p>举一个 event-based 模式的典型例子。</p></li><li><p>What is the difference between an initiating event and a processing event in event-driven architecture?</p><p>在事件驱动架构中，初始事件和处理中事件二者有什么不同？</p></li><li><p>What are some of the techniques for preventing data loss when sending and receiving messages from a queue?</p><p>有哪些技术可以防止在从队列发送和接收消息时丢失数据？</p></li><li><p>What are three main driving architecture characteristics for using event-driven architecture?</p><p>使用事件驱动架构的三个主要驱动架构特性是什么？</p></li><li><p>What are some of the architecture characteristics that are not well supported in event-driven architecture?</p><p>事件驱动架构不能很好地支持哪些架构特性？</p></li></ol><hr><p>传统的软件设计如同一个等级森严的组织，组件 A 直接向组件 B <strong>下达命令</strong>（例如，调用一个函数或 API）。而事件驱动架构则更像一个现代化的、扁平的协作网络。组件 A 只是<strong>发布一个事实</strong>（嘿，我这里发生了一件事！），而其他对此事感兴趣的组件（B, C, D…）可以自行决定如何<strong>响应</strong>。这种从命令到响应的范式革命，是事件驱动架构（Event-Driven Architecture, EDA）的灵魂所在。</p><h2 id="异步通信">异步通信</h2><p>EDA 的力量源泉来自于异步通信，它有以下优点：</p><ol><li><strong>极高的系统韧性与可用性 (Resiliency and Availability)</strong>：在同步调用中，如果服务 B 宕机，服务 A 的调用会立刻失败，导致整个链路中断。但在异步模式下，服务 A 将事件发送给一个中间人（消息代理），然后就可继续自己的工作。即使服务 B 此时宕机，事件也会被安全地存放在代理中，待 B 恢复后再进行处理。这使得系统能够优雅地处理局部故障，整体可用性大大提高。</li><li><strong>卓越的可伸缩性与弹性 (Scalability and Elasticity)</strong>：生产者和消费者被完全解耦，可以独立进行伸缩。如果事件产生的速度突然加快，我们只需要增加消费者实例的数量即可，而无需对生产者做任何改动。这种按需、独立伸缩的能力是构建高弹性系统的关键。</li></ol><h2 id="拓扑">拓扑</h2><p>典型的 EDA 有 2 种拓扑，分别为：</p><ul><li>代理拓扑（broker）</li><li>中介者拓扑（mediator）</li></ul><h3 id="broker">broker</h3><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718110824820.png" alt="FOSA Figure 14-2. Broker topology"></p><p>一个典型的 broker 拓扑如上图所示，它包含以下几个部分：</p><ul><li><code>initiating event</code>：初始事件，它用于<strong>启动整个事件流</strong>，一般来源于系统外部。</li><li><code>event channel</code>：事件通道，用于传递事件，比如 Go 的 channel，或者分布式系统中的消息队列，如 RabbitMQ、Kafka 等。一个事件通道一般对应一个订阅主题（topic）。</li><li><code>event processor</code>：事件处理器，它们会根据需求，订阅自己感兴趣的 topic，从 <code>event channel</code> 中获取事件进行处理。</li><li><code>processing event</code>：处理事件，是由<strong>事件处理器生成并异步广播的事件</strong>，用于广告它刚刚完成了什么操作。这些事件是事件流的中间步骤，通知其他事件处理器某个操作已经完成，以便它们可以继续后续的处理。无论是否有其他的 <code>event processor</code> 关心这些事件，最佳实践中还是建议一直发布这些事件，这对于后续的扩展性非常良好。</li></ul><p>它具有以下特点：</p><ul><li><strong>核心思想</strong>：它的唯一职责就是高效、可靠地分发事件。所有的业务逻辑和处理步骤都存在于各个独立的事件处理器（服务）中。</li><li><strong>工作流</strong>：工作流是<strong>分散且隐式</strong>的。一个事件可能被多个消费者同时处理，触发多个并行的、互不相关的后续流程。</li><li><strong>通信模型</strong>：利用<strong>基于主题的发布/订阅（Publish-Subscribe）模型</strong>。一个事件被发布到特定主题（Topic）上，所有订阅了该主题的消费者都能收到一份该事件的副本并进行处理。这使得系统具有极强的扩展性，可以随时增加新的订阅者来响应现有事件，而无需修改任何已有代码。</li><li><strong>优点</strong>：事件生产者和事件消费者之间是<strong>完全解耦</strong>的。生产者不知道谁会消费它的事件，消费者也不知道是谁生产了它所消费的事件。它们唯一的共同依赖是<strong>消息代理</strong>以及<strong>事件的契约（Schema）</strong>。</li><li><strong>缺点</strong>：端到端的工作流是<strong>隐式</strong>的，缺乏全局视图。如果流程出了问题，很难追踪到底是哪个环节的协同出了错，这对于异常处理和数据一致性要求较高的系统不是很友好。</li></ul><p>完整例子可参考下图：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718113630056.png" alt="FOSA Figure 14-4. Example of the broker topology"></p><h3 id="mediator">mediator</h3><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718111638117.png" alt="FOSA Figure 14-5. Mediator topology"></p><p>一个典型的 mediator 拓扑如上图所示，它跟 broker 有些许不同：</p><ul><li><code>event queue</code>：事件队列，它跟 <code>event channel</code> 有所不同，专门用于 <code>event mediator</code> 接收 <code>initiating event</code>。</li><li><code>event mediator</code>：事件中介者，了解处理事件所需的步骤，并生成相应的处理事件，这些事件被发送到专用事件通道（event channel），采用<strong>点对点消息传递</strong>方式。在一些复杂的场景中，也可以设置多个 <code>event mediator</code>，并分配到不同的层次中，以更好的管理复杂业务流程。</li></ul><p>它具有以下特点：</p><ul><li><strong>核心思想</strong>：它像一个流程编排引擎，包含了实现复杂业务流程的核心逻辑。</li><li><strong>工作流</strong>：工作流是<strong>集中且显式</strong>的。中介者接收一个初始事件，然后根据预设的逻辑，一步步地调用不同的服务来完成一个完整的、有状态的业务流程。</li><li><strong>通信模型</strong>：利用<strong>基于队列的点对点（Point-to-Point）模型</strong>。</li><li><strong>优点</strong>：工作流是<strong>显式</strong>的，易于理解、监控和管理。复杂的错误处理、重试、补偿逻辑都可以在中介者中集中处理。</li><li><strong>缺点</strong>：中介者本身可能成为一个<strong>复杂的单点</strong>（但通常是高可用的集群），所有流程的修改都必须在其中进行，降低了系统的灵活性。</li></ul><p>完整例子可参考下图：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718113522146.png" alt="FOSA Figure 14-9. Step 2 of the mediator example"></p><h3 id="对比">对比</h3><table><thead><tr><th>对比维度</th><th>代理拓扑 (Broker Topology)</th><th>中介者拓扑 (Mediator Topology)</th></tr></thead><tbody><tr><td><strong>核心组件</strong></td><td>轻量级、无状态的消息代理</td><td>重量级、有状态的流程中介者</td></tr><tr><td><strong>智能位置</strong></td><td>分散在各个事件处理器中</td><td>集中在中介者中</td></tr><tr><td><strong>工作流</strong></td><td><strong>协同式 (Choreography)</strong>，隐式，涌现式</td><td><strong>编排式 (Orchestration)</strong>，显式，集中式</td></tr><tr><td><strong>流程控制</strong></td><td>弱，难以进行全局控制</td><td>强，易于进行精细控制和监控</td></tr><tr><td><strong>耦合模型</strong></td><td>极致解耦（仅依赖代理和事件契约）</td><td>轮轴式耦合（所有服务都依赖中-介者）</td></tr><tr><td><strong>灵活性</strong></td><td>极高，易于增加新的事件响应者</td><td>较低，流程变更需修改中介者</td></tr><tr><td><strong>典型技术</strong></td><td>消息队列、流平台 (Kafka, RabbitMQ)</td><td>工作流引擎、ESB (AWS Step Functions, Camel)</td></tr><tr><td><strong>适用场景</strong></td><td>简单通知、数据广播、高度可扩展的系统</td><td>复杂、多步、有状态的业务流程，Saga 模式</td></tr></tbody></table><h2 id="Request-Reply">Request-Reply</h2><blockquote><ol start="5"><li><p>Give an example of a typical request within the request-based model.</p><p>举一个 request-based 模式的典型例子。</p></li><li><p>Give an example of a typical request in an event-based model.</p><p>举一个 event-based 模式的典型例子。</p></li></ol></blockquote><h3 id="request-based-vs-event-based">request-based vs event-based</h3><table><thead><tr><th>对比维度</th><th>基于请求的模型 (Request-Based)</th><th>基于事件的模型 (Event-Based)</th></tr></thead><tbody><tr><td><strong>核心意图</strong></td><td><strong>命令 (Command)</strong></td><td><strong>通知 (Notification / Fact)</strong></td></tr><tr><td><strong>详细说明</strong></td><td>请求方必须知道接收方的确切地址和接口（例如，一个 URL 端点和其 API 契约）。它们之间是点对点的、强依赖的关系。</td><td>发布方和消费方互相完全不知道对方的存在。它们唯一的共同依赖是消息中间件和事件的格式。这种解耦是其最大优势。</td></tr><tr><td><strong>通信模式</strong></td><td><strong>通常是同步的 (Synchronous)</strong></td><td><strong>总是异步的 (Asynchronous)</strong></td></tr><tr><td><strong>详细说明</strong></td><td>请求方发送请求后，会<strong>阻塞并等待</strong>一个响应。从请求方的视角看，整个调用是一个连续、不间断的操作。</td><td>发布方发送事件后，<strong>立即继续</strong>自己的工作（“发后即忘” Fire-and-Forget）。它不等待任何结果。</td></tr><tr><td><strong>例子</strong></td><td><strong>打电话</strong></td><td><strong>发布社交动态</strong></td></tr></tbody></table><h3 id="event-based-实现-reply">event-based 实现 reply</h3><p>虽然事件驱动架构的核心是异步和解耦，但在很多业务场景中，请求方确实需要得到一个明确的回复。例如，一个 Web 前端请求处理一个复杂的计算，它不能永远等待，而是需要在一个合理的时间内得到计算结果。</p><p>在事件模型之上实现请求-响应模式，关键在于解决两个核心问题：</p><ol><li><strong>响应应该发往何处？</strong> （因为接收方并不知道请求方是谁）</li><li><strong>收到的响应如何与当初的请求对应起来？</strong> （因为请求方可能同时发出了多个请求）</li></ol><p>解决方案是巧妙地利用消息的两个元数据字段：<strong>回复地址 (Reply-To)</strong> 和 <strong>关联标识 (Correlation ID)</strong>。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718132839093.png" alt="FOSA Figure 14-20. Request-reply message processing using a correlation ID"></p><p><strong>Step 1: 请求方 (Requester) 发起请求</strong></p><ol><li><strong>创建临时回复队列</strong>：请求方首先为自己创建一个唯一的、临时的、专用于接收本次响应的队列。这个队列的生命周期通常与本次请求-响应过程绑定。</li><li><strong>生成关联 ID</strong>：请求方生成一个全局唯一的字符串，作为 <code>Correlation ID</code>。</li><li><strong>构造请求消息</strong>：请求方创建请求消息，其内容是业务数据。在消息的**属性（Properties）或头信息（Headers）**中，设置两个关键字段：<ul><li><code>Reply-To</code>: 填入刚才创建的临时回复队列的名称。</li><li><code>Correlation ID</code>: 填入刚才生成的唯一 ID。</li></ul></li><li><strong>发送并等待</strong>：请求方将这个构造好的消息发送到一个众所周知的<strong>请求队列</strong>（例如 <code>calculation-request-queue</code>）。然后，它开始<strong>监听</strong>自己的那个<strong>临时回复队列</strong>，等待一个包含相同 <code>Correlation ID</code> 的消息出现。通常还会设置一个超时时间。</li></ol><p><strong>Step 2: 响应方 (Replier) 处理请求并回复</strong></p><ol><li><strong>接收请求</strong>：响应方服务从<strong>请求队列</strong>中消费一条消息。</li><li><strong>处理业务逻辑</strong>：执行消息内容所要求的业务计算或操作。</li><li><strong>提取元数据</strong>：从收到的请求消息的属性中，提取出 <code>Reply-To</code> 和 <code>Correlation ID</code> 的值。</li><li><strong>构造响应消息</strong>：响应方创建响应消息，其内容是业务处理的结果。</li><li><strong>设置并发送响应</strong>：在响应消息的属性中，<strong>必须</strong>将从请求中收到的那个 <code>Correlation ID</code> <strong>原封不动地设置回去</strong>。然后，将此响应消息发送到请求消息中 <code>Reply-To</code> 字段所指定的那个队列地址。</li></ol><p><strong>Step 3: 请求方 (Requester) 接收响应</strong></p><ol><li><strong>接收消息</strong>：请求方在其临时回复队列上收到了一个消息。</li><li><strong>匹配关联 ID</strong>：它检查收到的响应消息中的 <code>Correlation ID</code> 是否与它当初发送的那个 ID 相匹配。</li><li><strong>完成闭环</strong>：如果 ID 匹配，则证明这就是它所等待的响应。请求-响应的流程至此完成。请求方可以处理响应结果，然后安全地删除那个临时的回复队列。</li></ol><h2 id="可靠性">可靠性</h2><blockquote><p>What are some of the techniques for preventing data loss when sending and receiving messages from a queue?</p><p>有哪些技术可以防止在从队列发送和接收消息时丢失数据？</p></blockquote><p>这是一个生产者、消费者和代理三方共同的责任：</p><p><strong>1. 代理端 (Broker Side)</strong>：</p><ul><li><strong>持久化 (Persistence)</strong>：代理在将事件放入队列或主题时，会先将其写入磁盘，确保即使代理重启，事件也不会丢失。</li><li><strong>集群与复制 (Clustering and Replication)</strong>：通过将代理部署为集群，并将事件在多个节点间进行复制，可以防止单点故障导致的数据丢失。</li></ul><p><strong>2. 客户端 (Client Side)</strong>：</p><ul><li><strong>消费者确认 (ACK)</strong>：消费者在<strong>成功处理完</strong>一个事件后，必须向代理发送一个 ACK 信号。如果消费者在处理过程中崩溃而未发送 ACK，代理会认为该事件未被成功处理，并会将其重新投递给其他消费者。</li><li><strong>事务性发件箱 (Transactional)</strong>：这是一个非常关键的高级模式。为了确保&quot;写入业务数据库&quot;和&quot;发送事件&quot;这两个操作的原子性，开发者会将待发送的事件与业务数据变更<strong>放在同一个本地数据库事务中</strong>，写入一个发件箱（Outbox）表。然后由一个独立的轮询进程负责读取发件箱表，并将事件可靠地发送给代理。这彻底解决了&quot;业务成功但事件未发出&quot;的问题。</li></ul><h2 id="架构权衡">架构权衡</h2><blockquote><p>What are three main driving architecture characteristics for using event-driven architecture?</p><p>使用事件驱动架构的三个主要驱动架构特性是什么？</p></blockquote><ul><li><strong>可伸缩性与弹性 (Scalability &amp; Elasticity)</strong>：如前所述，独立伸缩组件的能力是其核心优势。</li><li><strong>可扩展性 (Extensibility)</strong>：系统极易扩展。当需要增加新功能时，只需开发一个新的服务来订阅感兴趣的现有事件即可，完全无需改动已有服务。</li><li><strong>响应性 (Responsiveness)</strong>：对于需要快速响应用户的系统，可以将耗时任务异步化。例如，用户提交视频后，系统立即返回&quot;上传成功，正在处理中&quot;，然后通过事件驱动后台的转码、审核等一系列复杂流程。</li></ul><blockquote><p>What are some of the architecture characteristics that are not well supported in event-driven architecture?</p><p>事件驱动架构不能很好地支持哪些架构特性？</p></blockquote><ul><li><strong>简单性 (Simplicity)</strong>：EDA 显著增加了系统的复杂性。你需要管理消息代理，处理异步编程的挑战（如调试、错误处理），并应对最终一致性带来的心智负担。</li><li><strong>事务性 (Transactional)</strong>：实现跨多个服务的原子性操作（即分布式事务）变得异常困难。虽然可以通过 Saga 等模式来模拟长事务，但其实现复杂，且只能保证最终一致性而非强一致性。</li><li><strong>工作流的可观测性 (Observability of Workflow)</strong>：尤其是在代理拓扑中，业务流程被分散到各个独立的处理器中，没有一个集中的地方可以让你直观地看到一个完整的业务流程是如何执行的，这给监控和排错带来了巨大挑战。</li></ul>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十四章的课后思考题，深入探讨事件驱动架构中代理拓扑与中介者拓扑的设计差异、异步通信的优势机制、请求模式与事件模式的应用场景，以及事件类型分类、消息可靠性保障技术和架构特性支持分析，帮助理解事件驱动架构的核心设计原理和实施策略，提升架构师在构建响应式系统时的架构选择能力和事件化设计水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨13丨基于服务的架构</title>
    <link href="https://hedon.top/2025/07/17/fosa/fosa-ch13/"/>
    <id>https://hedon.top/2025/07/17/fosa/fosa-ch13/</id>
    <published>2025-07-17T02:30:00.000Z</published>
    <updated>2025-07-27T04:29:14.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十三章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>How many services are there in a typical service-based architecture?</p><p>在一个经典的基于服务的架构中通常有多少个服务？</p></li><li><p>Do you have to break apart a database in service-based architecture?</p><p>在基于服务的架构中，你是否必须将数据库进行拆分？</p></li><li><p>Under what circumstances might you want to break apart a database?</p><p>在什么场景下你会对数据库进行拆分？</p></li><li><p>What technique can you use to manage database changes within a service-based architecture?</p><p>在基于服务的架构中，你会使用什么样的技术来管理数据库变更？</p></li><li><p>Do domain services require a container (such as Docker) to run?</p><p>领域服务需要在容器（如 Docker）中运行吗？</p></li><li><p>Which architecture characteristics are well supported by the service-based architecture style?</p><p>基于服务的架构在哪些架构特性表现很优异？</p></li><li><p>Why isn’t elasticity well supported in a service-based architecture?</p><p>为什么基于服务的架构的架构弹性不是很好？</p></li><li><p>How can you increase the number of architecture quanta in a service-based architecture?</p><p>在基于服务的架构中，你如何增加架构量子的数量？</p></li></ol><hr><h2 id="简介">简介</h2><p>在软件架构的演进光谱中，如果说单体（Monolith）和微服务（Microservices）是两个广为人知的端点，那么基于服务的架构（Service-Based Architecture, SBA）就是它们之间那个常常被忽略，却又极具现实意义的&quot;务实中间派&quot;。它既非庞大到笨拙，也非精细到繁杂，为许多成长中的系统提供了一条平滑的演进路径。</p><p>SBA 的本质是一种将一个大型的单体应用，<strong>分解为少数几个、逻辑独立的、可独立部署的&quot;服务&quot;</strong> 的架构风格。SBA 的服务数量通常不多，一般在 <strong>4 到 12 个</strong>之间。它不像微服务那样追求极致的拆分（可能会有几十上百个服务），而是将应用按照**核心的业务领域（Domain）**进行划分。</p><h2 id="拓扑">拓扑</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250717114456233.png" alt="FOSA Figure 13-8. Electronics recycling example using service-based architecture"></p><h2 id="数据库">数据库</h2><p>SBA 最具标志性，也是与微服务最根本的区别之一，就在于它对数据库的处理方式。这直接引出了接下来的两个问题。</p><blockquote><p>Do you have to break apart a database in service-based architecture?</p><p>在基于服务的架构中，你是否必须将数据库进行拆分？</p></blockquote><p>答案是：<strong>通常不，而且默认不拆分是其主要特征。</strong></p><p>SBA 的典型实现是，所有服务共享<strong>同一个数据库</strong>。这种设计的初衷是为了在享受独立部署带来的好处的同时，最大限度地<strong>降低数据层面的复杂性</strong>。共享数据库可以：</p><ul><li><strong>简化开发</strong>：开发者无需处理复杂的分布式事务和跨服务数据同步问题。</li><li><strong>保证数据一致性</strong>：传统的 ACID 事务可以在数据库层面轻松实现。</li><li><strong>降低技术门槛</strong>：团队无需掌握复杂的分布式数据管理技术。</li></ul><p>在共享数据库的模式下，如何管理这个公共资产成了一个关键的治理问题。</p><blockquote><p>What technique can you use to manage database changes within a service-based architecture?</p><p>在基于服务的架构中，你会使用什么样的技术来管理数据库变更？</p></blockquote><p>当多个团队开发的服务都依赖同一个数据库时，随意的 Schema 变更会引发灾难。因此，必须采用严格的数据库治理技术。</p><p>核心方法是成立一个跨团队的数据库治理小组，或者由一个专职的数据库管理员（DBA）团队来担当此任。这个团队的职责是：</p><ul><li><strong>守护数据库 Schema 的所有权</strong>：任何对数据库结构的修改（增删改表、字段等）都必须通过该团队的评审。</li><li><strong>执行数据库迁移脚本</strong>：使用专业的数据库迁移工具（如 <strong>Flyway</strong> 或 <strong>Liquibase</strong>）来统一管理和执行所有的变更脚本，确保变更的可追溯性、版本化和一致性。</li><li><strong>保证向后兼容性</strong>：确保数据库的变更不会破坏现有服务的正常运行。</li></ul><p>然而，这种共享模式并非一成不变，这就引出了下一个问题：</p><blockquote><p>Under what circumstances might you want to break apart a database?</p><p>在什么场景下你会对数据库进行拆分？</p></blockquote><p>随着业务发展，共享数据库的弊端会逐渐显现。在以下情况下，拆分数据库就成了合理的选择：</p><ol><li><strong>服务资源争用 (Service Contention)</strong>：某个服务（如高流量的商品浏览服务）对数据库产生巨大压力，影响了其他关键服务（如订单服务）的性能。</li><li><strong>数据隔离与安全 (Data Isolation and Security)</strong>：某个服务处理的数据高度敏感（如支付服务中的金融信息），需要从主数据库中物理隔离出来，以满足合规性或安全要求。</li><li><strong>技术栈不匹配 (Technology Mismatch)</strong>：某个服务有特殊的数据存储需求。例如，搜索服务最适合使用 Elasticsearch，而核心业务数据则存储在关系型数据库中。</li></ol><p>当这些情况发生时，SBA 允许你&quot;渐进式&quot;地将某个服务连同其数据一起剥离出去，赋予它独立的数据库。</p><h2 id="部署">部署</h2><blockquote><p>Do domain services require a container (such as Docker) to run?</p><p>领域服务需要容器（例如 Docker）来运行吗？</p></blockquote><p>答案是：<strong>不需要，但强烈推荐。</strong></p><p>从技术上讲，你可以将每个服务单独部署服务器上。但是，容器技术（如 Docker）和容器编排工具（如 Kubernetes）与 SBA 的理念天然契合。使用容器可以带来巨大好处：</p><ul><li>环境一致性</li><li>部署简化</li><li>资源利用率</li></ul><h2 id="架构权衡">架构权衡</h2><blockquote><p>Which architecture characteristics are well supported by the service-based architecture style?</p><p>基于服务的架构在哪些架构特性表现很优异？</p></blockquote><p>相比于单体架构，SBA 在以下方面有显著提升：</p><ol><li><strong>可部署性 (Deployability)</strong>：这是最大的优势之一。每个服务都可以独立部署，使得发布更加频繁、风险更低。</li><li><strong>模块化 (Modularity)</strong>：通过按领域划分服务，实现了清晰的业务模块边界。</li><li><strong>可维护性 (Maintainability)</strong>：每个服务的代码库规模远小于整个单体，更易于理解、修改和维护。</li><li><strong>容错性 (Fault Tolerance)</strong>：一个服务的崩溃不会导致整个应用程序宕机（尽管共享数据库可能成为共同的故障点）。</li></ol><p>然而，SBA 并非银弹，它也有其固有的局限性。</p><blockquote><p>Why isn’t elasticity well supported in a service-based architecture?</p><p>为什么基于服务的架构的架构弹性不是很好？</p></blockquote><p><strong>弹性</strong>指的是根据实时负载，自动、精细地伸缩应用<strong>特定部分</strong>的能力。</p><p>SBA 对弹性的支持不佳，根源在于其服务的<strong>粗粒度</strong>。假设&quot;订单服务&quot;包含了&quot;浏览历史订单&quot;、&quot;创建新订单&quot;和&quot;订单退款&quot;三个功能。如果&quot;创建新订单&quot;功能因为促销活动而流量激增，你无法只针对这一个功能进行扩容。你必须将整个庞大的&quot;订单服务&quot;进行水平扩展，复制出多个实例。这不仅造成了资源浪费（其他两个功能并未承压），也远不如微服务那样能够对具体功能点进行精准、高效的弹性伸缩。</p><h2 id="架构量子">架构量子</h2><blockquote><p>How can you increase the number of architecture quanta in a service-based architecture?</p><p>在基于服务的架构中，你如何增加架构量子的数量？</p></blockquote><p>首先要明确，在<strong>典型的、共享数据库的 SBA</strong> 中，整个系统只有<strong>一个架构量子</strong>。因为所有服务都与同一个数据库紧密耦合，它们无法被真正独立地部署和演化，形成了一个不可分割的整体。</p><p>增加架构量子的数量，唯一的途径就是<strong>打破这种共享依赖</strong>。具体方法是： <strong>将某个服务连同其数据一起拆分出来，为其分配一个独立的、专用的数据库。</strong></p><p>每完成一次这样的拆分，这个被分离出去的服务就演变成了一个独立的架构量子。因此，增加架构量子的过程，就是<strong>逐步从共享数据库模型向&quot;每个服务一个数据库&quot;模型演进的过程</strong>，也就逐渐趋向于微服务架构了。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十三章的课后思考题，深入探讨基于服务的架构中服务数量的设计考量、数据库分解策略与变更管理机制、领域服务的容器化部署模式，以及基于服务架构的特性支持分析、弹性限制因素和架构量子扩展方案，帮助理解基于服务架构的核心设计原则和实施要点，提升架构师在构建分布式系统时的架构选择能力和服务化设计水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨12丨微核架构</title>
    <link href="https://hedon.top/2025/07/16/fosa/fosa-ch12/"/>
    <id>https://hedon.top/2025/07/16/fosa/fosa-ch12/</id>
    <published>2025-07-16T02:20:00.000Z</published>
    <updated>2025-07-27T04:29:14.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十二章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>What is another name for the microkernel architecture style?</p><p>微核架构风格的别名是什么？</p></li><li><p>Under what situations is it OK for plug-in components to be dependent on other plug-in components?</p><p>在什么情况下，插件组件之间可以相互依赖？</p></li><li><p>What are some of the tools and frameworks that can be used to manage plug-ins?</p><p>有哪些工具和框架可用于管理插件？</p></li><li><p>What would you do if you had a third-party plug-in that didn’t conform to the standard plug-in contract in the core system?</p><p>如果一个第三方插件不遵循核心系统的标准插件契约，你会怎么做？</p></li><li><p>Provide two examples of the microkernel architecture style.</p><p>举 2 个微核架构的例子。</p></li><li><p>Is the microkernel architecture style technically partitioned or domain partitioned?</p><p>微核架构是技术分区还是领域分区？</p></li><li><p>Why is the microkernel architecture always a single architecture quantum?</p><p>为什么微核架构总是单一的架构量子？</p></li><li><p>What is domain/architecture isomorphism?</p><p>什么是领域/架构同构性？</p></li></ol><hr><h2 id="拓扑">拓扑</h2><p>微核架构，也被称为<strong>插件化架构（Plug-in Architecture）</strong>，是一种能够提供极高扩展性、灵活性和演化能力的系统设计模式。它的核心思想是将系统功能划分为两部分：一个最小化的、稳定的**核心系统（Core System）<strong>和一个由独立</strong>插件组件（Plug-in Components）**构成的可扩展生态。</p><p>我们可以将其想象成一个智能手机：操作系统是其微核，提供最基础的功能（通信、电源管理、应用商店接口），而我们安装的每一个 App 就是一个插件，为手机赋予了无穷无尽的新功能。</p><p>核心构成：</p><ul><li><strong>核心系统 (Core System)</strong>：这是架构的“微核”。它的职责被严格限制在<strong>最小且必要</strong>的范围内，通常只包含：<ol><li>系统运行所必需的通用业务逻辑（例如，一个 IDE 的文件管理和基础编辑器）。</li><li>一个至关重要的<strong>插件管理机制</strong>，包括插件的注册、发现、生命周期管理等。这是连接核心与插件的桥梁。</li></ol></li><li><strong>插件组件 (Plug-in Components)</strong>：这些是独立的、可插拔的模块，用于实现<strong>扩展功能或特定业务逻辑</strong>。每个插件都通过一个由核心系统定义的**标准契约（Standard Contract）**来与核心交互。这个契约通常是一个接口或一组 API。</li></ul><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250716105151041.png" alt="FOSA Figure 12-1. Basic components of the microkernel architecture style"></p><p>典型例子：</p><ul><li>Chrome</li><li>VS Code</li></ul><h2 id="插件生态">插件生态</h2><p>理想情况下，插件应该只依赖于核心系统，保持彼此的独立性，以获得最大的灵活性。然而，在复杂的现实世界中，插件间的依赖是不可避免的。</p><h3 id="插件依赖">插件依赖</h3><blockquote><p>Under what situations is it OK for plug-in components to be dependent on other plug-in components?</p><p>在什么情况下，插件组件之间可以相互依赖？</p></blockquote><p>允许插件间依赖的<strong>合理情况</strong>是：当一个插件的功能是另一个插件功能的<strong>逻辑扩展或前提</strong>时。</p><blockquote><p>例如：一个 <code>PDF 导出</code> 插件，可能需要依赖一个通用的 <code>报表生成</code> 插件。<code>PDF 导出</code> 插件负责将 <code>报表生成</code> 插件产生的数据模型渲染成 PDF 文件。</p></blockquote><h3 id="插件管理">插件管理</h3><blockquote><p>What are some of the tools and frameworks that can be used to manage plug-ins?</p><p>有哪些工具和框架可用于管理插件？</p></blockquote><p>管理插件的复杂性催生了许多优秀的框架和标准：</p><ol><li><strong>OSGi (Open Service Gateway initiative)</strong>：这是 Java 平台中最著名、最强大的插件化框架。它提供了一整套完善的模块层（Bundle）和生命周期管理机制，是构建大型、复杂微核系统的首选。Eclipse IDE 就是基于 OSGi 构建的。</li><li><strong>Eclipse Rich Client Platform (RCP)</strong>：基于 OSGi，专门用于构建桌面富客户端应用的框架，其本身就是一个微核。</li><li><strong>Java Platform Module System (JPMS)</strong>：从 Java 9 开始引入的官方模块化系统，也可以作为实现插件化的基础。</li><li><strong>Java ServiceLoader</strong>：Java 内置的一个简单的服务发现机制，适用于较轻量级的插件化场景。</li><li><strong>其他生态</strong>：在 .NET 中有 MEF (Managed Extensibility Framework)；在 Web 应用中，可以通过 Webhooks 机制实现一种分布式的插件化思想，允许第三方服务作为“插件”来响应核心系统的事件。</li></ol><h3 id="插件适配">插件适配</h3><blockquote><p>What would you do if you had a third-party plug-in that didn’t conform to the standard plug-in contract in the core system?</p><p>如果一个第三方插件不遵循核心系统的标准插件契约，你会怎么做？</p></blockquote><p>如果一个第三方插件不遵循核心系统的标准插件契约，最佳解决方案是引入<strong>适配器模式 (Adapter Pattern)</strong>。</p><p>具体做法是：</p><ul><li><p>创建一个新的、我们自己控制的<strong>适配器插件 (Adapter Plug-in)</strong>，这个适配器插件<strong>遵循</strong>我们核心系统的标准契约。</p></li><li><p>在适配器插件的内部，它负责将核心系统发来的请求<strong>翻译</strong>成第三方插件能够理解的格式，并调用第三方插件。</p></li><li><p>反之，它也负责将第三方插件的返回结果<strong>翻译</strong>回核心系统期望的格式。</p></li></ul><h2 id="分区风格">分区风格</h2><blockquote><p>Is the microkernel architecture style technically partitioned or domain partitioned?</p><p>微核架构是技术分区还是领域分区？</p></blockquote><p>微核架构是一种<strong>混合分区 (Hybrid Partitioning)</strong> 的风格，这也是它独特的地方。</p><ul><li><strong>核心系统本身</strong>通常是<strong>技术分区</strong>的。它关注的是底层、通用的技术能力，如插件生命周期管理、安全、通信等，而不涉及具体的业务领域。</li><li><strong>插件组件</strong>则通常是<strong>领域分区</strong>的。每一个插件都封装了一个特定的业务功能或领域（例如 <code>税务计算插件</code>、<code>保单审批插件</code>、<code>Git 版本控制插件</code>）。</li></ul><p>这种混合模式使得系统既有坚实的技术底座，又能灵活地按业务领域进行扩展。</p><h2 id="架构量子">架构量子</h2><blockquote><p>Why is the microkernel architecture always a single architecture quantum?</p><p>为什么微核架构总是单一的架构量子？</p></blockquote><p>首先，我们需要定义<strong>架构量子 (Architecture Quantum)</strong>：一个高功能内聚、可独立部署的组件，它包含了所有使其能够正常工作所需的元素（包括数据）。</p><p>微核架构在其经典实现中之所以是单一架构量子，是因为它在两个主要维度上表现出强烈的内聚和耦合：</p><ul><li><strong>在运行时维度上</strong>：组件共享同一个进程和内存空间，通过进程内调用紧密耦合，形成了一个&quot;共同命运共同体&quot;，缺乏独立的容错能力。</li><li><strong>在数据维度上</strong>：组件通常共享同一个物理数据库实例和事务上下文，导致在数据管理和演化上紧密耦合。</li></ul><h2 id="同构性">同构性</h2><blockquote><p>What is domain/architecture isomorphism?</p><p>什么是领域/架构同构性？</p></blockquote><p><strong>同构性 (Isomorphism)</strong> 是一个源于数学的概念，意为&quot;结构上的相似性&quot;或&quot;一对一的映射关系&quot;。</p><p><strong>领域/架构同构性 (Domain/Architecture Isomorphism)</strong> 指的是<strong>软件的架构结构与它所要解决的问题领域（业务领域）的结构高度一致</strong>。一个具备良好同构性的架构，其模块划分、组件关系能够清晰地反映出业务领域的划分和业务流程。</p><p>微核架构是展现领域/架构同构性的一个绝佳范例。</p><ul><li><strong>问题领域</strong>可以被分解为一个&quot;通用基础平台&quot;和多个&quot;特定业务功能&quot;。</li><li><strong>微核架构</strong>恰好与之对应：<strong>核心系统</strong>映射了’'通用基础平台&quot;，而每一个<strong>插件</strong>则精确地映射了一个&quot;特定业务功能&quot;。</li></ul><p>这种一一对应的关系使得系统非常容易被业务人员和开发人员共同理解，需求变更也能快速定位到需要修改的插件，极大地提升了系统的可维护性和演化能力。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十二章的课后思考题，深入探讨微核架构中插件组件间依赖关系的设计原则、插件管理工具与框架的选择策略、第三方插件契约兼容性处理方案，以及微核架构的分区特性、架构量子特征和领域同构性概念分析，帮助理解微核架构的核心设计模式和扩展机制，提升架构师在构建可扩展系统时的架构选择能力和插件化设计水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨11丨管道架构</title>
    <link href="https://hedon.top/2025/07/15/fosa/fosa-ch11/"/>
    <id>https://hedon.top/2025/07/15/fosa/fosa-ch11/</id>
    <published>2025-07-15T02:20:00.000Z</published>
    <updated>2025-07-27T04:29:14.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十一章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>Can pipes be bidirectional in a pipeline architecture?</p><p>在管道架构中管道可以是双向的吗？</p></li><li><p>Name the four types of filters and their purpose.</p><p>说出 4 种类型的过滤器及它们的作用。</p></li><li><p>Can a filter send data out through multiple pipes?</p><p>一个过滤器能否通过多条管道将数据发送出去？</p></li><li><p>Is the pipeline architecture style technically partitioned or domain partitioned?</p><p>管道架构是技术分区还是领域分区？</p></li><li><p>In what way does the pipeline architecture support modularity?</p><p>管道架构是如何支持模块化的呢？</p></li><li><p>Provide two examples of the pipeline architecture style.</p><p>举 2 个管道架构的例子。</p></li></ol><hr><h2 id="拓扑">拓扑</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250715105907327.png" alt="FOSA Figure 11-2. Pipeline architecture example"></p><p>管道架构，又称为管道与过滤器架构（Pipes and Filters Architecture），是一种用于处理数据流的强大模式。它的核心思想非常直观，就像一条工厂的流水线：原材料从一端进入，经过一系列独立工站的加工、处理、检验，最终在另一端形成成品。</p><p>要理解管道架构，首先要理解它的两个基本构件：</p><ul><li><strong>过滤器 (Filter)</strong>：它是一个独立的、可执行的处理单元，负责接收数据、执行单一任务（例如转换格式、过滤内容、扩充信息），然后将处理后的数据传递出去。关键在于，每个过滤器都是**自包含（Self-Contained）<strong>和</strong>无状态（Stateless）**的，它不关心上一个过滤器是谁，也不关心下一个过滤器是谁。</li><li><strong>管道 (Pipe)</strong>：代表流水线上的&quot;传送带&quot;。它是一个<strong>单向</strong>的数据通道，负责将一个过滤器处理完的数据传递给下一个过滤器。</li></ul><p>在管道架构中，每个<strong>过滤器</strong>通常代表一个具体的技术操作，而不是一个完整的业务领域。整个管道将这些技术步骤串联起来，以完成一个业务流程，但其划分的单元（过滤器）是技术性的。</p><h2 id="管道">管道</h2><p>管道的**单向性（Unidirectional）**是该架构风格的基石。原因在于：</p><ol><li><strong>维持简单性与解耦</strong>：单向流动保证了数据处理的顺序性和可预测性。每个过滤器只需关注自己的输入和输出，无需处理复杂的双向通信或回调逻辑。</li><li><strong>避免状态依赖</strong>：如果管道是双向的，就意味着过滤器之间可能存在请求-响应（Request-Response）式的交互。这会引入状态和时间上的耦合，破坏了过滤器作为独立、无状态组件的核心原则。一个需要双向通信的场景，更适合采用其他架构风格（如客户端-服务器模式），而非管道架构。</li></ol><p>因此，严格意义上的管道架构，其管道必须是单向的。同时，管道也可以支持强大的分支（Forking）和扇出（Fan-out）能力，一个过滤器可以根据处理结果，将数据发送到不同的下游管道，这个过程依旧保持了其单向性。</p><h2 id="过滤器">过滤器</h2><ul><li><p><strong>生产者 (Producer / Source)</strong>：作为整条管道的<strong>起点</strong>。它不接收来自管道的数据，而是负责创建数据，并将这些初始数据泵入管道。</p></li><li><p><strong>转换器 (Transformer)</strong>：它从上游管道接收数据，对其进行某种形式的<strong>修改或转换</strong>，然后将结果发送到下游管道。</p></li><li><p><strong>测试器 (Tester)</strong>：它接收数据，并根据一个或多个条件对数据进行<strong>检验</strong>。如果数据满足条件，就将其传递到下游管道；如果不满足，则数据流在此处被中断（或被导向另一条错误处理管道）。</p></li><li><p><strong>消费者 (Consumer / Sink)</strong>：作为整条管道的<strong>终点</strong>。它从上游管道接收最终处理好的数据，并将其消费掉，通常不会再将数据传递出去。</p></li></ul><h2 id="模块化">模块化</h2><ul><li><strong>高内聚、低耦合（High Cohesion, Low Coupling）</strong>：每个过滤器都是一个高内聚的模块，只专注于完成一件定义明确的任务。同时，过滤器之间通过管道这一标准接口进行通信，实现了极低的耦合，它们互相不知道对方的存在。</li><li><strong>可组合性（Composability）</strong>：过滤器就像乐高积木。我们可以通过不同的排列组合，快速地搭建出全新的数据处理流程，而无需修改过滤器本身的代码。</li><li><strong>可复用性（Reusability）</strong>：一个通用的过滤器（例如 <code>GzipCompressor</code>）可以被用在任何需要数据压缩的管道中，实现了代码的高度复用。</li><li><strong>可替换性（Replaceability）</strong>：只要遵守管道中的数据格式约定，我们可以轻易地用一个性能更好的新过滤器来替换掉一个旧的过滤器，而不会影响到管道的其他部分。</li></ul><h2 id="例子">例子</h2><h3 id="1-UNIX-Linux-命令行">1. UNIX/Linux 命令行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | grep &quot;ERROR&quot; | sort | uniq -c</span><br></pre></td></tr></table></figure><ul><li><code>cat access.log</code>：生产者，读取日志文件并产生数据流。</li><li><code>|</code>：管道，将标准输出连接到下一个命令的标准输入。</li><li><code>grep &quot;ERROR&quot;</code>：测试器/转换器，过滤出包含 “ERROR” 的行。</li><li><code>sort</code>：转换器，对错误日志进行排序。</li><li><code>uniq -c</code>：转换器/消费者，统计重复行并输出最终结果。</li></ul><h3 id="2-ELT-Extract-Transform-Load-流程">2. ELT(Extract, Transform, Load) 流程</h3><ul><li><strong>Extract（抽取）</strong>：生产者过滤器，从各种源系统（如业务数据库、日志文件、API）中读取原始数据。</li><li><strong>Transform（转换）</strong>：一系列转换器和测试器过滤器，对数据进行清洗（去除无效值）、转换（统一格式）、扩充（关联其他数据）、聚合（计算统计值）等操作。</li><li><strong>Load（加载）</strong>：消费者过滤器，将最终处理好的、高质量的数据加载到目标数据仓库或数据湖中，供后续分析使用。</li></ul>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十一章的课后思考题，深入探讨管道架构中管道双向性的可能性与限制、过滤器类型的分类与作用机制、数据流向的设计原则，以及管道架构的分区特性、模块化支持方式和典型应用场景分析，帮助理解管道与过滤器架构的核心概念和设计模式，提升架构师在处理数据流应用时的架构选择能力和系统设计水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨10丨分层架构</title>
    <link href="https://hedon.top/2025/07/14/fosa/fosa-ch10/"/>
    <id>https://hedon.top/2025/07/14/fosa/fosa-ch10/</id>
    <published>2025-07-14T02:20:00.000Z</published>
    <updated>2025-07-27T04:29:14.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>What is the difference between an open layer and a closed layer?</p><p>开放层和封闭层有何区别？</p></li><li><p>Describe the layers of isolation concept and what the benefits are of this concept.</p><p>隔离层概念及其益处是什么？</p></li><li><p>What is the architecture sinkhole anti-pattern?</p><p>架构漏斗反模式是什么？</p></li><li><p>What are some of the main architecture characteristics that would drive you to use a layered architecture?</p><p>驱动采用分层架构风格的主要架构特性有哪些？</p></li><li><p>Why isn’t testability well supported in the layered architecture style?</p><p>分层架构风格的可测试性为何不佳？</p></li><li><p>Why isn’t agility well supported in the layered architecture style?</p><p>分层架构风格的敏捷性为何不佳？</p></li></ol><hr><h2 id="概念">概念</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250714113807168.png" alt="FOSA Figure 10-2. Physical topology (deployment) variants"></p><p>分层架构的<strong>核心驱动力</strong>是<strong>关注点分离（Separation of Concerns）</strong>。它将一个复杂的系统按照不同的职责或技术关注点，垂直地划分成若干个水平的“层（Layer）”。</p><p>每一层都有明确的职责：</p><ul><li><strong>表现层（Presentation Layer）</strong>：负责处理用户界面和交互，例如 Web 页面或 API 端点。</li><li><strong>业务逻辑层（Business Logic Layer）</strong>：实现核心的业务规则和流程，是应用的心脏。</li><li><strong>持久化层（Persistence Layer）</strong>：负责数据的存储和检索，与数据库交互。</li><li><strong>数据库层（Database Layer）</strong>：即实际的数据库系统。</li></ul><p>这些层之间存在一个至关重要的约束：<strong>依赖关系是单向的</strong>。通常来说，上层可以依赖下层，但下层绝对不能依赖上层。例如，表现层可以调用业务逻辑层，但业务逻辑层不应该知道任何关于表现层的具体实现细节。</p><h2 id="封闭层-vs-开放层">封闭层 vs 开放层</h2><p><strong>封闭层（Closed Layer）</strong>：当一个请求从上层向下层传递时，它<strong>必须</strong>逐层通过。</p><ul><li><strong>优点</strong>：提供了最高程度的<strong>隔离</strong>。由于每一层都只与它的邻居交流，下层实现细节的变更对上上层的影响被完全隔离。这正是&quot;隔离层&quot;概念的基础。</li><li><strong>缺点</strong>：可能会引入不必要的冗余代码和性能开销。</li></ul><p><strong>开放层（Open Layer）</strong>：这是一种更为灵活的模式，允许上层&quot;跳过&quot;一个或多个中间层，直接访问更下方的层。</p><ul><li><strong>优点</strong>：当中间层对于某个特定请求没有任何业务逻辑需要添加时，开放该层可以避免编写无意义的传递（pass-through）代码，从而提高开发效率和运行效率。</li><li><strong>缺点</strong>：破坏了层与层之间的强隔离性。如果滥用开放层，会导致层级关系混乱，上层与多个下层产生耦合，削弱分层架构带来的可维护性优势。</li></ul><h2 id="隔离">隔离</h2><h3 id="概念及好处">概念及好处</h3><p>隔离指的是<strong>一个层中的变更，应该被隔离在这一层以及与之直接相邻的层中，而不会向上&quot;泄漏&quot;到更远的层</strong>。</p><p>想象一下，如果我们决定将数据库从 MySQL 迁移到 PostgreSQL。这个变化发生在最底层的数据库层和持久化层。</p><ul><li><strong>理想情况（强隔离）</strong>：由于业务逻辑层只依赖于持久化层定义的接口（例如 <code>UserRepository</code>），而不知道其背后是 MySQL 还是 PostgreSQL，因此业务逻辑层代码<strong>完全不需要修改</strong>。表现层就更不受影响了。变更被成功&quot;隔离&quot;在了持久化层内部。</li><li><strong>隔离被破坏的情况</strong>：如果持久化层的某些特定实现细节（例如特定的 SQL 方言）泄漏到了业务逻辑层，那么在迁移数据库时，业务逻辑层也必须跟着修改。这就是隔离性的失败。</li></ul><p>这样做的好处有：</p><ul><li>极高的可维护性</li><li>技术栈的独立性</li><li>系统的可理解性</li></ul><h3 id="潜在的陷阱：架构漏斗反模式">潜在的陷阱：架构漏斗反模式</h3><p><strong>架构漏斗反模式</strong>描述了这样一种情况：一个请求在流经多个封闭层时，其中一些中间层<strong>没有执行任何有意义的逻辑</strong>，仅仅是将请求原封不动地传递给下一层。这些&quot;只传话、不干活&quot;的层就成为了架构的&quot;漏斗&quot;或&quot;沉洞&quot;，增加了不必要的复杂度和代码量。</p><blockquote><p>可以使用二八原则，允许 20% 的 sinkhole，如果过多的 sinkhole，则说明分层架构很可能不适用于当前的业务场景。</p></blockquote><h2 id="优点">优点</h2><ol><li><strong>简单性（Simplicity）和低成本（Cost）</strong>：分层架构模式非常成熟，广为人知，开发团队的学习成本极低。对于中小型项目、预算有限的初创公司或内部管理系统，它是一个&quot;足够好&quot;的、性价比极高的起点。</li><li><strong>可维护性（Maintainability）</strong>：如前所述，只要遵循了隔离层原则，系统的维护和迭代会非常清晰。对于那些业务逻辑相对稳定、变更不频繁的系统，这是一个巨大的优势。</li><li><strong>整体可部署性（Deployability）</strong>：分层架构天然倾向于构建<strong>单体应用（Monolith）</strong>。整个应用被打包成一个单元（例如一个 WAR 包或一个可执行文件）进行部署。这极大地简化了部署和运维的复杂度，尤其是在项目早期或运维能力有限的团队中。</li></ol><h2 id="缺点">缺点</h2><ul><li><strong>技术分区而非领域分区</strong>：分层架构是一种技术分区架构。这意味着它的组件是根据其在架构中的技术角色（如表示层、业务层、持久层），而不是根据业务领域（如客户、订单）进行分组的。这会导致任何特定的业务领域（例如“客户”领域）的逻辑都会分散在架构的所有层中。同时，当需要对特定业务领域的需求进行更改时，由于其逻辑分散在多个技术层中，开发人员必须在所有相关层中进行修改，这降低了开发的敏捷性。</li><li><strong>部署风险高</strong>：在分层架构中，即使是对少量代码的更改（例如，一个类文件中简单的三行更改），也需要重新部署整个部署单元。这种部署往往会捆绑数十个其他更改，从而显著增加了部署风险，且部署频率受到限制。</li><li><strong>测试范围大且不完整</strong>：由于整个应用程序是作为一个大型单体单元部署的，开发人员通常不会为简单的三行更改花费数小时执行完整的回归测试套件。这导致测试覆盖范围不完整，并且难以确保更改不会影响看似不相关的部分。</li></ul>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十章的课后思考题，深入探讨分层架构中开放层与封闭层的核心差异、隔离层概念的重要价值、架构漏斗反模式的识别与防范，以及分层架构风格的主要驱动特性与局限性分析，帮助理解分层架构的设计原则和适用场景，提升架构师在选择和实施分层架构时的决策能力和风险评估意识。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨09丨架构风格基础</title>
    <link href="https://hedon.top/2025/07/10/fosa/fosa-ch9/"/>
    <id>https://hedon.top/2025/07/10/fosa/fosa-ch9/</id>
    <published>2025-07-10T02:20:00.000Z</published>
    <updated>2025-07-27T04:29:14.329Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第九章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>List the eight fallacies of distributed computing.</p><p>列举分布式计算中的 8 个谬论。</p></li><li><p>Name three challenges that distributed architectures have that monolithic architectures don’t.</p><p>说出 3 个单体架构没有而分布式架构有的挑战。</p></li><li><p>What is stamp coupling?</p><p>什么是邮票耦合？</p></li><li><p>What are some ways of addressing stamp coupling?</p><p>邮票耦合有哪些解决方案？</p></li></ol><hr><h2 id="分布式八谬论">分布式八谬论</h2><p><strong>1. 网络是可靠的 (The network is reliable)。</strong></p><ul><li><strong>谬论</strong>：开发者常常假设网络连接永远不会中断，数据总能成功从 A 点传输到 B 点。</li><li><strong>现实</strong>：网络硬件可能发生故障、交换机可能崩溃、路由器可能过载、网线可能被拔掉。任何网络调用都有可能失败，数据包可能会丢失、损坏或重复。因此，必须在设计中考虑网络中断的可能性，并加入重试机制 (retry mechanisms)、超时 (timeouts)、熔断器 (circuit breakers) 等容错策略。</li></ul><p><strong>2. 延迟为零 (Latency is zero)。</strong></p><ul><li><strong>谬论</strong>：开发者假设通过网络发送请求和接收响应是瞬时完成的，就像本地方法调用一样。</li><li><strong>现实</strong>：数据在网络上传输需要时间，这个时间被称为延迟 (latency)。即使在光速的限制下，物理距离也会导致不可避免的延迟。网络拥堵、数据包的路由跳转等因素都会增加延迟。在设计分布式系统时，必须意识到延迟的存在，并尽可能地减少网络往返次数，例如通过批处理请求或使用异步通信模式。</li></ul><p><strong>3. 带宽是无限的 (Bandwidth is infinite)。</strong></p><ul><li><strong>谬论</strong>：开发者认为网络的传输能力是无限的，可以随心所欲地发送大量数据。</li><li><strong>现实</strong>：每个网络连接都有其最大吞吐量，即带宽 (bandwidth) 限制。过度发送数据会导致网络拥塞，增加延迟，甚至导致数据包丢失。架构师需要关注数据传输的效率，对数据进行压缩，避免在网络上传输不必要的“重量级”数据对象。</li></ul><p><strong>4. 网络是安全的 (The network is secure)。</strong></p><ul><li><strong>谬论</strong>：开发者假设内部网络是安全的，传输的数据不会被窃听或篡改。</li><li><strong>现实</strong>：任何网络连接都有可能受到攻击。数据在传输过程中可能被中间人 (man-in-the-middle) 截获、窃听或修改。因此，必须采取加密措施（如 TLS/SSL）来保护传输中的数据，并使用认证 (authentication) 和授权 (authorization) 机制来确保只有合法的服务和用户才能访问资源。</li></ul><p><strong>5. 拓扑结构不会改变 (Topology doesn’t change)。</strong></p><ul><li><strong>谬论</strong>：开发者假设网络的布局、服务器的地址和服务的部署位置是固定不变的。</li><li><strong>现实</strong>：在现代的云原生和微服务环境中，网络拓扑是动态变化的。服务器可能会宕机，新的服务实例可能会被启动，服务可能会被迁移到不同的物理位置或 IP 地址。依赖硬编码的 IP 地址和端口是极其脆弱的。应该使用服务发现 (service discovery) 机制来动态地查找和连接服务。</li></ul><p><strong>6. 只有一个管理员 (There is one administrator)。</strong></p><ul><li><strong>谬论</strong>：开发者认为整个分布式系统由一个全知全能的管理员或团队来维护，他们了解并控制系统的所有部分。</li><li><strong>现实</strong>：一个大型的分布式系统通常由多个团队共同开发和维护，每个团队只负责其中的一部分。不同团队、不同系统之间可能存在策略、配置和维护窗口的冲突。此外，系统还可能依赖由第三方管理的外部服务。因此，必须通过标准化的监控、日志记录和告警来获得对整个系统的可见性。</li></ul><p><strong>7. 传输成本为零 (Transport cost is zero)。</strong></p><ul><li><strong>谬论</strong>：开发者认为进行网络通信本身是不需要成本的。</li><li><strong>现实</strong>：这里所说的“成本”不仅指金钱。它包括了运行网络硬件所需的 CPU 周期、内存，以及将数据序列化 (serialization) 和反序列化 (deserialization) 所需的计算资源。在云环境中，网络流量本身通常也是直接收费的。因此，在设计 API 和数据格式时，需要考虑其对性能和运营成本的综合影响。</li></ul><p><strong>8. 网络是同质的 (The network is homogeneous)。</strong></p><ul><li><strong>谬论</strong>：开发者假设网络中的所有设备都来自同一个供应商，使用相同的协议栈，并且性能表现一致。</li><li><strong>现实</strong>：一个复杂的网络通常由来自不同供应商的硬件（路由器、交换机、防火墙）和运行着不同操作系统（Linux, Windows）的服务器组成。这些异构组件的组合可能导致意想不到的兼容性问题和性能瓶颈。在设计系统时，应依赖于广泛支持的标准化协议，并对系统的端到端性能进行充分测试。</li></ul><h2 id="分布式系统挑战">分布式系统挑战</h2><p><strong>1. 服务间通信的复杂性 (Inter-service Communication Complexity)</strong></p><ul><li><strong>在单体架构中</strong>：不同模块或组件之间的调用是进程内的函数调用 (in-process function calls)。这种调用非常快速、可靠，并且事务性可以通过语言层面的机制轻松保证。</li><li><strong>在分布式架构中</strong>：服务间的调用变成了跨网络的远程过程调用 (RPC)。这立刻引入了前述“分布式计算的 8 个谬论”中的所有问题：网络可能失败，存在延迟，带宽有限，需要考虑安全等。开发者必须处理部分失败 (partial failure) 的情况——即一个服务可用，而它依赖的另一个服务却不可用。这就需要引入重试、超时、熔断、服务发现等复杂的模式来保证系统的韧性 (resilience)。</li></ul><p><strong>2. 分布式事务与数据一致性 (Distributed Transactions and Data Consistency)</strong></p><ul><li><strong>在单体架构中</strong>：通常使用单一的数据库，可以依赖数据库本身提供的 ACID（原子性、一致性、隔离性、持久性）事务来保证跨多个数据表的强一致性。操作要么全部成功，要么全部失败，状态不会处于中间状态。</li><li><strong>在分布式架构中</strong>：每个服务通常拥有自己独立的数据库，以实现松耦合和独立部署。当一个业务流程需要跨越多个服务时，就无法使用传统的单数据库事务。这就带来了分布式事务的挑战。实现强一致性的两阶段提交 (Two-Phase Commit, 2PC) 等协议通常非常复杂且性能低下。因此，架构师往往不得不放弃强一致性，转而寻求最终一致性 (eventual consistency)，并采用 Saga 模式、事件溯源 (Event Sourcing) 等更复杂的模式来管理跨服务的数据一致性，这极大地增加了开发的难度和心智负担。</li></ul><p><strong>3. 运维和监控的复杂性 (Operational and Observability Complexity)</strong></p><ul><li><p><strong>在单体架构中</strong>：整个应用被部署为一个单元。日志集中在一个地方，调试相对直接（例如，通过附加调试器），监控也相对简单，只需关注单个进程和服务器的 CPU、内存等指标。</p></li><li><p><strong>在分布式架构中</strong>：一个请求可能会流经数十个甚至上百个服务。要诊断一个问题，你需要追踪这个请求在整个系统中的调用链。这就需要建立复杂的“可观测性” (Observability) 体系，包括：</p><ul><li><p><strong>集中式日志 (Centralized Logging)</strong>：将所有服务的日志聚合到一起进行分析。</p></li><li><p><strong>分布式追踪 (Distributed Tracing)</strong>：为每个请求分配一个唯一的 ID，并在整个调用链中传递，以便追踪其路径和耗时。</p></li><li><p><strong>聚合指标 (Metrics Aggregation)</strong>：从各个服务收集关键性能指标（如请求率、错误率、延迟）并进行聚合展示。</p><p>部署、扩缩容、故障排查的难度都呈指数级增长。</p></li></ul></li></ul><h2 id="邮票耦合">邮票耦合</h2><p><strong>邮票耦合 (Stamp Coupling)</strong> 是一种特定类型的<strong>数据耦合 (Data Coupling)</strong>。当一个模块（或服务）向另一个模块传递一个复杂的数据结构（如一个对象或记录），但接收方模块实际上只需要该数据结构中的一小部分字段时，就发生了邮票耦合。</p><p>这个名字的比喻来源于：</p><blockquote><p>你只是想寄一封信，却把整个邮局（包含了所有信件和包裹）都递给了邮递员。接收方不得不从这个庞大的结构中&quot;筛选&quot;出自己需要的信息。</p></blockquote><p>核心特征：</p><ul><li><strong>传递了超量信息</strong>：调用者传递了比被调用者实际需要的多得多的数据。</li><li><strong>不必要的依赖</strong>：被调用者被迫依赖于一个它并不完全需要的数据结构的具体定义。</li></ul><p>解决邮票耦合的核心思想是将数据契约 (data contract) 的关注点从&quot;<strong>提供方有什么</strong>&quot;转变为&quot;<strong>消费方要什么</strong>&quot;。</p><ul><li><strong>创建私有的 RESTful API 端点</strong>：为特定的内部消费者（服务）创建专门的、不对外公开的 API 端点 (endpoint)。这些端点被设计为只返回该消费者完成其特定任务所必需的数据子集。</li><li><strong>在契约中使用字段选择器</strong>：允许 API 的调用方通过查询参数 (query parameter) 来动态指定响应中应包含哪些字段。</li><li><strong>使用 GraphQL 来解耦契约</strong>：GraphQL 从根本上就是为了解决 REST API 中常见的数据过度获取 (over-fetching) 和数据获取不足 (under-fetching) 问题而设计的，而过度获取正是邮票耦合的表现形式。</li><li><strong>使用价值驱动契约与消费者驱动契约</strong>：消费者驱动契约 (CDC) 是一种模式，其中 API 的消费者编写一份&quot;契约&quot;，明确声明它对提供者的期望（需要哪些字段、什么样的数据格式）。这份契约被用作自动化测试的一部分。</li><li><strong>使用内部消息端点</strong>：在消息系统中，不发布一个包含完整实体状态的&quot;大而全&quot;的事件，而是发布更细粒度、更具业务意图的事件。</li></ul><p>总而言之，这五种方案都体现了从 Push 模型向 Pull 模型的转变，是解决分布式系统中耦合问题的关键实践。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第九章的课后思考题，深入探讨分布式计算的八大谬论及其对架构设计的影响、分布式架构相比单体架构面临的独特挑战、邮票耦合问题的本质与危害，以及解决邮票耦合的有效策略与最佳实践，帮助理解分布式系统设计的核心原则和常见陷阱，提升架构师在分布式环境下的决策能力和风险识别意识。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨08丨组件思维</title>
    <link href="https://hedon.top/2025/07/09/fosa/fosa-ch8/"/>
    <id>https://hedon.top/2025/07/09/fosa/fosa-ch8/</id>
    <published>2025-07-09T02:20:00.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第八章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>We define the term <em>component</em> as a building block of an application—something the application does. A component usually consist of a group of classes or source files. How are components typically manifested within an application or service?</p><p>组件在应用程序或服务中通常如何体现？</p></li><li><p>What is the difference between technical partitioning and domain partitioning? Provide an example of each.</p><p>技术分区和领域分区有什么区别？请各举一个例子。</p></li><li><p>What is the advantage of domain partitioning?</p><p>领域分区的优点是什么？</p></li><li><p>Under what circumstances would technical partitioning be a better choice over domain partitioning?</p><p>在什么情况下，技术分区会是比领域分区更好的选择？</p></li><li><p>What is the entity trap? Why is it not a good approach for component identification?</p><p>&quot;实体陷阱&quot;是什么？为什么它不是一种好的组件识别方法？</p></li><li><p>When might you choose the workflow approach over the Actor/Actions approach when identifying core components?</p><p>在识别核心组件时，你何时会选择 workflow 方法而不是 actor/actions 方法？</p></li></ol><hr><h2 id="组件范围">组件范围</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250709102652672.png" alt="FOSA Figure 8-1. Different varieties of components"></p><p>在软件架构中，组件被定义为模块的物理体现。它代表了相关代码的逻辑分组，并通过不同的方式进行物理打包。</p><p>组件在应用程序或服务中的典型体现方式包括：</p><ul><li><strong>库文件</strong>：这是最简单的组件形式，它将代码包装成更高层次的模块，通常在与调用代码相同的内存地址空间中运行，并通过语言函数调用机制进行通信。例如，Java 中的 JAR 文件、.NET 中的 DLL 文件和 Ruby 中的 Gem 文件。</li><li><strong>子系统或层</strong>：组件也可以作为架构中的子系统或层来出现。</li><li><strong>服务</strong>：特别是在微服务等架构风格中，服务是一种组件，它在自己的地址空间中运行，并通过低级网络协议（如 TCP/IP）或高级格式（如 REST 或消息队列）进行通信，形成独立的、可部署的单元。</li><li><strong>逻辑边界</strong>：从领域驱动设计（DDD）的角度来看，有界上下文（Bounded Contexts）物理组件，例如服务、子系统等。每个有界上下文应作为一个独立的服务或项目来实现，这意味着它可以独立于其他有界上下文进行实现、演进和版本控制。有时一个有界上下文可以包含多个子域，此时有界上下文是物理边界，而其每个子域是逻辑边界，这些逻辑边界在不同编程语言中可能被称为命名空间、模块或包。</li></ul><p>总之，组件是架构中最基本的模块化构建块，它们定义了代码的组织方式以及系统各部分之间的交互方式。</p><h2 id="架构分区">架构分区</h2><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250709102924588.png" alt="FOSA Figure 8-4. Two types of top-level partitioning in architecture"></p><h3 id="技术分区">技术分区</h3><p><strong>技术分区 (Technical Partitioning):</strong> 是 <strong>根据代码的技术职责</strong> 来组织代码。这是传统分层架构的典型做法。每一层都有明确的技术目标，例如处理 HTTP 请求、执行业务规则或与数据库交互。</p><p>典型分层:</p><ul><li><strong>表现层 (Presentation/UI):</strong> 负责处理用户交互和展示，例如 MVC 框架中的 <code>Controller</code> 和 <code>View</code>。</li><li><strong>业务逻辑层 (Business/Service):</strong> 负责实现核心业务规则和流程，是系统的核心。</li><li><strong>数据访问层 (Data Access/Persistence):</strong> 负责与数据库或其他数据存储进行交互，执行增删改查 (CRUD)。</li></ul><p>优点：</p><ul><li>简单直观，上手快</li><li>清晰的技术关注点分离</li><li>促进技术层面的代码复用</li></ul><p>缺点：</p><ul><li><strong>业务内聚性极低 (Low Business Cohesion):</strong> 这是技术分区最大的问题。一个完整的业务功能（例如，“用户下单”）的逻辑被强制拆散，散落在所有三个层次中。当你需要理解或修改这个功能时，必须在多个目录和文件中来回跳转，增加了认知负荷。</li><li><strong>功能开发导致高耦合 (High Coupling for Feature Development):</strong> 由于功能代码被分散，任何一个业务需求的变更，都可能导致从上到下的“全垒打”式修改（即 <code>Controller</code> -&gt; <code>Service</code> -&gt; <code>Repository</code> 都需要改）。这使得变更的影响范围变大，回归测试的成本也更高。</li><li><strong>容易形成“上帝类”和瓶颈 (Prone to “God Classes” and Bottlenecks):</strong> 随着业务越来越复杂，业务逻辑层 (<code>Business Layer</code>) 很容易膨胀成一个巨大而臃肿的“上帝模块”，它了解所有业务细节，被所有表现层组件依赖。这个模块会变得难以维护和测试，成为整个系统演进的瓶颈。</li><li><strong>阻碍团队自治和独立扩展 (Impedes Team Autonomy and Scalability):</strong> 很难将一个完整的业务功能垂直地分配给一个团队。两个团队开发不同功能时，很可能会在共享的业务逻辑层或数据访问层产生代码冲突。在分布式架构中，你也无法仅仅因为订单逻辑复杂就单独扩展业务逻辑层，而必须扩展整个单体应用。</li></ul><p>适用场景：</p><ul><li><strong>小型、简单的应用程序：</strong> 尤其是 CRUD 密集型的管理后台、内容管理系统等。</li><li><strong>业务领域稳定且不复杂：</strong> 如果业务在可预见的未来不会有大的变化，技术分区的简单性就是一种优势。</li><li><strong>项目初期或概念验证 (PoC):</strong> 当业务边界尚不明确，需要快速验证想法时，可以从技术分区开始。</li><li><strong>按技术职能划分的团队：</strong> 如果你的公司有独立的前端团队、后端 Java 团队和 DBA 团队，这种分区方式能匹配组织结构。</li></ul><h3 id="领域分区">领域分区</h3><p><strong>领域分区 (Domain Partitioning):</strong> 是 <strong>根据业务领域或业务能力</strong> 来组织代码。每个组件都封装了某个特定业务领域所需的所有技术实现。这与领域驱动设计 (DDD) 的思想高度一致。</p><p>典型分区:</p><ul><li><strong>订单组件 (Ordering):</strong> 包含处理订单的所有逻辑，从 API 端点到数据库交互。</li><li><strong>库存组件 (Inventory):</strong> 负责管理商品库存。</li><li><strong>支付组件 (Payment):</strong> 封装与支付相关的所有功能。</li></ul><p>优点：</p><ul><li>业务内聚性极高</li><li>领域间的低耦合</li><li>支持团队自治和并行开发</li><li>易于独立扩展和部署</li><li>增强系统的演进能力</li></ul><p>缺点：</p><ul><li><strong>初期复杂度和设计门槛高 (Higher Initial Complexity):</strong> 正确地识别和划分领域边界是领域分区的核心挑战。这需要架构师对业务有深刻的理解，并投入大量的前期分析设计（例如通过领域驱动设计 DDD 中的事件风暴等实践）。如果边界划分错误，后期的重构成本会非常高。</li><li><strong>可能导致代码重复 (Potential for Code Duplication):</strong> 不同的领域组件可能需要相似的功能，例如身份验证、日志记录、数据访问模式等。如果缺乏良好的治理，这些横切关注点 (Cross-cutting Concerns) 可能会在多个组件中被重复实现。这通常需要通过共享库、平台服务或服务网格 (Service Mesh) 来解决。</li><li><strong>分布式架构的额外开销 (Overhead of Distributed Architecture):</strong> 如果将每个领域组件实现为微服务，就需要处理分布式系统带来的所有复杂性，如服务发现、网络延迟、数据一致性、分布式事务等。</li></ul><p>适用场景：</p><ul><li><strong>大型、复杂的企业级系统：</strong> 尤其是那些业务逻辑复杂、需要长期演进的系统。</li><li><strong>微服务架构 (Microservices Architecture):</strong> 领域分区是实现微服务的标准和基础。</li></ul><h2 id="组件识别">组件识别</h2><p>组件识别是指在定义了宏观的架构风格（例如，分层单体、微服务）之后，<strong>发现和划定系统中各个功能模块（即组件）边界的过程</strong>。这个过程的目标是创建一组高内聚、低耦合的组件。</p><p>组件识别不是一个随意的过程，它需要系统性的方法和深刻的业务理解。如果边界划分错误，将会导致维护困难、扩展不易等一系列问题。接下来我们将要讨论的几个概念，正是服务于这个目的的方法论和需要警惕的陷阱。</p><h3 id="实体陷阱">实体陷阱</h3><p>这是在组件识别过程中最常见、也最需要警惕的一个反模式 (Anti-pattern)。</p><p>实体陷阱是指 <strong>错误地将数据实体（通常直接对应数据库中的表）当作组件来进行划分</strong>。例如，系统中有 <code>User</code>, <code>Product</code>, <code>Order</code> 三张表，就草率地创建 <code>User</code> 组件、<code>Product</code> 组件和 <code>Order</code> 组件。</p><p>为什么是陷阱？</p><blockquote><p>软件的核心价值在于处理 <strong>业务流程 (Business Workflow)</strong>，而不仅仅是管理数据。一个有意义的业务流程往往会跨越多个数据实体。</p></blockquote><p>我们以经典的&quot;用户下单&quot;流程为例。这个行为需要：</p><ol><li>读取 <strong>用户信息</strong> (User) 以确认其身份和收货地址。</li><li>查询 <strong>商品信息</strong> (Product) 以获取价格并检查库存。</li><li>创建一个新的 <strong>订单记录</strong> (Order)。</li><li>更新 <strong>商品库存</strong> (Product)。</li></ol><p>如果 <code>User</code>、<code>Product</code>、<code>Order</code> 各自是一个独立的组件，那么&quot;用户下单&quot;这段核心业务逻辑应该放在哪里呢？</p><ul><li>放在 <code>Order</code> 组件里？那么它就需要频繁调用 <code>User</code> 组件和 <code>Product</code> 组件，并且可能需要了解它们的内部数据结构，形成了紧密的耦合。</li><li>放在一个单独的 <code>PlacingOrderService</code> 里？这个服务本身没有归属，像一个&quot;流浪&quot;的脚本，操纵着另外三个“只有数据没有行为”的贫血组件。</li></ul><p><strong>结论：</strong> 实体陷阱导致了 <strong>业务逻辑的碎片化</strong> 和 <strong>组件间的高度耦合</strong>。</p><blockquote><p>👉🏻 正确的做法是围绕 <strong>业务能力</strong> 来划分组件，而不是围绕数据实体。一个更合理的组件应该是 <code>Ordering</code> (订单管理)，它封装了 <code>Order</code> 实体以及所有相关的业务行为（如下单、取消订单、查询订单状态等）。</p></blockquote><h3 id="Actor-Actions">Actor/Actions</h3><p>这是一种非常直观且有效的自顶向下的组件识别方法。它的核心是回答：“<strong>谁 (Who) 会对系统做什么 (What)？</strong>”</p><p><strong>实施步骤：</strong></p><ol><li><strong>识别执行者 (Identify Actors):</strong> 列出所有会与系统交互的&quot;人&quot;或&quot;外部系统&quot;。例如：顾客 (Customer)、管理员 (Admin)、仓库管理系统 (WMS)、支付网关 (Payment Gateway)。</li><li><strong>识别操作 (Identify Actions):</strong> 针对每一个执行者，列出他们会对系统发起的具体操作（可以理解为用例）。<ul><li><strong>顾客</strong> 可以：搜索商品、查看商品详情、添加购物车、提交订单、支付。</li><li><strong>管理员</strong> 可以：上架商品、调整价格、查看销售报表。</li></ul></li><li><strong>组件划分：</strong> 将相关的操作进行分组，形成初步的组件。<ul><li><code>搜索商品</code>、<code>查看商品详情</code> -&gt; 可能属于 <code>Catalog</code> (商品目录) 组件。</li><li><code>添加购物车</code>、<code>提交订单</code> -&gt; 可能属于 <code>Ordering</code> (订单) 组件。</li><li><code>上架商品</code>、<code>调整价格</code> -&gt; 可能属于 <code>ProductManagement</code> (商品管理) 组件。</li></ul></li></ol><p><strong>优点：</strong></p><ul><li>简单直观，易于上手。</li><li>以用户为中心，能很好地识别出面向用户的核心功能。</li></ul><p><strong>缺点：</strong></p><ul><li>可能遗漏那些没有明确执行者的后台流程或系统内部流程。</li></ul><h3 id="Event-storming">Event storming</h3><p>事件风暴是领域驱动设计 (DDD) 中一种强大的 <strong>协作式工作坊技术</strong>，用于快速、全面地探索复杂的业务领域，并从中识别出聚合 (Aggregates) 和限界上下文 (Bounded Contexts)，而这些正是划分高质量组件（尤其是微服务）的理想边界。</p><p><strong>核心过程:</strong> 这是一个由业务专家和技术专家共同参与的会议，大家在一个足够大的墙上，用不同颜色的即时贴 (sticky notes) 来“风暴”出整个业务流程。</p><ol><li><strong>橙色贴 - 领域事件 (Domain Event):</strong><ul><li><strong>规则：</strong> 用过去时态描述业务中发生过的、有价值的事情。这是整个风暴的核心。</li><li><strong>例子：</strong> <code>订单已提交</code>、<code>商品已添加到购物车</code>、<code>用户已注册</code>。</li><li>大家将所有能想到的事件，按照时间顺序从左到右贴在墙上。</li></ul></li><li><strong>蓝色贴 - 命令 (Command):</strong><ul><li><strong>规则：</strong> 触发领域事件的用户操作或系统指令。</li><li><strong>例子：</strong> <code>提交订单</code> (触发 <code>订单已提交</code>)、<code>添加商品到购物车</code> (触发 <code>商品已添加到购物车</code>)。</li></ul></li><li><strong>黄色小贴 - 执行者 (Actor):</strong><ul><li><strong>规则：</strong> 发出命令的人或系统。</li><li><strong>例子：</strong> <code>顾客</code> (发出 <code>提交订单</code> 命令)。</li></ul></li><li><strong>粉色/黄色大贴 - 聚合 (Aggregate):</strong><ul><li><strong>规则：</strong> 聚合是处理命令并产生事件的业务实体，它负责维护一组相关对象的数据一致性。</li><li><strong>例子：</strong> <code>订单</code> 聚合负责处理 <code>提交订单</code> 命令，并产生 <code>订单已提交</code> 事件。</li></ul></li><li><strong>划定边界 - 限界上下文 (Bounded Context):</strong> 当整个流程可视化之后，团队会发现某些事件、命令和聚合在业务上高度相关，形成了一个个的&quot;簇&quot;。这些&quot;簇&quot;的边界，就是 <strong>限界上下文</strong> 的边界，也是 <strong>组件/微服务</strong> 的理想边界。例如，所有与订单创建、修改、状态流转相关的即时贴会自然地聚集在一起，形成 <code>Ordering</code> 上下文。</li></ol><p><strong>优点：</strong></p><ul><li><strong>协作性：</strong> 打破了业务与技术之间的隔阂，让所有人对业务有统一的理解。</li><li><strong>深度洞察：</strong> 能发现隐性的业务规则和流程，识别出比 Actor/Actions 更自然的边界。</li><li><strong>结果可靠：</strong> 通过事件风暴识别出的边界通常非常稳定，是划分微服务的黄金标准。</li></ul><h3 id="Workflow">Workflow</h3><p>这种方法是对 Actor/Actions 方法的一个重要补充，它专注于识别那些 <strong>没有明确、单一执行者的端到端业务流程</strong>。</p><p><strong>核心思想：</strong> 寻找系统中的关键业务事件，并追踪由该事件引发的一系列后续处理步骤，将整个流程封装成一个组件。</p><p><strong>实施步骤：</strong></p><ol><li><strong>识别关键业务事件或调度任务：</strong> 例如：“订单支付成功”、“每月一日进行财务结算”。</li><li><strong>描绘工作流：</strong> 画出该事件发生后，系统需要依次完成的所有步骤。<ul><li><strong>事件：订单支付成功 (Order Paid)</strong></li><li><strong>工作流：</strong><ol><li>更新订单状态为“待发货”。</li><li>调用仓库管理系统 (WMS) 接口，通知发货。</li><li>向用户发送“支付成功”的邮件/短信。</li><li>为用户增加积分。</li></ol></li></ul></li><li><strong>组件划分：</strong> 整个工作流可以被识别为一个或多个组件。例如，可以有一个 <code>OrderFulfillment</code> (订单履行) 组件来编排这个流程。</li></ol><p><strong>适用场景：</strong></p><ul><li><strong>后台处理：</strong> 如报表生成、数据同步、月末结算等。</li><li><strong>异步流程：</strong> 一个操作触发后，后台需要执行一系列复杂的、耗时的任务。</li><li><strong>编排服务 (Orchestration):</strong> 一个组件的主要职责是调用其他多个组件/服务来完成一个复杂的业务目标。</li></ul><h2 id="架构师职责">架构师职责</h2><ul><li>架构职责：架构分区<ul><li>按层分区</li><li>按模块分区</li><li>按技术分区</li><li>按领域分区</li></ul></li><li>开发职责：组件识别<ul><li>识别基础组件</li><li>为组件赋予需求</li><li>分析组件角色和职责</li><li>分析架构特征</li><li>重构组件</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第八章的课后思考题，深入探讨软件组件的核心概念与实现方式、技术导向与领域导向分区策略的差异、实体陷阱问题的本质及解决方案，以及Actor/Actions模式、工作流分析和事件风暴等组件识别技术的适用场景与局限性，帮助理解如何运用领域驱动的思维方式来设计组件边界，提升系统的内聚性、松耦合特性和业务适应能力。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Rust 入门丨02 闭包</title>
    <link href="https://hedon.top/2025/07/08/rust-02-closure/"/>
    <id>https://hedon.top/2025/07/08/rust-02-closure/</id>
    <published>2025-07-08T05:22:00.000Z</published>
    <updated>2025-07-27T04:29:14.333Z</updated>
    
    <content type="html"><![CDATA[<p>笔者之前一直不理解 Rust 中关于闭包的 Fn/FnMut/FnOnce 这 3 个 trait 的包含关系。通过一段时间的学习和分析，终于找到了我思维上的一个错误点 ，特此梳理此文，方便日后查询。</p><p>我之前的理解是这样的：</p><blockquote><p>Fn 只需要引用，所以要求是最容易满足的。FnMut 需要的是可变引用，所以能满足 FnMut，一定能满足 Fn。FnOnce 需要的是所有权，那都有所有权了 ，&amp;mut 和 &amp; 肯定就不在话下了。所以满足 FnOnce 的，一定是 Fn 和 FnMut。满足 FnMut 的，不一定是 FnOnce，但是一定是 Fn。</p></blockquote><p>我的错误点在于：在<strong>闭包实现者</strong>的角度想&quot;我拥有什么权限&quot;。</p><p>正确的思路应该是：<u>站在<strong>函数调用者</strong>的角度想&quot;我得到了什么承诺&quot;</u>。这才是 Trait 设计的本质，即是能力的声明，更是限制的承诺。</p><hr><h3 id="核心关键：承诺越强，限制越多，类型越“小”">核心关键：承诺越强，限制越多，类型越“小”</h3><p><code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code> 这三个 Trait，本质上是闭包对<strong>调用者</strong>做出的三种不同强度的<strong>承诺</strong>。</p><ol><li><strong><code>Fn</code> 的承诺 (最强的承诺)</strong><ul><li><strong>承诺内容</strong>：调用我，只需要对我进行不可变借用 (<code>&amp;self</code>)。你甚至可以同时在多个线程里调用我。我保证不会改变任何东西，也不会消耗掉自己。</li><li><strong>对闭包的限制</strong>：为了兑现这个最强的承诺，闭包自身受到的限制也最大。它<strong>只能</strong>不可变地借用环境中的变量。</li><li><strong>调用者的自由</strong>：调用者获得了最大的自由，可以随心所欲地、不限次数地调用这个闭包。</li></ul></li><li><strong><code>FnMut</code> 的承诺 (中等的承诺)</strong><ul><li><strong>承诺内容</strong>：调用我，需要对我进行可变借用 (<code>&amp;mut self</code>)。这意味着你不能同时调用我，但可以一个接一个地调用。我可能会改变我内部的状态。</li><li><strong>对闭包的限制</strong>：限制有所放宽。闭包可以<strong>可变地</strong>借用环境变量。</li><li><strong>调用者的自由</strong>：调用者的自由受到了一些限制，不能并发调用了。</li></ul></li><li><strong><code>FnOnce</code> 的承诺 (最弱的承诺)</strong><ul><li><strong>承诺内容</strong>：你<strong>只能</strong>调用我一次 (<code>self</code>)。调用之后，我就会被消耗掉，不复存在。</li><li><strong>对闭包的限制</strong>：对闭包自身的限制最小。它可以随心所欲，甚至可以拿走环境变量的<strong>所有权</strong>。</li><li><strong>调用者的自由</strong>：调用者只拥有一次调用的机会，自由度最低。</li></ul></li></ol><h3 id="将之前的逻辑反过来思考">将之前的逻辑反过来思考</h3><p>用&quot;承诺&quot;的视角：</p><ul><li><strong>错误想法</strong>：<code>FnOnce</code> 有所有权，最厉害，所以它包含了 <code>FnMut</code> 和 <code>Fn</code>。</li><li><strong>正确的逻辑</strong>：一个闭包如果能做出 <code>Fn</code> 的承诺（最强承诺），那么它自然也能满足 <code>FnMut</code>（中等承诺）和 <code>FnOnce</code>（最弱承诺）的要求。</li></ul><p>这就像一个人的信用评级：</p><ul><li>一个能被评为 <strong>AAA 级信用 (<code>Fn</code>)</strong> 的人，向他借钱（调用他）风险极低，可以随时借。他自然也满足 <strong>AA 级 (<code>FnMut</code>)</strong> 和 <strong>A 级 (<code>FnOnce</code>)</strong> 的标准。</li><li>一个被评为 <strong>AA 级信用 (<code>FnMut</code>)</strong> 的人，满足不了 AAA 级的苛刻标准，但他肯定满足 A 级的基本标准。</li><li>一个只有 <strong>A 级信用 (<code>FnOnce</code>)</strong> 的人，意味着和他交易有风险，只能“一次性买卖”，他肯定满足不了 AA 级和 AAA 级的要求。</li></ul><p>所以，这个关系是：</p><ul><li>凡是 <code>Fn</code>，必然是 <code>FnMut</code> 和 <code>FnOnce</code>。</li><li>凡是 <code>FnMut</code>，必然是 <code>FnOnce</code>，但不一定是 <code>Fn</code>。</li><li><code>FnOnce</code> 最为宽泛，它不承诺自己是 <code>FnMut</code> 或 <code>Fn</code>。</li></ul><h3 id="代码验证">代码验证</h3><p>我们用一个具体的例子来印证这个理论。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个函数，它要求一个“AAA信用”的闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_repeatedly</span>&lt;F: <span class="title function_ invoke__">Fn</span>()&gt;(closure: F) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;--- Calling an Fn closure ---&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，它要求一个“AA信用”的闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_mutably</span>&lt;F: <span class="title function_ invoke__">FnMut</span>()&gt;(<span class="keyword">mut</span> closure: F) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;--- Calling an FnMut closure ---&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，它只要求“A信用”的闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_once</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt;(closure: F) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;--- Calling an FnOnce closure ---&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">owned_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 这是一个 Fn 闭包，因为它只对 my_string 进行了不可变借用。</span></span><br><span class="line">    <span class="comment">// 它做出了最强的承诺。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure_fn</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Fn says: &#123;&#125;&quot;</span>, my_string);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 这是一个 FnMut 闭包，因为它对 my_string 进行了可变借用。</span></span><br><span class="line">    <span class="comment">// 它只能做出中等承诺。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">closure_fn_mut</span> = || &#123;</span><br><span class="line">        my_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;FnMut says: &#123;&#125;&quot;</span>, my_string);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 这是一个 FnOnce 闭包，因为它夺走了 owned_string 的所有权。</span></span><br><span class="line">    <span class="comment">// 它只能做出最弱的承诺。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure_fn_once</span> = || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">consumed</span> = owned_string;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;FnOnce says: &#123;&#125;&quot;</span>, consumed);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 开始验证 ---</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `closure_fn` (AAA级) 可以满足所有要求</span></span><br><span class="line">    <span class="title function_ invoke__">call_repeatedly</span>(closure_fn);</span><br><span class="line">    <span class="title function_ invoke__">call_mutably</span>(closure_fn);</span><br><span class="line">    <span class="title function_ invoke__">call_once</span>(closure_fn);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `closure_fn_mut` (AA级) 满足不了 AAA 级的要求</span></span><br><span class="line">    <span class="comment">// call_repeatedly(closure_fn_mut); // 编译错误！因为它改变了环境，不满足 Fn 的要求</span></span><br><span class="line">    <span class="title function_ invoke__">call_mutably</span>(&amp;<span class="keyword">mut</span> closure_fn_mut);</span><br><span class="line">    <span class="title function_ invoke__">call_once</span>(&amp;<span class="keyword">mut</span> closure_fn_mut);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `closure_fn_once` (A级) 只能满足最基本的要求</span></span><br><span class="line">    <span class="comment">// call_repeatedly(closure_fn_once); // 编译错误！</span></span><br><span class="line">    <span class="comment">// call_mutably(closure_fn_once);    // 编译错误！因为它被调用后就没了，不能调用第二次</span></span><br><span class="line">    <span class="title function_ invoke__">call_once</span>(closure_fn_once);</span><br><span class="line">    <span class="comment">// call_once(closure_fn_once); // 再次调用也会编译错误，因为它已经被消耗了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>在 Rust 的 Trait 系统中，一个类型如果满足更强的承诺（<code>Fn</code>），它就能被用在要求较弱承诺（<code>FnMut</code>, <code>FnOnce</code>）的任何地方。这就是为什么 <code>Fn</code> 是最小、最核心的那个集合。</p>]]></content>
    
    
    <summary type="html">本文通过&quot;承诺&quot;的视角深入解析 Rust 闭包中 Fn、FnMut、FnOnce 三个 trait 的包含关系，帮助读者理解闭包设计的本质。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="Rust 入门" scheme="https://hedon.top/categories/rust/Rust-%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨07丨架构特性范围</title>
    <link href="https://hedon.top/2025/07/08/fosa/fosa-ch7/"/>
    <id>https://hedon.top/2025/07/08/fosa/fosa-ch7/</id>
    <published>2025-07-08T03:00:00.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第七章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>What is an architectural quantum, and why is it important to architecture?</p><p>为什么是架构量子？它为什么对架构很重要？</p></li><li><p>Assume a system consisting of a single user interface with four independently deployed services, each containing its own separate database. Would this system have a single quantum or four quanta? Why?</p><p>假设一个系统包含一个单一的用户界面，以及四个独立部署的服务，每个服务都包含自己的独立数据库。这个系统会有一个量子还是四个量子？为什么？</p></li><li><p>Assume a system with an administration portion managing static reference data (such as the product catalog, and warehouse information) and a customer-facing portion managing the placement of orders. How many quanta should this system be and why? If you envision multiple quanta, could the admin quantum and customer-facing quantum share a database? If so, in which quantum would the database need to reside?</p><p>假设一个系统包含两个部分：</p><ol><li><strong>管理后台</strong>：负责管理静态参考数据（例如产品目录、仓库信息）。</li><li><strong>用户端</strong>：负责处理客户订单的下达。</li></ol><p>这个系统应该被划分为多少个 <strong>量子</strong>？为什么？如果您设想这是多个量子，那二者可以共享同一个数据库吗？如果可以，该数据库需要驻留在哪个量子中？</p></li></ol><hr><h2 id="什么是架构量子？">什么是架构量子？</h2><p><strong>架构量子 (Architectural Quantum)</strong> 这个概念源于 Neal Ford、Mark Richards 等人在《软件架构：艰难的部分》(Software Architecture: The Hard Parts) 一书中提出的。它的核心定义是：</p><blockquote><p>一个<strong>架构量子</strong>是指一个系统中，具有<strong>高功能内聚性 (High Functional Cohesion)</strong> 和<strong>同步部署依赖性 (Synchronous Deployable Dependency)</strong> 的、可独立部署的组件的最小集合。</p></blockquote><p>为了更好地理解这个定义，我们需要拆解其中的关键术语：</p><ul><li><strong>可独立部署的组件 (Independently Deployable Component)</strong>：这是现代架构（尤其是微服务架构）的基本单元。它可以是一个服务、一个应用或者任何可以独立于系统其他部分进行部署的模块。</li><li><strong>高功能内聚性 (High Functional Cohesion)</strong>：这个概念借鉴了软件工程中的“内聚性”，指的是一个组件内部的各个部分为了一个共同、明确的目标而紧密协作。例如，一个“订单处理服务”应该只包含与创建、更新、查询订单相关的逻辑，而不应该包含用户认证或产品推荐的逻辑。一个架构量子内的所有组件，共同构成了一个完整且内聚的业务功能。</li><li><strong>同步部署依赖性 (Synchronous Deployable Dependency)</strong>：这是定义中最关键也最“硬核”的部分。它指的是组件之间的行为调用必须是同步的，以保证系统正常工作。如果服务 A 调用服务 B，并且必须等待 B 的响应才能继续执行，那么 A 和 B 之间就存在同步依赖。这种依赖关系会将不同的独立部署组件“捆绑”在一起，形成一个不可分割的整体，也就是一个量子。如果为了让某个功能正常工作，你必须同时部署或更新服务 A 和服务 B，那它们就属于同一个量子。</li></ul><h2 id="为什么架构量子很重要？">为什么架构量子很重要？</h2><p>理解了定义后，我们来看看它在实践中的重要性。架构量子的概念为我们提供了一个强大的分析工具，帮助我们衡量和决策架构中的关键架构特性，例如：</p><ol><li><strong>可部署性 (Deployability)</strong>：一个架构量子是<strong>最小的独立部署单元</strong>。整个量子可以作为一个单元进行部署、回滚和发布，而不会破坏系统的其他部分。这极大地简化了 CI/CD 流程。如果你错误地将一个量子拆分成多个，可能会导致部署时的级联失败。</li><li><strong>可测试性 (Testability)</strong>：由于量子内部的组件功能高度内聚且存在同步依赖，因此它也成为了一个理想的<strong>测试边界</strong>。你可以对整个量子进行端到端的功能测试和集成测试，而无需启动整个庞大的系统。</li><li><strong>可伸缩性 (Scalability)</strong>：不同的量子承载不同的业务功能，其负载模式也可能完全不同。例如，浏览产品目录的量子和处理支付的量子对资源的需求天差地别。将它们划分为不同的量子，使得我们可以<strong>独立地扩展</strong>每一个量子，从而更高效地利用资源。</li><li><strong>容错性 (Fault Tolerance)</strong>：一个设计良好的量子边界可以形成一道“防火墙”。一个量子的失败（例如，由于代码缺陷或流量激增）不应该导致其他量子的同步崩溃。这种隔离性是构建高可用系统的基础。</li><li><strong>组织结构对齐 (Alignment with Team Structure)</strong>：根据康威定律 (Conway’s Law)，系统架构往往会反映出开发它的团队的沟通结构。一个清晰的量子可以由一个独立的、自治的团队负责，从而减少跨团队沟通的开销，提升开发效率。</li></ol><p>简而言之，架构量子帮助我们识别出系统中<strong>真正的、不可再分的架构单元</strong>。它提供了一个明确的边界，指导我们如何合理地拆分系统，从而在可部署性、可伸缩性、容错性和团队效率之间取得平衡。</p><h2 id="场景分析一：单一-UI-四个独立服务">场景分析一：单一 UI + 四个独立服务</h2><blockquote><p>假设一个系统包含一个单一的用户界面，以及四个独立部署的服务，每个服务都包含自己的独立数据库。这个系统会有一个量子还是四个量子？为什么？</p></blockquote><p>答案是：<strong>这个系统最有可能包含四个量子 (Four Quanta)</strong>。</p><p><strong>分析如下：</strong></p><p>这里的关键信息是“四个<strong>独立部署</strong>的服务，每个服务都包含<strong>自己的独立数据库</strong>”。</p><ol><li><strong>独立部署与自有数据库</strong>：这个设定强烈暗示了服务之间的高度解耦。在现代架构中，服务独占自己的数据库是实现真正自治和独立部署的黄金法则。如果服务间共享数据库，它们的部署就会产生耦合（例如，一个服务修改了表结构，可能会影响到所有依赖该表的其他服务），也就无法做到真正的独立部署。</li><li><strong>同步依赖的缺失</strong>：虽然这四个服务最终都服务于同一个用户界面 (UI)，但题目并未描述它们之间存在<strong>同步调用</strong>的强依赖关系。UI 很可能是通过异步的方式或者直接独立地与这四个服务进行通信。例如，UI 的一个页面可能需要同时展示来自服务 A 的用户信息和服务 B 的产品列表，但 UI 可以分别向 A 和 B 发起两个独立的 API 请求，这两个服务之间并不需要直接对话。</li><li><strong>功能内聚性</strong>：每个服务和它自己的数据库共同构成了一个高度内聚的功能单元。例如，服务 A 和它的数据库负责“用户管理”，服务 B 和它的数据库负责“订单管理”，等等。它们各自完成了闭环的业务能力。</li></ol><p><strong>结论</strong>：由于这四个服务（连同其数据库）可以独立部署，并且它们之间大概率不存在必须同步成功的强依赖，因此它们构成了四个独立的架构量子。单一的用户界面在这里扮演的是一个“集成层”或“客户端”的角色，它本身通常不被视为一个量子，而是作为这些量子的消费者。将系统划分为四个量子，使得每个服务都可以被独立地开发、测试、部署和扩展，从而获得了极大的架构灵活性。</p><h2 id="场景分析二：管理后台-用户端">场景分析二：管理后台 + 用户端</h2><blockquote><p>假设一个系统包含两个部分：</p><ul><li>管理后台：负责管理静态参考数据（例如产品目录、仓库信息）。</li><li>用户端：负责处理客户订单的下达。</li></ul><p>这个系统应该被划分为多少个量子？为什么？如果您设想这是多个量子，那二者可以共享同一个数据库吗？如果可以，该数据库需要驻留在哪个量子中？</p></blockquote><h3 id="这个系统应该被划分为多少个量子？为什么？">这个系统应该被划分为多少个量子？为什么？</h3><p>答案是：<strong>这个系统应该被划分为两个量子 (Two Quanta)</strong>。</p><p><strong>分析如下：</strong></p><ol><li><strong>不同的架构特性需求</strong>：<ul><li><strong>用户端 (Customer-facing Portion)</strong>：这是系统的核心交易部分。它需要<strong>高可用性 (High Availability)</strong>、<strong>高可伸缩性 (High Scalability)</strong>（因为用户流量波动大，尤其在促销期间）、以及<strong>低延迟 (Low Latency)</strong>。</li><li><strong>管理后台 (Administration Portion)</strong>：这部分主要由内部员工使用。它对可伸缩性的要求远低于用户端，但可能对<strong>数据一致性 (Consistency)</strong> 和安全性有更高的要求。其使用模式也更可预测。</li></ul></li><li><strong>功能内聚性与关注点分离</strong>：管理后台的功能（管理产品目录、仓库信息）和用户端的功能（浏览商品、下单、支付）在业务上是完全不同的。将它们分开，符合单一职责原则，也使得各自的逻辑更清晰。</li><li><strong>部署和生命周期的独立性</strong>：用户端的功能可能需要频繁迭代和快速发布（例如，上线一个新的促销活动），而管理后台的功能则相对稳定，更新频率较低。将它们划分为两个量子，可以实现独立的部署和发布节奏，用户端的紧急修复或更新不会被后台的发布流程所拖累。</li></ol><p><strong>结论</strong>：基于截然不同的架构特性需求、功能内聚性以及部署独立性的考量，将这个系统划分为一个“管理后台量子”和一个“用户端量子”是最佳实践。</p><h3 id="二者可以共享同一个数据库吗？">二者可以共享同一个数据库吗？</h3><p>答案是：<strong>技术上可以，但强烈不推荐 (Technically possible, but highly discouraged)</strong>。共享数据库会引入我们之前提到的问题，即<strong>耦合 (Coupling)</strong>。</p><ul><li><strong>性能耦合</strong>：管理后台的一个慢查询或数据批量导入操作，可能会锁住表，从而严重影响用户端的性能，甚至导致用户无法下单。</li><li><strong>部署耦合</strong>：如果用户端需要修改某个表的结构来支持新功能，这个修改可能会破坏管理后台的正常工作，反之亦然。这使得两个本应独立的量子在部署上产生了依赖。</li><li><strong>安全耦合</strong>：用户端和管理后台的数据库访问权限需求是不同的。共享数据库会增加权限管理的复杂性，可能导致安全漏洞。</li></ul><h3 id="如果一定要共享，数据库需要驻留在哪个量子中？">如果一定要共享，数据库需要驻留在哪个量子中？</h3><p>这是一个权衡和妥协的问题。如果因为历史原因、成本限制或其他因素<strong>不得不</strong>共享数据库，那么决策的关键在于<strong>数据的所有权 (Data Ownership)</strong> 和<strong>服务的关键性 (Service Criticality)</strong>。</p><p>在这个场景中，“产品目录”和“仓库信息”这些数据，虽然由管理后台进行维护，但它们的最终消费者和价值实现者是<strong>用户端</strong>。用户下单的逻辑严重依赖于这些数据的可用性和准确性。</p><p>因此，如果必须共享，该数据库在逻辑上应该<strong>驻留在用户端量子中</strong>。</p><p><strong>原因如下：</strong></p><ol><li><strong>业务关键性</strong>：用户端是直接产生商业价值的部分，其可用性是第一位的。将数据库置于此量子内，意味着所有架构决策（如扩展、备份、容灾）都将优先保障用户端的需求。</li><li><strong>数据所有权</strong>：虽然管理后台是数据的“生产者”，但用户端是数据的核心“消费者”。在领域驱动设计 (Domain-Driven Design) 的思想中，数据应该属于它所支持的核心业务领域 (Core Domain)，在这里显然是用户交易领域。</li><li><strong>架构上的清晰性</strong>：这样做可以建立一个清晰的依赖关系：管理后台量子依赖于用户端量子中的数据。这虽然不是最理想的解耦状态，但至少依赖关系是单向且明确的。</li></ol><p>在这种共享模式下，更好的实践是通过<strong>定义稳定的 API</strong> 来缓解耦合。管理后台不应直接操作数据库，而是应该通过用户端量子提供的 API 来修改产品目录等数据。这样做可以隐藏数据库的物理实现，为未来的数据库拆分创造可能性。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第七章的课后思考题，深入探讨架构量子的概念与定义、架构特性的作用范围以及量子边界的识别方法，分析系统组件间的同步依赖关系对架构分解的影响，帮助理解如何基于功能内聚性和部署依赖性来合理划分架构边界，优化系统的可部署性、可测试性和可维护性。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>课程笔记丨《手把手带你写一个 Web 框架》</title>
    <link href="https://hedon.top/2025/07/07/note-write-a-web-framework/"/>
    <id>https://hedon.top/2025/07/07/note-write-a-web-framework/</id>
    <published>2025-07-07T15:02:00.000Z</published>
    <updated>2025-07-07T15:51:47.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="框架-零件">框架&quot;零件&quot;</h2><h3 id="context">context</h3><ol><li>框架级 Context：可以组合优秀框架（如 gin.Context）的基础上，扩展自己常用的功能函数。</li><li>业务级 Context：针对具体的业务，组合框架 Context，封装更多的业务工具函数，进一步提升效率。</li><li>如果有必要进步提升性能的话，可以使用 sync.Pool 对 Context 进行管理，避免 Context 频繁创建销毁带来的性能损耗。</li><li>灵活使用链路调用，有助于提升代码的清晰度和可扩展性。</li></ol><h3 id="路由匹配">路由匹配</h3><p>Gin 使用 <a href="https://en.wikipedia.org/wiki/Radix_tree">radix tree</a>，尽可能压缩路由的公共前缀，同时使用 indices 加速路由的检索。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Patricia_trie_var.svg/350px-Patricia_trie_var.svg.png" alt="radix tree"></p><h3 id="中间件">中间件</h3><p>使用洋葱型中间件，可以很方便地进行 AOP 编程，有很大的扩展性。</p><p>如 Gin 框架中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlersChain defines a HandlerFunc slice.</span></span><br><span class="line"><span class="keyword">type</span> HandlersChain []HandlerFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc defines the handler used by gin middleware as return value.</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br></pre></td></tr></table></figure><p>同时为 <code>IRouter</code> 接口也定义 <code>Group</code> 函数，这样可以进一步提升聚合类的逻辑复用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRouter defines all router handle interface includes single and group router.</span></span><br><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span> &#123;</span><br><span class="line">IRoutes</span><br><span class="line">Group(<span class="type">string</span>, ...HandlerFunc) *RouterGroup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行过程中，使用 <code>c.Next()</code> 和 <code>c.Abort()</code> 来进行处理器调用或提前退出等逻辑控制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> abortIndex <span class="type">int8</span> = math.MaxInt8 &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Next() &#123;</span><br><span class="line">c.index++   <span class="comment">// 初始化 c.index = -1</span></span><br><span class="line"><span class="keyword">for</span> c.index &lt; <span class="type">int8</span>(<span class="built_in">len</span>(c.handlers)) &#123;</span><br><span class="line"><span class="keyword">if</span> c.handlers[c.index] != <span class="literal">nil</span> &#123;</span><br><span class="line">c.handlers[c.index](c)</span><br><span class="line">&#125;</span><br><span class="line">c.index++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Abort() &#123;</span><br><span class="line">c.index = abortIndex  <span class="comment">// 设置为最大值，后面的 next 就会直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展现有框架">扩展现有框架</h3><p>相比于自己从零开始写一个 Web 框架，完全可以站在前人的肩膀上，将流行的、好用的、开源协议允许的框架代码拷贝到自己的仓库中，进行改造升级，从而快速搭建一个功能完善、经过验证、贴合团队需要的强悍 Web 框架。</p><h2 id="一切皆服务">一切皆服务</h2><p>按照面向接口编程的理念，将每个模块看成是一个服务，服务的具体实现我们其实并不关心，我们关心的是服务提供的能力，即接口协议。那么框架主体真正要做的事情是什么呢？其实是：<strong>定义好每个模块服务的接口协议，规范服务与服务之间的调用，并且管理每个服务的具体实现</strong>。</p><p>所有的服务都去框架主体中注册自身的模块接口协议，其他的服务调用功能模块的时候，并不是直接去这个服务获取实例，而是从框架主体中获取有这个接口协议的服务实例。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250707232209688.png" alt="一切皆服务"></p><h3 id="容器-container">容器 container</h3><p>服务提供接口定义可参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewInstance is a function that creates a new instance of a service</span></span><br><span class="line"><span class="keyword">type</span> NewInstance <span class="function"><span class="keyword">func</span><span class="params">(...any)</span></span> (any, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceProvider is an interface that defines a service provider</span></span><br><span class="line"><span class="keyword">type</span> ServiceProvider <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Register a service provider into the container,</span></span><br><span class="line"><span class="comment">// whether to initialize the service or not determined by the IsDefer method</span></span><br><span class="line">Register(Container) NewInstance</span><br><span class="line"><span class="comment">// Boot the service provider, this method will be called after the container is initialized.</span></span><br><span class="line"><span class="comment">// Is id recommend to do some initialization work in this method.</span></span><br><span class="line"><span class="comment">// If returns error, the service initialization will be failed.</span></span><br><span class="line">Boot(Container) <span class="type">error</span></span><br><span class="line"><span class="comment">// IsDefer determines whether the service provider should be deferred.</span></span><br><span class="line"><span class="comment">// If true, the service provider will be deferred until the first time the service is used.</span></span><br><span class="line">IsDefer() <span class="type">bool</span></span><br><span class="line"><span class="comment">// Params are the parameters which would be passed to the NewInstance function.</span></span><br><span class="line">Params(Container) []any</span><br><span class="line"><span class="comment">// Name is a method that returns the unique name of the service provider.</span></span><br><span class="line">Name() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器接口定义可参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Container is a service provider container, provides methods to register and resolve service providers.</span></span><br><span class="line"><span class="keyword">type</span> Container <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Bind binds a service provider into the container,</span></span><br><span class="line"><span class="comment">// if the service provider is already bound, it would panic.</span></span><br><span class="line">Bind(provider ServiceProvider) <span class="type">error</span></span><br><span class="line"><span class="comment">// IsBind checks if a service provider is bound into the container</span></span><br><span class="line">IsBind(key <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line"><span class="comment">// Make resolves a service provider from the container</span></span><br><span class="line">Make(key <span class="type">string</span>) (any, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// MustMake resolves a service provider from the container, if not found, it will panic</span></span><br><span class="line">MustMake(key <span class="type">string</span>) any</span><br><span class="line"><span class="comment">// MakeNew creates a new instance of a service provider,</span></span><br><span class="line"><span class="comment">// it is useful when you need to create a new instance of a service provider</span></span><br><span class="line"><span class="comment">// and pass some different parameters to the service provider&#x27;s constructor.</span></span><br><span class="line">MakeNew(key <span class="type">string</span>, params ...any) (any, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现可参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helps to check if the Container interface is implemented</span></span><br><span class="line"><span class="keyword">var</span> _ Container = (*HdwebContainer)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HdwebContainer is the default implementation of the Container interface</span></span><br><span class="line"><span class="keyword">type</span> HdwebContainer <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// providers is a map of service providers, key is the name of the service provider</span></span><br><span class="line">providers <span class="keyword">map</span>[<span class="type">string</span>]ServiceProvider</span><br><span class="line"><span class="comment">// instances is a map of service instances, key is the name of the service</span></span><br><span class="line">instances <span class="keyword">map</span>[<span class="type">string</span>]any</span><br><span class="line"><span class="comment">// lock is used to protect the container from concurrent access</span></span><br><span class="line">lock sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewHdwebContainer creates a new HdwebContainer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHdwebContainer</span><span class="params">()</span></span> *HdwebContainer &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;HdwebContainer&#123;</span><br><span class="line">providers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]ServiceProvider),</span><br><span class="line">instances: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]any),</span><br><span class="line">lock:      sync.RWMutex&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind binds a service provider into the container,</span></span><br><span class="line"><span class="comment">// if the service provider is already bound, &#x27;</span></span><br><span class="line"><span class="comment">// it will replace the existing one and return an error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> Bind(provider ServiceProvider) <span class="type">error</span> &#123;</span><br><span class="line">h.lock.Lock()</span><br><span class="line">key := provider.Name()</span><br><span class="line"><span class="keyword">if</span> _, ok := h.providers[key]; ok &#123;</span><br><span class="line">h.lock.Unlock()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;service provider already bound: &quot;</span> + key)</span><br><span class="line">&#125;</span><br><span class="line">h.providers[key] = provider</span><br><span class="line">h.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> provider.IsDefer() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := provider.Boot(h); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">params := provider.Params(h)</span><br><span class="line">method := provider.Register(h)</span><br><span class="line"></span><br><span class="line">instance, err := method(params...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> h.lock.Unlock()</span><br><span class="line"><span class="keyword">if</span> _, ok := h.instances[key]; ok &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;service provider already resolved: &quot;</span> + key)</span><br><span class="line">&#125;</span><br><span class="line">h.instances[key] = instance</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsBind checks if a service provider is bound into the container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> IsBind(key <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h.findServiceProvider(key) != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make resolves a service provider from the container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> Make(key <span class="type">string</span>) (any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> h.<span class="built_in">make</span>(key, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeNew creates a new instance of a service provider,</span></span><br><span class="line"><span class="comment">// it is useful when you need to create a new instance of a service provider</span></span><br><span class="line"><span class="comment">// and pass some different parameters to the service provider&#x27;s constructor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> MakeNew(key <span class="type">string</span>, params ...any) (any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> h.<span class="built_in">make</span>(key, params, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MustMake resolves a service provider from the container, if not found, it will panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> MustMake(key <span class="type">string</span>) any &#123;</span><br><span class="line">ins, err := h.<span class="built_in">make</span>(key, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ins</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> <span class="built_in">make</span>(key <span class="type">string</span>, params []any, forceNew <span class="type">bool</span>) (any, <span class="type">error</span>) &#123;</span><br><span class="line">sp := h.findServiceProvider(key)</span><br><span class="line"><span class="keyword">if</span> sp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;service provider not found: &quot;</span> + key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> forceNew &#123;</span><br><span class="line"><span class="keyword">return</span> h.newInstance(sp, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ins := h.getInstance(key); ins != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ins, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> h.lock.Unlock()</span><br><span class="line"><span class="keyword">if</span> ins, ok := h.instances[key]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> ins, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">ins, err := h.newInstance(sp, params)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">h.instances[key] = ins</span><br><span class="line"><span class="keyword">return</span> ins, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> getInstance(key <span class="type">string</span>) any &#123;</span><br><span class="line">h.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> h.lock.RUnlock()</span><br><span class="line"><span class="keyword">return</span> h.instances[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> newInstance(sp ServiceProvider, params []any) (any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> err := sp.Boot(h); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> params == <span class="literal">nil</span> &#123;</span><br><span class="line">params = sp.Params(h)</span><br><span class="line">&#125;</span><br><span class="line">method := sp.Register(h)</span><br><span class="line"><span class="keyword">return</span> method(params...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> findServiceProvider(key <span class="type">string</span>) ServiceProvider &#123;</span><br><span class="line">h.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> h.lock.RUnlock()</span><br><span class="line"><span class="keyword">return</span> h.providers[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务-service-provider">服务 service provider</h3><ul><li>contract：服务功能接口定义</li><li>provider：为服务实现 ServiceProvider 接口</li><li>service：实现服务 contract 功能接口</li></ul><h4 id="框架级服务">框架级服务</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">contract</span>  <span class="comment"># 服务接口定义</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">app.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">kernel.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">env.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">config.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider</span>  <span class="comment"># 服务实现</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">app</span> <span class="comment"># app 服务</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider.go</span> <span class="comment"># 实现 Service Provider</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.go</span>  <span class="comment"># 实现服务接口</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">kernel</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.go</span></span><br></pre></td></tr></table></figure><h4 id="业务级服务">业务级服务</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> &#123;<span class="string">root</span>&#125;  <span class="comment"># 根目录</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">app</span> <span class="comment"># app 目录</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider</span> <span class="comment"># 通用业务服务</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">user</span>  <span class="comment"># user 服务</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">contract.go</span> <span class="comment"># user 服务接口定义</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.go</span>  <span class="comment"># user 服务接口实现</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider.go</span> <span class="comment"># 为 user 服务实现 Service Provider</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">mail</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">contract.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider.go</span></span><br></pre></td></tr></table></figure><h2 id="自动化-DRY">自动化 DRY</h2><p>在业务开发过程中，对于那些重复性的类模板劳动，可以使用 CLI 命令行工具，或其他自动化工具，来简化这些劳动输出。</p><p>这里有 2 个思路，一个是使用 Makefile，一个是使用 CLI（Go 里面可以使用 <code>cobra</code> 框架）。选择的时候可以考虑以下几个点：</p><ol><li>命令变动的频率（二者在这一点区别不大，不过如果变动频率比较低，那 CLI 的劣势就相对可以忽略了）</li><li>命令使用的复杂性（参数越多，则需要越详尽的帮助说明）</li><li>业务逻辑相关性（越相关，则逻辑越复杂，使用代码越好管控）</li></ol><p>常见的思路有：</p><ul><li>生成项目脚手架（init）</li><li>项目启动管理（build、start、stop、restart、update）</li><li>服务模版生成（provider list/new）—— 可以结合  <code>survey</code> 做命令行渐进式输入，<code>template</code> 生成模板代码</li><li>命令行系列生成（command list/new）</li><li>定时任务（cron list/run）</li><li>swagger 生成（swagger gen）</li></ul>]]></content>
    
    
    <summary type="html">极客时间《手把手带你写一个 Web 框架》课程笔记。</summary>
    
    
    
    <category term="课程笔记" scheme="https://hedon.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://hedon.top/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨06丨评估和管理架构特性</title>
    <link href="https://hedon.top/2025/07/07/fosa/fosa-ch6/"/>
    <id>https://hedon.top/2025/07/07/fosa/fosa-ch6/</id>
    <published>2025-07-07T03:00:00.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第六章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>Why is cyclomatic complexity such an important metric to analyze for architecture?</p><p>为什么圈复杂度是架构分析的重要指标？</p></li><li><p>What is an architecture fitness function? How can they be used to analyze an architecture?</p><p>什么是架构适应度函数？它们如何用于分析架构？</p></li><li><p>Provide an example of an architecture fitness function to measure the scalability of an architecture.</p><p>提供一个衡量架构可伸缩性的架构适应度函数示例。</p></li><li><p>What is the most important criteria for an architecture characteristic to allow architects and developers to create fitness functions?</p><p>允许架构师和开发人员创建适应度函数的最重要标准是什么？</p></li></ol><hr><h1>评估架构特性</h1><p>评估架构特性一般可以从 3 个方面入手：</p><ul><li>运维性指标 (operational measures)：主要关注系统在运维层面的能力，涵盖性能、可扩展性、弹性、可用性、可靠性等能力。</li><li>结构性指标 (structural measures)：关注代码结构，如模块化、组件间受控的耦合、可读代码以及其他内部质量评估。常用工具有：<ul><li><strong>圈复杂度 (Cyclomatic Complexity，CC)</strong>：一个代码层面的度量标准，由 Thomas McCabe, Sr. 于 1976 年开发，通过分析代码的决策点（如 if 语句）来量化代码的复杂性。高圈复杂度可能表明代码难以理解和测试。公式为 <code>CC = E - N + 2</code>（针对单个函数），或 <code>CC = E - N + 2P</code>（针对扇出调用）。行业普遍认为 CC 值低于 10 是可接受的，但更倾向于低于 5。</li><li><strong>距主序列距离 (Distance from the Main Sequence，D)</strong>：一个基于抽象性（A）和不稳定性（I）的综合指标，公式为 <code>D = |A + I - 1|</code>。它反映了抽象性和不稳定性之间的理想关系。远离理想线的类可能落入&quot;无用区&quot;（过于抽象难以使用）或&quot;痛苦区&quot;（过于具体且难以维护）</li></ul></li><li>流程性指标 (process measures)：关注软件开发过程中的特性，如敏捷性、可测试性和可部署性。常用工具有：<ul><li><strong>代码覆盖率（code coverage）</strong></li></ul></li></ul><h1>管理架构特性</h1><p>管理架构特性主要通过 4 个方面：</p><ul><li><strong>架构适应性函数 (Architecture Fitness Functions)</strong>：这是评估系统输出质量的客观函数，用于衡量架构特性。它们将重要的架构原则编码到软件基础中，并自动验证这些原则是否得到遵守。例如：<ul><li>检测组件之间的循环依赖 (Cyclic Dependencies)</li><li>验证分层架构中的层间依赖关系</li><li>衡量距主序列的距离</li><li>混沌工程</li></ul></li><li><strong>架构决策记录 (Architecture Decision Records, ADRs)</strong>：ADR 是一种有效的文档化架构决策的方式，通常是一到两页的短文本文件。每个 ADR 应包含标题、状态（例如“已接受”、“已取代”）、上下文、决策（使用肯定性语言）和结果（包括决策的正面和负面影响，以及权衡分析）。ADR 使得架构师能够清晰记录决策的技术和业务理由，避免重复讨论和误解。ADR 中的“合规性 (Compliance)”部分可以强制架构师思考如何衡量和管理决策的合规性，无论是手动还是通过适应性函数自动化。</li><li><strong>风险风暴 (Risk Storming)</strong>：这是一种协作活动，用于识别、达成共识并减轻架构风险。它包括识别（个体非协作活动）、共识（协作活动，讨论并统一风险评估）和缓解（协作活动，寻找减少或消除风险的方法）三个主要阶段。风险风暴通常使用风险矩阵 (Risk Matrix)，通过“影响”和“可能性”两个维度来量化风险。风险评估报告还可以显示特定风险类别或领域随时间的改进或恶化，使用加号 (+) 和减号 (-) 表示方向。</li><li><strong>持续沟通与协作</strong>：有效的沟通对于知识共享和项目成功至关重要。架构师应与产品负责人、项目经理、业务干系人以及开发人员进行谈判和协商，以获得架构决策的批准。倡导通用语言 (Ubiquitous Language)，确保所有项目相关方使用相同的业务领域术语，从而减少信息丢失和误解。</li></ul><h1>回答问题</h1><p>基于上述对本章的概括回顾，回到本章的 4 个课后题，笔者梳理了一下自己的理解，供读者们参考。</p><p>圈复杂度：</p><ol><li>圈复杂度是一种评估代码复杂性的工具。</li><li>如果一个函数（方法）中，条件分支和语句越多，则说明越复杂，一方面可能是业务逻辑本身就足够复杂，另外一方面，也很可能是代码的模块拆分没有做好，逻辑没有梳理清晰，写成了一坨。</li><li>这背后体现了模块化、可测试性、可部署性、可扩展性、可迭代性等多种代码结构层面的架构特性。</li></ol><p>架构适应度函数：</p><ol><li>架构适应度函数是一种用于持续评估当前架构是否满足需求的机制，可以理解为&quot;架构的单元测试&quot;。</li><li>不同的组织、不同的团队、不同的职责对同一个架构特性的理解、定义和需求都是不尽相同的。通过协商、建立其符合具体需求的架构适应度函数，在达成共识的基础上，可以持续对某些架构特性进行达标检测，避免偏离。比如代码测试覆盖率可以用来检测架构的可测试性、部署耗时可以用来横向架构的可部署性、可迭代性等。</li><li>要编写 fitness function，最重要也是唯一最重要的标准是<strong>架构特性必须能够被客观地衡量和定义</strong>。通过鼓励客观定义，团队可以拆解复合特性，从而发现可以被客观衡量的功能。一旦特性被具体定义，就可以更容易地建立相应的适应度函数来验证其完整性。</li></ol><p>衡量系统的可伸缩性：</p><ol><li>可伸缩性，指的是系统在用户或请求数量增加时，仍然能够维持性能和运行的能力。</li><li>假如说我们现在有一个订单服务，如果我们希望它具备良好的可伸缩性，当我们将服务实例从 2 个增加到 4 个时，系统在相同响应时间基准下，应用能处理接近翻倍的请求吞吐量。</li></ol>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第六章的课后思考题，深入探讨如何衡量和管理架构特性，分析圈复杂度等结构性指标的重要性、架构适应度函数的定义与应用，以及运维性、结构性、流程性指标的评估方法，帮助理解如何建立有效的架构治理机制来持续监控和优化系统架构。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨05丨识别架构特征</title>
    <link href="https://hedon.top/2025/07/04/fosa/fosa-ch5/"/>
    <id>https://hedon.top/2025/07/04/fosa/fosa-ch5/</id>
    <published>2025-07-04T02:24:26.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<a href="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals of Software Architecture》</a>（下文简称 FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第五章</u>内容。</p><p>本章的课后题是：</p><ol><li><p>Give a reason why it is a good practice to limit the number of characteristics (“-ilities”) an architecture should support.</p><p>举一个例子来说明为什么限制系统中支持的架构特性的数量的有必要的。</p></li><li><p>True or false: most architecture characteristics come from business requirements and user stories.</p><p>大多数的架构特性都来自于业务需求和用户故事，这对吗？</p></li><li><p>If a business stakeholder states that time-to-market (i.e., getting new features and bug fixes pushed out to users as fast as possible) is the most important business concern, which architecture characteristics would the architecture need to support?</p><p>如果一个业务利益相关者将上市时间（比如以最快的速度实现新功能和修复 BUG）视为最重要的需求点，这个时候需要支持什么样的架构特性？</p></li><li><p>What is the difference between scalability and elasticity?</p><p>可伸缩性（scalability） 和弹性（elasticity）的区别是什么？</p></li><li><p>You find out that your company is about to undergo several major acquisitions to significantly increase its customer base. Which architectural characteristics should you be worried about?</p><p>如果你发现了你的公司进行了几次重大收购以大幅增加其客户群，这个时候你应该考虑什么架构特性？</p></li></ol><hr><h1>架构特性不是越多越好</h1><ul><li><strong>增加系统设计的复杂性</strong>：每增加一个架构特性，都会使整个系统设计变得更加复杂。支持过多的架构特性会导致在架构师和开发人员开始解决核心业务问题之前，系统就变得越来越复杂。</li><li><strong>分散对核心问题的关注</strong>：架构特性定义了系统的成功标准，通常与系统的功能性正交，关注的是“如何”实现需求以及“为什么”做出某些选择。然而，如果过度追求特性数量，可能会导致偏离原始的业务问题，即开发软件的最初动机。</li><li><strong>每个特性都涉及权衡</strong>：软件架构中的每一个方面都存在权衡，有优点也有缺点。例如，在拍卖系统中，选择使用主题（topic）进行通信可能带来架构可扩展性的优势和服务的解耦，但会引入数据访问和数据安全方面的潜在问题，并且不支持异构契约。而使用队列（queue）则允许每个消费者拥有自己的契约，但不具备可扩展性，并且会增加服务间的耦合。架构师需要分析这些权衡，并根据业务驱动因素和环境选择最重要的特性。</li><li><strong>过度规范的危害</strong>：架构师过度规范架构特性是常见的陷阱，其破坏性不亚于规范不足，因为它会使系统设计过于复杂。历史案例“瓦萨号”战舰的失败就是一个例证，它是因为过度追求建造最宏伟的战舰（即过度规范架构特性）而最终导致沉没。</li><li><strong>陷入“意外复杂性”陷阱</strong>：架构师有时会为解决方案、图表和文档添加不必要的复杂性。正如一位作者所言，“开发者被复杂性吸引，就像飞蛾扑火一样——结果往往相同”。这种“意外复杂性”是由于人为地使问题复杂化，而不是问题本身固有的复杂性。通过识别子领域类型并根据其业务逻辑的复杂性选择合适的实现模式（例如，事务脚本和活动记录适用于简单业务逻辑，而领域模型和事件溯源领域模型适用于复杂的核心子领域），可以避免引入不必要的复杂性。</li><li><strong>设计应由业务驱动</strong>：领域驱动设计（DDD）的核心思想在于让业务领域驱动软件设计决策。这意味着设计决策应该基于业务领域的需求和战略，而非盲目地堆砌所有可能的架构特性。</li></ul><p>因此，与领域利益相关者合作时，架构师应努力使最终的架构特性列表尽可能短，因为每个特性都会增加总体系统设计的复杂性。</p><h1>如何识别架构特性</h1><ol><li>从领域焦点中识别架构特性</li><li>从业务需求中识别架构特性</li></ol><p>这里面的一大难点就是：<strong>业务方与开发方使用的不是同一种&quot;语言&quot;</strong>。双方对同一件事情的关注点是不一样的，所以表述出来的述求，也是不同的。</p><p>所以在识别架构特性的时候，架构师的职责就是需要将业务领域的关注点和架构特性进行对应。比如：</p><table><thead><tr><th>Domain Concern</th><th>Architecture characteristics</th></tr></thead><tbody><tr><td>Mergers and acquisitions 合并与收购</td><td>互操作性 interoperability<br>可扩展性 scalability<br>适配性 adaptability<br>可扩展性 extensibility</td></tr><tr><td>Time to market 上市时间</td><td>灵活性 agility<br>可测试性 testability<br>可部署性 deployability</td></tr><tr><td>User satisfaction 用户满意度</td><td>性能 performance<br>可用性 availability<br>容错性 fault tolerance<br>可测试性 testability<br>可部署性 deployability<br>灵活性 agility<br>安全性 security</td></tr><tr><td>Competitive advantage 竞争优势</td><td>灵活性 agility<br/>可测试性 testability<br/>可部署性 deployability<br/>可扩展性 scalability<br/>可用性 availability<br/>容错性 fault tolerance</td></tr><tr><td>Time and budget 时间和预算</td><td>简单性 simplicity<br>可行性 feasibility</td></tr></tbody></table><p>另外， 随着业务的发展，关注点也是在不断发生变化的，这个时候，架构所侧重的架构特性也是随之改变的。</p><h1>可扩展性 vs 弹性</h1><ul><li><strong>可伸缩性（Scalability）</strong>：<u>指的是系统在用户或请求数量增加时，仍然能够维持性能和运行的能力</u>。它衡量的是系统在负载线性增加时，性能是否能够保持相应的线性增长。例如，如果一个系统在用户增加一倍时，其性能也能线性提升，那么它就是可伸缩的。这通常通过增加资源（如服务器实例）来实现，以应对持续增长的用户数量。</li><li><strong>弹性（Elasticity）</strong>：<u>指的是系统处理请求突发性增长的能力</u>。它关注的是系统如何有效地应对不可预测和可变的用户流量高峰。例如，音乐会售票系统在门票开售时会经历用户流量的突然飙升，这需要高弹性的支持。一个具有弹性的系统能够在流量高峰时动态地启动新的处理单元（Processing Units），并在负载降低时关闭它们</li></ul><p>简而言之，可伸缩性是关于处理增加的负载并保持性能，而弹性是关于处理突发性、不可预测的负载波动。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第五章的课后思考题，深入探讨如何识别架构特征，分析限制架构特性数量的重要性、架构特性的来源、业务驱动与架构特性的关系，以及可伸缩性与弹性等关键特性的区别，帮助理解如何从业务需求中提取和选择合适的架构特性。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
