<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HedonWang</title>
  
  <subtitle>君子求诸己，律己则安。</subtitle>
  <link href="https://hedon.top/atom.xml" rel="self"/>
  
  <link href="https://hedon.top/"/>
  <updated>2025-07-27T04:31:56.167Z</updated>
  <id>https://hedon.top/</id>
  
  <author>
    <name>Hedon Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大白话解释反向传播算法</title>
    <link href="https://hedon.top/2025/07/27/back-propagation/"/>
    <id>https://hedon.top/2025/07/27/back-propagation/</id>
    <published>2025-07-27T04:30:20.000Z</published>
    <updated>2025-07-27T04:31:56.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一核心思想一个-分锅-大会">一、核心思想：一个 “分锅” 大会</h3><p>想象一下，你是一个大公司的CEO，你的公司有一个很长的流水线，用来生产一个精密的产品。这条流水线有很多道工序，每道工序都有一个工人负责。</p><ol type="1"><li><strong>最终产品出问题了</strong>：产品下线后，你发现最终的成品和设计图纸有偏差(比如，要求重 100 克，结果做出来重 110 克)。这个 “10 克的偏差” 就是<strong>误差 (Error)</strong>。</li><li><strong>你作为 CEO开始追责</strong>：你肯定不会把所有人都骂一顿，或者随机开除一个工人。最科学的方法是<strong>从后往前</strong>追查。</li><li><strong>追责第一步</strong>：你首先找到<strong>最后一道工序</strong>的工人。因为他是直接影响成品的人。你对他说：“产品重了 10克，你的操作对最终重量影响最大，你先调整一下你的机器参数。”</li><li><strong>追责第二步</strong>：这个工人会说：“老板，我这道工序的产出，也受到<strong>上一道工序</strong>给我的半成品的影响啊。根据我的机器参数，我可以计算出，上一个工人交给我的半成品大概是重了8 克导致的。”</li><li><strong>追责第三步</strong>：于是，你又拿着这个 “8 克的偏差” 去找<strong>倒数第二个工人</strong>。这个工人也同样会计算他受到了他上游工序的影响。</li><li><strong>一路向前追溯</strong>：就这样，这个 “锅” (误差)从最后一个工人开始，一层一层地<strong>向前传递</strong>，每个工人都根据自己的 “责任” 大小，领走一部分“锅”，并对自己的机器参数做出微小的调整。</li></ol><p>这个从后往前追责、分锅、调整的过程，就是 <strong>反向传播</strong>的核心思想。</p><h3 id="二从比喻到神经网络">二、从比喻到神经网络</h3><p>现在，我们把上面的比喻翻译成神经网络的术语：</p><table><colgroup><col style="width: 17%" /><col style="width: 30%" /><col style="width: 52%" /></colgroup><thead><tr><th>大白话比喻</th><th>神经网络术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>流水线</strong></td><td><strong>神经网络 (Neural Network)</strong></td><td>由多个层级组成，数据从输入层流向输出层。</td></tr><tr><td><strong>工人</strong></td><td><strong>神经元 (Neuron)</strong></td><td>网络中的计算单元。</td></tr><tr><td><strong>工人的机器参数</strong></td><td><strong>权重 (Weights) 和 偏置 (Biases)</strong></td><td>每个神经元里需要学习和调整的参数，就像机器的旋钮。</td></tr><tr><td><strong>最终产品</strong></td><td><strong>网络的预测输出 (Prediction)</strong></td><td>比如，给一张猫的图片，网络输出 “90% 是狗”。</td></tr><tr><td><strong>设计图纸</strong></td><td><strong>真实标签 (True Label)</strong></td><td>正确答案，比如 “100% 是猫”。</td></tr><tr><td><strong>产品偏差</strong></td><td><strong>损失/误差 (Loss / Error)</strong></td><td>预测输出和真实标签之间的差距。由 <strong>损失函数 (LossFunction)</strong> 计算得出。</td></tr><tr><td><strong>从后往前追责分锅</strong></td><td><strong>反向传播 (Backpropagation)</strong></td><td>将总误差从输出层开始，一层层向输入层传播，计算出每一层权重对总误差的“贡献度”。</td></tr><tr><td><strong>调整机器参数</strong></td><td><strong>权重更新 (Weight Update)</strong></td><td>使用一种叫做 <strong>梯度下降 (Gradient Descent)</strong>的方法，根据计算出的“贡献度”来微调网络中所有的权重，目的是让总误差变小。</td></tr></tbody></table><h3 id="三核心工具微积分里的-链式法则">三、核心工具：微积分里的“链式法则”</h3><p>你可能会问，每个工人是怎么精确计算出他应该背多大的“锅”呢？</p><p>这里的“锅”在数学上，就是 <strong>梯度(Gradient)</strong>，简单理解就是 <strong>导数</strong>。导数衡量的是“如果我稍微动一下这个参数，最终的误差会改变多少”。</p><ul><li>如果导数很大(无论是正还是负)，说明这个参数对最终误差的影响很大，是“主要责任人”，需要大幅调整。</li><li>如果导数很小，接近0，说明它基本没啥影响，是“吃瓜群众”，基本不用动。</li></ul><p>反向传播算法的数学精髓，就是应用了微积分里的 <strong>链式法则 (ChainRule)</strong>。</p><p><strong>链式法则通俗解释</strong>：如果 C 的变化依赖于 B，而 B的变化又依赖于 A，那么链式法则可以帮助我们计算出 A 的微小变化最终会对 C产生多大的影响。</p><p>在神经网络里，最终的误差 (Loss) 是输出层 (Output Layer)的函数，输出层又是前一个隐藏层 (Hidden Layer)的函数，以此类推，直到输入层。反向传播正是利用链式法则，高效地计算出<strong>总误差</strong> 相对于 <strong>网络中每一个权重</strong>的梯度(导数)。它就像一套完美的公式，能精确地把“锅”不多不少、恰如其分地分配给每一个相关的参数。</p><h3 id="四总结反向传播的完整流程">四、总结：反向传播的完整流程</h3><p>所以，神经网络的学习过程（训练）可以总结为以下循环往复的步骤：</p><ol type="1"><li><strong>正向传播 (Forward Pass)</strong>：<ul><li>给网络一个输入数据 (例如一张图片)。</li><li>数据从输入层开始，经过每一层神经元的计算(乘以权重，加上偏置，再通过激活函数)，最后到达输出层，得到一个预测结果。</li><li>这就像把原材料放上传送带，走完整条流水线，得到最终产品。</li></ul></li><li><strong>计算损失 (Calculate Loss)</strong>：<ul><li>用损失函数比较网络的预测结果和真实的正确答案，计算出它们之间的差距，即总误差(Loss)。</li><li>这就像质检员检查最终产品，看它和设计图纸差了多少。</li></ul></li><li><strong>反向传播 (Backward Pass / Backpropagation)</strong>：<ul><li>这是最关键的一步。从总误差出发，利用链式法则，从输出层开始，反向逐层计算出网络中<strong>每一个权重</strong> 对这个总误差的“贡献度”(梯度)。</li><li>这就像 CEO 拿着质检报告，从后往前追责，精确地给每个工序“分锅”。</li></ul></li><li><strong>更新权重 (Update Weights)</strong>：<ul><li>根据反向传播计算出的“贡献度”(梯度)，使用梯度下降等优化算法，对网络中所有的权重进行微小的调整。调整的方向是<strong>让总误差变小</strong> 的方向。</li><li>这就像每个工人接到“整改通知”后，都去微调自己的机器旋钮。</li></ul></li></ol><p>通过成千上万次地重复以上 4个步骤，网络中的所有权重会逐渐被调整到最优状态，使得网络在接收新的输入时，能够做出非常准确的预测。</p><p>简单来说，<strong>反向传播就是神经网络高效学习的秘诀，它通过一个巧妙的“从后往前分锅”机制，告诉网络里的每一个参数应该如何自我调整，才能让最终的预测结果越来越准。</strong></p>]]></content>
    
    
    <summary type="html">大白话解释反向传播算法</summary>
    
    
    
    <category term="机器学习" scheme="https://hedon.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://hedon.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://hedon.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记丨《Fundamentals of Software Architecture》</title>
    <link href="https://hedon.top/2025/07/24/note-fosa/"/>
    <id>https://hedon.top/2025/07/24/note-fosa/</id>
    <published>2025-07-24T03:01:24.000Z</published>
    <updated>2025-07-27T04:29:14.333Z</updated>
    
    <content type="html"><![CDATA[<h1id="聊架构设计的时候我们在谈什么">聊架构设计的时候，我们在谈什么？</h1><p><strong>第一步：理解商业与组织上下文 (Understand Business &amp;Organizational Context)</strong></p><ul><li><strong>利益相关方 (Stakeholders)</strong>:他们的核心诉求和期望是什么？</li><li><strong>用户视角 (User Perspective)</strong>:我们要为用户解决什么核心痛点？</li><li><strong>商业目标 (Business Goals)</strong>:这个项目要达成什么商业指标？（例如：降低成本、提升转化率）</li><li><strong>组织能力 (Organizational Capabilities)</strong>:<ul><li>公司文化 (Company Culture): 我们的文化是拥抱变化还是追求稳定？</li><li>团队现状 (Team Status): 团队的技术栈、技能水平和规模如何？</li></ul></li></ul><p><strong>第二步：定义架构特性与约束 (Define ArchitecturalCharacteristics &amp; Constraints)</strong></p><p>这一步的目标是将第一步中模糊的需求，转化为具体、可度量的技术目标。</p><ul><li><strong>识别架构特性 (Identify Architectural Characteristics /-ilities)</strong>:<ul><li>从性能、可伸缩性、可用性、容错性、可维护性、安全性、成本等特性中，识别出本次设计<strong>最关键</strong>的3-5 个。</li><li><strong>对它们进行排序</strong>。例如，对于一个后台管理系统，“可维护性”的优先级可能就高于“性能”。</li></ul></li><li><strong>明确约束条件 (Define Constraints)</strong>:<ul><li>有哪些不可逾越的红线？例如：预算上限、上线日期 (Time toMarket)、必须使用公司内某技术平台、法律合规要求等。</li></ul></li></ul><p><strong>第三步：探索方案与决策 (Explore Solutions &amp; MakeDecisions)</strong></p><p>有了第二步清晰的目标和边界，我们现在可以带着这些标准去评估方案。</p><ul><li><strong>探索可选方案 (Explore Options)</strong>: 至少寻找 2-3个备选方案。</li><li><strong>进行权衡分析 (Analyze Trade-offs)</strong>:基于第二步定义的<strong>架构特性优先级</strong>，系统地对比各方案的优劣。</li><li><strong>评估风险 (Assess Risks)</strong>:每个方案可能引入哪些短期或长期的技术、成本、人员风险？</li><li><strong>记录决策 (Document Decisions)</strong>: 使用 ADR(Architecture Decision Record) 记录最终选择和放弃的原因。</li></ul><p><strong>第四步：设计实施路径与验证机制 (Design Implementation Path&amp; Verification)</strong></p><p>在真正开始大规模编码前，设计好如何走，以及如何验证我们走在正确的路上。</p><ul><li><strong>实施计划 (Implementation Plan)</strong>:<ul><li>是否需要技术原型 (PoC) 来验证关键难点？</li><li>如何进行任务拆解和里程碑规划？</li></ul></li><li><strong>构建适应度函数 (Build Fitness Functions)</strong>:<ul><li>针对第二步定义的关键架构特性，设计具体的“检验尺”。</li><li>例如：为保证“模块解耦”，设计一个静态代码检查规则，禁止模块间的非法调用。</li></ul></li><li><strong>知识沉淀 (Knowledge Sedimentation)</strong>:准备好核心的架构图、设计文档等。</li></ul><p><strong>第五步：部署、观测与效果衡量 (Deploy, Observe &amp; MeasureEffectiveness)</strong></p><p>将架构推向真实世界，并通过数据验证其价值。</p><ul><li><strong>持续交付 (CI/CD)</strong>:作为将设计快速、可靠地部署到生产环境的手段。</li><li><strong>系统监控 (System Monitoring)</strong>:观测系统的健康状况（CPU、内存、延迟、错误率等）。</li><li><strong>业务指标验证 (Business Metrics Verification)</strong>:<strong>（闭环关键）</strong>验证是否达成了第一步定义的商业目标？例如，新架构上线后，用户转化率是否真的提升了？</li></ul><p><strong>第六步：复盘、沉淀与演进 (Retrospect, Internalize &amp;Evolve)</strong></p><ul><li><strong>问题记录与根因分析 (Problem Record &amp; Root CauseAnalysis)</strong>: 发生了什么？为什么会发生？</li><li><strong>流程与原则改进 (Process &amp; PrincipleImprovement)</strong>:如何优化我们的设计流程、技术原则，避免未来再犯？</li><li><strong>人员与组织成长 (Personnel &amp; OrganizationalGrowth)</strong>: 团队通过这次项目学到了什么？需要组织哪些培训？</li></ul><h1 id="fundamentals-of-software-architectrue-笔记梳理">Fundamentals ofSoftware Architectrue 笔记梳理</h1><h2 id="理解商业与组织上下文">1. 理解商业与组织上下文</h2><blockquote><p>利益相关方：他们的核心诉求和期望是什么？</p><p>用户视角：我们要为用户解决什么核心痛点？</p><p>商业目标：这个项目要达成什么商业指标？</p><p>组织能力：我们的文化是拥抱变化还是追求稳定？团队的技术栈、技能水平和规模如何？</p></blockquote><h3 id="谈判技巧">1.1 谈判技巧</h3><p>FOSA指出，架构师必须理解并驾驭企业的<strong>政治环境</strong>。几乎每一个架构决策都会受到挑战，这可能来自产品负责人、项目经理、业务利益相关方（因为成本或时间增加），甚至是开发者（认为有更好的方法）。</p><p>因此，架构师需要具备卓越的<strong>谈判和引导技能</strong>(Negotiation andFacilitation)，以理解各方诉求，并在分歧出现时达成共识。</p><p>FOSA 给出了几种谈判思路：</p><ol type="1"><li><strong>利用语法和流行语更好地理解情况。</strong>软件架构师应注意业务利益相关者在沟通中使用的短语和流行语。例如，像“我们需要零停机时间”或“我昨天就需要这些功能”这样的表述，虽然可能不精确，但却能揭示出对可用性或上市时间等方面的真正关注。通过利用这些“废话语法”，架构师可以更好地理解对方真正的担忧和需求，从而在谈判中占据优势。</li><li><strong>在进入谈判之前收集尽可能多的信息。</strong>在谈判之前，架构师应尽可能多地收集相关信息。例如，如果业务利益相关者坚持“五个九”的可用性（99.999%），架构师应提前研究这意味着什么，并将其转化为实际的停机时间（例如，每年约31.5秒的计划外停机时间）。充分掌握事实和数据有助于进行基于现实的讨论。</li><li><strong>当一切都失败时，说明成本和时间。</strong>这是最后的谈判策略。尽管成本和时间（投入的工作量）是任何谈判中的关键因素，但应作为最后的手段使用。过早提及这些可能会使谈判陷入僵局，因为它们可能会被视为阻止或拒绝的借口。</li><li><strong>利用“分而治之”的原则来限定需求。</strong>这一策略借鉴了孙子兵法中的思想，即“其力合者，离之”。当面临不合理或范围过大的要求时（例如，整个系统都需要“五个九”的可用性），架构师可以通过提问来缩小范围，确定哪些特定部分或功能真正需要这种高水平的特性。这样做可以减少困难且昂贵需求的范围，从而简化谈判。</li><li><strong>永远记住演示胜于讨论。</strong>当与同事或开发人员在技术方法上存在分歧时，与其争论不休，不如通过实际的演示来证明你的观点。例如，如果你认为消息队列比REST 更适合特定的服务间通信，可以在模拟生产环境中进行 A/B测试，用数据和实际结果来说服对方。实际操作的证据通常比理论争论更有说服力。</li><li><strong>在谈判中避免过于争辩或让事情变得过于个人化——冷静的领导力结合清晰简洁的推理总能赢得谈判。</strong>在讨论中，如果气氛变得过于激烈或个人化，最好的做法是暂停谈判，待双方冷静后再重新进行。作为领导者，保持冷静和专业的态度，并用清晰、简洁的逻辑进行推理，往往能够有效化解冲突，促使对方退让，最终达成共识。</li><li><strong>在说服开发人员采纳架构决策或执行特定任务时，提供理由而不是“高高在上地发号施令”。</strong>架构师不应凭借职位来命令开发人员，而应通过提供充分的理由来说明为什么需要某个架构决策或任务。例如，解释“所有数据库调用都需要通过业务层”是为了“更好地控制变更”，这比单纯命令“你必须通过业务层”更容易被接受。理解背后的原因能促使开发人员更积极地接受并实施决策。</li><li><strong>如果开发人员不同意某个决策，让他们自己找到解决方案。</strong>当开发人员对某个技术决策有异议时，与其直接反驳，不如挑战他们，让他们自己去探索并证明他们的替代方案。例如，如果开发人员坚持使用某个框架但你认为它不符合安全要求，可以让他们自行研究并展示如何解决安全问题。这不仅能促进开发人员的学习和思考，也能让架构师在最终解决方案上获得团队的认可和支持，形成双赢局面。</li></ol><h3 id="业务理解">1.2 业务理解</h3><p>架构决策必须<strong>提供业务价值</strong>。如果一个架构决策没有业务价值，它可能就不是一个好的决策，需要重新考虑。</p><p>FOSA强调，架构决策的<strong>商业合理性</strong>至关重要。常见的商业合理性包括：<strong>成本</strong>(Cost)、<strong>上市时间</strong> (Time toMarket)、<strong>用户满意度</strong> (User Satisfaction)和<strong>战略定位</strong> (StrategicPositioning)。在与业务利益相关方谈判时，要重点关注他们最看重的指标。</p><p>这里面的一大难点就是：<strong>业务方与开发方使用的不是同一种"语言"</strong>。双方对同一件事情的关注点是不一样的，所以表述出来的述求，也是不同的。所以架构师的职责就是需要将业务领域的关注点和架构特性进行对应。</p><p>比如：</p><table><colgroup><col style="width: 36%" /><col style="width: 63%" /></colgroup><thead><tr><th>Domain Concern</th><th>Architecture characteristics</th></tr></thead><tbody><tr><td>Mergers and acquisitions 合并与收购</td><td>互操作性 interoperability<br>可扩展性 scalability<br>适配性adaptability<br>可扩展性 extensibility</td></tr><tr><td>Time to market 上市时间</td><td>灵活性 agility<br/>可测试性 testability<br/>可部署性deployability</td></tr><tr><td>User satisfaction 用户满意度</td><td>性能 performance<br/>可用性 availability<br/>容错性 faulttolerance<br/>可测试性 testability<br/>可部署性 deployability<br/>灵活性agility<br/>安全性 security</td></tr><tr><td>Competitive advantage 竞争优势</td><td>灵活性 agility<br/>可测试性 testability<br/>可部署性deployability<br/>可扩展性 scalability<br/>可用性availability<br/>容错性 fault tolerance</td></tr><tr><td>Time and budget 时间和预算</td><td>简单性 simplicity<br/>可行性 feasibility</td></tr></tbody></table><p>另外，随着业务的发展，关注点也是在不断发生变化的，这个时候，架构所侧重的架构特性也是随之改变。</p><h2 id="定义架构特性与约束">2. 定义架构特性与约束</h2><blockquote><p>识别架构特性：从性能、可伸缩性、可用性、容错性、可维护性、安全性、成本等特性中，识别出本次设计最关键的3-5 个。</p><p>明确约束条件：有哪些不可逾越的红线？</p></blockquote><h3 id="架构特性定义">2.1 架构特性定义</h3><p>架构师的核心职责之一就是识别和定义系统的<strong>架构特性</strong>(ArchitectureCharacteristics)。这些特性定义了系统的<strong>成功标准</strong>，并且通常与系统的<strong>功能性</strong>(Functionality) 正交。</p><p>一个属性要成为架构特性（Architecture Characteristics），需至少满足 3个条件：</p><ol type="1"><li><strong>指定非领域设计考量</strong>：架构特性关注的是应用程序"如何"实现需求以及做出某些选择"为何"的原因，而不是应用程序"应该做什么"的业务需求。例如，性能水平通常不会出现在需求文档中，但却是重要的架构特性。</li><li><strong>影响设计的某个结构方面</strong>：如果一个架构特性需要特殊结构考虑才能成功，那么它就会上升到架构特性的层面。例如，一般的安全性对于几乎所有项目都是必需的，但当需要设计特定的模块、组件或服务来隔离关键安全问题时，安全才成为一个架构特性。</li><li><strong>对应用程序的成功至关重要</strong>：应用程序可以支持大量的架构特性，但并非所有都应该被支持。支持每个架构特性都会增加设计的复杂性，因此，架构师的关键任务是选择最少的、对应用程序成功至关重要或重要的架构特性，而不是尽可能多的。</li></ol><h3 id="架构特性类型">2.2 架构特性类型</h3><ul><li><strong>显性架构特性</strong>：是在需求规范中明确列出的，作为必要设计的一部分。它们通常直接出现在需求文档或其他具体说明中。</li><li><strong>隐性架构特性</strong>：很少出现在需求文档中，但它们对于项目的成功是必需的。架构师必须利用他们对问题领域的知识，在分析阶段发现这些特征。</li></ul><p>可进一步细分为：操作特性、结构特性和交叉特性。</p><p>操作性架构特性涵盖了系统的<strong>运行能力</strong>，例如性能、可伸缩性、弹性、可用性和可靠性等。这些特性通常与运营和DevOps 关注点高度重叠。</p><table><colgroup><col style="width: 23%" /><col style="width: 76%" /></colgroup><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>Availability</td><td>系统需要保持可用的时间长度；例如，如果需要 24/7可用，则需要采取措施确保系统始终可用。它指的是软件可操作和可访问的程度。</td></tr><tr><td>Continuity</td><td>灾难恢复能力。</td></tr><tr><td>Performance</td><td>衡量应用程序请求和响应周期所需的时间。它包括压力测试、高峰分析、功能使用频率分析、所需容量和响应时间。它也可以是更具体的度量，例如首屏渲染时间，即网页首次可见的时间。</td></tr><tr><td>Recoverability</td><td>业务连续性要求（例如，发生灾难时，系统需要多快才能重新上线？）这将影响备份策略和对复制硬件的要求。它也指软件从故障中恢复的能力，通过恢复任何受影响的数据并重新建立系统的所需状态。</td></tr><tr><td>Reliability/Safety</td><td>评估系统是否需要具备故障安全能力，或者其任务关键性是否影响生命。如果系统发生故障，是否会给公司带来巨额损失。它指系统在指定条件下和指定时间内运行的程度。</td></tr><tr><td>Robustness</td><td>在互联网连接中断、断电或硬件故障时，处理错误和边界条件的能力。</td></tr><tr><td>Scalability</td><td>系统随着用户或请求数量的增加而执行和运行的能力。这意味着处理大量并发用户而不会出现严重的性能下降。</td></tr></tbody></table><p>结构性架构特性关注<strong>代码结构</strong>。在许多情况下，架构师对代码质量问题负有独立或共同的责任，例如良好的模块化、组件间的受控耦合、可读性强的代码以及其他内部质量评估。</p><table><colgroup><col style="width: 25%" /><col style="width: 74%" /></colgroup><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>Configurability</td><td>最终用户通过可用界面轻松更改软件配置方面的能力。</td></tr><tr><td>Extensibility</td><td>系统的可扩展性。</td></tr><tr><td>Installability</td><td>系统在所有必要平台上安装的便捷性。它指软件在指定环境中安装和/或卸载的程度。</td></tr><tr><td>Leverageability/Reuse</td><td>跨多个产品利用通用组件的能力。它指开发人员在多个系统或构建其他资产中重复使用资产的程度。</td></tr><tr><td>Maintainability</td><td>开发人员修改、纠正或使其适应环境和/或需求变化的有效性和效率程度。</td></tr><tr><td>Portability</td><td>系统是否需要在多个平台上运行。它指开发人员将系统、产品或组件从一个硬件、软件或其他操作或使用环境转移到另一个环境的程度。</td></tr><tr><td>Supportability</td><td>应用程序所需的技术支持级别。系统中调试错误所需的日志记录及其他设施的级别。</td></tr><tr><td>Upgradeability</td><td>从该应用程序/解决方案的旧版本轻松/快速升级到新版本的能力。</td></tr></tbody></table><p>交叉架构特性指的是那些难以归类或超出传统类别，但却形成重要设计约束和考虑的特性。</p><table><colgroup><col style="width: 27%" /><col style="width: 72%" /></colgroup><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>Accessibility</td><td>确保所有用户（包括色盲或听力障碍等残障用户）能够访问系统。它指使软件可供具有最广泛特征和能力的人使用。</td></tr><tr><td>Archivability</td><td>数据是否需要在一段时间后归档或删除。</td></tr><tr><td>Authentication</td><td>确保用户是其所声称的身份的安全要求。</td></tr><tr><td>Authorization</td><td>确保用户只能访问应用程序内特定功能（按用例、子系统、网页、业务规则、字段级别等）的安全要求。</td></tr><tr><td>Legal</td><td>系统在哪些法律约束下运行（数据保护、萨班斯-奥克斯利法案、GDPR等）？公司需要哪些保留权利？关于应用程序构建或部署方式的任何规定。</td></tr><tr><td>Privacy</td><td>隐藏内部公司员工交易信息的能力（加密交易，甚至数据库管理员和网络架构师都无法查看）。</td></tr><tr><td>Security</td><td>数据是否需要在数据库中加密？内部系统之间网络通信是否需要加密？远程用户访问需要何种类型的认证？它指软件保护信息和数据的程度，以便人员或其他产品或系统具有与其授权类型和级别相称的数据访问程度。</td></tr><tr><td>Supportability</td><td>应用程序所需的技术支持级别。系统中调试错误所需的日志记录及其他设施的级别。</td></tr><tr><td>Usability/Achievability</td><td>用户使用应用程序/解决方案实现目标所需的培训水平。它指用户可以有效、高效、满意地使用系统达到预期目的。</td></tr></tbody></table><h3 id="架构特性选择">2.3 架构特性选择</h3><p>架构特性不是越多越好：</p><ul><li><strong>增加系统设计的复杂性</strong>：每增加一个架构特性，都会使整个系统设计变得更加复杂。支持过多的架构特性会导致在架构师和开发人员开始解决核心业务问题之前，系统就变得越来越复杂。</li><li><strong>分散对核心问题的关注</strong>：架构特性定义了系统的成功标准，通常与系统的功能性正交，关注的是“如何”实现需求以及“为什么”做出某些选择。然而，如果过度追求特性数量，可能会导致偏离原始的业务问题，即开发软件的最初动机。</li><li><strong>每个特性都涉及权衡</strong>：软件架构中的每一个方面都存在权衡，有优点也有缺点。例如，在拍卖系统中，选择使用主题（topic）进行通信可能带来架构可扩展性的优势和服务的解耦，但会引入数据访问和数据安全方面的潜在问题，并且不支持异构契约。而使用队列（queue）则允许每个消费者拥有自己的契约，但不具备可扩展性，并且会增加服务间的耦合。架构师需要分析这些权衡，并根据业务驱动因素和环境选择最重要的特性。</li><li><strong>过度规范的危害</strong>：架构师过度规范架构特性是常见的陷阱，其破坏性不亚于规范不足，因为它会使系统设计过于复杂。历史案例“瓦萨号”战舰的失败就是一个例证，它是因为过度追求建造最宏伟的战舰（即过度规范架构特性）而最终导致沉没。</li><li><strong>陷入“意外复杂性”陷阱</strong>：架构师有时会为解决方案、图表和文档添加不必要的复杂性。正如一位作者所言，“开发者被复杂性吸引，就像飞蛾扑火一样——结果往往相同”。这种“意外复杂性”是由于人为地使问题复杂化，而不是问题本身固有的复杂性。通过识别子领域类型并根据其业务逻辑的复杂性选择合适的实现模式（例如，事务脚本和活动记录适用于简单业务逻辑，而领域模型和事件溯源领域模型适用于复杂的核心子领域），可以避免引入不必要的复杂性。</li><li><strong>设计应由业务驱动</strong>：领域驱动设计（DDD）的核心思想在于让业务领域驱动软件设计决策。这意味着设计决策应该基于业务领域的需求和战略，而非盲目地堆砌所有可能的架构特性。</li></ul><p>因此，与领域利益相关者合作时，架构师应努力使最终的架构特性列表尽可能短，因为每个特性都会增加总体系统设计的复杂性。</p><h2 id="探索方案与决策">3. 探索方案与决策</h2><blockquote><p>探索可选方案 ：至少寻找 2-3 个备选方案。</p><p>进行权衡分析：基于第二步定义的架构特性优先级，系统地对比各方案的优劣。</p><p>评估风险：每个方案可能引入哪些短期或长期的技术、成本、人员风险？</p><p>记录决策：使用 ADR (Architecture Decision Record)记录最终选择和放弃的原因。</p></blockquote><h3 id="架构风格">3.1 架构风格</h3><h4 id="分层架构-layered-architecture">3.1.1 分层架构 LayeredArchitecture</h4><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/layer.png"alt="3.1.1 分层架构" /><figcaption aria-hidden="true">3.1.1 分层架构</figcaption></figure><p>分层架构的<strong>核心驱动力</strong>是<strong>关注点分离（SeparationofConcerns）</strong>。它将一个复杂的系统按照不同的职责或技术关注点，垂直地划分成若干个水平的“层（Layer）”。</p><p>这些层之间存在一个至关重要的约束：<strong>依赖关系是单向的</strong>。通常来说，上层可以依赖下层，但下层绝对不能依赖上层。例如，表现层可以调用业务逻辑层，但业务逻辑层不应该知道任何关于表现层的具体实现细节。</p><p>优点：</p><ul><li><strong>简单性（Simplicity）和低成本（Cost）</strong>：分层架构模式非常成熟，广为人知，开发团队的学习成本极低。对于中小型项目、预算有限的初创公司或内部管理系统，它是一个"足够好"的、性价比极高的起点。</li><li><strong>可维护性（Maintainability）</strong>：如前所述，只要遵循了隔离层原则，系统的维护和迭代会非常清晰。对于那些业务逻辑相对稳定、变更不频繁的系统，这是一个巨大的优势。</li><li><strong>整体可部署性（Deployability）</strong>：分层架构天然倾向于构建<strong>单体应用（Monolith）</strong>。整个应用被打包成一个单元（例如一个WAR包或一个可执行文件）进行部署。这极大地简化了部署和运维的复杂度，尤其是在项目早期或运维能力有限的团队中。</li></ul><p>缺点：</p><ul><li><strong>技术分区而非领域分区</strong>：分层架构是一种技术分区架构。这意味着它的组件是根据其在架构中的技术角色（如表示层、业务层、持久层），而不是根据业务领域（如客户、订单）进行分组的。这会导致任何特定的业务领域（例如“客户”领域）的逻辑都会分散在架构的所有层中。同时，当需要对特定业务领域的需求进行更改时，由于其逻辑分散在多个技术层中，开发人员必须在所有相关层中进行修改，这降低了开发的敏捷性。</li><li><strong>部署风险高</strong>：在分层架构中，即使是对少量代码的更改（例如，一个类文件中简单的三行更改），也需要重新部署整个部署单元。这种部署往往会捆绑数十个其他更改，从而显著增加了部署风险，且部署频率受到限制。</li><li><strong>测试范围大且不完整</strong>：由于整个应用程序是作为一个大型单体单元部署的，开发人员通常不会为简单的三行更改花费数小时执行完整的回归测试套件。这导致测试覆盖范围不完整，并且难以确保更改不会影响看似不相关的部分。</li></ul><h4 id="管道架构-pipeline-architecture">3.1.2 管道架构 PipelineArchitecture</h4><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250715105907327.png"alt="3.1.2 管道架构" /><figcaption aria-hidden="true">3.1.2 管道架构</figcaption></figure><p>管道架构，又称为管道与过滤器架构（Pipes and FiltersArchitecture），是一种用于处理数据流的强大模式。它的核心思想非常直观，就像一条工厂的流水线：原材料从一端进入，经过一系列独立工站的加工、处理、检验，最终在另一端形成成品。</p><p>要理解管道架构，首先要理解它的两个基本构件：</p><ul><li><strong>过滤器(Filter)</strong>：它是一个独立的、可执行的处理单元，负责接收数据、执行单一任务（例如转换格式、过滤内容、扩充信息），然后将处理后的数据传递出去。关键在于，每个过滤器都是<strong>自包含（Self-Contained）</strong>和<strong>无状态（Stateless）</strong>的，它不关心上一个过滤器是谁，也不关心下一个过滤器是谁。</li><li><strong>管道(Pipe)</strong>：代表流水线上的"传送带"。它是一个<strong>单向</strong>的数据通道，负责将一个过滤器处理完的数据传递给下一个过滤器。</li></ul><p>过滤器一般又分为 4 种：</p><ul><li><strong>生产者 (Producer /Source)</strong>：作为整条管道的<strong>起点</strong>。它不接收来自管道的数据，而是负责创建数据，并将这些初始数据泵入管道。</li><li><strong>转换器(Transformer)</strong>：它从上游管道接收数据，对其进行某种形式的<strong>修改或转换</strong>，然后将结果发送到下游管道。</li><li><strong>测试器(Tester)</strong>：它接收数据，并根据一个或多个条件对数据进行<strong>检验</strong>。如果数据满足条件，就将其传递到下游管道；如果不满足，则数据流在此处被中断（或被导向另一条错误处理管道）。</li><li><strong>消费者 (Consumer /Sink)</strong>：作为整条管道的<strong>终点</strong>。它从上游管道接收最终处理好的数据，并将其消费掉，通常不会再将数据传递出去。</li></ul><p>优点:</p><ul><li><strong>成本低且简单</strong>：作为一种单体架构，管道架构不具备分布式架构风格所带来的复杂性，因此它简单易懂，并且构建和维护成本相对较低。</li><li><strong>高模块化</strong>：通过不同过滤器类型之间关注点的分离，实现了架构的模块化。任何过滤器都可以修改或替换而不影响其他过滤器。</li><li><strong>部署性和可测试性较好</strong>：由于其模块化程度较高，部署性和可测试性略优于分层架构，但仍受单体应用固有的部署仪式、风险和测试完整性等因素的影响。</li></ul><p>缺点:</p><ul><li><strong>单体特性带来的限制</strong>：尽管在模块化方面有所改进，但它仍然是一种单体应用。这意味着部署的仪式感、风险、部署频率以及测试的完整性都会受到单体特性的影响。例如，对任何更改都需要测试和部署整个单体应用。</li><li><strong>弹性低</strong>：由于其单体部署和缺乏架构模块化，管道架构的弹性评级非常低（一星）。尽管可以在单体内部实现某些功能的伸缩，但这通常需要复杂的设计技术，而管道架构并不擅长此道。</li><li><strong>可伸缩性差</strong>：与弹性类似，由于是单体架构且缺乏模块化，可伸缩性也评级很低。应用程序的伸缩能力受限于单一系统量子。</li><li><strong>性能一般</strong>：管道架构不适合高性能系统，因为它缺乏并行处理能力、存在闭合分层（closedlayering）以及可能出现"架构下沉"（sinkhole anti-pattern）问题。</li></ul><h4 id="微核架构-microkernel-architecture">3.1.3 微核架构 MicrokernelArchitecture</h4><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250716105151041.png"alt="3.1.3 微核架构" /><figcaption aria-hidden="true">3.1.3 微核架构</figcaption></figure><p>微核架构，也被称为<strong>插件化架构（Plug-inArchitecture）</strong>，是一种能够提供极高扩展性、灵活性和演化能力的系统设计模式。它的核心思想是将系统功能划分为两部分：一个最小化的、稳定的<strong>核心系统（CoreSystem）</strong>和一个由独立<strong>插件组件（Plug-inComponents）</strong>构成的可扩展生态。</p><ul><li><strong>核心系统 (CoreSystem)</strong>：这是架构的"微核"。它的职责被严格限制在最小且必要的范围内，通常只包含：<ol type="1"><li>系统运行所必需的通用业务逻辑（例如，一个 IDE的文件管理和基础编辑器）。</li><li>一个至关重要的<strong>插件管理机制</strong>，包括插件的注册、发现、生命周期管理等。这是连接核心与插件的桥梁。</li></ol></li><li><strong>插件组件 (Plug-inComponents)</strong>：这些是独立的、可插拔的模块，用于实现<strong>扩展功能或特定业务逻辑</strong>。每个插件都通过一个由核心系统定义的<strong>标准契约（StandardContract）</strong>来与核心交互。这个契约通常是一个接口或一组 API。</li></ul><p>优点：</p><ul><li><strong>高模块化与扩展性</strong>：微内核架构通过插件组件实现了高度模块化和扩展性。应用程序逻辑被划分为核心系统和独立的插件组件，从而提供了可扩展性、适应性以及应用程序特性和自定义处理逻辑的隔离。任何插件都可以修改或替换而不影响其他组件，例如，添加一个新的电子设备评估逻辑只需添加一个新的插件组件并更新注册表。</li><li><strong>成本较低且相对简单</strong>：作为一种单体架构，微内核架构避免了分布式架构风格所带来的复杂性，因此它简单易懂，并且构建和维护成本相对较低。</li><li><strong>部署性和可测试性较好</strong>：由于其模块化程度较高，功能可以隔离到独立的插件组件中。如果做得好，这可以减少整体测试范围并降低部署风险，尤其是在运行时部署插件组件的情况下。因此，可部署性和可测试性略优于分层架构。</li><li><strong>领域与架构的同构性</strong>：微内核架构可以<strong>同时进行领域分区和技术分区</strong>。对于需要针对每个位置或客户端进行不同配置的问题，或者那些强调用户定制和功能扩展性的产品（例如Jira 或Eclipse IDE），这种架构风格非常适用。</li></ul><p>缺点：</p><ul><li><strong>单体特性带来的限制</strong>：尽管在模块化方面有所改进，但它<strong>仍然是一种单体应用</strong>。这意味着部署的仪式感、风险、部署频率以及测试的完整性都会受到单体特性的影响。</li><li><strong>弹性低</strong>：由于其单体部署和缺乏架构模块化，微内核架构的<strong>弹性评级非常低</strong>（一星）。尽管可以在单体内部实现某些功能的伸缩，但这通常需要复杂的设计技术。</li><li><strong>可伸缩性差</strong>：与弹性类似，由于是单体架构且缺乏模块化，可伸缩性也<strong>评级很低</strong>（一星）。所有请求都必须<strong>通过核心系统才能到达独立的插件组件</strong>。</li></ul><h4 id="基于服务的架构-service-based-architecture">3.1.4 基于服务的架构Service-Based Architecture</h4><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250717114456233.png"alt="3.1.4 基于服务的架构 SBA" /><figcaption aria-hidden="true">3.1.4 基于服务的架构 SBA</figcaption></figure><p>如果说单体（Monolith）和微服务（Microservices）是两个广为人知的端点，那么基于服务的架构（Service-BasedArchitecture,SBA）就是它们之间那个常常被忽略，却又极具现实意义的"务实中间派"。它既非庞大到笨拙，也非精细到繁杂，为许多成长中的系统提供了一条平滑的演进路径。</p><p>SBA的本质是一种将一个大型的单体应用，<strong>分解为少数几个、逻辑独立的、可独立部署的"服务"</strong>的架构风格。SBA 的服务数量通常不多，一般在 <strong>4 到 12个</strong>之间。它不像微服务那样追求极致的拆分（可能会有几十上百个服务），而是将应用按照<strong>核心的业务领域（Domain）</strong>进行划分。</p><p>与微服务不同的是 SBA的典型实现是，所有服务共享<strong>同一个数据库</strong>。这种设计的初衷是为了在享受独立部署带来的好处的同时，最大限度地<strong>降低数据层面的复杂性</strong>。共享数据库可以：</p><ul><li><strong>简化开发</strong>：开发者无需处理复杂的分布式事务和跨服务数据同步问题。</li><li><strong>保证数据一致性</strong>：传统的 ACID事务可以在数据库层面轻松实现。</li><li><strong>降低技术门槛</strong>：团队无需掌握复杂的分布式数据管理技术。</li></ul><p>随着业务发展，共享数据库的弊端会逐渐显现。在以下情况下，拆分数据库就成了合理的选择：</p><ol type="1"><li><strong>服务资源争用 (ServiceContention)</strong>：某个服务（如高流量的商品浏览服务）对数据库产生巨大压力，影响了其他关键服务（如订单服务）的性能。</li><li><strong>数据隔离与安全 (Data Isolation andSecurity)</strong>：某个服务处理的数据高度敏感（如支付服务中的金融信息），需要从主数据库中物理隔离出来，以满足合规性或安全要求。</li><li><strong>技术栈不匹配 (TechnologyMismatch)</strong>：某个服务有特殊的数据存储需求。例如，搜索服务最适合使用Elasticsearch，而核心业务数据则存储在关系型数据库中。</li></ol><p>当这些情况发生时，SBA允许你"渐进式"地将某个服务连同其数据一起剥离出去，赋予它独立的数据库。</p><p>优点：</p><ul><li><strong>可部署性(Deployability)</strong>：这是最大的优势之一。每个服务都可以独立部署，使得发布更加频繁、风险更低。</li><li><strong>模块化(Modularity)</strong>：通过按领域划分服务，实现了清晰的业务模块边界。</li><li><strong>可维护性(Maintainability)</strong>：每个服务的代码库规模远小于整个单体，更易于理解、修改和维护。</li><li><strong>容错性 (FaultTolerance)</strong>：一个服务的崩溃不会导致整个应用程序宕机（尽管共享数据库可能成为共同的故障点）。</li><li><strong>保留ACID事务</strong>：这是其相对于其他细粒度分布式架构（如微服务）的一大优势。由于领域服务是粗粒度的，事务通常限制在一个服务内部，可以利用传统的ACID 事务来保证<strong>数据完整性和一致性</strong>。</li></ul><p>缺点：</p><ul><li><strong>弹性低</strong>：尽管可以在单体内部实现某些功能的伸缩，但由于其单体部署和缺乏架构模块化，弹性评级仍然较低。</li><li><strong>可伸缩性受限</strong>：虽然可以扩展，但由于服务粒度较粗，与微服务等细粒度服务相比，在机器资源方面效率不高，成本效益也较低。</li><li><strong>部署风险</strong>：虽然比传统单体应用有所改进，但由于部署的代码量仍然较大，其<strong>部署风险</strong>仍然高于微服务架构。</li></ul><h4 id="事件驱动架构-event-driven-architecture">3.1.5 事件驱动架构Event-Driven Architecture</h4><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718110824820.png"alt="3.1.5 事件驱动架构" /><figcaption aria-hidden="true">3.1.5 事件驱动架构</figcaption></figure><p>在传统的<strong>请求驱动模型</strong>中，系统接收请求后会确定性地、同步地将请求路由到各个请求处理器来处理数据。而事件驱动模型则不同，它<strong>对特定情况做出反应，并根据该事件采取行动</strong>。</p><p>EDA 的力量源泉来自于异步通信，它有以下优点：</p><ol type="1"><li><strong>极高的系统韧性与可用性 (Resiliency andAvailability)</strong>：在同步调用中，如果服务 B 宕机，服务 A的调用会立刻失败，导致整个链路中断。但在异步模式下，服务 A将事件发送给一个中间人（消息代理），然后就可继续自己的工作。即使服务 B此时宕机，事件也会被安全地存放在代理中，待 B恢复后再进行处理。这使得系统能够优雅地处理局部故障，整体可用性大大提高。</li><li><strong>卓越的可伸缩性与弹性 (Scalability andElasticity)</strong>：生产者和消费者被完全解耦，可以独立进行伸缩。如果事件产生的速度突然加快，我们只需要增加消费者实例的数量即可，而无需对生产者做任何改动。这种按需、独立伸缩的能力是构建高弹性系统的关键。</li></ol><p>典型的 EDA 有 2种拓扑，分别为代理模式（broker）和中介者模式（mediator），二者最大的区别在于后者具有一个统一的协调者，这会对异常处理、全局统筹有很好的管控手段，当同时也牺牲了系统的解耦程度、灵活度和性能。</p><p>在 EDA 中，有几个典型的问题需要关注：</p><ul><li><p><strong>异常处理</strong>：可采用 workflow event pattern工作流事件模式。事件处理后，如果失败了，就告知<code>workflow process</code>。<code>workflow processor</code>识别错误，如果能自动处理，就自动处理，并丢回原始队列中，重新执行。如果不能处理，就放到dashbord 上，人工检查、校正或重试。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250725163511396.png"alt="workflow event pattern 工作流事件模式" /><figcaption aria-hidden="true">workflow event pattern工作流事件模式</figcaption></figure></li><li><p><strong>数据丢失</strong>：发送事件到 channel 的路上、channel转发事件到处理器的路上和处理器处理完持久化到 db的路上都有可能发生数据的丢失。可以通过同步发送、持久化队列、ACK机制和事务型 DB 来解决这个问题。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250725163644273.png"alt="防止 EDA 数据丢失的思路" /><figcaption aria-hidden="true">防止 EDA 数据丢失的思路</figcaption></figure></li><li><p><strong>返回响应</strong>：如果希望在事件驱动架构中实现请求-响应的能力，可以消息的两个元数据字段：<strong>回复地址(Reply-To)</strong> 和 <strong>关联标识 (Correlation ID)</strong>来通过回传通道返回响应数据。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718132839093.png"alt="EDA 返回响应数据的处理思路" /><figcaption aria-hidden="true">EDA 返回响应数据的处理思路</figcaption></figure></li></ul><p>优点：</p><ul><li><strong>可伸缩性与弹性 (Scalability &amp;Elasticity)</strong>：独立伸缩组件的能力是其核心优势。</li><li><strong>可扩展性(Extensibility)</strong>：系统极易扩展。当需要增加新功能时，只需开发一个新的服务来订阅感兴趣的现有事件即可，完全无需改动已有服务。</li><li><strong>响应性(Responsiveness)</strong>：对于需要快速响应用户的系统，可以将耗时任务异步化。例如，用户提交视频后，系统立即返回"上传成功，正在处理中"，然后通过事件驱动后台的转码、审核等一系列复杂流程。</li></ul><p>缺点：</p><ul><li><strong>简单性 (Simplicity)</strong>：EDA显著增加了系统的复杂性。你需要管理消息代理，处理异步编程的挑战（如调试、错误处理），并应对最终一致性带来的心智负担。</li><li><strong>事务性(Transactional)</strong>：实现跨多个服务的原子性操作（即分布式事务）变得异常困难。虽然可以通过Saga等模式来模拟长事务，但其实现复杂，且只能保证最终一致性而非强一致性。</li><li><strong>工作流的可观测性 (Observability ofWorkflow)</strong>：尤其是在代理拓扑中，业务流程被分散到各个独立的处理器中，没有一个集中的地方可以让你直观地看到一个完整的业务流程是如何执行的，这给监控和排错带来了巨大挑战。</li></ul><h4 id="空间架构-space-based-architecture">3.1.6 空间架构 Space-BasedArchitecture</h4><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250721175147426.png"alt="3.1.6 空间架构" /><figcaption aria-hidden="true">3.1.6 空间架构</figcaption></figure><p>传统三层 Web 拓扑在用户量剧增时呈倒三角：Web层易横向扩容，数据库层最难扩容，最终成为性能上限。为削弱数据库瓶颈，业界先用本地缓存，再出现集中式分布式缓存，但网络跳转仍是热点。把数据直接放到每个处理节点的<strong>复制型内存网格</strong>并实时同步，才真正让数据库从"同步路径"上消失，空间架构由此成形。</p><p>空间架构的名称来源于<strong>元组空间（TupleSpace）</strong>多个并行处理器通过共享内存进行通信。SBA的核心理念便是将应用数据保存在内存中（in-memory），并在所有活跃的处理单元（ProcessingUnits）复制，从而移除中心数据库作为同步约束，实现近乎无限的伸缩性。</p><p>空间架构由以下几个部分组成：</p><ul><li><p><strong>处理单元 Processing Unit：</strong></p><ul><li><p>处理单元包含了<strong>应用逻辑</strong>（包括基于 Web的组件和后端业务逻辑）。</p></li><li><p>它还包含一个<strong>内存数据网格</strong>和<strong>复制引擎</strong>，通常由Hazelcast、Apache Ignite 或 Oracle Coherence 等产品实现。</p></li><li><p>处理单元可以包含小型、单一用途的服务，类似于微服务</p></li></ul></li><li><p><strong>虚拟化中间件 VirtualizedMiddleware：</strong>虚拟化中间件负责处理架构中的基础设施问题，控制数据同步和请求处理。它由以下四个关键组件组成：</p><ul><li><p><strong>消息网格（MessagingGrid）</strong>：它负责将请求转发到任何可用的处理单元。</p></li><li><p><strong>数据网格（Data Grid）</strong>：它是 SBA中最重要和关键的组件，通常在处理单元内部以复制缓存的形式实现。它确保每个处理单元都包含完全相同的数据，数据复制是异步且快速的。</p></li><li><p><strong>处理网格（ProcessingGrid）</strong>：这是一个可选组件，用于管理<strong>协调请求处理</strong>，当一个业务请求涉及多个处理单元时，它会协调这些处理单元之间的请求。</p></li><li><p><strong>部署管理器（DeploymentManager）</strong>：该组件根据负载条件管理处理单元实例的<strong>动态启动和关闭</strong>，对于实现应用的弹性伸缩至关重要。</p></li></ul></li><li><p><strong>数据泵 DataPumps：</strong>数据泵是<strong>将数据发送到另一个处理器，然后该处理器更新数据库</strong>的方式。它们总是<strong>异步</strong>的，提供内存缓存与数据库之间的<strong>最终一致性（EventualConsistency）</strong>。消息机制是数据泵的常用实现方式，因为它支持异步通信、保证消息传递和维护消息顺序。</p></li><li><p><strong>数据写入器 Data Writers：</strong>数据写入器（DataWriters）负责接收来自数据泵的消息，并用消息中包含的信息更新数据库。它们可以是服务、应用或数据中心（如AbInitio）。写入器的粒度可以根据数据泵和处理单元的范围而变化，例如，领域驱动的数据写入器可以处理特定领域（如客户）内的所有更新。</p></li><li><p><strong>数据读取器 DataReaders：</strong>负责从数据库读取数据，并通过反向数据泵将其发送到处理单元。服务需要通过数据读取器访问数据的情况有三种：</p><ol type="1"><li>所有相同命名缓存的处理单元实例都崩溃时。</li><li>所有相同命名缓存的处理单元需要重新部署时。</li><li>需要检索复制缓存中不包含的归档数据时。</li></ol></li></ul><p>空间架构最大的一个问题就是<strong>数据冲突</strong>，不同的processing unit处理同一个业务逻辑相关的数据时，由于数据同步存在时序问题，所以很容易出现数据不一致的情况。</p><p>可以从以下几个因素进行冲突概率的评估：</p><ul><li>N：处理相同缓存的 processing unit 的数量</li><li>UR：缓存更新频率</li><li>S：缓存大小</li><li>RL：缓存复制的延迟</li></ul><blockquote><p>CollisitionRate = N × (UR<sup>2</sup>/S) × RL</p></blockquote><p>如果估算出来的冲突概率无法接受，或者需要缓存在内存中的业务数据过多而超过单机负载时，也可以使用<strong>分布式缓存</strong>来替代复制缓存。</p><p>优点：</p><ul><li><strong>弹性（Elasticity）</strong>：处理单元可以根据负载动态启停，实现高度弹性。</li><li><strong>伸缩性（Scalability）</strong>：通过内存数据缓存和移除数据库约束，支持处理数百万并发用户。</li><li><strong>性能（Performance）</strong>：移除了数据库瓶颈，提供了极高的性能。</li></ul><p>缺点：</p><ul><li><strong>简洁性（Simplicity）</strong>：SBA是一种<strong>非常复杂的架构风格</strong>，因为它涉及到缓存、最终一致性以及众多动态组件。</li><li><strong>可测试性（Testability）</strong>：由于需要模拟极高的伸缩性和弹性负载，<strong>测试复杂且成本高昂</strong>，许多高负载测试甚至需要在生产环境中进行，带来巨大风险。</li><li><strong>成本（Cost）</strong>：由于缓存产品许可费和高资源利用率，SBA通常相对昂贵。</li></ul><h4id="面向服务架构-orchestration-driven-service-oriented-architecture">3.1.7面向服务架构 Orchestration-Driven Service-Oriented Architecture</h4><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250722110031795.png"alt="3.1.7 面向服务架构" /><figcaption aria-hidden="true">3.1.7 面向服务架构</figcaption></figure><p>编排驱动的面向服务架构（Orchestration-Driven Service-OrientedArchitecture，简称SOA）是一种在特定时代背景下演变而来的软件架构风格。它在 20 世纪 90年代末企业快速扩张、需要更复杂的 IT 系统来适应增长的背景下出现。</p><ul><li><strong>资源稀缺性</strong>：在开源操作系统尚未被认为足够可靠用于严肃工作之前，操作系统和商业数据库服务器的许可费用昂贵且按机器收费。这导致架构师们被要求尽可能地实现<strong>重用</strong>，以优化成本。</li><li><strong>企业级重用</strong>：SOA的一个主要目标是实现服务层面的重用，即逐步构建可随时间增量重用的业务行为。大型公司厌倦了重复编写软件，因此采取了逐步解决这个问题的策略。</li><li><strong>技术分层</strong>：这种架构风格也将<strong>技术分层</strong>理念推向了极致。其驱动哲学围绕着企业级的重用展开。</li></ul><p>这个架构在历史进程中是一个反面教材，它是核心思想就俩字：<strong>复用</strong>！</p><p>失败的最核心原因：过度重视技术，以技术为导向进行模块划分和复用尝试，而业务是不断演进变化的，最终技术与业务之间的隔阂无法弥补，功亏一篑。</p><p>其他原因还有：</p><ul><li>过度追求复用导致的高度耦合</li><li>编排引擎成为巨大的耦合点和瓶颈</li><li>技术分区带来的业务流程碎片化</li></ul><h4 id="微服务架构-microservice-architecture">3.1.8 微服务架构Microservice Architecture</h4><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250723111539943.png"alt="3.1.8 微服务架构" /><figcaption aria-hidden="true">3.1.8 微服务架构</figcaption></figure><p>微服务架构的核心在于<strong>高度解耦</strong>。它<strong>倾向于复制而非耦合</strong>。这意味着，如果架构师的目标是高度解耦，那么他们会选择复制而不是重用。微服务通过物理上建模限界上下文（BoundedContext）的逻辑概念来实现高度解耦。</p><p>限界上下文（BoundedContext）是微服务设计理念的核心驱动力。这是一个愿与领域驱动设计（DDD）的概念。限界上下文代表了一种<strong>解耦</strong>风格。在限界上下文内，与特定领域相关的所有内部组件（如代码和数据库模式）都是紧密耦合的，但它们与外部限界上下文的任何内容（如其他数据库或类定义）是<strong>解耦</strong>的。</p><p>这种隔离使得每个服务可以<strong>独立演进</strong>，定义其自身所需的一切，而不必适应其他部分的约束。它<strong>避免了传统单体架构中常见的共享类和数据库作为集成点导致的紧密耦合问题</strong>。</p><p>所以微服务也是一个典型的领域分区架构，并且它倾向于将领域分区推到极致。</p><p>在划分微服务粒度时，以下三个方面是需要重点考虑的：</p><ol type="1"><li><strong>目的（Purpose）</strong>：微服务的首要目的应该是<strong>捕获一个领域或工作流</strong>。理想情况下，每个微服务都应该具有<strong>极高的功能内聚性</strong>，为整个应用程序贡献一个<strong>重要的行为</strong>。这意味着，服务应该专注于一个单一的、明确的业务功能。</li><li><strong>事务（Transactions）</strong>：限界上下文是业务工作流，通常需要<strong>在事务中协作的实体</strong>可以为服务边界提供良好的指示。由于分布式事务在分布式架构中会带来复杂性，架构师应尽量设计系统以<strong>避免跨服务的事务</strong>。如果需要跨服务事务，这可能表明服务粒度过细。事务边界通常是服务粒度的常见指标。</li><li><strong>通信（Communication）</strong>：如果一组服务为了完成功能而需要<strong>大量通信</strong>，那么将这些服务捆绑成一个更大的服务可能有助于<strong>避免过度的通信开销</strong>。换句话说，如果服务变得过于“多话”（chatty），频繁地相互调用，那么它们的边界可能需要重新评估，以减少不必要的<strong>全局复杂性</strong>。</li></ol><p>此外，业界也有一些其他的常用的判断方法：</p><ol type="1"><li><strong>变更频率</strong>：把一起变更/部署的东西放在一个服务，频率不同的拆开。</li><li><strong>耦合指标</strong>：如果拆分后跨服务调用暴增，说明拆太细；反之，如果内部复杂度过高且团队协作困难，可能太粗。</li><li><strong>认知负荷</strong>：一个团队能完全理解并独立维护的范围通常就是一个合理服务边界。</li></ol><p>在微服务架构中，有几个典型的问题需要关注：</p><ul><li><p><strong>基础设施复用</strong>：虽然微服务倾向于复制而非耦合，不过这更多是在业务层面，对于运维层面的基础设施，包括但不限于：<strong>监控（Monitoring）</strong>、<strong>日志记录（Logging）</strong>、<strong>断路器（CircuitBreakers）</strong>和<strong>服务发现（ServiceDiscovery）</strong>，微服务是主张进行统一建设和复用的。</p></li><li><p><strong>服务协作方式</strong>：一般有编舞和编排 2种协作方式：</p><ul><li><strong>编舞（Choreography）</strong>：是指多个服务<strong>相互之间直接通信</strong>，而<strong>没有中央协调器</strong>。服务（如同舞者）根据彼此发出的事件或信息自主响应和行动。</li><li><strong>编排（Orchestration）</strong>：是指通过一个<strong>单独的协调器服务</strong>来管理和控制工作流中多个服务的协调。协调器（如同乐队指挥）负责指导每个服务的执行顺序，并处理整个业务流程的状态和错误。在微服务中，架构师可以创建<strong>局部化的协调器服务</strong>来处理复杂的业务流程。</li></ul><p>微服务两者都支持。不过编舞方式更符合微服务的高度解耦哲学，因为它不依赖于中央协调器，而是通过解耦的事件来实现通信，使用起来更简便。当然，在复杂的业务流程中，<strong>编舞环境下的错误处理和协调会变得更加复杂</strong>。如果业务流程<strong>本质上是耦合的</strong>，此时编排可能更为适合。</p></li><li><p><strong>数据一致性：</strong>微服务主张尽可能避免分布式事务的问题，如果多个服务经常需要处理分布式事务问题，那最好将它们合而为一，直接在一个ACID 事务中完成。在万不得已的时候，也可以采用如 saga和最终一致性、人工补偿等方式来缓解数据一致性问题。</p></li></ul><p>优点：</p><ul><li><strong>高度解耦与小部署单元</strong>：微服务架构极力推崇<strong>高度解耦</strong>。每个服务都是<strong>极小的部署单元</strong>，且具备<strong>高度的独立性</strong>。这种解耦使得团队可以独立地开发、测试和部署服务，大大减少了对其他服务的依赖，从而提高了敏捷性。</li><li><strong>DevOps 革命与自动化</strong>：微服务架构的成功离不开<strong>DevOps革命和对操作关注点的自动化</strong>。自动化部署、自动化测试等现代工程实践是微服务存在的基础，它们极大地提高了部署频率、降低了部署风险，并保证了测试的完整性。</li><li><strong>更快的变更响应速度</strong>：由于服务范围小且高度解耦，当业务需求发生变化时，团队只需修改受影响的少量服务，而不是整个大型单体。这种<strong>增量式的演进</strong>能力使得组织能够<strong>更快地响应市场变化，提高时间到市场（time-to-market）的速度</strong>。</li><li><strong>单一职责与清晰边界</strong>：每个微服务都专注于一个<strong>单一的业务功能或领域</strong>。这种清晰的职责边界使得开发人员更容易理解、测试和维护代码，因为他们不必处理与服务无关的复杂性</li></ul><p>缺点：</p><ul><li><strong>网络调用开销（Network CallOverhead）</strong>：微服务是分布式架构。这意味着服务之间（乃至用户界面与服务之间）的通信需要通过网络进行。网络调用比本地方法调用耗时更长。当一个业务请求需要链式调用多个微服务时，累积的网络延迟会显著影响整体响应时间。</li><li><strong>安全验证开销（Security VerificationOverhead）</strong>：在微服务架构中，由于每个服务都是独立的部署单元，因此每个服务端点都需要进行安全验证。这增加了额外的处理时间。这种“在每个入口处进行安全检查”的模式进一步降低了同步、高度分布式架构（如微服务）的性能。</li><li><strong>高复杂性（Complexity）</strong>：作为一种分布式架构，微服务固有的缺点在于运行时连接各个部分所带来的复杂性，为了解决由此带来了一系列问题，需要学习、使用甚至开发一系列的组件，会给团队带来更大的心智负担和运维难度。</li><li><strong>数据一致性（DataConsistency）</strong>：如上所述，但无法避免分布式事务时，为了处理数据一致性问题，会引入很大的非业务复杂性。</li></ul><h3 id="架构选择">3.2 架构选择</h3><p>软件架构第一原理：<font color="red"><strong>一切都是权衡</strong></font>。</p><p>软件架构第二原理：<font color="red"><strong>为什么比如何更重要</strong></font>。</p><p>在选择架构时，最典型的 3 个问题：</p><ol type="1"><li>单体还是分布式架构？</li><li>数据存在哪里？</li><li>异步还是同步通信？</li></ol><h3 id="风险评估">3.3 风险评估</h3><p>从 2 个维度进行打分：</p><ol type="1"><li>风险的影响面</li><li>风险出现的可能性</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250725170843538.png"alt="架构风险评估矩阵" /><figcaption aria-hidden="true">架构风险评估矩阵</figcaption></figure><p>在分析时，不要企图一次性对所有的架构特性进行分析，拆开了，逐一击破，避免一次性关注点太多，从而不知所向。</p><h3 id="架构决策">3.4 架构决策</h3><h2 id="设计实施路径与验证机制">4. 设计实施路径与验证机制</h2><h2 id="部署观测与效果衡量">5. 部署、观测与效果衡量</h2><h2 id="复盘沉淀与演进">6. 复盘、沉淀与演进</h2>]]></content>
    
    
    <summary type="html">本篇</summary>
    
    
    
    <category term="读书笔记" scheme="https://hedon.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨17丨微服务架构</title>
    <link href="https://hedon.top/2025/07/23/fosa/fosa-ch17/"/>
    <id>https://hedon.top/2025/07/23/fosa/fosa-ch17/</id>
    <published>2025-07-23T03:02:00.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十七章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>Why is the bounded context concept so critical for microservicesarchitecture?</p><p>为什么限界上下文的概念对于微服务来说如此重要？</p></li><li><p>What are three ways of determining if you have the right level ofgranularity in a microservice?</p><p>在划分微服务粒度的时候，哪三个方面是你需要重点考虑的？</p></li><li><p>What functionality might be contained within a sidecar?</p><p>sidecar 有哪些功能？</p></li><li><p>What is the difference between orchestration and choreography?Which does microservices support? Is one communication style easier inmicroservices?</p><p>编舞（orchestration）和编排（choreography）的区别是什么？微服务支持哪种模式？在微服务中，哪种通信方式更简便？</p></li><li><p>What is a saga in microservices?</p><p>在微服务中，saga 是什么?</p></li><li><p>Why are agility, testability, and deployability so well supportedin microservices?</p><p>为什么敏捷性、可测试性和可部署性在微服务架构中表现良好？</p></li><li><p>What are two reasons performance is usually an issue inmicroservices?</p><p>在微服务中，性能问题的两个核心因素是什么？</p></li><li><p>Is microservices a domain-partitioned architecture or atechnically partitioned one?</p><p>微服务架构是领域分区还是技术分区？</p></li><li><p>Describe a topology where a microservices ecosystem might be onlya single quantum.</p><p>描述一种拓扑结构，其中微服务生态系统可能仅有一个架构量子。</p></li><li><p>How was domain reuse addressed in microservices? How wasoperational reuse addressed?</p><p>微服务中是如何解决领域复用问题的？又是如何解决运维复用问题的呢？</p></li></ol><hr /><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250723111539943.png"alt="FOSA Figure 17-1. The topologu of the microservices architecture style" /><figcaption aria-hidden="true">FOSA Figure 17-1. The topologu of themicroservices architecture style</figcaption></figure><h2 id="业务边界">业务边界</h2><blockquote><ol type="1"><li><p>Why is the bounded context concept so critical for microservicesarchitecture?</p><p>为什么限界上下文的概念对于微服务来说如此重要？</p></li><li><p>Is microservices a domain-partitioned architecture or atechnically partitioned one?</p><p>微服务架构是领域分区还是技术分区？</p></li></ol></blockquote><p>限界上下文（BoundedContext）是微服务设计理念的核心驱动力。微服务架构与领域驱动设计（DDD）紧密相关，尤其是受限界上下文概念的深刻影响。限界上下文代表了一种<strong>解耦</strong>风格。在限界上下文内，与特定领域相关的所有内部组件（如代码和数据库模式）都是紧密耦合的，但它们与外部限界上下文的任何内容（如其他数据库或类定义）是<strong>解耦</strong>的。</p><p>微服务架构的首要目标是<strong>高度解耦</strong>。它通过物理地建模限界上下文的逻辑概念来实现这一目标。这意味着，微服务架构鼓励将系统分解为<strong>独立的、自包含的服务</strong>，每个服务都对应一个特定的限界上下文。</p><p>这种隔离使得每个服务可以<strong>独立演进</strong>，定义其自身所需的一切，而不必适应其他部分的约束。它<strong>避免了传统单体架构中常见的共享类和数据库作为集成点导致的紧密耦合问题</strong>。</p><p>所以微服务也是一个典型的领域分区架构，并且它倾向于将领域分区推到极致。</p><h2 id="服务粒度">服务粒度</h2><blockquote><ol start="2" type="1"><li><p>What are three ways of determining if you have the right level ofgranularity in a microservice?</p><p>在划分微服务粒度的时候，哪三个方面是你需要重点考虑的？</p></li></ol></blockquote><p>在划分微服务粒度时，以下三个方面是需要重点考虑的：</p><ol type="1"><li><strong>目的（Purpose）</strong>：微服务的首要目的应该是<strong>捕获一个领域或工作流</strong>。理想情况下，每个微服务都应该具有<strong>极高的功能内聚性</strong>，为整个应用程序贡献一个<strong>重要的行为</strong>。这意味着，服务应该专注于一个单一的、明确的业务功能。</li><li><strong>事务（Transactions）</strong>：限界上下文是业务工作流，通常需要<strong>在事务中协作的实体</strong>可以为服务边界提供良好的指示。由于分布式事务在分布式架构中会带来复杂性，架构师应尽量设计系统以<strong>避免跨服务的事务</strong>。如果需要跨服务事务，这可能表明服务粒度过细。事务边界通常是服务粒度的常见指标。</li><li><strong>通信（Communication）</strong>：如果一组服务为了完成功能而需要<strong>大量通信</strong>，那么将这些服务捆绑成一个更大的服务可能有助于<strong>避免过度的通信开销</strong>。换句话说，如果服务变得过于“多话”（chatty），频繁地相互调用，那么它们的边界可能需要重新评估，以减少不必要的<strong>全局复杂性</strong>。</li></ol><p>书中还强调，<strong>迭代</strong>是确保良好服务设计的唯一途径，架构师很少能在第一次尝试时就发现完美的粒度、数据依赖和通信风格，只有不断适配业务发展、不断思考改善，才能设计出良好的架构。</p><p>此外，业界也有一些其他的常用的判断方法：</p><ol type="1"><li><strong>变更与部署频率一致性</strong>：把一起变更/部署的东西放在一个服务，频率不同的拆开。</li><li><strong>耦合/通信“积分器 vs.解耦器”指标</strong>：如果拆分后跨服务调用暴增（“chattiness”），说明拆太细；反之，如果内部复杂度过高且团队协作困难，可能太粗。</li><li><strong>团队/认知负荷</strong>：一个团队能完全理解并独立维护的范围通常就是一个合理服务边界。</li></ol><h2 id="基础设施">基础设施</h2><blockquote><ol start="3" type="1"><li><p>What functionality might be contained within a sidecar?</p><p>sidecar 有哪些功能？</p></li><li><p>How was domain reuse addressed in microservices? How wasoperational reuse addressed?</p><p>微服务中是如何解决领域复用问题的？又是如何解决运维复用问题的呢？</p></li></ol></blockquote><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250723111700037.png"alt="FOSA Figure 17-3. The service plane connects the sidecars in a service mesh" /><figcaption aria-hidden="true">FOSA Figure 17-3. The service planeconnects the sidecars in a service mesh</figcaption></figure><p>Sidecar 模式用于处理微服务中的<strong>通用运维关注点（operationalconcerns）</strong>，包括但不限于：<strong>监控（Monitoring）</strong>、<strong>日志记录（Logging）</strong>、<strong>断路器（CircuitBreakers）</strong>和<strong>服务发现（ServiceDiscovery）</strong>。这些功能由一个独立的组件处理，该组件可以由单个团队拥有，也可以由共享的基础设施团队拥有，从而实现了运维方面的复用。</p><p>而在领域复用中，由于微服务架构的主要目标是<strong>高度解耦</strong>。为了实现这一目标，微服务<strong>倾向于复制（duplication）而不是传统意义上的复用（reuse）</strong>。这意味着，对于通用实体（如<code>Address</code>类），微服务会<strong>避免共享公共类或数据库模式</strong>。相反，每个服务会在其自己的限界上下文内定义和管理其所需的数据和行为，即使这意味着某些概念的重复实现。这种策略牺牲了代码级别的复用，以换取服务之间更高的解耦度和独立演进的能力。</p><h2 id="服务协作">服务协作</h2><blockquote><ol start="4" type="1"><li><p>What is the difference between orchestration and choreography?Which does microservices support? Is one communication style easier inmicroservices?</p><p>编舞（orchestration）和编排（choreography）的区别是什么？微服务支持哪种模式？在微服务中，哪种通信方式更简便？</p></li></ol></blockquote><ul><li><p><strong>编舞（Choreography）</strong>：是指多个服务<strong>相互之间直接通信</strong>，而<strong>没有中央协调器</strong>。服务（如同舞者）根据彼此发出的事件或信息自主响应和行动。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250723112521618.png"alt="FOSA Figure 17-7. Using choreography in microservices to manage coordination" /><figcaption aria-hidden="true">FOSA Figure 17-7. Using choreography inmicroservices to manage coordination</figcaption></figure></li><li><p><strong>编排（Orchestration）</strong>：是指通过一个<strong>单独的协调器服务</strong>来管理和控制工作流中多个服务的协调。协调器（如同乐队指挥）负责指导每个服务的执行顺序，并处理整个业务流程的状态和错误。在微服务中，架构师可以创建<strong>局部化的协调器服务</strong>来处理复杂的业务流程。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250723112551443.png"alt="FOSA Figure 17-8. Using orchestration in microservices" /><figcaption aria-hidden="true">FOSA Figure 17-8. Using orchestration inmicroservices</figcaption></figure></li></ul><p>微服务两者都支持。不过编舞方式更符合微服务的高度解耦哲学，因为它不依赖于中央协调器，而是通过解耦的事件来实现通信，使用起来更简便。当然，在复杂的业务流程中，<strong>编舞环境下的错误处理和协调会变得更加复杂</strong>。如果业务流程<strong>本质上是耦合的</strong>，此时编排可能更为适合。</p><h2 id="一致性">一致性</h2><blockquote><ol start="5" type="1"><li><p>What is a saga in microservices?</p><p>在微服务中，saga 是什么?</p></li></ol></blockquote><p>在微服务中，<strong>Saga</strong>是一种<strong>分布式事务模式</strong>，用于管理跨多个服务的业务事务，因为在微服务中，跨服务边界的传统ACID 事务是不推荐的（甚至不可能的）。</p><p>Saga模式通过将一个业务流程分解为一系列<strong>本地事务</strong>来实现，每个本地事务由一个服务执行。</p><ul><li>如果某个本地事务失败，Saga 会通过执行<strong>补偿事务（compensatingtransactions）</strong>来撤销之前已成功的本地事务所做的更改，从而确保数据的一致性。</li><li>Saga 可以通过<strong>事件溯源（eventsourcing）</strong>或<strong>有限状态机（finite statemachines）</strong>来管理事务的状态。</li></ul><p>虽然 Saga 可以用于解决分布式事务问题，但也应<strong>谨慎使用 Saga模式</strong>，因为它会增加系统的复杂性，并且如果它成为架构中的主导特性，则可能表明服务粒度划分不当，违反了微服务解耦的核心原则。</p><h2 id="优点">优点</h2><blockquote><ol start="6" type="1"><li><p>Why are agility, testability, and deployability so well supportedin microservices?</p><p>为什么敏捷性、可测试性和可部署性在微服务架构中表现良好？</p></li></ol></blockquote><p>敏捷性（Agility）、可测试性（Testability）和可部署性（Deployability）在微服务架构中得到良好支持的原因主要有以下几点：</p><ul><li><strong>高度解耦与小部署单元</strong>：微服务架构极力推崇<strong>高度解耦</strong>。每个服务都是<strong>极小的部署单元</strong>，且具备<strong>高度的独立性</strong>。这种解耦使得团队可以独立地开发、测试和部署服务，大大减少了对其他服务的依赖，从而提高了敏捷性。</li><li><strong>DevOps 革命与自动化</strong>：微服务架构的成功离不开<strong>DevOps革命和对操作关注点的自动化</strong>。自动化部署、自动化测试等现代工程实践是微服务存在的基础，它们极大地提高了部署频率、降低了部署风险，并保证了测试的完整性。</li><li><strong>更快的变更响应速度</strong>：由于服务范围小且高度解耦，当业务需求发生变化时，团队只需修改受影响的少量服务，而不是整个大型单体。这种<strong>增量式的演进</strong>能力使得组织能够<strong>更快地响应市场变化，提高时间到市场（time-to-market）的速度</strong>。</li><li><strong>单一职责与清晰边界</strong>：每个微服务都专注于一个<strong>单一的业务功能或领域</strong>。这种清晰的职责边界使得开发人员更容易理解、测试和维护代码，因为他们不必处理与服务无关的复杂性</li></ul><h2 id="缺点">缺点</h2><blockquote><ol start="7" type="1"><li><p>What are two reasons performance is usually an issue inmicroservices?</p><p>在微服务中，性能问题的两个核心因素是什么？</p></li></ol></blockquote><p>在微服务中，性能问题通常由以下两个核心因素导致：</p><ol type="1"><li><strong>网络调用开销（Network CallOverhead）</strong>：微服务是分布式架构。这意味着服务之间（乃至用户界面与服务之间）的通信需要通过网络进行。网络调用比本地方法调用耗时更长。当一个业务请求需要链式调用多个微服务时，累积的网络延迟会显著影响整体响应时间。</li><li><strong>安全验证开销（Security VerificationOverhead）</strong>：在微服务架构中，由于每个服务都是独立的部署单元，因此每个服务端点都需要进行安全验证。这增加了额外的处理时间。这种“在每个入口处进行安全检查”的模式进一步降低了同步、高度分布式架构（如微服务）的性能。</li></ol><p>尽管性能是微服务常见的问题，但可以通过<strong>数据缓存（caching）和数据复制（replication）</strong>等模式来减少不必要的网络调用，从而提高性能。</p><h2 id="架构量子">架构量子</h2><blockquote><ol start="9" type="1"><li><p>Describe a topology where a microservices ecosystem might be onlya single quantum.</p><p>描述一种拓扑结构，其中微服务生态系统可能仅有一个架构量子。</p></li></ol></blockquote><p>通常来讲，微服务架构都意味着存在多个架构量子。但如果其部署或通信模型导致了上述的紧密耦合，例如<strong>共享数据库</strong>或<strong>中央同步协调器</strong>，那么整个微服务生态系统仍可能被归类为一个单一量子。</p><p><strong>1. 共享单一数据库</strong>：</p><ul><li>如果<strong>所有微服务都共享一个单一的、中央化的数据库实例</strong>，那么整个系统很可能构成一个单一量子。在这种情况下，尽管服务是独立的部署单元，但数据库模式的任何更改都可能影响所有服务，导致它们<strong>无法独立演进和部署</strong>。这使得系统在部署和数据一致性方面表现得像一个整体。</li><li>例如，传统的<strong>分层单体（layeredmonolith）</strong>即使有多个逻辑层，但由于共享一个数据库，它也是一个单一量子。</li></ul><p><strong>2. 强制同步通信与中央协调器</strong>：</p><ul><li>在某些情况下，即使服务是分离的，如果它们之间存在<strong>大量强制的同步通信依赖（synchronousconnascence）</strong>，或者存在一个<strong>中央编排引擎（orchestrationengine）</strong>作为所有行为的巨大耦合点，那么整个系统也可能被视为一个单一量子。在这种拓扑中，如果一个服务调用另一个服务是同步的，那么这些服务的操作架构特性（例如，性能和可用性）必须在调用期间保持一致。中央协调器会限制架构中任何部分具有不同架构特性的能力。</li><li>例如，<strong>编排驱动的服务导向架构（Orchestration-DrivenService-Oriented Architecture,SOA）</strong>，即使是分布式架构，也通常只有一个量子，因为它普遍使用单一或少量数据库，并且其编排引擎作为巨大的耦合点，阻止了各个部分独立拥有不同的架构特性。</li></ul><h2 id="架构全貌">架构全貌</h2><p><strong>边界设计</strong>：限界上下文、团队边界。</p><p><strong>粒度与组件识别</strong>：功能内聚 vs.通信复杂度；量子范围思维。</p><p><strong>数据拥有权</strong>：每服务独立数据存储（数据库多样性）；避免共享表。</p><p><strong>通信风格</strong>：同步 vs. 异步；编排 vs. 编舞。</p><p><strong>一致性策略</strong>：最终一致性、Saga、补偿事务。</p><p><strong>弹性与可观测性</strong>：Sidecar/ServiceMesh、熔断、限流、Tracing。</p><p><strong>部署与运营</strong>：CI/CD、容器编排（K8s）、自动化测试策略。</p><p><strong>性能与成本权衡</strong>：网络开销、数据复制、缓存策略。</p><p><strong>治理与演化</strong>：契约测试、架构健身函数、可观测指标驱动重构。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十七章的课后思考题，深入探讨微服务架构中限界上下文的核心作用、服务粒度划分的三大原则、sidecar模式的功能特性，以及编排与编舞的通信机制差异、saga分布式事务模式、微服务的敏捷性优势与性能挑战，帮助理解微服务架构的领域驱动设计理念和分布式系统复杂性，提升架构师在构建现代分布式系统时的微服务拆分能力和架构治理水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨16丨面向服务架构</title>
    <link href="https://hedon.top/2025/07/22/fosa/fosa-ch16/"/>
    <id>https://hedon.top/2025/07/22/fosa/fosa-ch16/</id>
    <published>2025-07-22T03:02:00.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十六章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>What was the main driving force behind service-orientedarchitecture?</p><p>SOA 的主要驱动力是什么？</p></li><li><p>What are the four primary service types within a service-orientedarchitecture?</p><p>SOA 的四种主要服务类型是什么？</p></li><li><p>List some of the factors that led to the downfall ofservice-oriented architecture.</p><p>列举一些导致 SOA 衰落的因素。</p></li><li><p>Is service-oriented architecture technically partitioned ordomain partitioned?</p><p>SOA 是技术分层还是领域分层？</p></li><li><p>How is domain reuse addressed in SOA? How is operational reuseaddressed?</p><p>SOA 中如何解决领域复用和操作复用问题？</p></li></ol><hr /><h2 id="背景">背景</h2><blockquote><ol type="1"><li><p>What was the main driving force behind service-orientedarchitecture</p><p>SOA 的主要驱动力是什么？</p></li><li><p>Is service-oriented architecture technically partitioned ordomain partitioned?</p><p>SOA 是技术分层还是领域分层？</p></li></ol></blockquote><p>编排驱动的面向服务架构（Orchestration-Driven Service-OrientedArchitecture，简称SOA）是一种在特定时代背景下演变而来的软件架构风格。它在 20 世纪 90年代末企业快速扩张、需要更复杂的 IT 系统来适应增长的背景下出现。</p><ul><li><strong>资源稀缺性</strong>：在开源操作系统尚未被认为足够可靠用于严肃工作之前，操作系统和商业数据库服务器的许可费用昂贵且按机器收费。这导致架构师们被要求尽可能地实现<strong>重用</strong>，以优化成本。</li><li><strong>企业级重用</strong>：SOA的一个主要目标是实现服务层面的重用，即逐步构建可随时间增量重用的业务行为。大型公司厌倦了重复编写软件，因此采取了逐步解决这个问题的策略。</li><li><strong>技术分层</strong>：这种架构风格也将<strong>技术分层</strong>理念推向了极致。其驱动哲学围绕着企业级的重用展开。</li></ul><h2 id="拓扑">拓扑</h2><blockquote><ol start="2" type="1"><li><p>What are the four primary service types within a service-orientedarchitecture?</p><p>SOA 的四种主要服务类型是什么？</p></li></ol></blockquote><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250722110031795.png"alt="FOSA Figure 16-1. Topology of orchestration-driven service-oriented architecture" /><figcaption aria-hidden="true">FOSA Figure 16-1. Topology oforchestration-driven service-oriented architecture</figcaption></figure><p>围绕企业级复用的目标，SOA 定义了以下几种服务类型：</p><ul><li><strong>业务服务（BusinessServices）</strong>：位于架构顶层，提供入口点，代表领域行为（例如ExecuteTrade 或PlaceOrder）。这些服务定义通常不包含代码，只包含输入、输出和模式信息，并由业务用户定义。</li><li><strong>企业服务（EnterpriseServices）</strong>：包含细粒度的共享实现，是构成粗粒度业务服务的构建块，并通过编排引擎连接起来（例如CreateCustomer、CalculateQuote）。其目标是构建可复用的原子行为，从而逐步建立可复用的企业资产集合。</li><li><strong>应用服务（ApplicationServices）</strong>：一次性、单一实现的服务，不要求与企业服务同等程度的复用和粒度。通常由单一应用团队拥有，用于解决特定应用需求。</li><li><strong>基础设施服务（InfrastructureServices）</strong>：提供操作层面的关注点，如监控、日志记录、身份验证和授权。这些服务通常是具体的实现，由共享的基础设施团队与运维团队紧密协作拥有。</li><li><strong>编排引擎（OrchestrationEngine）</strong>：作为分布式架构的核心，负责将业务服务实现通过编排串联起来，包括事务协调和消息转换等功能。它还充当集成中心，允许集成自定义代码、软件包和传统软件系统。由于这个机制是架构的核心，负责这个引擎的集成架构团队往往会成为组织内部的政治力量和官僚瓶颈<strong>...</strong>。</li></ul><h2 id="失败原因">失败原因</h2><blockquote><ol start="3" type="1"><li><p>List some of the factors that led to the downfall ofservice-oriented architecture.</p><p>列举一些导致 SOA 衰落的因素。</p></li><li><p>How is domain reuse addressed in SOA? How is operational reuseaddressed?</p><p>SOA 中如何解决领域复用和操作复用问题？</p></li></ol></blockquote><p>这个架构在历史进程中是一个反面教材，它是核心思想就俩字：复用！reuse。</p><p>失败的最核心原因：过度重视技术，以技术为导向进行模块划分和复用尝试，而业务是不断演进变化的，最终技术与业务之间的隔阂无法弥补，功亏一篑。其他原因还有：</p><ul><li>过度追求复用导致的高度耦合</li><li>编排引擎成为巨大的耦合点和瓶颈</li><li>技术分区带来的业务流程碎片化</li></ul><p>这里谈到了一对矛盾：复用和耦合。复用必定会带来耦合，解耦，会带来更多的重复。</p><p>在 SOA中，复用是其核心目标，但其实现方式也导致了架构的显著副作用：<strong>紧密耦合</strong>。</p><ul><li><strong>领域复用（Domain Reuse）</strong>：SOA通过抽象共享的业务概念（例如 <code>Customer</code>客户）为可重用服务来解决领域重用问题。其他服务会引用这些"规范的（canonical）"客户服务。</li><li><strong>操作复用（OperationalReuse）</strong>：通过基础设施服务（InfrastructureServices）尽可能地重用所有功能，无论是领域功能还是操作功能。</li></ul><p>然而，这种设计也带来了负面影响：当一个系统主要围绕重用构建时，组件之间也会产生大量的耦合。例如，对规范客户服务的更改可能会波及到所有其他引用该服务的服务，使得变更变得高风险和复杂。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十六章的课后思考题，深入探讨面向服务架构的历史驱动力与核心理念、四种主要服务类型的特征与职责、SOA衰落的关键因素分析，以及技术分层与领域分层的架构特性、领域复用与操作复用的实现机制，帮助理解面向服务架构的企业级设计原理和服务编排思想，提升架构师在构建大型企业系统时的服务化架构选择能力和SOA设计水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨15丨空间架构</title>
    <link href="https://hedon.top/2025/07/21/fosa/fosa-ch15/"/>
    <id>https://hedon.top/2025/07/21/fosa/fosa-ch15/</id>
    <published>2025-07-21T03:02:00.000Z</published>
    <updated>2025-07-27T04:29:14.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十五章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>Where does space-based architecture get its name from?</p><p>空间架构的名字从何而来？</p></li><li><p>What is a primary aspect of space-based architecture thatdifferentiates it from other architecture styles?</p><p>空间架构区别与其他架构的主要方面是什么？</p></li><li><p>Name the four components that make up the virtualized middlewarewithin a space-based architecture.</p><p>说出空间架构的虚拟化中间层的 4 个组成结构。</p></li><li><p>What is the role of the messaging grid?</p><p>消息网格的作用是什么？</p></li><li><p>What is the role of a data writer in space-basedarchitecture?</p><p>数据写入器在空间架构中的作用是什么？</p></li><li><p>Under what conditions would a service need to access data throughthe data reader?</p><p>一个服务在什么情况下需要通过数据读取器去获取数据？</p></li><li><p>Does a small cache size increase or decrease the chances for adata collision?</p><p>缓存越小，数据冲突概率是增大还是减小？</p></li><li><p>What is the difference between a replicated cache and adistributed cache? Which one is typically used in space-basedarchitecture?</p><p>复制缓存和分布式缓存的区别是什么？空间架构更倾向于使用哪个？</p></li><li><p>List three of the most strongly supported architecturecharacteristics in space- based architecture.</p><p>列出 3 个空间架构中非常优秀的架构特性。</p></li><li><p>Why does testability rate so low for space-basedarchitecture?</p><p>为什么空间架构的可测性较差？</p></li></ol><hr /><h2 id="背景">背景</h2><p>基于空间的架构（SBA）是一种专门为解决<strong>高伸缩性（Scalability）</strong>、<strong>高弹性（Elasticity）</strong>、<strong>高并发（HighConcurrency）</strong>、<strong>变动剧烈且不可预测</strong>的应用场景，例如在线票务系统或在线拍卖系统。</p><p>传统三层 Web 拓扑在用户量剧增时呈倒三角：Web层易横向扩容，数据库层最难扩容，最终成为性能上限。为削弱数据库瓶颈，业界先用本地缓存，再出现集中式分布式缓存，但网络跳转仍是热点。把数据直接放到每个处理节点的<strong>复制型内存网格</strong>并实时同步，才真正让数据库从"同步路径"上消失，空间架构由此成形。</p><p>空间架构的名称来源于<strong>元组空间（TupleSpace）</strong>多个并行处理器通过共享内存进行通信。SBA的核心理念便是将应用数据保存在内存中（in-memory），并在所有活跃的处理单元（ProcessingUnits）复制，从而移除中心数据库作为同步约束，实现近乎无限的伸缩性。</p><h2 id="拓扑">拓扑</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250721175147426.png"alt="FOSA Figure 15-2. Space-based architecture basic topology" /><figcaption aria-hidden="true">FOSA Figure 15-2. Space-basedarchitecture basic topology</figcaption></figure><h3 id="处理单元-processing-unit">处理单元 Processing Unit</h3><ul><li>处理单元包含了<strong>应用逻辑</strong>（包括基于 Web的组件和后端业务逻辑）。</li><li>它还包含一个<strong>内存数据网格</strong>和<strong>复制引擎</strong>，通常由Hazelcast、Apache Ignite 或 Oracle Coherence 等产品实现。</li><li>处理单元可以包含小型、单一用途的服务，类似于微服务</li></ul><h3 id="虚拟化中间件-virtualized-middleware">虚拟化中间件 VirtualizedMiddleware</h3><p>虚拟化中间件负责处理架构中的基础设施问题，控制数据同步和请求处理。它由以下四个关键组件组成：</p><ul><li><strong>消息网格（MessagingGrid）</strong>：它负责将请求转发到任何可用的处理单元。</li><li><strong>数据网格（Data Grid）</strong>：它是 SBA中最重要和关键的组件，通常在处理单元内部以复制缓存的形式实现。它确保每个处理单元都包含完全相同的数据，数据复制是异步且快速的。</li><li><strong>处理网格（ProcessingGrid）</strong>：这是一个可选组件，用于管理<strong>协调请求处理</strong>，当一个业务请求涉及多个处理单元时，它会协调这些处理单元之间的请求。</li><li><strong>部署管理器（DeploymentManager）</strong>：该组件根据负载条件管理处理单元实例的<strong>动态启动和关闭</strong>，对于实现应用的弹性伸缩至关重要。</li></ul><h3 id="数据泵-data-pumps">数据泵 Data Pumps</h3><p>数据泵是<strong>将数据发送到另一个处理器，然后该处理器更新数据库</strong>的方式。它们总是<strong>异步</strong>的，提供内存缓存与数据库之间的<strong>最终一致性（EventualConsistency）</strong>。消息机制是数据泵的常用实现方式，因为它支持异步通信、保证消息传递和维护消息顺序。</p><h3 id="数据写入器-data-writers">数据写入器 Data Writers</h3><p>数据写入器（DataWriters）负责接收来自数据泵的消息，并用消息中包含的信息更新数据库。它们可以是服务、应用或数据中心（如AbInitio）。写入器的粒度可以根据数据泵和处理单元的范围而变化，例如，领域驱动的数据写入器可以处理特定领域（如客户）内的所有更新。</p><h3 id="数据读取器-data-readers">数据读取器 Data Readers</h3><p>负责从数据库读取数据，并通过反向数据泵将其发送到处理单元。服务需要通过数据读取器访问数据的情况有三种：</p><ol type="1"><li>所有相同命名缓存的处理单元实例都崩溃时。</li><li>所有相同命名缓存的处理单元需要重新部署时。</li><li>需要检索复制缓存中不包含的归档数据时。</li></ol><h2 id="数据冲突">数据冲突</h2><blockquote><p>不同的 processing unit处理同一个业务逻辑相关的数据时，由于数据同步存在时序问题，所以很容易出现数据不一致的情况。</p></blockquote><p>可以从以下几个因素进行冲突概率的评估：</p><ul><li>N：处理相同缓存的 processing unit 的数量</li><li>UR：缓存更新频率</li><li>S：缓存大小</li><li>RL：缓存复制的延迟</li></ul><p>CollisitionRate = N* (UR<sup>2</sup>/S) *RL</p><p>其中<strong>缓存大小越小，意味着缓存能够容纳的数据量越少，因此在给定的更新速率和复制延迟下，数据被频繁覆盖和发生冲突的几率就越高。</strong></p><h2 id="分布式缓存">分布式缓存</h2><p><strong>复制缓存</strong>：每个处理单元包含一个自己的内存数据网格，与其他共享相同命名缓存的处理单元同步。这是SBA通常采用的缓存模式，因为它提供高性能和高容错性。适用于小缓存大小（&lt;100MB）、低更新率和相对静态数据。</p><p><strong>分布式缓存</strong>：需要一个外部服务器或服务专门用于存放集中式缓存。它支持高水平的数据一致性，但性能较低（需要远程访问），且容错性存在问题（如果缓存服务器宕机）。适用于大缓存大小（&gt;500MB）、高度动态数据和高更新率。</p><h2 id="优点">优点</h2><ul><li><strong>弹性（Elasticity）</strong>：处理单元可以根据负载动态启停，实现高度弹性。</li><li><strong>伸缩性（Scalability）</strong>：通过内存数据缓存和移除数据库约束，支持处理数百万并发用户。</li><li><strong>性能（Performance）</strong>：移除了数据库瓶颈，提供了极高的性能。</li></ul><h2 id="缺点">缺点</h2><ul><li><strong>简洁性（Simplicity）</strong>：SBA是一种<strong>非常复杂的架构风格</strong>，因为它涉及到缓存、最终一致性以及众多动态组件。</li><li><strong>可测试性（Testability）</strong>：由于需要模拟极高的伸缩性和弹性负载，<strong>测试复杂且成本高昂</strong>，许多高负载测试甚至需要在生产环境中进行，带来巨大风险。</li><li><strong>成本（Cost）</strong>：由于缓存产品许可费和高资源利用率，SBA通常相对昂贵。</li></ul>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十五章的课后思考题，深入探讨空间架构的命名来源与核心特征、虚拟化中间层的组件构成、消息网格与数据读写器的协作机制，以及缓存策略选择、数据冲突管理和架构特性评估分析，帮助理解空间架构的分布式计算原理和高可扩展性设计思路，提升架构师在构建高性能分布式系统时的架构选择能力和空间化设计水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨14丨事件驱动架构</title>
    <link href="https://hedon.top/2025/07/18/fosa/fosa-ch14/"/>
    <id>https://hedon.top/2025/07/18/fosa/fosa-ch14/</id>
    <published>2025-07-18T02:30:00.000Z</published>
    <updated>2025-07-27T04:29:14.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十四章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>What are the primary differences between the broker and mediatortopologies?</p><p>代理拓扑（broker）和中介者拓扑（mediator）两种拓扑的根本区别是什么？</p></li><li><p>For better workflow control, would you use the mediator or brokertopology?</p><p>为了更好的流程控制，你会选择代理拓扑还是中介者拓扑？</p></li><li><p>Does the broker topology usually leverage a publish-and-subscribemodel with topics or a point-to-point model with queues?</p><p>在代理拓扑中，是经常使用基于主题的发布订阅模式还是基于队列的点到点模式？</p></li><li><p>Name two primary advantage of asynchronous communications.</p><p>列出 2 个异步通信的主要优势。</p></li><li><p>Give an example of a typical request within the request-basedmodel.</p><p>举一个 request-based 模式的典型例子。</p></li><li><p>Give an example of a typical request in an event-based model.</p><p>举一个 event-based 模式的典型例子。</p></li><li><p>What is the difference between an initiating event and aprocessing event in event-driven architecture?</p><p>在事件驱动架构中，初始事件和处理中事件二者有什么不同？</p></li><li><p>What are some of the techniques for preventing data loss whensending and receiving messages from a queue?</p><p>有哪些技术可以防止在从队列发送和接收消息时丢失数据？</p></li><li><p>What are three main driving architecture characteristics forusing event-driven architecture?</p><p>使用事件驱动架构的三个主要驱动架构特性是什么？</p></li><li><p>What are some of the architecture characteristics that are notwell supported in event-driven architecture?</p><p>事件驱动架构不能很好地支持哪些架构特性？</p></li></ol><hr /><p>传统的软件设计如同一个等级森严的组织，组件 A 直接向组件 B<strong>下达命令</strong>（例如，调用一个函数或API）。而事件驱动架构则更像一个现代化的、扁平的协作网络。组件 A只是<strong>发布一个事实</strong>（嘿，我这里发生了一件事！），而其他对此事感兴趣的组件（B,C,D...）可以自行决定如何<strong>响应</strong>。这种从命令到响应的范式革命，是事件驱动架构（Event-DrivenArchitecture, EDA）的灵魂所在。</p><h2 id="异步通信">异步通信</h2><p>EDA 的力量源泉来自于异步通信，它有以下优点：</p><ol type="1"><li><strong>极高的系统韧性与可用性 (Resiliency andAvailability)</strong>：在同步调用中，如果服务 B 宕机，服务 A的调用会立刻失败，导致整个链路中断。但在异步模式下，服务 A将事件发送给一个中间人（消息代理），然后就可继续自己的工作。即使服务 B此时宕机，事件也会被安全地存放在代理中，待 B恢复后再进行处理。这使得系统能够优雅地处理局部故障，整体可用性大大提高。</li><li><strong>卓越的可伸缩性与弹性 (Scalability andElasticity)</strong>：生产者和消费者被完全解耦，可以独立进行伸缩。如果事件产生的速度突然加快，我们只需要增加消费者实例的数量即可，而无需对生产者做任何改动。这种按需、独立伸缩的能力是构建高弹性系统的关键。</li></ol><h2 id="拓扑">拓扑</h2><p>典型的 EDA 有 2 种拓扑，分别为：</p><ul><li>代理拓扑（broker）</li><li>中介者拓扑（mediator）</li></ul><h3 id="broker">broker</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718110824820.png"alt="FOSA Figure 14-2. Broker topology" /><figcaption aria-hidden="true">FOSA Figure 14-2. Brokertopology</figcaption></figure><p>一个典型的 broker 拓扑如上图所示，它包含以下几个部分：</p><ul><li><code>initiating event</code>：初始事件，它用于<strong>启动整个事件流</strong>，一般来源于系统外部。</li><li><code>event channel</code>：事件通道，用于传递事件，比如 Go 的channel，或者分布式系统中的消息队列，如 RabbitMQ、Kafka等。一个事件通道一般对应一个订阅主题（topic）。</li><li><code>event processor</code>：事件处理器，它们会根据需求，订阅自己感兴趣的topic，从 <code>event channel</code> 中获取事件进行处理。</li><li><code>processing event</code>：处理事件，是由<strong>事件处理器生成并异步广播的事件</strong>，用于广告它刚刚完成了什么操作。这些事件是事件流的中间步骤，通知其他事件处理器某个操作已经完成，以便它们可以继续后续的处理。无论是否有其他的<code>event processor</code>关心这些事件，最佳实践中还是建议一直发布这些事件，这对于后续的扩展性非常良好。</li></ul><p>它具有以下特点：</p><ul><li><strong>核心思想</strong>：它的唯一职责就是高效、可靠地分发事件。所有的业务逻辑和处理步骤都存在于各个独立的事件处理器（服务）中。</li><li><strong>工作流</strong>：工作流是<strong>分散且隐式</strong>的。一个事件可能被多个消费者同时处理，触发多个并行的、互不相关的后续流程。</li><li><strong>通信模型</strong>：利用<strong>基于主题的发布/订阅（Publish-Subscribe）模型</strong>。一个事件被发布到特定主题（Topic）上，所有订阅了该主题的消费者都能收到一份该事件的副本并进行处理。这使得系统具有极强的扩展性，可以随时增加新的订阅者来响应现有事件，而无需修改任何已有代码。</li><li><strong>优点</strong>：事件生产者和事件消费者之间是<strong>完全解耦</strong>的。生产者不知道谁会消费它的事件，消费者也不知道是谁生产了它所消费的事件。它们唯一的共同依赖是<strong>消息代理</strong>以及<strong>事件的契约（Schema）</strong>。</li><li><strong>缺点</strong>：端到端的工作流是<strong>隐式</strong>的，缺乏全局视图。如果流程出了问题，很难追踪到底是哪个环节的协同出了错，这对于异常处理和数据一致性要求较高的系统不是很友好。</li></ul><p>完整例子可参考下图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718113630056.png"alt="FOSA Figure 14-4. Example of the broker topology" /><figcaption aria-hidden="true">FOSA Figure 14-4. Example of the brokertopology</figcaption></figure><h3 id="mediator">mediator</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718111638117.png"alt="FOSA Figure 14-5. Mediator topology" /><figcaption aria-hidden="true">FOSA Figure 14-5. Mediatortopology</figcaption></figure><p>一个典型的 mediator 拓扑如上图所示，它跟 broker 有些许不同：</p><ul><li><code>event queue</code>：事件队列，它跟 <code>event channel</code>有所不同，专门用于 <code>event mediator</code> 接收<code>initiating event</code>。</li><li><code>event mediator</code>：事件中介者，了解处理事件所需的步骤，并生成相应的处理事件，这些事件被发送到专用事件通道（eventchannel），采用<strong>点对点消息传递</strong>方式。在一些复杂的场景中，也可以设置多个<code>event mediator</code>，并分配到不同的层次中，以更好的管理复杂业务流程。</li></ul><p>它具有以下特点：</p><ul><li><strong>核心思想</strong>：它像一个流程编排引擎，包含了实现复杂业务流程的核心逻辑。</li><li><strong>工作流</strong>：工作流是<strong>集中且显式</strong>的。中介者接收一个初始事件，然后根据预设的逻辑，一步步地调用不同的服务来完成一个完整的、有状态的业务流程。</li><li><strong>通信模型</strong>：利用<strong>基于队列的点对点（Point-to-Point）模型</strong>。</li><li><strong>优点</strong>：工作流是<strong>显式</strong>的，易于理解、监控和管理。复杂的错误处理、重试、补偿逻辑都可以在中介者中集中处理。</li><li><strong>缺点</strong>：中介者本身可能成为一个<strong>复杂的单点</strong>（但通常是高可用的集群），所有流程的修改都必须在其中进行，降低了系统的灵活性。</li></ul><p>完整例子可参考下图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718113522146.png"alt="FOSA Figure 14-9. Step 2 of the mediator example" /><figcaption aria-hidden="true">FOSA Figure 14-9. Step 2 of the mediatorexample</figcaption></figure><h3 id="对比">对比</h3><table><colgroup><col style="width: 12%" /><col style="width: 41%" /><col style="width: 45%" /></colgroup><thead><tr><th>对比维度</th><th>代理拓扑 (Broker Topology)</th><th>中介者拓扑 (Mediator Topology)</th></tr></thead><tbody><tr><td><strong>核心组件</strong></td><td>轻量级、无状态的消息代理</td><td>重量级、有状态的流程中介者</td></tr><tr><td><strong>智能位置</strong></td><td>分散在各个事件处理器中</td><td>集中在中介者中</td></tr><tr><td><strong>工作流</strong></td><td><strong>协同式 (Choreography)</strong>，隐式，涌现式</td><td><strong>编排式 (Orchestration)</strong>，显式，集中式</td></tr><tr><td><strong>流程控制</strong></td><td>弱，难以进行全局控制</td><td>强，易于进行精细控制和监控</td></tr><tr><td><strong>耦合模型</strong></td><td>极致解耦（仅依赖代理和事件契约）</td><td>轮轴式耦合（所有服务都依赖中-介者）</td></tr><tr><td><strong>灵活性</strong></td><td>极高，易于增加新的事件响应者</td><td>较低，流程变更需修改中介者</td></tr><tr><td><strong>典型技术</strong></td><td>消息队列、流平台 (Kafka, RabbitMQ)</td><td>工作流引擎、ESB (AWS Step Functions, Camel)</td></tr><tr><td><strong>适用场景</strong></td><td>简单通知、数据广播、高度可扩展的系统</td><td>复杂、多步、有状态的业务流程，Saga 模式</td></tr></tbody></table><h2 id="request-reply">Request-Reply</h2><blockquote><ol start="5" type="1"><li><p>Give an example of a typical request within the request-basedmodel.</p><p>举一个 request-based 模式的典型例子。</p></li><li><p>Give an example of a typical request in an event-based model.</p><p>举一个 event-based 模式的典型例子。</p></li></ol></blockquote><h3 id="request-based-vs-event-based">request-based vs event-based</h3><table><colgroup><col style="width: 9%" /><col style="width: 45%" /><col style="width: 45%" /></colgroup><thead><tr><th>对比维度</th><th>基于请求的模型 (Request-Based)</th><th>基于事件的模型 (Event-Based)</th></tr></thead><tbody><tr><td><strong>核心意图</strong></td><td><strong>命令 (Command)</strong></td><td><strong>通知 (Notification / Fact)</strong></td></tr><tr><td><strong>详细说明</strong></td><td>请求方必须知道接收方的确切地址和接口（例如，一个 URL 端点和其 API契约）。它们之间是点对点的、强依赖的关系。</td><td>发布方和消费方互相完全不知道对方的存在。它们唯一的共同依赖是消息中间件和事件的格式。这种解耦是其最大优势。</td></tr><tr><td><strong>通信模式</strong></td><td><strong>通常是同步的 (Synchronous)</strong></td><td><strong>总是异步的 (Asynchronous)</strong></td></tr><tr><td><strong>详细说明</strong></td><td>请求方发送请求后，会<strong>阻塞并等待</strong>一个响应。从请求方的视角看，整个调用是一个连续、不间断的操作。</td><td>发布方发送事件后，<strong>立即继续</strong>自己的工作（“发后即忘”Fire-and-Forget）。它不等待任何结果。</td></tr><tr><td><strong>例子</strong></td><td><strong>打电话</strong></td><td><strong>发布社交动态</strong></td></tr></tbody></table><h3 id="event-based-实现-reply">event-based 实现 reply</h3><p>虽然事件驱动架构的核心是异步和解耦，但在很多业务场景中，请求方确实需要得到一个明确的回复。例如，一个Web前端请求处理一个复杂的计算，它不能永远等待，而是需要在一个合理的时间内得到计算结果。</p><p>在事件模型之上实现请求-响应模式，关键在于解决两个核心问题：</p><ol type="1"><li><strong>响应应该发往何处？</strong>（因为接收方并不知道请求方是谁）</li><li><strong>收到的响应如何与当初的请求对应起来？</strong>（因为请求方可能同时发出了多个请求）</li></ol><p>解决方案是巧妙地利用消息的两个元数据字段：<strong>回复地址(Reply-To)</strong> 和 <strong>关联标识 (Correlation ID)</strong>。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250718132839093.png"alt="FOSA Figure 14-20. Request-reply message processing using a correlation ID" /><figcaption aria-hidden="true">FOSA Figure 14-20. Request-reply messageprocessing using a correlation ID</figcaption></figure><p><strong>Step 1: 请求方 (Requester) 发起请求</strong></p><ol type="1"><li><strong>创建临时回复队列</strong>：请求方首先为自己创建一个唯一的、临时的、专用于接收本次响应的队列。这个队列的生命周期通常与本次请求-响应过程绑定。</li><li><strong>生成关联 ID</strong>：请求方生成一个全局唯一的字符串，作为<code>Correlation ID</code>。</li><li><strong>构造请求消息</strong>：请求方创建请求消息，其内容是业务数据。在消息的<strong>属性（Properties）或头信息（Headers）</strong>中，设置两个关键字段：<ul><li><code>Reply-To</code>: 填入刚才创建的临时回复队列的名称。</li><li><code>Correlation ID</code>: 填入刚才生成的唯一 ID。</li></ul></li><li><strong>发送并等待</strong>：请求方将这个构造好的消息发送到一个众所周知的<strong>请求队列</strong>（例如<code>calculation-request-queue</code>）。然后，它开始<strong>监听</strong>自己的那个<strong>临时回复队列</strong>，等待一个包含相同<code>Correlation ID</code> 的消息出现。通常还会设置一个超时时间。</li></ol><p><strong>Step 2: 响应方 (Replier) 处理请求并回复</strong></p><ol type="1"><li><strong>接收请求</strong>：响应方服务从<strong>请求队列</strong>中消费一条消息。</li><li><strong>处理业务逻辑</strong>：执行消息内容所要求的业务计算或操作。</li><li><strong>提取元数据</strong>：从收到的请求消息的属性中，提取出<code>Reply-To</code> 和 <code>Correlation ID</code> 的值。</li><li><strong>构造响应消息</strong>：响应方创建响应消息，其内容是业务处理的结果。</li><li><strong>设置并发送响应</strong>：在响应消息的属性中，<strong>必须</strong>将从请求中收到的那个<code>Correlation ID</code><strong>原封不动地设置回去</strong>。然后，将此响应消息发送到请求消息中<code>Reply-To</code> 字段所指定的那个队列地址。</li></ol><p><strong>Step 3: 请求方 (Requester) 接收响应</strong></p><ol type="1"><li><strong>接收消息</strong>：请求方在其临时回复队列上收到了一个消息。</li><li><strong>匹配关联 ID</strong>：它检查收到的响应消息中的<code>Correlation ID</code> 是否与它当初发送的那个 ID 相匹配。</li><li><strong>完成闭环</strong>：如果 ID匹配，则证明这就是它所等待的响应。请求-响应的流程至此完成。请求方可以处理响应结果，然后安全地删除那个临时的回复队列。</li></ol><h2 id="可靠性">可靠性</h2><blockquote><p>What are some of the techniques for preventing data loss when sendingand receiving messages from a queue?</p><p>有哪些技术可以防止在从队列发送和接收消息时丢失数据？</p></blockquote><p>这是一个生产者、消费者和代理三方共同的责任：</p><p><strong>1. 代理端 (Broker Side)</strong>：</p><ul><li><strong>持久化(Persistence)</strong>：代理在将事件放入队列或主题时，会先将其写入磁盘，确保即使代理重启，事件也不会丢失。</li><li><strong>集群与复制 (Clustering andReplication)</strong>：通过将代理部署为集群，并将事件在多个节点间进行复制，可以防止单点故障导致的数据丢失。</li></ul><p><strong>2. 客户端 (Client Side)</strong>：</p><ul><li><strong>消费者确认(ACK)</strong>：消费者在<strong>成功处理完</strong>一个事件后，必须向代理发送一个ACK 信号。如果消费者在处理过程中崩溃而未发送ACK，代理会认为该事件未被成功处理，并会将其重新投递给其他消费者。</li><li><strong>事务性发件箱(Transactional)</strong>：这是一个非常关键的高级模式。为了确保"写入业务数据库"和"发送事件"这两个操作的原子性，开发者会将待发送的事件与业务数据变更<strong>放在同一个本地数据库事务中</strong>，写入一个发件箱（Outbox）表。然后由一个独立的轮询进程负责读取发件箱表，并将事件可靠地发送给代理。这彻底解决了"业务成功但事件未发出"的问题。</li></ul><h2 id="架构权衡">架构权衡</h2><blockquote><p>What are three main driving architecture characteristics for usingevent-driven architecture?</p><p>使用事件驱动架构的三个主要驱动架构特性是什么？</p></blockquote><ul><li><strong>可伸缩性与弹性 (Scalability &amp;Elasticity)</strong>：如前所述，独立伸缩组件的能力是其核心优势。</li><li><strong>可扩展性(Extensibility)</strong>：系统极易扩展。当需要增加新功能时，只需开发一个新的服务来订阅感兴趣的现有事件即可，完全无需改动已有服务。</li><li><strong>响应性(Responsiveness)</strong>：对于需要快速响应用户的系统，可以将耗时任务异步化。例如，用户提交视频后，系统立即返回"上传成功，正在处理中"，然后通过事件驱动后台的转码、审核等一系列复杂流程。</li></ul><blockquote><p>What are some of the architecture characteristics that are not wellsupported in event-driven architecture?</p><p>事件驱动架构不能很好地支持哪些架构特性？</p></blockquote><ul><li><strong>简单性 (Simplicity)</strong>：EDA显著增加了系统的复杂性。你需要管理消息代理，处理异步编程的挑战（如调试、错误处理），并应对最终一致性带来的心智负担。</li><li><strong>事务性(Transactional)</strong>：实现跨多个服务的原子性操作（即分布式事务）变得异常困难。虽然可以通过Saga等模式来模拟长事务，但其实现复杂，且只能保证最终一致性而非强一致性。</li><li><strong>工作流的可观测性 (Observability ofWorkflow)</strong>：尤其是在代理拓扑中，业务流程被分散到各个独立的处理器中，没有一个集中的地方可以让你直观地看到一个完整的业务流程是如何执行的，这给监控和排错带来了巨大挑战。</li></ul>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十四章的课后思考题，深入探讨事件驱动架构中代理拓扑与中介者拓扑的设计差异、异步通信的优势机制、请求模式与事件模式的应用场景，以及事件类型分类、消息可靠性保障技术和架构特性支持分析，帮助理解事件驱动架构的核心设计原理和实施策略，提升架构师在构建响应式系统时的架构选择能力和事件化设计水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨13丨基于服务的架构</title>
    <link href="https://hedon.top/2025/07/17/fosa/fosa-ch13/"/>
    <id>https://hedon.top/2025/07/17/fosa/fosa-ch13/</id>
    <published>2025-07-17T02:30:00.000Z</published>
    <updated>2025-07-27T04:29:14.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十三章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>How many services are there in a typical service-basedarchitecture?</p><p>在一个经典的基于服务的架构中通常有多少个服务？</p></li><li><p>Do you have to break apart a database in service-basedarchitecture?</p><p>在基于服务的架构中，你是否必须将数据库进行拆分？</p></li><li><p>Under what circumstances might you want to break apart adatabase?</p><p>在什么场景下你会对数据库进行拆分？</p></li><li><p>What technique can you use to manage database changes within aservice-based architecture?</p><p>在基于服务的架构中，你会使用什么样的技术来管理数据库变更？</p></li><li><p>Do domain services require a container (such as Docker) torun?</p><p>领域服务需要在容器（如 Docker）中运行吗？</p></li><li><p>Which architecture characteristics are well supported by theservice-based architecture style?</p><p>基于服务的架构在哪些架构特性表现很优异？</p></li><li><p>Why isn’t elasticity well supported in a service-basedarchitecture?</p><p>为什么基于服务的架构的架构弹性不是很好？</p></li><li><p>How can you increase the number of architecture quanta in aservice-based architecture?</p><p>在基于服务的架构中，你如何增加架构量子的数量？</p></li></ol><hr /><h2 id="简介">简介</h2><p>在软件架构的演进光谱中，如果说单体（Monolith）和微服务（Microservices）是两个广为人知的端点，那么基于服务的架构（Service-BasedArchitecture,SBA）就是它们之间那个常常被忽略，却又极具现实意义的"务实中间派"。它既非庞大到笨拙，也非精细到繁杂，为许多成长中的系统提供了一条平滑的演进路径。</p><p>SBA的本质是一种将一个大型的单体应用，<strong>分解为少数几个、逻辑独立的、可独立部署的"服务"</strong>的架构风格。SBA 的服务数量通常不多，一般在 <strong>4 到 12个</strong>之间。它不像微服务那样追求极致的拆分（可能会有几十上百个服务），而是将应用按照<strong>核心的业务领域（Domain）</strong>进行划分。</p><h2 id="拓扑">拓扑</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250717114456233.png"alt="FOSA Figure 13-8. Electronics recycling example using service-based architecture" /><figcaption aria-hidden="true">FOSA Figure 13-8. Electronics recyclingexample using service-based architecture</figcaption></figure><h2 id="数据库">数据库</h2><p>SBA最具标志性，也是与微服务最根本的区别之一，就在于它对数据库的处理方式。这直接引出了接下来的两个问题。</p><blockquote><p>Do you have to break apart a database in service-basedarchitecture?</p><p>在基于服务的架构中，你是否必须将数据库进行拆分？</p></blockquote><p>答案是：<strong>通常不，而且默认不拆分是其主要特征。</strong></p><p>SBA的典型实现是，所有服务共享<strong>同一个数据库</strong>。这种设计的初衷是为了在享受独立部署带来的好处的同时，最大限度地<strong>降低数据层面的复杂性</strong>。共享数据库可以：</p><ul><li><strong>简化开发</strong>：开发者无需处理复杂的分布式事务和跨服务数据同步问题。</li><li><strong>保证数据一致性</strong>：传统的 ACID事务可以在数据库层面轻松实现。</li><li><strong>降低技术门槛</strong>：团队无需掌握复杂的分布式数据管理技术。</li></ul><p>在共享数据库的模式下，如何管理这个公共资产成了一个关键的治理问题。</p><blockquote><p>What technique can you use to manage database changes within aservice-based architecture?</p><p>在基于服务的架构中，你会使用什么样的技术来管理数据库变更？</p></blockquote><p>当多个团队开发的服务都依赖同一个数据库时，随意的 Schema变更会引发灾难。因此，必须采用严格的数据库治理技术。</p><p>核心方法是成立一个跨团队的数据库治理小组，或者由一个专职的数据库管理员（DBA）团队来担当此任。这个团队的职责是：</p><ul><li><strong>守护数据库 Schema的所有权</strong>：任何对数据库结构的修改（增删改表、字段等）都必须通过该团队的评审。</li><li><strong>执行数据库迁移脚本</strong>：使用专业的数据库迁移工具（如<strong>Flyway</strong> 或<strong>Liquibase</strong>）来统一管理和执行所有的变更脚本，确保变更的可追溯性、版本化和一致性。</li><li><strong>保证向后兼容性</strong>：确保数据库的变更不会破坏现有服务的正常运行。</li></ul><p>然而，这种共享模式并非一成不变，这就引出了下一个问题：</p><blockquote><p>Under what circumstances might you want to break apart adatabase?</p><p>在什么场景下你会对数据库进行拆分？</p></blockquote><p>随着业务发展，共享数据库的弊端会逐渐显现。在以下情况下，拆分数据库就成了合理的选择：</p><ol type="1"><li><strong>服务资源争用 (ServiceContention)</strong>：某个服务（如高流量的商品浏览服务）对数据库产生巨大压力，影响了其他关键服务（如订单服务）的性能。</li><li><strong>数据隔离与安全 (Data Isolation andSecurity)</strong>：某个服务处理的数据高度敏感（如支付服务中的金融信息），需要从主数据库中物理隔离出来，以满足合规性或安全要求。</li><li><strong>技术栈不匹配 (TechnologyMismatch)</strong>：某个服务有特殊的数据存储需求。例如，搜索服务最适合使用Elasticsearch，而核心业务数据则存储在关系型数据库中。</li></ol><p>当这些情况发生时，SBA允许你"渐进式"地将某个服务连同其数据一起剥离出去，赋予它独立的数据库。</p><h2 id="部署">部署</h2><blockquote><p>Do domain services require a container (such as Docker) to run?</p><p>领域服务需要容器（例如 Docker）来运行吗？</p></blockquote><p>答案是：<strong>不需要，但强烈推荐。</strong></p><p>从技术上讲，你可以将每个服务单独部署服务器上。但是，容器技术（如Docker）和容器编排工具（如 Kubernetes）与 SBA的理念天然契合。使用容器可以带来巨大好处：</p><ul><li>环境一致性</li><li>部署简化</li><li>资源利用率</li></ul><h2 id="架构权衡">架构权衡</h2><blockquote><p>Which architecture characteristics are well supported by theservice-based architecture style?</p><p>基于服务的架构在哪些架构特性表现很优异？</p></blockquote><p>相比于单体架构，SBA 在以下方面有显著提升：</p><ol type="1"><li><strong>可部署性(Deployability)</strong>：这是最大的优势之一。每个服务都可以独立部署，使得发布更加频繁、风险更低。</li><li><strong>模块化(Modularity)</strong>：通过按领域划分服务，实现了清晰的业务模块边界。</li><li><strong>可维护性(Maintainability)</strong>：每个服务的代码库规模远小于整个单体，更易于理解、修改和维护。</li><li><strong>容错性 (FaultTolerance)</strong>：一个服务的崩溃不会导致整个应用程序宕机（尽管共享数据库可能成为共同的故障点）。</li></ol><p>然而，SBA 并非银弹，它也有其固有的局限性。</p><blockquote><p>Why isn’t elasticity well supported in a service-basedarchitecture?</p><p>为什么基于服务的架构的架构弹性不是很好？</p></blockquote><p><strong>弹性</strong>指的是根据实时负载，自动、精细地伸缩应用<strong>特定部分</strong>的能力。</p><p>SBA对弹性的支持不佳，根源在于其服务的<strong>粗粒度</strong>。假设"订单服务"包含了"浏览历史订单"、"创建新订单"和"订单退款"三个功能。如果"创建新订单"功能因为促销活动而流量激增，你无法只针对这一个功能进行扩容。你必须将整个庞大的"订单服务"进行水平扩展，复制出多个实例。这不仅造成了资源浪费（其他两个功能并未承压），也远不如微服务那样能够对具体功能点进行精准、高效的弹性伸缩。</p><h2 id="架构量子">架构量子</h2><blockquote><p>How can you increase the number of architecture quanta in aservice-based architecture?</p><p>在基于服务的架构中，你如何增加架构量子的数量？</p></blockquote><p>首先要明确，在<strong>典型的、共享数据库的 SBA</strong>中，整个系统只有<strong>一个架构量子</strong>。因为所有服务都与同一个数据库紧密耦合，它们无法被真正独立地部署和演化，形成了一个不可分割的整体。</p><p>增加架构量子的数量，唯一的途径就是<strong>打破这种共享依赖</strong>。具体方法是：<strong>将某个服务连同其数据一起拆分出来，为其分配一个独立的、专用的数据库。</strong></p><p>每完成一次这样的拆分，这个被分离出去的服务就演变成了一个独立的架构量子。因此，增加架构量子的过程，就是<strong>逐步从共享数据库模型向"每个服务一个数据库"模型演进的过程</strong>，也就逐渐趋向于微服务架构了。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十三章的课后思考题，深入探讨基于服务的架构中服务数量的设计考量、数据库分解策略与变更管理机制、领域服务的容器化部署模式，以及基于服务架构的特性支持分析、弹性限制因素和架构量子扩展方案，帮助理解基于服务架构的核心设计原则和实施要点，提升架构师在构建分布式系统时的架构选择能力和服务化设计水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨12丨微核架构</title>
    <link href="https://hedon.top/2025/07/16/fosa/fosa-ch12/"/>
    <id>https://hedon.top/2025/07/16/fosa/fosa-ch12/</id>
    <published>2025-07-16T02:20:00.000Z</published>
    <updated>2025-07-27T04:29:14.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十二章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>What is another name for the microkernel architecture style?</p><p>微核架构风格的别名是什么？</p></li><li><p>Under what situations is it OK for plug-in components to bedependent on other plug-in components?</p><p>在什么情况下，插件组件之间可以相互依赖？</p></li><li><p>What are some of the tools and frameworks that can be used tomanage plug-ins?</p><p>有哪些工具和框架可用于管理插件？</p></li><li><p>What would you do if you had a third-party plug-in that didn’tconform to the standard plug-in contract in the core system?</p><p>如果一个第三方插件不遵循核心系统的标准插件契约，你会怎么做？</p></li><li><p>Provide two examples of the microkernel architecture style.</p><p>举 2 个微核架构的例子。</p></li><li><p>Is the microkernel architecture style technically partitioned ordomain partitioned?</p><p>微核架构是技术分区还是领域分区？</p></li><li><p>Why is the microkernel architecture always a single architecturequantum?</p><p>为什么微核架构总是单一的架构量子？</p></li><li><p>What is domain/architecture isomorphism?</p><p>什么是领域/架构同构性？</p></li></ol><hr /><h2 id="拓扑">拓扑</h2><p>微核架构，也被称为<strong>插件化架构（Plug-inArchitecture）</strong>，是一种能够提供极高扩展性、灵活性和演化能力的系统设计模式。它的核心思想是将系统功能划分为两部分：一个最小化的、稳定的<strong>核心系统（CoreSystem）</strong>和一个由独立<strong>插件组件（Plug-inComponents）</strong>构成的可扩展生态。</p><p>我们可以将其想象成一个智能手机：操作系统是其微核，提供最基础的功能（通信、电源管理、应用商店接口），而我们安装的每一个App 就是一个插件，为手机赋予了无穷无尽的新功能。</p><p>核心构成：</p><ul><li><strong>核心系统 (CoreSystem)</strong>：这是架构的“微核”。它的职责被严格限制在<strong>最小且必要</strong>的范围内，通常只包含：<ol type="1"><li>系统运行所必需的通用业务逻辑（例如，一个 IDE的文件管理和基础编辑器）。</li><li>一个至关重要的<strong>插件管理机制</strong>，包括插件的注册、发现、生命周期管理等。这是连接核心与插件的桥梁。</li></ol></li><li><strong>插件组件 (Plug-inComponents)</strong>：这些是独立的、可插拔的模块，用于实现<strong>扩展功能或特定业务逻辑</strong>。每个插件都通过一个由核心系统定义的<strong>标准契约（StandardContract）</strong>来与核心交互。这个契约通常是一个接口或一组 API。</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250716105151041.png"alt="FOSA Figure 12-1. Basic components of the microkernel architecture style" /><figcaption aria-hidden="true">FOSA Figure 12-1. Basic components of themicrokernel architecture style</figcaption></figure><p>典型例子：</p><ul><li>Chrome</li><li>VS Code</li></ul><h2 id="插件生态">插件生态</h2><p>理想情况下，插件应该只依赖于核心系统，保持彼此的独立性，以获得最大的灵活性。然而，在复杂的现实世界中，插件间的依赖是不可避免的。</p><h3 id="插件依赖">插件依赖</h3><blockquote><p>Under what situations is it OK for plug-in components to be dependenton other plug-in components?</p><p>在什么情况下，插件组件之间可以相互依赖？</p></blockquote><p>允许插件间依赖的<strong>合理情况</strong>是：当一个插件的功能是另一个插件功能的<strong>逻辑扩展或前提</strong>时。</p><blockquote><p>例如：一个 <code>PDF 导出</code> 插件，可能需要依赖一个通用的<code>报表生成</code> 插件。<code>PDF 导出</code> 插件负责将<code>报表生成</code> 插件产生的数据模型渲染成 PDF 文件。</p></blockquote><h3 id="插件管理">插件管理</h3><blockquote><p>What are some of the tools and frameworks that can be used to manageplug-ins?</p><p>有哪些工具和框架可用于管理插件？</p></blockquote><p>管理插件的复杂性催生了许多优秀的框架和标准：</p><ol type="1"><li><strong>OSGi (Open Service Gateway initiative)</strong>：这是 Java平台中最著名、最强大的插件化框架。它提供了一整套完善的模块层（Bundle）和生命周期管理机制，是构建大型、复杂微核系统的首选。EclipseIDE 就是基于 OSGi 构建的。</li><li><strong>Eclipse Rich Client Platform (RCP)</strong>：基于OSGi，专门用于构建桌面富客户端应用的框架，其本身就是一个微核。</li><li><strong>Java Platform Module System (JPMS)</strong>：从 Java 9开始引入的官方模块化系统，也可以作为实现插件化的基础。</li><li><strong>Java ServiceLoader</strong>：Java内置的一个简单的服务发现机制，适用于较轻量级的插件化场景。</li><li><strong>其他生态</strong>：在 .NET 中有 MEF (Managed ExtensibilityFramework)；在 Web 应用中，可以通过 Webhooks机制实现一种分布式的插件化思想，允许第三方服务作为“插件”来响应核心系统的事件。</li></ol><h3 id="插件适配">插件适配</h3><blockquote><p>What would you do if you had a third-party plug-in that didn’tconform to the standard plug-in contract in the core system?</p><p>如果一个第三方插件不遵循核心系统的标准插件契约，你会怎么做？</p></blockquote><p>如果一个第三方插件不遵循核心系统的标准插件契约，最佳解决方案是引入<strong>适配器模式(Adapter Pattern)</strong>。</p><p>具体做法是：</p><ul><li><p>创建一个新的、我们自己控制的<strong>适配器插件 (AdapterPlug-in)</strong>，这个适配器插件<strong>遵循</strong>我们核心系统的标准契约。</p></li><li><p>在适配器插件的内部，它负责将核心系统发来的请求<strong>翻译</strong>成第三方插件能够理解的格式，并调用第三方插件。</p></li><li><p>反之，它也负责将第三方插件的返回结果<strong>翻译</strong>回核心系统期望的格式。</p></li></ul><h2 id="分区风格">分区风格</h2><blockquote><p>Is the microkernel architecture style technically partitioned ordomain partitioned?</p><p>微核架构是技术分区还是领域分区？</p></blockquote><p>微核架构是一种<strong>混合分区 (Hybrid Partitioning)</strong>的风格，这也是它独特的地方。</p><ul><li><strong>核心系统本身</strong>通常是<strong>技术分区</strong>的。它关注的是底层、通用的技术能力，如插件生命周期管理、安全、通信等，而不涉及具体的业务领域。</li><li><strong>插件组件</strong>则通常是<strong>领域分区</strong>的。每一个插件都封装了一个特定的业务功能或领域（例如<code>税务计算插件</code>、<code>保单审批插件</code>、<code>Git 版本控制插件</code>）。</li></ul><p>这种混合模式使得系统既有坚实的技术底座，又能灵活地按业务领域进行扩展。</p><h2 id="架构量子">架构量子</h2><blockquote><p>Why is the microkernel architecture always a single architecturequantum?</p><p>为什么微核架构总是单一的架构量子？</p></blockquote><p>首先，我们需要定义<strong>架构量子 (ArchitectureQuantum)</strong>：一个高功能内聚、可独立部署的组件，它包含了所有使其能够正常工作所需的元素（包括数据）。</p><p>微核架构在其经典实现中之所以是单一架构量子，是因为它在两个主要维度上表现出强烈的内聚和耦合：</p><ul><li><strong>在运行时维度上</strong>：组件共享同一个进程和内存空间，通过进程内调用紧密耦合，形成了一个"共同命运共同体"，缺乏独立的容错能力。</li><li><strong>在数据维度上</strong>：组件通常共享同一个物理数据库实例和事务上下文，导致在数据管理和演化上紧密耦合。</li></ul><h2 id="同构性">同构性</h2><blockquote><p>What is domain/architecture isomorphism?</p><p>什么是领域/架构同构性？</p></blockquote><p><strong>同构性 (Isomorphism)</strong>是一个源于数学的概念，意为"结构上的相似性"或"一对一的映射关系"。</p><p><strong>领域/架构同构性 (Domain/Architecture Isomorphism)</strong>指的是<strong>软件的架构结构与它所要解决的问题领域（业务领域）的结构高度一致</strong>。一个具备良好同构性的架构，其模块划分、组件关系能够清晰地反映出业务领域的划分和业务流程。</p><p>微核架构是展现领域/架构同构性的一个绝佳范例。</p><ul><li><strong>问题领域</strong>可以被分解为一个"通用基础平台"和多个"特定业务功能"。</li><li><strong>微核架构</strong>恰好与之对应：<strong>核心系统</strong>映射了''通用基础平台"，而每一个<strong>插件</strong>则精确地映射了一个"特定业务功能"。</li></ul><p>这种一一对应的关系使得系统非常容易被业务人员和开发人员共同理解，需求变更也能快速定位到需要修改的插件，极大地提升了系统的可维护性和演化能力。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十二章的课后思考题，深入探讨微核架构中插件组件间依赖关系的设计原则、插件管理工具与框架的选择策略、第三方插件契约兼容性处理方案，以及微核架构的分区特性、架构量子特征和领域同构性概念分析，帮助理解微核架构的核心设计模式和扩展机制，提升架构师在构建可扩展系统时的架构选择能力和插件化设计水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨11丨管道架构</title>
    <link href="https://hedon.top/2025/07/15/fosa/fosa-ch11/"/>
    <id>https://hedon.top/2025/07/15/fosa/fosa-ch11/</id>
    <published>2025-07-15T02:20:00.000Z</published>
    <updated>2025-07-27T04:29:14.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十一章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>Can pipes be bidirectional in a pipeline architecture?</p><p>在管道架构中管道可以是双向的吗？</p></li><li><p>Name the four types of filters and their purpose.</p><p>说出 4 种类型的过滤器及它们的作用。</p></li><li><p>Can a filter send data out through multiple pipes?</p><p>一个过滤器能否通过多条管道将数据发送出去？</p></li><li><p>Is the pipeline architecture style technically partitioned ordomain partitioned?</p><p>管道架构是技术分区还是领域分区？</p></li><li><p>In what way does the pipeline architecture supportmodularity?</p><p>管道架构是如何支持模块化的呢？</p></li><li><p>Provide two examples of the pipeline architecture style.</p><p>举 2 个管道架构的例子。</p></li></ol><hr /><h2 id="拓扑">拓扑</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250715105907327.png"alt="FOSA Figure 11-2. Pipeline architecture example" /><figcaption aria-hidden="true">FOSA Figure 11-2. Pipeline architectureexample</figcaption></figure><p>管道架构，又称为管道与过滤器架构（Pipes and FiltersArchitecture），是一种用于处理数据流的强大模式。它的核心思想非常直观，就像一条工厂的流水线：原材料从一端进入，经过一系列独立工站的加工、处理、检验，最终在另一端形成成品。</p><p>要理解管道架构，首先要理解它的两个基本构件：</p><ul><li><strong>过滤器(Filter)</strong>：它是一个独立的、可执行的处理单元，负责接收数据、执行单一任务（例如转换格式、过滤内容、扩充信息），然后将处理后的数据传递出去。关键在于，每个过滤器都是<strong>自包含（Self-Contained）</strong>和<strong>无状态（Stateless）</strong>的，它不关心上一个过滤器是谁，也不关心下一个过滤器是谁。</li><li><strong>管道(Pipe)</strong>：代表流水线上的"传送带"。它是一个<strong>单向</strong>的数据通道，负责将一个过滤器处理完的数据传递给下一个过滤器。</li></ul><p>在管道架构中，每个<strong>过滤器</strong>通常代表一个具体的技术操作，而不是一个完整的业务领域。整个管道将这些技术步骤串联起来，以完成一个业务流程，但其划分的单元（过滤器）是技术性的。</p><h2 id="管道">管道</h2><p>管道的<strong>单向性（Unidirectional）</strong>是该架构风格的基石。原因在于：</p><ol type="1"><li><strong>维持简单性与解耦</strong>：单向流动保证了数据处理的顺序性和可预测性。每个过滤器只需关注自己的输入和输出，无需处理复杂的双向通信或回调逻辑。</li><li><strong>避免状态依赖</strong>：如果管道是双向的，就意味着过滤器之间可能存在请求-响应（Request-Response）式的交互。这会引入状态和时间上的耦合，破坏了过滤器作为独立、无状态组件的核心原则。一个需要双向通信的场景，更适合采用其他架构风格（如客户端-服务器模式），而非管道架构。</li></ol><p>因此，严格意义上的管道架构，其管道必须是单向的。同时，管道也可以支持强大的分支（Forking）和扇出（Fan-out）能力，一个过滤器可以根据处理结果，将数据发送到不同的下游管道，这个过程依旧保持了其单向性。</p><h2 id="过滤器">过滤器</h2><ul><li><p><strong>生产者 (Producer /Source)</strong>：作为整条管道的<strong>起点</strong>。它不接收来自管道的数据，而是负责创建数据，并将这些初始数据泵入管道。</p></li><li><p><strong>转换器(Transformer)</strong>：它从上游管道接收数据，对其进行某种形式的<strong>修改或转换</strong>，然后将结果发送到下游管道。</p></li><li><p><strong>测试器(Tester)</strong>：它接收数据，并根据一个或多个条件对数据进行<strong>检验</strong>。如果数据满足条件，就将其传递到下游管道；如果不满足，则数据流在此处被中断（或被导向另一条错误处理管道）。</p></li><li><p><strong>消费者 (Consumer /Sink)</strong>：作为整条管道的<strong>终点</strong>。它从上游管道接收最终处理好的数据，并将其消费掉，通常不会再将数据传递出去。</p></li></ul><h2 id="模块化">模块化</h2><ul><li><strong>高内聚、低耦合（High Cohesion, LowCoupling）</strong>：每个过滤器都是一个高内聚的模块，只专注于完成一件定义明确的任务。同时，过滤器之间通过管道这一标准接口进行通信，实现了极低的耦合，它们互相不知道对方的存在。</li><li><strong>可组合性（Composability）</strong>：过滤器就像乐高积木。我们可以通过不同的排列组合，快速地搭建出全新的数据处理流程，而无需修改过滤器本身的代码。</li><li><strong>可复用性（Reusability）</strong>：一个通用的过滤器（例如<code>GzipCompressor</code>）可以被用在任何需要数据压缩的管道中，实现了代码的高度复用。</li><li><strong>可替换性（Replaceability）</strong>：只要遵守管道中的数据格式约定，我们可以轻易地用一个性能更好的新过滤器来替换掉一个旧的过滤器，而不会影响到管道的其他部分。</li></ul><h2 id="例子">例子</h2><h3 id="unixlinux-命令行">1. UNIX/Linux 命令行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | grep &quot;ERROR&quot; | sort | uniq -c</span><br></pre></td></tr></table></figure><ul><li><code>cat access.log</code>：生产者，读取日志文件并产生数据流。</li><li><code>|</code>：管道，将标准输出连接到下一个命令的标准输入。</li><li><code>grep "ERROR"</code>：测试器/转换器，过滤出包含 "ERROR"的行。</li><li><code>sort</code>：转换器，对错误日志进行排序。</li><li><code>uniq -c</code>：转换器/消费者，统计重复行并输出最终结果。</li></ul><h3 id="eltextract-transform-load-流程">2. ELT(Extract, Transform, Load)流程</h3><ul><li><strong>Extract（抽取）</strong>：生产者过滤器，从各种源系统（如业务数据库、日志文件、API）中读取原始数据。</li><li><strong>Transform（转换）</strong>：一系列转换器和测试器过滤器，对数据进行清洗（去除无效值）、转换（统一格式）、扩充（关联其他数据）、聚合（计算统计值）等操作。</li><li><strong>Load（加载）</strong>：消费者过滤器，将最终处理好的、高质量的数据加载到目标数据仓库或数据湖中，供后续分析使用。</li></ul>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十一章的课后思考题，深入探讨管道架构中管道双向性的可能性与限制、过滤器类型的分类与作用机制、数据流向的设计原则，以及管道架构的分区特性、模块化支持方式和典型应用场景分析，帮助理解管道与过滤器架构的核心概念和设计模式，提升架构师在处理数据流应用时的架构选择能力和系统设计水平。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨10丨分层架构</title>
    <link href="https://hedon.top/2025/07/14/fosa/fosa-ch10/"/>
    <id>https://hedon.top/2025/07/14/fosa/fosa-ch10/</id>
    <published>2025-07-14T02:20:00.000Z</published>
    <updated>2025-07-27T04:29:14.327Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第十章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>What is the difference between an open layer and a closedlayer?</p><p>开放层和封闭层有何区别？</p></li><li><p>Describe the layers of isolation concept and what the benefitsare of this concept.</p><p>隔离层概念及其益处是什么？</p></li><li><p>What is the architecture sinkhole anti-pattern?</p><p>架构漏斗反模式是什么？</p></li><li><p>What are some of the main architecture characteristics that woulddrive you to use a layered architecture?</p><p>驱动采用分层架构风格的主要架构特性有哪些？</p></li><li><p>Why isn’t testability well supported in the layered architecturestyle?</p><p>分层架构风格的可测试性为何不佳？</p></li><li><p>Why isn’t agility well supported in the layered architecturestyle?</p><p>分层架构风格的敏捷性为何不佳？</p></li></ol><hr /><h2 id="概念">概念</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250714113807168.png"alt="FOSA Figure 10-2. Physical topology (deployment) variants" /><figcaption aria-hidden="true">FOSA Figure 10-2. Physical topology(deployment) variants</figcaption></figure><p>分层架构的<strong>核心驱动力</strong>是<strong>关注点分离（SeparationofConcerns）</strong>。它将一个复杂的系统按照不同的职责或技术关注点，垂直地划分成若干个水平的“层（Layer）”。</p><p>每一层都有明确的职责：</p><ul><li><strong>表现层（PresentationLayer）</strong>：负责处理用户界面和交互，例如 Web 页面或 API端点。</li><li><strong>业务逻辑层（Business LogicLayer）</strong>：实现核心的业务规则和流程，是应用的心脏。</li><li><strong>持久化层（PersistenceLayer）</strong>：负责数据的存储和检索，与数据库交互。</li><li><strong>数据库层（DatabaseLayer）</strong>：即实际的数据库系统。</li></ul><p>这些层之间存在一个至关重要的约束：<strong>依赖关系是单向的</strong>。通常来说，上层可以依赖下层，但下层绝对不能依赖上层。例如，表现层可以调用业务逻辑层，但业务逻辑层不应该知道任何关于表现层的具体实现细节。</p><h2 id="封闭层-vs-开放层">封闭层 vs 开放层</h2><p><strong>封闭层（ClosedLayer）</strong>：当一个请求从上层向下层传递时，它<strong>必须</strong>逐层通过。</p><ul><li><strong>优点</strong>：提供了最高程度的<strong>隔离</strong>。由于每一层都只与它的邻居交流，下层实现细节的变更对上上层的影响被完全隔离。这正是"隔离层"概念的基础。</li><li><strong>缺点</strong>：可能会引入不必要的冗余代码和性能开销。</li></ul><p><strong>开放层（OpenLayer）</strong>：这是一种更为灵活的模式，允许上层"跳过"一个或多个中间层，直接访问更下方的层。</p><ul><li><strong>优点</strong>：当中间层对于某个特定请求没有任何业务逻辑需要添加时，开放该层可以避免编写无意义的传递（pass-through）代码，从而提高开发效率和运行效率。</li><li><strong>缺点</strong>：破坏了层与层之间的强隔离性。如果滥用开放层，会导致层级关系混乱，上层与多个下层产生耦合，削弱分层架构带来的可维护性优势。</li></ul><h2 id="隔离">隔离</h2><h3 id="概念及好处">概念及好处</h3><p>隔离指的是<strong>一个层中的变更，应该被隔离在这一层以及与之直接相邻的层中，而不会向上"泄漏"到更远的层</strong>。</p><p>想象一下，如果我们决定将数据库从 MySQL 迁移到PostgreSQL。这个变化发生在最底层的数据库层和持久化层。</p><ul><li><strong>理想情况（强隔离）</strong>：由于业务逻辑层只依赖于持久化层定义的接口（例如<code>UserRepository</code>），而不知道其背后是 MySQL 还是PostgreSQL，因此业务逻辑层代码<strong>完全不需要修改</strong>。表现层就更不受影响了。变更被成功"隔离"在了持久化层内部。</li><li><strong>隔离被破坏的情况</strong>：如果持久化层的某些特定实现细节（例如特定的SQL方言）泄漏到了业务逻辑层，那么在迁移数据库时，业务逻辑层也必须跟着修改。这就是隔离性的失败。</li></ul><p>这样做的好处有：</p><ul><li>极高的可维护性</li><li>技术栈的独立性</li><li>系统的可理解性</li></ul><h3 id="潜在的陷阱架构漏斗反模式">潜在的陷阱：架构漏斗反模式</h3><p><strong>架构漏斗反模式</strong>描述了这样一种情况：一个请求在流经多个封闭层时，其中一些中间层<strong>没有执行任何有意义的逻辑</strong>，仅仅是将请求原封不动地传递给下一层。这些"只传话、不干活"的层就成为了架构的"漏斗"或"沉洞"，增加了不必要的复杂度和代码量。</p><blockquote><p>可以使用二八原则，允许 20% 的 sinkhole，如果过多的sinkhole，则说明分层架构很可能不适用于当前的业务场景。</p></blockquote><h2 id="优点">优点</h2><ol type="1"><li><strong>简单性（Simplicity）和低成本（Cost）</strong>：分层架构模式非常成熟，广为人知，开发团队的学习成本极低。对于中小型项目、预算有限的初创公司或内部管理系统，它是一个"足够好"的、性价比极高的起点。</li><li><strong>可维护性（Maintainability）</strong>：如前所述，只要遵循了隔离层原则，系统的维护和迭代会非常清晰。对于那些业务逻辑相对稳定、变更不频繁的系统，这是一个巨大的优势。</li><li><strong>整体可部署性（Deployability）</strong>：分层架构天然倾向于构建<strong>单体应用（Monolith）</strong>。整个应用被打包成一个单元（例如一个WAR包或一个可执行文件）进行部署。这极大地简化了部署和运维的复杂度，尤其是在项目早期或运维能力有限的团队中。</li></ol><h2 id="缺点">缺点</h2><ul><li><strong>技术分区而非领域分区</strong>：分层架构是一种技术分区架构。这意味着它的组件是根据其在架构中的技术角色（如表示层、业务层、持久层），而不是根据业务领域（如客户、订单）进行分组的。这会导致任何特定的业务领域（例如“客户”领域）的逻辑都会分散在架构的所有层中。同时，当需要对特定业务领域的需求进行更改时，由于其逻辑分散在多个技术层中，开发人员必须在所有相关层中进行修改，这降低了开发的敏捷性。</li><li><strong>部署风险高</strong>：在分层架构中，即使是对少量代码的更改（例如，一个类文件中简单的三行更改），也需要重新部署整个部署单元。这种部署往往会捆绑数十个其他更改，从而显著增加了部署风险，且部署频率受到限制。</li><li><strong>测试范围大且不完整</strong>：由于整个应用程序是作为一个大型单体单元部署的，开发人员通常不会为简单的三行更改花费数小时执行完整的回归测试套件。这导致测试覆盖范围不完整，并且难以确保更改不会影响看似不相关的部分。</li></ul>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第十章的课后思考题，深入探讨分层架构中开放层与封闭层的核心差异、隔离层概念的重要价值、架构漏斗反模式的识别与防范，以及分层架构风格的主要驱动特性与局限性分析，帮助理解分层架构的设计原则和适用场景，提升架构师在选择和实施分层架构时的决策能力和风险评估意识。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨09丨架构风格基础</title>
    <link href="https://hedon.top/2025/07/10/fosa/fosa-ch9/"/>
    <id>https://hedon.top/2025/07/10/fosa/fosa-ch9/</id>
    <published>2025-07-10T02:20:00.000Z</published>
    <updated>2025-07-27T04:29:14.329Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第九章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>List the eight fallacies of distributed computing.</p><p>列举分布式计算中的 8 个谬论。</p></li><li><p>Name three challenges that distributed architectures have thatmonolithic architectures don’t.</p><p>说出 3 个单体架构没有而分布式架构有的挑战。</p></li><li><p>What is stamp coupling?</p><p>什么是邮票耦合？</p></li><li><p>What are some ways of addressing stamp coupling?</p><p>邮票耦合有哪些解决方案？</p></li></ol><hr /><h2 id="分布式八谬论">分布式八谬论</h2><p><strong>1. 网络是可靠的 (The network is reliable)。</strong></p><ul><li><strong>谬论</strong>：开发者常常假设网络连接永远不会中断，数据总能成功从A 点传输到 B 点。</li><li><strong>现实</strong>：网络硬件可能发生故障、交换机可能崩溃、路由器可能过载、网线可能被拔掉。任何网络调用都有可能失败，数据包可能会丢失、损坏或重复。因此，必须在设计中考虑网络中断的可能性，并加入重试机制(retry mechanisms)、超时 (timeouts)、熔断器 (circuit breakers)等容错策略。</li></ul><p><strong>2. 延迟为零 (Latency is zero)。</strong></p><ul><li><strong>谬论</strong>：开发者假设通过网络发送请求和接收响应是瞬时完成的，就像本地方法调用一样。</li><li><strong>现实</strong>：数据在网络上传输需要时间，这个时间被称为延迟(latency)。即使在光速的限制下，物理距离也会导致不可避免的延迟。网络拥堵、数据包的路由跳转等因素都会增加延迟。在设计分布式系统时，必须意识到延迟的存在，并尽可能地减少网络往返次数，例如通过批处理请求或使用异步通信模式。</li></ul><p><strong>3. 带宽是无限的 (Bandwidth is infinite)。</strong></p><ul><li><strong>谬论</strong>：开发者认为网络的传输能力是无限的，可以随心所欲地发送大量数据。</li><li><strong>现实</strong>：每个网络连接都有其最大吞吐量，即带宽(bandwidth)限制。过度发送数据会导致网络拥塞，增加延迟，甚至导致数据包丢失。架构师需要关注数据传输的效率，对数据进行压缩，避免在网络上传输不必要的“重量级”数据对象。</li></ul><p><strong>4. 网络是安全的 (The network is secure)。</strong></p><ul><li><strong>谬论</strong>：开发者假设内部网络是安全的，传输的数据不会被窃听或篡改。</li><li><strong>现实</strong>：任何网络连接都有可能受到攻击。数据在传输过程中可能被中间人(man-in-the-middle) 截获、窃听或修改。因此，必须采取加密措施（如TLS/SSL）来保护传输中的数据，并使用认证 (authentication) 和授权(authorization) 机制来确保只有合法的服务和用户才能访问资源。</li></ul><p><strong>5. 拓扑结构不会改变 (Topology doesn't change)。</strong></p><ul><li><strong>谬论</strong>：开发者假设网络的布局、服务器的地址和服务的部署位置是固定不变的。</li><li><strong>现实</strong>：在现代的云原生和微服务环境中，网络拓扑是动态变化的。服务器可能会宕机，新的服务实例可能会被启动，服务可能会被迁移到不同的物理位置或IP 地址。依赖硬编码的 IP 地址和端口是极其脆弱的。应该使用服务发现(service discovery) 机制来动态地查找和连接服务。</li></ul><p><strong>6. 只有一个管理员 (There is one administrator)。</strong></p><ul><li><strong>谬论</strong>：开发者认为整个分布式系统由一个全知全能的管理员或团队来维护，他们了解并控制系统的所有部分。</li><li><strong>现实</strong>：一个大型的分布式系统通常由多个团队共同开发和维护，每个团队只负责其中的一部分。不同团队、不同系统之间可能存在策略、配置和维护窗口的冲突。此外，系统还可能依赖由第三方管理的外部服务。因此，必须通过标准化的监控、日志记录和告警来获得对整个系统的可见性。</li></ul><p><strong>7. 传输成本为零 (Transport cost is zero)。</strong></p><ul><li><strong>谬论</strong>：开发者认为进行网络通信本身是不需要成本的。</li><li><strong>现实</strong>：这里所说的“成本”不仅指金钱。它包括了运行网络硬件所需的CPU 周期、内存，以及将数据序列化 (serialization) 和反序列化(deserialization)所需的计算资源。在云环境中，网络流量本身通常也是直接收费的。因此，在设计API 和数据格式时，需要考虑其对性能和运营成本的综合影响。</li></ul><p><strong>8. 网络是同质的 (The network is homogeneous)。</strong></p><ul><li><strong>谬论</strong>：开发者假设网络中的所有设备都来自同一个供应商，使用相同的协议栈，并且性能表现一致。</li><li><strong>现实</strong>：一个复杂的网络通常由来自不同供应商的硬件（路由器、交换机、防火墙）和运行着不同操作系统（Linux,Windows）的服务器组成。这些异构组件的组合可能导致意想不到的兼容性问题和性能瓶颈。在设计系统时，应依赖于广泛支持的标准化协议，并对系统的端到端性能进行充分测试。</li></ul><h2 id="分布式系统挑战">分布式系统挑战</h2><p><strong>1. 服务间通信的复杂性 (Inter-service CommunicationComplexity)</strong></p><ul><li><strong>在单体架构中</strong>：不同模块或组件之间的调用是进程内的函数调用(in-process functioncalls)。这种调用非常快速、可靠，并且事务性可以通过语言层面的机制轻松保证。</li><li><strong>在分布式架构中</strong>：服务间的调用变成了跨网络的远程过程调用(RPC)。这立刻引入了前述“分布式计算的 8个谬论”中的所有问题：网络可能失败，存在延迟，带宽有限，需要考虑安全等。开发者必须处理部分失败(partial failure)的情况——即一个服务可用，而它依赖的另一个服务却不可用。这就需要引入重试、超时、熔断、服务发现等复杂的模式来保证系统的韧性(resilience)。</li></ul><p><strong>2. 分布式事务与数据一致性 (Distributed Transactions and DataConsistency)</strong></p><ul><li><strong>在单体架构中</strong>：通常使用单一的数据库，可以依赖数据库本身提供的ACID（原子性、一致性、隔离性、持久性）事务来保证跨多个数据表的强一致性。操作要么全部成功，要么全部失败，状态不会处于中间状态。</li><li><strong>在分布式架构中</strong>：每个服务通常拥有自己独立的数据库，以实现松耦合和独立部署。当一个业务流程需要跨越多个服务时，就无法使用传统的单数据库事务。这就带来了分布式事务的挑战。实现强一致性的两阶段提交(Two-Phase Commit, 2PC)等协议通常非常复杂且性能低下。因此，架构师往往不得不放弃强一致性，转而寻求最终一致性(eventual consistency)，并采用 Saga 模式、事件溯源 (Event Sourcing)等更复杂的模式来管理跨服务的数据一致性，这极大地增加了开发的难度和心智负担。</li></ul><p><strong>3. 运维和监控的复杂性 (Operational and ObservabilityComplexity)</strong></p><ul><li><p><strong>在单体架构中</strong>：整个应用被部署为一个单元。日志集中在一个地方，调试相对直接（例如，通过附加调试器），监控也相对简单，只需关注单个进程和服务器的CPU、内存等指标。</p></li><li><p><strong>在分布式架构中</strong>：一个请求可能会流经数十个甚至上百个服务。要诊断一个问题，你需要追踪这个请求在整个系统中的调用链。这就需要建立复杂的“可观测性”(Observability) 体系，包括：</p><ul><li><p><strong>集中式日志 (CentralizedLogging)</strong>：将所有服务的日志聚合到一起进行分析。</p></li><li><p><strong>分布式追踪 (DistributedTracing)</strong>：为每个请求分配一个唯一的ID，并在整个调用链中传递，以便追踪其路径和耗时。</p></li><li><p><strong>聚合指标 (MetricsAggregation)</strong>：从各个服务收集关键性能指标（如请求率、错误率、延迟）并进行聚合展示。</p><p>部署、扩缩容、故障排查的难度都呈指数级增长。</p></li></ul></li></ul><h2 id="邮票耦合">邮票耦合</h2><p><strong>邮票耦合 (Stamp Coupling)</strong>是一种特定类型的<strong>数据耦合 (DataCoupling)</strong>。当一个模块（或服务）向另一个模块传递一个复杂的数据结构（如一个对象或记录），但接收方模块实际上只需要该数据结构中的一小部分字段时，就发生了邮票耦合。</p><p>这个名字的比喻来源于：</p><blockquote><p>你只是想寄一封信，却把整个邮局（包含了所有信件和包裹）都递给了邮递员。接收方不得不从这个庞大的结构中"筛选"出自己需要的信息。</p></blockquote><p>核心特征：</p><ul><li><strong>传递了超量信息</strong>：调用者传递了比被调用者实际需要的多得多的数据。</li><li><strong>不必要的依赖</strong>：被调用者被迫依赖于一个它并不完全需要的数据结构的具体定义。</li></ul><p>解决邮票耦合的核心思想是将数据契约 (data contract)的关注点从"<strong>提供方有什么</strong>"转变为"<strong>消费方要什么</strong>"。</p><ul><li><strong>创建私有的 RESTful API端点</strong>：为特定的内部消费者（服务）创建专门的、不对外公开的 API端点(endpoint)。这些端点被设计为只返回该消费者完成其特定任务所必需的数据子集。</li><li><strong>在契约中使用字段选择器</strong>：允许 API的调用方通过查询参数 (query parameter)来动态指定响应中应包含哪些字段。</li><li><strong>使用 GraphQL 来解耦契约</strong>：GraphQL从根本上就是为了解决 REST API 中常见的数据过度获取 (over-fetching)和数据获取不足 (under-fetching)问题而设计的，而过度获取正是邮票耦合的表现形式。</li><li><strong>使用价值驱动契约与消费者驱动契约</strong>：消费者驱动契约(CDC) 是一种模式，其中 API的消费者编写一份"契约"，明确声明它对提供者的期望（需要哪些字段、什么样的数据格式）。这份契约被用作自动化测试的一部分。</li><li><strong>使用内部消息端点</strong>：在消息系统中，不发布一个包含完整实体状态的"大而全"的事件，而是发布更细粒度、更具业务意图的事件。</li></ul><p>总而言之，这五种方案都体现了从 Push 模型向 Pull模型的转变，是解决分布式系统中耦合问题的关键实践。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第九章的课后思考题，深入探讨分布式计算的八大谬论及其对架构设计的影响、分布式架构相比单体架构面临的独特挑战、邮票耦合问题的本质与危害，以及解决邮票耦合的有效策略与最佳实践，帮助理解分布式系统设计的核心原则和常见陷阱，提升架构师在分布式环境下的决策能力和风险识别意识。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨08丨组件思维</title>
    <link href="https://hedon.top/2025/07/09/fosa/fosa-ch8/"/>
    <id>https://hedon.top/2025/07/09/fosa/fosa-ch8/</id>
    <published>2025-07-09T02:20:00.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第八章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>We define the term <em>component</em> as a building block of anapplication—something the application does. A component usually consistof a group of classes or source files. How are components typicallymanifested within an application or service?</p><p>组件在应用程序或服务中通常如何体现？</p></li><li><p>What is the difference between technical partitioning and domainpartitioning? Provide an example of each.</p><p>技术分区和领域分区有什么区别？请各举一个例子。</p></li><li><p>What is the advantage of domain partitioning?</p><p>领域分区的优点是什么？</p></li><li><p>Under what circumstances would technical partitioning be a betterchoice over domain partitioning?</p><p>在什么情况下，技术分区会是比领域分区更好的选择？</p></li><li><p>What is the entity trap? Why is it not a good approach forcomponent identification?</p><p>"实体陷阱"是什么？为什么它不是一种好的组件识别方法？</p></li><li><p>When might you choose the workflow approach over theActor/Actions approach when identifying core components?</p><p>在识别核心组件时，你何时会选择 workflow 方法而不是 actor/actions方法？</p></li></ol><hr /><h2 id="组件范围">组件范围</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250709102652672.png"alt="FOSA Figure 8-1. Different varieties of components" /><figcaption aria-hidden="true">FOSA Figure 8-1. Different varieties ofcomponents</figcaption></figure><p>在软件架构中，组件被定义为模块的物理体现。它代表了相关代码的逻辑分组，并通过不同的方式进行物理打包。</p><p>组件在应用程序或服务中的典型体现方式包括：</p><ul><li><strong>库文件</strong>：这是最简单的组件形式，它将代码包装成更高层次的模块，通常在与调用代码相同的内存地址空间中运行，并通过语言函数调用机制进行通信。例如，Java中的 JAR 文件、.NET 中的 DLL 文件和 Ruby 中的 Gem 文件。</li><li><strong>子系统或层</strong>：组件也可以作为架构中的子系统或层来出现。</li><li><strong>服务</strong>：特别是在微服务等架构风格中，服务是一种组件，它在自己的地址空间中运行，并通过低级网络协议（如TCP/IP）或高级格式（如 REST或消息队列）进行通信，形成独立的、可部署的单元。</li><li><strong>逻辑边界</strong>：从领域驱动设计（DDD）的角度来看，有界上下文（BoundedContexts）物理组件，例如服务、子系统等。每个有界上下文应作为一个独立的服务或项目来实现，这意味着它可以独立于其他有界上下文进行实现、演进和版本控制。有时一个有界上下文可以包含多个子域，此时有界上下文是物理边界，而其每个子域是逻辑边界，这些逻辑边界在不同编程语言中可能被称为命名空间、模块或包。</li></ul><p>总之，组件是架构中最基本的模块化构建块，它们定义了代码的组织方式以及系统各部分之间的交互方式。</p><h2 id="架构分区">架构分区</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250709102924588.png"alt="FOSA Figure 8-4. Two types of top-level partitioning in architecture" /><figcaption aria-hidden="true">FOSA Figure 8-4. Two types of top-levelpartitioning in architecture</figcaption></figure><h3 id="技术分区">技术分区</h3><p><strong>技术分区 (Technical Partitioning):</strong> 是<strong>根据代码的技术职责</strong>来组织代码。这是传统分层架构的典型做法。每一层都有明确的技术目标，例如处理HTTP 请求、执行业务规则或与数据库交互。</p><p>典型分层:</p><ul><li><strong>表现层 (Presentation/UI):</strong>负责处理用户交互和展示，例如 MVC 框架中的 <code>Controller</code> 和<code>View</code>。</li><li><strong>业务逻辑层 (Business/Service):</strong>负责实现核心业务规则和流程，是系统的核心。</li><li><strong>数据访问层 (Data Access/Persistence):</strong>负责与数据库或其他数据存储进行交互，执行增删改查 (CRUD)。</li></ul><p>优点：</p><ul><li>简单直观，上手快</li><li>清晰的技术关注点分离</li><li>促进技术层面的代码复用</li></ul><p>缺点：</p><ul><li><strong>业务内聚性极低 (Low Business Cohesion):</strong>这是技术分区最大的问题。一个完整的业务功能（例如，"用户下单"）的逻辑被强制拆散，散落在所有三个层次中。当你需要理解或修改这个功能时，必须在多个目录和文件中来回跳转，增加了认知负荷。</li><li><strong>功能开发导致高耦合 (High Coupling for FeatureDevelopment):</strong>由于功能代码被分散，任何一个业务需求的变更，都可能导致从上到下的“全垒打”式修改（即<code>Controller</code> -&gt; <code>Service</code> -&gt;<code>Repository</code>都需要改）。这使得变更的影响范围变大，回归测试的成本也更高。</li><li><strong>容易形成“上帝类”和瓶颈 (Prone to "God Classes" andBottlenecks):</strong> 随着业务越来越复杂，业务逻辑层(<code>Business Layer</code>)很容易膨胀成一个巨大而臃肿的“上帝模块”，它了解所有业务细节，被所有表现层组件依赖。这个模块会变得难以维护和测试，成为整个系统演进的瓶颈。</li><li><strong>阻碍团队自治和独立扩展 (Impedes Team Autonomy andScalability):</strong>很难将一个完整的业务功能垂直地分配给一个团队。两个团队开发不同功能时，很可能会在共享的业务逻辑层或数据访问层产生代码冲突。在分布式架构中，你也无法仅仅因为订单逻辑复杂就单独扩展业务逻辑层，而必须扩展整个单体应用。</li></ul><p>适用场景：</p><ul><li><strong>小型、简单的应用程序：</strong> 尤其是 CRUD密集型的管理后台、内容管理系统等。</li><li><strong>业务领域稳定且不复杂：</strong>如果业务在可预见的未来不会有大的变化，技术分区的简单性就是一种优势。</li><li><strong>项目初期或概念验证 (PoC):</strong>当业务边界尚不明确，需要快速验证想法时，可以从技术分区开始。</li><li><strong>按技术职能划分的团队：</strong>如果你的公司有独立的前端团队、后端 Java 团队和 DBA团队，这种分区方式能匹配组织结构。</li></ul><h3 id="领域分区">领域分区</h3><p><strong>领域分区 (Domain Partitioning):</strong> 是<strong>根据业务领域或业务能力</strong>来组织代码。每个组件都封装了某个特定业务领域所需的所有技术实现。这与领域驱动设计(DDD) 的思想高度一致。</p><p>典型分区:</p><ul><li><strong>订单组件 (Ordering):</strong> 包含处理订单的所有逻辑，从 API端点到数据库交互。</li><li><strong>库存组件 (Inventory):</strong> 负责管理商品库存。</li><li><strong>支付组件 (Payment):</strong> 封装与支付相关的所有功能。</li></ul><p>优点：</p><ul><li>业务内聚性极高</li><li>领域间的低耦合</li><li>支持团队自治和并行开发</li><li>易于独立扩展和部署</li><li>增强系统的演进能力</li></ul><p>缺点：</p><ul><li><strong>初期复杂度和设计门槛高 (Higher Initial Complexity):</strong>正确地识别和划分领域边界是领域分区的核心挑战。这需要架构师对业务有深刻的理解，并投入大量的前期分析设计（例如通过领域驱动设计DDD中的事件风暴等实践）。如果边界划分错误，后期的重构成本会非常高。</li><li><strong>可能导致代码重复 (Potential for Code Duplication):</strong>不同的领域组件可能需要相似的功能，例如身份验证、日志记录、数据访问模式等。如果缺乏良好的治理，这些横切关注点(Cross-cutting Concerns)可能会在多个组件中被重复实现。这通常需要通过共享库、平台服务或服务网格(Service Mesh) 来解决。</li><li><strong>分布式架构的额外开销 (Overhead of DistributedArchitecture):</strong>如果将每个领域组件实现为微服务，就需要处理分布式系统带来的所有复杂性，如服务发现、网络延迟、数据一致性、分布式事务等。</li></ul><p>适用场景：</p><ul><li><strong>大型、复杂的企业级系统：</strong>尤其是那些业务逻辑复杂、需要长期演进的系统。</li><li><strong>微服务架构 (Microservices Architecture):</strong>领域分区是实现微服务的标准和基础。</li></ul><h2 id="组件识别">组件识别</h2><p>组件识别是指在定义了宏观的架构风格（例如，分层单体、微服务）之后，<strong>发现和划定系统中各个功能模块（即组件）边界的过程</strong>。这个过程的目标是创建一组高内聚、低耦合的组件。</p><p>组件识别不是一个随意的过程，它需要系统性的方法和深刻的业务理解。如果边界划分错误，将会导致维护困难、扩展不易等一系列问题。接下来我们将要讨论的几个概念，正是服务于这个目的的方法论和需要警惕的陷阱。</p><h3 id="实体陷阱">实体陷阱</h3><p>这是在组件识别过程中最常见、也最需要警惕的一个反模式(Anti-pattern)。</p><p>实体陷阱是指<strong>错误地将数据实体（通常直接对应数据库中的表）当作组件来进行划分</strong>。例如，系统中有<code>User</code>, <code>Product</code>, <code>Order</code>三张表，就草率地创建 <code>User</code> 组件、<code>Product</code> 组件和<code>Order</code> 组件。</p><p>为什么是陷阱？</p><blockquote><p>软件的核心价值在于处理 <strong>业务流程 (BusinessWorkflow)</strong>，而不仅仅是管理数据。一个有意义的业务流程往往会跨越多个数据实体。</p></blockquote><p>我们以经典的"用户下单"流程为例。这个行为需要：</p><ol type="1"><li>读取 <strong>用户信息</strong> (User) 以确认其身份和收货地址。</li><li>查询 <strong>商品信息</strong> (Product) 以获取价格并检查库存。</li><li>创建一个新的 <strong>订单记录</strong> (Order)。</li><li>更新 <strong>商品库存</strong> (Product)。</li></ol><p>如果 <code>User</code>、<code>Product</code>、<code>Order</code>各自是一个独立的组件，那么"用户下单"这段核心业务逻辑应该放在哪里呢？</p><ul><li>放在 <code>Order</code> 组件里？那么它就需要频繁调用<code>User</code> 组件和 <code>Product</code>组件，并且可能需要了解它们的内部数据结构，形成了紧密的耦合。</li><li>放在一个单独的 <code>PlacingOrderService</code>里？这个服务本身没有归属，像一个"流浪"的脚本，操纵着另外三个“只有数据没有行为”的贫血组件。</li></ul><p><strong>结论：</strong> 实体陷阱导致了<strong>业务逻辑的碎片化</strong> 和<strong>组件间的高度耦合</strong>。</p><blockquote><p>👉🏻 正确的做法是围绕 <strong>业务能力</strong>来划分组件，而不是围绕数据实体。一个更合理的组件应该是<code>Ordering</code> (订单管理)，它封装了 <code>Order</code>实体以及所有相关的业务行为（如下单、取消订单、查询订单状态等）。</p></blockquote><h3 id="actoractions">Actor/Actions</h3><p>这是一种非常直观且有效的自顶向下的组件识别方法。它的核心是回答："<strong>谁(Who) 会对系统做什么 (What)？</strong>"</p><p><strong>实施步骤：</strong></p><ol type="1"><li><strong>识别执行者 (Identify Actors):</strong>列出所有会与系统交互的"人"或"外部系统"。例如：顾客 (Customer)、管理员(Admin)、仓库管理系统 (WMS)、支付网关 (Payment Gateway)。</li><li><strong>识别操作 (Identify Actions):</strong>针对每一个执行者，列出他们会对系统发起的具体操作（可以理解为用例）。<ul><li><strong>顾客</strong>可以：搜索商品、查看商品详情、添加购物车、提交订单、支付。</li><li><strong>管理员</strong>可以：上架商品、调整价格、查看销售报表。</li></ul></li><li><strong>组件划分：</strong> 将相关的操作进行分组，形成初步的组件。<ul><li><code>搜索商品</code>、<code>查看商品详情</code> -&gt; 可能属于<code>Catalog</code> (商品目录) 组件。</li><li><code>添加购物车</code>、<code>提交订单</code> -&gt; 可能属于<code>Ordering</code> (订单) 组件。</li><li><code>上架商品</code>、<code>调整价格</code> -&gt; 可能属于<code>ProductManagement</code> (商品管理) 组件。</li></ul></li></ol><p><strong>优点：</strong></p><ul><li>简单直观，易于上手。</li><li>以用户为中心，能很好地识别出面向用户的核心功能。</li></ul><p><strong>缺点：</strong></p><ul><li>可能遗漏那些没有明确执行者的后台流程或系统内部流程。</li></ul><h3 id="event-storming">Event storming</h3><p>事件风暴是领域驱动设计 (DDD) 中一种强大的<strong>协作式工作坊技术</strong>，用于快速、全面地探索复杂的业务领域，并从中识别出聚合(Aggregates) 和限界上下文 (BoundedContexts)，而这些正是划分高质量组件（尤其是微服务）的理想边界。</p><p><strong>核心过程:</strong>这是一个由业务专家和技术专家共同参与的会议，大家在一个足够大的墙上，用不同颜色的即时贴(sticky notes) 来“风暴”出整个业务流程。</p><ol type="1"><li><strong>橙色贴 - 领域事件 (Domain Event):</strong><ul><li><strong>规则：</strong>用过去时态描述业务中发生过的、有价值的事情。这是整个风暴的核心。</li><li><strong>例子：</strong><code>订单已提交</code>、<code>商品已添加到购物车</code>、<code>用户已注册</code>。</li><li>大家将所有能想到的事件，按照时间顺序从左到右贴在墙上。</li></ul></li><li><strong>蓝色贴 - 命令 (Command):</strong><ul><li><strong>规则：</strong> 触发领域事件的用户操作或系统指令。</li><li><strong>例子：</strong> <code>提交订单</code> (触发<code>订单已提交</code>)、<code>添加商品到购物车</code> (触发<code>商品已添加到购物车</code>)。</li></ul></li><li><strong>黄色小贴 - 执行者 (Actor):</strong><ul><li><strong>规则：</strong> 发出命令的人或系统。</li><li><strong>例子：</strong> <code>顾客</code> (发出<code>提交订单</code> 命令)。</li></ul></li><li><strong>粉色/黄色大贴 - 聚合 (Aggregate):</strong><ul><li><strong>规则：</strong>聚合是处理命令并产生事件的业务实体，它负责维护一组相关对象的数据一致性。</li><li><strong>例子：</strong> <code>订单</code> 聚合负责处理<code>提交订单</code> 命令，并产生 <code>订单已提交</code> 事件。</li></ul></li><li><strong>划定边界 - 限界上下文 (Bounded Context):</strong>当整个流程可视化之后，团队会发现某些事件、命令和聚合在业务上高度相关，形成了一个个的"簇"。这些"簇"的边界，就是<strong>限界上下文</strong> 的边界，也是 <strong>组件/微服务</strong>的理想边界。例如，所有与订单创建、修改、状态流转相关的即时贴会自然地聚集在一起，形成<code>Ordering</code> 上下文。</li></ol><p><strong>优点：</strong></p><ul><li><strong>协作性：</strong>打破了业务与技术之间的隔阂，让所有人对业务有统一的理解。</li><li><strong>深度洞察：</strong> 能发现隐性的业务规则和流程，识别出比Actor/Actions 更自然的边界。</li><li><strong>结果可靠：</strong>通过事件风暴识别出的边界通常非常稳定，是划分微服务的黄金标准。</li></ul><h3 id="workflow">Workflow</h3><p>这种方法是对 Actor/Actions 方法的一个重要补充，它专注于识别那些<strong>没有明确、单一执行者的端到端业务流程</strong>。</p><p><strong>核心思想：</strong>寻找系统中的关键业务事件，并追踪由该事件引发的一系列后续处理步骤，将整个流程封装成一个组件。</p><p><strong>实施步骤：</strong></p><ol type="1"><li><strong>识别关键业务事件或调度任务：</strong>例如："订单支付成功"、"每月一日进行财务结算"。</li><li><strong>描绘工作流：</strong>画出该事件发生后，系统需要依次完成的所有步骤。<ul><li><strong>事件：订单支付成功 (Order Paid)</strong></li><li><strong>工作流：</strong><ol type="1"><li>更新订单状态为“待发货”。</li><li>调用仓库管理系统 (WMS) 接口，通知发货。</li><li>向用户发送“支付成功”的邮件/短信。</li><li>为用户增加积分。</li></ol></li></ul></li><li><strong>组件划分：</strong>整个工作流可以被识别为一个或多个组件。例如，可以有一个<code>OrderFulfillment</code> (订单履行) 组件来编排这个流程。</li></ol><p><strong>适用场景：</strong></p><ul><li><strong>后台处理：</strong> 如报表生成、数据同步、月末结算等。</li><li><strong>异步流程：</strong>一个操作触发后，后台需要执行一系列复杂的、耗时的任务。</li><li><strong>编排服务 (Orchestration):</strong>一个组件的主要职责是调用其他多个组件/服务来完成一个复杂的业务目标。</li></ul><h2 id="架构师职责">架构师职责</h2><ul><li>架构职责：架构分区<ul><li>按层分区</li><li>按模块分区</li><li>按技术分区</li><li>按领域分区</li></ul></li><li>开发职责：组件识别<ul><li>识别基础组件</li><li>为组件赋予需求</li><li>分析组件角色和职责</li><li>分析架构特征</li><li>重构组件</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第八章的课后思考题，深入探讨软件组件的核心概念与实现方式、技术导向与领域导向分区策略的差异、实体陷阱问题的本质及解决方案，以及Actor/Actions模式、工作流分析和事件风暴等组件识别技术的适用场景与局限性，帮助理解如何运用领域驱动的思维方式来设计组件边界，提升系统的内聚性、松耦合特性和业务适应能力。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Rust 入门丨02 闭包</title>
    <link href="https://hedon.top/2025/07/08/rust-02-closure/"/>
    <id>https://hedon.top/2025/07/08/rust-02-closure/</id>
    <published>2025-07-08T05:22:00.000Z</published>
    <updated>2025-07-27T04:29:14.333Z</updated>
    
    <content type="html"><![CDATA[<p>笔者之前一直不理解 Rust 中关于闭包的 Fn/FnMut/FnOnce 这 3 个 trait的包含关系。通过一段时间的学习和分析，终于找到了我思维上的一个错误点，特此梳理此文，方便日后查询。</p><p>我之前的理解是这样的：</p><blockquote><p>Fn 只需要引用，所以要求是最容易满足的。FnMut需要的是可变引用，所以能满足 FnMut，一定能满足 Fn。FnOnce需要的是所有权，那都有所有权了 ，&amp;mut 和 &amp;肯定就不在话下了。所以满足 FnOnce 的，一定是 Fn 和 FnMut。满足 FnMut的，不一定是 FnOnce，但是一定是 Fn。</p></blockquote><p>我的错误点在于：在<strong>闭包实现者</strong>的角度想"我拥有什么权限"。</p><p>正确的思路应该是：<u>站在<strong>函数调用者</strong>的角度想"我得到了什么承诺"</u>。这才是Trait 设计的本质，即是能力的声明，更是限制的承诺。</p><hr /><h3id="核心关键承诺越强限制越多类型越小">核心关键：承诺越强，限制越多，类型越“小”</h3><p><code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code> 这三个Trait，本质上是闭包对<strong>调用者</strong>做出的三种不同强度的<strong>承诺</strong>。</p><ol type="1"><li><strong><code>Fn</code> 的承诺 (最强的承诺)</strong><ul><li><strong>承诺内容</strong>：调用我，只需要对我进行不可变借用(<code>&amp;self</code>)。你甚至可以同时在多个线程里调用我。我保证不会改变任何东西，也不会消耗掉自己。</li><li><strong>对闭包的限制</strong>：为了兑现这个最强的承诺，闭包自身受到的限制也最大。它<strong>只能</strong>不可变地借用环境中的变量。</li><li><strong>调用者的自由</strong>：调用者获得了最大的自由，可以随心所欲地、不限次数地调用这个闭包。</li></ul></li><li><strong><code>FnMut</code> 的承诺 (中等的承诺)</strong><ul><li><strong>承诺内容</strong>：调用我，需要对我进行可变借用(<code>&amp;mut self</code>)。这意味着你不能同时调用我，但可以一个接一个地调用。我可能会改变我内部的状态。</li><li><strong>对闭包的限制</strong>：限制有所放宽。闭包可以<strong>可变地</strong>借用环境变量。</li><li><strong>调用者的自由</strong>：调用者的自由受到了一些限制，不能并发调用了。</li></ul></li><li><strong><code>FnOnce</code> 的承诺 (最弱的承诺)</strong><ul><li><strong>承诺内容</strong>：你<strong>只能</strong>调用我一次(<code>self</code>)。调用之后，我就会被消耗掉，不复存在。</li><li><strong>对闭包的限制</strong>：对闭包自身的限制最小。它可以随心所欲，甚至可以拿走环境变量的<strong>所有权</strong>。</li><li><strong>调用者的自由</strong>：调用者只拥有一次调用的机会，自由度最低。</li></ul></li></ol><h3 id="将之前的逻辑反过来思考">将之前的逻辑反过来思考</h3><p>用"承诺"的视角：</p><ul><li><strong>错误想法</strong>：<code>FnOnce</code>有所有权，最厉害，所以它包含了 <code>FnMut</code> 和<code>Fn</code>。</li><li><strong>正确的逻辑</strong>：一个闭包如果能做出 <code>Fn</code>的承诺（最强承诺），那么它自然也能满足 <code>FnMut</code>（中等承诺）和<code>FnOnce</code>（最弱承诺）的要求。</li></ul><p>这就像一个人的信用评级：</p><ul><li>一个能被评为 <strong>AAA 级信用 (<code>Fn</code>)</strong>的人，向他借钱（调用他）风险极低，可以随时借。他自然也满足 <strong>AA 级(<code>FnMut</code>)</strong> 和 <strong>A 级(<code>FnOnce</code>)</strong> 的标准。</li><li>一个被评为 <strong>AA 级信用 (<code>FnMut</code>)</strong>的人，满足不了 AAA 级的苛刻标准，但他肯定满足 A 级的基本标准。</li><li>一个只有 <strong>A 级信用 (<code>FnOnce</code>)</strong>的人，意味着和他交易有风险，只能“一次性买卖”，他肯定满足不了 AA 级和 AAA级的要求。</li></ul><p>所以，这个关系是：</p><ul><li>凡是 <code>Fn</code>，必然是 <code>FnMut</code> 和<code>FnOnce</code>。</li><li>凡是 <code>FnMut</code>，必然是 <code>FnOnce</code>，但不一定是<code>Fn</code>。</li><li><code>FnOnce</code> 最为宽泛，它不承诺自己是 <code>FnMut</code> 或<code>Fn</code>。</li></ul><h3 id="代码验证">代码验证</h3><p>我们用一个具体的例子来印证这个理论。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个函数，它要求一个“AAA信用”的闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_repeatedly</span>&lt;F: <span class="title function_ invoke__">Fn</span>()&gt;(closure: F) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;--- Calling an Fn closure ---&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，它要求一个“AA信用”的闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_mutably</span>&lt;F: <span class="title function_ invoke__">FnMut</span>()&gt;(<span class="keyword">mut</span> closure: F) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;--- Calling an FnMut closure ---&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，它只要求“A信用”的闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">call_once</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt;(closure: F) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;--- Calling an FnOnce closure ---&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">closure</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">owned_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 这是一个 Fn 闭包，因为它只对 my_string 进行了不可变借用。</span></span><br><span class="line">    <span class="comment">// 它做出了最强的承诺。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure_fn</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Fn says: &#123;&#125;&quot;</span>, my_string);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 这是一个 FnMut 闭包，因为它对 my_string 进行了可变借用。</span></span><br><span class="line">    <span class="comment">// 它只能做出中等承诺。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">closure_fn_mut</span> = || &#123;</span><br><span class="line">        my_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;FnMut says: &#123;&#125;&quot;</span>, my_string);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 这是一个 FnOnce 闭包，因为它夺走了 owned_string 的所有权。</span></span><br><span class="line">    <span class="comment">// 它只能做出最弱的承诺。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure_fn_once</span> = || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">consumed</span> = owned_string;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;FnOnce says: &#123;&#125;&quot;</span>, consumed);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 开始验证 ---</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// `closure_fn` (AAA级) 可以满足所有要求</span></span><br><span class="line">    <span class="title function_ invoke__">call_repeatedly</span>(closure_fn);</span><br><span class="line">    <span class="title function_ invoke__">call_mutably</span>(closure_fn);</span><br><span class="line">    <span class="title function_ invoke__">call_once</span>(closure_fn);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `closure_fn_mut` (AA级) 满足不了 AAA 级的要求</span></span><br><span class="line">    <span class="comment">// call_repeatedly(closure_fn_mut); // 编译错误！因为它改变了环境，不满足 Fn 的要求</span></span><br><span class="line">    <span class="title function_ invoke__">call_mutably</span>(&amp;<span class="keyword">mut</span> closure_fn_mut);</span><br><span class="line">    <span class="title function_ invoke__">call_once</span>(&amp;<span class="keyword">mut</span> closure_fn_mut);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `closure_fn_once` (A级) 只能满足最基本的要求</span></span><br><span class="line">    <span class="comment">// call_repeatedly(closure_fn_once); // 编译错误！</span></span><br><span class="line">    <span class="comment">// call_mutably(closure_fn_once);    // 编译错误！因为它被调用后就没了，不能调用第二次</span></span><br><span class="line">    <span class="title function_ invoke__">call_once</span>(closure_fn_once);</span><br><span class="line">    <span class="comment">// call_once(closure_fn_once); // 再次调用也会编译错误，因为它已经被消耗了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>在 Rust 的 Trait系统中，一个类型如果满足更强的承诺（<code>Fn</code>），它就能被用在要求较弱承诺（<code>FnMut</code>,<code>FnOnce</code>）的任何地方。这就是为什么 <code>Fn</code>是最小、最核心的那个集合。</p>]]></content>
    
    
    <summary type="html">本文通过&quot;承诺&quot;的视角深入解析 Rust 闭包中 Fn、FnMut、FnOnce 三个 trait 的包含关系，帮助读者理解闭包设计的本质。</summary>
    
    
    
    <category term="rust" scheme="https://hedon.top/categories/rust/"/>
    
    <category term="Rust 入门" scheme="https://hedon.top/categories/rust/Rust-%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="rust" scheme="https://hedon.top/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨07丨架构特性范围</title>
    <link href="https://hedon.top/2025/07/08/fosa/fosa-ch7/"/>
    <id>https://hedon.top/2025/07/08/fosa/fosa-ch7/</id>
    <published>2025-07-08T03:00:00.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第七章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>What is an architectural quantum, and why is it important toarchitecture?</p><p>为什么是架构量子？它为什么对架构很重要？</p></li><li><p>Assume a system consisting of a single user interface with fourindependently deployed services, each containing its own separatedatabase. Would this system have a single quantum or four quanta?Why?</p><p>假设一个系统包含一个单一的用户界面，以及四个独立部署的服务，每个服务都包含自己的独立数据库。这个系统会有一个量子还是四个量子？为什么？</p></li><li><p>Assume a system with an administration portion managing staticreference data (such as the product catalog, and warehouse information)and a customer-facing portion managing the placement of orders. How manyquanta should this system be and why? If you envision multiple quanta,could the admin quantum and customer-facing quantum share a database? Ifso, in which quantum would the database need to reside?</p><p>假设一个系统包含两个部分：</p><ol type="1"><li><strong>管理后台</strong>：负责管理静态参考数据（例如产品目录、仓库信息）。</li><li><strong>用户端</strong>：负责处理客户订单的下达。</li></ol><p>这个系统应该被划分为多少个<strong>量子</strong>？为什么？如果您设想这是多个量子，那二者可以共享同一个数据库吗？如果可以，该数据库需要驻留在哪个量子中？</p></li></ol><hr /><h2 id="什么是架构量子">什么是架构量子？</h2><p><strong>架构量子 (Architectural Quantum)</strong> 这个概念源于 NealFord、Mark Richards 等人在《软件架构：艰难的部分》(SoftwareArchitecture: The Hard Parts) 一书中提出的。它的核心定义是：</p><blockquote><p>一个<strong>架构量子</strong>是指一个系统中，具有<strong>高功能内聚性(High Functional Cohesion)</strong> 和<strong>同步部署依赖性(Synchronous Deployable Dependency)</strong>的、可独立部署的组件的最小集合。</p></blockquote><p>为了更好地理解这个定义，我们需要拆解其中的关键术语：</p><ul><li><strong>可独立部署的组件 (Independently DeployableComponent)</strong>：这是现代架构（尤其是微服务架构）的基本单元。它可以是一个服务、一个应用或者任何可以独立于系统其他部分进行部署的模块。</li><li><strong>高功能内聚性 (High FunctionalCohesion)</strong>：这个概念借鉴了软件工程中的“内聚性”，指的是一个组件内部的各个部分为了一个共同、明确的目标而紧密协作。例如，一个“订单处理服务”应该只包含与创建、更新、查询订单相关的逻辑，而不应该包含用户认证或产品推荐的逻辑。一个架构量子内的所有组件，共同构成了一个完整且内聚的业务功能。</li><li><strong>同步部署依赖性 (Synchronous DeployableDependency)</strong>：这是定义中最关键也最“硬核”的部分。它指的是组件之间的行为调用必须是同步的，以保证系统正常工作。如果服务A 调用服务 B，并且必须等待 B 的响应才能继续执行，那么 A 和 B之间就存在同步依赖。这种依赖关系会将不同的独立部署组件“捆绑”在一起，形成一个不可分割的整体，也就是一个量子。如果为了让某个功能正常工作，你必须同时部署或更新服务A 和服务 B，那它们就属于同一个量子。</li></ul><h2 id="为什么架构量子很重要">为什么架构量子很重要？</h2><p>理解了定义后，我们来看看它在实践中的重要性。架构量子的概念为我们提供了一个强大的分析工具，帮助我们衡量和决策架构中的关键架构特性，例如：</p><ol type="1"><li><strong>可部署性(Deployability)</strong>：一个架构量子是<strong>最小的独立部署单元</strong>。整个量子可以作为一个单元进行部署、回滚和发布，而不会破坏系统的其他部分。这极大地简化了CI/CD流程。如果你错误地将一个量子拆分成多个，可能会导致部署时的级联失败。</li><li><strong>可测试性(Testability)</strong>：由于量子内部的组件功能高度内聚且存在同步依赖，因此它也成为了一个理想的<strong>测试边界</strong>。你可以对整个量子进行端到端的功能测试和集成测试，而无需启动整个庞大的系统。</li><li><strong>可伸缩性(Scalability)</strong>：不同的量子承载不同的业务功能，其负载模式也可能完全不同。例如，浏览产品目录的量子和处理支付的量子对资源的需求天差地别。将它们划分为不同的量子，使得我们可以<strong>独立地扩展</strong>每一个量子，从而更高效地利用资源。</li><li><strong>容错性 (FaultTolerance)</strong>：一个设计良好的量子边界可以形成一道“防火墙”。一个量子的失败（例如，由于代码缺陷或流量激增）不应该导致其他量子的同步崩溃。这种隔离性是构建高可用系统的基础。</li><li><strong>组织结构对齐 (Alignment with TeamStructure)</strong>：根据康威定律 (Conway'sLaw)，系统架构往往会反映出开发它的团队的沟通结构。一个清晰的量子可以由一个独立的、自治的团队负责，从而减少跨团队沟通的开销，提升开发效率。</li></ol><p>简而言之，架构量子帮助我们识别出系统中<strong>真正的、不可再分的架构单元</strong>。它提供了一个明确的边界，指导我们如何合理地拆分系统，从而在可部署性、可伸缩性、容错性和团队效率之间取得平衡。</p><h2 id="场景分析一单一-ui-四个独立服务">场景分析一：单一 UI +四个独立服务</h2><blockquote><p>假设一个系统包含一个单一的用户界面，以及四个独立部署的服务，每个服务都包含自己的独立数据库。这个系统会有一个量子还是四个量子？为什么？</p></blockquote><p>答案是：<strong>这个系统最有可能包含四个量子 (FourQuanta)</strong>。</p><p><strong>分析如下：</strong></p><p>这里的关键信息是“四个<strong>独立部署</strong>的服务，每个服务都包含<strong>自己的独立数据库</strong>”。</p><ol type="1"><li><strong>独立部署与自有数据库</strong>：这个设定强烈暗示了服务之间的高度解耦。在现代架构中，服务独占自己的数据库是实现真正自治和独立部署的黄金法则。如果服务间共享数据库，它们的部署就会产生耦合（例如，一个服务修改了表结构，可能会影响到所有依赖该表的其他服务），也就无法做到真正的独立部署。</li><li><strong>同步依赖的缺失</strong>：虽然这四个服务最终都服务于同一个用户界面(UI)，但题目并未描述它们之间存在<strong>同步调用</strong>的强依赖关系。UI很可能是通过异步的方式或者直接独立地与这四个服务进行通信。例如，UI的一个页面可能需要同时展示来自服务 A 的用户信息和服务 B 的产品列表，但UI 可以分别向 A 和 B 发起两个独立的 API请求，这两个服务之间并不需要直接对话。</li><li><strong>功能内聚性</strong>：每个服务和它自己的数据库共同构成了一个高度内聚的功能单元。例如，服务A 和它的数据库负责“用户管理”，服务 B和它的数据库负责“订单管理”，等等。它们各自完成了闭环的业务能力。</li></ol><p><strong>结论</strong>：由于这四个服务（连同其数据库）可以独立部署，并且它们之间大概率不存在必须同步成功的强依赖，因此它们构成了四个独立的架构量子。单一的用户界面在这里扮演的是一个“集成层”或“客户端”的角色，它本身通常不被视为一个量子，而是作为这些量子的消费者。将系统划分为四个量子，使得每个服务都可以被独立地开发、测试、部署和扩展，从而获得了极大的架构灵活性。</p><h2 id="场景分析二管理后台-用户端">场景分析二：管理后台 + 用户端</h2><blockquote><p>假设一个系统包含两个部分：</p><ul><li>管理后台：负责管理静态参考数据（例如产品目录、仓库信息）。</li><li>用户端：负责处理客户订单的下达。</li></ul><p>这个系统应该被划分为多少个量子？为什么？如果您设想这是多个量子，那二者可以共享同一个数据库吗？如果可以，该数据库需要驻留在哪个量子中？</p></blockquote><h3id="这个系统应该被划分为多少个量子为什么">这个系统应该被划分为多少个量子？为什么？</h3><p>答案是：<strong>这个系统应该被划分为两个量子 (TwoQuanta)</strong>。</p><p><strong>分析如下：</strong></p><ol type="1"><li><strong>不同的架构特性需求</strong>：<ul><li><strong>用户端 (Customer-facingPortion)</strong>：这是系统的核心交易部分。它需要<strong>高可用性 (HighAvailability)</strong>、<strong>高可伸缩性 (HighScalability)</strong>（因为用户流量波动大，尤其在促销期间）、以及<strong>低延迟(Low Latency)</strong>。</li><li><strong>管理后台 (AdministrationPortion)</strong>：这部分主要由内部员工使用。它对可伸缩性的要求远低于用户端，但可能对<strong>数据一致性(Consistency)</strong> 和安全性有更高的要求。其使用模式也更可预测。</li></ul></li><li><strong>功能内聚性与关注点分离</strong>：管理后台的功能（管理产品目录、仓库信息）和用户端的功能（浏览商品、下单、支付）在业务上是完全不同的。将它们分开，符合单一职责原则，也使得各自的逻辑更清晰。</li><li><strong>部署和生命周期的独立性</strong>：用户端的功能可能需要频繁迭代和快速发布（例如，上线一个新的促销活动），而管理后台的功能则相对稳定，更新频率较低。将它们划分为两个量子，可以实现独立的部署和发布节奏，用户端的紧急修复或更新不会被后台的发布流程所拖累。</li></ol><p><strong>结论</strong>：基于截然不同的架构特性需求、功能内聚性以及部署独立性的考量，将这个系统划分为一个“管理后台量子”和一个“用户端量子”是最佳实践。</p><h3 id="二者可以共享同一个数据库吗">二者可以共享同一个数据库吗？</h3><p>答案是：<strong>技术上可以，但强烈不推荐 (Technically possible, buthighlydiscouraged)</strong>。共享数据库会引入我们之前提到的问题，即<strong>耦合(Coupling)</strong>。</p><ul><li><strong>性能耦合</strong>：管理后台的一个慢查询或数据批量导入操作，可能会锁住表，从而严重影响用户端的性能，甚至导致用户无法下单。</li><li><strong>部署耦合</strong>：如果用户端需要修改某个表的结构来支持新功能，这个修改可能会破坏管理后台的正常工作，反之亦然。这使得两个本应独立的量子在部署上产生了依赖。</li><li><strong>安全耦合</strong>：用户端和管理后台的数据库访问权限需求是不同的。共享数据库会增加权限管理的复杂性，可能导致安全漏洞。</li></ul><h3id="如果一定要共享数据库需要驻留在哪个量子中">如果一定要共享，数据库需要驻留在哪个量子中？</h3><p>这是一个权衡和妥协的问题。如果因为历史原因、成本限制或其他因素<strong>不得不</strong>共享数据库，那么决策的关键在于<strong>数据的所有权(Data Ownership)</strong> 和<strong>服务的关键性 (ServiceCriticality)</strong>。</p><p>在这个场景中，“产品目录”和“仓库信息”这些数据，虽然由管理后台进行维护，但它们的最终消费者和价值实现者是<strong>用户端</strong>。用户下单的逻辑严重依赖于这些数据的可用性和准确性。</p><p>因此，如果必须共享，该数据库在逻辑上应该<strong>驻留在用户端量子中</strong>。</p><p><strong>原因如下：</strong></p><ol type="1"><li><strong>业务关键性</strong>：用户端是直接产生商业价值的部分，其可用性是第一位的。将数据库置于此量子内，意味着所有架构决策（如扩展、备份、容灾）都将优先保障用户端的需求。</li><li><strong>数据所有权</strong>：虽然管理后台是数据的“生产者”，但用户端是数据的核心“消费者”。在领域驱动设计(Domain-Driven Design) 的思想中，数据应该属于它所支持的核心业务领域(Core Domain)，在这里显然是用户交易领域。</li><li><strong>架构上的清晰性</strong>：这样做可以建立一个清晰的依赖关系：管理后台量子依赖于用户端量子中的数据。这虽然不是最理想的解耦状态，但至少依赖关系是单向且明确的。</li></ol><p>在这种共享模式下，更好的实践是通过<strong>定义稳定的 API</strong>来缓解耦合。管理后台不应直接操作数据库，而是应该通过用户端量子提供的 API来修改产品目录等数据。这样做可以隐藏数据库的物理实现，为未来的数据库拆分创造可能性。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第七章的课后思考题，深入探讨架构量子的概念与定义、架构特性的作用范围以及量子边界的识别方法，分析系统组件间的同步依赖关系对架构分解的影响，帮助理解如何基于功能内聚性和部署依赖性来合理划分架构边界，优化系统的可部署性、可测试性和可维护性。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>课程笔记丨《手把手带你写一个 Web 框架》</title>
    <link href="https://hedon.top/2025/07/07/note-write-a-web-framework/"/>
    <id>https://hedon.top/2025/07/07/note-write-a-web-framework/</id>
    <published>2025-07-07T15:02:00.000Z</published>
    <updated>2025-07-07T15:51:47.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="框架零件">框架"零件"</h2><h3 id="context">context</h3><ol type="1"><li>框架级 Context：可以组合优秀框架（如gin.Context）的基础上，扩展自己常用的功能函数。</li><li>业务级 Context：针对具体的业务，组合框架Context，封装更多的业务工具函数，进一步提升效率。</li><li>如果有必要进步提升性能的话，可以使用 sync.Pool 对 Context进行管理，避免 Context 频繁创建销毁带来的性能损耗。</li><li>灵活使用链路调用，有助于提升代码的清晰度和可扩展性。</li></ol><h3 id="路由匹配">路由匹配</h3><p>Gin 使用 <a href="https://en.wikipedia.org/wiki/Radix_tree">radixtree</a>，尽可能压缩路由的公共前缀，同时使用 indices加速路由的检索。</p><figure><imgsrc="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Patricia_trie_var.svg/350px-Patricia_trie_var.svg.png"alt="radix tree" /><figcaption aria-hidden="true">radix tree</figcaption></figure><h3 id="中间件">中间件</h3><p>使用洋葱型中间件，可以很方便地进行 AOP 编程，有很大的扩展性。</p><p>如 Gin 框架中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlersChain defines a HandlerFunc slice.</span></span><br><span class="line"><span class="keyword">type</span> HandlersChain []HandlerFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc defines the handler used by gin middleware as return value.</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br></pre></td></tr></table></figure><p>同时为 <code>IRouter</code> 接口也定义 <code>Group</code>函数，这样可以进一步提升聚合类的逻辑复用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRouter defines all router handle interface includes single and group router.</span></span><br><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span> &#123;</span><br><span class="line">IRoutes</span><br><span class="line">Group(<span class="type">string</span>, ...HandlerFunc) *RouterGroup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行过程中，使用 <code>c.Next()</code> 和 <code>c.Abort()</code>来进行处理器调用或提前退出等逻辑控制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> abortIndex <span class="type">int8</span> = math.MaxInt8 &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Next() &#123;</span><br><span class="line">c.index++   <span class="comment">// 初始化 c.index = -1</span></span><br><span class="line"><span class="keyword">for</span> c.index &lt; <span class="type">int8</span>(<span class="built_in">len</span>(c.handlers)) &#123;</span><br><span class="line"><span class="keyword">if</span> c.handlers[c.index] != <span class="literal">nil</span> &#123;</span><br><span class="line">c.handlers[c.index](c)</span><br><span class="line">&#125;</span><br><span class="line">c.index++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Abort() &#123;</span><br><span class="line">c.index = abortIndex  <span class="comment">// 设置为最大值，后面的 next 就会直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展现有框架">扩展现有框架</h3><p>相比于自己从零开始写一个 Web框架，完全可以站在前人的肩膀上，将流行的、好用的、开源协议允许的框架代码拷贝到自己的仓库中，进行改造升级，从而快速搭建一个功能完善、经过验证、贴合团队需要的强悍Web 框架。</p><h2 id="一切皆服务">一切皆服务</h2><p>按照面向接口编程的理念，将每个模块看成是一个服务，服务的具体实现我们其实并不关心，我们关心的是服务提供的能力，即接口协议。那么框架主体真正要做的事情是什么呢？其实是：<strong>定义好每个模块服务的接口协议，规范服务与服务之间的调用，并且管理每个服务的具体实现</strong>。</p><p>所有的服务都去框架主体中注册自身的模块接口协议，其他的服务调用功能模块的时候，并不是直接去这个服务获取实例，而是从框架主体中获取有这个接口协议的服务实例。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250707232209688.png"alt="一切皆服务" /><figcaption aria-hidden="true">一切皆服务</figcaption></figure><h3 id="容器-container">容器 container</h3><p>服务提供接口定义可参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewInstance is a function that creates a new instance of a service</span></span><br><span class="line"><span class="keyword">type</span> NewInstance <span class="function"><span class="keyword">func</span><span class="params">(...any)</span></span> (any, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServiceProvider is an interface that defines a service provider</span></span><br><span class="line"><span class="keyword">type</span> ServiceProvider <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Register a service provider into the container,</span></span><br><span class="line"><span class="comment">// whether to initialize the service or not determined by the IsDefer method</span></span><br><span class="line">Register(Container) NewInstance</span><br><span class="line"><span class="comment">// Boot the service provider, this method will be called after the container is initialized.</span></span><br><span class="line"><span class="comment">// Is id recommend to do some initialization work in this method.</span></span><br><span class="line"><span class="comment">// If returns error, the service initialization will be failed.</span></span><br><span class="line">Boot(Container) <span class="type">error</span></span><br><span class="line"><span class="comment">// IsDefer determines whether the service provider should be deferred.</span></span><br><span class="line"><span class="comment">// If true, the service provider will be deferred until the first time the service is used.</span></span><br><span class="line">IsDefer() <span class="type">bool</span></span><br><span class="line"><span class="comment">// Params are the parameters which would be passed to the NewInstance function.</span></span><br><span class="line">Params(Container) []any</span><br><span class="line"><span class="comment">// Name is a method that returns the unique name of the service provider.</span></span><br><span class="line">Name() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器接口定义可参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Container is a service provider container, provides methods to register and resolve service providers.</span></span><br><span class="line"><span class="keyword">type</span> Container <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Bind binds a service provider into the container,</span></span><br><span class="line"><span class="comment">// if the service provider is already bound, it would panic.</span></span><br><span class="line">Bind(provider ServiceProvider) <span class="type">error</span></span><br><span class="line"><span class="comment">// IsBind checks if a service provider is bound into the container</span></span><br><span class="line">IsBind(key <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line"><span class="comment">// Make resolves a service provider from the container</span></span><br><span class="line">Make(key <span class="type">string</span>) (any, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// MustMake resolves a service provider from the container, if not found, it will panic</span></span><br><span class="line">MustMake(key <span class="type">string</span>) any</span><br><span class="line"><span class="comment">// MakeNew creates a new instance of a service provider,</span></span><br><span class="line"><span class="comment">// it is useful when you need to create a new instance of a service provider</span></span><br><span class="line"><span class="comment">// and pass some different parameters to the service provider&#x27;s constructor.</span></span><br><span class="line">MakeNew(key <span class="type">string</span>, params ...any) (any, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现可参考：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helps to check if the Container interface is implemented</span></span><br><span class="line"><span class="keyword">var</span> _ Container = (*HdwebContainer)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HdwebContainer is the default implementation of the Container interface</span></span><br><span class="line"><span class="keyword">type</span> HdwebContainer <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// providers is a map of service providers, key is the name of the service provider</span></span><br><span class="line">providers <span class="keyword">map</span>[<span class="type">string</span>]ServiceProvider</span><br><span class="line"><span class="comment">// instances is a map of service instances, key is the name of the service</span></span><br><span class="line">instances <span class="keyword">map</span>[<span class="type">string</span>]any</span><br><span class="line"><span class="comment">// lock is used to protect the container from concurrent access</span></span><br><span class="line">lock sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewHdwebContainer creates a new HdwebContainer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHdwebContainer</span><span class="params">()</span></span> *HdwebContainer &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;HdwebContainer&#123;</span><br><span class="line">providers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]ServiceProvider),</span><br><span class="line">instances: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]any),</span><br><span class="line">lock:      sync.RWMutex&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind binds a service provider into the container,</span></span><br><span class="line"><span class="comment">// if the service provider is already bound, &#x27;</span></span><br><span class="line"><span class="comment">// it will replace the existing one and return an error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> Bind(provider ServiceProvider) <span class="type">error</span> &#123;</span><br><span class="line">h.lock.Lock()</span><br><span class="line">key := provider.Name()</span><br><span class="line"><span class="keyword">if</span> _, ok := h.providers[key]; ok &#123;</span><br><span class="line">h.lock.Unlock()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;service provider already bound: &quot;</span> + key)</span><br><span class="line">&#125;</span><br><span class="line">h.providers[key] = provider</span><br><span class="line">h.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> provider.IsDefer() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := provider.Boot(h); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">params := provider.Params(h)</span><br><span class="line">method := provider.Register(h)</span><br><span class="line"></span><br><span class="line">instance, err := method(params...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> h.lock.Unlock()</span><br><span class="line"><span class="keyword">if</span> _, ok := h.instances[key]; ok &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;service provider already resolved: &quot;</span> + key)</span><br><span class="line">&#125;</span><br><span class="line">h.instances[key] = instance</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsBind checks if a service provider is bound into the container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> IsBind(key <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h.findServiceProvider(key) != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make resolves a service provider from the container</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> Make(key <span class="type">string</span>) (any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> h.<span class="built_in">make</span>(key, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MakeNew creates a new instance of a service provider,</span></span><br><span class="line"><span class="comment">// it is useful when you need to create a new instance of a service provider</span></span><br><span class="line"><span class="comment">// and pass some different parameters to the service provider&#x27;s constructor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> MakeNew(key <span class="type">string</span>, params ...any) (any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> h.<span class="built_in">make</span>(key, params, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MustMake resolves a service provider from the container, if not found, it will panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> MustMake(key <span class="type">string</span>) any &#123;</span><br><span class="line">ins, err := h.<span class="built_in">make</span>(key, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ins</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> <span class="built_in">make</span>(key <span class="type">string</span>, params []any, forceNew <span class="type">bool</span>) (any, <span class="type">error</span>) &#123;</span><br><span class="line">sp := h.findServiceProvider(key)</span><br><span class="line"><span class="keyword">if</span> sp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;service provider not found: &quot;</span> + key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> forceNew &#123;</span><br><span class="line"><span class="keyword">return</span> h.newInstance(sp, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ins := h.getInstance(key); ins != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ins, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> h.lock.Unlock()</span><br><span class="line"><span class="keyword">if</span> ins, ok := h.instances[key]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> ins, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">ins, err := h.newInstance(sp, params)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">h.instances[key] = ins</span><br><span class="line"><span class="keyword">return</span> ins, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> getInstance(key <span class="type">string</span>) any &#123;</span><br><span class="line">h.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> h.lock.RUnlock()</span><br><span class="line"><span class="keyword">return</span> h.instances[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> newInstance(sp ServiceProvider, params []any) (any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> err := sp.Boot(h); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> params == <span class="literal">nil</span> &#123;</span><br><span class="line">params = sp.Params(h)</span><br><span class="line">&#125;</span><br><span class="line">method := sp.Register(h)</span><br><span class="line"><span class="keyword">return</span> method(params...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdwebContainer)</span></span> findServiceProvider(key <span class="type">string</span>) ServiceProvider &#123;</span><br><span class="line">h.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> h.lock.RUnlock()</span><br><span class="line"><span class="keyword">return</span> h.providers[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务-service-provider">服务 service provider</h3><ul><li>contract：服务功能接口定义</li><li>provider：为服务实现 ServiceProvider 接口</li><li>service：实现服务 contract 功能接口</li></ul><h4 id="框架级服务">框架级服务</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">contract</span>  <span class="comment"># 服务接口定义</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">app.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">kernel.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">env.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">config.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider</span>  <span class="comment"># 服务实现</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">app</span> <span class="comment"># app 服务</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider.go</span> <span class="comment"># 实现 Service Provider</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.go</span>  <span class="comment"># 实现服务接口</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">kernel</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.go</span></span><br></pre></td></tr></table></figure><h4 id="业务级服务">业务级服务</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> &#123;<span class="string">root</span>&#125;  <span class="comment"># 根目录</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">app</span> <span class="comment"># app 目录</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider</span> <span class="comment"># 通用业务服务</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">user</span>  <span class="comment"># user 服务</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">contract.go</span> <span class="comment"># user 服务接口定义</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.go</span>  <span class="comment"># user 服务接口实现</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider.go</span> <span class="comment"># 为 user 服务实现 Service Provider</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">mail</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">contract.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.go</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">provider.go</span></span><br></pre></td></tr></table></figure><h2 id="自动化-dry">自动化 DRY</h2><p>在业务开发过程中，对于那些重复性的类模板劳动，可以使用 CLI命令行工具，或其他自动化工具，来简化这些劳动输出。</p><p>这里有 2 个思路，一个是使用 Makefile，一个是使用 CLI（Go 里面可以使用<code>cobra</code> 框架）。选择的时候可以考虑以下几个点：</p><ol type="1"><li>命令变动的频率（二者在这一点区别不大，不过如果变动频率比较低，那 CLI的劣势就相对可以忽略了）</li><li>命令使用的复杂性（参数越多，则需要越详尽的帮助说明）</li><li>业务逻辑相关性（越相关，则逻辑越复杂，使用代码越好管控）</li></ol><p>常见的思路有：</p><ul><li>生成项目脚手架（init）</li><li>项目启动管理（build、start、stop、restart、update）</li><li>服务模版生成（provider list/new）—— 可以结合 <code>survey</code>做命令行渐进式输入，<code>template</code> 生成模板代码</li><li>命令行系列生成（command list/new）</li><li>定时任务（cron list/run）</li><li>swagger 生成（swagger gen）</li></ul>]]></content>
    
    
    <summary type="html">极客时间《手把手带你写一个 Web 框架》课程笔记。</summary>
    
    
    
    <category term="课程笔记" scheme="https://hedon.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://hedon.top/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨06丨评估和管理架构特性</title>
    <link href="https://hedon.top/2025/07/07/fosa/fosa-ch6/"/>
    <id>https://hedon.top/2025/07/07/fosa/fosa-ch6/</id>
    <published>2025-07-07T03:00:00.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第六章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>Why is cyclomatic complexity such an important metric to analyzefor architecture?</p><p>为什么圈复杂度是架构分析的重要指标？</p></li><li><p>What is an architecture fitness function? How can they be used toanalyze an architecture?</p><p>什么是架构适应度函数？它们如何用于分析架构？</p></li><li><p>Provide an example of an architecture fitness function to measurethe scalability of an architecture.</p><p>提供一个衡量架构可伸缩性的架构适应度函数示例。</p></li><li><p>What is the most important criteria for an architecturecharacteristic to allow architects and developers to create fitnessfunctions?</p><p>允许架构师和开发人员创建适应度函数的最重要标准是什么？</p></li></ol><hr /><h1 id="评估架构特性">评估架构特性</h1><p>评估架构特性一般可以从 3 个方面入手：</p><ul><li>运维性指标 (operationalmeasures)：主要关注系统在运维层面的能力，涵盖性能、可扩展性、弹性、可用性、可靠性等能力。</li><li>结构性指标 (structuralmeasures)：关注代码结构，如模块化、组件间受控的耦合、可读代码以及其他内部质量评估。常用工具有：<ul><li><strong>圈复杂度 (CyclomaticComplexity，CC)</strong>：一个代码层面的度量标准，由 Thomas McCabe, Sr.于 1976 年开发，通过分析代码的决策点（如 if语句）来量化代码的复杂性。高圈复杂度可能表明代码难以理解和测试。公式为<code>CC = E - N + 2</code>（针对单个函数），或<code>CC = E - N + 2P</code>（针对扇出调用）。行业普遍认为 CC 值低于 10是可接受的，但更倾向于低于 5。</li><li><strong>距主序列距离 (Distance from the MainSequence，D)</strong>：一个基于抽象性（A）和不稳定性（I）的综合指标，公式为<code>D = |A + I - 1|</code>。它反映了抽象性和不稳定性之间的理想关系。远离理想线的类可能落入"无用区"（过于抽象难以使用）或"痛苦区"（过于具体且难以维护）</li></ul></li><li>流程性指标 (processmeasures)：关注软件开发过程中的特性，如敏捷性、可测试性和可部署性。常用工具有：<ul><li><strong>代码覆盖率（code coverage）</strong></li></ul></li></ul><h1 id="管理架构特性">管理架构特性</h1><p>管理架构特性主要通过 4 个方面：</p><ul><li><strong>架构适应性函数 (Architecture FitnessFunctions)</strong>：这是评估系统输出质量的客观函数，用于衡量架构特性。它们将重要的架构原则编码到软件基础中，并自动验证这些原则是否得到遵守。例如：<ul><li>检测组件之间的循环依赖 (Cyclic Dependencies)</li><li>验证分层架构中的层间依赖关系</li><li>衡量距主序列的距离</li><li>混沌工程</li></ul></li><li><strong>架构决策记录 (Architecture Decision Records,ADRs)</strong>：ADR是一种有效的文档化架构决策的方式，通常是一到两页的短文本文件。每个 ADR应包含标题、状态（例如“已接受”、“已取代”）、上下文、决策（使用肯定性语言）和结果（包括决策的正面和负面影响，以及权衡分析）。ADR使得架构师能够清晰记录决策的技术和业务理由，避免重复讨论和误解。ADR中的“合规性(Compliance)”部分可以强制架构师思考如何衡量和管理决策的合规性，无论是手动还是通过适应性函数自动化。</li><li><strong>风险风暴 (RiskStorming)</strong>：这是一种协作活动，用于识别、达成共识并减轻架构风险。它包括识别（个体非协作活动）、共识（协作活动，讨论并统一风险评估）和缓解（协作活动，寻找减少或消除风险的方法）三个主要阶段。风险风暴通常使用风险矩阵(RiskMatrix)，通过“影响”和“可能性”两个维度来量化风险。风险评估报告还可以显示特定风险类别或领域随时间的改进或恶化，使用加号(+) 和减号 (-) 表示方向。</li><li><strong>持续沟通与协作</strong>：有效的沟通对于知识共享和项目成功至关重要。架构师应与产品负责人、项目经理、业务干系人以及开发人员进行谈判和协商，以获得架构决策的批准。倡导通用语言(UbiquitousLanguage)，确保所有项目相关方使用相同的业务领域术语，从而减少信息丢失和误解。</li></ul><h1 id="回答问题">回答问题</h1><p>基于上述对本章的概括回顾，回到本章的 4个课后题，笔者梳理了一下自己的理解，供读者们参考。</p><p>圈复杂度：</p><ol type="1"><li>圈复杂度是一种评估代码复杂性的工具。</li><li>如果一个函数（方法）中，条件分支和语句越多，则说明越复杂，一方面可能是业务逻辑本身就足够复杂，另外一方面，也很可能是代码的模块拆分没有做好，逻辑没有梳理清晰，写成了一坨。</li><li>这背后体现了模块化、可测试性、可部署性、可扩展性、可迭代性等多种代码结构层面的架构特性。</li></ol><p>架构适应度函数：</p><ol type="1"><li>架构适应度函数是一种用于持续评估当前架构是否满足需求的机制，可以理解为"架构的单元测试"。</li><li>不同的组织、不同的团队、不同的职责对同一个架构特性的理解、定义和需求都是不尽相同的。通过协商、建立其符合具体需求的架构适应度函数，在达成共识的基础上，可以持续对某些架构特性进行达标检测，避免偏离。比如代码测试覆盖率可以用来检测架构的可测试性、部署耗时可以用来横向架构的可部署性、可迭代性等。</li><li>要编写 fitnessfunction，最重要也是唯一最重要的标准是<strong>架构特性必须能够被客观地衡量和定义</strong>。通过鼓励客观定义，团队可以拆解复合特性，从而发现可以被客观衡量的功能。一旦特性被具体定义，就可以更容易地建立相应的适应度函数来验证其完整性。</li></ol><p>衡量系统的可伸缩性：</p><ol type="1"><li>可伸缩性，指的是系统在用户或请求数量增加时，仍然能够维持性能和运行的能力。</li><li>假如说我们现在有一个订单服务，如果我们希望它具备良好的可伸缩性，当我们将服务实例从2 个增加到 4个时，系统在相同响应时间基准下，应用能处理接近翻倍的请求吞吐量。</li></ol>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第六章的课后思考题，深入探讨如何衡量和管理架构特性，分析圈复杂度等结构性指标的重要性、架构适应度函数的定义与应用，以及运维性、结构性、流程性指标的评估方法，帮助理解如何建立有效的架构治理机制来持续监控和优化系统架构。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨05丨识别架构特征</title>
    <link href="https://hedon.top/2025/07/04/fosa/fosa-ch5/"/>
    <id>https://hedon.top/2025/07/04/fosa/fosa-ch5/</id>
    <published>2025-07-04T02:24:26.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第五章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>Give a reason why it is a good practice to limit the number ofcharacteristics (“-ilities”) an architecture should support.</p><p>举一个例子来说明为什么限制系统中支持的架构特性的数量的有必要的。</p></li><li><p>True or false: most architecture characteristics come frombusiness requirements and user stories.</p><p>大多数的架构特性都来自于业务需求和用户故事，这对吗？</p></li><li><p>If a business stakeholder states that time-to-market (i.e.,getting new features and bug fixes pushed out to users as fast aspossible) is the most important business concern, which architecturecharacteristics would the architecture need to support?</p><p>如果一个业务利益相关者将上市时间（比如以最快的速度实现新功能和修复BUG）视为最重要的需求点，这个时候需要支持什么样的架构特性？</p></li><li><p>What is the difference between scalability and elasticity?</p><p>可伸缩性（scalability） 和弹性（elasticity）的区别是什么？</p></li><li><p>You find out that your company is about to undergo several majoracquisitions to significantly increase its customer base. Whicharchitectural characteristics should you be worried about?</p><p>如果你发现了你的公司进行了几次重大收购以大幅增加其客户群，这个时候你应该考虑什么架构特性？</p></li></ol><hr /><h1 id="架构特性不是越多越好">架构特性不是越多越好</h1><ul><li><strong>增加系统设计的复杂性</strong>：每增加一个架构特性，都会使整个系统设计变得更加复杂。支持过多的架构特性会导致在架构师和开发人员开始解决核心业务问题之前，系统就变得越来越复杂。</li><li><strong>分散对核心问题的关注</strong>：架构特性定义了系统的成功标准，通常与系统的功能性正交，关注的是“如何”实现需求以及“为什么”做出某些选择。然而，如果过度追求特性数量，可能会导致偏离原始的业务问题，即开发软件的最初动机。</li><li><strong>每个特性都涉及权衡</strong>：软件架构中的每一个方面都存在权衡，有优点也有缺点。例如，在拍卖系统中，选择使用主题（topic）进行通信可能带来架构可扩展性的优势和服务的解耦，但会引入数据访问和数据安全方面的潜在问题，并且不支持异构契约。而使用队列（queue）则允许每个消费者拥有自己的契约，但不具备可扩展性，并且会增加服务间的耦合。架构师需要分析这些权衡，并根据业务驱动因素和环境选择最重要的特性。</li><li><strong>过度规范的危害</strong>：架构师过度规范架构特性是常见的陷阱，其破坏性不亚于规范不足，因为它会使系统设计过于复杂。历史案例“瓦萨号”战舰的失败就是一个例证，它是因为过度追求建造最宏伟的战舰（即过度规范架构特性）而最终导致沉没。</li><li><strong>陷入“意外复杂性”陷阱</strong>：架构师有时会为解决方案、图表和文档添加不必要的复杂性。正如一位作者所言，“开发者被复杂性吸引，就像飞蛾扑火一样——结果往往相同”。这种“意外复杂性”是由于人为地使问题复杂化，而不是问题本身固有的复杂性。通过识别子领域类型并根据其业务逻辑的复杂性选择合适的实现模式（例如，事务脚本和活动记录适用于简单业务逻辑，而领域模型和事件溯源领域模型适用于复杂的核心子领域），可以避免引入不必要的复杂性。</li><li><strong>设计应由业务驱动</strong>：领域驱动设计（DDD）的核心思想在于让业务领域驱动软件设计决策。这意味着设计决策应该基于业务领域的需求和战略，而非盲目地堆砌所有可能的架构特性。</li></ul><p>因此，与领域利益相关者合作时，架构师应努力使最终的架构特性列表尽可能短，因为每个特性都会增加总体系统设计的复杂性。</p><h1 id="如何识别架构特性">如何识别架构特性</h1><ol type="1"><li>从领域焦点中识别架构特性</li><li>从业务需求中识别架构特性</li></ol><p>这里面的一大难点就是：<strong>业务方与开发方使用的不是同一种"语言"</strong>。双方对同一件事情的关注点是不一样的，所以表述出来的述求，也是不同的。</p><p>所以在识别架构特性的时候，架构师的职责就是需要将业务领域的关注点和架构特性进行对应。比如：</p><table><colgroup><col style="width: 18%" /><col style="width: 81%" /></colgroup><thead><tr><th>Domain Concern</th><th>Architecture characteristics</th></tr></thead><tbody><tr><td>Mergers and acquisitions 合并与收购</td><td>互操作性 interoperability<br>可扩展性 scalability<br>适配性adaptability<br>可扩展性 extensibility</td></tr><tr><td>Time to market 上市时间</td><td>灵活性 agility<br>可测试性 testability<br>可部署性deployability</td></tr><tr><td>User satisfaction 用户满意度</td><td>性能 performance<br>可用性 availability<br>容错性 faulttolerance<br>可测试性 testability<br>可部署性 deployability<br>灵活性agility<br>安全性 security</td></tr><tr><td>Competitive advantage 竞争优势</td><td>灵活性 agility<br/>可测试性 testability<br/>可部署性deployability<br/>可扩展性 scalability<br/>可用性availability<br/>容错性 fault tolerance</td></tr><tr><td>Time and budget 时间和预算</td><td>简单性 simplicity<br>可行性 feasibility</td></tr></tbody></table><p>另外，随着业务的发展，关注点也是在不断发生变化的，这个时候，架构所侧重的架构特性也是随之改变的。</p><h1 id="可扩展性-vs-弹性">可扩展性 vs 弹性</h1><ul><li><strong>可伸缩性（Scalability）</strong>：<u>指的是系统在用户或请求数量增加时，仍然能够维持性能和运行的能力</u>。它衡量的是系统在负载线性增加时，性能是否能够保持相应的线性增长。例如，如果一个系统在用户增加一倍时，其性能也能线性提升，那么它就是可伸缩的。这通常通过增加资源（如服务器实例）来实现，以应对持续增长的用户数量。</li><li><strong>弹性（Elasticity）</strong>：<u>指的是系统处理请求突发性增长的能力</u>。它关注的是系统如何有效地应对不可预测和可变的用户流量高峰。例如，音乐会售票系统在门票开售时会经历用户流量的突然飙升，这需要高弹性的支持。一个具有弹性的系统能够在流量高峰时动态地启动新的处理单元（ProcessingUnits），并在负载降低时关闭它们</li></ul><p>简而言之，可伸缩性是关于处理增加的负载并保持性能，而弹性是关于处理突发性、不可预测的负载波动。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第五章的课后思考题，深入探讨如何识别架构特征，分析限制架构特性数量的重要性、架构特性的来源、业务驱动与架构特性的关系，以及可伸缩性与弹性等关键特性的区别，帮助理解如何从业务需求中提取和选择合适的架构特性。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨04丨架构特性定义</title>
    <link href="https://hedon.top/2025/07/03/fosa/fosa-ch4/"/>
    <id>https://hedon.top/2025/07/03/fosa/fosa-ch4/</id>
    <published>2025-07-03T02:35:26.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第四章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>What three criteria must an attribute meet to be considered anarchitecture characteristic?</p><p>一个属性要被认定为架构特性，必须满足哪三个条件？</p></li><li><p>What is the difference between an implicit characteristic and anexplicit one? Provide an example of each.</p><p>隐性特性和显性特性的区别是什么？请分别举一个例子。</p></li><li><p>Provide an example of an operational characteristic.</p><p>提供一个操作特性的例子。</p></li><li><p>Provide an example of a structural characteristic.</p><p>提供一个结构特性的例子。</p></li><li><p>Provide an example of a cross-cutting characteristic.</p><p>提供一个交叉特性的例子。</p></li><li><p>Which architecture characteristic is more important to strivefor—availability or performance?</p><p>在架构特性中，更应努力追求的是可用性还是性能？</p></li></ol><hr /><h2 id="架构特性定义">架构特性定义</h2><p>一个属性要成为架构特性（Architecture Characteristics），需至少满足 3个条件：</p><ol type="1"><li><strong>指定非领域设计考量</strong>：架构特性关注的是应用程序"如何"实现需求以及做出某些选择"为何"的原因，而不是应用程序"应该做什么"的业务需求。例如，性能水平通常不会出现在需求文档中，但却是重要的架构特性。</li><li><strong>影响设计的某个结构方面</strong>：如果一个架构特性需要特殊结构考虑才能成功，那么它就会上升到架构特性的层面。例如，一般的安全性对于几乎所有项目都是必需的，但当需要设计特定的模块、组件或服务来隔离关键安全问题时，安全才成为一个架构特性。</li><li><strong>对应用程序的成功至关重要</strong>：应用程序可以支持大量的架构特性，但并非所有都应该被支持。支持每个架构特性都会增加设计的复杂性，因此，架构师的关键任务是选择最少的、对应用程序成功至关重要或重要的架构特性，而不是尽可能多的。</li></ol><h2 id="显性-隐性">显性 &amp; 隐性</h2><ul><li><p><strong>显性架构特性 (Explicit ArchitectureCharacteristics)</strong>是在需求规范中明确列出的，作为必要设计的一部分。它们通常直接出现在需求文档或其他具体说明中。</p><blockquote><p>在书中的 Silicon Sandwiches的案例中，用户数量（“当前数千，未来可能数百万”）就隐含地要求了可伸缩性(Scalability)，即在不严重降低性能的情况下处理大量并发用户的能力。虽然需求没有明确提出可伸缩性，但从用户数量的描述中可以推断出来</p></blockquote></li><li><p><strong>隐性架构特性 (Implicit ArchitectureCharacteristics)</strong>很少出现在需求文档中，但它们对于项目的成功是必需的。架构师必须利用他们对问题领域的知识，在分析阶段发现这些特征。</p><blockquote><p>可用性 (Availability)是一种隐性特征，它确保用户可以访问系统。与可用性密切相关的是可靠性(Reliability)，它确保网站在交互过程中保持正常运行，不会出现连接中断等问题。这些特征通常不会在设计文档中明确指定，但对于几乎所有应用程序都至关重要。</p></blockquote></li></ul><h2 id="操作特性">操作特性</h2><p>操作性架构特性涵盖了系统的<strong>运行能力</strong>，例如性能、可伸缩性、弹性、可用性和可靠性等。这些特性通常与运营和DevOps 关注点高度重叠。</p><table><colgroup><col style="width: 9%" /><col style="width: 90%" /></colgroup><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>Availability</td><td>系统需要保持可用的时间长度；例如，如果需要 24/7可用，则需要采取措施确保系统始终可用。它指的是软件可操作和可访问的程度。</td></tr><tr><td>Continuity</td><td>灾难恢复能力。</td></tr><tr><td>Performance</td><td>衡量应用程序请求和响应周期所需的时间。它包括压力测试、高峰分析、功能使用频率分析、所需容量和响应时间。它也可以是更具体的度量，例如首屏渲染时间，即网页首次可见的时间。</td></tr><tr><td>Recoverability</td><td>业务连续性要求（例如，发生灾难时，系统需要多快才能重新上线？）这将影响备份策略和对复制硬件的要求。它也指软件从故障中恢复的能力，通过恢复任何受影响的数据并重新建立系统的所需状态。</td></tr><tr><td>Reliability/Safety</td><td>评估系统是否需要具备故障安全能力，或者其任务关键性是否影响生命。如果系统发生故障，是否会给公司带来巨额损失。它指系统在指定条件下和指定时间内运行的程度。</td></tr><tr><td>Robustness</td><td>在互联网连接中断、断电或硬件故障时，处理错误和边界条件的能力。</td></tr><tr><td>Scalability</td><td>系统随着用户或请求数量的增加而执行和运行的能力。这意味着处理大量并发用户而不会出现严重的性能下降。</td></tr></tbody></table><h2 id="结构特性">结构特性</h2><p>结构性架构特性关注<strong>代码结构</strong>。在许多情况下，架构师对代码质量问题负有独立或共同的责任，例如良好的模块化、组件间的受控耦合、可读性强的代码以及其他内部质量评估。</p><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>Configurability</td><td>最终用户通过可用界面轻松更改软件配置方面的能力。</td></tr><tr><td>Extensibility</td><td>系统的可扩展性。</td></tr><tr><td>Installability</td><td>系统在所有必要平台上安装的便捷性。它指软件在指定环境中安装和/或卸载的程度。</td></tr><tr><td>Leverageability/Reuse</td><td>跨多个产品利用通用组件的能力。它指开发人员在多个系统或构建其他资产中重复使用资产的程度。</td></tr><tr><td>Maintainability</td><td>开发人员修改、纠正或使其适应环境和/或需求变化的有效性和效率程度。</td></tr><tr><td>Portability</td><td>系统是否需要在多个平台上运行。它指开发人员将系统、产品或组件从一个硬件、软件或其他操作或使用环境转移到另一个环境的程度。</td></tr><tr><td>Supportability</td><td>应用程序所需的技术支持级别。系统中调试错误所需的日志记录及其他设施的级别。</td></tr><tr><td>Upgradeability</td><td>从该应用程序/解决方案的旧版本轻松/快速升级到新版本的能力。</td></tr></tbody></table><h2 id="交叉特性">交叉特性</h2><p>交叉架构特性指的是那些难以归类或超出传统类别，但却形成重要设计约束和考虑的特性。</p><table><colgroup><col style="width: 10%" /><col style="width: 89%" /></colgroup><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>Accessibility</td><td>确保所有用户（包括色盲或听力障碍等残障用户）能够访问系统。它指使软件可供具有最广泛特征和能力的人使用。</td></tr><tr><td>Archivability</td><td>数据是否需要在一段时间后归档或删除。</td></tr><tr><td>Authentication</td><td>确保用户是其所声称的身份的安全要求。</td></tr><tr><td>Authorization</td><td>确保用户只能访问应用程序内特定功能（按用例、子系统、网页、业务规则、字段级别等）的安全要求。</td></tr><tr><td>Legal</td><td>系统在哪些法律约束下运行（数据保护、萨班斯-奥克斯利法案、GDPR等）？公司需要哪些保留权利？关于应用程序构建或部署方式的任何规定。</td></tr><tr><td>Privacy</td><td>隐藏内部公司员工交易信息的能力（加密交易，甚至数据库管理员和网络架构师都无法查看）。</td></tr><tr><td>Security</td><td>数据是否需要在数据库中加密？内部系统之间网络通信是否需要加密？远程用户访问需要何种类型的认证？它指软件保护信息和数据的程度，以便人员或其他产品或系统具有与其授权类型和级别相称的数据访问程度。</td></tr><tr><td>Supportability</td><td>应用程序所需的技术支持级别。系统中调试错误所需的日志记录及其他设施的级别。</td></tr><tr><td>Usability/Achievability</td><td>用户使用应用程序/解决方案实现目标所需的培训水平。它指用户可以有效、高效、满意地使用系统达到预期目的。</td></tr></tbody></table><h2 id="可用性-vs-性能">可用性 vs 性能</h2><p>在架构特性中，没有绝对的"更重要"之分，只有权衡取舍(trade-offs)。这是软件架构的第一定律。架构师很少能够设计一个系统来最大化每一个架构特性。</p><p>可用性和性能之间的选择取决于具体的业务驱动因素、环境和一系列其他因素。例如：</p><ul><li><strong>业务需求</strong>：<ul><li>如果一个系统对用户来说必须始终可用，即使偶尔慢一点也可以接受，那么可用性可能是更高的优先级。例如，一个紧急服务系统或金融交易系统，即使延迟增加，也必须确保服务不中断。</li><li>如果业务目标是提供极快的响应时间，即使偶尔停机也能接受，那么性能可能更重要。例如，高频交易系统，毫秒级的延迟都可能导致巨大损失。</li></ul></li><li><strong>相互影响与权衡</strong>：提升某一个架构特性往往会对其他特性产生负面影响。例如，为了提高安全性，可能需要进行更多的加密和间接操作，这几乎肯定会负面影响性能。</li><li><strong>上下文决定</strong>：不同的系统部分可能需要不同的优先级。例如，在一个在线拍卖系统中，拍卖师界面的可用性和可靠性可能比单个竞拍者界面的可用性更关键。</li></ul><p>因此，架构师的工作是分析这些权衡，并根据特定情况选择"最不差的架构"（leastworstarchitecture）。这要求架构师深入理解业务领域，并与所有相关利益方（包括开发人员、业务分析师、产品负责人等）进行协作，而不是孤立地做出决策。</p>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第四章的课后思考题，深入探讨架构特性（Architecture Characteristics）的定义与分类，分析架构特性的三个判定标准、隐性与显性特性的区别，以及操作型、结构型、交叉型特性的具体表现形式，帮助理解如何识别和选择适合系统需求的架构特性。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>RAG 全栈技术</title>
    <link href="https://hedon.top/2025/07/03/ai-rag-tech-complete/"/>
    <id>https://hedon.top/2025/07/03/ai-rag-tech-complete/</id>
    <published>2025-07-03T00:00:00.000Z</published>
    <updated>2025-07-27T04:29:14.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文档加载">1. 文档加载</h1><ul><li><ahref="https://python.langchain.com/docs/integrations/document_loaders/">langchain-document_loaders</a></li></ul><h2 id="langchian-document">langchian Document</h2><ul><li><code>page_content</code>: 文档内容</li><li><code>metadata</code>: 文档元信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line">document = Document(</span><br><span class="line">    page_content=<span class="string">&quot;Hello, world!&quot;</span>,</span><br><span class="line">    metadata=&#123;<span class="string">&quot;source&quot;</span>: <span class="string">&quot;https://example.com&quot;</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="html">html</h2><ul><li><p>在线网页：<em>from</em> langchain<em>community.document_loaders_import</em> WebBaseLoader</p></li><li><p>本地文件：<em>from</em> langchain<em>community.document_loaders_import</em> BSHTMLLoader</p></li><li><p>解析代码：<em>from</em> bs4 <em>import</em> BeautifulSoup</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 HTML 文件内容</span></span><br><span class="line">html_txt = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./file_load/test.html&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        html_txt += line</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析 HTML</span></span><br><span class="line">soup = BeautifulSoup(html_txt, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码块 td class=&quot;code&quot;</span></span><br><span class="line">code_content = soup.find_all(<span class="string">&#x27;td&#x27;</span>, class_=<span class="string">&quot;code&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> code_content:</span><br><span class="line">    <span class="built_in">print</span>(ele.text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;+&quot;</span>*<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>这里对代码块解析时的 <code>class</code>需要根据具体网页的元素定义进行更换，不过大体思路都一样（也不局限于代码块）。</p></li></ul><h2 id="pdf">PDF</h2><ul><li><p>加载文件：<em>from</em> langchain<em>community.document_loaders_import</em> PyMuPDFLoader</p></li><li><p>解析表格：<em>import</em> fitz</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fitz</span><br><span class="line"></span><br><span class="line">doc = fitz.<span class="built_in">open</span>(<span class="string">&quot;./file_load/fixtures/zhidu_travel.pdf&quot;</span>)</span><br><span class="line"></span><br><span class="line">table_data = []</span><br><span class="line">text_data = []</span><br><span class="line"></span><br><span class="line">doc_tables = []</span><br><span class="line"><span class="keyword">for</span> idx, page <span class="keyword">in</span> <span class="built_in">enumerate</span>(doc):</span><br><span class="line">    text = page.get_text()</span><br><span class="line">    text_data.append(text)</span><br><span class="line">    tabs = page.find_tables()</span><br><span class="line">    <span class="keyword">for</span> i, tab <span class="keyword">in</span> <span class="built_in">enumerate</span>(tabs):</span><br><span class="line">        ds = tab.to_pandas()</span><br><span class="line">        table_data.append(ds.to_markdown())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tab <span class="keyword">in</span> table_data:</span><br><span class="line">    <span class="built_in">print</span>(tab)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">100</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="unstructured">Unstructured</h2><p><ahref="https://github.com/Unstructured-IO/unstructured">Unstructured</a>是由 Unstructured.IO 开发的开源 Python 库，专为处理非结构化数据（如PDF、Word、HTML、XML 等）设计。在 LangChain中，它作为文档加载的核心工具，实现以下功能：</p><ol type="1"><li>格式支持广泛：解析 PDF、DOCX、PPTX、HTML、XML、CSV等格式，甚至支持扫描件中的 OCR 文本提取。</li><li>元素分区（Partitioning）：将文档拆分为结构化元素（标题、段落、表格、列表），保留原始布局和元数据。</li><li>数据清洗：自动清理文档中的无关符号、页眉页脚，生成纯净文本。</li></ol><p>使用 langchain_unstructured 需要安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uv add unstructured</span><br><span class="line">uv add langchain_unstructured</span><br><span class="line">uv add unstructured_inference</span><br><span class="line">uv add unstructured_pytesseract</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统依赖（macOS）</span></span><br><span class="line">brew install poppler</span><br><span class="line">brew install tesseract</span><br><span class="line">brew install libmagic</span><br><span class="line">brew install ghostscript</span><br><span class="line">brew install pandoc</span><br></pre></td></tr></table></figure><h3 id="pdf-1">PDF</h3><p>需要额外安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uv remove camelot-py # 如果有 camelot 需要先移出，在一些版本上存在冲突</span><br><span class="line"></span><br><span class="line">uv add &quot;unstructured[pdf]&quot;</span><br></pre></td></tr></table></figure><p>使用时导入包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_unstructured <span class="keyword">import</span> UnstructuredLoader</span><br></pre></td></tr></table></figure><h3 id="ppt">PPT</h3><p>需要安装额外依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv add python-pptx</span><br></pre></td></tr></table></figure><p>使用时导入包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> UnstructuredPowerPointLoader</span><br></pre></td></tr></table></figure><p>解析 PPT 中的表格及其他特殊类型，可以使用原始的<code>python-pptx</code> 库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pptx <span class="keyword">import</span> Presentation</span><br><span class="line"><span class="keyword">from</span> pptx.enum.shapes <span class="keyword">import</span> MSO_SHAPE_TYPE</span><br><span class="line"></span><br><span class="line">ppt = Presentation(<span class="string">&quot;./file_load/fixtures/test_ppt.pptx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> slide_number, slide <span class="keyword">in</span> <span class="built_in">enumerate</span>(ppt.slides, start=<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Slide <span class="subst">&#123;slide_number&#125;</span>:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> shape <span class="keyword">in</span> slide.shapes:</span><br><span class="line">        <span class="keyword">if</span> shape.has_text_frame:  <span class="comment"># 文本信息</span></span><br><span class="line">            <span class="built_in">print</span>(shape.text)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> shape.has_table:  <span class="comment"># 表格信息</span></span><br><span class="line">            table = shape.table</span><br><span class="line">            <span class="keyword">for</span> row_idx, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(table.rows):</span><br><span class="line">                <span class="keyword">for</span> col_idx, cell <span class="keyword">in</span> <span class="built_in">enumerate</span>(row.cells):</span><br><span class="line">                    cell_text = cell.text</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Row <span class="subst">&#123;row_idx + <span class="number">1</span>&#125;</span>, Column <span class="subst">&#123;col_idx + <span class="number">1</span>&#125;</span>: <span class="subst">&#123;cell_text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> shape.shape_type == MSO_SHAPE_TYPE.PICTURE: <span class="comment"># 图片信息</span></span><br><span class="line">            imgae = shape.image</span><br><span class="line">            image_filename = <span class="string">&quot;./file_load/fixtures/pic_from_ppt.jpg&quot;</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(image_filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(imgae.blob)</span><br></pre></td></tr></table></figure><h3 id="word">Word</h3><p>需要安装额外依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uv add docx2txt</span><br><span class="line">uv add python-docx</span><br></pre></td></tr></table></figure><p>使用时导入包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> Docx2txtLoader</span><br></pre></td></tr></table></figure><p>解析 Word 中的表格及其他特殊类型，可以使用原始的<code>python-docx</code> 库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_docx</span>(<span class="params">file_path</span>):</span><br><span class="line">    doc = Document(file_path)</span><br><span class="line">    <span class="keyword">for</span> para <span class="keyword">in</span> doc.paragraphs:</span><br><span class="line">        <span class="built_in">print</span>(para.text)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> table <span class="keyword">in</span> doc.tables:</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> table.rows:</span><br><span class="line">            <span class="keyword">for</span> cell <span class="keyword">in</span> row.cells:</span><br><span class="line">                <span class="built_in">print</span>(cell.text, end=<span class="string">&#x27; | &#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./file_load/fixtures/test_word.docx&quot;</span></span><br><span class="line">read_docx(file_path=file_path)</span><br></pre></td></tr></table></figure><h3 id="excel">Excel</h3><p>需要安装额外依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv add openpyxl</span><br></pre></td></tr></table></figure><h2 id="ragflow.deepdoc">ragflow.deepdoc</h2><p>RAGFlow 是一个开源的、基于"深度文档理解"的 RAG 引擎。</p><p><strong>RAGFlow 的主要特点：</strong></p><ol type="1"><li><strong>开箱即用：</strong> 提供 Web UI界面，用户可以通过简单的几次点击，无需编写代码，就能完成知识库的建立和问答测试。通过<code>Docker</code> 可以一键部署，非常方便。</li><li><strong>工作流自动化 (Automated Workflow)：</strong> RAGFlow将复杂的 RAG流程（文档解析、切块、向量化、存储、检索、生成）模板化。用户可以选择不同的模板来适应不同的数据和任务需求，整个过程高度自动化。</li><li><strong>可视化与可解释性：</strong> 在处理文档时，RAGFlow会生成一个可视化的解析结果图，让用户能清晰地看到文档是如何被理解和切分的，大大增强了系统的透明度和可调试性。</li><li><strong>企业级特性：</strong>它支持多种文档格式，能够生成可溯源的答案（即答案会附上来源出处），并且兼容多种LLM 和向量数据库，易于集成到现有企业环境中。</li></ol><p>如果说 RAGFlow 是一个高效的问答“工厂”，那么 DeepDoc就是这个工厂里最核心、最先进的“原材料加工车间”。所有外部文档在进入知识库之前，都必须经过DeepDoc 的精细处理。</p><p>DeepDoc 的全称是 <strong>Deep DocumentUnderstanding</strong>（深度文档理解），它是 RAGFlow实现高质量检索的基石。它并非简单地提取文本，而是试图像人一样“看”和“理解”文档的版面布局和内在逻辑。</p><p><strong>DeepDoc 的工作原理与核心能力：</strong></p><ol type="1"><li><strong>视觉版面分析 (Vision-based Layout Analysis)：</strong><ul><li><strong>理论：</strong> DeepDoc首先会利用计算机视觉（CV）模型，像人眼一样扫描整个文档页面。它不是逐行读取字符，而是先识别出页面上的宏观结构，例如：这是标题、那是段落、这是一个表格、这是一张图片、这是一个页眉/页脚。</li><li><strong>实践：</strong> 对于一个两栏布局的 <code>PDF</code>报告，传统的文本提取工具可能会把左边一行的结尾和右边一行的开头错误地拼在一起。而DeepDoc的视觉分析能准确识别出两个独立的栏目，并按照正确的阅读顺序（先读完左栏，再读右栏）来处理文本。</li></ul></li><li><strong>智能分块 (Intelligent Chunking)：</strong><ul><li><strong>理论：</strong> 这是 DeepDoc最具价值的一点。在理解了文档布局之后，它会进行“语义分块”而非“物理分块”。传统的RAG 会把文档切成固定长度（如 500个字符）的块，这常常会将一个完整的表格或一段逻辑连贯的话拦腰截断。</li><li><strong>实践：</strong> DeepDoc会将一个完整的表格识别出来并视为一个独立的“块”（Chunk）。一个标题和它紧随其后的段落也会被智能地划分在一起。这样做的好处是，当用户提问与表格相关的问题时，系统检索到的就是这个包含完整上下文的表格块，而不是表格的某几行碎片。这极大地保证了提供给LLM 的上下文信息的完整性和逻辑性。</li></ul></li><li><strong>高质量光学字符识别 (OCR)：</strong><ul><li><strong>理论：</strong> 对于扫描的 <code>PDF</code>文件或者文档中嵌入的图片，DeepDoc 内置了高质量的 OCR 引擎。</li><li><strong>实践：</strong>即便文档是扫描的复印件，它也能尽可能准确地提取出其中的文字内容，并将其融入到上述的版面分析中，确保信息不丢失。</li></ul></li><li><strong>表格解析与转译：</strong><ul><li><strong>理论：</strong> 识别出表格只是第一步，更关键的是让 LLM能“读懂”表格。</li><li><strong>实践：</strong> DeepDoc能够提取出表格的结构化数据，并将其转换为 LLM 更容易理解的格式，例如Markdown 格式。一个复杂的表格图片，在经过 DeepDoc 处理后，可能会变成一个Markdown 文本表格，这样 LLM就能轻松地理解其行列关系，并回答诸如“请总结一下表格中第三季度销售额最高的产品是哪个？”这类的问题。</li></ul></li></ol><p>笔者在实践过程中，通过精简 ragflow.deepdoc 中的pdfparser，抽出了一个组件 <ahref="https://github.com/hedon-ai-road/deepdoc_pdfparser">deepdoc_pdfparser</a>.</p><h1 id="分块策略">2. 分块策略</h1><ul><li>可视化工具：<ahref="https://chunkviz.up.railway.app/">ChunkViz</a></li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/https%253A%252F%252Fsubstack-post-media.s3.amazonaws.com%252Fpublic%252Fimages%252F92c70184-ba0f-4877-9a55-e4add0e311ad_870x1116.gif"alt="RAG 五大分块策略" /><figcaption aria-hidden="true">RAG 五大分块策略</figcaption></figure><blockquote><p>参考：<ahref="https://blog.dailydoseofds.com/p/5-chunking-strategies-for-rag-f8b?ref=dailydev">5-chunking-strategies-for-rag</a></p></blockquote><h1 id="向量嵌入">3. 向量嵌入</h1><h2 id="嵌入模型评测">3.1 嵌入模型评测</h2><p>Hugging Face 的 <ahref="https://huggingface.co/spaces/mteb/leaderboard">MTEB</a> (MassiveText Embedding Benchmark)是一个大规模的文本嵌入模型评测基准。它的核心作用是<strong>为各种文本嵌入模型提供一个统一、全面、客观的性能衡量标准</strong>。</p><p>涵盖了文本嵌入在现实世界中最常见的 8 种应用场景，共计 58 个数据集和112 种语言。这 8 大任务分别是：</p><ul><li><strong>Bitext Mining (双语文本挖掘):</strong>在不同语言的句子中找出翻译对。</li><li><strong>Classification (分类):</strong>将文本划分到预定义的类别中。</li><li><strong>Clustering (聚类):</strong> 将相似的文本分组在一起。</li><li><strong>Pair Classification (句子对分类):</strong>判断两个句子是否具有某种关系 (如释义、矛盾等)。</li><li><strong>Reranking (重排序):</strong> 对一个已经排好序的列表(如搜索结果) 进行重新排序，以提升质量。</li><li><strong>Retrieval (检索):</strong>从一个大规模的文档语料库中找出与查询最相关的文档。这是目前文本嵌入最核心和最热门的应用之一。</li><li><strong>Semantic Textual Similarity (STS, 语义文本相似度):</strong>判断两个句子的语义相似程度，通常给出一个从 0 到 5 的分数。</li><li><strong>Summarization (摘要):</strong>评估生成的摘要与原文的语义相似度。</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250725171512447.png"alt="MTEB" /><figcaption aria-hidden="true">MTEB</figcaption></figure><h2 id="稀疏嵌入sparse-embedding">3.2 稀疏嵌入（Sparse Embedding）</h2><table><colgroup><col style="width: 12%" /><col style="width: 87%" /></colgroup><thead><tr><th style="text-align: left;"><strong>特征</strong></th><th style="text-align: left;"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align: left;"><strong>维度</strong></td><td style="text-align: left;">通常等于完整词表或特征集合的大小，可达 10⁵– 10⁶；大多数维度为 0，只有少数位置有权重</td></tr><tr><td style="text-align: left;"><strong>构造方式</strong></td><td style="text-align: left;">基于词频或词频-逆文档频率（TF-IDF）、BM25等统计方法，不依赖深度学习</td></tr><tr><td style="text-align: left;"><strong>权重含义</strong></td><tdstyle="text-align: left;">每个非零维可直观解释为某个词或特征的重要度，具有高度可解释性</td></tr><tr><td style="text-align: left;"><strong>检索/存储</strong></td><td style="text-align: left;">用倒排索引即可实现 O(1)级精确匹配；在线增量更新代价低</td></tr><tr><td style="text-align: left;"><strong>优势</strong></td><td style="text-align: left;">对长文档、术语精确匹配友好易于调参（停用词、词根化） 资源消耗小、无推理延迟</td></tr><tr><td style="text-align: left;"><strong>劣势</strong></td><td style="text-align: left;">维度极高，逐向量暴力计算代价大只捕获词面共现，无法理解语义或同义词 对拼写/语序变化鲁棒性差</td></tr></tbody></table><h3id="tf-idfterm-frequency---inverse-document-frequency词频-逆文档频率">TF-IDF(TermFrequency - Inverse Document Frequency，词频-逆文档频率)</h3><blockquote><p><em>一种经典的加权方案，用来衡量 词语 t 对 文档 d 在 语料库 D中的重要程度。</em></p></blockquote><ul><li>一句话：词在整个语料库中出现得越少，但在本篇文档中出现得越多，那它就越重要。</li></ul><p>公式：<span class="math inline">\(TF-IDF(t,d,D) = TF(t,d) ×IDF(t,D)\)</span></p><p>TF（局部权重）：</p><ul><li>计数：<code>tf = #t 出现次数</code></li><li>频率：<code>tf = #t / |d|</code></li><li>对数平滑：<code>tf = 1 + log(#t)</code></li></ul><p>ID（全局权重）：<span class="math display">\[IDF(t) =log\frac{N-df(t)+0.5}{df(t)+0.5} \]</span></p><ul><li><em>N</em> = 语料中文档总数</li><li><em>df(t)</em> = 含词 <em>t</em> 的文档数</li><li>加 1 或 0.5 可以避免分母为 0，并抑制长尾噪声。</li></ul><h3 id="bm25best-matching-25">BM25(Best Matching 25)</h3><p>可视为 TF-IDF 的扩展版，进一步引入：</p><ul><li><em>k₁</em> 控制 TF 饱和：TF 越大，增益递减。</li><li><em>b</em> 长度归一化：文档越长，单词 TF 权重被抑制。</li></ul><p>公式：<span class="math display">\[w(t,d)=IDF(t)⋅\frac{TF(k_{1}+1)}{TF+k_{1}·（1-b+b·\frac{文档长度}{平均文档长度} ）} \]</span></p><table><colgroup><col style="width: 9%" /><col style="width: 31%" /><col style="width: 5%" /><col style="width: 24%" /><col style="width: 29%" /></colgroup><thead><tr><th style="text-align: left;"><strong>角色</strong></th><th style="text-align: left;"><strong>控制对象</strong></th><th style="text-align: left;"><strong>常见区间</strong></th><th style="text-align: left;"><strong>极值行为</strong></th><th style="text-align: left;"><strong>直觉比喻</strong></th></tr></thead><tbody><tr><td style="text-align: left;">k₁ (saturation factor)</td><td style="text-align: left;">TF饱和曲线斜率——同一个词在同一文档中重复出现到第 n次时，还能再加多少分</td><td style="text-align: left;">1.0 – 2.0</td><td style="text-align: left;">k₁ → 0：完全不计重复词；k₁ →∞：线性计数，退化为 TF-IDF</td><td style="text-align: left;">沾一滴酱油 vs.倒一瓶酱油：味道总有极限，不会永远 1 → 2 → 3 倍变浓</td></tr><tr><td style="text-align: left;">b (length normalizer)</td><tdstyle="text-align: left;">文档长度惩罚强度——长文能否用“大块头”刷分</td><td style="text-align: left;">0.3 – 0.9</td><td style="text-align: left;">b = 0：不考虑长度（BM15）b =1：长度全量归一化（BM11）</td><td style="text-align: left;">打篮球按身高加分：b=0 不管身高；b=1按身高严格扣分；中间值折中</td></tr></tbody></table><h2 id="密集嵌入dense-embedding">3.3 密集嵌入（Dense Embedding）</h2><table><colgroup><col style="width: 12%" /><col style="width: 87%" /></colgroup><thead><tr><th style="text-align: left;"><strong>特征</strong></th><th style="text-align: left;"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align: left;"><strong>维度</strong></td><td style="text-align: left;">兼顾效率与表达力，常见 128 –1536；每一维几乎都非零。</td></tr><tr><td style="text-align: left;"><strong>构造方式</strong></td><td style="text-align: left;">由深度模型（BERT、Sentence-BERT、OpenAItext-embedding-3-small 等）端对端学习，捕获上下文语义</td></tr><tr><td style="text-align: left;"><strong>权重含义</strong></td><tdstyle="text-align: left;">单维难以直观解释，但整体向量在低维空间中编码了丰富的语义相似度</td></tr><tr><td style="text-align: left;"><strong>检索/存储</strong></td><td style="text-align: left;">需专门的 ANN（HNSW、Faiss IVF-PQ等）索引；向量更新需重新编码</td></tr><tr><td style="text-align: left;"><strong>优势</strong></td><tdstyle="text-align: left;">具备语义泛化能力，能跨同义词、拼写、语序可跨语言、跨模态（图文）在RAG/问答场景提升召回率</td></tr><tr><td style="text-align: left;"><strong>劣势</strong></td><td style="text-align: left;">训练与推理成本高（GPU/CPU向量化计算）结果可解释性弱 在线增量写入需再编码、重建索引</td></tr></tbody></table><h2 id="colbert">3.4 ColBERT</h2><p>ColBERT 是一种让 BERT 用“词级小向量”做快速、精准文本检索的方法 ——既不像传统 TF-IDF 那样粗糙，也不像跨编码器那样慢。</p><p>ColBERT = “把 BERT 的句向量拆成 token 向量，再用 Late Interaction重新拼起来做检索”的工程化改造版 BERT。</p><p><strong>Late Interaction</strong>就是把查询（Q）和文档（D）<strong>先独立编码</strong>，等到最后打分时再让它们在<strong>token 级别</strong> 做一次“小范围、轻量级”的互动——既不像Cross-Encoder 那样“一上来就深度交互”，也不像 Bi-Encoder那样“全程零交互”。</p><blockquote><p>换言之，BERT 提供<strong>语言理解底座</strong>，ColBERT在此之上加了<strong>面向检索的输出格式与打分逻辑</strong>，二者既同宗又分工明确。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">           预训练阶段（同一个 BERT 权重）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">┌───────────────┐</span><br><span class="line">│ Google BERT │ ← 海量文本上做 MLM/NSP</span><br><span class="line">└───────────────┘</span><br><span class="line">│ （加载相同参数）</span><br><span class="line">╭───────────┴───────────╮</span><br><span class="line">│ │</span><br><span class="line">│ ↓ 普通微调 │ ↓ ColBERT 微调</span><br><span class="line">│ （分类、NER…） │ （稠密检索）</span><br><span class="line">│ │</span><br><span class="line">│ 取 [CLS] 整句向量 │ 保留 每个 token 向量</span><br><span class="line">│ + 任务特定头 │ + Late-Interaction 打分</span><br><span class="line">│ │</span><br><span class="line">╰───────────┬───────────╯</span><br><span class="line">│</span><br><span class="line">下游推理/检索</span><br></pre></td></tr></table></figure><h2 id="bge-m3">3.5 BGE-M3</h2><p>BGE-M3是由智源研究院（BAAI）开发的新一代旗舰文本嵌入模型，它开创性地在单一模型内集成了<strong>多语言</strong>（支持超过100 种语言）、<strong>长文本</strong> （支持 8192词符）和<strong>多功能检索</strong>（同时支持稠密、稀疏和多向量检索）的强大能力。</p><table><colgroup><col style="width: 9%" /><col style="width: 3%" /><col style="width: 52%" /><col style="width: 34%" /></colgroup><thead><tr><th style="text-align: left;"><strong>M</strong></th><th style="text-align: left;"><strong>含义</strong></th><th style="text-align: left;"><strong>具体能力</strong></th><th style="text-align: left;"><strong>参考</strong></th></tr></thead><tbody><tr><td style="text-align: left;">Multi-Functionality</td><td style="text-align: left;">多功能</td><td style="text-align: left;">同时产出稠密向量（dense）、多向量/ColBERT（colbert） 和稀疏向量（sparse），一套模型即可覆盖混合检索需求。</td><td style="text-align: left;"><ahref="https://huggingface.co/BAAI/bge-m3">huggingface.bge-m3</a></td></tr><tr><td style="text-align: left;">Multi-Linguality</td><td style="text-align: left;">多语种</td><td style="text-align: left;">覆盖 100+语言，是目前公开数据集中多语检索任务的 SOTA。</td><td style="text-align: left;"><ahref="https://arxiv.org/abs/2402.03216?utm_source=chatgpt.com">arXiv.bge-m3</a></td></tr><tr><td style="text-align: left;">Multi-Granularity</td><td style="text-align: left;">多粒度</td><td style="text-align: left;">最长输入 8 192token，既能编码短句也能处理长文档。</td><td style="text-align: left;"><ahref="https://huggingface.co/BAAI/bge-m3">huggingface.bge-m3</a></td></tr></tbody></table><h1 id="查询增强技术">4. 查询增强技术</h1><h2 id="查询构建">4.1 查询构建</h2><h3 id="text-to-sql">4.1.1 Text-to-SQL</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1*wDKR6-ToiX5UgsUYN41JiQ.png"alt="Text-to-SQL" /><figcaption aria-hidden="true">Text-to-SQL</figcaption></figure><ol type="1"><li>构建 DDL 知识库：schema 提取与切片；</li><li>构建 Q-SQL 知识库：示例对注入；</li><li>构建 DB 描述知识库：业务描述补充；</li><li>提供 RAG 检索上下文；</li><li>调用 LLM 进行 SQL 生成；</li><li>执行 SQL 并反馈结果；</li><li>迭代直到正确解决问题。</li></ol><p>常用框架：</p><ul><li>vanna</li><li>Chat2DB</li><li>DB-GPT</li></ul><h3 id="text-to-cypher">4.1.2 Text-to-Cypher</h3><p>跟 Text-to-SQL 一样，只不过是生成图数据库（neo4j）查询语句。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1*lhHfQGKOkZGNm40QIqTNIQ.png"alt="Text-to-Cypher" /><figcaption aria-hidden="true">Text-to-Cypher</figcaption></figure><ol type="1"><li>构建图元模型（Graph Metamodel）知识库；</li><li>构建 Q-Cypher 知识库（示例对注入）；</li><li>构建图描述（Graph Description）知识库；</li><li>提供 RAG 检索上下文；</li><li>调用 LLM 进行 SQL 生成；</li><li>执行 SQL 并反馈结果；</li><li>迭代直到正确解决问题。</li></ol><h3 id="从查询中提取元数据构建过滤器">4.1.3从查询中提取元数据构建过滤器</h3><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/output.png"alt="从查询中提取元数据构建过滤器" /><figcaption aria-hidden="true">从查询中提取元数据构建过滤器</figcaption></figure><ol type="1"><li>将自然语言转为向量查询语句；</li><li>利用 LLM 推断出元数据过滤条件；</li><li>在查询检索时，根据过滤条件进行文档过滤；</li><li>返回过滤后的相似文档；</li></ol><p>实战案例：</p><ul><li>https://ragflow.io/blog/implementing-text2sql-with-ragflow</li><li>https://medium.com/neo4j/generating-cypher-queries-with-chatgpt-4-on-any-graph-schema-a57d7082a7e7</li></ul><h2 id="查询翻译">4.2 查询翻译</h2><p>通过对用户查询进行改造和扩展，使其更加清晰、具体，从而提高检索精度。</p><p>常用工具：</p><table><colgroup><col style="width: 6%" /><col style="width: 78%" /><col style="width: 15%" /></colgroup><thead><tr><th style="text-align: left;"><strong>方案</strong></th><th style="text-align: left;"><strong>链接</strong></th><th style="text-align: left;"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align: left;">ragbear</td><td style="text-align: left;"><ahref="https://github.com/lexiforest/ragbear">GitHub -lexiforest/ragbear</a></td><td style="text-align: left;">rewrite= 参数多种改写模式</td></tr><tr><td style="text-align: left;">LangChain</td><td style="text-align: left;"><ahref="https://blog.langchain.dev/query-transformations/">QueryTransformations</a></td><td style="text-align: left;">内置链式改写</td></tr><tr><td style="text-align: left;">LlamaIndex</td><td style="text-align: left;"><ahref="https://docs.llamaindex.ai/en/stable/examples/query_transformations/query_transform_cookbook/">QueryTransform Cookbook ¶</a></td><td style="text-align: left;">多策略组合</td></tr><tr><td style="text-align: left;">Haystack</td><td style="text-align: left;"><ahref="https://haystack.deepset.ai/cookbook/metadata_enrichment">AdvancedRAG: Automated Structured Metadata Enrichment | Haystack</a></td><td style="text-align: left;">pipeline node</td></tr></tbody></table><h3 id="query2doc">4.2.1 Query2Doc</h3><p><a href="https://arxiv.org/pdf/2303.07678">Query2Doc</a> 是指将 query直接交给 LLM 去生成一份相关文档，然后将 query和生成的文档一起去进行检索。虽然 LLM生成的文档可能不对，但是提供了更丰富的信息、丰富了问题的语义，有助于提高检索时的精度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">query2doc</span>(<span class="params">query</span>):</span><br><span class="line">    prompt = <span class="string">f&quot;你是一名公司员工制度的问答助手，熟悉公司规章制度，请简短回答以下问题：<span class="subst">&#123;query&#125;</span>&quot;</span></span><br><span class="line">    doc_info = llm(prompt)</span><br><span class="line">    context_query = <span class="string">f&quot;<span class="subst">&#123;query&#125;</span>, <span class="subst">&#123;doc_info&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> context_query</span><br></pre></td></tr></table></figure><h3 id="hyde">4.2.2 HyDE</h3><p><ahref="https://docs.haystack.deepset.ai/docs/hypothetical-document-embeddings-hyde">HyDE</a>（HypotheticalDocument Embeddings，假设文档向量）让 LLM 根据 query去生成一系列假设性文档，然后将这些文档跟 query一起做向量化，取向量均值去进行检索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hyde</span>(<span class="params">query, include_query=<span class="literal">True</span></span>):</span><br><span class="line">    prompt_template = <span class="string">&quot;&quot;&quot;你是一名公司员工制度的问答助手，熟悉公司规章制度，请简短回答以下问题：</span></span><br><span class="line"><span class="string">    Question: &#123;question&#125;</span></span><br><span class="line"><span class="string">    Answer:&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    prompt = PromptTemplate(input_variables=[<span class="string">&quot;question&quot;</span>], template=prompt_template)</span><br><span class="line">    embeddings = HypotheticalDocumentEmbedder(llm_chain= prompt | llm,</span><br><span class="line">                                 base_embeddings=embedding_model.get_embedding_fun())</span><br><span class="line">    hyde_embedding = embeddings.embed_query(query)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> include_query:</span><br><span class="line">        query_embeddings = embedding_model.get_embedding_fun().embed_query(query)</span><br><span class="line">        result = (np.array(query_embeddings) + np.array(hyde_embedding)) / <span class="number">2</span></span><br><span class="line">        result = <span class="built_in">list</span>(result)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = hyde_embedding</span><br><span class="line">    result = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">float</span>, result))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="子问题查询">4.2.3 子问题查询</h3><p>当问题比较复杂时，可以利用 LLM将问题拆解成子问题，每个子问题都生成检索上下文，可以根据合并后总的上下文回答，也可以每个上下文独立回答后汇总。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sun_question</span>(<span class="params">query</span>):</span><br><span class="line">    prompt_template = <span class="string">&quot;&quot;&quot;你是一名公司员工制度的问答助手，熟悉公司规章制度。</span></span><br><span class="line"><span class="string">    你的任务是对复杂问题继续拆解，以便理解员工的意图。</span></span><br><span class="line"><span class="string">    请根据以下问题创建一个子问题列表：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    复杂问题：&#123;question&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    请执行以下步骤：</span></span><br><span class="line"><span class="string">    1. 识别主要问题：找出问题中的核心概念或主题。</span></span><br><span class="line"><span class="string">    2. 分解成子问题：将主要问题分解成可以独立理解和解决的多个子问题。</span></span><br><span class="line"><span class="string">    3. 只返回子问题列表，不包含其他解释信息，格式为：</span></span><br><span class="line"><span class="string">        1. 子问题1</span></span><br><span class="line"><span class="string">        2. 子问题2</span></span><br><span class="line"><span class="string">        3. 子问题3</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    prompt = PromptTemplate(input_variables=[<span class="string">&quot;question&quot;</span>], template=prompt_template)</span><br><span class="line"></span><br><span class="line">    llm_chain = prompt | llm</span><br><span class="line">    sub_queries = llm_chain.invoke(query).split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> sub_queries</span><br></pre></td></tr></table></figure><h3 id="查询改写">4.2.4 查询改写</h3><p>当问题表达不清、措辞差、缺少关键信息时，使用 LLM根据用户问题<strong>多角度</strong>重写问题，增加额外的信息，提高检索质量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">question_rewrite</span>(<span class="params">query</span>):</span><br><span class="line">    prompt_template = <span class="string">&quot;&quot;&quot;你是一名公司员工制度的问答助手，熟悉公司规章制度。</span></span><br><span class="line"><span class="string">    你的任务是需要为给定的问题，从不同层次生成这个问题的转述版本，使其更易于检索，转述的版本增加一些公司规章制度的关键词。</span></span><br><span class="line"><span class="string">    问题：&#123;question&#125;</span></span><br><span class="line"><span class="string">    请直接给出转述后的问题列表，不包含其他解释信息，格式为：</span></span><br><span class="line"><span class="string">        1. 转述问题1</span></span><br><span class="line"><span class="string">        2. 转述问题2</span></span><br><span class="line"><span class="string">        3. 转述问题3</span></span><br><span class="line"><span class="string">        ...&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    prompt = PromptTemplate(input_variables=[<span class="string">&quot;question&quot;</span>], template=prompt_template)</span><br><span class="line"></span><br><span class="line">    llmchain = prompt | llm</span><br><span class="line">    rewrote_question = llmchain.invoke(query)</span><br><span class="line">    <span class="keyword">return</span> rewrote_question</span><br></pre></td></tr></table></figure><h3 id="查询抽象">4.2.5 查询抽象</h3><p>查询抽象（Take a StepBack）是指当问题包含太多的细节，可能导致检索时忽略了关键的信息，降低检索质量。可以将用户的具体问题转化为一个更高层次的抽象问题，一个更广泛的问题，关注于高级概念或原则，从而提高检索质量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts.chat <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts.few_shot <span class="keyword">import</span> FewShotChatMessagePromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将复杂问题抽象化，使其更聚焦在本质问题上</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">take_step_back</span>(<span class="params">query</span>):</span><br><span class="line">    examples = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;input&quot;</span>: <span class="string">&quot;我祖父去世了，我要回去几天&quot;</span>,</span><br><span class="line">            <span class="string">&quot;output&quot;</span>: <span class="string">&quot;公司丧葬假有什么规定？&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;input&quot;</span>: <span class="string">&quot;我去北京出差，北京的消费高，有什么额外的补助？&quot;</span>,</span><br><span class="line">            <span class="string">&quot;output&quot;</span>: <span class="string">&quot;员工出差的交通费、住宿费、伙食补助费的规定是什么？&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    example_prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">        [</span><br><span class="line">            (<span class="string">&quot;human&quot;</span>, <span class="string">&quot;&#123;input&#125;&quot;</span>),</span><br><span class="line">            (<span class="string">&quot;ai&quot;</span>, <span class="string">&quot;&#123;output&#125;&quot;</span>),</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    few_shot_prompt = FewShotChatMessagePromptTemplate(</span><br><span class="line">        example_prompt=example_prompt,</span><br><span class="line">        examples=examples,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">        [</span><br><span class="line">            (</span><br><span class="line">                <span class="string">&quot;system&quot;</span>,</span><br><span class="line">                <span class="string">&quot;&quot;&quot;你是一名公司员工制度的问答助手，熟悉公司规章制度。</span></span><br><span class="line"><span class="string">                你的任务是将输入的问题通过归纳、提炼，转换为关于公司规章制度制定相关的一般性问题，使得问题更容易捕捉问题的意图。</span></span><br><span class="line"><span class="string">                请参考下面的例子，按照同样的风格直接返回一个转述后的问题：&quot;&quot;&quot;</span></span><br><span class="line">            ),</span><br><span class="line">            <span class="comment"># few shot exmaples,</span></span><br><span class="line">            few_shot_prompt,</span><br><span class="line">            <span class="comment"># new question</span></span><br><span class="line">            (<span class="string">&quot;user&quot;</span>, <span class="string">&quot;&#123;question&#125;&quot;</span>)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    question_gen = prompt | llm | StrOutputParser()</span><br><span class="line">    res = question_gen.invoke(&#123;<span class="string">&quot;question&quot;</span>: query&#125;).removeprefix(<span class="string">&quot;AI: &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="查询路由">4.3 查询路由</h2><p>查询路由（QueryRouting）是指根据用户问题的具体意图，自动判断应该将该问题导向最合适的数据源（例如向量知识库、SQL数据库、图数据库或特定 API）以获取最精准信息的决策过程。</p><table><colgroup><col style="width: 7%" /><col style="width: 92%" /></colgroup><thead><tr><th style="text-align: left;">思路</th><th style="text-align: left;">图示</th></tr></thead><tbody><tr><td style="text-align: left;">逻辑路由</td><td style="text-align: left;"><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1831ccf2-5d1b-4a7c-b094-6251d4aa61f5.png"alt="逻辑路由" /></td></tr><tr><td style="text-align: left;">语义路由</td><td style="text-align: left;"><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/3b10f6dc-c598-498a-90c2-c9085c7d1b27.png"alt="语义路由" /></td></tr></tbody></table><h1 id="索引优化技术">5. 索引优化技术</h1><p>基本思路：</p><ul><li>父子文档索引</li><li>分层索引</li><li>多表示索引</li></ul><h2 id="从小块到大上下文">5.1 从小块到大上下文</h2><blockquote><p>向量检索的时候，检索到的是一个小文档，但是通过小文档的metadata，返回给 LLM 的是查询出来的大文档。</p></blockquote><p>节点-句子滑动窗口检索 SentenceWindowNodeParser</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/output%20(1).png"alt="SentenceWindowNodeParser" /><figcaption aria-hidden="true">SentenceWindowNodeParser</figcaption></figure><p>父子文本块检索：ParentDocumentRetriever</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(1).png"alt="ParentDocumentRetriever" /><figcaption aria-hidden="true">ParentDocumentRetriever</figcaption></figure><p>前后串连、自动扩展上下文：PrevNextNodePostprocessor、AutoPrevNextPostprocessor</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(2).png"alt="PrevNextNodePostprocessor" /><figcaption aria-hidden="true">PrevNextNodePostprocessor</figcaption></figure><h2 id="构建有层次的索引">5.2 构建有层次的索引</h2><ul><li>构建两个向量数据库（Summary 和 Details），通过 Metadata进行连接；</li><li>通过 <code>llamaindex</code> 的 <code>indexnode</code> 和<code>PandasQueryEngine</code>；</li><li>通过查询先检索相关表名，然后做 <code>Text2SQL</code>。</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(3).png"alt="Summary &amp; Detail" /><figcaption aria-hidden="true">Summary &amp; Detail</figcaption></figure><h2 id="构建多表示索引">5.3 构建多表示索引</h2><p>构建混合索引：EnsembleRetriever</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(4).png"alt="EnsembleRetriever" /><figcaption aria-hidden="true">EnsembleRetriever</figcaption></figure><p>构建多表示索引：MultiVectorRetriever</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(5).png"alt="MultiVectorRetriever" /><figcaption aria-hidden="true">MultiVectorRetriever</figcaption></figure><h1 id="检索后优化技术">6. 检索后优化技术</h1><h2 id="重排-rerank">6.1 重排 rerank</h2><p>传统的搜索或推荐系统通常分为两步：</p><ol type="1"><li><strong>召回（Recall）</strong>:从海量的候选集中，快速、粗略地筛选出几百或几千个可能相关的项目。此阶段追求<strong>速度</strong>和<strong>查全率</strong>，常用技术包括基于关键词的搜索（如BM25）或向量相似度搜索（ANN）。</li><li><strong>排序/重排（Ranking/Reranking）</strong>:对召回的结果进行更精细、更复杂的计算，以确定最终呈现给用户的顺序。此阶段追求<strong>精准度</strong>和<strong>查准率</strong>。我们今天讨论的技术就属于这个范畴。</li></ol><p>可以把这个过程比作“海选”和“决赛”。召回是海选，快速淘汰掉明显不相关的选手；重排是决赛，评委（重排模型）对入围选手进行全方位的严格评审，最终给出排名。</p><h3 id="rrf-重排">6.1.1 RRF 重排</h3><blockquote><p>民主投票式的融合</p></blockquote><p>RRF是一种简单、高效、无需训练的“结果融合”策略。想象一下，你有多个独立的搜索系统（比如一个关键词搜索，一个向量搜索），它们各自对同一批文档给出了自己的排名。RRF的作用就是将这些不同的排名列表“民主地”融合成一个最终的、可能更优的排名列表。</p><p>RRF的核心思想是：<strong>一个文档在多个列表中的排名越靠前，它在最终列表中的排名就应该越靠前。</strong></p><p>与简单地将不同系统的得分相加不同，RRF 采用“倒数排名”（ReciprocalRank）来计算每个文档的最终分数。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(6).png"alt="RRF Rerank" /><figcaption aria-hidden="true">RRF Rerank</figcaption></figure><p>优势：</p><ul><li><strong>无需训练</strong>: 即插即用，非常方便。</li><li><strong>性能稳健</strong>:在不同召回源质量参差不齐时，表现通常比简单的分数相加（如<code>sum fusion</code>）更稳定。</li><li><strong>计算开销极低</strong>: 几乎不增加额外的计算负担。</li></ul><p>缺点：</p><ul><li><strong>效果上限不高</strong>:它只利用了“排名”这一个信息，忽略了不同系统给出的原始“分数”中蕴含的置信度信息。</li><li><strong>依赖召回质量</strong>: 如果所有召回源的质量都很差，RRF也无力回天。</li></ul><p>适应场景：</p><ul><li>混合搜索（HybridSearch）：融合关键词搜索（BM25）和向量搜索的结果。</li><li>多模态搜索：融合文本、图片等不同模态的搜索结果。</li></ul><h3 id="cross-encoder-重排">6.1.2 Cross-Encoder 重排</h3><blockquote><p>query 和文档的"深度阅读理解"</p></blockquote><p>如果说召回阶段的向量搜索是"看标题识文章"，那么 Cross-Encoder重排就是"把 query和每篇文档放在一起，逐字逐句地做一篇完整的阅读理解"。</p><p>它通过深度学习模型（通常是 Transformer 架构，如 BERT）来判断一个query 和一个文档之间的相关性到底有多强。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1*hkV7rQlN6OuEin7qPxyafA.jpeg"alt="Cross-Encoder Rerank" /><figcaption aria-hidden="true">Cross-Encoder Rerank</figcaption></figure><p>基本流程：</p><ol type="1"><li><strong>输入构建</strong>:将查询（Query）和待排序的文档（Document）用一个特殊的分隔符（如<code>[SEP]</code>）拼接在一起，形成一个单一的输入序列。例如：<code>[CLS] 我的问题是什么？[SEP] 这是候选文档的内容... [SEP]</code></li><li><strong>模型计算</strong>: 将这个拼接后的序列输入到一个预训练好的Transformer 模型（如BERT）中。模型内部的自注意力机制（Self-Attention）会让 Query中的每个词和 Document 中的每个词都进行充分的交互和信息比对。</li><li><strong>分数输出</strong>:模型在处理完整个序列后，通常会利用起始位置 <code>[CLS]</code> Token对应的输出向量，接一个简单的线性层，最终输出一个单一的分数（logit），这个分数就代表了Query 和 Document 之间的相关性得分。</li><li><strong>排序</strong>:根据所有文档得到的相关性得分，从高到低进行排序，得到最终结果。</li></ol><p>优点：</p><ul><li><strong>效果极佳</strong>: 由于对 query和文档进行了深度的、非对称的交互分析，其精度通常是所有重排方法中最高的。</li></ul><p>缺点：</p><ul><li><strong>计算成本极高</strong>: 对于每个<code>(query, document)</code>对，都需要进行一次完整的、重量级的模型前向传播。如果召回了 500个文档，就需要进行 500 次 BERT模型的计算，这在实时性要求高的场景下是巨大的挑战。</li><li><strong>无法提前索引</strong>: 文档的表示不是独立的，必须在查询时与query 结合才能计算，因此无法像向量搜索那样提前为所有文档建立索引。</li></ul><p>适用场景：</p><ul><li>对精度要求极高，且可以容忍较高延迟的场景，如某些法律或医疗文献的精确查找。</li><li>作为“黄金标准”来生成高质量的标注数据，用于训练更轻量的召回模型（如Bi-Encoder）。</li></ul><h3 id="colbert-重排">6.1.3 ColBERT 重排</h3><blockquote><p>Contextualized Late Interaction over BERT。</p><p>介于“看标题”和“深度阅读”之间的“划重点式”阅读</p></blockquote><p>ColBERT 试图在 Cross-Encoder 的高精度和 Bi-Encoder (召回阶段常用)的高效率之间找到一个平衡点。它的核心思想是：<strong>不需要逐字逐句地进行完整对比，而是先把query和文档各自的"重点"（关键词向量）划出来，然后再计算这些重点之间的匹配程度。</strong></p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/colbert.png"alt="ColBERT Rerank" /><figcaption aria-hidden="true">ColBERT Rerank</figcaption></figure><p>基本流程：</p><ol type="1"><li><strong>独立编码</strong>: 首先，使用一个 BERT类的模型（但稍作修改）分别独立地处理 Query 和Document。它不再是输出一个单一的 <code>[CLS]</code> 向量，而是为 Query和 Document 中的<strong>每一个 Token</strong>都生成一个上下文相关的向量。</li><li><strong>Query 端向量</strong>: 对于 Query，我们保留所有 Token的输出向量。</li><li><strong>Document 端向量</strong>: 对于 Document，我们也保留所有Token 的输出向量。这些向量可以<strong>提前计算并存储</strong>，这是它比Cross-Encoder 高效的关键。</li><li><strong>延迟交互计算</strong>:在查询时，进行“延迟交互”。具体来说，对于 Query中的<strong>每一个</strong> Token 向量，我们都去 Document 的所有 Token向量中寻找一个最相似的（通过最大内积<code>MaxSim</code>操作）。</li><li><strong>分数聚合</strong>: 最后，将 Query 中每个 Token找到的最大相似度分数<strong>相加</strong>，得到最终的相关性总分。</li></ol><blockquote><p>这个过程好比：</p><ul><li><strong>Query</strong>: "best deep learning framework"</li><li><strong>Document</strong>: "PyTorch is a popular framework for deeplearning..."</li></ul><p>ColBERT 会分别计算：</p><ul><li>"best" 和文档中所有词向量的最大相似度。</li><li>"deep" 和文档中所有词向量的最大相似度。</li><li>"learning" 和文档中所有词向量的最大相似度。</li><li>"framework" 和文档中所有词向量的最大相似度。</li><li>然后把这四个最大相似度值加起来作为总分。</li></ul></blockquote><p>优点：</p><ul><li><strong>性能优越</strong>: 精度远超传统的Bi-Encoder，并且在很多任务上能逼近 Cross-Encoder。</li><li><strong>效率较高</strong>:由于文档向量可以预计算和索引，查询时的计算开销远低于Cross-Encoder，只涉及向量的相似度计算。</li></ul><p>缺点：</p><ul><li><strong>存储开销大</strong>: 需要为文档中的每个 Token都存储一个高维向量，存储成本远高于只存一个文档向量的 Bi-Encoder。</li><li><strong>实现相对复杂</strong>:其索引和查询逻辑比标准向量搜索更复杂。</li></ul><p>适用场景：</p><ul><li>需要高精度但又对延迟有一定要求的现代搜索引擎，如微软的 Bing就在使用类似的技术。</li><li>作为 RAG 系统中的高质量重排器。</li></ul><h3 id="cohere-和-jina-重排">6.1.4 Cohere 和 Jina 重排</h3><blockquote><p>商业化的"重排即服务"（Reranking-as-a-Service）</p></blockquote><p>Cohere 和 Jina AI 都是提供 AI模型和服务的公司。它们都将高质量的重排模型封装成了简单易用的 API服务。本质上，它们提供的重排器很可能就是基于类似 Cross-Encoder架构的、在海量高质量数据上训练和优化的专有模型。</p><p>优点：</p><ul><li><strong>使用简单</strong>: 只需几行代码调用 API即可，无需关心模型训练、部署和维护。</li><li><strong>效果保证</strong>:通常能获得非常好的开箱即用效果，因为这些模型经过了大量数据的锤炼。</li></ul><p>缺点：</p><ul><li><strong>成本</strong>: 按调用量或 token数量计费，对于大流量应用可能是一笔不小的开销。</li><li><strong>数据隐私</strong>: 需要将你的 query和文档数据发送给第三方服务商，对于数据敏感的应用需要仔细评估其隐私政策。</li><li><strong>灵活性受限</strong>:无法像自建模型那样进行深度定制或调优。</li></ul><p>适用场景：</p><ul><li>快速原型验证（MVP）。</li><li>中小型企业或开发者，希望以最小的工程代价获得最好的排序质量。</li><li>大型企业中非核心但又需要高质量排序的业务场景。</li></ul><h3 id="rankgpt-和-rankllm">6.1.5 RankGPT 和 RankLLM</h3><p>这是最新的重排范式，直接利用 LLM强大的语言理解和推理能力来进行排序。它的思路是：<strong>不再让模型输出一个简单的相关性分数，而是让LLM直接对召回的文档列表进行"思考"和"比较"，然后输出一个排序好的列表。</strong></p><p>基本思路：</p><ol type="1"><li><strong>构建 Prompt</strong>: 将 query和召回的文档列表（通常是文档的标题和摘要）格式化成一个复杂的Prompt。这个 Prompt 会明确指示 LLM作为一个排序专家，对给定的文档列表根据与 query的相关性进行排序，并按指定的格式输出结果。</li><li><strong>LLM 推理</strong>: 将这个 Prompt 发送给 LLM。LLM会利用其强大的上下文理解能力，分析 query的深层意图，并比较不同文档之间的细微差别（例如，一个内容更全面，另一个更新颖）。</li><li><strong>解析输出</strong>: LLM会返回一个文本结果，比如一个重新排序好的文档 ID列表。程序需要解析这个文本输出来获取最终的排序。</li></ol><p>优点：</p><ul><li><strong>理解复杂意图</strong>: LLM 能够理解非常复杂和模糊的query，并能进行一定程度的推理，这是传统模型难以做到的。</li><li><strong>零样本/少样本能力强</strong>:无需针对特定任务进行微调，就能在很多场景下取得惊人的效果。</li><li><strong>可解释性</strong>: 有时可以引导 LLM给出排序的理由，增加了透明度。</li></ul><p>缺点：</p><ul><li><strong>成本和延迟极高</strong>: 调用大型 LLM API的成本和时间开销是目前所有方法中最高的，通常只能用于非实时或小批量任务。</li><li><strong>上下文长度限制</strong>: LLM的上下文窗口大小有限，一次能处理的文档数量和文档长度都受限。</li><li><strong>稳定性问题</strong>:输出格式可能不稳定，需要设计鲁棒的解析逻辑。结果也可能有一定的随机性。</li></ul><p>适用场景：</p><ul><li>对召回结果的“最后一公里”进行精加工，例如对前 10名结果进行最终排序。</li><li>作为生成高质量排序标注数据的强大工具。</li><li>对成本不敏感、但对排序质量有极致要求的特定应用。</li></ul><h3 id="时效加权重排">6.1.6 时效加权重排</h3><p>这是一种业务逻辑驱动的重排策略，而非特定的模型或算法。其核心思想是：<strong>对于某些类型的查询，最新的信息比旧的信息更有价值。</strong></p><p>基本思路：</p><ol type="1"><li><strong>时间衰减函数 (Time Decay Function)</strong>:设计一个函数，使得文档的分数随着其发布时间的流逝而衰减。最常用的函数是指数衰减或高斯衰减。</li><li><strong>分桶加权</strong>: 将文档按发布时间分到不同的桶里，如"24小时内"、"一周内"、"一月内"、"更早"。为每个桶设置一个固定的权重或加分项。例如，"24小时内"的文档分数乘以 1.5，"一周内"的乘以 1.2 等。</li></ol><p>优点：</p><ul><li><strong>实现简单</strong>: 逻辑清晰，容易实现和调整。</li><li><strong>效果显著</strong>:对于新闻、社交媒体、产品更新等时效性强的查询，能极大提升用户体验。</li></ul><p>缺点：</p><ul><li><strong>"一刀切"风险</strong>:如果不加区分地对所有查询都增强时效性，可能会伤害那些寻求""永恒"知识的查询（如"什么是牛顿第一定律"）。</li><li><strong>参数难调</strong>: 衰减函数的形状、权重 w等参数需要根据经验和 A/B 测试来仔细调整。</li></ul><p>适用场景：</p><ul><li><strong>新闻搜索</strong>: 用户总是想看最新的报道。</li><li><strong>电商新品</strong>:用户搜索"手机"时，可能更想看到最新款。</li><li><strong>社交媒体 Feed</strong>: 最新的帖子通常排在最前面。</li><li><strong>需要与查询意图识别结合</strong>:一个优秀的系统应该能识别出哪些 query是具有时效性意图的，然后动态地应用时效性加权。</li></ul><h2 id="压缩-compression">6.2 压缩 compression</h2><p>传统的 RAG流程是“检索-增强-生成”。系统首先根据用户问题从知识库中检索出若干相关文档片段（Chunks），然后将这些片段作为上下文（Context）连同用户问题一起提交给大语言模型（LLM），由LLM 生成最终答案。</p><p>这里面潜藏着几个挑战：</p><ol type="1"><li><strong>上下文窗口限制 (Context Window Limit)</strong>：每个 LLM都有其上下文长度上限（如 GPT-4 是 128ktokens）。如果检索出的文档过多，会超出窗口限制，导致无法处理。</li><li><strong>成本与延迟 (Cost &amp; Latency)</strong>：LLM 的 API调用费用通常与输入的 Token数量成正比。上下文越长，费用越高，同时模型的推理时间也越长，导致用户等待时间增加。</li><li><strong>“大海捞针”问题 (Lost in the Middle)</strong>：研究表明，当LLM的上下文中包含大量信息时，它对位于上下文中间部分信息的注意力会下降。如果关键信息被大量无关或次要信息包围，LLM可能无法有效利用它，从而影响生成答案的准确性。</li><li><strong>噪声干扰 (NoiseInterference)</strong>：检索出的文档片段虽然“相关”，但并非每个字、每句话都对回答当前问题至关重要。这些无关信息就是“噪声”，会干扰LLM 的判断。</li></ol><p>因此，<strong>RAG压缩技术的核心目标</strong>，就是在将检索到的信息送入 LLM之前，对其进行“精炼”——去除无关信息、保留核心内容，从而在<strong>降低成本、提升效率</strong>的同时，<strong>提高最终答案的质量</strong>。</p><h3 id="上下文压缩检索器">6.2.1 上下文压缩检索器</h3><p>上下文压缩检索器是指 LangChain 提供的<code>Contextual Compression Retriever</code>。</p><p>它不是一个独立的检索器，而是一个"包装器"（Wrapper）。它首先使用一个常规的检索器（如<code>VectorStoreRetriever</code>）获取一批文档，然后通过一个嵌入的"文档压缩器"（DocumentCompressor）对这些文档进行筛选或重写，最后只返回那些真正重要的信息。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*SL1A95gsICIB5IDA.png"alt="Contextual Compression Retriever" /><figcaption aria-hidden="true">Contextual CompressionRetriever</figcaption></figure><p>LangChain 提供了两种主流的压缩器：</p><ul><li><strong><code>LLMChainExtractor</code></strong>：这个压缩器内部会运行一个LLM（通常是一个小模型）。它会遍历每个检索到的文档，并向 LLM提出一个问题，例如："请从以下文档中抽取出与'[用户原始问题]'相关的句子。"LLM会根据指令抽取出关键句子，丢弃无关部分，从而实现压缩。这是一种<strong>基于LLM 的抽取式压缩</strong></li><li><strong><code>EmbeddingsFilter</code></strong>：这个压缩器不依赖LLM。它会计算用户问题和每个检索文档（或文档内更小的句子片段）的嵌入向量（Embedding）之间的相似度。只有当相似度超过预设的阈值（e.g.,<code>similarity_threshold=0.8</code>）时，该文档或句子才会被保留。这是一种<strong>基于嵌入相似度的过滤式压缩</strong>。</li></ul><p>优势：</p><ul><li><strong>提升信噪比</strong>：直接过滤掉与问题无关的整个文档或文档中的无关部分。</li><li><strong>灵活性高</strong>：可以根据需求选择计算成本低但效果略粗糙的<code>EmbeddingsFilter</code>，或选择成本高但更智能的<code>LLMChainExtractor</code>。</li><li><strong>模块化</strong>：与 LangChain 生态无缝集成，易于实现。</li></ul><h3 id="句子嵌入优化器">6.2.2 句子嵌入优化器</h3><p>句子嵌入优化器是指 LlamaIndex 提供的<code>Sentence Embedding Optimizer</code>。</p><p>与 LangChain 的 <code>EmbeddingsFilter</code> 思想非常相似，但它在LlamaIndex 的生态系统内，并专注于句子级别的精细化过滤。</p><p>在检索到相关的文档块（Node）之后，不是将整个文档块都丢给LLM，而是深入到文档块内部，逐一分析每个句子，只保留与用户问题最相关的句子。</p><p>基本原理：</p><ol type="1"><li><strong>初始节点检索</strong>：查询引擎首先从索引中检索出 Top-K个最相关的节点（Nodes，相当于 LangChain 的 Documents）。</li><li><strong>句子级分析</strong>：<code>SentenceEmbeddingOptimizer</code>（或类似功能的<code>SimilarityPostprocessor</code>）接收这些节点。它会：<ul><li>将每个节点分解成单独的句子。</li><li>为每个句子计算一个嵌入向量。</li><li>计算每个句子的嵌入向量与用户原始问题嵌入向量之间的相似度得分。</li></ul></li><li><strong>阈值过滤</strong>：它会根据一个预设的相似度阈值（<code>similarity_cutoff</code>）来决定保留哪些句子。只有得分高于阈值的句子才会被保留下来，组合成新的、更精简的节点内容。</li><li><strong>合成响应</strong>：最后，只有这些经过精炼的、包含高相关度句子的节点才会被送入响应合成器（ResponseSynthesizer），由 LLM 生成最终答案。</li></ol><p>优势：</p><ul><li><strong>粒度极细</strong>：相比于过滤整个文档，句子级过滤能最大程度地保留一个文档块中的相关信息，同时剔除无关句子，精度更高。</li><li><strong>减少上下文割裂</strong>：有时一个文档块整体相关度可能不高，但其中有一两句关键信息。这种方法可以精准地把这两句"捞"出来，避免整个文档块被丢弃。</li></ul><h3 id="llmlingua">6.2.3 LLMLingua</h3><p>在将包含检索文档的冗长提示词（Prompt）发送给昂贵的大模型（如GPT-4）之前，先用一个更小、更便宜的语言模型（如 GPT-2 或一个微调过的Llama）来对这个提示词进行"有损压缩"。这个压缩过程会识别并删除那些对 LLM理解问题和生成答案不太重要的词语或句子。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/LLMLinguafigure1.png"alt="LLMLingua: Innovating LLM efficiency with prompt compression - Microsoft Research" /><figcaption aria-hidden="true">LLMLingua: Innovating LLM efficiency withprompt compression - Microsoft Research</figcaption></figure><p>基本原理：</p><ol type="1"><li><strong>构建完整提示词</strong>：将用户问题和所有检索到的文档拼接成一个完整的、非常长的提示词。</li><li><strong>小模型介入</strong>：LLMLingua使用一个小模型来分析这个长提示词。它会评估如果从提示词中删除某个词或某段话，对大模型理解原始提示词的“困惑度”会产生多大影响。</li><li><strong>智能删除</strong>：它会优先删除那些对困惑度影响最小的词语和句子，因为这些内容被认为是信息量较低或冗余的。这个过程被设计得非常精巧，旨在保留关键的实体、术语和逻辑关系。</li><li><strong>生成压缩提示词</strong>：经过这个过程，原始的长提示词被压缩成一个更短的版本，其中包含了原始上下文的"精华"。</li><li><strong>提交大模型</strong>：最后，这个压缩后的、短小精悍的提示词被发送给目标大模型进行处理。</li></ol><h3 id="recomp-压缩">6.2.4 RECOMP 压缩</h3><p>RECOMP (REtrieval-and-COMPression)是一种面向<strong>复杂问题</strong>的、多步骤的 RAG策略，它将压缩思想融入到了一个更宏大的框架中。</p><p>当面对一个需要综合多个信息源才能回答的复杂问题时，传统的 RAG一次性检索出的文档可能包含大量不相关细节。RECOMP通过"分而治之"和"先抽取再合成"的方式来创建高度浓缩和相关的上下文。</p><p>基本原理：</p><ol type="1"><li><strong>问题分解（可选）</strong>：对于一个非常复杂的问题，可能首先会将其分解为几个更简单的子问题。</li><li><strong>检索与抽取 (Retrieve andExtract)</strong>：针对（每个子）问题，执行以下操作：<ol type="1"><li><strong>检索</strong>：从知识库中检索相关文档。</li><li><strong>抽取</strong>：<strong>这是关键步骤</strong>。它不是直接使用这些文档，而是向LLM 发出指令，要求 LLM阅读每个文档，并从中<strong>抽取</strong>出与当前（子）问题直接相关的<strong>简明摘要或关键事实点</strong>。例如："请阅读以下关于A 公司的财报，并抽取出其 2023 年第四季度的收入和利润数字。"</li></ol></li><li><strong>压缩与合成 (Compress and Synthesize)</strong>：<ol type="1"><li>将从所有文档中抽取出的摘要或事实点收集起来。</li><li>再次调用LLM，将这些零散但高度相关的信息点<strong>合成</strong>成一段连贯、流畅、无冗余的文本。这段文本就是最终为原始复杂问题量身定制的“完美上下文”。</li></ol></li><li><strong>最终生成</strong>：将这个合成好的、高度浓缩的上下文连同原始问题一起提交给LLM，生成最终答案。</li></ol><p>优势：</p><ul><li><strong>极高的信息密度</strong>：最终生成的上下文几乎不含任何与问题无关的噪声，每一句话都是为了回答问题而存在的。</li><li><strong>处理复杂问题的能力强</strong>：非常适合需要整合来自不同文档、不同主题信息的“多跳（multi-hop）”问题。</li><li><strong>可解释性</strong>：由于中间步骤生成了摘要和事实点，这个过程比黑盒方法更易于调试和理解。</li></ul><h3 id="prompt-caching-记忆上下文">6.2.5 Prompt Caching 记忆上下文</h3><p>它是一种<strong>性能优化</strong>技术，而非内容压缩技术，但常在处理长上下文时被提及。</p><p>在 Transformer 模型（所有现代 LLM的基础）中，当模型处理一个序列时，它会为每个 Token计算一个键（Key）和值（Value）向量，这个计算过程非常耗时。PromptCaching（或称 KV Cache）技术的核心就是：<strong>将已经处理过的 Prompt部分的 KV 向量缓存起来，下次请求时如果 Prompt前缀相同，则直接复用缓存，无需重新计算。</strong></p><p>基本原理：</p><ol type="1"><li><strong>首次请求</strong>：用户发送一个长Prompt（例如，一篇需要总结的文章）。模型在处理这个长 Prompt时，会计算其中每个 Token 的 KV 向量，并将它们存储在 GPU 的内存中（即 KVCache）。</li><li><strong>后续交互</strong>：现在，用户基于这篇文章提问（例如，“文章的作者是谁？”）。这个新的请求实际上是<code>[原始长Prompt] + [新问题]</code>。</li><li><strong>缓存命中</strong>：当模型收到这个新请求时，它会发现请求的前半部分（<code>[原始长Prompt]</code>）与上一次完全相同。它会立即从KV Cache 中加载这部分的 KV向量，而<strong>只需为新的部分（<code>[新问题]</code>）计算 KV向量</strong>。</li><li><strong>加速生成</strong>：这样一来，模型省去了重复计算长 Prompt部分的巨大开销，从而极大地加快了对新问题的响应速度。</li></ol><p>优势：</p><ul><li><strong>大幅提升多轮对话或连续查询的性能</strong>：对于聊天机器人、文档问答等需要保持长上下文的场景，效果极其显著。</li><li><strong>降低总计算成本</strong>：虽然不减少送入的 Token数，但通过复用计算结果，降低了处理相同前缀的实际计算成本和时间。</li></ul><h2 id="校正-correction">6.3 校正 correction</h2><p>C-RAG的核心思想是在检索模块和生成模块之间，引入一个<strong>轻量级的“检索评估器”(RetrievalEvaluator)</strong>，并根据评估结果采取不同的<strong>校正措施</strong>。这项技术主要在学术论文<em><a href="https://arxiv.org/abs/2401.15884">arXiv:2401.15884</a></em>中被系统性地提出和阐述。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(7).png"alt="C-RAG" /><figcaption aria-hidden="true">C-RAG</figcaption></figure><p>C-RAG 的精髓在于其动态的、差异化的处理策略。</p><ul><li><strong>当评估为“不正确”时</strong>：C-RAG会果断地<strong>抛弃</strong>所有从内部知识库检索到的文档。因为它判断这些文档只会误导LLM。取而代之，它会<strong>重写 (Rewrite)</strong>用户的查询，使其更适合通用搜索引擎，然后<strong>触发网络搜索 (WebSearch)</strong>，从更广阔的、实时更新的互联网中获取信息。这极大地扩展了RAG系统的知识边界，尤其适用于回答关于近期事件或内部知识库未覆盖领域的问题。</li><li><strong>当评估为“正确”时</strong>：即便文档是相关的，也可能包含大量与问题无关的“噪音”段落。为了让LLM 更专注于核心信息，C-RAG 采用了一种“分解-再重组”(Decompose-then-Recompose)*的知识精炼算法。<ul><li><strong>分解(Decompose)</strong>：将相关的文档分解成更小的、独立的知识片段(Knowledge Strips)。</li><li><strong>重组(Recompose)</strong>：再次使用评估器对每个知识片段进行打分，过滤掉无关的片段，只保留最核心、最相关的知识点，然后将这些精华片段“重组”起来，作为最终的上下文。</li></ul></li><li><strong>当评估为“模糊”时</strong>：C-RAG会采取一种混合策略。它会<strong>同时</strong>对内部检索到的模糊文档进行上述的“分解-再重组”精炼，并启动网络搜索获取外部信息。最后，将两方面的信息<strong>合并</strong>，为LLM 提供一个更全面、更鲁棒的上下文。</li></ul><p>实战案例：<ahref="https://langchain-ai.github.io/langgraph/tutorials/rag/langgraph_crag/">LangGraph-CRAG</a></p><h1 id="响应生成">7. 响应生成</h1><ul><li><ahref="https://python.langchain.com/docs/concepts/output_parsers/">Outputparsers | 🦜️🔗 LangChain</a></li><li><ahref="https://docs.llamaindex.ai/en/stable/module_guides/querying/structured_outputs/output_parser/">LlamaIndex丨 Output Parsing Modules</a></li><li><ahref="https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses">OpenAI丨 Structured Outputs</a></li></ul><h1 id="系统性优化">8. 系统性优化</h1><p>系统性优化指的是从系统层面上，通过优化整个 RAG流程来达到一个更好的检索效果。</p><h2 id="自我修正与反思型-rag">8.1 自我修正与反思型 RAG</h2><ul><li>业界标杆：<ahref="https://github.com/AkariAsai/self-rag">self-rag</a></li><li>笔者实践：<ahref="https://github.com/hedon-ai-road/regulation_rag/blob/main/self_rag.py">self-rag.py</a></li></ul><p>此架构模拟了人类“先思考、再审视、后修正”的决策过程。系统首先生成一个初步答案，然后启动一个内部的"批评家"来评估这个答案的质量。如果发现问题（如信息不完整、逻辑不通顺），系统会生成修正指令，并基于新指令进行迭代优化，直到产出高质量的最终答案。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/d9b68194-3676-4c00-88c2-12f4e1020e64.png"alt="Self-RAG 思想简化" /><figcaption aria-hidden="true">Self-RAG 思想简化</figcaption></figure><h2 id="迭代式检索-rag">8.2 迭代式检索 RAG</h2><ul><li><a href="https://arxiv.org/pdf/2403.06840">RA-ISF</a></li></ul><p>此架构专门应对信息不足的问题。当一次检索无法获取回答复杂问题所需的全部信息时，系统会进入一个迭代循环。它会分析已获取的内容，智能地生成新的、更深入的查询，然后再次进行检索。这个过程不断重复，直到收集到足够全面的上下文，最后再进行综合生成。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(8).png"alt="Iterative Retrieval RAG 原理简化" /><figcaption aria-hidden="true">Iterative Retrieval RAG原理简化</figcaption></figure><h2 id="自适应智能体-rag">8.3 自适应/智能体 RAG</h2><ul><li><ahref="https://github.com/asinghcsu/AgenticRAG-Survey">AgenticRAG-Survey</a></li></ul><p>此架构将 RAG 提升到了一个智能体（Agent）的高度。系统核心是一个作为大脑的LLM，它能自主分析用户问题，并决策采取何种行动：是进行知识库检索、上网搜索、调用计算器，还是直接回答。它能制定多步计划并调用不同工具，展现出更高的灵活性和解决复杂问题的能力。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(9).png"alt="Agentic RAG 原理简化" /><figcaption aria-hidden="true">Agentic RAG 原理简化</figcaption></figure><h1 id="评估">9. 评估</h1><ul><li>实践案例：<ahref="https://github.com/hedon-ai-road/regulation_rag/blob/main/eval.ipynb">eval.ipynb</a></li></ul><h2 id="三大标准">9.1 三大标准</h2><ul><li><strong>ContextRelevance</strong>：系统检索到的上下文是否紧密围绕用户的问题展开，是否包含了解答问题所需的关键信息。</li><li><strong>Faithfulness</strong>：生成的答案与给定的上下文之间的事实一致性。</li><li><strong>AnswerRelevance</strong>：关注答案是否直接回答了问题，还关注答案是否完整、是否包含冗余信息。</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250704094042400.png"alt="RAG 评估三大标准" /><figcaption aria-hidden="true">RAG 评估三大标准</figcaption></figure><h2 id="三大步骤">9.2 三大步骤</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250704094056404.png"alt="RAG 评估三大步骤" /><figcaption aria-hidden="true">RAG 评估三大步骤</figcaption></figure><h2 id="ragas">9.3 Ragas</h2><p><a href="https://docs.ragas.io/en/stable/">Ragas</a> 评估指标：</p><ul><li><strong>Faithfulness</strong>:生成的答案与给定的上下文之间的事实一致性。</li><li><strong>Answer relevancy</strong>:关注答案是否直接回答了问题，还关注答案是否完整、是否包含冗余信息。</li><li><strong>Context Precision</strong>: 衡量检索上下文的信噪比。</li><li><strong>Context Recall</strong>:判断是否能检索到回答问题所需的全部相关信息。</li></ul><p>优点：</p><p>优点：</p><ol type="1"><li>轻量易用。</li><li>指标专业性：专为 RAG 设计四大核心指标：上下文相关性（ContextRelevance）、上下文召回率（ContextRecall）、答案忠实度（Faithfulness）、答案相关性（AnswerRelevance）。</li><li>无参考标签评估：不依赖参考答案即可完成评估，降低标注成本。</li></ol><p>缺点：</p><ol type="1"><li>结果可解释性弱：仅输出分数，不提供得分原因。</li><li>本地化支持不足：主要优化英文场景，对中文等语言支持有限。</li><li>功能扩展性弱：不支持自定义指标，灵活性较。</li></ol><p>代码示例：</p><p><strong>1. 构建数据集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line">questions = [</span><br><span class="line">    <span class="string">&quot;伙食补助费标准是什么?&quot;</span>,</span><br><span class="line">    <span class="string">&quot;出差可以买意外保险吗？需要自己购买吗&quot;</span>,</span><br><span class="line">]</span><br><span class="line">ground_truths = [</span><br><span class="line">    <span class="string">&quot;伙食补助费标准: 西藏、青海、新疆 120元/人、天 其他省份 100元/人、天&quot;</span>,</span><br><span class="line">    <span class="string">&quot;出差可以购买交通意外保险，由单位统一购买，不再重复购买&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">answers = []</span><br><span class="line">contexts = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> query <span class="keyword">in</span> questions:</span><br><span class="line">    response, context_list = run_rag_pipeline_without_stream(query=query, k=<span class="number">3</span>)</span><br><span class="line">    answers.append(response)</span><br><span class="line">    contexts.append(context_list)</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;question&quot;</span>: questions,</span><br><span class="line">    <span class="string">&quot;answer&quot;</span>: answers,</span><br><span class="line">    <span class="string">&quot;contexts&quot;</span>: contexts,</span><br><span class="line">    <span class="string">&quot;ground_truth&quot;</span>: ground_truths</span><br><span class="line">&#125;</span><br><span class="line">dataset = Dataset.from_dict(data)</span><br></pre></td></tr></table></figure><p><strong>2. 定义评估指标</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ragas.metrics <span class="keyword">import</span>(</span><br><span class="line">    faithfulness,</span><br><span class="line">    answer_relevancy,</span><br><span class="line">    context_recall,</span><br><span class="line">    context_precision,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>3. 执行评估</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ragas <span class="keyword">import</span> evaluate</span><br><span class="line"><span class="keyword">from</span> ragas <span class="keyword">import</span> RunConfig</span><br><span class="line"></span><br><span class="line">eval_llm = RagLLM()</span><br><span class="line">embedding_model = RagEmbedding()</span><br><span class="line">eval_embedding_fn = embedding_model.get_embedding_fun()</span><br><span class="line"></span><br><span class="line">result = evaluate(</span><br><span class="line">    dataset=dataset,</span><br><span class="line">    llm=eval_llm,</span><br><span class="line">    embeddings=eval_embedding_fn,</span><br><span class="line">    metrics=[</span><br><span class="line">        context_precision,</span><br><span class="line">        context_recall,</span><br><span class="line">        faithfulness,</span><br><span class="line">        answer_relevancy,</span><br><span class="line">    ],</span><br><span class="line">    raise_exceptions=<span class="literal">True</span>,</span><br><span class="line">    run_config=config</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">df = result.to_pandas()</span><br></pre></td></tr></table></figure><p><strong>4. 评估结果</strong></p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image%20(10).png"alt="Ragas 评估结果示例" /><figcaption aria-hidden="true">Ragas 评估结果示例</figcaption></figure><h2 id="trulens">9.4 TruLens</h2><p>提供一个交互式的仪表板（Dashboard），用于可视化评估结果、比较不同版本的实验并追踪性能变化。它不仅支持LangChain 和 LlamaIndex 等主流框架，还支持对完全自定义的 RAG应用进行封装和评估。</p><p>典型流程：</p><ol type="1"><li>定义反馈函数（如<code>Groundedness</code>，<code>AnswerRelevance</code>，<code>ContextRelevance</code>）；</li><li>然后用 <code>TruApp</code> 包装 RAG 应用；</li><li>再一个 <code>with</code> 上下文管理器中运行查询；</li><li><code>run_dashboard</code> 启动仪表盘查看结果。</li></ol><p>优点：</p><ol type="1"><li>全链路追踪：记录 RAG全流程（检索、上下文、生成），支持根本原因分析，精准定位故障点（如检索错误或生成偏差）。</li><li>可视化与集成：内置 Web 仪表盘，实时展示评估结果；深度集成 LangChain和 LlamaIndex。</li><li>反馈函数组合：支持自定义反馈函数（如毒性检测、语言匹配），灵活适配业务需求。</li></ol><p>缺点：</p><ol type="1"><li>指标覆盖面窄：核心仅三大指标（上下文相关性、答案忠实度、答案相关性），缺乏上下文召回率等关键维度。</li><li>依赖人工标注：答案正确性等指标需参考答案（GroundTruth），增加标注成本。</li><li>调试门槛高：全链路追踪需额外配置，对新手不够友好。</li></ol><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> trulens_eval <span class="keyword">import</span> TruApp, Feedback, OpenAI, Select</span><br><span class="line"><span class="keyword">from</span> trulens_eval.app <span class="keyword">import</span> App</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化反馈函数提供者</span></span><br><span class="line">provider = OpenAI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 RAG 三元组反馈函数</span></span><br><span class="line">f_groundedness = Feedback(provider.groundedness_measure_with_cot_reasons).on(Select.RecordCalls.retrieve.rets.collect()).on_output()</span><br><span class="line">f_answer_relevance = Feedback(provider.relevance_with_cot_reasons).on_input().on_output()</span><br><span class="line">f_context_relevance = Feedback(provider.context_relevance_with_cot_reasons).on_input().on(Select.RecordCalls.retrieve.rets[:]).aggregate(np.mean)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包装 RAG 应用</span></span><br><span class="line">tru_rag_app = TruApp(rag_query_engine, app_id=<span class="string">&quot;RAG_v1&quot;</span>, feedbacks=[f_groundedness, f_answer_relevance, f_context_relevance])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行并记录评估</span></span><br><span class="line"><span class="keyword">with</span> tru_rag_app <span class="keyword">as</span> recording:</span><br><span class="line">    rag_query_engine.query(<span class="string">&quot;What did the author do growing up?&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动仪表板</span></span><br><span class="line">tru.run_dashboard()</span><br></pre></td></tr></table></figure><h2 id="deepeval">9.5 DeepEval</h2><p>将自身定位为 LLM 应用的"单元测试"框架，理念非常现代化。提供超过 14种评估指标，不仅覆盖RAG，还包括微调等场景。其一大亮点是指标具有<strong>自我解释</strong>能力，即在给出分数的同时，会提供具体的理由来解释为何得分不高，极大地便利了调试过程。此外，它与流行的测试框架Pytest 深度集成，可以无缝地融入 CI/CD 流程。</p><p>优点：</p><ol type="1"><li>工程化与自动化：原生支持 pytest，可集成 CI/CD流水线，实现自动化测试与报告生成。</li><li>指标丰富且可定制：内置 30+ 指标（如忠实度、毒性、偏见检测），支持DAG自定义指标（决策树结构）满足复杂逻辑。独创上下文召回率计算（基于关键陈述覆盖比例）。</li><li>结果可解释性强：提供分数原因及改进建议，支持与 RAGAS结果联动分析</li></ol><p>缺点：</p><ol type="1"><li>部分指标非 RAG专属：如摘要质量、知识保留等指标更通用，需筛选适用场景。</li><li>依赖评估模型：默认使用 OpenAI 模型，替换自定义模型需额外开发。</li><li>配置复杂：DAG指标需设计节点逻辑（任务节点、裁决节点等），学习曲线陡峭。</li></ol><p>示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> deepeval</span><br><span class="line"><span class="keyword">import</span> deepeval.evaluate</span><br><span class="line"><span class="keyword">from</span> deepeval.metrics <span class="keyword">import</span> (</span><br><span class="line">    FaithfulnessMetric,</span><br><span class="line">    AnswerRelevancyMetric,</span><br><span class="line">    ContextualPrecisionMetric,</span><br><span class="line">    ContextualRecallMetric</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> deepeval.test_case <span class="keyword">import</span> LLMTestCase</span><br><span class="line"></span><br><span class="line">test_cases = []</span><br><span class="line"><span class="keyword">for</span> i, question <span class="keyword">in</span> <span class="built_in">enumerate</span>(questions):</span><br><span class="line">    test_cases.append(LLMTestCase(</span><br><span class="line">        <span class="built_in">input</span>=question,</span><br><span class="line">        actual_output=answers[i],</span><br><span class="line">        retrieval_context=contexts[i],</span><br><span class="line">        expected_output=ground_truths[i],</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">evaluation_metrics = [</span><br><span class="line">    FaithfulnessMetric(threshold=<span class="number">0.7</span>),</span><br><span class="line">    AnswerRelevancyMetric(threshold=<span class="number">0.8</span>),</span><br><span class="line">    ContextualPrecisionMetric(threshold=<span class="number">0.7</span>),</span><br><span class="line">    ContextualRecallMetric(threshold=<span class="number">0.9</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">results = deepeval.evaluate(</span><br><span class="line">    test_cases=test_cases,</span><br><span class="line">    metrics=evaluation_metrics</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, result <span class="keyword">in</span> <span class="built_in">enumerate</span>(results.test_results):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;--- TestCase <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Query: <span class="subst">&#123;result.<span class="built_in">input</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result.success:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;✅ Overall Result: Passed\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;❌ Overall Result: Failed\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印每个指标的详细得分和原因</span></span><br><span class="line">    <span class="keyword">for</span> metric_result <span class="keyword">in</span> result.metrics_data:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  📊 Metric: <span class="subst">&#123;metric_result.__class__.__name__&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;     - Score: <span class="subst">&#123;metric_result.score:<span class="number">.2</span>f&#125;</span> (Threshold: <span class="subst">&#123;metric_result.threshold&#125;</span>)&quot;</span>)</span><br><span class="line">        reason = <span class="built_in">getattr</span>(metric_result, <span class="string">&#x27;reason&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;     - Reason: <span class="subst">&#123;reason&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">25</span> + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>结合单元测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> deepeval <span class="keyword">import</span> assert_test</span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;test_case&quot;</span>, test_cases</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regualation_rag_eval</span>(<span class="params">test_case: LLMTestCase</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Testing Input: <span class="subst">&#123;test_case.<span class="built_in">input</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    assert_test(</span><br><span class="line">        test_case=test_case,</span><br><span class="line">        metrics=[</span><br><span class="line">            FaithfulnessMetric(threshold=<span class="number">0.7</span>),</span><br><span class="line">            AnswerRelevancyMetric(threshold=<span class="number">0.8</span>),</span><br><span class="line">            ContextualPrecisionMetric(threshold=<span class="number">0.7</span>),</span><br><span class="line">            ContextualRecallMetric(threshold=<span class="number">0.9</span>)</span><br><span class="line">        ]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--- TestCase 1 ---</span><br><span class="line">Query: 伙食补助费标准是什么?</span><br><span class="line">✅ Overall Result: Passed</span><br><span class="line"></span><br><span class="line">  📊 Metric: MetricData</span><br><span class="line">     - Score: 1.00 (Threshold: 0.7)</span><br><span class="line">     - Reason: The score is 1.00 because there are no contradictions, indicating a perfect alignment between the actual output and the retrieval context. Great job maintaining accuracy and consistency!</span><br><span class="line">  📊 Metric: MetricData</span><br><span class="line">     - Score: 1.00 (Threshold: 0.8)</span><br><span class="line">     - Reason: The score is 1.00 because the response perfectly addresses the question about the standard for meal allowances without any irrelevant information. Great job!</span><br><span class="line">  📊 Metric: MetricData</span><br><span class="line">     - Score: 1.00 (Threshold: 0.7)</span><br><span class="line">     - Reason: The score is 1.00 because the relevant nodes in the retrieval contexts are perfectly ranked above the irrelevant node. The first node provides a clear table with the &#x27;伙食补助费标准&#x27; for different regions, directly answering the input question. The second node further explains the concept and provides the same standards, reinforcing the relevance. The third node, which discusses hotel recommendations and accommodation fees, is unrelated and correctly ranked last.</span><br><span class="line">  📊 Metric: MetricData</span><br><span class="line">     - Score: 1.00 (Threshold: 0.9)</span><br><span class="line">     - Reason: The score is 1.00 because the expected output perfectly aligns with the information in the nodes in the retrieval context, showcasing a flawless match. Great job!</span><br></pre></td></tr></table></figure><h1 id="graph-rag">10. Graph RAG</h1><h2 id="图数据库">10.1 图数据库</h2><h3 id="neo4j">10.1.1 neo4j</h3><p><a href="https://github.com/neo4j/neo4j">neo4j</a> 使用的是语言是 <ahref="https://neo4j.com/docs/getting-started/cypher/">cypher</a>。Cypher的核心是 <code>MATCH</code>（模式匹配） +<code>RETURN</code>（结果返回），辅以<code>CREATE</code>/<code>MERGE</code>（数据操作）、<code>WHERE</code>（过滤）、<code>WITH</code>（管道传递）。</p><p><strong>1. 节点与关系语法</strong></p><ul><li><strong>节点</strong>：用圆括号 <code>()</code>表示，可包含变量、标签和属性。<ul><li><code>()</code>：匿名节点</li><li><code>(p:Person)</code>：变量 <code>p</code> + 标签<code>Person</code></li><li><code>(p:Person &#123;name: 'Alice', age: 30&#125;)</code>：带属性的节点。</li></ul></li><li><strong>关系</strong>：用方括号 <code>[]</code>表示，放在两个短横线中间（<code>--</code>），方向用箭头（<code>→</code>或 <code>←</code>）指定。<ul><li><code>-[:KNOWS]-</code>：无变量、类型为 <code>KNOWS</code>的无向关系</li><li><code>-[r:ACTED_IN &#123;roles: ['Neo']&#125;]-→</code>：变量 <code>r</code> +类型 <code>ACTED_IN</code> + 属性</li></ul></li></ul><p><strong>2. 模式匹配（MATCH）</strong></p><p>核心是通过路径模式描述图结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[r:ACTED_IN]-&gt;(m:Movie &#123;title: &#x27;The Matrix&#x27;&#125;)</span><br><span class="line">RETURN p, r.roles</span><br></pre></td></tr></table></figure><ul><li>可选匹配：<code>OPTIONAL MATCH</code> 处理可能不存在的关系。</li></ul><p><strong>3. 数据操作语句</strong></p><ul><li><p>创建：</p><ul><li><code>CREATE (p:Person &#123;name: 'Alice'&#125;)</code>：创建节点。</li><li><code>CREATE (a)-[:FRIEND]-&gt;(b)</code>：创建关系（需先匹配<code>a</code>, <code>b</code>）</li></ul></li><li><p>更新：<code>SET</code> 修改属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person) SET p.age = 31</span><br></pre></td></tr></table></figure></li><li><p>合并：<code>MERGE</code> 存在则匹配，不存在则创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MERGE (p:Person &#123;name: &#x27;Alice&#x27;&#125;)</span><br><span class="line">ON CREATE SET p.created_at = timestamp()</span><br></pre></td></tr></table></figure></li><li><p>删除：</p><ul><li><code>DELETE n</code>：删除节点（需先断开关系）</li><li><code>DETACH DELETE n</code>：删除节点及关联关系</li></ul></li></ul><p><strong>4. 查询控制条件</strong></p><ul><li><p>过滤：<code>WHERE</code> 条件筛选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person) WHERE p.age &gt; 30 OR p.name STARTS WITH &#x27;A&#x27;</span><br></pre></td></tr></table></figure></li><li><p>返回：<code>RETURN</code> 指定输出</p></li><li><p>连接查询：<code>WITH</code> 传递中间结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p)-[:FRIEND]-&gt;(f)</span><br><span class="line">WITH p, count(f) AS friendCount</span><br><span class="line">WHERE friendCount &gt; 10</span><br><span class="line">RETURN p.name</span><br></pre></td></tr></table></figure></li><li><p>聚合与排序：</p><ul><li><code>COUNT()</code>, <code>COLLECT()</code>：聚合函数</li><li><code>ORDER BY p.age DESC LIMIT 10</code>：排序和分页</li></ul></li></ul><p><strong>5. 索引与约束</strong></p><ul><li><p>索引：加速节点查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX FOR (p:Person) ON (p.name)</span><br></pre></td></tr></table></figure></li><li><p>约束：确保数据唯一性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE CONSTRAINT ON (m:Movie) ASSERT m.title IS UNIQUE</span><br></pre></td></tr></table></figure></li></ul><h3 id="nebula-graph">10.1.2 nebula graph</h3><p><a href="https://github.com/vesoft-inc/nebula">nebula graph</a>使用的语言是 <ahref="https://docs.nebula-graph.io/3.8.0/3.ngql-guide/1.nGQL-overview/1.overview/">nGQL</a>。</p><h2 id="典型流程">10.2 典型流程</h2><ol type="1"><li>将问题提交给 LLM，让其提取（总结）关键词；</li><li>通过关键词来地毯式查询节点，尝试命中图数据库中定义的节点；</li><li>如果有命中的，则通过节点来查询关联的关系和节点信息；</li><li>将查询到的信息组织上上下文提交给 LLM，解答最初的问题。</li></ol><h2 id="实战案例">10.3 实战案例</h2><ul><li><ahref="https://github.com/hedon-py-road/learn-neo4j/blob/main/neo4j.ipynb">learn-neo4j</a></li><li><ahref="https://github.com/hedon-ai-road/ftt_rag/blob/main/graph-rag.ipynb">ftt_graph_rag</a></li></ul><h1 id="react-rag">11. ReAct RAG</h1><p>ReAct = Reasoning + Acting = 推理 + 行动</p><ul><li>核心理念：让大型语言模型像人一样，在解决复杂问题时，能够先思考分析（推理），然后根据思考结果采取行动（行动），再观察行动结果，接着进行新一轮的思考，如此循环，直到问题解决。</li><li>核心流程：<ul><li>思考（Thought）</li><li>行动（Action）</li><li>观察（Observation）</li><li>思考（Thought）</li><li>...</li><li>最终答案（Final Answer）</li></ul></li></ul><h2 id="prompt">11.1 Prompt</h2><p><strong>1. 明确的规则制定（Rule Formulation）</strong></p><ol type="1"><li>循环结构：强制模型遵循 "Thought -&gt; Action -&gt; Observation"的循环。</li><li>输出格式：严格规定每一个环节的输出格式，便于程序解析。</li><li>终止条件：明确告诉模型何时任务算完成，以及如何提交最终答</li></ol><p><strong>2. 精确的工具授权（Tool Granting）</strong></p><ol type="1"><li>功能单一：每个工具最好只做一件事，这让模型更容易选择。</li><li>描述清晰：工具的描述 (description)是模型决定使用哪个工具的唯一依据。描述要用自然语言写得清晰、准确，说明白“这个工具能干什么”。</li><li>参数明确：工具的输入参数 (parameters)必须定义清楚，包括名称、类型和用途。</li><li>有了 MCP 后，这一步可以用 MCP 来替代。</li></ol><p><strong>3. 高质量的示例引导（Example Guidance）</strong></p><ol type="1"><li>展示思维链：清晰地展示从问题到第一个思考，再到行动的逻辑。</li><li>覆盖典型场景：展示如何使用不同的工具，甚至是如何组合使用工具。</li><li>处理异常情况：最好能包含一个处理错误的示例(比如搜索不到结果时该怎么办)，这能极大地提升模型的鲁棒性。</li></ol><p>Prompt 示例骨架：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">You are an expert assistant capable of solving complex problems by breaking them down into a sequence of thought and action. You must strictly follow the format of &quot;Thought, Action, Observation&quot; to solve the problem.</span><br><span class="line"></span><br><span class="line">You have access to the following tools:</span><br><span class="line"></span><br><span class="line">[tool<span class="emphasis">_definitions]</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Use the following format:</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Question: The user&#x27;s question you need to answer.</span></span><br><span class="line"><span class="emphasis">Thought: Your internal reasoning and plan for the next action.</span></span><br><span class="line"><span class="emphasis">Action: The tool you will use. It must be one of [list_</span>of<span class="emphasis">_tool_</span>names].</span><br><span class="line">Observation: The result returned by the action.</span><br><span class="line">... (this Thought/Action/Observation cycle can repeat N times)</span><br><span class="line">Thought: I now have the final answer.</span><br><span class="line">Action: finish(the final answer)</span><br></pre></td></tr></table></figure><p>Few Shot 示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Question: 苹果公司的现任 CEO 是谁？他的前任是谁？</span><br><span class="line"></span><br><span class="line">Thought: 我需要分两步解决这个问题。第一，找出苹果的现任 CEO。第二，找出他的前任。我先执行第一步。</span><br><span class="line">Action: search(&quot;苹果公司现任 CEO&quot;)</span><br><span class="line">Observation: 苹果公司现任 CEO 是蒂姆·库克 (Tim Cook)。</span><br><span class="line"></span><br><span class="line">Thought: 我已经知道了现任 CEO 是蒂姆·库克。现在我需要找出他的前任是谁。</span><br><span class="line">Action: search(&quot;蒂姆·库克的前任是谁&quot;)</span><br><span class="line">Observation: 蒂姆·库克的前任是苹果公司的创始人史蒂夫·乔布斯 (Steve Jobs)。</span><br><span class="line"></span><br><span class="line">Thought: 我已经获得了所有需要的信息：现任 CEO 是蒂姆·库克，前任是史蒂夫·乔布斯。我可以给出最终答案了。</span><br><span class="line">Action: finish(&quot;苹果公司的现任 CEO 是蒂姆·库克，他的前任是史蒂夫·乔布斯。&quot;)</span><br></pre></td></tr></table></figure><h2 id="实战案例-1">11.2 实战案例</h2><ul><li><ahref="https://github.com/hedon-ai-road/react_rag">react-rag</a></li></ul><h1 id="rag-相关思考">12. RAG 相关思考</h1><ul><li><ahref="https://www.woshipm.com/ai/6235363.html">企业大模型落地的现实解法：为什么RAG 是绕不开的技术路径？</a></li><li><ahref="https://blog.csdn.net/2401_84495872/article/details/148831083">不需要RAG！手把手教你构建问答 Agent</a></li></ul>]]></content>
    
    
    <summary type="html">RAG 全栈技术</summary>
    
    
    
    <category term="AI" scheme="https://hedon.top/categories/AI/"/>
    
    <category term="RAG" scheme="https://hedon.top/categories/AI/RAG/"/>
    
    
    <category term="AI" scheme="https://hedon.top/tags/AI/"/>
    
    <category term="RAG" scheme="https://hedon.top/tags/RAG/"/>
    
  </entry>
  
  <entry>
    <title>FOSA丨03丨模块化</title>
    <link href="https://hedon.top/2025/07/02/fosa/fosa-ch3/"/>
    <id>https://hedon.top/2025/07/02/fosa/fosa-ch3/</id>
    <published>2025-07-02T03:00:26.000Z</published>
    <updated>2025-07-27T04:29:14.328Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章通过逐章回答<ahref="https://fundamentalsofsoftwarearchitecture.com/">《Fundamentals ofSoftware Architecture》</a>（下文简称FOSA）一书中的课后思考题，来深入理解书中的核心概念和理论，从而提升我们的软件架构设计能力。本篇为<u>第三章</u>内容。</p><p>本章的课后题是：</p><ol type="1"><li><p>What is meant by the term <em>connascence</em>?</p><p>"连接性"这个术语是什么意思？</p></li><li><p>What is the difference between static and dynamicconnascence?</p><p>静态连接性和动态连接性有什么区别？</p></li><li><p>What does <em>connascence of type</em> mean? Is it static ordynamic connascence?</p><p>类型连接性是什么意思？它是静态的还是动态的？</p></li><li><p>What is the strongest form of connascence?</p><p>连接性最强的形式是什么？</p></li><li><p>What is the weakest form of connascence?</p><p>连接性最弱的形式是什么？</p></li><li><p>Which is preferred within a code base—static or dynamicconnascence?</p><p>在一个代码库中，静态连接性和动态连接性哪个更受青睐？</p></li></ol><hr /><p>本篇的主题是Modularity（模块化），谈到模块化，我们最常提到的一句话就是："高内聚（cohesion）、低耦合（coupling）"。</p><ul><li>内聚是指模块内部各元素之间关联的紧密程度。高内聚意味着模块中的所有元素都紧密相关，并且共同为一个单一的、明确定义的目的服务。高内聚使模块的功能职责更加集中和明确，易于理解和修改。</li><li>耦合是指不同模块之间相互依赖的程度。低耦合意味着模块之间的依赖关系很弱，一个模块的改变对其他模块的影响尽可能小。低耦合降低了系统修改、测试和部署的风险。当系统的一个部分发生变化时，由于依赖关系较少，需要修改的其他部分也较少。</li></ul><p>课后题中提到的 connascence（连接性）跟耦合的概念很像。</p><blockquote><p>当一个组件的修改需要修改另外一个组件才能保持系统整体的正确性时，这两个组件就处于连接性状态。它衡量了软件组件之间相互依赖的程度。</p><p>连接性是对耦合度量的一种细化。虽然传统的耦合度量（如内向耦合和外向耦合）关注的是连接的方向，但连接性更进一步，关心组件之间如何耦合在一起。</p></blockquote><p>连接性可以分为 2 大类：</p><ul><li>静态连接性：指的是源代码级别的耦合，它可以通过简单的源代码分析来确定。<ul><li>命名连接性：多个组件必须就某个实体的名称达成一致。这是最弱的连接性形式，也是代码库中最理想的耦合方式，因为现代重构工具可以轻松实现系统范围内的名称更改。</li><li>类型连接性：多个组件必须就某个实体的类型达成一致。这在许多静态类型语言中很常见，例如变量和参数被限制为特定类型。</li><li>意义连接性 /约定连接性：多个组件必须就某个值的含义或约定达成一致。</li><li>位置连接性：多个组件必须就某个实体在列表、记录或参数中的位置达成一致。</li><li>算法连接性：多个组件必须就某个特定算法达成一致。</li><li>执行连接性：多个组件必须就某个执行顺序或流程达成一致。</li></ul></li><li>动态连接性：指的是运行时的调用，这种很难确定，因为缺乏有效的运行时分析工具。<ul><li>执行连接性：不同语句的执行顺序很重要。例如一段代码中某些属性必须按特定顺序设置才能正确运行。</li><li>时序连接性：多个组件的执行时序很重要。通常发生在竞态条件中，即两个线程同时执行并影响联合操作的结果</li><li>值连接性：多个值之间相互关联，必须一起改变。</li><li>身份连接性：多个组件必须引用同一个实体。例如，两个独立的组件必须共享和更新一个公共数据结构。</li></ul></li></ul><p>连接性的强弱如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20250702130438266.png"alt="FOSA Figure 3-5. The strength on connascence provides a good refactoring guide" /><figcaption aria-hidden="true">FOSA Figure 3-5. The strength onconnascence provides a good refactoring guide</figcaption></figure><p>越往左上角，表示连接性越弱，也是我们编写代码时更希望看到的。</p><p>Page-Jones 提出了 3 个使用连接性来改善系统模块化的指导原则：</p><ol type="1"><li>通过将系统分解为封装的元素来最小化整体连接性；</li><li>最小化任何剩余的跨越封装边界的连接性；</li><li>最大化封装边界内的连接性。</li></ol><p>Jim Weirich 进一步给出了 2 条建议：</p><ol type="1"><li><strong>程度规则（Rule ofDegree）</strong>：将强形式的连接性转换为弱形式的连接性。例如，可以通过重构将意义连接性（CoM）转换为命名连接性（CoN），即创建命名常量而不是使用"魔法值"。</li><li><strong>局部性规则（Rule ofLocality）</strong>：随着软件元素之间距离的增加，使用弱形式的连接性。这意味着，如果组件彼此远离，则它们之间的耦合应尽可能松散，避免强连接性形式。</li></ol>]]></content>
    
    
    <summary type="html">本篇通过回答《Fundamentals of Software Architecture》第三章的课后思考题，深入探讨模块化设计的核心概念——连接性（connascence），分析静态与动态连接性的区别、不同连接性形式的强弱程度，以及如何在代码库中合理选择连接性类型，帮助理解高内聚低耦合的实现原理和最佳实践。</summary>
    
    
    
    <category term="架构设计" scheme="https://hedon.top/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="读书笔记" scheme="https://hedon.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="fosa" scheme="https://hedon.top/tags/fosa/"/>
    
    <category term="软件架构" scheme="https://hedon.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
