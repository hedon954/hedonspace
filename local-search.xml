<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rust 入门丨01 类型系统概述</title>
    <link href="/2024/11/28/rust-01-type-system/"/>
    <url>/2024/11/28/rust-01-type-system/</url>
    
    <content type="html"><![CDATA[<p>在 Rust 编程世界中，绝大部分的特性和能力都离不开 Rust强大的类型系统，所以在这个系列的第 1 篇我们先来对 Rust的类型系统做一个全局概述，希望可以帮助你建立起对 Rust的基本印象。在后续的实践过程中，我推荐你可以经常回来思考下为什么 Rust要构建这样的类型系统，在每一个分支点是如何做出决策的，这些决策又体现在代码的哪些地方。相信这样可以帮助你更好地入门Rust。</p><p>废话不多说，进入正文。</p><h1 id="什么是类型系统">什么是类型系统？</h1><p>在进入 Rust类型系统讨论之前，我们先尝试占在更高的角度，即整个编程语言界的角度去思考，<font color="red">什么是类型系统？</font></p><blockquote><p>编程语言的类型系统是指一套规则，用于定义和管理程序中数据的类型。类型系统的主要目的是帮助捕获程序中的错误，提高代码的可靠性和可读性。</p></blockquote><p>类型系统可以根据多种特性进行分类，主要包括以下几个方面：</p><ol type="1"><li><strong>静态类型和动态类型</strong>：<ul><li><strong>静态类型</strong>：在编译时检查变量类型。例如，Java、C++ 和Haskell都是静态类型语言。在这些语言中，变量的类型必须在编译时确定，这样可以在编译阶段捕获许多类型错误。</li><li><strong>动态类型</strong>：在运行时检查变量类型。例如，Python、Ruby和 JavaScript是动态类型语言。在这些语言中，变量的类型是在程序运行时确定的，这提供了更大的灵活性，但也可能导致运行时错误。</li></ul></li><li><strong>强类型和弱类型</strong>：<ul><li><strong>强类型</strong>：严格限制不同类型之间的操作。例如，Python 和Java是强类型语言。强类型系统通常不允许隐式类型转换，这意味着在进行不同类型之间的操作时，必须显式地进行类型转换。</li><li><strong>弱类型</strong>：允许更多隐式类型转换。例如，JavaScript 和Perl是弱类型语言。在这些语言中，编译器或解释器会在需要时自动进行类型转换，这可能导致难以预料的行为。</li></ul></li><li><strong>显式类型和隐式类型</strong>：<ul><li><strong>显式类型</strong>：程序员必须明确声明每个变量的类型。例如，Java和 C++ 要求在声明变量时指定其类型。</li><li><strong>隐式类型</strong>：编译器或解释器会根据上下文自动推断变量的类型。例如，Python和 JavaScript 使用隐式类型，程序员不需要显式声明变量类型。</li></ul></li><li><strong>子类型和多态</strong>：<ul><li><strong>子类型</strong>：一种类型系统允许一种类型作为另一种类型的子集。例如，在面向对象编程中，子类是父类的子类型。</li><li><strong>多态</strong>：允许一个接口被多种不同类型实现。多态性有多种形式，包括参数多态（如泛型）和子类型多态（如继承）。</li></ul></li><li><strong>类型推断</strong>：<ul><li>类型推断是指编译器自动确定表达式的类型，而无需明确的类型注释。例如，Haskell和 Scala 使用类型推断来减少程序员的负担，同时保持静态类型的安全性。</li></ul></li><li><strong>代数数据类型和类型构造</strong>：<ul><li>代数数据类型（ADT）是通过组合其他类型来构造新类型的机制，常见于函数式编程语言，如Haskell 和 OCaml。ADT 包括产品类型（如元组）和和类型（如枚举）。</li></ul></li><li><strong>结构类型和名义类型</strong>：<ul><li><strong>结构类型</strong>：基于对象的结构来确定类型的兼容性。例如，TypeScript和 Go 使用结构类型系统。</li><li><strong>名义类型</strong>：基于名称来确定类型的兼容性。例如，Java 和C++ 使用名义类型系统。</li></ul></li></ol><p>这里我梳理了一张图，供你参考：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241128183852984.png"alt="编程语言类型系统" /><figcaption aria-hidden="true">编程语言类型系统</figcaption></figure><blockquote><p>注：本图参考了陈天老师在 Rust训练营课程上提供的教案并进行了增改。</p></blockquote><h1 id="rust-类型系统">Rust 类型系统</h1><p>Rust为了在提供高性能的同时保证内存安全和线程安全，花了大量力气构建了一个强大的类型系统。</p><p>基于之前提到的七个方面，我们来梳理下 Rust 的类型系统：</p><ol type="1"><li><p><strong>静态类型</strong>：Rust是静态类型语言，这意味着变量的类型在编译时就被确定。这种设计使得 Rust在编译阶段就可以捕获许多类型错误，从而提高代码的安全性和性能。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>; <span class="hljs-comment">// 明确指定类型</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>强类型</strong>：Rust是强类型语言，它严格限制不同类型之间的操作。Rust不允许隐式类型转换（例如，不能自动将整数转换为浮点数），需要显式地使用as 进行类型转换。这种严格性有助于避免许多常见的编程错误。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: <span class="hljs-type">f64</span> = <span class="hljs-number">10.0</span>;<br><br>    <span class="hljs-comment">// 错误：不能将 i32 隐式转换为 f64</span><br>    <span class="hljs-comment">// let sum = x + y;</span><br><br>    <span class="hljs-comment">// 正确：需要显式转换</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = x <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> + y;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Sum = &#123;&#125;&quot;</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>显式类型和类型推断</strong>：虽然 Rust是显式类型语言，要求在某些情况下声明变量类型，但它也具有强大的类型推断能力。编译器可以根据上下文推断出大多数变量的类型，减少了程序员的负担。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[];<br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">5u8</span>);  <span class="hljs-comment">// 结合这里，Rust 编译器可以推断出 v 的类型是 Vec&lt;u8&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>子类型和多态</strong>：Rust 支持泛型和trait，这是一种多态性的实现方式。trait类似于接口，允许定义类型可以实现的一组方法。泛型允许定义函数、结构体和枚举时使用占位类型，从而实现代码的重用和灵活性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 这里 std::fmt::Display 就是一个 trait，目前，你可以先简单理解为 trait 就是接口</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_value</span>&lt;T: std::fmt::Display&gt;(value: T) &#123;  <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, value);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">print_value</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 42 默认为 i32，标准库为其是实现了 Display trait</span><br>    <span class="hljs-title function_ invoke__">print_value</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>); <span class="hljs-comment">// &amp;str 也实现了 Display trait</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>类型推断</strong>：Rust的类型推断系统非常强大，能够根据代码上下文自动推断变量和表达式的类型。这使得代码更简洁，同时保持了类型安全性。</p></li><li><p><strong>代数数据类型和类型构造</strong>：Rust支持代数数据类型，通过枚举（enum）和结构体（struct）来实现。枚举允许定义一个类型，该类型可以是几种不同的变体之一，每个变体可以携带不同的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>结构类型和名义类型</strong>：Rust使用名义类型系统。每个类型都有一个显式的名称，类型的兼容性基于名称而不是结构。这意味着即使两个结构体有相同的字段，它们也被视为不同的类型，除非通过特征或显式转换来实现兼容性。</p></li></ol><p>除此之外，Rust的类型系统还提供了其他非常强大且有用的特效，如所有权和借用、生命周期以及模式匹配。</p><ul><li><p><strong>所有权和借用（Ownership and Borrowing）</strong>：</p><ul><li>Rust的类型系统与其所有权模型紧密结合。所有权模型通过所有权、借用和生命周期的概念来管理内存，从而在无垃圾回收器的情况下确保内存安全。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;s); <span class="hljs-comment">// 借用</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>生命周期（Lifetimes）</strong>：</p><ul><li>Rust使用生命周期标注来跟踪引用的有效范围，确保引用在使用时始终有效。这是Rust 类型系统中一个独特的特性，帮助防止悬空引用和数据竞争。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;long string is long&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-string">&quot;xyz&quot;</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(), string2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The longest string is &#x27;&#123;&#125;&#x27;&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>模式匹配</strong>：</p><ul><li>Rust提供强大的模式匹配功能，尤其是在处理枚举和复杂数据结构时，使得代码更具表达力和安全性。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Quit,<br>    Move &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;,<br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">process_message</span>(msg: Message) &#123;<br>    <span class="hljs-keyword">match</span> msg &#123;<br>        Message::Quit =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Quit the application&quot;</span>);<br>        &#125;<br>        Message::Move &#123; x, y &#125; =&gt; &#123;  <span class="hljs-comment">// 模式匹配能根据数据类型直接拆解出来，使用起来非常方便</span><br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Move to coordinates: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);<br>        &#125;<br>        Message::<span class="hljs-title function_ invoke__">Write</span>(text) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Text message: &#123;&#125;&quot;</span>, text);<br>        &#125;<br>        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Change color to RGB(&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;</span>, r, g, b);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>Rust的类型系统通过上述特性实现了高效、安全和灵活的编程模型，适合系统编程和高性能应用。它在编译期捕获许多潜在错误，使得运行时更为安全可靠。</p><p>当然，如果你之前没有学习过Rust，那这些概念和代码对你来说大概率是云里雾里，不要着急，我们先建立起一个大概的印象就行了。这里我针对Rust 类型系统梳理了一张图，你可以在以后的学习中时常回来看看：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241128185615522.png"alt="Rust 类型系统" /><figcaption aria-hidden="true">Rust 类型系统</figcaption></figure><blockquote><p>注：本图参考了陈天老师在 Rust训练营课程上提供的教案并进行了增改。</p></blockquote><p>本篇就到这里，下篇我们将介绍 Rust 的数据类型，enjoy coding~</p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 入门丨02 数据类型</title>
    <link href="/2024/11/28/rust-02-data-type/"/>
    <url>/2024/11/28/rust-02-data-type/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 训练营总结丨第三次入门 Rust</title>
    <link href="/2024/11/26/rust-bootcamp/"/>
    <url>/2024/11/26/rust-bootcamp/</url>
    
    <content type="html"><![CDATA[<h1 id="缘起">缘起</h1><p>2023年我给自己定了很多个目标，最终的结果是每个都做了一些事情，但是没有一个是做得比较彻底的，印证了《孙子兵法》的那句：“无所不备，则无所不寡”。</p><p>在 2023.10.23 出于好奇，我订阅了《Rust语言从入门到实战》的专栏，跟着课程的更新节奏学习完了整个专栏。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Rust%E8%AF%AD%E8%A8%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E7%BB%93%E8%AF%BE%E8%AF%81%E4%B9%A6.png" alt="Rust语言从入门到实战结课证书" style="zoom:33%;" /></p><p>虽然我第一次入门 Rust 失败了，但也被 Rust的种种特性所吸引。我是个特别喜欢“痛苦前置”的人，而 Rust编译器"睚眦必报"的编译器检查正给予了我被虐的爽感，编译通过后程序的稳定运行也符合我追求成为一位“靠谱”工程师的愿景。</p><p>加之我的主力语言是Go，一门应用编程语言，所以我一直希望学习一门系统编程语言，以期将来有能力窥探一些底层的细节原理。C/C++太古老了，特性太多了，大神太多了，我怎么学都不可能赶得上别人，嘿嘿，学个新的，大家都没学过，这不就舒服了么。</p><p>后来极客时间决定开设《Rust 训练营》，讲师是<ahref="https://www.zhihu.com/people/tchen">陈天</a>老师，我去搜了关于陈天老师的一些资料，看了一些他写的文章和技术分享视频，甚至油管上还有他之前面试的视频。OK，这个人得到了我的认可，我想跟这样的人交个朋友，哪怕只是加个微信，至少我多了个口子，得以窥探精英阶层人士的生活一角。</p><p>结合 2023 年的教训，2024年年初我就给自己制定了一年的目标，只有一个，就是<strong>踏踏实实、完完整整学习完整个Rust 训练营，其他所有事情和目标，都要为其让步</strong>。</p><blockquote><p>其实是 2 个目标 hhh，另外一个目标是：完成人生的第一场半程马拉松。</p></blockquote><h1 id="筑基">筑基</h1><p>为了更好服务于《Rust 训练营》，在 1-4 月份，我花了差不多 3个多月的时间啃下了<ahref="https://book.douban.com/subject/36547630/">《Rust程序设计（第二版）》</a>，对整个 Rust的语言特性建立了更加完善的体系基础，也多奠定了一些基础，当然，这是我第二次入门Rust 失败。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241127172804063.png" alt="Rust 程序设计（第二版）阅读计划" style="zoom: 25%;" /></p><h1 id="修炼">修炼</h1><p>4 月 18 号开营，本来是预计 7月份结营的，不过陈天老师分享的欲望刹不住车，硬是“拖堂”到了 11 月 22号。事实上，这是有点难受的，一个事情拖太久，思维上很容易疲惫，懒惰也愈难克服。不过从消费者的角度，这是赚翻了，毕竟，学着学着，花呗的12 期无息分期也差不多要还完了。</p><p>所以，其实一个 1095 的程序员，在 4.20 到 11.22 是可以花 279 小时 54分钟学完 202 讲课程的。</p><blockquote><p>即使你将来不使用Rust，相信你学完这门课程后也能成为一位更好的软件工程师。 —— 陈天</p></blockquote><p>是的，在学习中，更多时候感受到的不仅仅是在学习Rust，而是在重学软件工程，我开始切身接触优秀的软件开发具备了哪些不可或缺的流程。为了效仿这些优秀的思想和实践，在实际工作中，今年我做了一些尝试：</p><ol type="1"><li>引入更丰富的 CI/CD流程，尽可能发挥机器的能力，让机器不厌其烦地做那些的重复劳动，而这些不起眼的重复劳动，却能以最小代码为我们排查出最多难以发现的“失误”BUG。</li><li>开始学习写单测，开始学习如何将代码写得能单测、易单测，学习着如何将那些不能单测的💩代码改造成可单测的代码，也将单测运行加入了CI/CD的流程中。在单测多次帮我揪出那些我意识不到的不小心改错的逻辑的时候，我才切身感受到单测的作用，也真正理解了“写单测并不会影响开发效率，如果影响了，那也是提高了开发效率”。幸运的是，截至目前（11.27），我已经连续2 次，在上千行代码的需求开发中，提测阶段和线上发布阶段，都是 0Bug，运气不错。</li><li>引入监控系统，在指标上，存储层、应用层、业务层和网关层进行分层监控，在开发时，从业务无关组件（<ahref="https://github.com/hedon954/goapm">goapm</a>），到业务相关通用组件，最后再到应用程序特定组件的分阶段分层次开发，开始学习着“先解决业务背后的领域问题，顺带解决业务问题”。</li><li>开始思考一些架构层面的东西，开始思考一些代码组织、接口契约、领域模块划分的问题，以期写出质量更好的代码。</li></ol><p>为了支撑上面这些事情，今年我又顺带读了一些书，我是个很少读书的人，因为我总觉得：“读书好慢”。而且我读书也确实很慢，主要是，很困😅。然而，当我回望来时路，一切却都在我的意料之外。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241127180300408.png"alt="hedon 2024 的书单" /><figcaption aria-hidden="true">hedon 2024 的书单</figcaption></figure><p>这个时候我才知道：</p><ul><li>慢就是快</li><li>少就是多</li></ul><h1 id="历劫">历劫</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241127161520649.png"alt="rust-road" /><figcaption aria-hidden="true">rust-road</figcaption></figure><p>这些书其实都不在我的计划之内，因为 2024 我只有一个目标：<strong>完成Rust训练营的学习</strong>。它们只不过是我完成既定计划之余的加餐罢了。</p><p>而幸好我只有一个目标，所以才能有更多时间和精力去应对跟随训练营学习中的一些困难：</p><ul><li>晚上 9 点下班，真累啊，休息下吧，真不想学了。</li><li>工作了一周，真累啊，周末要不就休息吧，真不想学了。</li><li>编译器报错好多啊，算了，要不直接 copy 现成的代码吧。</li><li>这知识点在讲啥啊，算了，先不懂装懂吧，后面还那么多课，先赶进度再说。</li><li>前端和客户端的知识，好像跟我没啥关系，算了，不听了，过过过。</li><li>单测我就不写了，浪费时间。</li><li>学完咯，感觉没啥好总结的，算了，下一个吧。</li><li>....</li></ul><p>运气不错，上述的 n 多种情况，至少在 50-70% 的时候，我能做到：</p><ul><li>学一下再说，累了再停。</li><li>下午出去玩，早上先学了再说。</li><li>算了，狠点，盲写，自己尝试解决一下，咦，也就那么回事。写完后再对比下，哦，其实这块没听懂。</li><li>弄懂再说，多听几遍课，重新看几遍书，再搜一些相关博客，哦，这个知识点是这个意思，读书百遍其义自见原来是这味？</li><li>算了，试试现在 LLM 是否如吹的那么牛，嗯，好像用 LLM来实现前端和客户端的基础功能还真可以，也没那么无聊嘛。</li><li>算了，先试着写下单测吧。哦，我的代码这么难测啊，哦，这行代码怎么就犯蠢了呢，哦，花不了多少时间嘛。</li><li>要不还是总结下吧，哦，原来这个地方是这个意思，哦，原来还讲到了这个点。</li></ul><p>所以这个时候我又知道了：</p><ul><li>慢就是快</li><li>少就是多</li></ul><h1 id="小成">小成</h1><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs tap">➜  hedon-rust-road ll<br>total 0<br>drwxr-xr-x <span class="hljs-number"> 21 </span>wangjiahan  staff   672B Nov<span class="hljs-number"> 27 </span>18:26 aicomm<br>drwxr-xr-x <span class="hljs-number"> 23 </span>wangjiahan  staff   736B Sep<span class="hljs-number"> 11 </span>13:55 chat<br>drwxr-xr-x <span class="hljs-number"> 17 </span>wangjiahan  staff   544B Sep<span class="hljs-number"> 11 </span>18:31 chatapp<br>drwxr-xr-x <span class="hljs-number"> 26 </span>wangjiahan  staff   832B Nov<span class="hljs-number"> 27 </span>18:26 crm<br>drwxr-xr-x <span class="hljs-number"> 22 </span>wangjiahan  staff   704B Nov<span class="hljs-number"> 27 </span>18:26 dino<br>drwxr-xr-x <span class="hljs-number"> 16 </span>wangjiahan  staff   512B Nov<span class="hljs-number"> 27 </span>18:29 error-info<br>drwxr-xr-x <span class="hljs-number"> 18 </span>wangjiahan  staff   576B Sep <span class="hljs-number"> 4 </span>19:00 hackernews<br>drwxr-xr-x <span class="hljs-number"> 22 </span>wangjiahan  staff   704B Sep<span class="hljs-number"> 12 </span>15:54 hedon-bot<br>drwxr-xr-x  <span class="hljs-number"> 9 </span>wangjiahan  staff   288B Nov<span class="hljs-number"> 27 </span>18:29 httpie<br>drwxr-xr-x <span class="hljs-number"> 13 </span>wangjiahan  staff   416B Aug<span class="hljs-number"> 22 </span>10:40 inverted-index-concurrency<br>drwxr-xr-x  <span class="hljs-number"> 7 </span>wangjiahan  staff   224B Nov<span class="hljs-number"> 27 </span>18:28 json-macro<br>drwxr-xr-x <span class="hljs-number"> 26 </span>wangjiahan  staff   832B Sep <span class="hljs-number"> 3 </span>19:30 learn-ffi<br>drwxr-xr-x  <span class="hljs-number"> 8 </span>wangjiahan  staff   256B Nov<span class="hljs-number"> 27 </span>18:29 learn-proc-macro<br>drwxr-xr-x  <span class="hljs-number"> 7 </span>wangjiahan  staff   224B Nov<span class="hljs-number"> 27 </span>18:30 mandelbrot<br>drwxr-xr-x <span class="hljs-number"> 10 </span>wangjiahan  staff   320B Aug<span class="hljs-number"> 22 </span>10:40 matrix-multi<br>drwxr-xr-x  <span class="hljs-number"> 7 </span>wangjiahan  staff   224B Nov<span class="hljs-number"> 27 </span>18:29 pest-parser-collection<br>drwxr-xr-x <span class="hljs-number"> 19 </span>wangjiahan  staff   608B Nov<span class="hljs-number"> 27 </span>18:27 r-redis<br>drwxr-xr-x <span class="hljs-number"> 21 </span>wangjiahan  staff   672B Aug<span class="hljs-number"> 22 </span>10:40 rcli<br>drwxr-xr-x <span class="hljs-number"> 17 </span>wangjiahan  staff   544B Aug<span class="hljs-number"> 22 </span>10:40 simple-chat<br>drwxr-xr-x <span class="hljs-number"> 17 </span>wangjiahan  staff   544B Aug<span class="hljs-number"> 22 </span>10:40 simple-shortener<br>drwxr-xr-x <span class="hljs-number"> 21 </span>wangjiahan  staff   672B Aug<span class="hljs-number"> 22 </span>10:40 taotie<br>drwxr-xr-x@<span class="hljs-number"> 18 </span>wangjiahan  staff   576B Nov<span class="hljs-number"> 27 </span>15:38 thumbor<br>drwxr-xr-x <span class="hljs-number"> 19 </span>wangjiahan  staff   608B Aug<span class="hljs-number"> 29 </span>10:56 winnow-parser-collection<br>➜  hedon-rust-road tokei -t rust<br>===============================================================================<br> Language            Files        Lines         Code     Comments       Blanks<br>===============================================================================<br> Rust                 <span class="hljs-number"> 336 </span>      <span class="hljs-number"> 25451 </span>      <span class="hljs-number"> 21615 </span>        <span class="hljs-number"> 644 </span>        3192<br> |- Markdown           <span class="hljs-number"> 53 </span>        <span class="hljs-number"> 546 </span>          <span class="hljs-number"> 0 </span>        <span class="hljs-number"> 476 </span>          70<br> (Total)                         <span class="hljs-number"> 25997 </span>      <span class="hljs-number"> 21615 </span>       <span class="hljs-number"> 1120 </span>        3262<br>===============================================================================<br> Total                <span class="hljs-number"> 336 </span>      <span class="hljs-number"> 25451 </span>      <span class="hljs-number"> 21615 </span>        <span class="hljs-number"> 644 </span>        3192<br>===============================================================================<br></code></pre></td></tr></table></figure><p>看老师画了那么多牛逼的图，要不“邯郸学步”模仿一下吧。故而又忍着“下一个吧”的念头，梳理了下这几个月到底做了些什么。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/8abb5b2a2f3020ca36f75087ae76a53c.PNG"alt="rcli" /><figcaption aria-hidden="true">rcli</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/4ac783c6adaa38a45853861753112e35.PNG"alt="r-redis" /><figcaption aria-hidden="true">r-redis</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/4bdd0cba75aa773c6f4e941cf5c5fe29.PNG"alt="macro-json" /><figcaption aria-hidden="true">macro-json</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/969e023d9003b3c28ea1c95a7c1d9388.PNG"alt="macro-error-info" /><figcaption aria-hidden="true">macro-error-info</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/f25b8a0f1c95ac306ecda6c4ff3954a3.PNG"alt="rust-ecosystem" /><figcaption aria-hidden="true">rust-ecosystem</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/d04da8bf3577f1d09b7fce647451a700.PNG"alt="crm" /><figcaption aria-hidden="true">crm</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/c85939619088cda8c9a763ba514d235e.PNG"alt="taotie" /><figcaption aria-hidden="true">taotie</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/2d3892c57b0742707c6ff3a1267f532a.PNG"alt="dino" /><figcaption aria-hidden="true">dino</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/874082e0f9f9410f342d875f8559bd15.PNG"alt="aicomm" /><figcaption aria-hidden="true">aicomm</figcaption></figure><h1 id="归元">归元</h1><ul><li>知是行之始，行是知之成。</li><li>遇事不决，可问春风。春风不语，既随本心。</li></ul><p>2025 见！</p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>总结</category>
      
      <category>2024</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 原理丨聊一聊 Rust 的 Atomic 和内存顺序</title>
    <link href="/2024/11/11/rust-memory-order/"/>
    <url>/2024/11/11/rust-memory-order/</url>
    
    <content type="html"><![CDATA[<h1 id="atomic">Atomic</h1><p>在 Rust 的 <code>std::sync::atomic</code>模块中包含了无锁并发编程的原子化类型，与通常的算术运算符和逻辑运算符不同，原子化类型会暴露执行原子化操作的方法，单独的加载、存储、交换和算术运算都会作为一个单元安全地进行，哪怕其他线程也在执行操作同一内存的原子化操作也没问题。</p><p>Rust 提供了以下几种原子化类型：</p><ul><li><code>AtomicIsize</code> 和 <code>AtomicUsize</code> 是与单线程<code>isize</code> 类型和 <code>usize</code>类型对应的共享整数类型。</li><li><code>AtomicI8</code>、<code>AtomicI16</code>、<code>AtomicI32</code>、<code>AtomicI64</code>及其无符号变体（如<code>AtomicU8</code>）是共享整数类型，对应于单线程中的类型<code>i8</code>、<code>i16</code> 等。</li><li><code>AtomicBool</code> 是一个共享的 <code>bool</code> 值。</li><li><code>AtomicPtr</code> 是不安全指针类型 <code>*mut T</code>的共享值。</li></ul><p>这些类型都会以下几类核心功能：</p><ul><li><code>Load</code> 、<code>Store</code>: 存取值</li><li><code>Fetch-and-Modify</code>: 获取并修改</li><li><code>Compare-and-Exchange</code>: 比较并交换</li></ul><p>下面我们对上述提到的几种核心功能进行举例。</p><h2 id="load-store">Load &amp; Store</h2><ul><li><strong>load</strong>:从原子化类型中获取起对应的基本数据类型的值。</li><li><strong>store</strong>:将一个基本数据类型的值存储到其对应的原子化类型中。</li></ul><p>在下面的例子中，我们使用 <code>AtomicUsize::new(0)</code>初始化了一个原子类型，它对应的基本数据类型是 <code>usize</code>。</p><p>我们起了一个子线程，在 for 循环中不断地使用 <code>store</code>函数修改 <code>num_done</code> 的值，然后在主线程中使用<code>load</code> 获取起对应的值，当发现值为 <code>100</code>时，就退出循环，进程结束。</p><p>得益于原子化类型的并发安全特性，所以这里两个线程对<code>num_done</code> 进行并发读写都是安全的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num_done</span> = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">main_thread</span> = thread::<span class="hljs-title function_ invoke__">current</span>();<br><br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> &#123;<br>                <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">10</span>));<br>                num_done.<span class="hljs-title function_ invoke__">store</span>(i + <span class="hljs-number">1</span>, std::sync::atomic::Ordering::Relaxed);  <span class="hljs-comment">// store 存储</span><br>                main_thread.<span class="hljs-title function_ invoke__">unpark</span>();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = num_done.<span class="hljs-title function_ invoke__">load</span>(std::sync::atomic::Ordering::Relaxed); <span class="hljs-comment">// load 获取</span><br>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">100</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Working... &#123;n&#125;/100 done&quot;</span>);<br>            thread::<span class="hljs-title function_ invoke__">park_timeout</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里我们暂且忽略 <code>std::sync::atomic::Ordering::Relaxed</code>这个参数的含义，在后续的「内存顺序」章节会进行详细阐述。</p></blockquote><h2 id="fetch-and-modify">Fetch-and-Modify</h2><p><strong>Fetch-and-Modify</strong>操作用于在获取当前值的同时对其进行修改。这类操作包括<code>fetch_add</code>、<code>fetch_sub</code>、<code>fetch_and</code>、<code>fetch_or</code>、<code>fetch_xor</code>等。</p><p>我们将上面的例子修改一下，不再是直接 <code>store</code>一个值，而是不断进行加 1 操作：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num_done</span> = &amp;AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> &#123;<br>                num_done.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, std::sync::atomic::Ordering::Relaxed); <span class="hljs-comment">// 使用 fetch_add 进行加 1</span><br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = num_done.<span class="hljs-title function_ invoke__">load</span>(std::sync::atomic::Ordering::Relaxed);<br>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">100</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Working... &#123;n&#125;/100 done&quot;</span>);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="compare-and-exchange">Compare-and-Exchange</h2><p><strong>Compare-and-Exchange</strong>是一种条件更新操作，只有在当前值等于预期值时才会更新。</p><p>下面的例子中我们实现了一个函数<code>allocate_new_id</code>，它支持在并发环境下分配新的<code>id</code>，这里我们使用了 <code>compare_exchange(id, id+1)</code>进行条件更新，只有当 <code>id</code>没有发生变化的时候，才运行对其进行加1，这就保证了在并发下，只有一个线程可以成功执行该语句，从而保证<code>id</code> 的递增性和唯一性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">allocate_new_id</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-keyword">static</span> NEXT_ID: AtomicU32 = AtomicU32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">id</span> = NEXT_ID.<span class="hljs-title function_ invoke__">load</span>(std::sync::atomic::Ordering::Relaxed);<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">assert!</span>(id &lt; <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;Too many IDs!&quot;</span>);<br>        <span class="hljs-keyword">match</span> NEXT_ID.<span class="hljs-title function_ invoke__">compare_exchange</span>(  <span class="hljs-comment">// 只有 id 没有发生变化，才允许进行加 1</span><br>            id,<br>            id + <span class="hljs-number">1</span>,<br>            std::sync::atomic::Ordering::Relaxed,<br>            std::sync::atomic::Ordering::Relaxed,<br>        ) &#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-keyword">return</span> id,<br>            <span class="hljs-title function_ invoke__">Err</span>(v) =&gt; id = v,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>在 Rust中，原子化类型还提供了另外一个函数：<code>compare_exchange_weak</code>，它与<code>compare_exchange</code>的主要区别在于它们在<strong>失败时</strong>的行为：</p><p><strong>compare_exchange</strong>:</p><ul><li>只会在实际值不等于期望值时失败。</li><li>提供更强的保证，但可能性能较低。</li><li>适用于不在循环中的单次比较交换操作。</li></ul><p><strong>compare_exchange_weak</strong>:</p><ul><li>即使实际值等于期望值时也可能失败（称为“虚假失败”或“spuriousfailure”）。</li><li>性能可能更好，因为允许在某些架构上生成更高效的代码。</li><li>最适合在循环中使用，因为需要处理可能的虚假失败。</li></ul><p>在实际应用中:</p><ul><li>如果操作在循环中,使用 <code>compare_exchange_weak</code>通常更好。</li><li>如果是单次操作,使用 <code>compare_exchange</code> 更合适。</li><li>在某些平台上，这两个操作可能没有性能差异,但<code>compare_exchange_weak</code> 的行为仍然可能不同。</li></ul><p>这种区别的存在是因为在某些 CPU架构上,允许虚假失败可以生成更高效的机器码。比如在 ARM架构上，<code>compare_exchange_weak</code> 可以直接映射到单个LL/SC（Load-Link/Store-Conditional）指令。</p>          </div><h2 id="硬件原理">硬件原理</h2><p>在一些处理器架构中，当一个 CPU执行需要原子性的操作时，它可以通过锁定内存总线来确保在操作完成之前，其他CPU 无法访问相关的内存地址。</p><p>基本工作流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">CPU 发出 LOCK 信号<br>   └── 激活处理器的 LOCK# 引脚<br>      └── 获得总线的独占访问权<br>          └── 执行原子操作<br>              └── 释放 LOCK 信号<br>                  └── 其他处理器可以访问内存<br></code></pre></td></tr></table></figure><p>主流的有 2 种锁定机制：</p><ul><li><p><strong>总线锁定（BusLocking）</strong>：总线锁定是一种机制，它通过锁定内存总线来确保在执行原子操作时，其他处理器无法访问内存。这种方法虽然简单，但会导致总线的其他操作被阻塞，从而影响系统性能。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">优点：<br><span class="hljs-bullet">-</span> 绝对的原子性保证<br><span class="hljs-bullet">-</span> 适用于所有内存位置<br><br>缺点：<br><span class="hljs-bullet">-</span> 性能开销大<br><span class="hljs-bullet">-</span> 会阻塞其他 CPU 对内存的访问<br></code></pre></td></tr></table></figure></li><li><p><strong>缓存锁定（CacheLocking）</strong>：现代处理器通常使用缓存锁定来实现原子操作。缓存锁定通过锁定处理器的缓存行来实现，而不是锁定整个总线。这种方法可以减少对总线的影响，提高系统的并发性能。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">优点：<br><span class="hljs-bullet">-</span> 性能更好<br><span class="hljs-bullet">-</span> 不会完全阻塞内存访问<br><br>条件：<br><span class="hljs-bullet">-</span> 数据必须在缓存行中<br><span class="hljs-bullet">-</span> 缓存行必须是独占状态<br></code></pre></td></tr></table></figure></li></ul><p>缓存锁定通常依赖于缓存一致性协议（如 <strong>MESI</strong>协议）来确保在多个处理器之间的数据一致性。通过这些协议，处理器可以在本地缓存中执行原子操作，并在必要时与其他处理器同步。</p><p><strong>MESI</strong> 协议即：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">M (Modified)：已修改<br>E (Exclusive)：独占<br>S (Shared)：共享<br>I (Invalid)：无效<br><br>操作流程：<br><span class="hljs-bullet">1.</span> 检查数据是否在缓存中<br><span class="hljs-bullet">2.</span> 如果在，将状态改为 Exclusive<br><span class="hljs-bullet">3.</span> 执行原子操作<br><span class="hljs-bullet">4.</span> 通知其他 CPU 使其缓存失效<br></code></pre></td></tr></table></figure><p>不同的架构有不同的锁定方式：</p><ul><li>x86/x64：使用 LOCK 前缀</li><li>ARM：使用 exclusive load/store 指令</li><li>PowerPC：使用 load-linked/store-conditional</li></ul><p>以下是 x86 汇编的一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; 原子加法操作<br>lock add dword ptr [memory], 1<br><br>; 比较并交换<br>lock cmpxchg dword ptr [memory], eax<br></code></pre></td></tr></table></figure><p>为了充分利用<strong>缓存锁定</strong>的优势，我们在编写代码时，可以有以下的性能考虑：</p><ul><li><p><strong>缓存行对齐，避免伪共享</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicI32, Ordering&#125;;<br><br><span class="hljs-comment">// 在 Rust 中，可以使用 #[repr(align(N))] 属性来确保结构体或变量的对齐方式，以避免伪共享。</span><br><span class="hljs-comment">// 伪共享是指多个线程访问不同的变量，但这些变量共享同一个缓存行，从而导致不必要的缓存一致性流量。</span><br><span class="hljs-meta">#[repr(align(64))]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlignedCounter</span> &#123;<br>    counter: AtomicI32,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = AlignedCounter &#123;<br>        counter: AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>),<br>    &#125;;<br>    <span class="hljs-comment">// 使用 counter.counter.fetch_add(...) 进行操作</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>避免频繁的总线锁定</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicI32, Ordering&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 不好的做法：频繁的原子操作</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1000</span> &#123;<br>        counter.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Ordering::SeqCst);<br>    &#125;<br><br>    <span class="hljs-comment">// 更好的做法：本地累加后一次性更新</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">local_sum</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1000</span> &#123;<br>        local_sum += <span class="hljs-number">1</span>;<br>    &#125;<br>    counter.<span class="hljs-title function_ invoke__">fetch_add</span>(local_sum, Ordering::SeqCst);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="rust-实战查看汇编">Rust 实战查看汇编</h3><blockquote><p>笔者使用的是 ARM64 架构的 macbook。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicI64, Ordering&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">static</span> ATOMIC: AtomicI64 = AtomicI64::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        ATOMIC.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">10086</span>, Ordering::Release);<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">val</span> = ATOMIC.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire);<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;val&#125;&quot;</span>);<br>    &#125;);<br><br>    t1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    t2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>rustc</code> 编译并输出汇编代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rustc -O --emit asm src/main.rs<br></code></pre></td></tr></table></figure><p>代码中我特地设置了 <code>10086</code>这个特殊的值，这是为了可以在输出的 <code>main.s</code> 文件中快速找到<code>store</code> 对应的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__ZN3std3sys9backtrace28__rust_begin_short_backtrace17h750d7a3a9c81fc67E:<br>.cfi_startproc<br>Lloh8:<br>adrpx8, __ZN4main6ATOMIC17hd0b0dbf92e477148E.0@PAGE<br>Lloh9:<br>addx8, x8, __ZN4main6ATOMIC17hd0b0dbf92e477148E.0@PAGEOFF<br>movw9, #10086 ; 将值 10086 移入寄存器<br>stlrx9, [x8] ; Store-Release 指令，原子地存储值<br>; InlineAsm Start<br>; InlineAsm End<br>ret<br>.loh AdrpAddLloh8, Lloh9<br>.cfi_endproc<br></code></pre></td></tr></table></figure><p>在这个代码中，<code>stlr</code> 就是 <code>Store Release</code>的意思，另外一个关键字是 <code>ladpr</code>，表示<code>Load Acquire</code> 的意思，通过这个关键字，你可以找到<code>load</code> 对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Lloh11:<br>addx8, x8, __ZN4main6ATOMIC17hd0b0dbf92e477148E.0@PAGEOFF<br>ldaprx8, [x8] ; ; Load-Acquire 指令，原子地加载值<br>strx8, [sp, #8]<br></code></pre></td></tr></table></figure><h3 id="go-实战查看汇编">Go 实战查看汇编</h3><blockquote><p>笔者使用的是 ARM64 架构的 macbook。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>data := atomic.Int64&#123;&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>data.Store(<span class="hljs-number">10086</span>)<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>a := data.Load()<br><span class="hljs-built_in">println</span>(a)<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>使用如下命令，可以输出优化后的汇编代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go build -gcflags=-S -ldflags=-w main.go 2&gt; assembly.txt<br></code></pre></td></tr></table></figure><p>查看输出的文件，我们同样搜索 <code>10086</code>，可以快速找到<code>store</code> 的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x0008 00008 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:109)MOVD$10086, R1<br>0x000c 00012 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:109)STLRR1, (R0)<br></code></pre></td></tr></table></figure><p>可以看到，这里同样也是使用了 <code>STLR</code> 指令。接着我们看第 14行代码的位置对应的汇编：可以发现这里使用的 <code>LDAR</code>指令，也就是 <code>Load Acuqire</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x001c 00028 (/Users/wangjiahan/goStudy/go-atomic/main.go:14)HINT$0<br>0x0020 00032 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:106)LDAR(R0), R0<br>0x0024 00036 (/Users/wangjiahan/go/go1.23.2/src/sync/atomic/type.go:106)MOVDR0, main..autotmp_6-8(SP)<br></code></pre></td></tr></table></figure><h1 id="内存顺序">内存顺序</h1><p>在了解了 Rust Atomic的基本用法和基本原理之后，我们回过头来谈一谈原子操作参数中的<code>std::sync::atomic::Ordering::Relaxed</code>，这个就是本篇的主题：<strong>内存顺序</strong>。内存顺序要解决的核心问题是<u>如何合理地限制单一线程中的代码执行顺序，使得在不使用锁的情况下，既能最大化利用CPU 的计算能力，又能保证多线程环境下不会出现逻辑错误。</u></p><h2 id="指令乱序">指令乱序</h2><p>CPU和编译器都会在保证程序运行结果不发生改变的前提下，尽一切可能让我们的程序运行得尽可能快。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>(a: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>, b: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>) &#123;<br>  *a += <span class="hljs-number">1</span>;<br>  *b += <span class="hljs-number">1</span>;<br>  *a += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>像上述代码，编译器完全可以优化成下面的代码，从而提高程序的运行效率：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>(a: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>, b: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>) &#123;<br>  *a += <span class="hljs-number">2</span>;<br>  *b += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个过程中，就可能会出现<strong>指令重排</strong>，甚至是<strong>代码重写</strong>，不过这带来了指令乱序的问题，即<u>程序的实际执行顺序跟我们的代码顺序是不一致的</u>。</p><p>不过，编译器保证的是<strong>在单线程环境下，执行的结果最终一致</strong>，所以，指令乱序在单线程环境下完全是允许的。对于编译器来说，它只知道：在当前线程中，数据的读写以及数据之间的依赖关系。但是，<strong>编译器并不知道哪些数据是在线程间共享，而且是有可能会被修改的</strong>。而这些是需要开发人员去保证的。</p><h2 id="内存模型">内存模型</h2><p>为了解决指令乱序带来的并发问题，Rust 采用了内存模型（MemoryModel）这一概念。这个概念主要借鉴自 C++11中引入的内存模型，它定义了在多线程环境下内存访问的行为规范。</p><p>内存模型的核心目标是在以下三方面之间取得平衡：</p><ol type="1"><li><strong>正确性保证</strong>：确保多线程程序的行为是可预测和一致的。</li><li><strong>性能优化</strong>：允许编译器和 CPU在不违反正确性的前提下进行优化。</li><li><strong>跨平台兼容</strong>：提供一个统一的抽象层，使代码可以在不同的硬件架构上正确运行。</li></ol><p>具体来说，内存模型：</p><ul><li>为开发者提供了清晰的规则，说明在多线程环境下，什么样的内存访问行为是合法的，什么样的行为会导致未定义行为。</li><li>为编译器开发者提供了明确的标准，指导他们在不同平台上实现必要的内存同步原语。</li><li>通过定义不同的内存顺序级别（如 Relaxed、Release/Acquire、SeqCst等），让开发者可以根据需要选择合适的同步强度。</li></ul><p>这种抽象让开发者可以专注于并发逻辑本身，而不必过分关注底层硬件的具体实现细节。</p><h2 id="sequenced-before">Sequenced-Before</h2><p>在讨论内存顺序之前，我们需要先对 2 个重要关系术语进行简单阐述，分别是<code>Sequenced-Before</code> 和 <code>Happens-Before</code>。</p><p><strong>Sequenced-Before</strong>描述的是<strong>单个线程内</strong>的操作顺序。它基于程序的源代码顺序，表示在同一线程中，一个操作在程序中出现在另一个操作之前。</p><p>具体来说，如果操作 A sequenced-before 操作 B，那么：</p><ol type="1"><li><p><strong>数据依赖关系</strong>：如果 B 依赖于 A 的结果，那么 A一定会在 B 之前执行。例如： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;      <span class="hljs-comment">// 操作 A</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 操作 B - 依赖于 A 的结果</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>原子操作的顺序</strong>：对同一个原子变量的操作会保持程序顺序。例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">5</span>, Relaxed);    <span class="hljs-comment">// 一定先执行</span><br>X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">10</span>, Relaxed);   <span class="hljs-comment">// 一定后执行</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>独立操作的可重排性</strong>：如果两个操作之间没有数据依赖关系，且操作的是不同的变量，那么它们可能会被重排序。例如：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">X.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, Relaxed);  <span class="hljs-comment">// 这两个操作可能会被重排序</span><br>Y.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">2</span>, Relaxed);  <span class="hljs-comment">// 因为它们操作的是不同的变量</span><br></code></pre></td></tr></table></figure></p></li></ol><h2 id="happens-before">Happens-Before</h2><p><strong>Happens-Before</strong>则描述了<strong>跨线程</strong>的操作顺序。它定义了不同线程中的操作之间的可见性和顺序关系。如果操作A Happens-Before 操作 B，那么 A 的内存写入对 B 是可见的。</p><p>典型的 Happens-Before 有：</p><ol type="1"><li>同一线程内，如果先调用 <code>f()</code>，再调佣 <code>g()</code>，则<code>f()</code> happens-before <code>g()</code>，其实这就是<code>sequenced-before</code>。</li><li><code>spawing</code> happens-before <code>joining</code>。</li><li><code>lock</code> happens-before <code>unlock</code>。</li></ol><p>举个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> X: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(f);<br>    X.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">2</span>, Relaxed);<br>    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    X.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">3</span>, Relaxed);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">f</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-built_in">assert!</span>(x == <span class="hljs-number">1</span> || x == <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子的执行顺序如下图所示，因为 <code>spawn</code>happens-before<code>join</code>，所以我们可以确定的执行顺序是：<strong>“store 1 toX”→“store 2 to X”→“store 3 to X”</strong>。而 <strong>load fromX</strong> 介于 spawn 和 join之间，且没有进行任何其他的内存顺序限制，所以它和 <strong>store 2 toX</strong> 之间的顺序是不确定的，但是可以肯定的是，它一定在<strong>store 3 to X</strong> 之前，所以<code>assert!(x == 1 || x == 2);</code> 是永远成立的。</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241111160041436.png" alt="spawn-happens-before-join" style="zoom:33%;" /></p><p>到这里，相信不少读者已经能够理解为什么需要内存顺序这个东西了，核心问题就是在于<strong>store 2 to X</strong> 和 <strong>load from X</strong>的执行顺序是否会影响我们的业务逻辑，如果不会，那么我们可以指定最松散的内存顺序要求，如果会，那么我们就要利用指定合适的内存顺序来使得其按照我们的预期顺序进行执行，从而保证业务逻的正确。</p><h2 id="rust-内存顺序">Rust 内存顺序</h2><p>Rust 支持五种内存顺序（Ordering），从最松散到最严格依次为：</p><table><thead><tr class="header"><th>内存顺序</th><th>说明</th><th>保证</th><th>适用场景</th><th>示例</th></tr></thead><tbody><tr class="odd"><td>Relaxed</td><td>最宽松的内存顺序</td><td>- 仅保证操作的原子性<br>- 不提供任何同步保证<br>- 不建立happens-before 关系</td><td>- 简单计数器<br>- 性能要求极高且确定不需要同步<br>-已通过其他方式确保同步</td><td><code>counter.fetch_add(1, Ordering::Relaxed)</code></td></tr><tr class="even"><td>Release</td><td>用于存储操作</td><td>- 之前的内存访问不会被重排到此操作之后<br>- 与 Acquire配对使用可建立 happens-before 关系</td><td>- 生产者-消费者模式<br>- 发布共享数据<br>- 初始化完成标志</td><td><code>data.store(42, Ordering::Release)</code></td></tr><tr class="odd"><td>Acquire</td><td>用于加载操作</td><td>- 之后的内存访问不会被重排到此操作之前<br>- 与 Release配对使用可建立 happens-before 关系</td><td>- 生产者-消费者模式<br>- 获取共享数据<br>- 检查初始化标志</td><td><code>data.load(Ordering::Acquire)</code></td></tr><tr class="even"><td>AcqRel</td><td>同时包含 Acquire 和 Release 语义</td><td>- 结合了 Acquire 和 Release 的所有保证<br>- 用于读改写操作</td><td>- 需要双向同步的原子操作<br>- 锁的实现<br>- 复杂的同步原语</td><td><code>value.fetch_add(1, Ordering::AcqRel)</code></td></tr><tr class="odd"><td>SeqCst</td><td>最严格的内存顺序</td><td>- 包含 AcqRel 的所有保证<br>- 所有线程看到的所有 SeqCst操作顺序一致<br>- 提供全局的顺序一致性</td><td>- 需要严格的全局顺序<br>- 不确定使用哪种顺序时<br>-对性能要求不高的场景</td><td><code>flag.store(true, Ordering::SeqCst)</code></td></tr></tbody></table><p>在 C++ 中，其实还有另外一种内存顺序 <code>Consume</code>，它是<code>Acquire</code> 的一个更弱的版本：</p><ul><li><p><strong>Acquire</strong>:保证后续的所有读写操作不会重排到这个操作前面</p></li><li><p><strong>Consume</strong>:只保证后续与这个操作结果相关的读写操作不会重排到这个操作前面</p></li></ul><p>理论上，Consume 在某些架构上可以提供比 Acquire更好的性能，因为它只需要对数据依赖的操作进行同步。</p><p>然而，由于以下原因，Rust 选择不支持 Consume 顺序：</p><ol type="1"><li><strong>实现复杂性</strong>：很多编译器实现者发现正确实现 Consume语义非常困难。</li><li><strong>性能收益不确定</strong>：在实践中，大多数编译器都将 Consume视为 Acquire 来处理。</li><li><strong>标准困惑</strong>：C++ 标准委员会也承认当前的 Consume语义定义存在问题，正在考虑重新设计。</li></ol><div class="note note-info">            <p>选择建议：</p><ol type="1"><li><strong>不确定选择哪种顺序时</strong>：<ul><li>使用 SeqCst（最安全但性能最低）</li><li>或咨询有经验的开发者</li></ul></li><li><strong>性能优化时</strong>：<ul><li>先使用 SeqCst 开发</li><li>在性能测试后，根据需要降低到 Release/Acquire</li><li>只有在确实需要时才使用 Relaxed</li></ul></li><li><strong>常见组合</strong>：<ul><li>Release 写 + Acquire 读：最常见的生产者-消费者模式</li><li>AcqRel：用于原子的读改写操作</li><li>Relaxed：用于简单的计数器场景</li></ul></li></ol>          </div><p>下面我们来对每种内存顺序进行举例阐述。</p><h3 id="relaxed">Relaxed</h3><p><code>Relaxed</code>是最宽松的内存顺序，它只保证了原子操作在并发下的安全性，但不保证执行顺序。</p><p>考虑如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> X: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">5</span>, Relaxed);<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">10</span>, Relaxed); <br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">b</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;a&#125; &#123;b&#125; &#123;c&#125; &#123;d&#125;&quot;</span>);  <span class="hljs-comment">// 这个输出不一定</span><br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(a);<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(b);<br>    &#125;);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, X.<span class="hljs-title function_ invoke__">load</span>(Relaxed)); <span class="hljs-comment">// 最终结果一定是 15</span><br>&#125;<br></code></pre></td></tr></table></figure><p>基于我们上面提到的 <code>sequenced-before</code> 规则，我们可以确定<code>a</code> 和 <code>b</code> 两个线程内的<code>happens-before</code> 规则，但是二者之间的<code>happens-before</code> 是无法确定的，但是我们可以确定最后的结果是<code>15</code>。下图展示了上述代码的执行顺序示意图：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241111164259913.png" alt="relaxed-ordering" style="zoom:50%;" /></p><p>虽然两个线程之间的 <code>happens-before</code>是无法确定的，但是我们可以确定 <code>X</code>的变化顺序：0→5→15。所以线程 <code>b</code> 输出<code>0 0 0 0</code>、<code>0 0 5 15</code> 和 <code>0 15 15 15</code>都是可能的，而永远不可能输出 <code>0 5 0 15</code> 或<code>0 0 10 15</code> 类似的结果。</p><p>但是如果是这样子的话，就不一定了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> X: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a1</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">5</span>, Relaxed);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a2</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">10</span>, Relaxed); <br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">b</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;a&#125; &#123;b&#125; &#123;c&#125; &#123;d&#125;&quot;</span>);  <span class="hljs-comment">// 这个输出不一定</span><br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(a1);<br>      s.<span class="hljs-title function_ invoke__">apawn</span>(a2);<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(b);<br>    &#125;);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, X.<span class="hljs-title function_ invoke__">load</span>(Relaxed)); <span class="hljs-comment">// 最终结果一定是 15</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子，<code>X</code> 的变化顺序可以是 0→5→15，也可以是0→10→15，这取决于哪个 <code>fetch_add</code> 先被执行。</p><p>再举个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> DATA: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        <span class="hljs-comment">// 线程 A - 写入者</span><br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">123</span>, Ordering::Relaxed);     <span class="hljs-comment">// ① 准备数据</span><br>            READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Relaxed);   <span class="hljs-comment">// ② 发出数据就绪信号</span><br>        &#125;);<br><br>        <span class="hljs-comment">// 线程 B - 读取者</span><br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed) &#123;  <span class="hljs-comment">// ③ 等待数据就绪信号</span><br>                thread::<span class="hljs-title function_ invoke__">yield_now</span>();<br>            &#125;<br>            <span class="hljs-built_in">assert_eq!</span>(DATA.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed), <span class="hljs-number">123</span>); <span class="hljs-comment">// ④ 获取数据，这里断言一定成功吗？</span><br>        &#125;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子中，线程 A 执行了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">123</span>, Ordering::Relaxed);     <span class="hljs-comment">// 准备数据</span><br>READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Relaxed);   <span class="hljs-comment">// 发出数据就绪信号</span><br></code></pre></td></tr></table></figure><p>这是 2 个没有依赖关系的原子操作，且使用的是 <code>Relaxed</code>内存顺序，所以对于线程 B 来说，这 2个操作的顺序是不确定的。所以是很可能在<code>READY.load(Ordering::Relaxed)</code> 返回 <code>true</code>的时候，<code>DATA.load(Ordering::Relaxed)</code> 依旧还是<code>0</code>。</p><p>那如何确保这个断言一定成功呢？那就需要“升级”一下了~ 这个时候就轮到<code>Release</code> 和 <code>Acquire</code> 的出场了。</p><h3 id="release-acquire">Release &amp; Acquire</h3><p><code>Release</code> 和 <code>Acquire</code>一般成对出现，它们共同建立了线程间的同步关系：</p><ul><li><code>Release</code>:作用于写操作（store），确保该操作之前的所有内存访问不会被重排到这个Release 操作之后。</li><li><code>Acquire</code>:作用于读操作（load），确保该操作之后的所有内存访问不会被重排到这个Acquire 操作之前。</li></ul><p>当一个线程通过 <code>Acquire</code> 读取到另一个线程通过<code>Release</code> 写入的值时，会建立一个 happens-before关系：<strong><font color="orange">线程 A 中 Release写入之前的所有内存写操作，对于线程 B 中 Acquire读取之后的所有内存读操作都是可见的</font></strong>。</p><p>修改一下上面的例子： <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> DATA: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">123</span>, Ordering::Relaxed);   <br>            READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Release);   <span class="hljs-comment">// 这里改为 release</span><br>        &#125;);<br><br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire) &#123;  <span class="hljs-comment">// 这里改为 acquire</span><br>                thread::<span class="hljs-title function_ invoke__">yield_now</span>();<br>            &#125;<br>            <span class="hljs-built_in">assert_eq!</span>(DATA.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed), <span class="hljs-number">123</span>); <span class="hljs-comment">// 必定成功</span><br>        &#125;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241111165714772.png" alt="release-acquire-ordering" style="zoom:50%;" /></p><p>如上图所示，在这个例子中：</p><ol type="1"><li>Release-Acquire 同步确保了 <code>READY</code> 的写入和读取之间建立了happens-before 关系</li><li>由于 <code>DATA</code> 的写入在 <code>READY</code> 的 Release写入之前，而 <code>DATA</code> 的读取在 <code>READY</code> 的 Acquire读取之后</li><li>因此可以保证线程 B 一定能看到线程 A 写入的值 123</li></ol><p>更进一步，我们通过观察，可以发现 <code>DATA</code> 都没必要使用<code>Atomic</code> 类型，因为由 <code>READY</code> 建议的<code>happens-before</code> 规则已经能保证对 <code>DATA</code>的读写不可能并发执行了。��过因为 Rust的类型系统并不允许跨线程进行非原子类型的读写操作，所以这里我们需要使用<code>unsafe</code>才能使编译通过，但通过我们之前的分析，我们可以确保下面这段代码是安全的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> DATA: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-comment">// Safety: 此时没有其他线程访问 DATA，</span><br>        <span class="hljs-comment">// 因为我们还没有设置 READY 标志</span><br>        <span class="hljs-keyword">unsafe</span> &#123; DATA = <span class="hljs-number">123</span> &#125;;<br>        READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Release); <span class="hljs-comment">// 在这个存储操作之前的所有内存操作 ..</span><br>    &#125;);<br>    <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Acquire) &#123; <span class="hljs-comment">// .. 在这个加载操作返回 true 后都是可见的</span><br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">100</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// Safety: 没有线程会修改 DATA，因为 READY 已经被设置</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; DATA &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <h3 id="释放序列release-sequence">释放序列（Release Sequence）</h3><p>我们再来看一段代码示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;sync::atomic::AtomicU8, thread&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> DATA: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i64</span>&gt; = <span class="hljs-built_in">vec!</span>[];<br><span class="hljs-keyword">static</span> FLAG: AtomicU8 = AtomicU8::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread_1</span>() &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        DATA.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">42</span>);<br>    &#125;<br>    FLAG.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, std::sync::atomic::Ordering::Release);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread_2</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">expected</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// memory_order_relaxed is okay because this is an RMW,</span><br>    <span class="hljs-comment">// and RMWs (with any ordering) following a release form a release sequence</span><br>    <span class="hljs-keyword">while</span> FLAG<br>        .<span class="hljs-title function_ invoke__">compare_exchange</span>(<br>            expected,<br>            <span class="hljs-number">2</span>,<br>            std::sync::atomic::Ordering::Relaxed,<br>            std::sync::atomic::Ordering::Relaxed,<br>        )<br>        .<span class="hljs-title function_ invoke__">is_err</span>()<br>    &#123;<br>        expected = <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread_3</span>() &#123;<br>    <span class="hljs-keyword">while</span> FLAG.<span class="hljs-title function_ invoke__">load</span>(std::sync::atomic::Ordering::Acquire) &lt; <span class="hljs-number">2</span> &#123;&#125;<br>    <span class="hljs-comment">// if we read the value 2 from the atomic flag, we see 42 in the vector</span><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(DATA[<span class="hljs-number">0</span>], <span class="hljs-number">42</span>); <span class="hljs-comment">// will never fire</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(thread_1);<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(thread_2);<br>        s.<span class="hljs-title function_ invoke__">spawn</span>(thread_3);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是参考 <ahref="https://en.cppreference.com/w/cpp/atomic/memory_order">cppreference</a>而翻译成 Rust 代码的，在上述代码中，即使 <code>thread_2</code>中我们使用的是 <code>Relaxed</code>， 这段代码中的<code>assert_eq!(DATA[0], 42)</code>也是一定成功的。为什么呢？这涉及到一个重要的概念——<strong>释放序列（ReleaseSequence）</strong>：</p><ul><li>当一个 <code>release</code>操作后面跟着一系列的原子<code>"读-修改-写"(RMW)</code>操作时，这些操作会形成一个释放序列。</li><li>在这个序列中，后续的 RMW 操作<strong>不需要</strong>使用 release 或acquire 语义也能保证同步。</li></ul><p>在这段代码中：当 <code>thread_2</code> 的 <code>RMW</code>操作成功的时候，说明 <code>FLAG</code> 是 <code>1</code>，即<code>thread_1</code> 已经执行了 <code>release</code>操作，这个时候：</p><ol type="1"><li><code>thread_1</code> 的 <code>release</code> 操作建立了同步点</li><li><code>thread_2</code> 的 <code>RMW</code>操作自动成为释放序列的一部分</li><li>当 <code>thread_3</code> 通过 <code>acquire</code> 看到值 2时，它能看到整个释放序列的所有修改。</li><li>因此能保证看到 <code>DATA</code> 中的 42。</li></ol><p>所以在这种场景下使用 <code>relaxed</code> 既安全又高效，因为：</p><ul><li>它是释放序列的一部分</li><li>不需要额外的同步开销</li><li>仍然能保证正确的内存顺序</li></ul><p>为什么这样设计呢？</p><ul><li><strong>原子性保证</strong>：RMW操作本身就是原子的，不会产生数据竞争</li><li><strong>连续性</strong>：每个 RMW操作都直接或间接地基于前一个操作的结果</li><li><strong>因果关系</strong>：形成了一个清晰的修改链条</li><li><strong>性能考虑</strong>：中间的 RMW 操作不需要额外的同步开销</li></ul>          </div><h3 id="sequentially-consistent">Sequentially Consistent</h3><p><code>SeqCst</code> 是最严格的内存顺序，它包括获取<code>release</code> 和 <code>acquire</code>的所有保证，还保证了全局一致的操作顺序。简单理解就是，你代码的顺序是怎么样，实际的执行顺序就是什么样。</p><p>我们来看一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::Ordering::SeqCst;<br><br><span class="hljs-keyword">static</span> A: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">static</span> B: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> S: <span class="hljs-type">String</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        A.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, SeqCst);<br>        <span class="hljs-keyword">if</span> !B.<span class="hljs-title function_ invoke__">load</span>(SeqCst) &#123;<br>            <span class="hljs-keyword">unsafe</span> &#123; S.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&#x27;!&#x27;</span>) &#125;;<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        B.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, SeqCst);<br>        <span class="hljs-keyword">if</span> !A.<span class="hljs-title function_ invoke__">load</span>(SeqCst) &#123;<br>            <span class="hljs-keyword">unsafe</span> &#123; S.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&#x27;!&#x27;</span>) &#125;;<br>        &#125;<br>    &#125;);<br><br>    a.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    b.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，两个线程都是希望将自己的原子变量设置为<code>true</code>，从而阻止另外一个线程对 <code>S</code> 进行<code>push</code> 操作，其实就类似于锁。因为这里使用了<code>SeqCst</code>，所以代码的执行顺序是跟代码编写顺序是一致的，那么就可能出现以下3 种执行情况：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241112113535084.png"alt="seqcst-memory-order" /><figcaption aria-hidden="true">seqcst-memory-order</figcaption></figure><p>即：同一时刻，<strong>最多</strong>只可能有一个线程会对<code>S</code> 进行操作。</p><h1 id="内存屏障">内存屏障</h1><p>除了内存顺序（MemoryOrder），还有另外一种方式可以控制程序的执行顺序，就是内存屏障（MemoryBarrier）。内存屏障是一种底层的同步原语，它能强制处理器按照特定的顺序执行内存操作。内存屏障通过阻止或限制指令重排序，来确保内存操作的可见性和顺序性。</p><h2 id="基本概念">基本概念</h2><p>内存屏障主要分为以下几种类型：</p><ol type="1"><li><strong>Load Barrier（读屏障）</strong><ul><li>确保在屏障之前的所有读操作都执行完成</li><li>防止后续读操作被重排到屏障之前</li><li>对应 Acquire 语义</li></ul></li><li><strong>Store Barrier（写屏障）</strong><ul><li>确保在屏障之前的所有写操作都执行完成</li><li>防止后续写操作被重排到屏障之前</li><li>对应 Release 语义</li></ul></li><li><strong>Full Barrier（全屏障）</strong><ul><li>同时包含读屏障和写屏障的功能</li><li>防止任何内存操作的重排序</li><li>对应 SeqCst 语义</li></ul></li></ol><p>即下面这 2 种实现方式是等价的：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241112123652784.png" alt="fench" style="zoom:50%;" /></p><p>所以到这里，我们可以更好地理解<strong>为什么 <code>release</code>是阻止其前面的内存访问越过它，而 <code>acquire</code>是阻止其后面的内存访问越过它了</strong>。因为有个 <code>fence</code>在前面或后面拦着！</p><p>但是一般来说，下面的写法相比上面的写法会有一丢丢的性能损失，因为这会增加一些额外的处理指令。那<code>fence</code> 的用武之地是什么呢？</p><ol type="1"><li>可以同时对多个原子操作进行 <code>fench</code>；</li><li>可以根据条件判断，选择是否进行 <code>fench</code>。</li></ol><p>举个例子：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20241112125023036.png" alt="fence-multi-atomics" style="zoom:50%;" /></p><p>这个例子的关键点是：</p><ol type="1"><li>如果线程 2 中的任何一个 load 操作观察到了线程 1 中对应的 store操作的值：<ul><li>比如 A.load() 读到了值 1，或</li><li>B.load() 读到了值 2，或</li><li>C.load() 读到了值 3</li></ul></li><li>那么：线程 1 中的 release fence 就会 happens-before 线程 2 中的acquire fence。这意味着线程 1 中 release fence 之前的所有内存操作对线程2 中 acquire fence 之后的操作都是可见的。</li></ol><p>这展示了内存屏障的一个重要优势：<strong>一个屏障可以同时为多个原子操作建立同步关系，而不需要在每个原子操作上都使用Release/Acquire 内存序。这在某些场景下可能会更高效。</strong></p><p>用更通俗的话说：这就像在线程 1 设置了一个"检查点"（releasefence），在线程 2 也设置了一个"检查点"（acquire fence），只要线程 2看到了线程 1 在其检查点之后做的任何一个改动，那么线程 1检查点之前的所有操作对线程 2 的检查点之后都是可见的。</p><h2 id="硬件实现">硬件实现</h2><p>不同的处理器架构实现内存屏障的方式不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; x86/x64<br>MFENCE  ; 全屏障<br>LFENCE  ; 读屏障<br>SFENCE  ; 写屏障<br><br>; ARM<br>DMB     ; 数据内存屏障<br>DSB     ; 数据同步屏障<br>ISB     ; 指令同步屏障<br></code></pre></td></tr></table></figure><h2 id="与内存顺序的关系">与内存顺序的关系</h2><p>Rust 的内存顺序实际上是通过内存屏障来实现的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Release 写入会插入 Store Barrier</span><br>atomic.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">42</span>, Ordering::Release);  <span class="hljs-comment">// 编译器会在此处插入 Store Barrier</span><br><br><span class="hljs-comment">// Acquire 读取会插入 Load Barrier</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = atomic.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire);  <span class="hljs-comment">// 编译器会在此处插入 Load Barrier</span><br><br><span class="hljs-comment">// SeqCst 操作会插入 Full Barrier</span><br>atomic.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">42</span>, Ordering::SeqCst);  <span class="hljs-comment">// 编译器会在此处插入 Full Barrier</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>注意：直接使用内存屏障是非常底层的操作，通常我们应该使用 Rust提供的高级抽象（如原子类型和它们的内存顺序）来实现同步。内存屏障的知识主要用于理解这些高级抽象的工作原理。</p>          </div><h1 id="go-atomic">Go Atomic</h1><p>熟悉 Go 语言的读者应该会意识到在使用 Go语言的原子类型的时候，好像都没见过 Memory Order 这个东西，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>data := atomic.Int64&#123;&#125;<br>data.Add(<span class="hljs-number">1</span>)<br>data.And(<span class="hljs-number">2</span>)<br>data.Or(<span class="hljs-number">3</span>)<br>data.Swap(<span class="hljs-number">4</span>)<br>data.Store(<span class="hljs-number">5</span>)<br>data.Load()<br>data.CompareAndSwap(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <ahref="https://github.com/golang/go/blob/release-branch.go1.23/src/sync/atomic/doc.go">atomic/doc.go</a>源码中我们可以看到这段话：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The load and store operations, implemented by the LoadT and StoreT</span><br><span class="hljs-comment">// functions, are the atomic equivalents of &quot;return *addr&quot; and</span><br><span class="hljs-comment">// &quot;*addr = val&quot;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// In the terminology of [the Go memory model], if the effect of</span><br><span class="hljs-comment">// an atomic operation A is observed by atomic operation B,</span><br><span class="hljs-comment">// then A “synchronizes before” B.</span><br><span class="hljs-comment">// Additionally, all the atomic operations executed in a program</span><br><span class="hljs-comment">// behave as though executed in some sequentially consistent order.</span><br><span class="hljs-comment">// This definition provides the same semantics as</span><br><span class="hljs-comment">// C++&#x27;s sequentially consistent atomics and Java&#x27;s volatile variables.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// [the Go memory model]: https://go.dev/ref/mem</span><br></code></pre></td></tr></table></figure><p>Go语言设计者认为让程序员选择内存序会增加复杂性和出错的可能，所以为了程序的简单性和可预测性，直接就<strong>使用了最安全的<code>Seq-Cst</code> 内存顺序</strong>了。</p><p><a href="https://go.dev/ref/mem">the Go memory model</a>中还提了一句：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">If you must read the rest of this document to understand the behavior of your program, you are being too clever.<br>Don&#x27;t be clever.<br></code></pre></td></tr></table></figure><p>这也呼应了 Go 的设计理念：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Share memory by communicating; don&#x27;t communicate by sharing memory.<br></code></pre></td></tr></table></figure><p>所以总结一下：</p><ol type="1"><li>Go 的原子操作采用了最强的顺序一致性内存序；</li><li>这是一个有意识的设计选择，为了简单性和可预测性；</li><li>如果你需要更细粒度的内存序控制，那么 Go 可能不是最佳选择；</li><li>Go 更推荐使用 channels 和其他同步原语来进行并发控制。</li></ol><h1 id="参考">参考</h1><ul><li><a href="https://marabos.nl/atomics/memory-ordering.html">RustAtomics And Lock</a></li><li><ahref="https://mp.weixin.qq.com/s/t5_Up2YZEZt1NLbvgYz9FQ">聊一聊内存模型与内存序</a></li><li><ahref="https://en.cppreference.com/w/cpp/atomic/memory_order">cppreference</a></li><li><a href="https://go.dev/ref/mem">the Go memory model</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 底层原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Rust</tag>
      
      <tag>内存顺序</tag>
      
      <tag>内存屏障</tag>
      
      <tag>并发控制</tag>
      
      <tag>Atomic</tag>
      
      <tag>Happens-Before</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KCP 源码分析与原理总结</title>
    <link href="/2024/06/12/kcp/"/>
    <url>/2024/06/12/kcp/</url>
    
    <content type="html"><![CDATA[<h1 id="序言">序言</h1><p>本文很大部分参考了 <ahref="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP协议的原理和实现</a>，非常感谢该文作者的讲解。本文再此基础上，加入了一些笔者的思考和分析图示，以期更好地理解KCP 的底层原理。</p><h1 id="结论先行">结论先行</h1><p>KCP 是一个快速可靠协议，能以比 TCP 浪费 10%-20%的带宽的代价，换取平均延迟降低30%-40%，且最大延迟降低三倍的传输效果。</p><p>TCP 是为流量设计的（每秒内可以传输多少 KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以 10%-20%带宽浪费的代价换取了比 TCP 快 30%-40% 的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而 KCP是水流湍急的小激流。</p><h2 id="kcp-增加的带宽在哪里增加的速度又在哪里">KCP增加的带宽在哪里？增加的速度又在哪里？</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612111337839.png"alt="为什么 KCP 能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%？" /><figcaption aria-hidden="true">为什么 KCP 能以比 TCP 浪费 10%-20%的带宽的代价，换取平均延迟降低 30%-40%？</figcaption></figure><h2 id="kcp-核心特性">KCP 核心特性</h2><p><strong>快速重传</strong>： KCP支持快速重传机制，不像 TCP那样依赖超时重传。KCP可以根据接收方返回的确认信息快速判断哪些数据包已经丢失，并迅速进行重传。</p><p><strong>选择性确认（Selective Acknowledgment, SACK）</strong>： KCP支持SACK，这允许接收端告知发送端哪些包已经收到，从而仅重传未被确认接收的数据包，减少不必要的重传。</p><p><strong>无连接操作</strong>： 基于 UDP 的实现使得 KCP在传输数据前不需要像 TCP那样进行三次握手建立连接，这减少了初始的延迟，并使其能在连接性较差的网络环境下更加灵活和快速。</p><p><strong>拥塞控制</strong>： KCP 实现了类似 TCP的拥塞控制算法，但更为简化，能够快速适应网络条件的变化，如带宽波动和丢包。</p><p><strong>流量控制</strong>： KCP允许调整发送和接收的窗口大小，使得发送方可以根据接收方的处理能力和网络条件调整数据发送速率，优化网络利用率和减少拥塞。</p><p><strong>可配置的传输策略</strong>： KCP允许用户根据应用需求调整内部参数，如传输间隔、窗口大小等，以达到最优的传输效率和延迟。</p><p><strong>前向错误校正（Forward Error Correction, FEC）</strong>： KCP还可以结合使用 FEC技术，通过发送额外的冗余数据来恢复丢失的包，进一步提高在高丢包环境下的数据传输可靠性。</p><h2 id="为什么-tcp-做不到-kcp-这样">为什么 TCP 做不到 KCP 这样？</h2><p>TCP作为一种成熟且广泛使用的传输协议，在设计上注重可靠性和通用性，因此在拥塞控制和流量控制方面相对保守，以确保在各种网络条件下都能稳定运行。然而，这些设计上的保守性也导致了TCP 在某些情况下的灵活性和自适应性不如 KCP。</p><table><thead><tr class="header"><th>特性类别</th><th>协议</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>拥塞控制机制</td><td>TCP</td><td>固定算法（慢启动、拥塞避免等），保守的调整策略（指数和线性增长）</td></tr><tr class="even"><td></td><td>KCP</td><td>灵活算法，动态调整策略，快速调整窗口大小</td></tr><tr class="odd"><td>重传机制的延迟</td><td>TCP</td><td>固定重传间隔（RTO），多次确认触发重传</td></tr><tr class="even"><td></td><td>KCP</td><td>快速重传，选择性重传，减少重传延迟</td></tr><tr class="odd"><td>流量控制</td><td>TCP</td><td>固定流量控制（依赖接收窗口和发送窗口），通用性设计</td></tr><tr class="even"><td></td><td>KCP</td><td>自适应流量控制，应用层反馈调整发送窗口和重传策略</td></tr><tr class="odd"><td>应用场景</td><td>TCP</td><td>广泛应用于各种网络环境，标准化要求高</td></tr><tr class="even"><td></td><td>KCP</td><td>优化特定场景（如高丢包率和高延迟网络），灵活实现</td></tr></tbody></table><h3 id="拥塞控制机制的固定性">1. 拥塞控制机制的固定性</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定算法</strong>：TCP 的拥塞控制算法，如慢启动（SlowStart）、拥塞避免（Congestion Avoidance）、快速重传（FastRetransmit）和快速恢复（FastRecovery），在设计时考虑了广泛的兼容性和可靠性。这些算法虽然有效，但其调整机制相对固定，响应速度较慢。</li><li><strong>保守的调整策略</strong>：TCP的拥塞控制算法采用了保守的调整策略，例如指数增长和线性增长，这在高丢包率或高延迟网络中，可能会导致拥塞窗口（cwnd）增长速度较慢，影响传输效率。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>灵活算法</strong>：KCP的拥塞控制机制更为灵活，可以根据实时网络状况进行快速调整。例如，KCP的快速重传和选择性重传机制，使其能更快速地响应网络丢包情况。</li><li><strong>动态调整策略</strong>：KCP的拥塞窗口调整更为灵活，可以根据网络状况快速增加或减少窗口大小，提高传输效率。</li></ul><h3 id="重传机制的延迟">2. 重传机制的延迟</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定重传间隔</strong>：TCP使用固定的重传超时（RTO），并随着每次重传逐渐增加（指数回退），这种保守的重传机制在高延迟和高丢包率网络中可能导致重传延迟较长。</li><li><strong>多次确认触发重传</strong>：TCP 的快速重传需要等待三个重复的ACK 才能触发，这在丢包率较高的情况下，可能会导致较长的延迟。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>快速重传</strong>：KCP在检测到丢包后立即进行重传，而不需要等待多个重复的ACK，这显著减少了重传延迟。</li><li><strong>选择性重传</strong>：KCP只重传丢失的数据包，而不是所有未确认的数据包，减少了不必要的重传开销。</li></ul><h3 id="流量控制的灵活性">3. 流量控制的灵活性</h3><p><strong>TCP</strong>：</p><ul><li><strong>固定流量控制</strong>：TCP的流量控制主要依赖于接收窗口（rwnd）和发送窗口（swnd），在处理突发流量或变化较大的网络条件时，调整速度较慢。</li><li><strong>通用性设计</strong>：TCP作为一种通用协议，其设计必须兼顾各种网络环境，因此在流量控制上相对保守，以确保在任何环境下都能稳定运行。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>自适应流量控制</strong>：KCP的流量控制机制可以根据实际应用需求进行更细粒度的调整。例如，KCP可以根据延迟抖动、丢包率等动态参数调整发送速率，确保在不同网络条件下都能保持高效传输。</li><li><strong>应用层反馈</strong>：KCP可以根据应用层的实时反馈，动态调整发送窗口和重传策略，进一步优化传输效率。</li></ul><h3 id="应用场景的差异">4. 应用场景的差异</h3><p><strong>TCP</strong>：</p><ul><li><strong>广泛应用</strong>：TCP设计用于广泛的网络环境，包括稳定的有线网络和不稳定的无线网络，因此其机制必须足够通用和保守，保证在各种情况下的可靠性。</li><li><strong>标准化要求</strong>：作为互联网的基础协议，TCP的各项机制经过严格标准化，任何修改都需要广泛测试和验证，以确保不会影响现有网络的稳定性。</li></ul><p><strong>KCP</strong>：</p><ul><li><strong>特定优化</strong>：KCP设计初衷是优化特定场景下的传输性能，特别是高丢包率和高延迟网络，因此在设计上更加灵活，能够根据实时网络状况进行调整。</li><li><strong>灵活实现</strong>：KCP可以根据具体应用需求进行优化，例如在实时通信和在线游戏等场景中，灵活的流量控制和快速重传机制显著提升了传输效率。</li></ul><h3 id="结论">结论</h3><p>虽然 TCP在拥塞控制和流量控制方面具备基本的动态调整能力，但其保守的设计和标准化要求使得其在高丢包率和高延迟网络中的适应性和灵活性不如KCP。KCP通过灵活的拥塞控制、快速重传和自适应流量控制机制，能够更有效地应对不同网络条件下的传输需求，提供更高效的传输性能。</p><h2 id="kcp-一定比-tcp-快吗">KCP 一定比 TCP 快吗？</h2><p><font color="red">不一定</font>。KCP 并不一定在所有情况下都比 TCP快。虽然 KCP在某些特定网络环境（如高丢包率和高延迟的网络）中表现更优异，但在某些情况下，TCP可能更合适。</p><h3 id="网络环境">1. 网络环境</h3><p><strong>高丢包率和高延迟网络</strong>：</p><ul><li><strong>KCP</strong>：KCP通过快速重传和选择性重传机制，以及动态调整的窗口和重传间隔，能够更好地应对高丢包率和高延迟网络，减少传输延迟，提高传输效率。</li><li><strong>TCP</strong>：TCP的重传机制和保守的拥塞控制在这种环境中可能导致较高的延迟和较低的带宽利用率。</li></ul><p><strong>低丢包率和低延迟网络</strong>：</p><ul><li><strong>KCP</strong>：在稳定的低丢包率和低延迟网络中，KCP的频繁重传和控制报文可能会导致额外的带宽开销，未必有明显的性能优势。</li><li><strong>TCP</strong>：TCP在这种环境中表现稳定，且由于其带宽开销较小，可能比 KCP 更高效。</li></ul><h3 id="带宽利用率">2. 带宽利用率</h3><p><strong>带宽充足的网络</strong>：</p><ul><li><strong>KCP</strong>：KCP由于其频繁的重传和控制报文，可能会占用更多的带宽，但如果带宽充足，这种开销对整体性能影响较小，且其低延迟优势可能更明显。</li><li><strong>TCP</strong>：TCP的带宽利用率较高，适合带宽充足的环境。</li></ul><p><strong>带宽受限的网络</strong>：</p><ul><li><strong>KCP</strong>：KCP的额外带宽开销在带宽受限的网络中可能会显著影响整体传输效率。</li><li><strong>TCP</strong>：TCP的较低带宽开销使其在带宽受限的环境中更有优势。</li></ul><h3 id="应用场景">3. 应用场景</h3><p><strong>实时应用</strong>（如在线游戏、视频会议）：</p><ul><li><strong>KCP</strong>：KCP的低延迟和快速响应能力使其非常适合实时应用，在这些场景中，传输的及时性比带宽利用率更重要。</li><li><strong>TCP</strong>：TCP 在这些场景中的表现可能不如KCP，特别是在高丢包率和高延迟的网络中。</li></ul><p><strong>非实时应用</strong>（如文件传输、网页浏览）：</p><ul><li><strong>KCP</strong>：KCP 在这些场景中可能不如 TCP高效，特别是在网络稳定且带宽有限的情况下。</li><li><strong>TCP</strong>：TCP的可靠性和高带宽利用率使其非常适合非实时应用。</li></ul><h3 id="实现和配置">4. 实现和配置</h3><p><strong>实现复杂性</strong>：</p><ul><li><strong>KCP</strong>：实现和配置 KCP 可能比 TCP更复杂，需要根据具体应用和网络环境进行优化和调整。</li><li><strong>TCP</strong>：TCP是一个成熟的协议，系统和库的支持较好，配置和使用相对简单。</li></ul><h3 id="总结">总结</h3><p>KCP 在某些特定环境和应用场景中确实比 TCP更快，尤其是高丢包率和高延迟的网络环境，以及对低延迟要求较高的实时应用。但在网络稳定、带宽有限或非实时应用场景中，TCP可能表现更好。因此，选择使用 KCP 还是 TCP应根据具体的网络条件和应用需求进行权衡。</p><h1 id="前置准备">前置准备</h1><p>笔者不想那么快就贴出大段大段的代码进行分析，这可能会使读者不知所云。为了更好地阐述KCP的底层原理，笔者的设想是先对原理部分进行概要总结，然后再带着这些结论去分析源码，进一步填充里面的边角细节。</p><p>但是呢，为了更好地理解 KCP的原理，又不得不对涉及源码的一些重要设计，为了避免在原理分析阶段，对源码进行过多的涉及，笔者决定添加这单独的一章内容，对KCP 的“接口设计”、“报文段”、“KCP控制块”以及“队列和缓冲区”先进行简要概述，以辅助读者更好地理解后续的内容。</p><h2 id="接口设计">接口设计</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612171839051.png"alt="KCP 工作简约图" /><figcaption aria-hidden="true">KCP 工作简约图</figcaption></figure><p>在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h">kcp.h</a>文件中，定义了 KCP 最核心的几个接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个新的 KCP 控制对象</span><br>ikcpcb* <span class="hljs-title function_">ikcp_create</span><span class="hljs-params">(IUINT32 conv, <span class="hljs-type">void</span> *user)</span>;<br><br><span class="hljs-comment">// 释放一个 KCP 控制对象。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_release</span><span class="hljs-params">(ikcpcb *kcp)</span>;<br><br><span class="hljs-comment">// 设置 KCP 的输出回调函数，这个回调函数在 KCP 需要发送数据时被调用。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_setoutput</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">int</span> (*output)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> len, </span><br><span class="hljs-params">ikcpcb *kcp, <span class="hljs-type">void</span> *user))</span>;<br><br><span class="hljs-comment">// 从 KCP 的接收队列中接收数据，用于上层从 KCP 中读取数据。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_recv</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> len)</span>;<br><br><span class="hljs-comment">// 向 KCP 的发送队列中添加数据，用于上层向 KCP 发送数据，KCP 会管理这些数据并负责其可靠传输。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_send</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> len)</span>;<br><br><span class="hljs-comment">// 更新 KCP 的内部状态，通常需要定期调用。</span><br><span class="hljs-comment">// 这个函数负责处理 KCP 的超时、重传等操作，需要在一定的时间间隔内反复调用（通常每 10-100 毫秒）。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_update</span><span class="hljs-params">(ikcpcb *kcp, IUINT32 current)</span>;<br><br><span class="hljs-comment">// 判断是否要调用 ikcp_update</span><br>IUINT32 <span class="hljs-title function_">ikcp_check</span><span class="hljs-params">(<span class="hljs-type">const</span> ikcpcb *kcp, IUINT32 current)</span>;<br><br><span class="hljs-comment">// 处理接收到的低层数据包（例如 UDP 包）。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ikcp_input</span><span class="hljs-params">(ikcpcb *kcp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">long</span> size)</span>;<br><br><span class="hljs-comment">// 将缓冲区可以发送的包发送出去，会在 ikcp_update 中被调用。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_flush</span><span class="hljs-params">(ikcpcb *kcp)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>ikcp_create</code>:</p><ul><li><code>conv</code>:会话标识符，用于标识两个端点之间的连接。这个标识符在两个通信端点之间必须一致。</li><li><code>user</code>: 用户数据指针，可以传递任意用户数据，这个数据在KCP 的 <code>output</code> 回调中会被传递回去。</li><li><strong>返回值</strong>: 一个指向新创建的 KCP控制块（<code>ikcpcb</code>）的指针。</li></ul></li><li><p><code>ikcp_release</code>: 释放一个 KCP 控制对象。</p></li><li><p><code>ikcp_setoutput</code>: 设置 KCP 的输出回调函数。</p><ul><li><p><code>output</code>: 输出回调函数指针。这个回调函数在 KCP需要发送数据时被调用。</p><ul><li><code>buf</code>: 要发送的数据缓冲区。</li><li><code>len</code>: 数据长度。</li><li><code>kcp</code>: 当前的 KCP 对象。</li><li><code>user</code>: 用户数据。</li></ul><p>通过这个回调，KCP 可以将要发送的数据传递给下层的网络层，比如 UDP套接字。</p></li></ul></li><li><p><code>ikcp_recv</code>: 从 KCP 的接收队列中接收数据。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>buffer</code>: 用户提供的缓冲区，用于存储接收到的数据。</li><li><code>len</code>: 缓冲区的长度。</li><li><strong>返回值</strong>:成功接收的数据大小；如果没有数据可接收，返回负值（例如，EAGAIN）。</li></ul><p>这个函数用于上层从 KCP 中读取数据。</p></li><li><p><code>ikcp_send</code>: 向 KCP 的发送队列中添加数据。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>buffer</code>: 要发送的数据缓冲区。</li><li><code>len</code>: 数据的长度。</li><li><strong>返回值</strong>:成功发送的数据大小；如果发送失败，返回负值。</li></ul><p>这个函数用于上层向 KCP 发送数据，KCP会管理这些数据并负责其可靠传输。</p></li><li><p><code>ikcp_update</code>: 更新 KCP的内部状态，通常需要定期调用。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>current</code>: 当前的时间戳（以毫秒为单位）。</li></ul><p>这个函数负责处理 KCP的超时、重传等操作，需要在一定的时间间隔内反复调用（通常每 10-100毫秒）。</p></li><li><p><code>ikcp_input</code>: 处理接收到的低层数据包（例如 UDP包）。</p><ul><li><code>kcp</code>: KCP 控制对象的指针。</li><li><code>data</code>: 收到的数据缓冲区。</li><li><code>size</code>: 数据的长度。</li><li><strong>返回值</strong>:成功处理的数据大小；如果处理失败，返回负值。</li></ul></li><li><p><code>ikcp_flush</code>: 刷新待发送的数据。</p></li></ul><p>其中最重要的是这 4 个：</p><ul><li><code>ikcp_send</code>: 将数据放在发送队列中等待发送。</li><li><code>ikcp_recv</code>: 从接收队列中读取数据。</li><li><code>ikcp_input</code>:读取下层协议输入数据，解析报文段，如果是数据，就将数据放入接收缓冲区，如果是ACK，就在发送缓冲区中标记对应的报文段已送达。</li><li><code>ikcp_flush</code>:调用输出回调将发送缓冲区的数据发送出去。</li></ul><p>这里就先简要介绍到这里，后面在源码分析篇章再对这些接口进行详细分析。</p><h2 id="报文段">报文段</h2><p>KCP 的报文段大小为 24 字节，结构如下图所示：</p><p><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612172557464.png" alt="KCP 报文段" style="zoom: 33%;" /></p><p>每个字段的含义如下：</p><ul><li><code>conv</code>: 连接标识</li><li><code>cmd</code>：报文类型</li><li><code>frg</code>：分片数量，表示随后还有多少个报文属于同一个包</li><li><code>wnd</code>：发送方剩余接收窗口的大小</li><li><code>ts</code>：时间戳</li><li><code>sn</code>：报文编号</li><li><code>una</code>：发送方的接收缓冲区中最小还未收到的报文段的编号，也就是说，比它小的报文段都已全部接收</li><li><code>len</code>：数据段长度</li><li><code>data</code>：数据段，只有数据报文会有这个字段</li></ul><p>其中 <code>cmd</code> 共有 4 种报文类型：</p><ul><li>数据报文：IKCP_CMD_PUSH</li><li>确认报文：IKCP_CMD_ACK</li><li>窗口探测报文：IKCP_CMD_WASK 询问对端剩余接收窗口的大小</li><li>窗口通知报文：IKCP_CMD_WINS 通知对端剩余接收窗口的大小</li></ul><p>在 KCP 中，报文段结构定义在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h">kcp.h</a>文件中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPSEG</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">node</span>;</span><br>IUINT32 conv;<br>IUINT32 cmd;<br>IUINT32 frg;<br>IUINT32 wnd;<br>IUINT32 ts;<br>IUINT32 sn;<br>IUINT32 una;<br>IUINT32 len;<br>IUINT32 resendts;<br>IUINT32 rto;<br>IUINT32 fastack;<br>IUINT32 xmit;<br><span class="hljs-type">char</span> data[<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>IKCPSEG</code> 结构还多出了几个字段，这是为了支持 KCP协议的可靠性和效率：</p><ul><li><code>resendts</code>:记录报文的下次重传时间，用于实现重传机制。如果报文在一定时间内没有被确认收到，就会在这个时间戳之后被重新发送。</li><li><code>rto</code>: 表示当前报文的重传超时时间（RTT的估计值）。用于计算每个报文的重传时间，如果超过 <code>rto</code>时间没有收到 ACK，会触发重传。</li><li><code>fastack</code>:快速重传计数，记录该报文被跳过的次数。如果一个报文的 ACK连续接收到多个对同一报文的确认，而不是新的报文，会增加这个计数，用于实现快速重传机制。</li><li><code>xmit</code>:记录报文已经被发送的次数。用于统计一个报文的重传次数，帮助判断传输的可靠性。如果操作<code>dead_link</code> 次，则会判断为连接失效，KCP 会断开连接。</li><li><code>node</code>: 链表节点，用于将多个 <code>IKCPSEG</code>结构体链接在一起。KCP 的队列和缓冲区都是循环双链表结构。</li></ul><p>这些字段共同作用，帮助 KCP 实现以下功能：</p><ul><li><strong>可靠性</strong>：通过 <code>sn</code>、<code>una</code> 和<code>ack</code> 确保数据包按顺序接收和重传。</li><li><strong>流量控制</strong>：通过 <code>wnd</code>控制数据流量，避免接收方过载。</li><li><strong>高效传输</strong>：通过 <code>resendts</code> 和<code>rto</code> 进行超时和重传控制，<code>fastack</code>提供快速重传机制。</li><li><strong>灵活管理</strong>：使用链表节点 <code>node</code>组织数据，便于内部管理。</li></ul><h2 id="kcp-控制块-ikcpcb">KCP 控制块 ikcpcb</h2><p>上面我们提到的 <code>ikcp_create</code> 和 <code>ikcp_release</code>就是对 KCP 控制块 <code>ikcpcb</code> 的创建和释放，每个 KCP连接都对应一个 KCP 控制块。它定义在 <ahref="https://github.com/skywind3000/kcp/blob/master/ikcp.h#L343">kcp.h</a>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPCB</span></span><br><span class="hljs-class">&#123;</span><br>IUINT32 conv, mtu, mss, state;<br>IUINT32 snd_una, snd_nxt, rcv_nxt;<br>IUINT32 ts_recent, ts_lastack, ssthresh;<br>IINT32 rx_rttval, rx_srtt, rx_rto, rx_minrto;<br>IUINT32 snd_wnd, rcv_wnd, rmt_wnd, cwnd, probe;<br>IUINT32 current, interval, ts_flush, xmit;<br>IUINT32 nrcv_buf, nsnd_buf;<br>IUINT32 nrcv_que, nsnd_que;<br>IUINT32 nodelay, updated;<br>IUINT32 ts_probe, probe_wait;<br>IUINT32 dead_link, incr;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_buf</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_buf</span>;</span><br>IUINT32 *acklist;<br>IUINT32 ackcount;<br>IUINT32 ackblock;<br><span class="hljs-type">void</span> *user;<br><span class="hljs-type">char</span> *buffer;<br><span class="hljs-type">int</span> fastresend;<br><span class="hljs-type">int</span> fastlimit;<br><span class="hljs-type">int</span> nocwnd, stream;<br><span class="hljs-type">int</span> logmask;<br><span class="hljs-type">int</span> (*output)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> len, <span class="hljs-keyword">struct</span> IKCPCB *kcp, <span class="hljs-type">void</span> *user);<br><span class="hljs-type">void</span> (*writelog)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-built_in">log</span>, <span class="hljs-keyword">struct</span> IKCPCB *kcp, <span class="hljs-type">void</span> *user);<br>&#125;;<br></code></pre></td></tr></table></figure><p>字段的含义如下，读者可在后续分析过程回过来查阅：</p><table><thead><tr class="header"><th>字段名</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>conv</code></td><td>连接标识符，用于识别一个特定的会话。</td></tr><tr class="even"><td><code>mtu</code></td><td>最大传输单元（Maximum TransmissionUnit），表示网络层传输数据包的最大字节数。</td></tr><tr class="odd"><td><code>mss</code></td><td>最大报文段长度（Maximum SegmentSize），表示应用层传输数据的最大字节数。</td></tr><tr class="even"><td><code>state</code></td><td>连接状态，标识当前的传输状态。</td></tr><tr class="odd"><td><code>snd_una</code></td><td>未确认的发送序号，表示最早未确认的包的序号。</td></tr><tr class="even"><td><code>snd_nxt</code></td><td>下一个发送序号，表示即将发送的包的序号。</td></tr><tr class="odd"><td><code>rcv_nxt</code></td><td>下一个接收序号，表示期望接收的下一个包的序号。</td></tr><tr class="even"><td><code>ts_recent</code></td><td>最近的时间戳，用于延迟测量。</td></tr><tr class="odd"><td><code>ts_lastack</code></td><td>最近的确认时间戳，用于 RTT 计算。</td></tr><tr class="even"><td><code>ssthresh</code></td><td>拥塞避免的慢启动阈值。</td></tr><tr class="odd"><td><code>rx_rttval</code></td><td>RTT 的偏差，用于计算 RTT 的波动。</td></tr><tr class="even"><td><code>rx_srtt</code></td><td>平滑的 RTT 值，用于计算平均 RTT。</td></tr><tr class="odd"><td><code>rx_rto</code></td><td>重新传输超时时间，根据 RTT 动态调整。</td></tr><tr class="even"><td><code>rx_minrto</code></td><td>最小的重新传输超时时间。</td></tr><tr class="odd"><td><code>snd_wnd</code></td><td>发送窗口大小，控制发送流量的窗口。</td></tr><tr class="even"><td><code>rcv_wnd</code></td><td>接收窗口大小，控制接收流量的窗口。</td></tr><tr class="odd"><td><code>rmt_wnd</code></td><td>远端窗口大小，表示对方接收窗口的大小。</td></tr><tr class="even"><td><code>cwnd</code></td><td>拥塞窗口大小，控制发送流量的窗口，用于拥塞控制。</td></tr><tr class="odd"><td><code>probe</code></td><td>探测标志，表示是否需要进行窗口探测。</td></tr><tr class="even"><td><code>current</code></td><td>当前的时间戳。</td></tr><tr class="odd"><td><code>interval</code></td><td>刷新间隔时间，表示定期刷新 KCP 状态的间隔。</td></tr><tr class="even"><td><code>ts_flush</code></td><td>下次刷新时间戳，用于确定何时执行下一次状态刷新。</td></tr><tr class="odd"><td><code>xmit</code></td><td>发送次数，表示数据包重传的次数。</td></tr><tr class="even"><td><code>nrcv_buf</code></td><td>接收缓冲区的数据包数量。</td></tr><tr class="odd"><td><code>nsnd_buf</code></td><td>发送缓冲区的数据包数量。</td></tr><tr class="even"><td><code>nrcv_que</code></td><td>接收队列中的数据包数量。</td></tr><tr class="odd"><td><code>nsnd_que</code></td><td>发送队列中的数据包数量。</td></tr><tr class="even"><td><code>nodelay</code></td><td>延迟模式标志，表示是否启用无延迟模式。</td></tr><tr class="odd"><td><code>updated</code></td><td>更新标志，表示是否需要更新 KCP 状态。</td></tr><tr class="even"><td><code>ts_probe</code></td><td>下次探测时间戳，用于窗口探测。</td></tr><tr class="odd"><td><code>probe_wait</code></td><td>探测等待时间，表示等待多长时间后进行下一次窗口探测。</td></tr><tr class="even"><td><code>dead_link</code></td><td>死链标志，表示连接是否已经失效。</td></tr><tr class="odd"><td><code>incr</code></td><td>增量，用于控制流量的增加速率。</td></tr><tr class="even"><td><code>snd_queue</code></td><td>发送队列，用于存储待发送的数据包。</td></tr><tr class="odd"><td><code>rcv_queue</code></td><td>接收队列，用于存储待处理的数据包。</td></tr><tr class="even"><td><code>snd_buf</code></td><td>发送缓冲区，用于存储已经发送但未确认的数据包。</td></tr><tr class="odd"><td><code>rcv_buf</code></td><td>接收缓冲区，用于存储已经接收到但未处理的数据包。</td></tr><tr class="even"><td><code>acklist</code></td><td>确认列表，用于存储待发送的确认序号。</td></tr><tr class="odd"><td><code>ackcount</code></td><td>确认计数，表示确认列表中的条目数量。</td></tr><tr class="even"><td><code>ackblock</code></td><td>确认块大小，表示确认列表的内存分配大小。</td></tr><tr class="odd"><td><code>user</code></td><td>用户数据指针，用于存储用户自定义的数据。</td></tr><tr class="even"><td><code>buffer</code></td><td>缓冲区，用于临时存储发送的数据。</td></tr><tr class="odd"><td><code>fastresend</code></td><td>快速重传标志，表示启用快速重传功能。</td></tr><tr class="even"><td><code>fastlimit</code></td><td>快速重传限制，表示在一个 RTT 内允许的最大重传次数。</td></tr><tr class="odd"><td><code>nocwnd</code></td><td>无拥塞窗口控制标志，表示是否禁用拥塞窗口控制。</td></tr><tr class="even"><td><code>stream</code></td><td>流模式标志，表示是否启用流模式。</td></tr><tr class="odd"><td><code>logmask</code></td><td>日志掩码，用于控制日志输出的级别。</td></tr><tr class="even"><td><code>output</code></td><td>发送数据回调函数，用于发送数据。</td></tr><tr class="odd"><td><code>writelog</code></td><td>日志回调函数，用于输出日志。</td></tr></tbody></table><h2 id="队列和缓冲区">队列和缓冲区</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IKCPCB</span></span><br><span class="hljs-class">&#123;</span><br>  ...<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_queue</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">snd_buf</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> <span class="hljs-title">rcv_buf</span>;</span><br>  ...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IQUEUEHEAD</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">prev</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>KCP中队列和缓冲区都是循环双链表，链表由宏实现，笔者并不擅长，所以本文就不探讨该链表的实现了，有数据结构基础的笔者应该很好理解这一块。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612175626865.png"alt="队列和缓冲区的实现：循环双链表" /><figcaptionaria-hidden="true">队列和缓冲区的实现：循环双链表</figcaption></figure><p>队列和缓冲区是 KCP最核心的部分，它们的作用流程大概如下图所示，读者可以自行阅读尝试理解，后续我们会进行详细的分析。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612175950432.png"alt="KCP 队列和缓冲区作用流程" /><figcaption aria-hidden="true">KCP 队列和缓冲区作用流程</figcaption></figure><h1 id="原理分析">原理分析</h1><p>这一节我们详细讨论 KCP 的整个 ARQ流程。首先我们会对整体流程进行简要概述，然后详细讨论滑动窗口中的发送和接收过程，接着讨论超时重传和快速重传，在这之后我们会将KCP 和 TCP 的重传策略进行简单对比，最后介绍一下拥塞控制策略。</p><h2 id="整体流程">1. 整体流程</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612192523848.png"alt="KCP 全流程" /><figcaption aria-hidden="true">KCP 全流程</figcaption></figure><p>KCP 的全流程如上图所示：</p><ol type="1"><li>发送方调用 <code>ikcp_send</code>将发送数据，这个时候会创建报文段实例，并放入 <code>snd_queue</code>发送队列中。</li><li>KCP 会定时调用 <code>ikcp_update</code> 判断是否要调用<code>ikcp_flush</code>。</li><li>调用 <code>ikcp_flush</code> 时会将合适的报文段放入<code>snd_buf</code> 缓冲区中，具体包括：<ol type="1"><li>发送 ACK 列表中所有 ACK；</li><li>根据是否需要发送窗口探测和通知报文，需要则发；</li><li>根据发送窗口大小，将适量的报文段从 <code>snd_queue</code> 移入<code>snd_buf</code> 中；</li><li>发送 <code>snd_buf</code>中的报文，包括<strong>新加入的</strong>、<strong>RTO 内未收到ACK</strong> 的和 <strong>ACK 失序若干次</strong>的；</li><li>根据丢包情况计算 <code>ssthresh</code> 和 <code>cwnd</code>。</li></ol></li><li>发送的时候会调用由 <code>ikcp_setoutput</code>设置的回调函数，将数据发送到对端。</li><li>接收方收到数据后，会调用 <code>ikcp_input</code>，将数据放入<code>rcv_buf</code> 缓冲区，具体包括：<ol type="1"><li>根据所有报文的 una 将相应的报文标记为已送达；</li><li>如果是 ACK，就将相应的报文标记为已送达；</li><li>如果是数据报文，就将它放入 <code>rcv_buf</code>，然后将<code>rcv_buf</code> 中顺序正确的报文移入 <code>rcv_queue</code>接收队列中，接着将相关信息插入 ACK 列表，在稍后的<code>ikcp_flush</code> 中会发送相应的 ACK；</li><li>如果是窗口探测报文，就标记“需要发送窗口通知”，在稍后的<code>ikcp_flush</code> 中会发送窗口通知报文；</li><li>包括窗口通知报文在内的所有报文都有 wnd 字段，据此更新 rmt_wnd；</li><li>根据 ACK 失序情况决定是否进行快速重传；</li><li>计算 cwnd。</li></ol></li><li>调用 <code>ikcp_recv</code> 从 <code>rcv_queue</code>中接收数据。</li></ol><h2 id="滑动窗口">2. 滑动窗口</h2><p>发送缓冲区 <code>snd_buf</code> 和接收缓冲区 <code>rcv_buf</code>中活动的报文都是在滑动窗口之中的。这对于我们理解 KCP的发送和接收流程非常重要，所有我们先从滑动窗口开始介绍。</p><p>滑动窗口实际是一个抽象的概念,不能简单地认为它是缓冲区的一部分，准确的说，滑动窗口是由队列加缓冲区共同组成的。</p><h3 id="发送">2.1 发送</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612193023604.png"alt="发送窗口" /><figcaption aria-hidden="true">发送窗口</figcaption></figure><p><code>snd_una</code> 和 <code>snd_nxt</code>会努力往<strong>右</strong>移动：</p><ol type="1"><li><code>ikcp_flush</code> 时，会从 <code>snd_queue</code>中取出报文插入到 <code>snd_nxt</code> 的位置上；</li><li>如果<code>snd_nxt - snd_una &gt;= cwnd</code>，则不允许新的报文插入；</li><li>当 <code>snd_una</code> 的 ACK 报文到达时，<code>snd_una</code>就会右移到第一个没有收到 ACK 报文的位置；</li></ol><p>发送窗口中未确认到达的报文何时重传？</p><ul><li>报文在一个 RTO 时间内仍未确认到达，就会重传。报文 RTO 初始值是rx_rto ，会持续增长，速率支持配置。</li></ul><h3 id="接收">2.2 接收</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612193238859.png"alt="接收窗口" /><figcaption aria-hidden="true">接收窗口</figcaption></figure><ol type="1"><li>每收到一个数据报文, 都会根据它的编号将它插入到 <code>rcv_buf</code>对应的位置中；</li><li>接着检查 <code>rcv_nxt</code> 能否向右移动,只有当报文的顺序正确且连续才能移动；</li><li>在上图的例子中由于 4 号报文的缺失, <code>rcv_nxt</code> 只能处于 4号位置等待，5, 6 号报文也不能移动到 <code>rcv_queue</code> 中；</li><li>等到 4 号报文到达后，才能将 4, 5, 6 号报文一并移动到<code>rcv_queue</code> 中，同时 <code>rcv_nxt</code> 会右移到 7号位置。</li></ol><h3 id="案例分析">2.3 案例分析</h3><p>我们举个简单的例子演示整个 ARQ的流程。下图中实线箭头表示数据报文，虚线箭头表示 ACK。</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/kcp_5.svg"alt="KCP ARQ 流程" /><figcaption aria-hidden="true">KCP ARQ 流程</figcaption></figure><p>① t1 时刻发送方发送 1 号报文, 1 号报文放入发送缓冲区中, snd_una 指向1, snd_nxt 指向 2.</p><p>② t2 至 t3 时刻发送方依次发送 2 至 3 号报文, snd_nxt 依次后移.</p><p>③ 1 号报文丢包.</p><p>④ t4, t5 时刻接收方收到 3 号和 2 号报文, 放入 rcv_buf 中; 随后回复 3号和 2 号 ACK. 此时由于 1 号报文缺失, rcv_nxt 始终指向 1.</p><p>⑤ 3 号 ACK 丢包.</p><p>⑥ t7 时刻发送方收到 2 号 ACK, 将 2 号报文标记为已送达. 此时由于 3 号ACK 丢包, 3 号报文未标记为已送达. 由于 1 号报文未确认送达, snd_una亦指向 1.</p><p>⑦ t8 时刻 1 号报文超时, 重传.</p><p>⑧ t9 时刻接收方收到 1 号报文, 放入 rcv_buf 中; 这时 1, 2, 3号报文顺序正确, rcv_nxt 右移到 4 号位置. 接收方回复 1 号 ACK, 同时带上una = 4.</p><p>⑨ t10 时刻发送方收到 1 号 ACK, 将 1 号报文标记为已送达. 同时 una 表明1, 2, 3 号报文均已送达, 因此也将 3 号报文标记为已送达. snd_una 移动到4.</p><h2 id="超时重传">3. 超时重传</h2><p>超时重传是当发送的数据包在预定时间内未被确认时，重新发送该数据包的机制。在KCP 中，这个时间由重新传输超时（RTO）决定。KCP 计算 RTO 初始值的方法是TCP 的标准方法, 规定在 <ahref="https://www.rfc-editor.org/rfc/rfc6298.html">RFC 6298</a> 中。</p><p>这里还是贴出源码讲比较直观：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">ikcp_update_ack</span><span class="hljs-params">(ikcpcb *kcp, IINT32 rtt)</span><br>&#123;<br>IINT32 rto = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (kcp-&gt;rx_srtt == <span class="hljs-number">0</span>) &#123;<br>kcp-&gt;rx_srtt = rtt;<br>kcp-&gt;rx_rttval = rtt / <span class="hljs-number">2</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">long</span> delta = rtt - kcp-&gt;rx_srtt;<br><span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>) delta = -delta;<br>kcp-&gt;rx_rttval = (<span class="hljs-number">3</span> * kcp-&gt;rx_rttval + delta) / <span class="hljs-number">4</span>;<br>kcp-&gt;rx_srtt = (<span class="hljs-number">7</span> * kcp-&gt;rx_srtt + rtt) / <span class="hljs-number">8</span>;<br><span class="hljs-keyword">if</span> (kcp-&gt;rx_srtt &lt; <span class="hljs-number">1</span>) kcp-&gt;rx_srtt = <span class="hljs-number">1</span>;<br>&#125;<br>rto = kcp-&gt;rx_srtt + _imax_(kcp-&gt;interval, <span class="hljs-number">4</span> * kcp-&gt;rx_rttval);<br>kcp-&gt;rx_rto = _ibound_(kcp-&gt;rx_minrto, rto, IKCP_RTO_MAX);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个计算过程笔者就不做详细介绍了，代码里面的公式读者可以尝试自行画图进行理解，这里就不花大篇幅画公式了，下面我尝试以更通俗易懂的话语解释RTO，只需要理解它在做什么，为什么这么做，就可以了，个人觉得对公式的细节可以暂且忽略。</p><h3 id="rto-计算目的">3.1 RTO 计算目的</h3><p>KCP 的 RTO计算是为了确定在多长时间内未收到确认（ACK）时，应该重新发送数据包。这段时间被称为重传超时时间（RTO）。计算RTO的目的是在网络条件变化的情况下，既能快速响应数据丢失，也能避免不必要的重传，从而保持高效的传输。</p><h3 id="rto-计算涉及的变量解释">3.2 RTO 计算涉及的变量解释</h3><p><strong>RTT 和 SRTT 的概念:</strong></p><ul><li>RTT（Round-Trip Time）:是从发送一个数据包到收到其确认（ACK）所花的时间。</li><li>SRTT（Smoothed RTT）: 是 RTT 的加权平均值，它代表了 RTT的一个更稳定的估计值。SRTT 的目的是减少 RTT 的短期波动对 RTO的影响。</li></ul><p><strong>RTT 变化值（RTTvariance）</strong>：网络传输时间并不总是固定的，有时会因为网络拥塞或其他原因出现波动。我们通过计算RTT 变化值（RTT variance）来估计这种波动的大小。</p><p><strong>为什么需要 SRTT 和 RTT 变化值：</strong></p><ul><li>SRTT 给我们一个平均的 RTT 估计值。</li><li>RTT 变化值告诉我们网络的波动性。如果波动很大，我们希望 RTO更大，以免因为短暂的网络延迟就触发不必要的重传。</li></ul><h3 id="rto-计算步骤">3.3 RTO 计算步骤</h3><p><strong>1. 初始化</strong>：初次计算时，我们没有历史 RTT值，所以直接用第一次测量的 RTT 来初始化 SRTT，并将 RTT 变化值设为 RTT的一半。</p><p><strong>2. 更新 SRTT 和 RTT 变化值</strong>:</p><ul><li>每次我们测量新的 RTT，就用它来更新 SRTT 和 RTT 变化值。</li><li>更新 SRTT：我们不直接替换旧的SRTT，而是用一个平滑的方式（即加权平均），使得 SRTT 逐渐靠近新RTT，但又不会剧烈变化。</li><li>更新 RTT 变化值：计算新的 RTT 与 SRTT 的差值，用这个差值来更新 RTT变化值，使其反映当前网络波动的大小。</li></ul><p><strong>3. 计算 RTO</strong>:</p><ul><li>用 SRTT 加上四倍的 RTT 变化值来计算 RTO，这样可以确保 RTO足够长，能涵盖大部分的网络波动。</li><li>我们还要确保 RTO 不小于一个最小值（<code>rx_minrto</code>），以防止RTO过小导致频繁重传；也不能大于一个最大值（<code>IKCP_RTO_MAX</code>），以防止RTO 过大影响响应速度。</li></ul><h3 id="rto-计算效果">4. RTO 计算效果</h3><ul><li><strong>稳定的传输</strong>: SRTT 提供了一个稳定的平均 RTT估计，使得 RTO 能适应网络的长期变化。</li><li><strong>适应网络波动</strong>: RTT 变化值使得 RTO能够应对网络的短期波动，减少因短暂延迟而导致的重传。</li><li><strong>快速响应</strong>: RTO设置合理后，能够在数据丢失时快速重传，保持传输的高效和及时性。</li></ul><p>通过这样的计算方式，KCP能够在不同的网络条件下，自动调整重传策略，从而在保证数据可靠性的同时，保持较高的传输效率。</p><h2 id="快速重传">4. 快速重传</h2><p>在网络传输中，数据包可能会由于网络拥塞、丢包等原因而丢失。超时重传依赖于重传超时时间（RTO）来判断是否需要重传，这可能会导致响应延迟。而快速重传通过检测重复的确认包（ACK）来快速判断数据包的丢失，并立即触发重传，显著缩短了数据丢失的恢复时间。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240612200038895.png"alt="KCP 快速重传" /><figcaption aria-hidden="true">KCP 快速重传</figcaption></figure><h3 id="何时快速重传">4.1 何时快速重传？</h3><ul><li>每个报文的 <code>fastack</code> 记录了它检测到 ACK 失序的次数，每当KCP 收到一个编号为 sn 的 ACK 时，就会检查 snd_buf 中编号小于 sn且未确认送达的报文，并将其 <code>fastack</code> 加 1。</li><li>可以通过配置 <code>fastresend</code>指定失序多少次就执行快速重传。</li><li>每次调用 ikcp_flush 都会重传 snd_buf 中<code>fastask &gt;= fastresend</code> 的报文。</li></ul><h3 id="无限快速重传吗">4.2 无限快速重传吗？</h3><ul><li>每个报文的 <code>xmit</code> 记录它被传输的次数，可以配置<code>fastlimit</code> 规定传输次数小于 <code>fastlimit</code>的报文才能执行快速重传。</li></ul><h2 id="比较-tcp-的超时重传和快速重传">5. 比较 TCP的超时重传和快速重传</h2><p>TCP 也实现了类似的机制，但在复杂性和应用场景上有所不同。</p><h3 id="tcp-的超时重传">5.1 TCP 的超时重传</h3><p><strong>1. RTT 估算</strong>:</p><ul><li><p>TCP 通过接收确认包来估算 RTT，并使用 RTT 的变化范围来计算RTO。</p></li><li><p>TCP 使用 Jacobson/Karels 算法进行 RTT 估算和 RTO 计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// SRTT and RTTVAR calculation</span><br>RTTVAR = (<span class="hljs-number">1</span> - β) * RTTVAR + β * |RTTsample - SRTT|<br>SRTT = (<span class="hljs-number">1</span> - α) * SRTT + α * RTTsample<br>RTO = SRTT + <span class="hljs-number">4</span> * RTTVAR<br></code></pre></td></tr></table></figure><p>其中，SRTT 是平滑的 RTT，RTTVAR 是 RTT 的变化范围，α 和 β是权重因子。</p></li></ul><p><strong>2. 重传策略</strong>:</p><ul><li>如果在 RTO 时间内未收到 ACK，TCP 会重传未确认的数据包。</li><li>每次重传，RTO 值会按照指数增长（指数退避算法）。</li></ul><p><strong>3. 拥塞控制</strong>:</p><ul><li>TCP使用复杂的拥塞控制机制，如慢启动、拥塞避免等，来调整发送窗口和传输速率。</li></ul><h3 id="tcp-的快速重传">5.2 TCP 的快速重传</h3><ul><li>当接收到三个重复的 ACK 时，TCP 会立即重传丢失的数据包，而不等待 RTO超时。</li><li>快速重传后，TCP进入快速恢复状态，调整拥塞窗口，避免拥塞窗口过度收缩。</li></ul><h3 id="比较分析">5.3 比较分析</h3><table><thead><tr class="header"><th>特性</th><th>KCP</th><th>TCP</th></tr></thead><tbody><tr class="odd"><td><strong>RTT 估算</strong></td><td>基于加权移动平均，较为简单</td><td>使用 Jacobson/Karels 算法，复杂但精确</td></tr><tr class="even"><td><strong>RTO 计算</strong></td><td>简化的计算公式</td><td>基于 RTT 的复杂计算</td></tr><tr class="odd"><td><strong>重传机制</strong></td><td>超时重传和快速重传</td><td>超时重传和快速重传</td></tr><tr class="even"><td><strong>拥塞控制</strong></td><td>简单的拥塞控制，适合低延迟应用</td><td>复杂的拥塞控制，适合广泛的传输场景</td></tr><tr class="odd"><td><strong>适用场景</strong></td><td>实时应用，如游戏、视频会议</td><td>通用应用，如文件传输、HTTP</td></tr><tr class="even"><td><strong>实现复杂度</strong></td><td>较为简单，易于理解和实现</td><td>复杂，需处理更多的网络状态和控制</td></tr><tr class="odd"><td><strong>可靠性</strong></td><td>依赖于用户自定义的重传和控制策略</td><td>内置可靠性和流控制机制</td></tr><tr class="even"><td><strong>响应速度</strong></td><td>高效快速，适用于低延迟和高吞吐量场景</td><td>可靠但响应速度较慢，适合稳定传输场景</td></tr></tbody></table><p>KCP 和 TCP 都提供了可靠的传输机制，但它们适用于不同的应用场景。KCP设计简单，适合对延迟敏感的实时应用，而 TCP拥有完善的拥塞控制和可靠性机制，适合广泛的网络应用。</p><h2 id="拥塞控制">6. 拥塞控制</h2><p>拥塞控制是网络传输协议中的一个重要机制，用于防止发送过多的数据包导致网络拥塞。在KCP中，拥塞控制相对简单，主要通过发送窗口（<code>snd_wnd</code>）和拥塞窗口（<code>cwnd</code>）来管理数据发送速率。</p><h3 id="三种策略">6.1 三种策略</h3><p>KCP 有 3 种拥塞控制的策略：</p><ul><li>慢启动（slow start）</li><li>拥塞避免（congestion avoidance）</li><li>快速恢复（fast recovery）</li></ul><p><strong>慢启动</strong>：先将 cwnd 设置为 1，随后平均每经过一个 RTT时间，<code>cwnd = cwnd * 2</code>，直到阈值 <code>ssthresh</code>。</p><p><strong>拥塞避免</strong>：cwnd 到 <code>ssthresh</code> 后，cwnd呈<strong>线性</strong>增长。</p><p>当慢启动或者拥塞避免造成 <strong>丢包</strong>后，就采取相应的退让策略：</p><ol type="1"><li><code>fastack &gt;= fastresend</code> -&gt; 发生快速重传：将<code>ssthresh = cwnd / 2</code>，<code>cwnd = ssthresh + fastresend</code>进入<strong>快恢复</strong>。</li><li><code>current &gt;= resentts</code> -&gt;超时重传：<code>ssthresh = ssthresh / 2</code>，<code>cwnd = 1</code>，进入<strong>慢启动</strong>。</li></ol><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/kcp_7.svg"alt="拥塞控制中 cwnd 和 ssthresh 的变化情况" /><figcaption aria-hidden="true">拥塞控制中 cwnd 和 ssthresh的变化情况</figcaption></figure><h3 id="核心概念">6.2 核心概念</h3><p>KCP 的拥塞控制基于以下几个核心概念：</p><ul><li><strong>发送窗口(<code>snd_wnd</code>)</strong>：表示发送端在未收到接收端确认之前，允许发送的数据包的数量。它类似于TCP 中的发送窗口，控制了数据流的速率。</li><li><strong>接收窗口(<code>rcv_wnd</code>)</strong>：表示接收端能够处理的最大数据包数量。发送端通过接收端的窗口大小来调整自己的发送速率。</li><li><strong>远端窗口(<code>rmt_wnd</code>)</strong>：表示接收端的窗口大小，发送端会根据这个值调整自己的发送窗口，以避免发送的数据超出接收端的处理能力。</li><li><strong>拥塞窗口(<code>cwnd</code>)</strong>：用于控制传输中的数据包数量。它基于网络的拥塞情况动态调整，以避免网络拥塞。</li><li><strong>慢启动阈值(<code>ssthresh</code>)</strong>：用于确定拥塞控制的模式。当<code>cwnd</code> 小于 <code>ssthresh</code> 时，KCP处于慢启动模式，否则进入拥塞避免模式。</li></ul><h3 id="窗口探测window-probing">6.3 窗口探测（Window Probing）</h3><p>在某些情况下，接收端的窗口可能会被关闭（即 <code>rmt_wnd</code> 为0），这意味着接收端无法接收任何新的数据。为了应对这种情况，KCP实现了窗口探测机制：</p><ul><li>当 <code>rmt_wnd</code> 为 0 时，KCP不会立即停止发送数据，而是会定期发送一个探测包，以检测接收端窗口是否已经打开。</li><li>这个探测包会触发接收端返回一个ACK，其中包含最新的接收窗口大小信息。</li></ul><h3 id="调节和配置">6.4 调节和配置</h3><p>KCP的拥塞控制机制提供了一些配置参数，用户可以通过调整这些参数来优化传输性能：</p><ul><li><strong><code>snd_wnd</code></strong>:发送窗口大小，用户可以根据应用的需求调整该值，以控制数据发送的最大量。</li><li><strong><code>rcv_wnd</code></strong>:接收窗口大小，表示接收端能够处理的最大数据包数量。</li><li><strong><code>ssthresh</code></strong>:慢启动阈值，初始值通常设置为较大的一个常量，用户可以根据网络情况调整。</li><li><strong><code>cwnd</code></strong>: 拥塞窗口大小，初始值通常设置为1，随传输情况动态调整。</li></ul><h2 id="比较-tcp-的拥塞控制">7. 比较 TCP 的拥塞控制</h2><h3 id="四个阶段">7.1 四个阶段</h3><p>TCP 拥塞控制有四个关键阶段</p><p><strong>慢启动（Slow Start）</strong>：</p><ul><li><strong>目的</strong>：快速探测网络的可用带宽。</li><li><strong>机制</strong>：当一个连接刚建立或者从丢包恢复时，<code>cwnd</code>（拥塞窗口）从一个较小的值（通常是1 个 MSS，即最大报文段大小）开始，并以指数增长的方式增加。</li><li><strong>过程</strong>：每次收到一个 ACK，<code>cwnd</code> 增加一个MSS，使得 <code>cwnd</code> 每 RTT 增加一倍，直到 <code>cwnd</code>达到慢启动阈值（<code>ssthresh</code>）。</li></ul><p><strong>拥塞避免（Congestion Avoidance）</strong>:</p><ul><li><strong>目的</strong>：逐步探测网络的最大容量，并避免拥塞。</li><li><strong>机制</strong>：当 <code>cwnd</code> 达到或超过<code>ssthresh</code> 时，TCP 进入拥塞避免阶段，此时 <code>cwnd</code>以线性增长的方式增加。</li><li><strong>过程</strong>：每个 RTT，<code>cwnd</code> 增加<code>1/cwnd</code> 个MSS，这种增长方式较为保守，旨在防止过度发送导致的拥塞。</li></ul><p><strong>快速重传（Fast Retransmit）</strong>:</p><ul><li><strong>目的</strong>：快速响应丢包，提高传输效率。</li><li><strong>机制</strong>：当发送端收到三个重复的 ACK时，立即重传被确认丢失的数据包，而不等待 RTO 超时。</li><li><strong>过程</strong>：快速重传的目的是迅速恢复丢失的数据包，从而减少因丢包导致的等待时间。</li></ul><p><strong>快速恢复（Fast Recovery）</strong>:</p><ul><li><strong>目的</strong>：在拥塞后快速恢复到适当的传输速率。</li><li><strong>机制</strong>：在快速重传后，TCP不会直接进入慢启动，而是保持 <code>cwnd</code>的一部分，以较快的速度恢复到拥塞避免状态。</li><li><strong>过程</strong>：将 <code>ssthresh</code> 设置为当前<code>cwnd</code> 的一半，<code>cwnd</code> 被临时减小，然后在接收新 ACK时快速增加 <code>cwnd</code>，直到恢复到 <code>ssthresh</code>为止。</li></ul><h3 id="比较分析-1">7.2 比较分析</h3><table><thead><tr class="header"><th>特性</th><th>TCP</th><th>KCP</th></tr></thead><tbody><tr class="odd"><td><strong>实现复杂度</strong></td><td>复杂，包含多个阶段和算法</td><td>简单，主要通过窗口大小控制</td></tr><tr class="even"><td><strong>拥塞检测</strong></td><td>通过 RTT 估算和 ACK 检测丢包</td><td>主要通过 ACK 和窗口大小检测丢包</td></tr><tr class="odd"><td><strong>响应速度</strong></td><td>响应相对较慢，适合稳定传输</td><td>响应较快，适合实时性高的传输</td></tr><tr class="even"><td><strong>适应性</strong></td><td>能适应广泛的网络条件</td><td>适应性较好，但更适合低延迟网络</td></tr><tr class="odd"><td><strong>配置灵活性</strong></td><td>较为固定，依赖于系统配置和优化</td><td>提供更多的配置选项，用户可根据需求调整</td></tr><tr class="even"><td><strong>应用场景</strong></td><td>适用于各种需要可靠传输的应用</td><td>适用于实时性要求高的应用，如游戏和视频会议</td></tr><tr class="odd"><td><strong>窗口调整</strong></td><td>慢启动、拥塞避免、快速重传、快速恢复等机制</td><td>主要通过发送窗口和拥塞窗口调整</td></tr><tr class="even"><td><strong>丢包响应</strong></td><td>丢包时通过减小 <code>cwnd</code> 和 <code>ssthresh</code>来调整</td><td>丢包时迅速调整 <code>cwnd</code> 和重传</td></tr><tr class="odd"><td><strong>拥塞控制策略</strong></td><td>慢启动、拥塞避免、快速重传、快速恢复等多种策略</td><td>主要通过调整 <code>cwnd</code> 和 <code>ssthresh</code>进行简单控制</td></tr><tr class="even"><td><strong>优点</strong></td><td>稳定可靠、机制全面、应用广泛</td><td>实现简单、响应快、灵活性高、适合实时应用</td></tr><tr class="odd"><td><strong>缺点</strong></td><td>复杂、响应慢、初始阶段保守</td><td>无法应对更加复杂的网络状况、应用场景有限</td></tr></tbody></table><p>TCP 和 KCP 都有各自的拥塞控制机制，适用于不同的应用场景。TCP提供了复杂而全面的拥塞控制，适合于各种网络条件下的可靠传输，而 KCP提供了简单高效的控制机制，适合于低延迟和高响应速度的实时应用。选择使用哪种协议取决于具体的应用需求和网络环境。</p><h1 id="源码分析">源码分析</h1><h1 id="材料">材料</h1><ul><li>excalidraw 分析文件：</li></ul><h1 id="参考">参考</h1><ul><li><a href="https://github.com/skywind3000/kcp">KCP repo</a></li><li><a href="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP协议的原理和实现</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KCP</tag>
      
      <tag>TCP</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 实战丨SSE(Server-Sent Events)</title>
    <link href="/2024/06/06/rust-action-sse/"/>
    <url>/2024/06/06/rust-action-sse/</url>
    
    <content type="html"><![CDATA[<p>📌 SSE（Server-SentEvents）是一种允许服务器向客户端浏览器推送信息的技术。它是 HTML5的一部分，专门用于建立一个单向的从服务器到客户端的通信连接。SSE的使用场景非常广泛，包括实时消息推送、实时通知更新等。</p><h1 id="sse-的本质">SSE 的本质</h1><p>严格地说，<ahref="https://en.wikipedia.org/wiki/HTTP">HTTP</a>无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息（streaming）。</p><p>也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。本质上，这种通信就是以流信息的方式，完成一次用时很长的下载。</p><p>SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 HTTP协议，目前除了 IE/Edge，其他浏览器都支持。</p><h1 id="特点">特点</h1><ol type="1"><li><strong>持续连接</strong>：与传统的 HTTP 请求不同，SSE保持连接开放，服务器可以随时发送消息。</li><li><strong>文本数据流</strong>：SSE主要传输文本数据，这些数据以特定的格式流式传输，使得每条消息都是简单的文本格式。</li><li><strong>内置重连机制</strong>：浏览器会自动处理连接中断和重连，包括在重连请求中发送最后接收的事件ID，以便服务器从正确的位置恢复发送事件。</li><li><strong>简单的客户端处理</strong>：在浏览器中，使用 JavaScript 的<code>EventSource</code> 接口处理 SSE非常简单，只需几行代码即可监听服务器发来的事件。</li></ol><h1 id="工作原理">工作原理</h1><ol type="1"><li><strong>建立连接</strong>：客户端通过创建一个<code>EventSource</code> 对象请求特定的 URL 来启动 SSE连接。这个请求是一个标准的 HTTP请求，但会要求服务器以特定方式响应。</li><li><strong>服务器响应</strong>：服务器响应必须设置<code>Content-Type</code> 为<code>text/event-stream</code>，然后保持连接打开。</li><li><strong>发送消息</strong>：服务器可以通过持续发送数据格式为特定事件流的消息来推送更新。每个消息包括一个可选的事件类型、数据和一个可选的ID。<ul><li><strong>数据</strong>：实际的消息内容，以 <code>data:</code>开头，多行数据以双换行符 <code>\n\n</code> 结束。</li><li><strong>事件类型</strong>：允许客户端根据事件类型来监听，以<code>event:</code> 开头。</li><li><strong>ID</strong>：如果连接中断，客户端将发送包含上次接收的最后一个ID的<code>Last-Event-ID</code> 头，以便服务器从断点继续发送数据。</li></ul></li></ol><h1 id="实战">实战</h1><h2 id="客户端">客户端</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>SSE Test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Server-Sent Events Test<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;events&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 确保这里的URL匹配你的服务器地址和端口</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> eventSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&#x27;http://localhost:8000/events&#x27;</span>);</span><br><span class="language-javascript">    eventSource.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;New event:&#x27;</span>, event.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;events&#x27;</span>).<span class="hljs-property">innerHTML</span> += event.<span class="hljs-property">data</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="rust-服务端">Rust 服务端</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/20240606213652.gif"alt="Rust 实现演示" /><figcaption aria-hidden="true">Rust 实现演示</figcaption></figure><p>依赖：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-attr">anyhow</span> = <span class="hljs-string">&quot;1.0.86&quot;</span><br><span class="hljs-attr">axum</span> = &#123; version = <span class="hljs-string">&quot;0.7.5&quot;</span> &#125;<br><span class="hljs-attr">chrono</span> = <span class="hljs-string">&quot;0.4.38&quot;</span><br><span class="hljs-attr">futures-core</span> = <span class="hljs-string">&quot;0.3.30&quot;</span><br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1.38.0&quot;</span>, features = [<span class="hljs-string">&quot;macros&quot;</span>, <span class="hljs-string">&quot;rt-multi-thread&quot;</span>, ] &#125;<br><span class="hljs-attr">tokio-stream</span> = <span class="hljs-string">&quot;0.1.15&quot;</span><br><span class="hljs-attr">tower-http</span> = &#123; version = <span class="hljs-string">&quot;0.5.2&quot;</span>, features = [<span class="hljs-string">&quot;cors&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">use</span> axum::&#123;<br>    response::&#123;sse::Event, Sse&#125;,<br>    routing::get,<br>    Router,<br>&#125;;<br><span class="hljs-keyword">use</span> tokio::&#123;net::TcpListener, time::interval&#125;;<br><span class="hljs-keyword">use</span> tokio_stream::&#123;wrappers::IntervalStream, StreamExt&#125;;<br><span class="hljs-keyword">use</span> tower_http::cors::&#123;Any, CorsLayer&#125;;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cors</span> = CorsLayer::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">allow_headers</span>(Any)<br>        .<span class="hljs-title function_ invoke__">allow_origin</span>(Any)<br>        .<span class="hljs-title function_ invoke__">allow_headers</span>(Any)<br>        .<span class="hljs-title function_ invoke__">allow_credentials</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;0.0.0.0:8000&quot;</span>).<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Router::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/events&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(sse_handler)).<span class="hljs-title function_ invoke__">layer</span>(cors);<br>    axum::<span class="hljs-title function_ invoke__">serve</span>(listener, app).<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sse_handler</span>() <span class="hljs-punctuation">-&gt;</span> Sse&lt;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">futures_core</span>::Stream&lt;Item = <span class="hljs-type">Result</span>&lt;Event, axum::Error&gt;&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">interval</span> = <span class="hljs-title function_ invoke__">interval</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = IntervalStream::<span class="hljs-title function_ invoke__">new</span>(interval).<span class="hljs-title function_ invoke__">map</span>(|_| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">data</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;\n\n&quot;</span>, chrono::Local::<span class="hljs-title function_ invoke__">now</span>().<span class="hljs-title function_ invoke__">to_rfc2822</span>());<br>        <span class="hljs-title function_ invoke__">Ok</span>(Event::<span class="hljs-title function_ invoke__">default</span>().<span class="hljs-title function_ invoke__">data</span>(data))<br>    &#125;);<br><br>    Sse::<span class="hljs-title function_ invoke__">new</span>(stream)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="go-服务端">Go 服务端</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/20240606195749.gif"alt="Go 实现演示" /><figcaption aria-hidden="true">Go 实现演示</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sseHandler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-comment">// 设置头部信息，确保允许跨域，并且告诉浏览器这是一个事件流</span><br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/event-stream&quot;</span>)<br>w.Header().Set(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>)<br>w.Header().Set(<span class="hljs-string">&quot;Connection&quot;</span>, <span class="hljs-string">&quot;keep-alive&quot;</span>)<br>w.Header().Set(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)<br><br><span class="hljs-comment">// 不断发送消息</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 生成服务器时间，并发送给客户端</span><br>now := time.Now()<br><span class="hljs-comment">// 生成消息，格式为 data: &#123;content&#125; \n\n</span><br>msg := fmt.Sprintf(<span class="hljs-string">&quot;data: %s\n\n&quot;</span>, now.Format(time.DateTime))<br><span class="hljs-comment">// 发送消息</span><br><span class="hljs-keyword">if</span> _, err := fmt.Fprintf(w, msg); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;write error:&quot;</span>, err)<br><span class="hljs-keyword">break</span><br>&#125;<br><br><span class="hljs-comment">// 刷新响应缓冲，确保即时发送</span><br>flusher, ok := w.(http.Flusher)<br><span class="hljs-keyword">if</span> !ok &#123;<br>log.Println(<span class="hljs-string">&quot;Streaming unsupported!&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br>flusher.Flush()<br><br><span class="hljs-comment">// 每秒发送一次</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/events&quot;</span>, sseHandler)<br>log.Println(<span class="hljs-string">&quot;Server started on port 8000...&quot;</span>)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Rust</tag>
      
      <tag>SSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 实战丨通过实现 json! 掌握声明宏</title>
    <link href="/2024/05/28/rust-action-macro-json/"/>
    <url>/2024/05/28/rust-action-macro-json/</url>
    
    <content type="html"><![CDATA[<p>在 Rust编程语言中，宏是一种强大的工具，可以用于在编译时生成代码。<code>json!</code>是一个在 Rust 中广泛使用的宏，它允许我们在 Rust 代码中方便地创建 JSON数据。</p><p>声明宏（declarative macros）是 Rust 中的一种宏，它们使用<code>macro_rules!</code> 关键字定义。</p><p>本文将参考《Rust 程序设计（第二版）》，通过实现 <code>json!</code>宏，深入理解声明宏的工作原理。</p><h1 id="结论先行">结论先行</h1><p>本文我们将构建一个 <code>json!</code> 宏，它支持我们以字符串 JSON风格的语法来编写 Json 值。如下面这个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">students</span> = json![<br>&#123;<br><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Hedon Wang&quot;</span>,<br><span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">2022</span>,<br><span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Software engineering&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jun Lei&quot;</span>,<br><span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">1991</span>,<br><span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Computor science&quot;</span><br>&#125;<br>]<br></code></pre></td></tr></table></figure><blockquote><p><a href="#完整代码">完整代码</a></p></blockquote><h1 id="实现-json">实现 <code>json!</code></h1><h2 id="定义-json-enum">定义 Json enum</h2><p>首先我们需要思考一下 Json 结构是什么样子的？主要是以下 3 种模式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Wuhan University&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hubwi Wuhan&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;john&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-literal"><span class="hljs-keyword">null</span></span><br></code></pre></td></tr></table></figure><p>为此我们定义一个 Json 结构的枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone, PartialEq, Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Json</span> &#123;<br>    Null,<br>    <span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-type">bool</span>),<br>    <span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">String</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-type">Vec</span>&lt;Json&gt;),<br>    <span class="hljs-title function_ invoke__">Object</span>(HashMap&lt;<span class="hljs-type">String</span>, Json&gt;),<br>&#125;<br></code></pre></td></tr></table></figure><p>你应该可以感到非常奇妙，使用一个这么简单的枚举，居然就可以表示所有的Json 结构了。遗憾的是，现在这个结构编写 Json 值的语法相当冗长。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">people</span> = Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>    (<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hedon&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>    (<span class="hljs-string">&quot;age&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">10.0</span>)),<br>    (<span class="hljs-string">&quot;is_student&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)),<br>    (<br>        <span class="hljs-string">&quot;detail&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            (<span class="hljs-string">&quot;address&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;beijing&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>            (<span class="hljs-string">&quot;phone&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()))<br>        ]))<br>    )<br>]))<br></code></pre></td></tr></table></figure><p>我们期望可以以下面这种方式来声明 Json变量，这看起来就清爽许多了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">students</span> = json!([<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jim Blandy&quot;</span>,<br>        <span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">1926</span>,<br>        <span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Tibetan throat singing&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jason Orendorff&quot;</span>,<br>        <span class="hljs-string">&quot;class_of&quot;</span>: <span class="hljs-number">1702</span>,<br>        <span class="hljs-string">&quot;major&quot;</span>: <span class="hljs-string">&quot;Knots&quot;</span><br>    &#125;<br>]);<br></code></pre></td></tr></table></figure><h2 id="猜想-json">猜想 <code>json!</code></h2><p>我们可以预见 Json 宏内部将会有多条规则，因为 JSON数据有多种类型：对象、数组、数值等。事实上，我们可以合理地猜测每种 JSON类型都将有一条规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null)    =&gt; &#123; Json::Null &#125;;<br>    ([ ... ]) =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Array</span>(...) &#125;;<br>    (&#123; ... &#125;) =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Object</span>(...) &#125;;<br>    (???)     =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Boolean</span>(...) &#125;;<br>    (???)     =&gt; &#123; Json::<span class="hljs-title function_ invoke__">Number</span>(...) &#125;;<br>    (???)     =&gt; &#123; Json::<span class="hljs-title function_ invoke__">String</span>(...) &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而这不太正确，因为宏模式无法区分最后 3种情况，稍后我们会讨论如何处理。至于前 3种情况，显然它们是以不同的语法标记开始的，所以这几种情况比较好处理。</p><h2 id="实现-null">实现 Null</h2><p>我们先从最简单的 <code>Null</code> 分支开始，先编写如下测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_null_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(null);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::Null);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要通过上述测试用例非常简单，我们只需要在 <code>macro_rules!</code>支持中匹配这种情况即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>#[macro_export]</code> 注解是 Rust中的一个属性，用于指示这个宏应该被导出到调用者的作用域中，这样其他模块也可以使用它。</li><li><code>macro_rules!</code>宏定义了一个自定义的宏。在这里，它创建了一个名为 <code>json</code>的宏，用于生成 JSON 数据。</li><li>宏定义中 <code>(null)</code> 是匹配模式。这意味着当你调用<code>json!</code> 宏并传递 <code>null</code>作为参数时，将会触发这个规则。</li><li><code>=&gt;</code>符号用于指示匹配模式后的代码块。在这里，它指定了当匹配<code>(null)</code> 时应该生成的代码块。</li><li><code>Json::Null</code> 是一个 JSON 类型的枚举值，表示 JSON 中的null 值。这个宏的目的是将传入的 <code>null</code> 转换为<code>Json::Null</code>。</li></ul><h2 id="实现-booleannumberstring">实现 Boolean/Number/String</h2><p>我们先准备如下测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_boolean_number_string_json</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察分析，它们其实都是同一种模式：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240528114725679.png"alt="Boolean/Number/String 分析" /><figcaption aria-hidden="true">Boolean/Number/String 分析</figcaption></figure><p>现在需要解决的问题就是，如何将这 3 种模式进行统一，这样在<code>macro_rules!</code> 中才可以统一匹配模式并进行代码生成。</p><p>这里我们其实需要做的就是将 <code>bool</code>、<code>f64</code> 和<code>&amp;str</code> 转为对应的 <code>Json</code>类型。那就需要用到标准库中的 <code>From</code> trait 了。</p><p>做法很简单，我们实现如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">Boolean</span>(value)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;&amp;<span class="hljs-type">str</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">String</span>(value.<span class="hljs-title function_ invoke__">to_string</span>())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">f64</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">Number</span>(value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后完善我们的 <code>json!</code>，目前的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们使用 <code>$value</code>作 为变量来承接匹配到的元素，其类型为<code>tt</code> ，表示任意的语法标记树。具体可以参考：<ahref="#片段类型">片段类型</a>。</p><p>这时运行上述测试用例，是没有问题的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">PASS [   0.004s] json-macro tests::test_boolean_number_string_json<br>PASS [   0.004s] json-macro tests::test_null_json<br></code></pre></td></tr></table></figure><p>美中不足的是，JSON 结构中的数字类型，其实不一定是 f64，也可以是i32、u32、f32 或其他的数字类型，如果我们要为这全部的数字类型都实现到Json 的 <code>From</code> trait，那就多冗余。</p><p>这个时候我们又可以实现一个宏，用于快速生成<code>impl From&lt;T&gt; for Json</code>。这个实现比较简单，本文就不赘述了，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> impl_from_for_primitives &#123;<br>    (  $( $<span class="hljs-keyword">type</span>: ty ) * ) =&gt; &#123;<br>        $(<br>            <span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;$<span class="hljs-keyword">type</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>                <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: $<span class="hljs-keyword">type</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>                    Json::<span class="hljs-title function_ invoke__">Number</span>(value <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>)<br>                &#125;<br>            &#125;<br>        )*<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们只需要用下面这一行代码，就可以为所有的数字类型实现<code>From</code> trait 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">impl_from_for_primitives!(<span class="hljs-type">u8</span> <span class="hljs-type">u16</span> <span class="hljs-type">u32</span> <span class="hljs-type">u64</span> <span class="hljs-type">i8</span> <span class="hljs-type">i16</span> <span class="hljs-type">i32</span> <span class="hljs-type">i64</span> <span class="hljs-type">f32</span> <span class="hljs-type">f64</span> <span class="hljs-type">isize</span> <span class="hljs-type">usize</span>);<br></code></pre></td></tr></table></figure><p>记得这个时候你要删除上面手动实现的<code>impl From&lt;f64&gt; for Json</code>，不然会有 impl 冲突错误。</p><p>再次运行测试，也是可以通过的。</p><h2 id="实现-array">实现 Array</h2><p>准备如下测试用例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_json</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!([<span class="hljs-number">1</span>, null, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-literal">true</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        json,<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<br>            Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>),<br>            Json::Null,<br>            Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>            Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)<br>        ])<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>要匹配<code>[1, null, "string", true]</code>这个模式，笔者的分析过程如下：</p><ol type="1"><li>首先是外面的两个中括号 <code>[</code> 和 <code>]</code> ；</li><li>再往里，是一个重复匹配的模式，以 <code>,</code> 分割，可以匹配 0到任意多个元素，所以是 <code>$(  ,*)</code> ，具体可以参考：<ahref="#重复模式">重复模式</a>；</li><li>最里面就是第 2 步要匹配的元素了，我们先用 <code>$element</code>作为变量来承接每一个元素，其类型为 <code>tt</code>，表示任意的语法标记树。</li></ol><p>分析完匹配的表达式后，我们就可以得到：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">([ $( $element:tt ), * ]) =&gt; &#123; <span class="hljs-comment">/* TODO */</span> &#125;<br></code></pre></td></tr></table></figure><p>我们要生成的代码长这个样子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust">Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<br>    Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>),<br>    Json::Null,<br>    Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>    Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)<br>])<br></code></pre></td></tr></table></figure><p>其实就是一个 <code>vec!</code>，然后里面每个元素都是一个<code>Json</code>，如此递归下去。</p><p>即可以得到代码生成部分的逻辑为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[$(json!($element)),* ])<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240528134133088.png"alt="Json::Array 宏分析" /><figcaption aria-hidden="true">Json::Array 宏分析</figcaption></figure><p>综上，我们实现的代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ([ $( $element: tt),* ]) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[ $( json!($element)), * ])<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试用例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">PASS [   0.003s] json-macro tests::test_null_json<br>PASS [   0.003s] json-macro tests::test_boolean_number_string_json<br>PASS [   0.004s] json-macro tests::test_array_json<br></code></pre></td></tr></table></figure><h2 id="实现-object">实现 Object</h2><p>写好如下测试用例，这次我们顺带把 Null、Boolean、Number 和 String带上了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_object_json</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(&#123;<br>        <span class="hljs-string">&quot;null&quot;</span>: null,<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hedon&quot;</span>,<br>        <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&quot;is_student&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;detail&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;beijing&quot;</span>,<br>            <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span><br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        json,<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            (<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hedon&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>            (<span class="hljs-string">&quot;age&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">10.0</span>)),<br>            (<span class="hljs-string">&quot;is_student&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)),<br>            (<br>                <span class="hljs-string">&quot;detail&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>                Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>                    (<span class="hljs-string">&quot;address&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;beijing&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>                    (<span class="hljs-string">&quot;phone&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()))<br>                ]))<br>            )<br>        ]))<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>对比预期的 <code>json!</code> 宏内容和展开后的代码：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240528133040062.png"alt="Json::Object 宏分析" /><figcaption aria-hidden="true">Json::Object 宏分析</figcaption></figure><p>完善我们的 <code>macro_rules! json</code> ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ([ $( $element: tt),* ]) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[ $( json!($element)), * ])<br>    &#125;;<br>    (&#123; $( $key:tt : $value:tt ),* &#125;) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            $(<br>                ( $key.<span class="hljs-title function_ invoke__">to_string</span>(), json!($value) )<br>            ), *<br>        ]))<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试用例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">PASS [   0.004s] json-macro tests::test_object_json<br>PASS [   0.005s] json-macro tests::test_array_json<br>PASS [   0.004s] json-macro tests::test_null_json<br>PASS [   0.005s] json-macro tests::test_boolean_number_string_json<br></code></pre></td></tr></table></figure><p>至此，我们就完成了 <code>json!</code> 宏的构建了！完整源码可见：<ahref="https://www.notion.so/e90c161d8e3743b2a4f788e3d7b75181?pvs=21">完整代码</a></p><p>Peace! Enjoy coding~</p><h1 id="附录">附录</h1><h2 id="重复模式">重复模式</h2><p>在 <ahref="https://www.notion.so/Array-c914526ab9474ccd9cb92c7eb17225b6?pvs=21">实现Array</a> 中，我们匹配了这样一个模式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">([ $( $element:tt ), * ]) =&gt; &#123; <span class="hljs-comment">/* TODO */</span> &#125;<br></code></pre></td></tr></table></figure><p>其中 <code>$($element:tt), *)</code>就是一个重复模式，其可以进一步抽象为 <code>$( ... ),*</code> ，表示匹配0 次或多次，以 <code>,</code> 分隔。</p><p>Rust 支持以下全部重复模式：</p><table><thead><tr class="header"><th>模式</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>$( … ) *</td><td>匹配 0 次或多次，没有分隔符</td></tr><tr class="even"><td>$( … ), *</td><td>匹配 0 次或多次，以逗号分隔</td></tr><tr class="odd"><td>$( … ); *</td><td>匹配 0 次或多次，以分号分隔</td></tr><tr class="even"><td>$( … ) +</td><td>匹配 1 次或多次，没有分隔符</td></tr><tr class="odd"><td>$( … ), +</td><td>匹配 1 次或多次，以逗号分隔</td></tr><tr class="even"><td>$( … ); +</td><td>匹配 1 次或多次，以分号分隔</td></tr><tr class="odd"><td>$( … ) ?</td><td>匹配 0 次或 1 次，没有分隔符</td></tr></tbody></table><p>即：</p><ul><li><code>*</code> 表示 0 次或多次</li><li><code>+</code> 表示 1 次或多次</li><li><code>?</code> 表示 0 次或 1 次</li><li>可在上述 3 者之前加入分隔符</li></ul><h2 id="片段类型">片段类型</h2><p>在 <a href="#实现-array">实现 Array</a>中，我们匹配了这样一个模式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">([ $( $element:tt ), * ]) =&gt; &#123; <span class="hljs-comment">/* TODO */</span> &#125;<br></code></pre></td></tr></table></figure><p>这里我们将 <code>$element</code> 指定为 <code>tt</code>，这个<code>tt</code> 就是宏中的一种片段类型。</p><p><code>tt</code> 能匹配单个语法标记树，包含：</p><ul><li>一对括号，如 <code>(..)</code>、<code>[..]</code>、或<code>&#123;..&#125;</code> ，以及位于其中的所有内容，包括嵌套的语法标记树。</li><li>单独的非括号语法标记，比如 <code>1926</code> 或 <code>Knots</code>。</li></ul><p>所以为了匹配任意类型的 <code>Json</code> ，我们选择了 <code>tt</code>作为 <code>$element</code> 的片段类型。</p><p><code>macro_rules!</code> 支持的片段类型如下所示：</p><table><thead><tr class="header"><th>片段类型</th><th>匹配（带例子）</th><th>后面可以跟 ······</th></tr></thead><tbody><tr class="odd"><td>expr</td><td>表达式：2 + 2, "udon", x.len()</td><td>=&gt;,;</td></tr><tr class="even"><td>stmt</td><td>表达式或声明，不包括任何尾随分号（很难用，请尝试使用 expr 或block）</td><td>=&gt;,;</td></tr><tr class="odd"><td>ty</td><td>类型：String, Vec<u8>, (&amp;str, bool), dyn Read + Send</td><td>=&gt;,; =</td></tr><tr class="even"><td>path</td><td>路径：ferns, ::std::sync::mpsc</td><td>=&gt;,; =</td></tr><tr class="odd"><td>pat</td><td>模式：_, Some(ref x)</td><td>=&gt;,=</td></tr><tr class="even"><td>item</td><td>语法项：struct Point { x: f64, y: f64 }, mod ferns;</td><td>任意</td></tr><tr class="odd"><td>block</td><td>块：{ s += "ok"; true }</td><td>任意</td></tr><tr class="even"><td>meta</td><td>属性的主体：inline, derive(Copy, Clone), doc="3D models."</td><td>任意</td></tr><tr class="odd"><td>literal</td><td>字面量值：1024, "Hello, world!", 1_000_000f64</td><td>任意</td></tr><tr class="even"><td>lifetime</td><td>生命周期：'a, 'item, 'static</td><td>任意</td></tr><tr class="odd"><td>vis</td><td>可见性说明符：pub, pub(crate), pub(in module::submodule)</td><td>任意</td></tr><tr class="even"><td>ident</td><td>标识符：std, Json, longish_variable_name</td><td>任意</td></tr><tr class="odd"><td>tt</td><td>语法标记树：;, &gt;=, {}, [0 1 (+ 0 1)]</td><td>任意</td></tr></tbody></table><h2 id="完整代码">完整代码</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-meta">#[derive(Debug, Clone, PartialEq)]</span><br><span class="hljs-meta">#[allow(unused)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Json</span> &#123;<br>    Null,<br>    <span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-type">bool</span>),<br>    <span class="hljs-title function_ invoke__">String</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-type">Vec</span>&lt;Json&gt;),<br>    <span class="hljs-title function_ invoke__">Object</span>(HashMap&lt;<span class="hljs-type">String</span>, Json&gt;),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">Boolean</span>(value)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;&amp;<span class="hljs-type">str</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">String</span>(value.<span class="hljs-title function_ invoke__">to_string</span>())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Json::<span class="hljs-title function_ invoke__">String</span>(value)<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> impl_from_for_primitives &#123;<br>    (  $( $<span class="hljs-keyword">type</span>: ty ) * ) =&gt; &#123;<br>        $(<br>            <span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;$<span class="hljs-keyword">type</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Json</span> &#123;<br>                <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(value: $<span class="hljs-keyword">type</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>                    Json::<span class="hljs-title function_ invoke__">Number</span>(value <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>)<br>                &#125;<br>            &#125;<br>        )*<br>    &#125;<br>&#125;<br><br>impl_from_for_primitives!(<span class="hljs-type">u8</span> <span class="hljs-type">u16</span> <span class="hljs-type">u32</span> <span class="hljs-type">u64</span> <span class="hljs-type">i8</span> <span class="hljs-type">i16</span> <span class="hljs-type">i32</span> <span class="hljs-type">i64</span> <span class="hljs-type">f32</span> <span class="hljs-type">f64</span> <span class="hljs-type">isize</span> <span class="hljs-type">usize</span>);<br><br><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-built_in">macro_rules!</span> json &#123;<br>    (null) =&gt; &#123;<br>        Json::Null<br>    &#125;;<br>    ([ $( $element: tt),* ]) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[ $( json!($element)), * ])<br>    &#125;;<br>    (&#123; $( $key:tt : $value:tt ),* &#125;) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>            $(<br>                ( $key.<span class="hljs-title function_ invoke__">to_string</span>(), json!($value) )<br>            ), *<br>        ]))<br>    &#125;;<br>    ($value: tt) =&gt; &#123;<br>        Json::<span class="hljs-title function_ invoke__">from</span>($value)<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_null_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(null);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::Null);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_boolean_number_string_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-literal">true</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>));<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-number">1.0</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>));<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(json, Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()));<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_object_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!(&#123;<br>            <span class="hljs-string">&quot;null&quot;</span>: null,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hedon&quot;</span>,<br>            <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">10</span>,<br>            <span class="hljs-string">&quot;is_student&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-string">&quot;detail&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">&quot;beijing&quot;</span>,<br>                <span class="hljs-string">&quot;phone&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-built_in">assert_eq!</span>(<br>            json,<br>            Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>                (<span class="hljs-string">&quot;null&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::Null),<br>                (<span class="hljs-string">&quot;name&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;hedon&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>                (<span class="hljs-string">&quot;age&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">10.0</span>)),<br>                (<span class="hljs-string">&quot;is_student&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)),<br>                (<br>                    <span class="hljs-string">&quot;detail&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>                    Json::<span class="hljs-title function_ invoke__">Object</span>(HashMap::<span class="hljs-title function_ invoke__">from</span>([<br>                        (<span class="hljs-string">&quot;address&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;beijing&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>                        (<span class="hljs-string">&quot;phone&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()))<br>                    ]))<br>                )<br>            ]))<br>        )<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_array_json</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">json</span> = json!([<span class="hljs-number">1</span>, null, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-literal">true</span>]);<br>        <span class="hljs-built_in">assert_eq!</span>(<br>            json,<br>            Json::<span class="hljs-title function_ invoke__">Array</span>(<span class="hljs-built_in">vec!</span>[<br>                Json::<span class="hljs-title function_ invoke__">Number</span>(<span class="hljs-number">1.0</span>),<br>                Json::Null,<br>                Json::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>                Json::<span class="hljs-title function_ invoke__">Boolean</span>(<span class="hljs-literal">true</span>)<br>            ])<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>宏</tag>
      
      <tag>元编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xgo 原理探索</title>
    <link href="/2024/05/23/go-xgo-explore/"/>
    <url>/2024/05/23/go-xgo-explore/</url>
    
    <content type="html"><![CDATA[<h1 id="go-单测-mock-方案">Go 单测 mock 方案</h1><table><thead><tr class="header"><th>Mock 方法</th><th>原理</th><th>依赖</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr class="odd"><td>接口 Mock</td><td>为依赖项定义接口，并提供接口的 Mock 实现。</td><td>需要定义接口和 Mock 实现。</td><td>灵活，遵循 Go 的类型系统；易于替换实现。</td><td>需要更多的样板代码来定义接口和 Mock 实现。</td></tr><tr class="even"><td>Monkey Patching（bouk/moneky）</td><td>直接修改函数指针的内存地址来实现对函数的替换。</td><td>内存保护；汇编代码。</td><td>强大，可以 Mock 任何函数，甚至第三方库的函数。</td><td>复杂，容易出错；线程不安全；依赖系统指令集。</td></tr></tbody></table><h1 id="boukmonkey-弊端">bouk/monkey 弊端</h1><blockquote><p><a href="https://github.com/bouk/monkey">bouk/monkey</a> 🐒</p></blockquote><p>monkey 的核心功能是能够在运行时替换某个函数的实现。</p><p><strong>原理：</strong></p><ol type="1"><li><strong>函数指针替换</strong>：在 Go语言中，函数的地址存储在内存中。bouk/monkey通过直接修改函数指针的内存地址来实现对函数的替换。</li><li><strong>汇编代码</strong>：使用了汇编代码来实现对函数入口的跳转。这些汇编代码会在函数被调用时，将执行流重定向到新的函数实现。</li><li><strong>内存保护</strong>：为了修改内存中的函数指针，bouk/monkey需要临时修改内存页面的保护属性（例如，将页面设为可写）。在修改完毕后，它会恢复原来的保护属性。</li><li><strong>反射与 unsafe 包</strong>：利用 Go 的反射机制和 unsafe包，bouk/monkey 可以获取并操作函数的底层实现细节。</li></ol><p><strong>实现步骤：</strong></p><ol type="1"><li><strong>保存原函数</strong>：在替换函数之前，bouk/monkey会保存原始函数的指针，以便在需要时恢复或调用原始函数。</li><li><strong>生成跳转代码</strong>：bouk/monkey生成一段汇编跳转代码，这段代码会在函数调用时，将执行流跳转到新的函数实现。</li><li><strong>修改函数指针</strong>：使用 unsafe 包，bouk/monkey修改目标函数的入口地址，指向生成的跳转代码。</li><li><strong>恢复内存保护</strong>：在完成上述修改后，恢复内存页面的保护属性。</li></ol><p><strong>有以下几个弊端：</strong></p><ol type="1"><li>如果启用了内联，Monkey有时无法修补函数。尝试在禁用内联的情况下运行测试，例如:<code>go test -gcflags=-l</code>。同样的命令行参数也可以用于构建。</li><li>Monkey不能在一些面向安全的操作系统上工作，这些操作系统不允许同时写入和执行内存页。目前的方法并没有真正可靠的解决方案。</li><li>线程不安全的。</li><li>依赖指令集。</li></ol><h1 id="先看-xgo-怎么用">先看 xgo 怎么用</h1><blockquote><p><a href="https://github.com/xhd2015/xgo">xgo</a> 😈</p></blockquote><p>代码结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">.<br>├── greet.<span class="hljs-keyword">go</span><br>└── greet_test.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>现在在 <code>greet.go</code> 中有一个函数 <code>greet</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>在真实的生产环境中，<code>greet</code>可能要复杂得多，它可能会依赖各种第三方API，也可能会依赖数据库等多种外部组件。所以在测试的时候，我们希望对其进行<strong>mock</strong>，使其返回一个固定的值，便于我们撰写单元测试。</p><p><code>xgo</code> 参考了 <code>go-monkey</code> 的思想，但是不从<strong>修改指令</strong> 这个途径入手，而是另辟蹊径，从<strong>代码重写</strong> 的角度实现了 <strong>mock</strong>的能力。</p><p>为了使用 <code>xgo</code>，我们需要先安装 <code>xgo</code>这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install github.com/xhd2015/xgo/cmd/xgo@latest<br></code></pre></td></tr></table></figure><p>同时在我们的项目中需要引入 <code>xgo</code> 依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get <span class="hljs-string">&quot;github.com/xhd2015/xgo/runtime/mock&quot;</span><br></code></pre></td></tr></table></figure><p>我们编写的 <code>greet_test.go</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> xgo_use<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-string">&quot;github.com/xhd2015/xgo/runtime/mock&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestOriginGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMockGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.Patch(greet, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在 <code>TestMockGreet</code> 这个单元测试中，我们将<code>greet</code> 进行了 mock，返回 <code>"mock " + s</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mock.Patch(greet, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br></code></pre></td></tr></table></figure><p>为了使用 <code>xgo</code>的能力，我们在执行单元测试的时候，需要运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xgo <span class="hljs-built_in">test</span> -v ./<br></code></pre></td></tr></table></figure><p>输出大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  xgo-use git:(master) xgo <span class="hljs-built_in">test</span> -v ./<br>xgo is taking a <span class="hljs-keyword">while</span> to setup, please <span class="hljs-built_in">wait</span>...<br>=== RUN   TestOriginGreet<br>--- PASS: TestOriginGreet (0.00s)<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>PASS<br>ok      xgo-explore/xgo-use     (cached)<br></code></pre></td></tr></table></figure><h1 id="xgo-的核心原理">xgo 的核心原理</h1><p><code>xgo</code> 的核心原理是利用 <code>go build -toolexec</code>的能力。</p><p>运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">help</span> build<br></code></pre></td></tr></table></figure><p>找到 <code>toolexec</code> 的相关说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">-toolexec <span class="hljs-string">&#x27;cmd args&#x27;</span><br>        a program to use to invoke toolchain programs like vet and asm.<br>        For example, instead of running asm, the go <span class="hljs-built_in">command</span> will run<br>        <span class="hljs-string">&#x27;cmd args /path/to/asm &lt;arguments for asm&gt;&#x27;</span>.<br>        The TOOLEXEC_IMPORTPATH environment variable will be <span class="hljs-built_in">set</span>,<br>        matching <span class="hljs-string">&#x27;go list -f &#123;&#123;.ImportPath&#125;&#125;&#x27;</span> <span class="hljs-keyword">for</span> the package being built.<br></code></pre></td></tr></table></figure><p>一言以蔽之：<code>-toolexec</code> 允许对 go 工具链进行拦截，包括<code>vet</code>、<code>asm</code>、<code>compile</code> 和<code>link</code>。</p><p>这种技术也被称为：插桩（stubbing）、增强（instrumentation）和代码重写（rewriting）。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Km9eLWtYFJMiFYP0uC-B29J__5mGvLlSsrD52hWgS_S2nOGSx9PnMybHuqcQljAtTUr5QVVqaHGyyAEwqVPowhPqJvAZHLALdQpj6gzHzb60NLLe91tX87_sAerIGq2mwYMVdBcptglQpJ0QkfmDC-ZHoQ=s2048.png"alt="-toolexec 示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）" /><figcaption aria-hidden="true">-toolexec示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）</figcaption></figure><p>基于上述分析，<code>xgo</code> 提出了 <strong>代码重写</strong>的思路，实现了 <strong>在编译过程中插入拦截器代码</strong> 的功能：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240523164815047.png"alt="xgo 在 go build 中的作用位置（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）" /><figcaption aria-hidden="true">xgo 在 go build中的作用位置（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）</figcaption></figure><p>所以上述我们的 <code>greet.go</code> 文件中的源代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>经过 <code>xgo</code> 编译后最终实际编译的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;runtime&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (r0 <span class="hljs-type">string</span>) &#123;<br>  stop, post := runtime.__xgo_trap(Greet, &amp;s, &amp;r0)<br>  <span class="hljs-keyword">if</span> stop &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">defer</span> post()<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/5e020865-fd1d-49d3-be72-7ee2233a3c5f.png"alt="greet 函数重写变化示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）" /><figcaption aria-hidden="true">greet函数重写变化示意图（来源：https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/）</figcaption></figure><p>如图所示，一旦函数被调用，它的控制流首先转移到<code>Trap</code>，然后一系列拦截器将根据其目的检查当前调用是否应该被Mock、修改、记录或停止。</p><p>如果 <code>greet</code> 注册了 mock 函数，那么就会在<code>__xgo_trap</code> 中调用 mock 的函数，并将返回值设置到<code>r0</code> 上进行返回，而跳过原始的执行逻辑。</p><h1 id="第-1-步死代码实现">第 1 步：死代码实现</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  01-deadcode git:(master) tree<br>.<br>├── greet.go<br>├── greet_test.go<br>└── mock.go<br></code></pre></td></tr></table></figure><p>我们先从最简单的实现开始，采用侵入性代码实现 <code>xgo</code>的核心功能，这里我们还用不到 <code>-toolexec</code>。</p><p>代码结构如上所示，在 <code>mock.go</code> 中，我们有如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mockFuncs = sync.Map&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterMockFunc</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>, fun <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>mockFuncs.Store(funcName, fun)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>mockFuncs</code>: 用于承载函数与 mock 函数的对应关系，其中 key为函数名称，value 为 mock 函数。我们使用 <code>sync.Map</code>来保证并发安全。</li><li><code>RegisterMockFunc</code> 用于为指定的 funcName 注册 mock函数。</li></ul><p>在 <code>greet.go</code> 中，我们有一个 <code>Greet</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们要对其支持 mock，那么需要修改其实现为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fun, ok := mockFuncs.Load(<span class="hljs-string">&quot;Greet&quot;</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>f, ok := fun.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br><span class="hljs-keyword">return</span> f(s)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>在修改后的代码中，我们先判断是否存在 mock 函数，如果存在，则执行 mock函数，否则执行原始逻辑。</p><p>现在我们在 <code>greet_test.go</code> 中编写测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMockGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestOriginGreet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 单独执行 TestMockGreet</span><br>➜  01-deadcode git:(master) ✗ go <span class="hljs-built_in">test</span> -v -run TestMockGreet<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>PASS<br>ok      xgo-explore/01-deadcode 0.103s<br><br><span class="hljs-comment"># 单独执行 TestOriginGreet</span><br>➜  01-deadcode git:(master) ✗ go <span class="hljs-built_in">test</span> -v -run TestOriginGreet<br>=== RUN   TestOriginGreet<br>--- PASS: TestOriginGreet (0.00s)<br>PASS<br>ok      xgo-explore/01-deadcode 0.102s<br><br><span class="hljs-comment"># 一起执行</span><br>➜  01-deadcode git:(master) ✗ go <span class="hljs-built_in">test</span> -v -run $Test$<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>=== RUN   TestOriginGreet<br>    greet_test.go:20: Greet() = <span class="hljs-string">&quot;mock world&quot;</span>; want <span class="hljs-string">&quot;hello world&quot;</span><br>--- FAIL: TestOriginGreet (0.00s)<br>FAIL<br><span class="hljs-built_in">exit</span> status 1<br>FAIL    xgo-explore/01-deadcode 0.102s<br></code></pre></td></tr></table></figure><p>我们会发现单独执行都是 ok 的，不过一起执行的话<code>TestOriginGreet</code> 就失败了，这是因为先执行了<code>TestMockGreet</code>，这个时候已经往 <code>mockFunc</code>中注册了 mock 函数了，所以 <code>TessOriginGreet</code>就执行失败了。</p><p>这里需要在协程层面上做 mock 隔离，<code>xgo</code>的思路是在编译时注入 <code>getg()</code>函数来获取当前协程信息从而实现在注册 mock函数时进行协程隔离。本文将聚焦在 <code>xgo</code> 的核心原理<strong>代码重写</strong> 上，故暂时不考虑这一块。</p><p>Ok，那么短短几行代码，我们就将 <code>xgo</code>的最核心思想给展示出来了。可以看到，<code>xgo</code>的核心思想是往源代码中加入 <strong>合法的 Go代码</strong>，所以不涉及指令重写，故而只要你的机器能执行 Go程序，天然就支持 mock功能，这就天然达到了架构无关的兼容性了。同时我们也使用了<code>sync.Map</code> 来保证了并发安全。</p><h1 id="第-2-步死代码拦截器">第 2 步：死代码拦截器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  02-deadcode-interceptor git:(master) tree<br>.<br>├── greet.go<br>├── greet_test.go<br>└── mock.go<br></code></pre></td></tr></table></figure><p>在第 1 步中，这段代码我觉得有点冗长了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">fun, ok := mockFuncs.Load(<span class="hljs-string">&quot;Greet&quot;</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>  f, ok := fun.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<br>  <span class="hljs-keyword">if</span> ok &#123;<br>    <span class="hljs-keyword">return</span> f(s)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考 <code>xgo</code> 的函数签名，我们对其进行优化，在<code>mock.go</code> 中加入一个 <strong>丐版拦截器</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// mock.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InterceptMock</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>, arg <span class="hljs-type">string</span>, result *<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>fn, ok := mockFuncs.Load(funcName)<br><span class="hljs-keyword">if</span> ok &#123;<br>f, ok := fn.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>*result = f(arg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对应 <code>greet.go</code> 中 <code>Greet</code> 函数就修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>这看起来就清爽多了。再次执行测试代码，一样是可以通过的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  02-deadcode-interceptor git:(master) go <span class="hljs-built_in">test</span> -v -run TestOriginGreet<br>=== RUN   TestOriginGreet<br>--- PASS: TestOriginGreet (0.00s)<br>PASS<br>ok      xgo-explore/02-deadcode-interceptor     0.331s<br><br>➜  02-deadcode-interceptor git:(master) go <span class="hljs-built_in">test</span> -v -run TestMockGreet<br>=== RUN   TestMockGreet<br>--- PASS: TestMockGreet (0.00s)<br>PASS<br>ok      xgo-explore/02-deadcode-interceptor     0.103s<br></code></pre></td></tr></table></figure><h1 id="第-3-步toolexec-初探">第 3 步：toolexec 初探</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>这里 <code>mock.go</code> 没有任何变化。我们期望使用<code>-toolexec</code> 来修改源代码，以实现 mock无源代码侵入的特性，所以我们在 <code>greet.to</code> 中将<code>Greet</code> 函数恢复为只关注实际功能的样子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>同时为了更好地测试使用 <code>-toolexec</code>编译后的运行结果，这里将 <code>greet_test.go</code> 删除了并新增了<code>main.go</code> 文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>那么 <code>-toolexec</code> 要执行的命令怎么实现呢？在 Google 搜索<strong>go toolexec</strong> 你会看到官方给出的一个案例：<ahref="https://go.dev/src/cmd/go/testdata/script/toolexec.txt">toolexec.txt</a>。</p><p>核心部分在最下面，参考这个示例，我们来实现自己的<code>toolexec</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p cmd/mytool<br><span class="hljs-built_in">touch</span> cmd/mytool/mytool.go<br></code></pre></td></tr></table></figure><p>在<code>mytool.go</code>中，我们先写这么点代码，看一下会输出什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tool, args := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>:]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;-V=full&quot;</span> &#123;<br><span class="hljs-comment">// don&#x27;t do anything to infuence the version full output.</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;tool: %s\n&quot;</span>, tool)<br>fmt.Printf(<span class="hljs-string">&quot;args: %v\n&quot;</span>, args)<br>&#125;<br>  <span class="hljs-comment">// 继续执行之前的命令</span><br>cmd := exec.Command(tool, args...)<br>cmd.Stdout = os.Stdout<br>cmd.Stderr = os.Stderr<br><br><span class="hljs-keyword">if</span> err := cmd.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;run command error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们企图输出执行的工具 <code>tool</code> 及传给它的参数<code>args</code>。由于 <code>-V=full</code>的作用是在终端输出版本信息，所以我们要跳过它，避免产生干扰。输出日志后，我们暂且先继续执行原始的命令，不对编译过程做其他的干扰。</p><p>Ok，现在就来看看这个 <code>-toolexec</code> 到底做了什么，在<code>03-toolexec-static</code> 目录下执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清除缓存，一直使用最新的编译结果</span><br>go clean -cache -modcache -i -r<br><span class="hljs-comment"># 编译 mytool</span><br>go build ./cmd/mytool<br><span class="hljs-comment"># 编译业务程序</span><br>go build -toolexec=./mytool -o main<br></code></pre></td></tr></table></figure><p>因为这几个命令经常会用到，所以我们可以将其封装到<code>script.sh</code> 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> script.sh<br><span class="hljs-built_in">chmod</span> +x script.sh<br></code></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>go clean -cache -modcache -i -r<br>go build ./cmd/mytool<br>go build -toolexec=./mytool -o main<br></code></pre></td></tr></table></figure><p>执行上述命令后，可以看到以下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ./script.sh<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/compile<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/_pkg_.a -trimpath <span class="hljs-variable">$WORK</span>/b001=&gt; -p main -lang=go1.22 -complete -buildid PcS9clqF_ny_Ds5N0i_s/PcS9clqF_ny_Ds5N0i_s -goversion go1.22.3 -c=4 -shared -nolocalimports -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg -pack ./greet.go ./main.go ./mock.go]<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/link<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/exe/a.out -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg.link -buildmode=pie -buildid=KgnnCoU_6enHkOm-T62Z/PcS9clqF_ny_Ds5N0i_s/H80dtgGZw1L8mTtVqJBf/KgnnCoU_6enHkOm-T62Z -extld=cc <span class="hljs-variable">$WORK</span>/b001/_pkg_.a]<br></code></pre></td></tr></table></figure><p>可以看到执行了 <code>compile</code> 和 <code>link</code>两个工具，<code>compile</code> 是编译过程，将生成 <code>&#123;&#125;.out</code>文件，而 <code>link</code> 是将多个 <code>&#123;&#125;.out</code>文件链接成一个可执行文件。这是很经典的编译过程，如果对 Go语言的编译过程感兴趣，也可以参考官方的 <ahref="https://github.com/golang/go/tree/release-branch.go1.22/src/cmd/compile">GoCompile Readme</a>，或者笔者撰写的 <ahref="https://hedon.top/2023/11/29/go-compilation/">Go1.21.0程序编译过程</a>。</p><p>这里我们需要重点关注的是 <code>compile</code>命令，它是负责编译源代码的，涉及到的源代码文件会通过<code>-pack ./greet.go ./main.go ./mock.go</code> 传递给<code>compile</code> 命令。</p><p>结合 <code>-toolexec</code> 的帮助信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">-toolexec <span class="hljs-string">&#x27;cmd args&#x27;</span><br>        a program to use to invoke toolchain programs like vet and asm.<br>        For example, instead of running asm, the go <span class="hljs-built_in">command</span> will run<br>        <span class="hljs-string">&#x27;cmd args /path/to/asm &lt;arguments for asm&gt;&#x27;</span>.<br>        The TOOLEXEC_IMPORTPATH environment variable will be <span class="hljs-built_in">set</span>,<br>        matching <span class="hljs-string">&#x27;go list -f &#123;&#123;.ImportPath&#125;&#125;&#x27;</span> <span class="hljs-keyword">for</span> the package being built.<br></code></pre></td></tr></table></figure><p>我们只需要在执行 <code>compile</code> 命令之前，在<code>cmd args</code> 这个环节，进行 <strong>代码重写</strong>就可以实现我们想要的功能了。</p><p>我们现在是要对 <code>greet.go</code> 里面的 <code>Greet</code>函数进行重写，先看看之前的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>重写后的代码应该跟我们之前 <strong>第 2 步</strong> 是一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br> <span class="hljs-keyword">return</span> res<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有 n多种方式可以做到，现在笔者决定使用最暴力的方式，直接临时创建一个包含这段代码的文件<code>tmp.go</code>，并替换掉传给 <code>compile</code> 的参数，即将<code>-pack ./greet.go ./main.go ./mock.go</code> 替换为<code>-pack tmp.go ./main.go ./mock.go</code></p><p>综上，<code>cmd/mytool/mytool/go</code> 实现的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tool, args := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>:]<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;-V=full&quot;</span> &#123;<br><span class="hljs-comment">// don&#x27;t do anything to infuence the version full output.</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> filepath.Base(tool) == <span class="hljs-string">&quot;compile&quot;</span> &#123;<br>index := findGreetFile(args)<br><span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">-1</span> &#123;<br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><span class="hljs-keyword">defer</span> os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br>_, _ = f.WriteString(newCode)<br>args[index] = <span class="hljs-string">&quot;tmp.go&quot;</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;tool: %s\n&quot;</span>, tool)<br>fmt.Printf(<span class="hljs-string">&quot;args: %v\n&quot;</span>, args)<br>&#125;<br><span class="hljs-comment">// 继续执行之前的命令</span><br>cmd := exec.Command(tool, args...)<br>cmd.Stdout = os.Stdout<br>cmd.Stderr = os.Stderr<br><br><span class="hljs-keyword">if</span> err := cmd.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;run command error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findGreetFile</span><span class="hljs-params">(args []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br><span class="hljs-keyword">if</span> strings.Contains(arg, <span class="hljs-string">&quot;greet.go&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-keyword">var</span> newCode = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func Greet(s string) (res string) &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;Greet&quot;, s, &amp;res) &#123;</span><br><span class="hljs-string"> return res</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">return &quot;hello &quot; + s</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这里我先使用 <code>findGreetFile</code> 来查找 <code>greet.go</code>文件所处的参数位置，如果找到了，则生成新的 <code>tmp.go</code>文件，并替换参数，最后在 本次 <code>compile</code> 命令执行完毕后，删除<code>tmp.go</code>，“毁尸灭迹”。</p><p>执行 <code>./script.sh</code> 重新编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ✗ ./script.sh<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/compile<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/_pkg_.a -trimpath <span class="hljs-variable">$WORK</span>/b001=&gt; -p main -lang=go1.22 -complete -buildid PcS9clqF_ny_Ds5N0i_s/PcS9clqF_ny_Ds5N0i_s -goversion go1.22.3 -c=4 -shared -nolocalimports -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg -pack tmp.go ./main.go ./mock.go]<br><span class="hljs-comment"># xgo-explore/03-toolexec-static</span><br>tool: /opt/homebrew/Cellar/go/1.22.3/libexec/pkg/tool/darwin_arm64/link<br>args: [-o <span class="hljs-variable">$WORK</span>/b001/exe/a.out -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg.link -buildmode=pie -buildid=KgnnCoU_6enHkOm-T62Z/PcS9clqF_ny_Ds5N0i_s/H80dtgGZw1L8mTtVqJBf/KgnnCoU_6enHkOm-T62Z -extld=cc <span class="hljs-variable">$WORK</span>/b001/_pkg_.a]<br></code></pre></td></tr></table></figure><p>输出的结果中可以看到已经将 <code>compile</code> 的参数替换为<code>-pack tmp.go ./main.go ./mock.go</code> 了。</p><p>现在我们来执行生成的程序文件，可以看到是执行成功的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ✗ ./main<br>2024/05/23 17:53:52 run successfully<br></code></pre></td></tr></table></figure><p>如果我们不使用 <code>-toolexec</code>，是执行不成功的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  03-toolexec-static git:(master) ✗ go clean -cache -modcache -i -r<br>➜  03-toolexec-static git:(master) ✗ go build -o main<br>➜  03-toolexec-static git:(master) ✗ ./main<br>2024/05/23 17:54:33 Greet() = <span class="hljs-string">&quot;hello world&quot;</span>; want <span class="hljs-string">&quot;mock world&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第-4-步使用-ast-在函数前插入代码">第 4 步：使用 AST在函数前插入代码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  04-toolexec-ast git:(master) ✗ tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>暴力替换源代码文件的方式可能是不太优雅哈，假如我们的<code>greet.go</code> 内容改成下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet2</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 2 &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想对 <code>Greet2</code> 也进行<strong>代码重写</strong>，那就需要修改前面 <code>newCode</code>字段的内容，而且它是写死的，确实不太优雅。现在我们正式来面对这件事，对比修改后的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br> <span class="hljs-keyword">return</span> res<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是在每个函数前加上这么一段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Greet&quot;</span>, s, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>了解过编译原理的读者应该可以想到，我们可以通过操作源代码的 AST结构，往函数的开头插入这段代码即可。如果我们先不考虑参数和返回值的话，那这段代码我们需要替换的地方就是函数名称了，所以它的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;$&#123;funcName&#125;&quot;</span>, s, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们需要用到几个标准库工具：</p><ul><li><code>go/ast</code>: 包定义了 Go编程语言的抽象语法树（AST），核心有以下几种类型：<ul><li><code>File</code>: 表示一个 Go 源文件。</li><li><code>Decl</code>:表示一个声明，包括函数声明、变量声明、类型声明等。</li><li><code>Stmt</code>: 表示一个语句。</li><li><code>Expr</code>: 表示一个表达式。</li></ul></li><li><code>go/token</code>: 定义了处理 Go源代码的词法元素的基础设施，包括位置、标记和标识符等。这个包提供了用于管理源代码位置的信息，可以帮助定位代码中的特定部分。</li><li><code>go/parser</code>: 将一个 <code>.go</code> 文件以解析成 AST结构。</li><li><code>go/printer</code>: 提供了将 AST 格式化并输出为 Go源码的功能</li></ul><p>修改后的 <code>cmd/mytool/mytool.go</code> 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tool, args := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>:]<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &amp;&amp; args[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;-V=full&quot;</span> &#123;<br><span class="hljs-comment">// don&#x27;t do anything to infuence the version full output.</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> filepath.Base(tool) == <span class="hljs-string">&quot;compile&quot;</span> &#123;<br>index := findGreetFile(args)<br><span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">-1</span> &#123;<br>filename := args[index]<br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()<br><span class="hljs-keyword">defer</span> os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(insertCode(filename))<br>args[index] = <span class="hljs-string">&quot;tmp.go&quot;</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;tool: %s\n&quot;</span>, tool)<br>fmt.Printf(<span class="hljs-string">&quot;args: %v\n&quot;</span>, args)<br>&#125;<br><span class="hljs-comment">// 继续执行之前的命令</span><br>cmd := exec.Command(tool, args...)<br>cmd.Stdout = os.Stdout<br>cmd.Stderr = os.Stderr<br><br><span class="hljs-keyword">if</span> err := cmd.Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;run command error: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findGreetFile</span><span class="hljs-params">(args []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br><span class="hljs-keyword">if</span> strings.Contains(arg, <span class="hljs-string">&quot;greet.go&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertCode</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fset := token.NewFileSet()<br>fast, err := parser.ParseFile(fset, filename, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse file error: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, decl := <span class="hljs-keyword">range</span> fast.Decls &#123;<br>fun, ok := decl.(*ast.FuncDecl)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>f, err := os.Create(<span class="hljs-string">&quot;tmp2.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp2.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(fmt.Sprintf(newCodeFormat, fun.Name.Name))<br>f.Close()<br><br>tmpFset := token.NewFileSet()<br>tmpF, err := parser.ParseFile(tmpFset, <span class="hljs-string">&quot;tmp2.go&quot;</span>, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse tmp2.go error: %v\n&quot;</span>, err)<br>&#125;<br>fun.Body.List = <span class="hljs-built_in">append</span>(tmpF.Decls[<span class="hljs-number">0</span>].(*ast.FuncDecl).Body.List, fun.Body.List...)<br>os.Remove(<span class="hljs-string">&quot;tmp2.go&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>printer.Fprint(&amp;buf, fset, fast)<br><br>fmt.Println(buf.String())<br><br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, s, &amp;res) &#123;</span><br><span class="hljs-string"> return res</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>核心的修改在于 <code>insertCode</code> 函数：</p><ol type="1"><li><p>使用 <code>parser.ParseFile</code> 将源代码文件解析成 AST结构；</p></li><li><p>遍历 AST 结构，找到所有的声明（Decl）结构，并使用<code>decl(.ast.FuncDecl)</code> 找到所有的函数；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">FuncDecl <span class="hljs-keyword">struct</span> &#123;<br>  Doc  *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span><br>  Recv *FieldList    <span class="hljs-comment">// receiver (methods); or nil (functions)</span><br>  Name *Ident        <span class="hljs-comment">// function/method name</span><br>  Type *FuncType     <span class="hljs-comment">// function signature: type and value parameters, results, and position of &quot;func&quot; keyword</span><br>  Body *BlockStmt    <span class="hljs-comment">// function body; or nil for external (non-Go) function</span><br>&#125;<br><br>BlockStmt <span class="hljs-keyword">struct</span> &#123;<br>  Lbrace token.Pos <span class="hljs-comment">// position of &quot;&#123;&quot;</span><br>  List   []Stmt<br>  Rbrace token.Pos <span class="hljs-comment">// position of &quot;&#125;&quot;, if any (may be absent due to syntax error)</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查看 <code>ast.FuncDecl</code> 的结构后，可以得出下一步就是往<code>FuncDecl.Body.List</code> 列表前面插入一些<code>Stmt</code>；</p></li><li><p>笔者没找到类似 <code>parseStmt</code>方法，所以取了个巧，我定义了一段代码的 <code>format</code>，里面的<code>%s</code> 会使用 <code>fun.Name.Name</code>获取函数名并进行替换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, s, &amp;res) &#123;</span><br><span class="hljs-string"> return res</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure></li><li><p>创建一个临时文件 <code>tmp2.go</code>并写入格式化后的代码，然后再次调用 <code>parser.ParseFile</code>得到解析这段代码的抽象语法树结构 <code>tmpF</code> 了；</p></li><li><p>然后通过 <code>tmpF.Decls[0].(*ast.FuncDecl).Body.List</code>就可以得到 <code>TmpFunc</code> 中的语句 <code>Stmt</code> 了；</p></li><li><p>将其加在源代码函数的前面即可：<code>fun.Body.List = append(tmpF.Decls[0].(*ast.FuncDecl).Body.List, fun.Body.List...)</code>；</p></li><li><p>然后再使用 <code>go/printer</code> 将修改后的 AST输出为新文件内容。</p></li></ol><p>通过上述步骤，我们就可以为 <code>greet.go</code>中的每个函数前面都插入打桩代码了。</p><p>修改 <code>main.go</code> 里面的内容，加入对 <code>Greet2</code>的测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s<br>&#125;)<br>res = Greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet2() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 2 successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>输出应该还是跟之前是一样的，我们运行生成的可执行函数，得到如下结果那就说明我们又成功进了一步了~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  04-toolexec-ast git:(master) ✗ ./main<br>2024/05/23 20:03:22 run greet 1 successfully<br>2024/05/23 20:03:22 run greet 2 successfully<br></code></pre></td></tr></table></figure><h1 id="第-5-步使用-reflect-反射动态获取参数和返回值名称">第 5 步：使用reflect 反射动态获取参数和返回值名称</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  05-toolexec-general git:(master) ✗ tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>接下来我们来处理函数签名中的参数和返回值部分，我们的样板代码中，写死了参数的名称和返回值的名称，现在我们需要来动态获取函数参数的名称和返回值的名称，如果返回值没有名称，那我们还需要手动设置名称。</p><p>我们将 <code>greet.to</code> 修改为以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet2</span><span class="hljs-params">(s2 <span class="hljs-type">string</span>)</span></span> (res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 2 &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet3</span><span class="hljs-params">(s3 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 3 &quot;</span> + s3<br>&#125;<br></code></pre></td></tr></table></figure><p>函数的信息当然都在前面获得的 <code>ast.FuncDecl</code>结构中，再次观察其结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">FuncDecl <span class="hljs-keyword">struct</span> &#123;<br>Doc  *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span><br>Recv *FieldList    <span class="hljs-comment">// receiver (methods); or nil (functions)</span><br>Name *Ident        <span class="hljs-comment">// function/method name</span><br>Type *FuncType     <span class="hljs-comment">// function signature: type and value parameters, results, and position of &quot;func&quot; keyword</span><br>Body *BlockStmt    <span class="hljs-comment">// function body; or nil for external (non-Go) function</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过注释就可以知道 <code>Type</code>字段就包含了参数和返回值的相关信息，查看 <code>FuncType</code>结构，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">FuncType <span class="hljs-keyword">struct</span> &#123;<br>  Func       token.Pos  <span class="hljs-comment">// position of &quot;func&quot; keyword (token.NoPos if there is no &quot;func&quot;)</span><br>  TypeParams *FieldList <span class="hljs-comment">// type parameters; or nil</span><br>  Params     *FieldList <span class="hljs-comment">// (incoming) parameters; non-nil</span><br>  Results    *FieldList <span class="hljs-comment">// (outgoing) results; or nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Params</code>：函数参数</li><li><code>Results</code>：函数返回值</li></ul><p>查看 <code>FieldList</code> 结构，可知参数列表和返回值列表都在相应的<code>List</code> 字段中，而其中的 <code>Names</code>字段就是参数的名称了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FieldList <span class="hljs-keyword">struct</span> &#123;<br>Opening token.Pos <span class="hljs-comment">// position of opening parenthesis/brace/bracket, if any</span><br>List    []*Field  <span class="hljs-comment">// field list; or nil</span><br>Closing token.Pos <span class="hljs-comment">// position of closing parenthesis/brace/bracket, if any</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Field <span class="hljs-keyword">struct</span> &#123;<br>Doc     *CommentGroup <span class="hljs-comment">// associated documentation; or nil</span><br>Names   []*Ident      <span class="hljs-comment">// field/method/(type) parameter names; or nil</span><br>Type    Expr          <span class="hljs-comment">// field/method/parameter type; or nil</span><br>Tag     *BasicLit     <span class="hljs-comment">// field tag; or nil</span><br>Comment *CommentGroup <span class="hljs-comment">// line comments; or nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>补充一下，这里为什么 <code>Names</code> 类型是 <code>[]*Ident</code>呢？因为函数有以下的命名方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (r1, r1 <span class="hljs-type">string</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>那么在当下，只有 1 个参数和只有 1 个返回值的情况下，我们就可以通过<code>fun.Type.Params.List[0].Names[0].Name</code>来获取参数名称，也可以通过 <code>fun.Type.Results.List[0].Names</code>来获取返回值名称，如果返回值没有名称，那我们就为其设置名称<code>__xgo_res_1</code> 并写回源 AST结构。这样就都有名称，就很好处理了。</p><p>经上分析， <code>cmd/mytool/mytool.go</code> 中我们只需要修改<code>insertCode</code> 部分，修改的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertCode</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fset := token.NewFileSet()<br>fast, err := parser.ParseFile(fset, filename, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse file error: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, decl := <span class="hljs-keyword">range</span> fast.Decls &#123;<br>fun, ok := decl.(*ast.FuncDecl)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(newCode(fun))<br>f.Close()<br><br>tmpFset := token.NewFileSet()<br>tmpF, err := parser.ParseFile(tmpFset, <span class="hljs-string">&quot;tmp.go&quot;</span>, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>fun.Body.List = <span class="hljs-built_in">append</span>(tmpF.Decls[<span class="hljs-number">0</span>].(*ast.FuncDecl).Body.List, fun.Body.List...)<br>os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>printer.Fprint(&amp;buf, fset, fast)<br><br>fmt.Println(buf.String())<br><br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCode</span><span class="hljs-params">(fun *ast.FuncDecl)</span></span> <span class="hljs-type">string</span> &#123;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[s] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[res] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[s2] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[res2] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[s3] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">&amp;&#123;Doc:&lt;nil&gt; Names:[] Type:string Tag:&lt;nil&gt; Comment:&lt;nil&gt;&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 函数名称</span><br>funcName := fun.Name.Name<br><br><span class="hljs-comment">// 参数列表</span><br>argName := fun.Type.Params.List[<span class="hljs-number">0</span>].Names[<span class="hljs-number">0</span>].Name<br><br><span class="hljs-comment">// 返回值列表</span><br>resNames := fun.Type.Results.List[<span class="hljs-number">0</span>].Names<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(resNames) == <span class="hljs-number">0</span> &#123;<br>resNames = <span class="hljs-built_in">append</span>(resNames, &amp;ast.Ident&#123;Name: <span class="hljs-string">&quot;_xgo_res_1&quot;</span>&#125;)<br>fun.Type.Results.List[<span class="hljs-number">0</span>].Names = resNames<br>&#125;<br>resName := resNames[<span class="hljs-number">0</span>].Name<br><span class="hljs-keyword">return</span> fmt.Sprintf(newCodeFormat, funcName, argName, resName, resName)<br>&#125;<br><br><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, %s, &amp;%s) &#123;</span><br><span class="hljs-string"> return %s</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>现在我们就可以动态获取参数名称和返回值名称了。</p><p>修改我们的 <code>main.go</code>，以测试所有的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>res := Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s<br>&#125;)<br>res = Greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet2() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 2 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 3 &quot;</span> + s<br>&#125;)<br>res = Greet3(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 3 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet3() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 3 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 3 successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行编译脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>执行编译产生的可执行程序，输出如下就说明我们又成功进了一大步~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  05-toolexec-general git:(master) ✗ ./main<br>2024/05/23 20:15:08 run greet 1 successfully<br>2024/05/23 20:15:08 run greet 2 successfully<br>2024/05/23 20:15:08 run greet 3 successfully<br></code></pre></td></tr></table></figure><h1 id="第-6-步支持多参数和多返回值">第 6 步：支持多参数和多返回值</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  06-toolexec-multi git:(master) ✗ tree<br>.<br>├── cmd<br>│   └── mytool<br>│       └── mytool.go<br>├── greet.go<br>├── main.go<br>├── mock.go<br>└── script.sh<br></code></pre></td></tr></table></figure><p>本文的最后一步，我们来面对一下多参数和多返回值的问题。假设我们又如下函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair1</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候我们 <strong>代码重写</strong>后应该长什么样子呢？可以是下面这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair1</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Pair1&quot;</span>, s1, s2, &amp;res) &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>按照这个思路，下面这个函数呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>那就是这样的？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Pair2&quot;</span>, s1, s2, &amp;res1, &amp;res2) &#123;<br><span class="hljs-keyword">return</span> res1, res2<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>这种思路当然也能实现，换一种更优雅的思路呢？既然是一个列表，那么就可以用切片来承载，也就是可以是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;Pair2&quot;</span>, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;s1, s2&#125;, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&amp;res1, &amp;res2&#125;) &#123;<br><span class="hljs-keyword">return</span> res1, res2<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br></code></pre></td></tr></table></figure><p>那我们就可以抽象出插入代码的模板了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> InterceptMock(<span class="hljs-string">&quot;$&#123;funcName&#125;&quot;</span>, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;$&#123;paramList&#125;&#125;, []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;$&#123;returnListWith&amp;&#125;&#125;) &#123;<br>  <span class="hljs-keyword">return</span> $&#123;returnListWithout&amp;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了实现这个，我们需要先修改一下 <code>mock.go</code> 中的<code>InterceptMock</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InterceptMock</span><span class="hljs-params">(funcName <span class="hljs-type">string</span>, args []<span class="hljs-keyword">interface</span>&#123;&#125;, results []<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>mockFn, ok := mockFuncs.Load(funcName)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><br>in := <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-built_in">len</span>(args))<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args &#123;<br>in[i] = reflect.ValueOf(arg)<br>&#125;<br><br>  mockFnValue := reflect.ValueOf(mockFn)<br>out := mockFnValue.Call(in)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(out) != <span class="hljs-built_in">len</span>(results) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;mock function return value number is not equal to results number&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> i, result := <span class="hljs-keyword">range</span> results &#123;<br>reflect.ValueOf(result).Elem().Set(out[i])<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器的具体实现如下：</p><ol type="1"><li>判断是否注册了 mock 函数，没有则直接返回；</li><li>将所有参数都放到 <code>[]refect.Value</code> 中；</li><li>通过反射 <code>refect.ValueOf</code> 获取 mockFn 的值；</li><li>调用 <code>mockFnValue.Call()</code>来执行函数，并返回结果列表；</li><li>遍历传进来的返回值引用列表，调用<code>reflect.ValueOf(result).Elem().Set(out[i])</code>将返回值设置回去。</li></ol><p>现在我们来修改我们的 <code>-toolexec</code> 工具，来根据函数的 AST结构，获取参数列表和返回值列表，生成代插入的模板代码，并将其插入到每个函数的开头。这次在<code>cmd/mytool/mytool.go</code> 中，我们只需修改 <code>newCode</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertCode</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>fset := token.NewFileSet()<br>fast, err := parser.ParseFile(fset, filename, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse file error: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, decl := <span class="hljs-keyword">range</span> fast.Decls &#123;<br>fun, ok := decl.(*ast.FuncDecl)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>f, err := os.Create(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;create tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>_, _ = f.WriteString(newCode(fun))<br>f.Close()<br><br>tmpFset := token.NewFileSet()<br>tmpF, err := parser.ParseFile(tmpFset, <span class="hljs-string">&quot;tmp.go&quot;</span>, <span class="hljs-literal">nil</span>, parser.AllErrors)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;parse tmp.go error: %v\n&quot;</span>, err)<br>&#125;<br>fun.Body.List = <span class="hljs-built_in">append</span>(tmpF.Decls[<span class="hljs-number">0</span>].(*ast.FuncDecl).Body.List, fun.Body.List...)<br>os.Remove(<span class="hljs-string">&quot;tmp.go&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>printer.Fprint(&amp;buf, fset, fast)<br><br>fmt.Println(buf.String())<br><br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newCode</span><span class="hljs-params">(fun *ast.FuncDecl)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// 函数名称</span><br>funcName := fun.Name.Name<br><br><span class="hljs-comment">// 参数列表</span><br>args := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> fun.Type.Params.List &#123;<br><span class="hljs-keyword">for</span> _, name := <span class="hljs-keyword">range</span> arg.Names &#123;<br>args = <span class="hljs-built_in">append</span>(args, name.Name)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 返回值列表</span><br>returns := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>returnRefs := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>returnNames := fun.Type.Results.List[<span class="hljs-number">0</span>].Names<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(returnNames) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; fun.Type.Results.NumFields(); i++ &#123;<br>fun.Type.Results.List[<span class="hljs-number">0</span>].Names = <span class="hljs-built_in">append</span>(fun.Type.Results.List[<span class="hljs-number">0</span>].Names,<br>&amp;ast.Ident&#123;Name: fmt.Sprintf(<span class="hljs-string">&quot;_xgo_res_%d&quot;</span>, i+<span class="hljs-number">1</span>)&#125;)<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> _, re := <span class="hljs-keyword">range</span> fun.Type.Results.List[<span class="hljs-number">0</span>].Names &#123;<br>returns = <span class="hljs-built_in">append</span>(returns, re.Name)<br>returnRefs = <span class="hljs-built_in">append</span>(returnRefs, <span class="hljs-string">&quot;&amp;&quot;</span>+re.Name)<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(newCodeFormat,<br>funcName,<br>strings.Join(args, <span class="hljs-string">&quot;,&quot;</span>),<br>strings.Join(returnRefs, <span class="hljs-string">&quot;,&quot;</span>),<br>strings.Join(returns, <span class="hljs-string">&quot;,&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">var</span> newCodeFormat = <span class="hljs-string">`</span><br><span class="hljs-string">package main</span><br><span class="hljs-string"></span><br><span class="hljs-string">func TmpFunc() &#123;</span><br><span class="hljs-string">if InterceptMock(&quot;%s&quot;, []interface&#123;&#125;&#123;%s&#125;, []interface&#123;&#125;&#123;%s&#125;) &#123;</span><br><span class="hljs-string">return %s</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>思路跟之前第 5步大同小异，不过是用遍历的方式来支持多个参数和多个返回值罢了。</p><p>现在我们为 <code>greet.go</code> 添加更多的测试函数，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet2</span><span class="hljs-params">(s2 <span class="hljs-type">string</span>)</span></span> (res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 2 &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Greet3</span><span class="hljs-params">(s3 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello 3 &quot;</span> + s3<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair1</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pair2</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (res1, res2 <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pair 1 &quot;</span> + s1, <span class="hljs-string">&quot;pair 2 &quot;</span> + s2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Other</span><span class="hljs-params">(i <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, f <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;int: %d, string: %s, float: %f&quot;</span>, i, s, f)<br>&#125;<br></code></pre></td></tr></table></figure><p>为了测试，我们再次修改 <code>main.go</code>，使其覆盖所有的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Other&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, f <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;mock %d %s %.2f&quot;</span>, i, s, f)<br>&#125;)<br>res := Other(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">3.14</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 1 hello 3.14&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Other() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 1 hello 3.14&quot;</span>)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;run other successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Pair1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 1 &quot;</span> + s1 + <span class="hljs-string">&quot; &quot;</span> + s2<br>&#125;)<br>res = Pair1(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 1 hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Pair1() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 1 hello world&quot;</span>)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;run pair1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Pair2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s1, <span class="hljs-string">&quot;mock 2 &quot;</span> + s2<br>&#125;)<br>res1, res2 := Pair2(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res1 != <span class="hljs-string">&quot;mock 2 hello&quot;</span> || res2 != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Pair2() = %q, %q; want %q, %q&quot;</span>, res1, res2, <span class="hljs-string">&quot;mock 2 hello&quot;</span>, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;run pair2 successfully&quot;</span>)<br><br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;hello world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br>res = Greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 1 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 2 &quot;</span> + s<br>&#125;)<br>res = Greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 2 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet2() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 2 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 2 successfully&quot;</span>)<br><br>RegisterMockFunc(<span class="hljs-string">&quot;Greet3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock 3 &quot;</span> + s<br>&#125;)<br>res = Greet3(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock 3 world&quot;</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Greet3() = %q; want %q&quot;</span>, res, <span class="hljs-string">&quot;mock 3 world&quot;</span>)<br>&#125;<br><br>log.Println(<span class="hljs-string">&quot;run greet 3 successfully&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>编译代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./script.sh<br></code></pre></td></tr></table></figure><p>执行生成的可执行程序，如果有以下输出，那我们就又成功进了一大大步了~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  06-toolexec-multi git:(master) ✗ ./main<br>2024/05/23 20:31:10 run other successfully<br>2024/05/23 20:31:10 run pair1 successfully<br>2024/05/23 20:31:10 run pair2 successfully<br>2024/05/23 20:31:10 run greet 1 successfully<br>2024/05/23 20:31:10 run greet 2 successfully<br>2024/05/23 20:31:10 run greet 3 successfully<br></code></pre></td></tr></table></figure><h1 id="更进一步">更进一步</h1><p>通过上面 6 个简单的小阶段，我们就已经把 <code>xgo</code>最最核心的功能给实现了，在一些小场景下还勉强能用？🤡</p><p>我们来看看包含测试代码和样例函数，总共用了多少代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  06-toolexec-multi git:(master) ✗ tokei .<br>===============================================================================<br> Language            Files        Lines         Code     Comments       Blanks<br>===============================================================================<br> Go                      4          281          224           11           46<br> Shell                   1            5            3            1            1<br>===============================================================================<br> Total                   5          286          227           12           47<br>===============================================================================<br></code></pre></td></tr></table></figure><p>短短 <strong>224</strong> 行代码，这是一个非常了不起的成就！</p><p>当然，优秀的读者肯定可以发现我们这个 <strong>丐版 xgo</strong>有太多的不足和缺陷了。这是必然的，我们来看看 <code>xgo</code> 截止<code>1.0.37</code> 版本，总共有多少行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">➜  xgo git:(master) tokei .<br>===============================================================================<br> Language            Files        Lines         Code     Comments       Blanks<br>===============================================================================<br> BASH                    <span class="hljs-number">1</span>          <span class="hljs-number">104</span>           <span class="hljs-number">81</span>           <span class="hljs-number">11</span>           <span class="hljs-number">12</span><br> CSS                     <span class="hljs-number">1</span>          <span class="hljs-number">153</span>          <span class="hljs-number">118</span>            <span class="hljs-number">5</span>           <span class="hljs-number">30</span><br> Go                    <span class="hljs-number">369</span>        <span class="hljs-number">33232</span>        <span class="hljs-number">26836</span>         <span class="hljs-number">2588</span>         <span class="hljs-number">3808</span><br> JavaScript              <span class="hljs-number">1</span>          <span class="hljs-number">170</span>          <span class="hljs-number">146</span>           <span class="hljs-number">10</span>           <span class="hljs-number">14</span><br> JSON                    <span class="hljs-number">2</span>          <span class="hljs-number">435</span>          <span class="hljs-number">435</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> PowerShell              <span class="hljs-number">1</span>           <span class="hljs-number">28</span>           <span class="hljs-number">16</span>            <span class="hljs-number">3</span>            <span class="hljs-number">9</span><br> Shell                   <span class="hljs-number">3</span>          <span class="hljs-number">288</span>          <span class="hljs-number">251</span>            <span class="hljs-number">4</span>           <span class="hljs-number">33</span><br> SVG                     <span class="hljs-number">1</span>           <span class="hljs-number">41</span>           <span class="hljs-number">41</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> Plain Text              <span class="hljs-number">7</span>          <span class="hljs-number">192</span>            <span class="hljs-number">0</span>          <span class="hljs-number">174</span>           <span class="hljs-number">18</span><br>-------------------------------------------------------------------------------<br> HTML                    <span class="hljs-number">1</span>           <span class="hljs-number">19</span>           <span class="hljs-number">16</span>            <span class="hljs-number">3</span>            <span class="hljs-number">0</span><br> |- JavaScript           <span class="hljs-number">1</span>            <span class="hljs-number">6</span>            <span class="hljs-number">6</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> (Total)                             <span class="hljs-number">25</span>           <span class="hljs-number">22</span>            <span class="hljs-number">3</span>            <span class="hljs-number">0</span><br>-------------------------------------------------------------------------------<br> Markdown               <span class="hljs-number">17</span>         <span class="hljs-number">1455</span>            <span class="hljs-number">0</span>         <span class="hljs-number">1083</span>          <span class="hljs-number">372</span><br> |- Go                   <span class="hljs-number">8</span>          <span class="hljs-number">820</span>          <span class="hljs-number">635</span>           <span class="hljs-number">72</span>          <span class="hljs-number">113</span><br> |- JSON                 <span class="hljs-number">1</span>           <span class="hljs-number">80</span>           <span class="hljs-number">80</span>            <span class="hljs-number">0</span>            <span class="hljs-number">0</span><br> (Total)                           <span class="hljs-number">2355</span>          <span class="hljs-number">715</span>         <span class="hljs-number">1155</span>          <span class="hljs-number">485</span><br>===============================================================================<br> Total                 <span class="hljs-number">404</span>        <span class="hljs-number">36117</span>        <span class="hljs-number">27940</span>         <span class="hljs-number">3881</span>         <span class="hljs-number">4296</span><br>===============================================================================<br></code></pre></td></tr></table></figure><p>光 Go 代码就有 <strong>26836</strong> 行了。所以可知 <code>xgo</code>的作者是做了很多的付出和努力的。不过我们用了不到百分之一的代码量，就将<code>xgo</code>最核心的原理展示得淋漓尽致了，感兴趣的读者可以进一步阅读<code>xgo</code> 的源码，可以进一步探索如何抽象出更通用更简洁更易扩展的interceptor，如何支持协程隔离，如何优化依赖管理，以及如何实现其他的trace、coverage 功能。再次为 <code>xgo</code> 打 call 👏！</p><h1 id="参考">参考</h1><ul><li><a href="https://github.com/xhd2015/xgo">xgo repo</a></li><li><ahref="https://docs.google.com/presentation/d/1U5yTdrUjnManxztzsMPGBAePrE3HvJcDtRjV6h3HelA/edit#slide=id.g2705943ae25_0_50">xgo:基于代码重写实现 Monkey Patch 和 Trace</a></li><li><ahref="https://github.com/golang/go/tree/release-branch.go1.22/src/cmd/compile">gocompile README</a></li><li><ahref="https://blog.xhd2015.xyz/zh/posts/xgo-monkey-patching-in-go-using-toolexec/">xgo:在 go 中使用-toolexec 实现猴子补丁</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>开源项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>开源项目</tag>
      
      <tag>单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xgo 使用经验</title>
    <link href="/2024/05/21/go-xgo-use/"/>
    <url>/2024/05/21/go-xgo-use/</url>
    
    <content type="html"><![CDATA[<h1 id="patch">Patch</h1><h2 id="mock-函数">mock 函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPatchFunc</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.Patch(greet, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span> + s<br>&#125;)<br><br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced mock world got %s&quot;</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mock-变量">mock 变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> value = <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greet</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> value + s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPatchVar</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.Patch(&amp;value, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span><br>&#125;)<br>res := greet(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced mock world got %s&quot;</span>, res)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPatchVarByName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.PatchByName(<span class="hljs-string">&quot;learn-xgo/api&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mock &quot;</span><br>&#125;)<br>res := greet2(<span class="hljs-string">&quot;world&quot;</span>)<br><span class="hljs-keyword">if</span> res != <span class="hljs-string">&quot;mock world&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced mock world got %s&quot;</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="mock">Mock</h1><blockquote><p>因此，当函数含有未导出类型时，<code>Patch</code>无法使用，此时可以使用 <code>Mock</code>。</p></blockquote><h2 id="mockbyname">MockByName</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// learn-xgo/funcs/funcs.go</span><br><span class="hljs-keyword">package</span> funcs<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CallUnexportedFunc</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> unexportedFunc(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unexportedFunc</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;origin unexported func, your msg is &quot;</span> + s<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// learn-xgo/api/mock_test.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMockByName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mock.MockByName(<span class="hljs-string">&quot;learn-xgo/funcs&quot;</span>, <span class="hljs-string">&quot;unexportedFunc&quot;</span>,<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, fn *core.FuncInfo, args core.Object, results core.Object)</span></span> <span class="hljs-type">error</span> &#123;<br>results.GetFieldIndex(<span class="hljs-number">0</span>).Set(<span class="hljs-string">&quot;mock funcs &quot;</span> + args.GetFieldIndex(<span class="hljs-number">0</span>).Value().(<span class="hljs-type">string</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><br>msg := funcs.CallUnexportedFunc(<span class="hljs-string">&quot;hedon&quot;</span>)<br><span class="hljs-keyword">if</span> msg != <span class="hljs-string">&quot;mock funcs hedon&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;expteced `mock funcs hedon` got %s&quot;</span>, msg)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>开源项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>开源项目</tag>
      
      <tag>单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 负载均衡挑战及解决思路</title>
    <link href="/2024/05/20/kafka-load-balance/"/>
    <url>/2024/05/20/kafka-load-balance/</url>
    
    <content type="html"><![CDATA[<p>本文转载自 Agoda Engineering，介绍了在实际应用中，如何应对 Kafka负载均衡所遇到的各种挑战，并提出相应的解决思路。本文简要阐述了 Kafka的并行性机制、常用的分区策略以及在实际操作中遇到的异构硬件、不均匀工作负载等问题。通过深入分析这些挑战，并提供具体的解决方案，本文旨在帮助读者更好地理解和应用Kafka 的负载均衡技术，从而提高系统的整体性能和稳定性。</p><p>以下大部分内容翻译自原文 <ahref="https://medium.com/agoda-engineering/how-we-solve-load-balancing-challenges-in-apache-kafka-8cd88fdad02b">how-we-solve-load-balancing-challenges-in-apache-kafka</a>，并已获得原作者同意。</p><h1 id="思维导图">思维导图</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Kafka%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png"alt="Kafka 负载均衡解决方案" /><figcaption aria-hidden="true">Kafka 负载均衡解决方案</figcaption></figure><h1 id="kafka-并行性">Kafka 并行性</h1><p>Kafka通过分区来实现并行性，如下图所示，生产者（Producer）产生的消息会按照一定的分区策略分配到多个分区（Partition）中，消费组中的每个消费者会分别负责消费其中的若干个分区。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*ixosAmhBDsyBBhoS.png"alt="Kafka 分区演示" /><figcaption aria-hidden="true">Kafka 分区演示</figcaption></figure><p>分区策略：</p><ul><li>轮询（Round Robin）：默认情况下，Kafka使用轮询策略将消息均匀地分配到所有分区。</li><li>哈希（Key Hashing）：如果消息有分区键，Kafka会对键进行哈希计算，将消息分配到特定的分区。</li><li>自定义分区策略：开发者可以实现自定义的分区器（Partitioner）逻辑，以满足特定需求。</li></ul><p>如果要使用轮询或者哈希策略来达到“负载均衡”的目的，那么需要满足以下 2个假设：</p><ol type="1"><li>消费者拥有相同的处理能力，</li><li>消息的工作量相等。</li></ol><p>然而，在实践中，这些假设往往不成立。</p><h1 id="现实挑战">现实挑战</h1><h2 id="异构硬件">1. 异构硬件</h2><p>不同代的服务器硬件性能不同，导致处理速率存在差异。例如，使用不同代硬件进行处理的基准显示性能存在显着差异：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1*B6svY0ZjYVy-uJ7ZA18Jtg.png"alt="不同服务器处理速率差异举例" /><figcaption aria-hidden="true">不同服务器处理速率差异举例</figcaption></figure><h2 id="每条-kafka-消息的工作负载不均匀">2. 每条 Kafka消息的工作负载不均匀</h2><p>下图显示了在一个时间窗口内到达的 12条消息。在这里，生产者向该主题中的六个分区中的每一个发布两条消息。因此，每个worker 消耗来自 2 个分区的数据，这意味着每个 worker 需要处理 4条消息。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*VwPda5gNsHRL2tJV.png"alt="使用循环分区器和循环分配器来分发消息的先前供应系统的演示。每个 worker 都分配有相同数量的消息。" /><figcaptionaria-hidden="true">使用循环分区器和循环分配器来分发消息的先前供应系统的演示。每个worker 都分配有相同数量的消息。</figcaption></figure><p>不同的消息可能需要不同的处理步骤集。例如，处理消息可能涉及调用第三方HTTP端点，并且不同的响应大小或延迟可能会影响处理速率。此外，对于涉及数据库操作的应用程序，其数据库查询的延迟可能会根据查询参数而波动，从而导致处理速率发生变化。</p><h2 id="过度配置问题">3. 过度配置问题</h2><p>由于工作负载和处理效率不同，为了达到系统吞吐量的需求，可能会出现过度配置问题，从而导致资源浪费。</p><p>假设我们的高吞吐量和低吞吐量的处理速率分别为 20 msg/s 和 10msg/s（根据表 1中的数据进行简化）。使用两个较快的处理器和一个较慢的处理器，我们预计总容量为20+20+10 = 50条消息/秒。但是，当保持消息的循环分配时，我们无法达到此容量。下图显示了如果流量持续达到每秒50 条消息时会发生什么情况。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*P-Qa3gyPgXtIeZMx.png"alt="如果传入流量保持在 50 条消息/秒，则慢速处理器无法处理总体消息 1/3 的负载，从而导致累积延迟。为了避免高延迟，向该系统添加了额外的资源以维持处理。" /><figcaption aria-hidden="true">如果传入流量保持在 50条消息/秒，则慢速处理器无法处理总体消息 1/3的负载，从而导致累积延迟。为了避免高延迟，向该系统添加了额外的资源以维持处理。</figcaption></figure><p>从这个例子中我们可以看到，我们的处理器服务一次最多只能接受 30条消息，以防止滞后并确保及时传递更新。</p><p>在这种情况下，要实际每秒处理 50 条消息，我们必须总共扩展到 5台机器，以保证及时处理所有消息。由于这种不适当的分配逻辑（66.7％的过度配置），我们会向该系统过度配置额外的两台机器。</p><p>为了每秒处理 50条消息，我们需要扩展到五台机器以确保及时处理所有消息。由于这种不适当的分配逻辑（66.7%的过度配置），这会导致向该系统过度配置两台额外的机器。</p><h1 id="静态解决方案">静态解决方案</h1><h2 id="在相同的-pod机器上部署">1. 在相同的 Pod（机器）上部署</h2><p>考虑控制服务部署中使用的硬件类型以缓解问题。如果您在虚拟机上部署服务并拥有充足的资源和性能相同的硬件，则此方法是可行的。</p><p>然而，由于成本效益和灵活性下降，在私有云环境中通常不建议采用这种策略，主要是因为同时升级所有现有硬件可能具有挑战性。如果它非常适合您的情况，则可以使用<ahref="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/">Kubernetes关联性将 Pod 分配给某些类型的节点。</a></p><h2 id="加权负载均衡">2. 加权负载均衡</h2><p>如果容量是可预测的并且大部分时间保持静态，则为不同的消费者分配不同的权重可以帮助最大限度地利用可用资源。例如，在为表现较好的消费者赋予更高的权重后，我们可以将更多流量路由给这些消费者。</p><h1 id="动态解决方案">动态解决方案</h1><p>虽然我们可以估计消息的容量和工作负载来设计静态规则来确定加权负载平衡策略，但由于以下几个因素，这种方法在实际生产环境中可能并不总是可行：</p><ul><li>消息的工作负载并不统一，这使得估计机器容量变得困难。</li><li>依赖关系（例如网络和第三方连接）不稳定，有时会导致实际处理中的容量发生变化。</li><li>该系统经常添加新功能，增加额外的维护工作以保持权重更新。</li></ul><p>为了解决这些问题，我们可以动态监控每个分区中的当前滞后并根据当前流量状况做出相应响应。</p><p>有 2 种思路：</p><ol type="1"><li><strong>生产者角度</strong>：使用自定义算法根据滞后的消息数量来确定每个分区的流量，这种生产者称为滞后感知生产者（Lag-awareProducer）。</li><li><strong>消费者角度</strong>：这些消费者旨在监控当前滞后的消息数量，并可以在必要时取消订阅以触发负载重新平衡。通常，可以采用自定义的重新平衡策略来调整分区分配。这种消费者称为滞后感知消费者（Lag-awareComsumer）。</li></ol><h2 id="从生产者角度出发">1. 从生产者角度出发</h2><p>如此图所示，生产者可以使用自定义算法根据滞后确定每个分区的流量。为了减少对Kafka代理的调用次数，系统可以维护一个内部延迟缓存，而不是在发布每条消息之前调用Kafka 代理。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*Mg1lxKzMTy7LRAXT.png"alt="在此示例中，分区 4 和 6 的延迟比其他分区高得多。应减少从内部生产者发送到这些分区的流量。" /><figcaption aria-hidden="true">在此示例中，分区 4 和 6的延迟比其他分区高得多。应减少从内部生产者发送到这些分区的流量。</figcaption></figure><p>使用滞后数据，定制的算法被设计为向经历高滞后的分区发布更少的流量，向低滞后的分区发布更多流量，以平衡每个分区上的工作负载。当滞后平衡且稳定时，此方法应确保消息的均匀分布。</p><p>不适用情况：</p><ol type="1"><li><strong>纯消费者应用程序</strong>：您的应用程序不控制消息生成。</li><li><strong>多个消费者组：</strong>当生成的消息被多个消费者组消费时，生产者可能会为其他消费者组产生不必要的倾斜负载，因为滞后只是特定于一个消费者组的信息。</li></ol><h3 id="相同队列长度算法">相同队列长度算法</h3><p>该算法将每个分区滞后视为处理的队列大小。获取滞后信息后，它会发布适当数量的消息以填充短队列。此方法更适合由于异构硬件而导致的倾斜滞后分布，其中高性能Pod（机器）在大多数情况下能够更快地处理。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*zp-S1Y_GbIzbjCX4.png"alt="相同队列长度算法的演示。最初，不同队列的长度不同。该算法尝试生成不同数量的消息，以在所有队列中实现相同的队列长度。这里，队列长度和 Kafka lag 是同一个概念，代表尚未处理的消息数量" /><figcaptionaria-hidden="true">相同队列长度算法的演示。最初，不同队列的长度不同。该算法尝试生成不同数量的消息，以在所有队列中实现相同的队列长度。这里，队列长度和Kafka lag 是同一个概念，代表尚未处理的消息数量</figcaption></figure><h3 id="异常值检测算法">异常值检测算法</h3><p>该算法利用统计方法来确定所有分区的上离群值，并暂时停止那些慢速离群值的发布过程。在原文章中，针对Agoda 的特定需求，他们提出了 IQR（四分位距）和STD（标准差）异常值检测算法。算法流程图如下所示。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*pjkj5kF6aFcWwBwU.png"alt="异常值检查算法流程" /><figcaption aria-hidden="true">异常值检查算法流程</figcaption></figure><ul><li><strong>慢速分区：</strong>（已关闭）由于存在延迟，这些分区的消息生成已停止。</li><li><strong>好的分区</strong>：（打开）照常发布并均匀分发到所有好的分区。</li><li><strong>OK分区：</strong>（观察/半开放）为了提高性能不佳的机器的性能，当系统尝试将慢速分区提升为良好分区时，会添加一个观察期。通过仅生成一小部分消息并进行观察，可以将该观察阶段优化为“半开放”状态。当滞后获取间隔相对较长时，半开放是有益的，因为它可以防止消费者延迟等待传入消息而更新的滞后数据尚未查询的情况。</li></ul><h2 id="从消费者角度出发">2. 从消费者角度出发</h2><p>这里 Adoga提出的思路是：<strong>遇到高延迟的实例可以主动取消订阅主题以触发重新平衡。在重新平衡期间，可以使用自定义的分配器来平衡所有消费者实例之间的分区。</strong></p><p>触发重新平衡的成本非常昂贵，因为急切的重新平衡会停止消费者组中的所有处理。Kafka2.4中引入的<ahref="https://www.confluent.io/blog/incremental-cooperative-rebalancing-in-kafka/">增量协作再平衡协议</a>已经最大限度地减少了性能影响，允许更频繁的再平衡以更好地分配每个分区上的负载。</p><p>为了增强重新分配的灵活性，分区的数量应该大于 worker的数量。这一比率应根据应用程序而有所不同，并假设一个工作线程至少可以处理来自一个分区的负载以避免饥饿。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/0*68P7QtdFGeIzwZSs.png"alt="在此示例中，工作程序 3 在速度较慢的硬件上运行，导致分区 5 和 6 出现更高的延迟。因此，工作程序 3 可能会主动取消订阅主题以触发重新平衡并更有效地重新分配分区。在此示例中，应实现自定义分配器以根据机器指标和滞后信息重新分配分区。" /><figcaption aria-hidden="true">在此示例中，工作程序 3在速度较慢的硬件上运行，导致分区 5 和 6 出现更高的延迟。因此，工作程序 3可能会主动取消订阅主题以触发重新平衡并更有效地重新分配分区。在此示例中，应实现自定义分配器以根据机器指标和滞后信息重新分配分区。</figcaption></figure><h1 id="总结">总结</h1><p>本文从 Kafka 并行性的一般实现出发，探讨了 Kafka实现负载均衡在现实实践中可能遇到的各种挑战，并从静态调整和动态调整两个方面给出了解决思路，特别注重讨论了动态调整策略，并分别从生产者和消费者的角度提出了解决方案。</p><p>总之，通过在 Kafka中实现负载均衡，可以有效地将工作负载分配到可用资源之间，从而显著提高服务性能。具体的算法和策略需要根据实际情况进行选择和调整。</p>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习记录：用 Go 自制解释器 Monkey</title>
    <link href="/2024/05/12/monkey-language/"/>
    <url>/2024/05/12/monkey-language/</url>
    
    <content type="html"><![CDATA[<h1 id="词法分析">词法分析</h1><p>TDD：测试驱动开发</p><p>先写测试用例，再进行词法分析逻辑的完善。</p><h1 id="语法分析">语法分析</h1><p>递归下降语法分析伪代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go">function parseProgram() &#123;<br>    program = newProgramASTNode()<br>    advanceTokens()<br>    <span class="hljs-keyword">for</span> (currentToken() != EOF_TOKEN) &#123;<br>        statement = null<br>        <span class="hljs-keyword">if</span> (currentToken() == LET_TOKEN) &#123;<br>            statement = parseLetStatement()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken() == RETURN_TOKEN) &#123;<br>            statement = parseReturnStatement()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken() == IF_TOKEN) &#123;<br>            statement = parseIfStatement()<br>        &#125;<br>        <span class="hljs-keyword">if</span> (statement != null) &#123;<br>            program.Statements.push(statement)<br>        &#125;<br>        advanceTokens()<br>    &#125;<br>    <span class="hljs-keyword">return</span> program<br>&#125;<br>function parseLetStatement() &#123;<br>    advanceTokens()<br>    identifier = parseIdentifier()<br>    advanceTokens()<br>    <span class="hljs-keyword">if</span> currentToken() != EQUAL_TOKEN &#123;<br>        parseError(<span class="hljs-string">&quot;no equal sign!&quot;</span>)<br>        <span class="hljs-keyword">return</span> null<br>    &#125;<br>    advanceTokens()<br>    value = parseExpression()<br>    variableStatement = newVariableStatementASTNode()<br>    variableStatement.identifier = identifier<br>    variableStatement.value = value<br>    <span class="hljs-keyword">return</span> variableStatement<br>&#125;<br>function parseIdentifier() &#123;<br>    identifier = newIdentifierASTNode()<br>    identifier.token = currentToken()<br>    <span class="hljs-keyword">return</span> identifier<br>&#125;<br>function parseExpression() &#123;<br>    <span class="hljs-keyword">if</span> (currentToken() == INTEGER_TOKEN) &#123;<br>        <span class="hljs-keyword">if</span> (nextToken() == PLUS_TOKEN) &#123;<br>            <span class="hljs-keyword">return</span> parseOperatorExpression()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextToken() == SEMICOLON_TOKEN) &#123;<br>            <span class="hljs-keyword">return</span> parseIntegerLiteral()<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentToken() == LEFT_PAREN) &#123;<br>        <span class="hljs-keyword">return</span> parseGroupedExpression()<br>    &#125;<br><span class="hljs-comment">// [...]</span><br>&#125;<br>function parseOperatorExpression() &#123;<br>    operatorExpression = newOperatorExpression()<br>    operatorExpression.left = parseIntegerLiteral()<br>    operatorExpression.operator = currentToken()<br>    operatorExpression.right = parseExpression()<br>    <span class="hljs-keyword">return</span> operatorExpression()<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512042659060.png"alt="递归下降分析法" /><figcaption aria-hidden="true">递归下降分析法</figcaption></figure><h2 id="let-x5">let x=5</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512035446100.png"alt="let stmt AST structure" /><figcaption aria-hidden="true">let stmt AST structure</figcaption></figure><h2 id="return-5">return 5</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512045650041.png"alt="return stmt AST structue" /><figcaption aria-hidden="true">return stmt AST structue</figcaption></figure><h2 id="普拉特解析">普拉特解析</h2>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
      <category>Go 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间处理基础：Rust 的 chrono 库教程</title>
    <link href="/2024/05/11/rust-crate-chrono/"/>
    <url>/2024/05/11/rust-crate-chrono/</url>
    
    <content type="html"><![CDATA[<p>在开发过程中，我们经常有对时间和日期处理的需求。不论是日历应用、日程安排、还是时间戳记录，准确的时间数据处理都是必不可少的。Rust社区提供的 <code>chrono</code> 库以其强大的功能和灵活的接口，在 Rust开发者中广受欢迎。本文将简单介绍 <code>chrono</code>库，展示如何利用它来精确处理和转换时间和日期，帮助你在任何 Rust项目中都能高效地管理时间。</p><h1 id="版本">版本</h1><ul><li><code>chrono</code>: 0.4.38</li></ul><h1 id="结论先行">结论先行</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512010241356.png"alt="chrono 各种时间类型转换图" /><figcaption aria-hidden="true">chrono 各种时间类型转换图</figcaption></figure><h1 id="时间相关概念">时间相关概念</h1><table><thead><tr class="header"><th>概念</th><th>理解</th></tr></thead><tbody><tr class="odd"><td>UNIX 时间戳（UNIX Timestamp）</td><td>也称为 POSIX 时间或 Epoch 时间，是自 1970 年 1 月 1 日（UTC时区）以来经过的秒数，不计入闰秒。这是一种非常通用的时间表示方法，在编程中广泛使用，因为它可以简化时间差的计算。</td></tr><tr class="even"><td>UTC（协调世界时）</td><td>全称为协调世界时（Coordinated UniversalTime），是目前国际上广泛采用的时间标准。它基本上与格林威治平均时（GMT）相同，但在技术上更加精确，因为它使用原子钟来保持时间准确。世界各地的时间都是以UTC 为基础，加上或减去一定的小时数来定义的。</td></tr><tr class="odd"><td>时区（Time Zone）</td><td>时区是地球上划分的标准时间区域。由于地球自西向东旋转，每向东移动一定角度，当地的太阳时间就会相应地提前。世界被分成了24个时区，每个时区通常相差一小时。时区允许地区内的人们能在大致相同的时间内，经历类似的日夜更替模式。</td></tr><tr class="even"><td>UTC+8</td><td>UTC+8 是 UTC 时间加上 8小时的时间区。中国大陆就是位于这个时区。例如，当 UTC 时间为 00:00时，UTC+8 的时间就是 08:00。</td></tr></tbody></table><h1 id="chrono-关键类型">chrono 关键类型</h1><table><thead><tr class="header"><th>类型</th><th>含义</th><th>适用场景</th></tr></thead><tbody><tr class="odd"><td>DateTime&lt;Tz&gt;</td><td>一个带有时区的日期和时间类型，其中 <code>Tz</code> 是实现了<code>TimeZone</code> 特质的类型，如 <code>Utc</code> 和<code>Local</code> 。这意味着 <code>DateTime</code>考虑了时区的影响，可以表示全球任意地点的精确时间。</td><td>广泛用于需要考虑时区转换的场景，如存储用户的本地时间或在不同地区之间转换时间。</td></tr><tr class="even"><td>NaiveDateTime</td><td>一个“天真的”日期和时间，即不包含任何时区信息的日期和时间。这种类型仅仅表示一个日历日期和一天中的时间，而没有任何关于地理或政治时区的数据。</td><td>对于一些时区不重要的场景非常有用，比如记录电影的发行日期或历史事件的日期。</td></tr><tr class="odd"><td>NaiveDate</td><td>仅表示一个日历日期，不包括时间或时区信息。</td><td>它用于处理只需要日期而不关心具体时间的场景，如生日、节日等。</td></tr><tr class="even"><td>NaiveTime</td><td>是一个只表示一天中时间的类型，它不包含日期或时区信息。</td><td>这个类型适用于需要处理具体某个时间点（如开会时间、日常活动的开始时间）但不需要日期数据的情景。</td></tr></tbody></table><h1 id="chrono-时区类型">chrono 时区类型</h1><p><code>chrono</code>支持多种时区类型，方便进行全球时间的转换和计算：</p><ul><li><strong><code>Utc</code></strong>: 用于处理协调世界时。</li><li><strong><code>Local</code></strong>:代表服务器或用户的本地时区。</li><li><strong><code>FixedOffset</code></strong>:允许定义任意的小时和分钟偏移量，适合固定偏移的时间计算。</li></ul><h1 id="常用功能">常用功能</h1><h2 id="获取当前时间">获取当前时间</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span>: DateTime&lt;Local&gt; = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">utc_datetime</span>: DateTime&lt;Utc&gt; = Utc::<span class="hljs-title function_ invoke__">now</span>();<br></code></pre></td></tr></table></figure><h2 id="datetime-转-string">DateTime 转 String</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">to_rfc2822</span>()); <span class="hljs-comment">// Sun, 12 May 2024 00:15:55 +0800</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">to_rfc3339</span>()); <span class="hljs-comment">// 2024-05-12T00:15:55.325058+08:00</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">to_string</span>()); <span class="hljs-comment">// 2024-05-12 00:15:55.325058 +08:00</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, local_datetime.format(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)) <span class="hljs-comment">// 2024-05-12 00:15:55</span><br></code></pre></td></tr></table></figure><h2 id="string-转-datetime">String 转 DateTime</h2><p>字符串带时区信息，使用<code>DateTime::parse_from_str(s, f)</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">format_withzone</span> = <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">datetime_withzone_str</span> = <span class="hljs-string">&quot;2024-01-01 00:00:00 +08:00&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span> =<br>    DateTime::<span class="hljs-title function_ invoke__">parse_from_str</span>(&amp;datetime_withzone_str, &amp;format_withzone).<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><p>字符串无时区信息，使用<code>NaiveDateTime::parse_from_str(s, f)</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">format</span> = <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">datetime_str</span> = <span class="hljs-string">&quot;2024-01-01 00:00:00&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span> = NaiveDateTime::<span class="hljs-title function_ invoke__">parse_from_str</span>(&amp;datetime_str, &amp;format)<br>    .<span class="hljs-title function_ invoke__">unwrap</span>()<br>    .<span class="hljs-title function_ invoke__">and_local_timezone</span>(Local) <span class="hljs-comment">// 转为带时区的 DateTime</span><br>    .<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><h2 id="datetime-转-timestamp">DateTime 转 timestamp</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span> = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;seconds: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp</span>()); <span class="hljs-comment">// 1715444324</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;millis: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp_millis</span>()); <span class="hljs-comment">// 1715444338610</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;micros: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp_micros</span>()); <span class="hljs-comment">// 1715444338610873</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;nacos: &#123;&#125;&quot;</span>, local_datetime.<span class="hljs-title function_ invoke__">timestamp_nanos_opt</span>().<span class="hljs-title function_ invoke__">unwrap</span>()); <span class="hljs-comment">// 1715444338610873000</span><br></code></pre></td></tr></table></figure><h2 id="timestamp-转-datetime">timestamp 转 DateTime</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">utc_datetime</span>: DateTime&lt;Utc&gt; = DateTime::<span class="hljs-title function_ invoke__">from_timestamp</span>(<span class="hljs-number">1704139200</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// 默认是 Utc</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">local_datetime</span>: DateTime&lt;Local&gt; = DateTime::<span class="hljs-title function_ invoke__">from_timestamp</span>(<span class="hljs-number">1704139200</span>, <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">into</span>(); <span class="hljs-comment">// 使用 into() 转为 Local</span><br></code></pre></td></tr></table></figure><h2 id="时区转换">时区转换</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> chrono::&#123;DateTime, FixedOffset, Utc&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">utc_date_time</span>: DateTime&lt;Utc&gt; = Utc::<span class="hljs-title function_ invoke__">now</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">fixed_offset</span> = FixedOffset::<span class="hljs-title function_ invoke__">east</span>(<span class="hljs-number">8</span> * <span class="hljs-number">3600</span>); <span class="hljs-comment">// 转为 utc+8 东八区</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">local_date_time</span> = utc_date_time.<span class="hljs-title function_ invoke__">with_timezone</span>(&amp;fixed_offset);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Local time in UTC+8: &#123;&#125;&quot;</span>, local_date_time);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间计算">时间计算</h2><p>时间加减：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> chrono::&#123;Duration, Local&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">now</span> = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">yesterday</span> = now - Duration::<span class="hljs-title function_ invoke__">hours</span>(<span class="hljs-number">24</span>);<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512002330526.png"alt="chrono time duration methods" /><figcaption aria-hidden="true">chrono time duration methods</figcaption></figure><p>时间间隔：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> chrono::&#123;Duration, Local&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">now</span> = Local::<span class="hljs-title function_ invoke__">now</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">yesterday</span> = now - Duration::<span class="hljs-title function_ invoke__">hours</span>(<span class="hljs-number">24</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">hour_interval</span> = (now - yesterday).<span class="hljs-title function_ invoke__">num_hours</span>();<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240512002106738.png"alt="chrono time interval methods" /><figcaption aria-hidden="true">chrono time interval methods</figcaption></figure><h1 id="总结">总结</h1><p>通过本文的详细介绍和实用示例，我们了解了如何使用 Rust 的<code>chrono</code> 库来精确处理时间和日期。<code>chrono</code>不仅支持复杂的时区计算和全球时间管理，还提供了方便的日期时间解析和格式化工具，以及灵活的时间运算功能。掌握了这些技能后，你将能够在任何需要精确时间数据处理的Rust 应用中，提供稳定和高效的解决方案。</p><p>时间是每个程序的基石，而 <code>chrono</code>就是那把能够操纵时间的魔杖。</p><p>希望本文能对你有帮助，peace! enjoy coding~</p><blockquote><p>参考：</p><ul><li><a href="https://docs.rs/chrono/latest/chrono/">chronocrate</a></li><li><ahref="https://blog.stackademic.com/rust-working-with-date-and-time-30e003cd59e8">rust-working-with-date-and-time</a></li></ul><p>作图：</p><ul><li>https://excalidraw.com/</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 常用库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>epoll</title>
    <link href="/2024/04/28/epoll/"/>
    <url>/2024/04/28/epoll/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><code>epoll</code> 是一种 I/O多路复用技术，主要用于高性能的网络服务器中，特别是在处理大量并发连接时。它是Linux 特有的，自 Linux 内核 2.5.44版本引入，并在后续版本中不断优化。<code>epoll</code>能够帮助服务器高效地管理数以千计的客户端连接，是 <code>select</code> 和<code>poll</code> 方法的现代替代品。</p><p>本文不对 <code>epoll</code>的源码进行分析，仅做原理上的总结，方便快速查阅回顾。各大论坛很多大佬都对<code>epoll</code>的源码进行了详尽的分析，感兴趣的读者可以看「参考」篇章。</p><h1 id="主要特点">主要特点</h1><ol type="1"><li><strong>效率高</strong>: 相较于 <code>select</code> 和<code>poll</code>，<code>epoll</code>可以更高效地处理大量的并发连接。<code>select</code> 和 <code>poll</code>的效率随着监视的文件描述符数量增加而线性下降，而 <code>epoll</code>则不会因为监视的文件描述符数量增加而显著降低效率。</li><li><strong>扩展性好</strong>: <code>epoll</code>使用一种称为事件通知的机制，只会处理那些真正发生了事件的文件描述符。这意味着系统不必重新检查所有文件描述符，从而大大减少了不必要的CPU 开销。</li><li><strong>支持边缘触发和水平触发</strong>: <code>epoll</code> 支持<code>Edge Triggered</code> 和水平触发 <code>Level Triggered</code>两种模式。边缘触发模式只在文件描述符状态改变时才通知应用程序，适用于非阻塞I/O；而水平触发模式则在有事件可读或可写时都会通知应用程序，更容易使用但效率略低。</li></ol><h1 id="结论先行">结论先行</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240429121302958.png"alt="epoll flow chart" /><figcaption aria-hidden="true">epoll flow chart</figcaption></figure><h1 id="工作原理">工作原理</h1><p><code>epoll</code> 的工作可以分为三个主要步骤：</p><ol type="1"><li><strong>创建 epoll 实例</strong>: 使用 <code>epoll_create</code>函数创建一个 <code>epoll</code> 实例。</li><li><strong>添加/修改/删除文件描述符</strong>: 使用<code>epoll_ctl</code> 函数将新的文件描述符添加到 <code>epoll</code>实例中，或者修改、删除已存在的文件描述符。这些操作与文件描述符的数量无关，因此执行速度非常快。</li><li><strong>等待事件发生</strong>: 使用 <code>epoll_wait</code>函数等待事件的发生。这个函数可以同时监控多个文件描述符，当指定的文件描述符上发生了注册的事件时，函数返回，并告知哪些文件描述符上发生了事件。</li></ol><h1 id="et-lt">ET &amp; LT</h1><p>在 <code>epoll</code> 中，边缘触发（ET, EdgeTriggered）和水平触发（LT, LevelTriggered）是两种不同的事件通知方式，它们定义了操作系统如何通知应用程序文件描述符上的I/O 事件。</p><p>这两种模式的主要区别在于何时以及如何多次通知应用程序关于某个文件描述符的事件。</p><h2 id="水平触发level-triggered">水平触发（Level Triggered）</h2><ul><li><strong>定义</strong>: 在水平触发模式下，只要文件描述符上有未处理的I/O 事件存在，<code>epoll_wait</code>就会通知应用程序。这意味着，如果数据可读取但未被完全读取，<code>epoll_wait</code>会在下次调用时再次返回该文件描述符。</li><li><strong>行为</strong>:这种模式更容易编程，因为应用程序可以不用担心在一个操作中处理所有数据。如果数据还在，<code>epoll_wait</code>会继续通知你。</li><li><strong>适用场景</strong>:更适合那些简单的应用或者对实时性要求不是非常高的应用，因为它简化了处理逻辑。</li></ul><h2 id="边缘触发edge-triggered">边缘触发（Edge Triggered）</h2><ul><li><strong>定义</strong>:在边缘触发模式下，只有状态变化时（例如从无数据到有数据），<code>epoll_wait</code>才会通知应用程序。一旦通知了应用程序某事件发生，除非有新的数据到达或状态再次发生变化，否则不会再次通知应用程序该事件。</li><li><strong>行为</strong>:这要求应用程序必须立即处理所有事件，因为之后不会再收到关于这些事件的通知。这意味着应用程序必须循环读取或写入，直到数据被完全处理完，以确保不遗漏任何事件。</li><li><strong>适用场景</strong>:适合需要高性能的场景，因为它减少了事件处理的次数，但要求程序必须更加小心地管理I/O 操作。</li></ul><h2 id="比较和选择">比较和选择</h2><ul><li><strong>性能</strong>:边缘触发通常提供更高的性能，因为它减少了系统调用的次数和不必要的事件处理。</li><li><strong>编程复杂性</strong>:边缘触发模式编程比水平触发复杂，因为需要确保每次事件被彻底处理，并且更容易遇到如“惊群效应”（多个进程或线程被同一个事件唤醒）等问题。</li><li><strong>可靠性</strong>:水平触发因为其简单的行为模式，在可靠性处理上更为直接和容易。</li></ul><p>通常，选择哪种模式取决于应用的具体需求、预期的负载以及开发者对事件处理逻辑的控制程度。高性能服务器通常选择边缘触发模式，以最大化其效率，而简单的或者低负载应用可能会更倾向于使用水平触发，以简化开发和调试过程。</p><h1 id="数据结构">数据结构</h1><p><code>epoll</code> 使用 2种关键的数据结构来维护和跟踪文件描述符（FD）和事件：</p><ol type="1"><li><strong>红黑树（Red-Black Tree）</strong>:用于存储所有注册的文件描述符及其事件。红黑树是一种自平衡二叉搜索树，能够在对数时间内完成插入、删除和查找操作，这使得管理大量文件描述符变得高效。</li><li><strong>就绪列表（Ready List）</strong>:当事件发生（如可读、可写等）并被内核检测到时，相应的 FD会被添加到一个就绪列表中。这个列表仅包含实际有事件发生的文件描述符，从而减少了<code>epoll_wait</code> 调用的处理时间。</li></ol><h1 id="工作细节">工作细节</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/epoll_principle.jpg"alt="epoll data structure" /><figcaption aria-hidden="true">epoll data structure</figcaption></figure><ol type="1"><li>通过调用 <code>epoll_create()</code> 函数创建并初始化一个<code>eventpoll</code> 对象。</li><li>通过调用 <code>epoll_ctl()</code> 函数把被监听的文件句柄 (如 socket句柄) 封装成 <code>epitem</code> 对象并且添加到 <code>eventpoll</code>对象的红黑树中进行管理。</li><li>通过调用 <code>epoll_wait()</code>函数等待被监听的文件状态发生改变。</li><li>当被监听的文件状态发生改变时（如 socket接收到数据），会把文件句柄对应 <code>epitem</code> 对象添加到<code>eventpoll</code> 对象的就绪队列 <code>rdllist</code>中。并且把就绪队列的文件列表复制到 <code>epoll_wait()</code> 函数的<code>events</code> 参数中。</li><li>唤醒调用 <code>epoll_wait()</code> 函数被阻塞（睡眠）的进程。</li></ol><h1 id="事件监听">事件监听</h1><p>内核中的事件监听和回调机制是通过高效的事件驱动模型实现的，而不是简单的循环检查（如在用户空间中的轮询）。这种机制利用了现代操作系统的中断和回调系统，以及针对异步事件的优化处理策略。</p><p>以下是这个过程的详细解释：</p><h2 id="中断和中断处理">1. 中断和中断处理</h2><p>在硬件层面，大多数 I/O 操作（如网络通信、磁盘I/O）都是通过中断驱动的。当一个 I/O设备准备好数据或需要服务时，它会产生一个中断信号，这个信号被发送到CPU。CPU 响应中断，并执行一个预定的中断处理程序（Interrupt ServiceRoutine, ISR），该程序是由设备的驱动程序提供的。</p><h2 id="事件和回调">2. 事件和回调</h2><p>在 ISR中，与设备相关的事件（例如网络包的接收、硬盘读取完成）会被检测到，并且可以在此阶段调用特定的回调函数。这些回调函数是在设备驱动或相关的内核模块中定义的，用来通知内核其他部分或者相关的进程有关事件的发生。</p><h2 id="文件描述符的回调机制">3. 文件描述符的回调机制</h2><p>对于 <code>epoll</code> 等 I/O多路复用技术，内核为每个文件描述符维护了一个事件处理机制。当文件描述符被创建时，相关的设备或资源会注册一组回调函数，这些函数会在特定的操作（如读、写、错误）上被触发。例如，一个网络套接字可能会在数据到达时触发一个“可读”事件的回调。</p><h2 id="epoll-的事件绑定">4. <code>epoll</code> 的事件绑定</h2><p>当一个文件描述符被加入到 <code>epoll</code>监听队列中，<code>epoll</code>会利用这些回调来获得事件通知。<code>epoll</code>操作相关的代码会将一个额外的回调函数绑定到这些文件描述符上。当文件描述符的状态改变时（如数据可读），这个回调函数将被触发，然后它会将相应的文件描述符标记为“就绪”，并放入<code>epoll</code> 的就绪队列。</p><h2 id="事件通知和唤醒">5. 事件通知和唤醒</h2><p>当 <code>epoll_wait</code>被调用且有事件就绪时，内核会检查就绪队列，并将这些事件传递给等待的进程。如果没有事件就绪，进程将被挂起直到有事件发生。事件的发生会触发内核调度程序唤醒相应的进程。</p><h2 id="效率和性能">6. 效率和性能</h2><p>这种基于中断的事件通知机制意味着内核不需要不断循环检查每个文件描述符的状态，从而极大地提高了效率。事件只有在实际发生时才被处理，且处理通常是由硬件中断直接触发的，这使得整个系统更加响应快速，减少了无效的CPU 使用。</p><p>这种设计使得 Linux 内核在处理大量并发 I/O操作时能够保持高效和稳定，适合构建高性能的网络服务和应用。</p><h1 id="中断">中断</h1><p>中断机制是计算机硬件和操作系统核心功能之一，它允许外设或硬件异步地通知CPU 需要处理某些事件。中断机制的实现并不依赖于类似于 <code>for</code>循环的轮询检查，而是建立在更为直接和高效的硬件和处理器架构支持之上。</p><p>当 CPU接收到中断信号时，它是通过一套内建于硬件的协调机制来识别和响应中断的。这个过程涉及硬件电路设计、处理器架构和操作系统的中断管理功能。</p><p>以下是 CPU 如何知道有中断发生，并且如何处理这一中断的详细步骤：</p><h2 id="中断信号的检测和响应">中断信号的检测和响应</h2><ol type="1"><li><p><strong>中断请求线（IRQ）</strong>：外部设备通过连接到处理器的一个特定的硬件线路（IRQ）发送中断信号。这个线路直接与处理器内的中断控制单元（InterruptController）相连。</p></li><li><p><strong>中断控制器</strong>：大多数现代计算机系统使用一个或多个中断控制器来管理中断信号。中断控制器的任务是接收来自各种外部设备的中断请求，并将这些请求优先级排序后发送给CPU。</p></li><li><p><strong>中断向量</strong>：当中断控制器接收到一个中断信号后，它会根据中断源确定一个中断向量。这个向量是一个数字，指向中断向量表中对应的入口，该入口包含了处理该中断的中断服务例程（ISR）的地址。</p></li></ol><h2 id="cpu-如何处理中断">CPU 如何处理中断</h2><ol type="1"><li><p><strong>当前指令的完成</strong>：当 CPU接收到中断控制器发出的中断信号时，它首先会完成当前执行的指令。这是为了保证程序的状态能够正确保存，从而在中断处理完毕后可以无缝地恢复执行。</p></li><li><p><strong>保存上下文</strong>：一旦当前指令执行完毕，CPU会自动保存当前的程序状态，包括程序计数器（PC）、寄存器和其他必要的状态信息。这些信息通常被推送到当前的栈上。</p></li><li><p><strong>跳转到 ISR</strong>：CPU使用中断向量来访问中断向量表，找到与中断号对应的中断服务例程（ISR）的地址，并跳转到该地址开始执行ISR。这个过程是自动的，由处理器的内部机制控制。</p></li><li><p><strong>执行ISR</strong>：中断服务例程会执行必要的操作来处理中断，比如读取数据缓冲区、清除设备状态或发送信号等。</p></li><li><p><strong>恢复上下文并返回</strong>：一旦 ISR执行完成，处理器会从栈上恢复之前保存的程序状态，并将控制权返回到被中断的程序，继续执行。</p></li></ol><h2 id="硬件支持">硬件支持</h2><p>这一过程大量依赖于处理器的硬件支持，如中断向量表通常是固定在处理器的特定内存地址上的。此外，现代处理器如x86架构还提供了更高级的功能，比如支持多重中断控制器和高级可编程中断控制器（APIC）等。</p><p>这种基于硬件的中断响应机制允许 CPU快速有效地处理各种外部事件，确保系统的响应性和稳定性。</p><h1 id="参考">参考</h1><ul><li><ahref="https://blog.csdn.net/zhangyanfei01/article/details/114959103">图解| 深入揭秘 epoll 是如何实现 IO 多路复用的！</a></li><li><ahref="https://blog.csdn.net/zhpCSDN921011/article/details/125580548">一图总结epoll 的总体工作流程</a></li><li><ahref="https://thetechsolo.wordpress.com/2016/02/29/scalable-io-events-vs-multithreading-based/">scalable-io-events-vs-multithreading-based</a></li><li><ahref="https://github.com/liexusong/linux-source-code-analyze/blob/master/epoll-principle.md">Epoll实现原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/667412830">网络编程之 epoll源码深度剖析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>epoll</tag>
      
      <tag>网络编程</tag>
      
      <tag>非阻塞 I/0</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 实战丨并发构建倒排索引</title>
    <link href="/2024/04/23/rust-action-inverted-index-concurrency/"/>
    <url>/2024/04/23/rust-action-inverted-index-concurrency/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>继上篇 <ahref="https://hedon.top/2024/04/15/rust-action-inverted-index-demo/">Rust实战丨倒排索引</a>，本篇我们将参考《Rust程序设计（第二版）》中并发编程篇章来实现高并发构建倒排索引。</p><p>本篇主要分为以下几个部分：</p><ol type="1"><li>功能展示：展示我们最终实现的 2个工具的效果（构建索引、搜索功能）</li><li>阅读源码：阅读书中源码的实现，理清大体思路。</li><li>构建索引：实战构建索引的每个具体环节，并对核心逻辑进行解释和阐述缘由。</li><li>搜索功能：这是书中未曾提供的功能，笔者根据自身理解，对齐上篇提供的功能，实现了一个搜索功能。</li></ol><p>能学到：</p><ul><li>Rust 各种迭代器的使用</li><li>Rust 文件常用操作</li><li>Rust 字符串常用操作</li><li>Rust channel 实战</li><li>Rust 并发编程</li><li>多路合并文件实际应用</li><li>使用 <code>byteorder</code> 进行位操作</li><li>使用 <code>clap</code> 进行 CLI 开发</li><li>终端高亮输出</li><li>深入理解倒排索引高性能的核心细节</li></ul><h1 id="阅读建议">阅读建议</h1><p>本篇内容较为冗长，涉及到的细节讲解可能比较啰嗦，推荐<strong>直接阅读源码，然后对不理解的地方再来本篇对应的章节进行阅读</strong>。</p><p>完成源码位于：https://github.com/hedon-rust-road/inverted-index-concurrency</p><h1 id="版本声明">版本声明</h1><ul><li>Rust: 1.76</li><li>byteordrr: 1.5.0</li><li>clap: 4.5.0</li><li>运行环境：macbookPro Apple M2 Max</li></ul><h1 id="功能展示">功能展示</h1><h2 id="create.rs">create.rs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: create [OPTIONS] &lt;FILENAMES&gt;...<br><br>Arguments:<br>  &lt;FILENAMES&gt;...<br><br>Options:<br>  -s, --single-threaded  Default <span class="hljs-literal">false</span><br>  -h, --<span class="hljs-built_in">help</span>             Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>指定文件目录，构建索引，可以使用 <code>-s</code>使用单线程构建，默认使用并发构建。</p><p>执行示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  inverted-index-concurrency git:(master) ✗ cargo run --bin create ./texts<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.08s<br>     Running `/Users/wangjiahan/rust-target/debug/create ./texts`<br>indexed document 0:<span class="hljs-string">&quot;./texts/text1.txt&quot;</span>, 22 bytes, 5 words<br>indexed document 1:<span class="hljs-string">&quot;./texts/text3.txt&quot;</span>, 27 bytes, 5 words<br>indexed document 2:<span class="hljs-string">&quot;./texts/text2.txt&quot;</span>, 39 bytes, 6 words<br>word count: 16<br>351 bytes main, 736 bytes total<br>wrote file <span class="hljs-string">&quot;./tmp00000001.dat&quot;</span><br></code></pre></td></tr></table></figure><h2 id="search.rs">search.rs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: search --index-file &lt;INDEX_FILE&gt; --term &lt;TERM&gt;<br><br>Options:<br>  -i, --index-file &lt;INDEX_FILE&gt;  Specify index file path<br>  -t, --term &lt;TERM&gt;              Specify search term<br>  -h, --<span class="hljs-built_in">help</span>                     Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>指定索引文件和搜索词来进行搜索。</p><p>执行示例如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423201406903.png"alt="search.rs 执行示例" /><figcaption aria-hidden="true">search.rs 执行示例</figcaption></figure><h1 id="阅读源码">阅读源码</h1><blockquote><p>书中的源码位于：<ahref="https://github.com/ProgrammingRust/fingertips/tree/master">fingertips</a></p></blockquote><p>第一部分我们先来阅读源码，书中展示了这样一张图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image00882.jpeg"alt="索引构建器管道，其中箭头表示通过通道将值从一个线程发送到另一个线程（未展示磁盘 I/O）" /><figcaptionaria-hidden="true">索引构建器管道，其中箭头表示通过通道将值从一个线程发送到另一个线程（未展示磁盘I/O）</figcaption></figure><p>从这张图我们大概可以猜想本案例中构建并发索引的过程可能是：</p><ol type="1"><li>读取文件内容；</li><li>根据文件内容构建索引；</li><li>多个索引进行合并；</li><li>将索引写入文件；</li><li>多个索引文件进行合并。</li></ol><p>按照这个思路的指引，我们打开源码，从 <code>main.rs</code> 的<code>main()</code> 出发：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">single_threaded</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">filenames</span> = <span class="hljs-built_in">vec!</span>[];<br><br>  <span class="hljs-comment">// 命令行参数解析</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ap</span> = ArgumentParser::<span class="hljs-title function_ invoke__">new</span>();<br>        ap.<span class="hljs-title function_ invoke__">set_description</span>(<span class="hljs-string">&quot;Make an inverted index for searching documents.&quot;</span>);<br>        ap.<span class="hljs-title function_ invoke__">refer</span>(&amp;<span class="hljs-keyword">mut</span> single_threaded).<span class="hljs-title function_ invoke__">add_option</span>(<br>            &amp;[<span class="hljs-string">&quot;-1&quot;</span>, <span class="hljs-string">&quot;--single-threaded&quot;</span>],<br>            StoreTrue,<br>            <span class="hljs-string">&quot;Do all the work on a single thread.&quot;</span>,<br>        );<br>        ap.<span class="hljs-title function_ invoke__">refer</span>(&amp;<span class="hljs-keyword">mut</span> filenames).<span class="hljs-title function_ invoke__">add_argument</span>(<br>            <span class="hljs-string">&quot;filenames&quot;</span>,<br>            Collect,<br>            <span class="hljs-string">&quot;Names of files/directories to index. \</span><br><span class="hljs-string">                           For directories, all .txt files immediately \</span><br><span class="hljs-string">                           under the directory are indexed.&quot;</span>,<br>        );<br>        ap.<span class="hljs-title function_ invoke__">parse_args_or_exit</span>();<br>    &#125;<br><br>  <span class="hljs-comment">// 构建索引</span><br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">run</span>(filenames, single_threaded) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(()) =&gt; &#123;&#125;<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error: &#123;&#125;&quot;</span>, err),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>解析命令行参数，这里使用 <code>argparse</code> 这个比较古老的 crate来解析，现在一般是使用 <code>clap</code>。<ul><li><code>single_threaded:</code> 是否使用单线程，默认是多线程。</li><li><code>filenames</code>: 指定的文本文件或目录。</li></ul></li><li><code>run</code> 函数执行构建索引。</li></ol><p>看一下 <code>run</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Generate an index for a bunch of text files.</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(filenames: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;, single_threaded: <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">output_dir</span> = PathBuf::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">documents</span> = <span class="hljs-title function_ invoke__">expand_filename_arguments</span>(filenames)?;<br><br>    <span class="hljs-keyword">if</span> single_threaded &#123;<br>        <span class="hljs-title function_ invoke__">run_single_threaded</span>(documents, output_dir)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">run_pipeline</span>(documents, output_dir)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>单线程：run_single_threaded</li><li>多线程：run_pipeline</li></ul><p>先从简单看，单线程，忽略掉源码中定义的特殊数据结构，可以发现跟我们上篇介绍的简单版倒排索引思路基本是一致的，只不过本案例中数据是从文件中读，最后又会将索引写入到文件中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_single_threaded</span>(documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">accumulated_index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">merge</span> = FileMerge::<span class="hljs-title function_ invoke__">new</span>(&amp;output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp_dir</span> = TmpDir::<span class="hljs-title function_ invoke__">new</span>(&amp;output_dir);<br><br>    <span class="hljs-comment">// 迭代每个文本文件</span><br>    <span class="hljs-keyword">for</span> (doc_id, filename) <span class="hljs-keyword">in</span> documents.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>      <span class="hljs-comment">// 打开文件，并将内容读取到 `text` 上</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(filename)?;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>        f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> text)?;<br><br>        <span class="hljs-comment">// 构建索引</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_single_document</span>(doc_id, text);<br>        accumulated_index.<span class="hljs-title function_ invoke__">merge</span>(index);<br>        <span class="hljs-keyword">if</span> accumulated_index.<span class="hljs-title function_ invoke__">is_large</span>() &#123;<br>            <span class="hljs-comment">// 当索引足够大的时候，将其写到文件中</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(accumulated_index, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>            merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>            accumulated_index = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将最后一个索引写入到文件中</span><br>    <span class="hljs-keyword">if</span> !accumulated_index.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(accumulated_index, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>        merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>    &#125;<br>    merge.<span class="hljs-title function_ invoke__">finish</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看本文的重头戏，多线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_pipeline</span>(documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// 将构建索引分为 5 个过程</span><br>    <span class="hljs-keyword">let</span> (texts, h1) = <span class="hljs-title function_ invoke__">start_file_reader_thread</span>(documents);<br>    <span class="hljs-keyword">let</span> (pints, h2) = <span class="hljs-title function_ invoke__">start_file_indexing_thread</span>(texts);<br>    <span class="hljs-keyword">let</span> (gallons, h3) = <span class="hljs-title function_ invoke__">start_in_memory_merge_thread</span>(pints);<br>    <span class="hljs-keyword">let</span> (files, h4) = <span class="hljs-title function_ invoke__">start_index_writer_thread</span>(gallons, &amp;output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">merge_index_files</span>(files, &amp;output_dir);<br><br>    <span class="hljs-comment">// 等待所有线程执行完毕</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = h1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h3.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = h4.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    r1?;<br>    r4?;<br>    result<br>&#125;<br></code></pre></td></tr></table></figure><p>首先将索引构建分成 5 个阶段：</p><p><strong>1. start_file_reader_thread</strong></p><p>就是从文件中读取文本信息，并将其扔进<code>Receiver&lt;String&gt;</code> channel 中，传到下一个阶段。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_reader_thread</span>(<br>    documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;<span class="hljs-type">String</span>&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">filename</span> <span class="hljs-keyword">in</span> documents &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(filename)?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>          <span class="hljs-comment">// 读取文件内容</span><br>            f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> text)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(text).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. start_file_indexing_thread</strong></p><p>从第 1 步传过来的文本信息中调用<code>InMemoryIndex::from_single_document</code> 构建索引。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_indexing_thread</span>(<br>    texts: Receiver&lt;<span class="hljs-type">String</span>&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> (doc_id, text) <span class="hljs-keyword">in</span> texts.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>          <span class="hljs-comment">// 构建索引</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_single_document</span>(doc_id, text);<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. start_in_memory_merge_thread</strong></p><p>将第 2 步构建的单一索引进行合并，并将合并后的索引传到下一个阶段。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_in_memory_merge_thread</span>(<br>    file_indexes: Receiver&lt;InMemoryIndex&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">accumulated_index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">fi</span> <span class="hljs-keyword">in</span> file_indexes &#123;<br>          <span class="hljs-comment">// 将索引进行合并</span><br>            accumulated_index.<span class="hljs-title function_ invoke__">merge</span>(fi);<br>            <span class="hljs-keyword">if</span> accumulated_index.<span class="hljs-title function_ invoke__">is_large</span>() &#123;<br>              <span class="hljs-comment">// 如果索引大小到达阈值，则传到下一阶段</span><br>                <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                accumulated_index = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !accumulated_index.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index);<br>        &#125;<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. start_index_writer_thread</strong></p><p>将第 3 步传来的内存索引写入到临时文件中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_index_writer_thread</span>(<br>    big_indexes: Receiver&lt;InMemoryIndex&gt;,<br>    output_dir: &amp;Path,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;PathBuf&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp_dir</span> = TmpDir::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">index</span> <span class="hljs-keyword">in</span> big_indexes &#123;<br>          <span class="hljs-comment">// 将索引写入临时文件中</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(index, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(file).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5. merge_index_files</strong></p><p>将临时文件进行合并，生成最终的索引文件。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_index_files</span>(files: Receiver&lt;PathBuf&gt;, output_dir: &amp;Path) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">merge</span> = FileMerge::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">file</span> <span class="hljs-keyword">in</span> files &#123;<br>        merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>    &#125;<br>    merge.<span class="hljs-title function_ invoke__">finish</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>这 5 个步骤跟书中给出的示意图基本一致，我们再来看<code>run_pipeline</code> 是如何合并并行的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 join() 等待所有线程完成</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = h1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>h2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>h3.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = h4.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br><span class="hljs-comment">// 阶段 2 和阶段 3 都是纯内存操作，不会有错误</span><br><span class="hljs-comment">// 阶段 1 是读文件，阶段 4 是写文件，所以有可能会报错</span><br>r1?;<br>r4?;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240416001044618.png"alt="run_pipeline 示意图" /><figcaption aria-hidden="true">run_pipeline 示意图</figcaption></figure><p>源码阅读部分差不多就到这了，大的思想架构你应该都能 Get到了，其中每个数据结构的具体实现细节，我们在后面的实战中进行拆解。</p><h1 id="构建索引">构建索引</h1><h2 id="代码结构">代码结构</h2><p>书中源码代码结构如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  fingertips git:(master) ✗ tree<br>.<br>├── Cargo<span class="hljs-selector-class">.lock</span><br>├── Cargo<span class="hljs-selector-class">.toml</span><br>├── LICENSE-MIT<br>├── README<span class="hljs-selector-class">.md</span><br>├── <span class="hljs-attribute">src</span><br>│   ├── index<span class="hljs-selector-class">.rs</span><br>│   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.rs</span><br>│   ├── merge<span class="hljs-selector-class">.rs</span><br>│   ├── read<span class="hljs-selector-class">.rs</span><br>│   ├── tmp<span class="hljs-selector-class">.rs</span><br>│   └── write.rs<br></code></pre></td></tr></table></figure><p>书中给出的源码并没有实现使用构建好的索引文件进行搜索的功能，笔者将在此基础上实现该功能，所以对代码结构进行了简单的调整：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜  inverted_index git:(master) ✗ tree<br>.<br>├── Cargo<span class="hljs-selector-class">.lock</span><br>├── Cargo<span class="hljs-selector-class">.toml</span><br>├── index<span class="hljs-selector-class">.bat</span><br>├── <span class="hljs-attribute">src</span><br>│   ├── bin<br>│   │   ├── create<span class="hljs-selector-class">.rs</span><br>│   │   └── search<span class="hljs-selector-class">.rs</span><br>│   ├── index<span class="hljs-selector-class">.rs</span><br>│   ├── lib<span class="hljs-selector-class">.rs</span><br>│   ├── merge<span class="hljs-selector-class">.rs</span><br>│   ├── read<span class="hljs-selector-class">.rs</span><br>│   ├── tmp<span class="hljs-selector-class">.rs</span><br>│   └── write<span class="hljs-selector-class">.rs</span><br>└── texts<br>    ├── text1<span class="hljs-selector-class">.txt</span><br>    ├── text2<span class="hljs-selector-class">.txt</span><br>    └── text3.txt<br></code></pre></td></tr></table></figure><p>可以看到我将核心代码从 <code>bin</code> 改成了 <code>lib</code>，这是为了支持我后面要实现的两个 <code>bin</code>:</p><ul><li><code>create</code>: 构建索引，基本上就是源代码中的<code>main.rs</code></li><li><code>search</code>: 基于生成的索引文件实现搜索功能</li></ul><p><code>texts</code> 是我提供的文本文件样例。</p><p><code>src</code> 目录中的代码阅读顺序及功能划分如下：</p><ul><li><code>index</code>: 定义了内存索引数据结构InMemoryIndex，实现了从文件内容中构建内存索引的基本逻辑，也实现了从索引文件重建内存索引的功能。</li><li><code>tmp</code>: 定义了临时目录数据结构TmpDir，用于存放临时索引文件。</li><li><code>write</code>: 定义了索引文件写入器 IndexFileWriter，实现了将InMemoryIndex 写入文件中的逻辑。</li><li><code>merge</code>: 定义了文件合并器 FileMerge，用于合并 TmpDir的所有索引文件。</li><li><code>read</code>: 定义了索引文件读取器IndexFileWrite，实现了解析索引文件的逻辑。</li></ul><h2 id="项目准备">项目准备</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new --lib inverted_index_concurrency<br></code></pre></td></tr></table></figure><p>Cargo.toml</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;inverted-index-concurrency&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><span class="hljs-attr">license</span> = <span class="hljs-string">&quot;mit&quot;</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">&quot;hedon&quot;</span>]<br><span class="hljs-attr">description</span> = <span class="hljs-string">&quot;a tool to concurrently build an inverted index.&quot;</span><br><br><span class="hljs-section">[[bin]]</span><br><span class="hljs-attr">name</span>=<span class="hljs-string">&quot;create&quot;</span><br><span class="hljs-attr">path</span>=<span class="hljs-string">&quot;src/bin/create.rs&quot;</span><br><br><span class="hljs-section">[[bin]]</span><br><span class="hljs-attr">name</span>=<span class="hljs-string">&quot;search&quot;</span><br><span class="hljs-attr">path</span>=<span class="hljs-string">&quot;src/bin/search.rs&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">byteorder</span> = <span class="hljs-string">&quot;1.5.0&quot;</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.4&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><h2 id="lib.rs">lib.rs</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> index;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> merge;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> read;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> tmp;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> write;<br></code></pre></td></tr></table></figure><p>在 <code>lib.rs</code> 中我们将这 5 个 mod 公开出去，这样就可以给<code>bin</code> 目录中的 <code>crate.rs</code> 和<code>search.rs</code> 使用了。</p><h2 id="index.rs">index.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/index.rs">index.rs</a></p></blockquote><p>第一部分是内存索引的构建。</p><h3 id="tokenize">tokenize</h3><p>我们先定义一个分词函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tokenize</span>(text: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;(&amp;<span class="hljs-type">str</span>, <span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>)&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">res</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">token_start</span> = <span class="hljs-literal">None</span>;<br>    <span class="hljs-keyword">for</span> (idx, ch) <span class="hljs-keyword">in</span> text.<span class="hljs-title function_ invoke__">char_indices</span>() &#123;<br>        <span class="hljs-keyword">match</span> (ch.<span class="hljs-title function_ invoke__">is_alphanumeric</span>(), token_start) &#123;<br>            (<span class="hljs-literal">true</span>, <span class="hljs-literal">None</span>) =&gt; token_start = <span class="hljs-title function_ invoke__">Some</span>(idx),  <span class="hljs-comment">// 每个单词的开始</span><br>            (<span class="hljs-literal">false</span>, <span class="hljs-title function_ invoke__">Some</span>(start)) =&gt; &#123;  <span class="hljs-comment">// 每个单词的结尾</span><br>                res.<span class="hljs-title function_ invoke__">push</span>((&amp;text[start..idx], start, idx - <span class="hljs-number">1</span>));<br>                token_start = <span class="hljs-literal">None</span><br>            &#125;<br>            _ =&gt; &#123;&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(start) = token_start &#123;<br>        res.<span class="hljs-title function_ invoke__">push</span>((&amp;text[start..], start, text.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>))<br>    &#125;<br>    res<br>&#125;<br></code></pre></td></tr></table></figure><p>这个分词函数跟书中源码提供的不一样，为了实现文本高亮，我们需要记录每个分词在原文本中的起始位置和结束位置。它的核心逻辑如下：</p><ol type="1"><li><p>通过 <code>char_indices()</code> 获取 <code>text</code>的字符迭代器，这是一种懒加载的方法，避免一次性将所有 char加载到内存中。</p></li><li><p>匹配 <code>(ch.is_alphanumeric(), token_start)</code>：</p><ul><li>如果是 <code>(true, None)</code>则表示这是一个单词的开始，我们纪录其开始的位置<code>Some(idx)</code>；</li><li>如果是 <code>(false, Some(idx))</code>则表示这是一个单词的结束，我们将其加入到 <code>res</code>中，并记录起始位置和结束位置。</li><li>其他情况，不做处理，要么是非法字符，要么是处于单词中间。</li></ul><p>从这个简单的理解中，你应该可以感受到 Rust 中 match pattern的强大和便捷了，666 👍🏻</p></li></ol><h3 id="struct-inmemoryindex">struct: InMemoryIndex</h3><p>在 <code>index.rs</code> 中，我们定义了三个数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">InMemoryIndex</span> &#123;<br>    <span class="hljs-keyword">pub</span> word_count: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> terms: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;Hit&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> docs: HashMap&lt;<span class="hljs-type">usize</span>, Document&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Document</span> &#123;<br>    <span class="hljs-keyword">pub</span> id: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> path: PathBuf,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Hit</span> = <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;;<br></code></pre></td></tr></table></figure><ul><li><p><code>Document</code>: 文档封装。</p><ul><li><code>id</code>: 文档 id，唯一标识符。</li><li><code>path</code>: 源文件路径。</li></ul></li><li><p><code>Hit</code>:它是一个字节数组，我们按照小端序进行存储，它的存储结构如下：</p><ul><li>[0..3] 存储一个 <code>HITS_SEPERATOR = -1</code>，表示一个<code>Hit</code> 的开始。</li><li>[4..7] 存储一个 u32 的 <code>document_id</code>。</li><li>后面每 8 个 u8 会存在一个 u32 的 <code>start_pos</code> 和一个 u32的 <code>end_pos</code>。</li></ul></li><li><p><code>InMemoryIndex</code>: 内存索引。</p><ul><li><code>word_count</code>:包含的单词（word/term）个数，记录它是为了判断索引是否过大，以便对索引进行分片存储。</li><li><code>terms</code>: 存储 word 到 Hits 的映射，每个 <code>word</code>是一个搜索项。</li><li><code>docs</code>: 存储了 document_id到文档的映射，用于查询原始文档信息。</li></ul></li></ul><p>接下来我们来为 <code>InMemoryIndex</code>实现一系列方法，因为我们期望使用小端序存储 <code>Hit</code>中的数据，所以我们需要引入 <code>byteorder</code> 这个 crate:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add byteorder<br></code></pre></td></tr></table></figure><p>具体实现可参考源码，核心逻辑是 <code>from_single_document</code> 和<code>merge</code>。</p><h3 id="from_single_document">from_single_document</h3><p><strong>from_single_document</strong>的核心逻辑在这一段，它其实跟我们之前实现的简易版倒排索引很相似：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> (token, start_pos, end_pos) <span class="hljs-keyword">in</span> tokens.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hits</span> = index.terms.<span class="hljs-title function_ invoke__">entry</span>(token.<span class="hljs-title function_ invoke__">to_string</span>()).<span class="hljs-title function_ invoke__">or_insert_with</span>(|| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hits</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span>);<br>        hits.write_i32::&lt;LittleEndian&gt;(<span class="hljs-keyword">Self</span>::HITS_SEPERATOR)<br>            .<span class="hljs-title function_ invoke__">unwrap</span>();<br>        hits.write_u32::&lt;LittleEndian&gt;(document_id).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-built_in">vec!</span>[hits]<br>    &#125;);<br><br>    hits[<span class="hljs-number">0</span>].write_u32::&lt;LittleEndian&gt;(*start_pos <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    hits[<span class="hljs-number">0</span>].write_u32::&lt;LittleEndian&gt;(*end_pos <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    index.word_count += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>遍历每个 <code>token</code> 和它在文本中的位置。</li><li>对于每个 <code>token</code>，尝试在索引的 <code>map</code>中查找一个现有的条目。如果不存在，则创建一个新的 <code>Hit</code>记录，并初始化它：<ul><li>创建一个新的 <code>Hit</code> 向量，预留 24字节的容量，这是因为至少要存储 1 个分隔符、1 个 document_id、1 个start_pos 和 1 个 end_pos。</li><li>首先写入 <code>HITS_SEPERATOR</code> 和<code>document_id</code>（使用小端序）。</li></ul></li><li>向对应的 <code>Hit</code> 向量中添加当前单词的位置。</li><li>累加处理的单词总数到 <code>index.word_count</code>。</li></ul><p>这里给个示例，希望可以帮助你理解 <code>InMemoryIndex</code>的内存结构：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">InMemoryIndex</span><br><span class="hljs-string">│</span><br><span class="hljs-string">├──</span> <span class="hljs-attr">word_count:</span> <span class="hljs-string">usize</span><br><span class="hljs-string">│</span><br><span class="hljs-string">├──</span> <span class="hljs-attr">terms:</span> <span class="hljs-string">HashMap&lt;String,</span> <span class="hljs-string">Vec&lt;Hit&gt;&gt;</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span><br><span class="hljs-string">│</span>   <span class="hljs-string">├──</span> <span class="hljs-attr">Key:</span> <span class="hljs-string">&quot;example&quot;</span> <span class="hljs-string">(String)</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Vec&lt;Hit&gt;</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span>       <span class="hljs-string">├──</span> [<span class="hljs-string">HITS_SEPERATOR</span>, <span class="hljs-attr">Document ID:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">Positions:</span> [<span class="hljs-number">10</span>, <span class="hljs-number">19</span>, <span class="hljs-number">30</span>, <span class="hljs-number">39</span>]] <span class="hljs-string">(Hit)</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span>       <span class="hljs-string">└──</span> [<span class="hljs-string">HITS_SEPERATOR</span>, <span class="hljs-attr">Document ID:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">Positions:</span> [<span class="hljs-number">15</span>, <span class="hljs-number">25</span>]] <span class="hljs-string">(Hit)</span><br><span class="hljs-string">│</span>   <span class="hljs-string">│</span><br><span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-attr">Key:</span> <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-string">│</span>       <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Vec&lt;Hit&gt;</span><br><span class="hljs-string">│</span>           <span class="hljs-string">└──</span> [<span class="hljs-string">HITS_SEPERATOR</span>, <span class="hljs-attr">Document ID:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">Positions:</span> [<span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">50</span>, <span class="hljs-number">69</span>]] <span class="hljs-string">(Hit)</span><br><span class="hljs-string">│</span><br><span class="hljs-string">└──</span> <span class="hljs-attr">docs:</span> <span class="hljs-string">HashMap&lt;u32,</span> <span class="hljs-string">Document&gt;</span><br>    <span class="hljs-string">├──</span> <span class="hljs-attr">Key:</span> <span class="hljs-number">1</span> <span class="hljs-string">(u32)</span><br>    <span class="hljs-string">│</span>   <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Document</span> &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;path/to/file1.txt&quot;</span>&#125;<br>    <span class="hljs-string">└──</span> <span class="hljs-attr">Key:</span> <span class="hljs-number">2</span><br>        <span class="hljs-string">└──</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">Document</span> &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;path/to/file2.txt&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="merge">merge</h3><p><strong>merge</strong> 是用于合并多个<code>InMemoryIndex</code>，起到批处理的目的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, other: InMemoryIndex) &#123;<br>    <span class="hljs-keyword">for</span> (term, hits) <span class="hljs-keyword">in</span> other.terms &#123;<br>        <span class="hljs-keyword">self</span>.terms.<span class="hljs-title function_ invoke__">entry</span>(term).<span class="hljs-title function_ invoke__">or_default</span>().<span class="hljs-title function_ invoke__">extend</span>(hits)<br>    &#125;<br>    <span class="hljs-keyword">self</span>.word_count += other.word_count;<br>    <span class="hljs-keyword">self</span>.docs.<span class="hljs-title function_ invoke__">extend</span>(other.docs);<br>&#125;<br></code></pre></td></tr></table></figure><p>实现完了 <code>InMemoryIndex</code> 后，我们就可以先来完成<code>create.rs</code> 的 <code>run_pipeline</code> 的前 3个阶段了。</p><h3 id="step1-start_file_reader_thread">step1:start_file_reader_thread</h3><ol type="1"><li>读取文件信息：我们需要在独立的线程中依次打开给定的文件列表，并将文件内容读取到一个String 中，并利用 channel 传送出去。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_reader_thread</span>(<br>    documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;(PathBuf, <span class="hljs-type">String</span>)&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handler</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">filename</span> <span class="hljs-keyword">in</span> documents &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(filename.<span class="hljs-title function_ invoke__">clone</span>())?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>            f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> text)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>((filename, text)).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br><br>    (receiver, handler)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="step2-start_file_indexing_thread">step2:start_file_indexing_thread</h3><ol start="2" type="1"><li>构建索引：通过 channel 从第 1 阶段中获取文档文本信息，通过from_single_document 构建索引 InMemoryIndex 后，将索引通过 channel传送出去。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_file_indexing_thread</span>(<br>    docs: Receiver&lt;(PathBuf, <span class="hljs-type">String</span>)&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handler</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> (doc_id, (path, text)) <span class="hljs-keyword">in</span> docs.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_single_document</span>(doc_id <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>, path, text);<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    (receiver, handler)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="step3-start_in_memory_merge_thread">step3:start_in_memory_merge_thread</h3><ol start="3" type="1"><li>合并索引：通过 channel 从第 2 阶段中获得构建的 InMemoryIndex并将其合并成大索引，然后通过 channel 传送出去。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_in_memory_merge_thread</span>(<br>    indexes: Receiver&lt;InMemoryIndex&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;InMemoryIndex&gt;, JoinHandle&lt;()&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">accumulated_index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> indexes &#123;<br>            accumulated_index.<span class="hljs-title function_ invoke__">merge</span>(i);<br>            <span class="hljs-keyword">if</span> accumulated_index.<span class="hljs-title function_ invoke__">is_large</span>() &#123;<br>                <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                accumulated_index = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !accumulated_index.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = sender.<span class="hljs-title function_ invoke__">send</span>(accumulated_index);<br>        &#125;<br>    &#125;);<br><br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><big><strong>补充：为什么采用这种“复杂”的方式来存储数据呢？可否使用JSON 或者 Protobuf 呢？</strong></big></p><p>选择如何组织和存储数据，特别是在实现一个搜索引擎或数据库索引时，是一个关键决策，这会直接影响到程序的性能、可维护性以及扩展性。在这些情况下，使用像<code>byteorder</code> 这样的低级数据格式存储索引信息可能比使用 JSON 或Protobuf 等高级格式更有优势。</p><p>读写速度：</p><ul><li><strong>二进制格式</strong>：直接操作二进制格式通常比解析文本或半结构化的数据格式（如JSON）要快，因为它减少了解析时间和内存使用。在二进制格式中，数据通常是紧密打包的，没有额外的格式标记（如JSON 中的花括号和逗号），这减少了磁盘 I/O 需求。</li><li><strong>文本/半结构化格式</strong>：例如JSON，每次读取时都需要解析文本，转换数据类型，这会增加 CPU的负担，尤其是在大规模数据处理时。</li></ul><p>空间效率：</p><ul><li><strong>二进制格式</strong>：使用最少的字节表示数据，例如使用定长的整数存储文档ID 和位置索引，不仅节省空间，还能提高缓存利用率。</li><li><strong>文本/半结构化格式</strong>：文本格式需要存储额外的字符来标识数据（例如引号和键名），这增加了存储需求。</li></ul><p>适用场景：</p><ul><li><strong>二进制格式</strong>：非常适合需要高性能和大数据处理的后端系统，如搜索引擎和数据库索引。这种格式可以有效地支持快速的数据读取和写入，特别是在资源受限的环境中（如嵌入式系统或低延迟应用）。</li><li><strong>JSON/Protobuf</strong>：更适合需要跨平台兼容性和易于调试的应用场景。例如，在Web 应用中使用 JSON 作为数据交换格式，可以简化前后端的集成和测试。</li></ul>          </div><h2 id="tmp.rs">tmp.rs</h2><p>完成内存索引的构建后，我们需要将构建过程中产生的大索引先临时落盘，后面再进行合并。为了临时存储这些数据文件，我们需要将他们放在一个临时目录中，为此，我们定义了<code>TmpDir</code> 数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TmpDir</span> &#123;<br>    dir: PathBuf,<br>    n: <span class="hljs-type">usize</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>dir</code>: 目录</li><li><code>n</code>: 自增器，用于区分临时文件命名</li></ul><p>接下来为 <code>TmpDir</code> 实现 2 个方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">TmpDir</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>&lt;P: <span class="hljs-built_in">AsRef</span>&lt;Path&gt;&gt;(dir: P) <span class="hljs-punctuation">-&gt;</span> TmpDir &#123;<br>        TmpDir &#123;<br>            dir: dir.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">to_owned</span>(),<br>            n: <span class="hljs-number">1</span>,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">create</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;(PathBuf, BufWriter&lt;File&gt;)&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">r</span>#<span class="hljs-keyword">try</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">filename</span> = <span class="hljs-keyword">self</span><br>                .dir<br>                .<span class="hljs-title function_ invoke__">join</span>(PathBuf::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;tmp&#123;:08x&#125;.dat&quot;</span>, <span class="hljs-keyword">self</span>.n)));<br>            <span class="hljs-keyword">self</span>.n += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">match</span> fs::OpenOptions::<span class="hljs-title function_ invoke__">new</span>()<br>                .<span class="hljs-title function_ invoke__">write</span>(<span class="hljs-literal">true</span>)<br>                .<span class="hljs-title function_ invoke__">create_new</span>(<span class="hljs-literal">true</span>)<br>                .<span class="hljs-title function_ invoke__">open</span>(&amp;filename)<br>            &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(f) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>((filename, BufWriter::<span class="hljs-title function_ invoke__">new</span>(f))),<br>                <span class="hljs-title function_ invoke__">Err</span>(exc) =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> r#<span class="hljs-keyword">try</span> &lt; <span class="hljs-number">999</span> &amp;&amp; exc.<span class="hljs-title function_ invoke__">kind</span>() == io::ErrorKind::AlreadyExists &#123;<br>                        <span class="hljs-comment">// keep going</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(exc);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            r#<span class="hljs-keyword">try</span> += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>new</strong> 方法是 <code>TmpDir</code>的构造函数，其中我们将 <code>n</code> 设置为 1，即文件名从 1开始生成。<code>dir.as_ref().to_owned()</code>接受一个可能是任何类型的路径，将其标准化为一个 <code>Path</code>类型的引用，然后再复制这个引用，创建一个完全独立的、拥有所有权的<code>PathBuf</code> 对象，</p><p><strong>create</strong> 方法是在 <code>TmpDir</code>目录下创建一个临时文件。</p><h2 id="write.rs">write.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/write.rs">write.rs</a></p></blockquote><p>准备好内存索引和临时文件，那我们就需要实现将内存索引写入到文件中的功能了。</p><h3 id="struct-inmemoryindex-1">struct: InMemoryIndex</h3><p>我们先来分析一下如何将 <code>InMemoryIndex</code> 落盘。首先<code>InMemoryIndex</code> 的结构如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">InMemoryIndex</span> &#123;<br>    <span class="hljs-keyword">pub</span> word_count: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> terms: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;Hit&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> docs: HashMap&lt;<span class="hljs-type">u32</span>, Document&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Document</span> &#123;<br>    <span class="hljs-keyword">pub</span> id: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> path: PathBuf,<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>word_count</code>不需要存储，我们可以计算出来。那我们就需要存储索引 <code>map</code>和文档原数据 <code>docs</code>。为了能精确定位到各个数据，我们需要：</p><p>terms:</p><ul><li>写入 Vec&lt;Hit&gt;</li></ul><p>docs:</p><ul><li>写入 docs 中的每个 Document<ul><li>写入 id</li><li>写入 path 大小</li><li>写入 path</li></ul></li></ul><p>而为了快速定位到每个 term 和 doc的位置，我们需要下面几个值，这几个值将组合起来辅助我们快速定位 terms 或docs，我们后面会将其称为 <strong>Entry</strong>，它包含以下几个值：</p><ul><li><code>term</code>: 索引单词。为了统一，如果 <code>term</code>为空，则表示当前表示的是 doc，否则为 terms。</li><li><code>df</code>: term 的出现次数。为了统一，如果 <code>df</code> 为0，则表示当前表示的是 doc，否则为 terms。</li><li><code>offset</code>: 对应的 terms 或 docs 在文件中的偏移。</li><li><code>nbytes</code>: 对应的 terms 或 docs 的总长度。</li></ul><p>所以文件的内存结构大概如下：</p><table><thead><tr class="header"><th>文件区域</th><th>描述</th><th>指向内容</th></tr></thead><tbody><tr class="odd"><td>头部 （8 字节）</td><td>包含一个指向目录表开始位置的偏移量。</td><td>header</td></tr><tr class="even"><td>主条目</td><td>这些条目按顺序紧密存储，没有额外的元数据。这部分包含实际的数据条目。</td><td>terms + docs</td></tr><tr class="odd"><td>目录表</td><td>存储在文件的最后，包括每个条目的术语信息、文档频率、偏移和大小。</td><td>entries</td></tr></tbody></table><p>示意图如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423194529529.png"alt="索引文件内存结构示意图" /><figcaption aria-hidden="true">索引文件内存结构示意图</figcaption></figure><p>为此我们定义了 <code>IndexFileWriter</code>，它专门用于将<code>InMemoryIndex</code> 写入到临时文件中，定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// A structure to manage writing to an index file efficiently.</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IndexFileWriter</span> &#123;<br>    offset: <span class="hljs-type">u64</span>,<br>    writer: BufWriter&lt;File&gt;,<br>    contents_buf: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>offset</code>: 用于追踪文件中当前的写入位置。</li><li><code>writer</code>:一个缓冲写入器，它包装了一个文件，用于输出操作。</li><li><code>contents_buf</code>:一个向量，用来存储内容条目，在全部写入文件之前暂存在这个缓冲区。</li></ul><p>接下来我们为 <code>IndexFileWriter</code> 实现几个方法：</p><ul><li><code>new</code>:这是一个构造函数，它初始化文件并设置初始偏移量。在文件的开始处写入一个占位符作为头部，这个头部最终会存储主数据区的大小。</li><li><code>write_document</code>:用于将一个文档以二进制格式写入到文件中，同时更新偏移量。</li><li><code>write_main</code>:这个方法接受一段数据，并将它写入文件中，同时更新偏移量。</li><li><code>write_contents_entry</code>: 将一个内容 Entry追加到内部的缓冲区中。Entry包括一个术语、文档频率、术语数据的起始偏移和大小，它用于快速定位 terms或 docs。</li><li><code>finish</code>:完成文件写入过程，将内部缓冲区的内容写入文件，并更新文件头部的主数据大小。</li></ul><h3 id="new">new</h3><p>我们先来看构造方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(<span class="hljs-keyword">mut</span> f: BufWriter&lt;File&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;IndexFileWriter&gt; &#123;<br>    <span class="hljs-keyword">const</span> HEADER_SIZE: <span class="hljs-type">u64</span> = <span class="hljs-number">8</span>;<br>    f.write_u64::&lt;LittleEndian&gt;(<span class="hljs-number">0</span>)?; <span class="hljs-comment">// content start</span><br>    <span class="hljs-title function_ invoke__">Ok</span>(IndexFileWriter &#123;<br>        offset: HEADER_SIZE,<br>        writer: f,<br>        contents_buf: <span class="hljs-built_in">vec!</span>[],<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>new</strong> 分为以下几步：</p><ol type="1"><li><strong>定义头部大小</strong>：<code>const HEADER_SIZE: u64 = 8;</code>：定义一个常量<code>HEADER_SIZE</code>，其值为 8字节，这表示文件头部的大小。这个头部将用于后续在文件的开始处写入主数据区的起始位置。</li><li><strong>写入头部占位符</strong>：<code>f.write_u64::&lt;LittleEndian&gt;(0)?;</code>：在文件的开始处写入一个8字节的占位符，这个值是以小端字节序（<code>LittleEndian</code>）存储的。初始时这里写入的是0，意味着“主数据区的起始位置未知”，这个值在后续的 <code>finish</code>函数中会被更新。</li><li><strong>返回一个新的 IndexFileWriter实例</strong>：<code>Ok(IndexFileWriter &#123; offset: HEADER_SIZE, writer: f, contents_buf: vec![], &#125;)</code>：构造并返回一个<code>IndexFileWriter</code> 实例。这个实例的 <code>offset</code>字段被初始化为 <code>HEADER_SIZE</code>（8字节），表示实际数据将从文件的第 17 个字节开始写入。<code>writer</code>字段就是传入的文件写入器，<code>contents_buf</code>是一个新的空向量，用于临时存储内容条目数据。</li></ol><div class="note note-info">            <p><big><strong>为什么这样设计？</strong></big></p><p>这个实现方式有几个设计上的考虑：</p><ol type="1"><li><strong>预留头部空间</strong>：通过在文件开始处预留 8字节空间来存储主数据区的大小，这样做可以在数据写入完成后，方便地回填这个信息。这是文件格式设计中常见的做法，允许读取者快速定位主数据区和内容索引区。</li><li><strong>使用小端字节序</strong>：小端字节序是一种在二进制文件中常用的字节序，尤其是在Windows平台下。使用小端字节序可以提高文件的兼容性，并且对于多数处理器架构来说，小端字节序的读写操作更为高效。</li><li><strong>灵活的数据写入</strong>：通过将 <code>writer</code> 和<code>contents_buf</code>组合使用，这个结构体可以灵活地处理不同的数据写入需求。<code>writer</code>直接写入文件，适合连续大块数据的写入；而 <code>contents_buf</code>用于聚集多个小片段的数据，可以在最后统一写入，减少磁盘操作次数。</li></ol><p>总的来说，这个构造函数的实现为高效和灵活的文件写操作提供了良好的基础，同时通过合理的错误处理和数据组织方式，确保了程序的健壮性和高性能。</p>          </div><h3 id="write_main">write_main</h3><p>Hit 本身就是一个 Vec&lt;u8&gt;， 将其写入文件很简单，调用<code>write_all</code>，即可，我们为其封装 <code>write_main</code>方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_main</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">write_all</span>(buf)?;<br>    <span class="hljs-keyword">self</span>.offset += buf.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="write_document">write_document</h3><p>为了将 Docuemnt本以二进制结构写入到文件中，我们需要拆分成几个部分：</p><ol type="1"><li>文件 id</li><li>文件路径大小</li><li>文件路径</li></ol><p>为此我们为 <code>IndexFileWriter</code> 封装了<code>write_document</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_document</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, doc: &amp;Document) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">self</span>.writer.write_u32::&lt;LittleEndian&gt;(doc.id)?;<br>    <span class="hljs-keyword">self</span>.writer<br>        .write_u64::&lt;LittleEndian&gt;(doc.path.<span class="hljs-title function_ invoke__">as_os_str</span>().<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>)?;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">write_all</span>(doc.path.<span class="hljs-title function_ invoke__">as_os_str</span>().<span class="hljs-title function_ invoke__">as_bytes</span>())?;<br>    <span class="hljs-keyword">self</span>.offset += <span class="hljs-number">4</span> + <span class="hljs-number">8</span> + doc.path.<span class="hljs-title function_ invoke__">as_os_str</span>().<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="write_contents_entry">write_contents_entry</h3><p>Entry的数据量一般较小，我们会先写入缓冲中，后面再一次性刷盘，为此我们为<code>IndexFileWriter</code> 封装了<code>write_contents_entry</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Appends a content entry to the internal buffer.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// # Arguments</span><br><span class="hljs-comment">/// * `term` - The term associated with the entry</span><br><span class="hljs-comment">/// * `df` - Document frequency for the term</span><br><span class="hljs-comment">/// * `offset` - Offset where the term data starts in the file</span><br><span class="hljs-comment">/// * `nbytes` - Number of bytes of the term data</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_contents_entry</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, term: <span class="hljs-type">String</span>, df: <span class="hljs-type">u32</span>, offset: <span class="hljs-type">u64</span>, nbytes: <span class="hljs-type">u64</span>) &#123;<br>    <span class="hljs-keyword">self</span>.contents_buf.write_u64::&lt;LittleEndian&gt;(offset).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf.write_u64::&lt;LittleEndian&gt;(nbytes).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf.write_u32::&lt;LittleEndian&gt;(df).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = term.<span class="hljs-title function_ invoke__">bytes</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf<br>        .write_u32::&lt;LittleEndian&gt;(bytes.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>)<br>        .<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">self</span>.contents_buf.<span class="hljs-title function_ invoke__">extend</span>(bytes);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="finish">finish</h3><p>刷盘的过程我们封装在 <code>finish</code> 中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">finish</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contents_start</span> = <span class="hljs-keyword">self</span>.offset;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">write_all</span>(&amp;<span class="hljs-keyword">self</span>.contents_buf)?;<br>    <span class="hljs-keyword">self</span>.writer.<span class="hljs-title function_ invoke__">seek</span>(SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(<span class="hljs-number">0</span>))?;<br>    <span class="hljs-keyword">self</span>.writer.write_u64::&lt;LittleEndian&gt;(contents_start)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="write_index_to_tmp_file">write_index_to_tmp_file</h3><p>综合下来，我们就可以实现最核心的函数<code>write_index_to_tmp_file</code> 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_index_to_tmp_file</span>(index: InMemoryIndex, tmp_dir: &amp;<span class="hljs-keyword">mut</span> TmpDir) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;PathBuf&gt; &#123;<br>    <span class="hljs-keyword">let</span> (filename, f) = tmp_dir.<span class="hljs-title function_ invoke__">create</span>()?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">writer</span> = IndexFileWriter::<span class="hljs-title function_ invoke__">new</span>(f)?;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index_as_vec</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = index.terms.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    index_as_vec.<span class="hljs-title function_ invoke__">sort_by</span>(|(a, _), (b, _)| a.<span class="hljs-title function_ invoke__">cmp</span>(b));<br><br>    <span class="hljs-keyword">for</span> (term, hits) <span class="hljs-keyword">in</span> index_as_vec &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">df</span> = hits.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span> = writer.offset;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">buffer</span> <span class="hljs-keyword">in</span> hits &#123;<br>            writer.<span class="hljs-title function_ invoke__">write_main</span>(&amp;buffer)?;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stop</span> = writer.offset;<br>        writer.<span class="hljs-title function_ invoke__">write_contents_entry</span>(term, df, start, stop - start);<br>    &#125;<br><br>    <span class="hljs-comment">// if term == &quot;&quot; &amp;&amp; df == 0 &#123; type = document &#125;</span><br>    <span class="hljs-keyword">for</span> (_, doc) <span class="hljs-keyword">in</span> index.docs &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span> = writer.offset;<br>        writer.<span class="hljs-title function_ invoke__">write_document</span>(&amp;doc)?;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stop</span> = writer.offset;<br>        writer.<span class="hljs-title function_ invoke__">write_contents_entry</span>(<span class="hljs-string">&quot;&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">0</span>, start, stop - start)<br>    &#125;<br><br>    writer.<span class="hljs-title function_ invoke__">finish</span>()?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;wrote file &#123;:?&#125;&quot;</span>, filename);<br>    <span class="hljs-title function_ invoke__">Ok</span>(filename)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>我们在临时目录中创建一个临时文件，并初始化 IndexFileWriter；</li><li>将索引的 <code>terms</code> 转换成一个向量并按照键排序；</li><li>对于每个<code>term</code>，计算文档频率（<code>df</code>），记录开始和结束位置，然后调用<code>write_main</code> 方法将数据写入文件，然后使用<code>write_contents_entry</code> 方法写入 <code>Entry</code>的元数据到目录表；</li><li>对于 <code>index.docs</code>中的每个文档，计算起止位置，并使用一个特殊的条目（空字符串作为条目名和 0作为文档频率）标记在文件中；</li><li>最后我们使用 <code>finish</code> 将缓存中所有的 <code>Entry</code>刷盘，并设置 <code>entries</code> 的起始位置。</li></ol><p>文件的内存结构如上面给出的图一样，这里我们可以再看一次：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423194529529-20240423195227516.png"alt="索引文件内存结构示意图" /><figcaption aria-hidden="true">索引文件内存结构示意图</figcaption></figure><h3 id="step4-start_index_writer_thread">step4:start_index_writer_thread</h3><p>实现了将内存索引写入到文件的功能后，我们就可以继续在<code>create.rs</code> 中实现下一个流程了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_index_writer_thread</span>(<br>    big_indexes: Receiver&lt;InMemoryIndex&gt;,<br>    output_dir: &amp;Path,<br>) <span class="hljs-punctuation">-&gt;</span> (Receiver&lt;PathBuf&gt;, JoinHandle&lt;io::<span class="hljs-type">Result</span>&lt;()&gt;&gt;) &#123;<br>    <span class="hljs-keyword">let</span> (sender, receiver) = <span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp_dir</span> = TmpDir::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> big_indexes &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;word count: &#123;&#125;&quot;</span>, i.word_count);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">file</span> = <span class="hljs-title function_ invoke__">write_index_to_tmp_file</span>(i, &amp;<span class="hljs-keyword">mut</span> tmp_dir)?;<br>            <span class="hljs-keyword">if</span> sender.<span class="hljs-title function_ invoke__">send</span>(file).<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;);<br><br>    (receiver, handle)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>start_index_writer_thread</code>流程中，我们将构建好的内存索引一个个写入到文件中，并将生成的文件句柄传入下一个流程。</p><h2 id="merge.rs">merge.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/merge.rs">merge.rs</a></p></blockquote><p>前面 <code>start_index_writer_thread</code> 是将一个个<code>InMemoryIndex</code> 写入到 <code>TmpDir</code>临时目录中。现在我们要将这些临时文件合并成一个最终的索引文件，以优化查询效率和节省存储空间。</p><h3 id="srtuct-filemerge">srtuct: FileMerge</h3><p>我们定义一下结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">FileMerge</span> &#123;<br>    output_dir: PathBuf,<br>    tmp_dir: TmpDir,<br>    stacks: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;PathBuf&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>output_dir</code>: 用于存储最终合并文件的输出目录。</li><li><code>tmp_dir</code>: 前面 <code>tmp.rs</code>定义的结构，用于管理合并过程中产生的临时文件。</li><li><code>stacks</code>:这是一个二维向量，每个内部向量代表一个合并“层”，存储了该层待合并的文件路径。</li></ul><p>关于 <code>stacks</code>，再多说两点：</p><ul><li><strong>多级合并策略</strong>: <code>FileMerge</code>使用一个多层合并策略，这种策略在处理大量文件时尤为有效。基本思想是，当一层的文件数量达到一个预设的阈值（<code>NSTREAMS</code>）时，这些文件会被合并成一个新的文件，新文件则被推送到上一层。这种层级式的处理方式可以显著减少最终合并步骤需要处理的文件数量，从而优化性能。</li><li><strong>动态扩展</strong>：使用<code>Vec&lt;Vec&lt;PathBuf&gt;&gt;</code>允许动态地添加新的合并层，这在处理不确定数量的文件时非常有用。向量的灵活性意味着无需预先知道将处理多少文件，它可以根据实际需要进行扩展。</li></ul><p>接下来我们会为 <code>FileMerge</code> 实现 2 个方法：</p><ul><li><code>add_file</code>:添加一个文件到合并栈中，并使用多级合并策略进行合并。</li><li><code>finish</code>: 执行最后的合并操作，生成最终的索引文件，输出到<code>output_dir</code> 中。</li></ul><h3 id="add_file">add_file</h3><p>首先我们来看<code>add_file</code>，它的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_file</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, <span class="hljs-keyword">mut</span> file: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><span class="hljs-comment">// 从第一层开始检查</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">level</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 使用循环来处理文件的添加和可能的合并。</span><br>    <span class="hljs-keyword">loop</span> &#123;<br><br>      <span class="hljs-comment">// 如果当前的 level （层级）不存在于 stacks 中，</span><br>        <span class="hljs-comment">// 就在 stacks 中添加一个新的空向量。</span><br>        <span class="hljs-comment">// 这是为了存放该层级的文件。</span><br>        <span class="hljs-keyword">if</span> level == <span class="hljs-keyword">self</span>.stacks.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-keyword">self</span>.stacks.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-built_in">vec!</span>[]);<br>        &#125;<br><br>        <span class="hljs-comment">// 将当前的文件添加到对应层级的向量中。</span><br>        <span class="hljs-keyword">self</span>.stacks[level].<span class="hljs-title function_ invoke__">push</span>(file);<br><br>        <span class="hljs-comment">// 如果这个级别的堆栈已满，就合并这个级别的文件。</span><br>      <span class="hljs-comment">// 如果没满，则不进行合并，直接退出。</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.stacks[level].<span class="hljs-title function_ invoke__">len</span>() &lt; NSTREAMS &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建一个新文件来存储合并结果，并更新堆栈。</span><br>        <span class="hljs-keyword">let</span> (filename, out) = <span class="hljs-keyword">self</span>.tmp_dir.<span class="hljs-title function_ invoke__">create</span>()?;<br><br>        <span class="hljs-comment">// 初始化一个空的 to_merge 向量，</span><br>      <span class="hljs-comment">// 然后使用 mem::swap 交换当前层级的文件列表和这个空向量，</span><br>        <span class="hljs-comment">// 这样 to_merge 向量就包含了需要合并的文件，</span><br>        <span class="hljs-comment">// 而当前层级变为空，可以用来存放新的合并文件。</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">to_merge</span> = <span class="hljs-built_in">vec!</span>[];<br>        mem::<span class="hljs-title function_ invoke__">swap</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.stacks[level], &amp;<span class="hljs-keyword">mut</span> to_merge);<br><br>        <span class="hljs-comment">// 调用 merge_streams 函数将 to_merge 中的文件合并到新创建的文件中。</span><br>        <span class="hljs-title function_ invoke__">merge_streams</span>(to_merge, out)?;<br><br>        <span class="hljs-comment">// 将合并后得到的新文件路径赋值给 file 变量，用于下一轮循环。</span><br>        file = filename;<br>        <span class="hljs-comment">// level 加一，表示移动到下一个层级。</span><br>        level += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法通过层级的方式管理文件合并，每个层级可以有多个文件，但数量上限为<code>NSTREAMS</code>。如果某层满了，就将该层的文件合并成一个新文件，并将这个新文件移动到上一层继续参与合并。这种设计有效地将多个文件逐步合并成一个文件，同时控制内存和I/O 资源的使用。</p><p>其中 <code>merge_streams</code>就是具体的合并过程，它的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_streams</span>(files: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, out: BufWriter&lt;File&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>  <span class="hljs-comment">// 从索引文件中构建 IndexFileReader 列表</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">streams</span>: <span class="hljs-type">Vec</span>&lt;IndexFileReader&gt; = files<br>        .<span class="hljs-title function_ invoke__">into_iter</span>()<br>        .<span class="hljs-title function_ invoke__">map</span>(|p| IndexFileReader::<span class="hljs-title function_ invoke__">open_and_delete</span>(p, <span class="hljs-literal">true</span>))<br>        .collect::&lt;io::<span class="hljs-type">Result</span>&lt;_&gt;&gt;()?;<br><br>  <span class="hljs-comment">// 针对输出文件生成一个 IndexFileWriter 用于写入索引信息</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">output</span> = IndexFileWriter::<span class="hljs-title function_ invoke__">new</span>(out)?;<br>  <span class="hljs-comment">// 用于记录当前写入的位置（或者数据偏移量）。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">point</span>: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 记录还有数据未处理的文件流数量，用 peek() 方法检查。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = streams.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|s| s.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">is_some</span>()).<span class="hljs-title function_ invoke__">count</span>();<br><br>  <span class="hljs-comment">// 只要 count 大于0，表示还有文件未完全处理，就继续循环。</span><br>    <span class="hljs-keyword">while</span> count &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">term</span> = <span class="hljs-literal">None</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">nbytes</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">df</span> = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 这段代码通过遍历每个文件流，使用 peek() 方法预览每个文件的当前数据条目</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> &amp;streams &#123;<br>            <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">peek</span>() &#123;<br>                <span class="hljs-literal">None</span> =&gt; &#123;&#125;<br>                <span class="hljs-title function_ invoke__">Some</span>(entry) =&gt; &#123;<br>                  <span class="hljs-comment">// term 是空的，则说明这是表示 doc 的 entry。</span><br>                  <span class="hljs-comment">// 直接退出 for 循环，因为 doc 的 entry 没有顺序且唯一，不会进行累加。</span><br>                    <span class="hljs-keyword">if</span> entry.term.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                        term = <span class="hljs-title function_ invoke__">Some</span>(entry.term.<span class="hljs-title function_ invoke__">clone</span>());<br>                        nbytes = entry.nbytes;<br>                        df = entry.df;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                  <span class="hljs-comment">// term 不是空的，则说明这是表示 terms 的 entry。</span><br>                    <span class="hljs-comment">// 选择词条最小的一个（字典序），并且累加其出现的频次和字节大小。</span><br>                    <span class="hljs-comment">// 这是多路归并的核心，确保输出文件是有序的。</span><br>                    <span class="hljs-keyword">if</span> term.<span class="hljs-title function_ invoke__">is_none</span>() || entry.term &lt; *term.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>() &#123;<br>                        term = <span class="hljs-title function_ invoke__">Some</span>(entry.term.<span class="hljs-title function_ invoke__">clone</span>());<br>                        nbytes = entry.nbytes;<br>                        df = entry.df<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> entry.term == *term.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>() &#123;<br>                        nbytes += entry.nbytes;<br>                        df += entry.df<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">term</span> = term.<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;bug in algorithm&quot;</span>);<br><br>      <span class="hljs-comment">// 对于每个文件流，如果当前数据条目与选择的 term 相同，</span><br>        <span class="hljs-comment">// 则将该条目写入输出文件，并更新该流的读取位置。</span><br>      <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> streams &#123;<br>            <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">is_at</span>(&amp;term) &#123;<br>                s.<span class="hljs-title function_ invoke__">move_entry_to</span>(&amp;<span class="hljs-keyword">mut</span> output)?;<br>                <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">peek</span>().<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>                    count -= <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> term.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        output.<span class="hljs-title function_ invoke__">write_contents_entry</span>(term, df, point, nbytes);<br>        point += nbytes<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到了一个新的结构<code>IndexFileReader</code>，它是索引文件的读取器，我们将在<code>read.rs</code> 中实现它。这里先不展开，你只需要知道：</p><ul><li><code>IndexFileReader::open_and_delete(p, true)</code>:打开一个索引文件，并根据传入的参数判断是否要删除这个文件，在合并过程中，因为都是临时文件，所以我们会指定为删除文件。但是在后面从索引文件中重建<code>InMemoryIndex</code> 的时候，我们不希望删除原始的索引文件。</li><li><code>s.peek()</code>: 查看下一个 Entry，它的返回值是Option&lt;Entry&gt;。</li><li><code>s.move_entry_to(&amp;mut output)</code>: 将<code>s.peek()</code> 指向的 Entry 写入到 output 文件中，并移动到一下Entry。</li></ul><p>总结下来，这个函数实现多路归并的核心部分，它将多个索引文件合并成一个单一的有序文件。</p><h3 id="finish-1">finish</h3><p>我们再来看 <code>FileMerge</code> 的另外一个方法<code>finish</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">finish</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><br>    <span class="hljs-comment">// 初始化一个临时向量 tmp，用来暂存需要合并的文件路径。</span><br>    <span class="hljs-comment">// 这个向量的容量设置为 NSTREAMS，这是预先定义的常量，表示一次可以合并的最大文件数。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tmp</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(NSTREAMS);<br><br>    <span class="hljs-comment">// 方法遍历 self.stacks 中的每个堆栈。每个堆栈代表一个合并层级，包含若干待合并的文件。</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stack</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.stacks &#123;<br>        <span class="hljs-comment">// 对于每个堆栈，方法使用 .into_iter().rev() 迭代器反向遍历文件，</span><br>      <span class="hljs-comment">// 以确保按正确的顺序处理（先进后出）。</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">file</span> <span class="hljs-keyword">in</span> stack.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>            <span class="hljs-comment">// 将文件逐个添加到 tmp 向量中。</span><br>            tmp.<span class="hljs-title function_ invoke__">push</span>(file);<br>            <span class="hljs-comment">// 当 tmp 的长度达到 NSTREAMS 时，</span><br>          <span class="hljs-comment">// 调用 merge_reversed 函数进行合并。</span><br>            <span class="hljs-keyword">if</span> tmp.<span class="hljs-title function_ invoke__">len</span>() == NSTREAMS &#123;<br>                <span class="hljs-title function_ invoke__">merge_reversed</span>(&amp;<span class="hljs-keyword">mut</span> tmp, &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.tmp_dir)?;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>  <span class="hljs-comment">// 对于剩余文件进行最终的合并。</span><br>    <span class="hljs-keyword">if</span> tmp.<span class="hljs-title function_ invoke__">len</span>() &gt; <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-title function_ invoke__">merge_reversed</span>(&amp;<span class="hljs-keyword">mut</span> tmp, &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.tmp_dir)?;<br>    &#125;<br><br>  <span class="hljs-comment">// 最后应该只有一个最终文件</span><br>    <span class="hljs-built_in">assert!</span>(tmp.<span class="hljs-title function_ invoke__">len</span>() == <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">match</span> tmp.<span class="hljs-title function_ invoke__">pop</span>() &#123;<br>      <span class="hljs-comment">// 对文件进行重命名</span><br>        <span class="hljs-title function_ invoke__">Some</span>(last_file) =&gt; fs::<span class="hljs-title function_ invoke__">rename</span>(last_file, <span class="hljs-keyword">self</span>.output_dir.<span class="hljs-title function_ invoke__">join</span>(MERGED_FILENAME)),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-title function_ invoke__">Err</span>(io::Error::<span class="hljs-title function_ invoke__">new</span>(<br>            io::ErrorKind::Other,<br>            <span class="hljs-string">&quot;no ducuments were parsed or none contained any words&quot;</span>,<br>        )),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到了另外一个函数 <code>merge_reversed</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_reversed</span>(filenames: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, tmp_dir: &amp;<span class="hljs-keyword">mut</span> TmpDir) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    filenames.<span class="hljs-title function_ invoke__">reverse</span>();<br>    <span class="hljs-keyword">let</span> (merge_filename, out) = tmp_dir.<span class="hljs-title function_ invoke__">create</span>()?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">to_merge</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(NSTREAMS);<br>    mem::<span class="hljs-title function_ invoke__">swap</span>(filenames, &amp;<span class="hljs-keyword">mut</span> to_merge);<br>    <span class="hljs-title function_ invoke__">merge_streams</span>(to_merge, out)?;<br>    filenames.<span class="hljs-title function_ invoke__">push</span>(merge_filename);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>它其实就是将 <code>filenames</code> 翻转，清空并将内容转移到<code>to_merge</code>，然后调用 <code>merge_streams</code>合并，并将合并后的文件重新放回被清空的<code>filenames</code>，也就是我们在 <code>finish</code> 中声明的<code>tmp</code> 变量。</p><div class="note note-info">            <p><big><strong>为什么这里需要翻转 filenames？</strong></big></p><p>假设 NSTREAMS = 3，我们执行 <code>add_file</code>，从<code>file1</code> 到 <code>file8</code>，那么过程如下：</p><table><thead><tr class="header"><th>Action</th><th>Stack 0</th><th>Stack 1</th><th>Notes</th></tr></thead><tbody><tr class="odd"><td>Add file1</td><td>file1</td><td></td><td></td></tr><tr class="even"><td>Add file2</td><td>file1, file2</td><td></td><td></td></tr><tr class="odd"><td>Add file3</td><td>file1, file2, file3</td><td></td><td></td></tr><tr class="even"><td>Merge S1</td><td>(empty)</td><td>merge1</td><td><code>merge1</code> is the result of merging file1-file3</td></tr><tr class="odd"><td>Add file4</td><td>file4</td><td>merge1</td><td></td></tr><tr class="even"><td>Add file5</td><td>file4, file5</td><td>merge1</td><td></td></tr><tr class="odd"><td>Add file6</td><td>file4, file5, file6</td><td>merge1</td><td></td></tr><tr class="even"><td>Merge S2</td><td>(empty)</td><td>merge1, merge2</td><td><code>merge2</code> is the result of merging file4-file6</td></tr><tr class="odd"><td>Add file7</td><td>file7</td><td>merge1, merge2</td><td></td></tr><tr class="even"><td>Add file8</td><td>file7, file8</td><td>merge1, merge2</td><td>Trigger merge because 8 files are reached</td></tr></tbody></table><p>最后我们获得的结果是：</p><table><thead><tr class="header"><th>stack0</th><th>stack1</th></tr></thead><tbody><tr class="odd"><td>file7, file8</td><td>merge1, merge2</td></tr></tbody></table><p>按照文件的添加顺序，我们期望在 <code>finish</code>中合并的顺序应该是：merge1, merge2, file7, file8。所以我们遍历<code>stacks</code> 的时候，从第 1 层开始遍历的话，我们就需要反向遍历<code>rev()</code>，这个时候我们组成的 <code>tmp</code> 就是：file8,file7, merge2, merge1。最后我们传入 <code>merge_reversed</code>的时候，再进行 <code>reverse()</code>，就可以获得我们期望的顺序 merge1,merge2, file7, file8。</p>          </div><p>回过头来，我们总结一下<code>finish</code>：这个方法通过多级合并的方式，逐层处理并最终合并所有文件到一个文件。这个方法确保在多个文件频繁合并的环境中，能有效地管理和减少临时存储使用，并保持合并操作的效率。通过最后的重命名操作，它还处理了文件的最终存放，确保合并结果的正确性和可用性。</p><p>实现了 <code>merge.rs</code> 的相关内容，我们就可以来实现<code>create.rs</code> 中的最后一步了。</p><h3 id="step5-merge_index_files">step5: merge_index_files</h3><p>我们将第 4 阶段构建的临时文件合并成一个最终的索引文件并输出到<code>output_dir</code> 目录中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">merge_index_files</span>(files: Receiver&lt;PathBuf&gt;, output_dir: &amp;Path) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">merge</span> = FileMerge::<span class="hljs-title function_ invoke__">new</span>(output_dir);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">file</span> <span class="hljs-keyword">in</span> files &#123;<br>        merge.<span class="hljs-title function_ invoke__">add_file</span>(file)?;<br>    &#125;<br>    merge.<span class="hljs-title function_ invoke__">finish</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="run_pipeline">run_pipeline</h3><p>至此，我们就完成了并发构建倒排索引的 5个步骤了，对其进行组织，就可以实现我们的并发构建函数<code>run_pipeline</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_pipeline</span>(documents: <span class="hljs-type">Vec</span>&lt;PathBuf&gt;, output_dir: PathBuf) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// Launch all five stages of the pipeline.</span><br>    <span class="hljs-keyword">let</span> (texts, h1) = <span class="hljs-title function_ invoke__">start_file_reader_thread</span>(documents);<br>    <span class="hljs-keyword">let</span> (pints, h2) = <span class="hljs-title function_ invoke__">start_file_indexing_thread</span>(texts);<br>    <span class="hljs-keyword">let</span> (gallons, h3) = <span class="hljs-title function_ invoke__">start_in_memory_merge_thread</span>(pints);<br>    <span class="hljs-keyword">let</span> (files, h4) = <span class="hljs-title function_ invoke__">start_index_writer_thread</span>(gallons, &amp;output_dir);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">merge_index_files</span>(files, &amp;output_dir);<br><br>    <span class="hljs-comment">// Wait for threads to finish, holding on to any errors that they encounter.</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = h1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    h3.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r4</span> = h4.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// Return the first error encountered, if any.</span><br>    <span class="hljs-comment">// (As it happens, h2 and h3 can&#x27;t fail: those threads</span><br>    <span class="hljs-comment">// are pure in-memory data processing.)</span><br>    r1?;<br>    r4?;<br>    result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="read.rs">read.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/read.rs">read.rs</a></p></blockquote><p>在 <code>merge.rs</code> 中，我们还剩最后一个结构没有解析，那就是<code>IndexFileReader</code>，它是索引文件的读取器。</p><h3 id="struct-indexfilereader">struct: IndexFileReader</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IndexFileReader</span> &#123;<br>    <span class="hljs-keyword">pub</span> terms_docs: BufReader&lt;File&gt;,<br>    entries: BufReader&lt;File&gt;,<br>    next: <span class="hljs-type">Option</span>&lt;Entry&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">pub</span> term: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> df: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> offset: <span class="hljs-type">u64</span>,<br>    <span class="hljs-keyword">pub</span> nbytes: <span class="hljs-type">u64</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 <code>IndexFileReader</code> 结构体中定义两个<code>BufReader&lt;File&gt;</code>，这是为了有效管理和操作索引文件中的不同数据段。具体来说，这种设计使得代码能够更加灵活和高效地处理索引文件中的“主数据区”和“内容表区”。</p><p>即用来分别处理下图的 <code>terms&amp;doc</code> 和<code>entries</code> 两个区域：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423194529529-20240423195227516.png"alt="索引文件内存结构示意图" /><figcaption aria-hidden="true">索引文件内存结构示意图</figcaption></figure><p>这有几个好处：</p><ul><li><strong>独立的文件指针</strong>：每个<code>BufReader&lt;File&gt;</code>维护自己的文件读取位置（文件指针）。这意味着读取或搜索内容表时，不会影响主数据区的文件指针，反之亦然。这样可以避免频繁地重新定位文件指针，提高文件操作的效率。</li><li><strong>缓冲读取</strong>：<code>BufReader</code>提供了缓冲读取功能，可以减少直接对硬盘的读取次数，从而优化读取性能。对于需要频繁读取小块数据的索引操作，使用缓冲读取可以显著提高效率。</li><li><strong>并行操作</strong>：在多线程环境中，可能需要同时读取主数据区和内容表区。使用两个独立的<code>BufReader</code>实例可以简化并行读取的管理，每个读取操作都可以在不干扰另一个操作的情况下独立进行。</li></ul><p><code>Entry</code> 就是我们在 <code>write.rs</code> 中<code>write_contents_entry</code> 时传入的参数，这里我们将其封装成一个struct，再次回顾下这几个字段的含义：</p><ul><li><code>term</code>: 索引单词。为了统一，如果 <code>term</code>为空，则表示当前表示的是 doc，否则为 terms。</li><li><code>df</code>: term 的出现次数。为了统一，如果 <code>df</code> 为0，则表示当前表示的是 doc，否则为 terms。</li><li><code>offset</code>: 对应的 terms 或 docs 在文件中的偏移。</li><li><code>nbytes</code>: 对应的 terms 或 docs 的总长度。</li></ul><h3 id="read_entry">read_entry</h3><p>这里我们重点解释一下 <code>read_entry</code>方法，其他的都比较简单，请在源码中查找。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_entry</span>(f: &amp;<span class="hljs-keyword">mut</span> BufReader&lt;File&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">Option</span>&lt;Entry&gt;&gt; &#123;<br>  <span class="hljs-comment">// 获取偏移值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">offset</span> = <span class="hljs-keyword">match</span> f.read_u64::&lt;LittleEndian&gt;() &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(value) =&gt; value,<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> err.<span class="hljs-title function_ invoke__">kind</span>() == io::ErrorKind::UnexpectedEof &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-literal">None</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(err);<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>  <span class="hljs-comment">// 读取 nbytes</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">nbytes</span> = f.read_u64::&lt;LittleEndian&gt;()?;<br>  <span class="hljs-comment">// 读取 df</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">df</span> = f.read_u32::&lt;LittleEndian&gt;()?;<br>  <span class="hljs-comment">// 读取 term_len，并初始化一块内存 bytes 用来读取完整的 term</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">term_len</span> = f.read_u32::&lt;LittleEndian&gt;()? <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">bytes</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; term_len];<br>    f.<span class="hljs-title function_ invoke__">read_exact</span>(&amp;<span class="hljs-keyword">mut</span> bytes)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">term</span> = <span class="hljs-keyword">match</span> <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(bytes) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(s) =&gt; s,<br>        <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(io::Error::<span class="hljs-title function_ invoke__">new</span>(io::ErrorKind::Other, <span class="hljs-string">&quot;unicode fail&quot;</span>)),<br>    &#125;;<br><br>  <span class="hljs-comment">// 返回构建的 Entry</span><br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">Some</span>(Entry &#123;<br>        term,<br>        df,<br>        offset,<br>        nbytes,<br>    &#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>结合下面这张图，很容易理解 <code>read_entry</code> 就是前面<code>write_contents_entry</code> 的逆向过程。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240423224035544.png"alt="entries 区域布局，每个 entry 紧贴排布" /><figcaption aria-hidden="true">entries 区域布局，每个 entry紧贴排布</figcaption></figure><h2 id="create.rs-1">create.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/bin/create.rs">create.rs</a></p></blockquote><p>至此，我们就分析完并发构建索引的整个过程了，在 <code>create.rs</code>中，我们使用 <code>clap</code> 命令解析框架来构建一个 CLI工具用以支持构建索引，我们同时支持单线程构建和并发构建，具体可看完整源码。</p><p>如果对 <code>clap</code> 不熟悉的读者，可参考：<ahref="https://hedon.top/2024/03/02/rust-crate-clap/">深入探索 Rust 的clap 库：命令行解析的艺术</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Opts</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, default_value_t = false, help = <span class="hljs-string">&quot;Default false&quot;</span>)]</span><br>    single_threaded: <span class="hljs-type">bool</span>,<br><br>    <span class="hljs-meta">#[arg(required = true)]</span><br>    filenames: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">opts</span> = Opts::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">run</span>(opts.filenames, opts.single_threaded) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(()) =&gt; &#123;&#125;<br>        <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error: &#123;&#125;&quot;</span>, err),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="搜索功能">搜索功能</h1><p>在《Rust程序设计（第二版）》中，作者并没有实现搜索功能，笔者对其进行扩展，目标是对标我们前篇所构建的<ahref="https://hedon.top/2024/04/15/rust-action-inverted-index-demo/">Rust实战丨倒排索引</a>。这个搜索功能，会根据现有的索引文件重建内存索引<code>InMemoryIndex</code>，支持指定 <code>term</code>进行搜索，并将包含这个 <code>term</code>的文件在响应的位置中进行高亮显示并输出到终端。</p><h2 id="search.rs-1">search.rs</h2><blockquote><p>完整源码：<ahref="https://github.com/hedon-rust-road/inverted-index-concurrency/blob/master/src/bin/search.rs">search.rs</a></p></blockquote><p>程序入口如下所示，比较简单，就不赘述了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Opts</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, required = true, help = <span class="hljs-string">&quot;Specify index file path&quot;</span>)]</span><br>    index_file: <span class="hljs-type">String</span>,<br>    <span class="hljs-meta">#[arg(short, long, required = true, help = <span class="hljs-string">&quot;Specify search term&quot;</span>)]</span><br>    term: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">opts</span> = Opts::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">from_index_file</span>(opts.index_file)?;<br>    index.<span class="hljs-title function_ invoke__">search</span>(&amp;opts.term)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有 2 个核心逻辑：</p><ul><li><code>InMemoryIndex::from_index_file</code>:根据索引文件重建内存索引。</li><li><code>index.search(term)</code>: 搜索。</li></ul><h2 id="index.rs-1">index.rs</h2><p>我们在 <code>index.rs</code> 中为 <code>InMemoryIndex</code> 实现上述2 个方法。</p><h3 id="from_index_file">from_index_file</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_index_file</span>&lt;P: <span class="hljs-built_in">AsRef</span>&lt;Path&gt;&gt;(filename: P) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;InMemoryIndex&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index</span> = InMemoryIndex::<span class="hljs-title function_ invoke__">new</span>();<br><br>  <span class="hljs-comment">// 获取 IndexFileReader</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">reader</span> = IndexFileReader::<span class="hljs-title function_ invoke__">open_and_delete</span>(filename, <span class="hljs-literal">false</span>)?;<br><br>  <span class="hljs-comment">// 依次解析每个 Entry</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(entry) = reader.<span class="hljs-title function_ invoke__">iter_next_entry</span>() &#123;<br>        <span class="hljs-keyword">if</span> entry.term.<span class="hljs-title function_ invoke__">is_empty</span>() &amp;&amp; entry.df == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 当前 Entry 指向的是一个 Document。</span><br>          <span class="hljs-comment">// 通过 terms_docs 读取 Document 所在位置并进行解析。</span><br>            reader.terms_docs.<span class="hljs-title function_ invoke__">seek</span>(io::SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(entry.offset))?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">doc_id</span> = reader.terms_docs.read_u32::&lt;LittleEndian&gt;()?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">path_len</span> = reader.terms_docs.read_u64::&lt;LittleEndian&gt;()?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">path</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0u8</span>; path_len <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];<br>            reader.terms_docs.<span class="hljs-title function_ invoke__">read_exact</span>(&amp;<span class="hljs-keyword">mut</span> path)?;<br>            index.docs.<span class="hljs-title function_ invoke__">insert</span>(<br>                doc_id,<br>                Document &#123;<br>                    id: doc_id,<br>                    path: <span class="hljs-title function_ invoke__">vec_to_pathbuf</span>(path),<br>                &#125;,<br>            );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当前 Entry 指向的是一个 terms。</span><br>          <span class="hljs-comment">// 通过 terms_docs 读取 terms 所在位置并进行解析。</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hits</span> = <span class="hljs-built_in">vec!</span>[];<br>            reader.terms_docs.<span class="hljs-title function_ invoke__">seek</span>(io::SeekFrom::<span class="hljs-title function_ invoke__">Start</span>(entry.offset))?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">data</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0u8</span>; entry.nbytes <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];<br>            reader.terms_docs.<span class="hljs-title function_ invoke__">read_exact</span>(&amp;<span class="hljs-keyword">mut</span> data)?;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cursor</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(data);<br><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = entry.df;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">has_hit</span> = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">quit</span> = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; !quit &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hit</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span>); <span class="hljs-comment">// cannot use vec![0;12]</span><br>                <span class="hljs-keyword">loop</span> &#123;<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(item) = cursor.read_i32::&lt;LittleEndian&gt;() &#123;<br>                        <span class="hljs-comment">// the start of next hit</span><br>                        <span class="hljs-keyword">if</span> item == <span class="hljs-keyword">Self</span>::HITS_SEPERATOR &amp;&amp; has_hit &#123;<br>                            hits.<span class="hljs-title function_ invoke__">push</span>(hit);<br>                            i -= <span class="hljs-number">1</span>;<br>                            index.word_count -= <span class="hljs-number">2</span>;<br>                            hit = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span>);<br>                        &#125;<br>                        has_hit = <span class="hljs-literal">true</span>;<br>                        hit.write_u32::&lt;LittleEndian&gt;(item <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>                        index.word_count += <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        quit = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">if</span> !hit.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                            hits.<span class="hljs-title function_ invoke__">push</span>(hit);<br>                            index.word_count -= <span class="hljs-number">2</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            index.terms.<span class="hljs-title function_ invoke__">insert</span>(entry.term, hits);<br>        &#125;<br>    &#125;<br>    index.word_count /= <span class="hljs-number">2</span>;<br>    <span class="hljs-title function_ invoke__">Ok</span>(index)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="search">search</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search</span>(&amp;<span class="hljs-keyword">self</span>, term: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>  <span class="hljs-comment">// 获取 term 出现的位置</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span>: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;&gt;&gt; = <span class="hljs-keyword">self</span>.terms.<span class="hljs-title function_ invoke__">get</span>(term);<br>    <span class="hljs-keyword">if</span> m.<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;can not found &#123;&#125; in all documents&quot;</span>, term);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(());<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hits</span> = m.<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>  <span class="hljs-comment">// 遍历每个出现的位置</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">hit</span> <span class="hljs-keyword">in</span> hits &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cursor</span> = Cursor::<span class="hljs-title function_ invoke__">new</span>(hit);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = cursor.read_i32::&lt;LittleEndian&gt;().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>      <span class="hljs-comment">// 获取文档原始信息</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">document_id</span> = cursor.read_u32::&lt;LittleEndian&gt;().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">doc</span> = <span class="hljs-keyword">self</span>.docs.<span class="hljs-title function_ invoke__">get</span>(&amp;document_id);<br>        <span class="hljs-keyword">if</span> doc.<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;cannot found document &#123;&#125;&quot;</span>, document_id);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">doc</span> = doc.<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>      <span class="hljs-comment">// hits 存储的内容：[HITS_SEPERATOR, document_id, start_pos1, end_pos1, ...]</span><br>      <span class="hljs-comment">// 解析 term 出现在 doc 中的每个位置</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">poss</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(hits.<span class="hljs-title function_ invoke__">len</span>() / <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">pos</span> = TokenPos::<span class="hljs-title function_ invoke__">default</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">has_pos</span> = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(p) = cursor.read_u32::&lt;LittleEndian&gt;() &#123;<br>            <span class="hljs-keyword">if</span> !has_pos &#123;<br>                pos.start_pos = p;<br>                has_pos = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pos.end_pos = p;<br>                poss.<span class="hljs-title function_ invoke__">push</span>(pos);<br>                pos = TokenPos::<span class="hljs-title function_ invoke__">default</span>();<br>                has_pos = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>      <span class="hljs-comment">// 对每个出现的位置进行高亮处理</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">highlight_file</span>(doc.path.<span class="hljs-title function_ invoke__">clone</span>(), &amp;<span class="hljs-keyword">mut</span> poss)?;<br>      <span class="hljs-comment">// 输出高亮后的结果</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;\n&#123;:?&#125;: \n&#123;&#125;&quot;</span>, doc.path, result);<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>至此，我们就实现了高并发构建索引和根据索引进行搜索的功能，本篇某些部分可能比较复杂，篇幅也比较冗长，笔者在阅读书中原实现的时候，也是获益颇丰，想不到一个简单的倒排索引竟涉及这么多的处理细节。也希望本篇文章能对感兴趣的读者有些许帮助。</p><p>peace! enjoy coding~</p><h1 id="绘图工具">绘图工具</h1><ul><li><ahref="https://link.zhihu.com/?target=https%3A//excalidraw.com/">https://excalidraw.com/</a></li></ul><h1 id="参考资料">参考资料</h1><ul><li><ahref="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Inverted_index">维基百科·倒排索引</a></li><li><ahref="https://link.zhihu.com/?target=https%3A//book.douban.com/subject/36547630/">Rust程序设计（第二版）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>倒排索引</tag>
      
      <tag>并发编程</tag>
      
      <tag>通道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 实战丨倒排索引</title>
    <link href="/2024/04/15/rust-action-inverted-index-demo/"/>
    <url>/2024/04/15/rust-action-inverted-index-demo/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>倒排索引（InvertedIndex）是一种索引数据结构，用于存储某个单词（词项）在一组文档中的所有出现情况的映射。它是搜索引擎执行快速全文搜索的核心技术，也广泛用于数据库中进行文本搜索。我们熟知的ElasticSearch 最核心底层原理便就是倒排索引。</p><p>倒排索引的基本原理是<strong>将文档中的词汇进行反转，形成倒排列表</strong>。在倒排列表中，每个词汇都对应一个文档标识符的列表，这些标识符指明了该词汇出现在哪些文档中。通过查询倒排列表，可以快速地找到包含特定词汇的文档。</p><p>本文将使用 Rust语言来实现一个简单的倒排索引，包括倒排索引的构建和搜索过程。在下一篇文章中，笔者会基于《Rust程序设计（第二版）》并发编程篇章，解读该书作者是如何基于 Rust通道实现更优秀、更高性能的倒排索引。</p><h1 id="可以学到">可以学到</h1><ol type="1"><li>倒排索引的原理、优势和使用</li><li>常用 crate：<code>colored</code>、<code>regex</code></li><li>Rust HashMap</li><li>Rust 迭代器</li></ol><h1 id="开发思路">开发思路</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240414112337590.png"alt="倒排索引构建过程" /><figcaption aria-hidden="true">倒排索引构建过程</figcaption></figure><p>一个简单的倒排索引开发思路大概如上图所示：</p><ol type="1"><li>读取文档</li><li>分词</li><li>构建每个词到每个文档的映射</li></ol><h1 id="开发过程">开发过程</h1><blockquote><p>完整源码位于：<ahref="https://github.com/hedon-rust-road/inverted-index">inverted_index</a>。</p></blockquote><h2 id="最终效果">最终效果</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">index</span> = InvertedIndex::<span class="hljs-title function_ invoke__">new</span>();<br>    index.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Rust is safe and fast.&quot;</span>);<br>    index.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Rust is a systems programming language.&quot;</span>);<br>    index.<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Programming in Rust is fun.&quot;</span>);<br><br>    <span class="hljs-comment">// query &quot;Rust&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">results</span> = index.<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;Rust&quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">result</span> <span class="hljs-keyword">in</span> results &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-comment">// query &quot;Programming&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">results</span> = index.<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;Programming&quot;</span>);<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">result</span> <span class="hljs-keyword">in</span> results &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo run<br></code></pre></td></tr></table></figure><p>输出：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240414122848805.png"alt="inverted index 输出示例" /><figcaption aria-hidden="true">inverted index 输出示例</figcaption></figure><h2 id="版本声明">版本声明</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;inverted_index&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">colored</span> = <span class="hljs-string">&quot;2.1.0&quot;</span><br><span class="hljs-attr">regex</span> = <span class="hljs-string">&quot;1.10.4&quot;</span><br></code></pre></td></tr></table></figure><h2 id="项目准备">项目准备</h2><p>首先我们创建项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new inverted_index<br></code></pre></td></tr></table></figure><p>准备依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add regex<br>cargo add colored<br></code></pre></td></tr></table></figure><ul><li>colored:终端高亮，后面我们将实现搜索词的高亮显示，使结果更美观。</li><li>regex: 正则库，用于实现不区分大小写替换匹配到的搜索词。</li></ul><h2 id="实现过程">实现过程</h2><p>首先我们定义两个数据结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Document</span> &#123;<br>    id: <span class="hljs-type">usize</span>,<br>    content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>    indexes: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt;&gt;,<br>    documents: HashMap&lt;<span class="hljs-type">usize</span>, Document&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> InvertedIndex &#123;<br>        InvertedIndex &#123;<br>            indexes: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>            documents: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Document: 封装原始文档</li><li>IndexedIndex: 我们将构建的倒排索引</li></ul><p>接下来我们要实现 2 个辅助函数，一个是<code>tokenize</code>，用于将原始的文档信息拆分成独立的词（word/term），另一个是<code>hightlight</code>，用于将匹配到的文本进行替换，使其在中断可以以<font color="purple">紫色</font>输出。</p><p><code>tokenize</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tokenize</span>(text: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-type">str</span>&gt; &#123;<br>    text.<span class="hljs-title function_ invoke__">split</span>(|ch: <span class="hljs-type">char</span>| !ch.<span class="hljs-title function_ invoke__">is_alphanumeric</span>())<br>        .<span class="hljs-title function_ invoke__">filter</span>(|c| !c.<span class="hljs-title function_ invoke__">is_empty</span>())<br>        .<span class="hljs-title function_ invoke__">collect</span>()<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tokenize_test</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        <span class="hljs-title function_ invoke__">tokenize</span>(<span class="hljs-string">&quot;This is\nhedon&#x27;s tokenize function.&quot;</span>),<br>        <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;This&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;hedon&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;tokenize&quot;</span>, <span class="hljs-string">&quot;function&quot;</span>]<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>highlight</code> 实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">highlight</span>(term: &amp;<span class="hljs-type">str</span>, content: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">regex</span> = Regex::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-built_in">format!</span>(<span class="hljs-string">r&quot;(?i)&#123;&#125;&quot;</span>, term)).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">highlighted_content</span> = regex<br>        .<span class="hljs-title function_ invoke__">replace_all</span>(content, |caps: &amp;regex::Captures| &#123;<br>            caps[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">purple</span>().<span class="hljs-title function_ invoke__">to_string</span>()<br>        &#125;)<br>        .<span class="hljs-title function_ invoke__">to_string</span>();<br>    highlighted_content<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">highlight_test</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        <span class="hljs-title function_ invoke__">highlight</span>(<span class="hljs-string">&quot;programming&quot;</span>, <span class="hljs-string">&quot;I like programming with Rust Programming&quot;</span>),<br>        <span class="hljs-string">&quot;I like \u&#123;1b&#125;[35mprogramming\u&#123;1b&#125;[0m with Rust \u&#123;1b&#125;[35mProgramming\u&#123;1b&#125;[0m&quot;</span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以为 <code>InvertedIndex</code> 实现构建索引的方法<code>add</code>了，它会接收原始文档，对其进行分词，并将记录每个分词和文档 id的映射。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, doc_id: <span class="hljs-type">usize</span>, content: &amp;<span class="hljs-type">str</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">content_lowercase</span> = content.<span class="hljs-title function_ invoke__">to_lowercase</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">words</span> = <span class="hljs-title function_ invoke__">tokenize</span>(&amp;content_lowercase);<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> words &#123;<br>            <span class="hljs-keyword">self</span>.indexes<br>                .<span class="hljs-title function_ invoke__">entry</span>(word.<span class="hljs-title function_ invoke__">to_string</span>())<br>                .<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-built_in">vec!</span>[])<br>                .<span class="hljs-title function_ invoke__">push</span>(doc_id)<br>        &#125;<br><br>        <span class="hljs-keyword">self</span>.documents.<span class="hljs-title function_ invoke__">insert</span>(<br>            doc_id,<br>            Document &#123;<br>                id: doc_id,<br>                content: content.<span class="hljs-title function_ invoke__">to_string</span>(),<br>            &#125;,<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们再实现对应的根据分词 <code>term</code>搜索原始文档的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">InvertedIndex</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">query</span>(&amp;<span class="hljs-keyword">self</span>, term: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">term_lowercase</span> = term.<span class="hljs-title function_ invoke__">to_lowercase</span>();<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(doc_ids) = <span class="hljs-keyword">self</span>.indexes.<span class="hljs-title function_ invoke__">get</span>(&amp;term_lowercase) &#123;<br>            doc_ids<br>                .<span class="hljs-title function_ invoke__">iter</span>()<br>                .<span class="hljs-title function_ invoke__">filter_map</span>(|doc_id| &#123;<br>                    <span class="hljs-keyword">self</span>.documents<br>                        .<span class="hljs-title function_ invoke__">get</span>(doc_id)<br>                        .<span class="hljs-title function_ invoke__">map</span>(|doc| <span class="hljs-title function_ invoke__">highlight</span>(&amp;term_lowercase, &amp;doc.content))<br>                &#125;)<br>                .<span class="hljs-title function_ invoke__">collect</span>()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一个简单的倒排索引构建和搜索功能就完成了，具体的执行效果你可以回到前面的「最终效果」进行查阅。</p><h1 id="总结预告">总结预告</h1><p>本文实现的倒排索引虽然非常简单，但是也基本体现了倒排索引的最核心思想和应用方式了。在《Rust程序设计（第二版）》的并发编程篇章中，该书提出了使用通道 channel来并发构建倒排索引，同时给出了更加丰富和优雅的实现。在下篇文章中，笔者将阅读这部分的源码，解析并重现当中的实战过程，并进行适当扩展。</p><p>peace! enjoy coding~</p><h1 id="绘图工具">绘图工具</h1><ul><li>https://excalidraw.com/</li></ul><h1 id="参考资料">参考资料</h1><ul><li><ahref="https://en.wikipedia.org/wiki/Inverted_index">维基百科·倒排索引</a></li><li><a href="https://book.douban.com/subject/36547630/">Rust程序设计（第二版）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>倒排索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出 Go 语言的 defer 机制</title>
    <link href="/2024/03/28/go-defer/"/>
    <url>/2024/03/28/go-defer/</url>
    
    <content type="html"><![CDATA[<p>Go语言以其简洁的语法和强大的并发支持而闻名。在这些特性中，<code>defer</code>语句是 Go语言提供的一项独特功能，它允许我们推迟函数的执行直到包含它的函数即将返回。这个简单而强大的机制不仅可以帮助我们处理资源释放和错误处理，还能让代码更加简洁和安全。本文将深入浅出地介绍<code>defer</code>的工作原理，探究其背后的机制，并通过丰富的案例来展示它的实际应用。</p><p>笔者本来以为 Go 语言的 <code>defer</code>其实东西不多，就是类似于“栈”的操作罢了，无非就是用于释放资源、后进先出而已。但是最近在阅读完《深入理解Go 语言》、《Go 底层原理剖析》和《Go 语言设计与实现》中关于<code>defer</code>的篇章。发现其中隐含的道道和坑还是比较有意思的，特此整理这篇文章，希望能对Go <code>defer</code> 原理感兴趣的读者带来一些帮助。</p><p>本文具体会包含以下内容：</p><ul><li><strong><code>defer</code> 机制简介</strong>：介绍<code>defer</code> 关键字的基本概念和它在 Go 语言中的作用。</li><li><strong><code>defer</code> 的工作原理</strong>：深入探讨<code>defer</code> 在函数执行结束时如何工作的细节。</li><li><strong><code>defer</code> 的执行顺序</strong>：解释<code>defer</code> 语句是如何按照后进先出（LIFO）的顺序执行的。</li><li><strong>参数预计算和值传递</strong>：讨论 <code>defer</code>语句中参数是如何被预先计算和传递的。</li><li><strong>环境变量和闭包</strong>：探讨 <code>defer</code>如何与闭包一起工作，以及如何捕获和影响环境变量。</li><li><strong><code>defer</code> 与错误处理</strong>：说明如何利用<code>defer</code> 和 <code>recover</code> 进行错误处理和异常捕获。</li><li><strong><code>defer</code> 的实现细节</strong>：深入分析<code>defer</code>的不同实现策略，包括堆上分配、栈上分配和开放编码。</li></ul><h1 id="版本声明">版本声明</h1><ul><li>Go1.22</li></ul><h1 id="思维导图">思维导图</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/Go%20defer.png"alt="Go defer" /><figcaption aria-hidden="true">Go defer</figcaption></figure><h1 id="核心要点">核心要点</h1><p>对于后面将要分析的各种各样的情况，在分析的时候只要遵循以下几个核心点，基本上就不会跑偏：</p><ol type="1"><li>延迟执行：在函数结束时执行，包括正常返回或遭遇 panic。</li><li>栈式执行顺序：后定义的 <code>defer</code> 先执行（LIFO）。</li><li>参数预计算：<code>defer</code> 语句定义时即计算并固定参数值。</li><li>值传递原则：<code>defer</code> 拷贝参数，使用定义时的值。</li><li>环境变量捕获：在 <code>defer</code>中可以跟一个闭包，闭包可以捕获环境变量，当然这包括具名返回值。</li></ol><p>特别说明的是，虽然我们通常将 <code>defer</code>想象为使用栈进行管理，但是实际实现上，<code>defer</code>并不都是存放在栈上的，我们后面会具体分析到。这种实现细节通常对于编写正确的Go代码并不重要，但了解这一点对于深入理解语言内部机制可能是有帮助的。</p><h1 id="基本用法">基本用法</h1><p>在 Go 语言中，<code>defer</code>语句通常用于确保一个函数调用在程序执行结束时发生，常见的用例包括文件关闭、锁释放、资源回收等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    f, err := os.Open(filename)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-comment">// 确保文件在函数返回时关闭</span><br>    <span class="hljs-keyword">defer</span> f.Close()<br><br>    <span class="hljs-comment">// ... 处理文件 ...</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>defer f.Close()</code> 保证了无论<code>readFile</code>函数如何返回（正常返回或发生错误），<code>f.Close()</code>都会被调用，从而避免了资源泄露。</p><h1 id="执行顺序">执行顺序</h1><p><code>defer</code>的执行顺序是先进后出，即“栈”操作。这里借用刘丹冰老师的一张图来演示这个过程：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/1651037338287-fd17c81d-a1ad-4bc7-ae7e-eec8a264af5f.jpeg"alt="Go defer 执行顺序" /><figcaption aria-hidden="true">Go defer 执行顺序</figcaption></figure><p>我们可以通过以下代码进行验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func1...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func2...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func3...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> func1()<br><span class="hljs-keyword">defer</span> func2()<br><span class="hljs-keyword">defer</span> func3()<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">func3</span></span>...<br><span class="hljs-function"><span class="hljs-title">func2</span></span>...<br><span class="hljs-function"><span class="hljs-title">func1</span></span>...<br></code></pre></td></tr></table></figure><h1 id="参数求值与陷阱">参数求值与陷阱</h1><p>关于 <code>defer</code>参数这一块，是一个比较容易出错的地方。我们先来看一个例子，你可以分析下它的输出会是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printI</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;printI i:&quot;</span>, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">10</span><br><span class="hljs-keyword">defer</span> printI(i * <span class="hljs-number">10</span>)<br>i = i + <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;main i:&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure><p>按照我们之前总结的核心点：<strong>参数预计算：<code>defer</code>语句定义时即计算并固定参数值</strong>。具体来说，在把 <code>defer</code>压入“栈”时，会同时压入<strong>函数地址</strong>和<strong>函数形参</strong>，也就是会在这个时候就把参数先算好。所以在执行到第7 行代码的时候，就会把 <code>i*10</code> 算好，然后同<code>printI</code> 一同压入到延迟执行栈中。</p><p>所以最后的结果就是：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">i</span>: <span class="hljs-number">11</span><br><span class="hljs-selector-tag">printI</span> <span class="hljs-selector-tag">i</span>: <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>关于<strong>参数值传递</strong>，笔者这里再举两个例子进行比较，体会后你应该就理解了。</p><p>第一个例子中，<code>defer</code>后面参数是指针，本质上<strong>值传递</strong>，但是拷贝的是指针，所以在<code>defer</code> 中修改的东西，最后会反馈到指针指向的对象，所以对<code>testUser</code> 的返回值是有影响的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span>&#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testUser</span><span class="hljs-params">()</span></span> *User &#123;<br>user := &amp;User&#123;&#125;<br>user.name = <span class="hljs-string">&quot;name-1&quot;</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u *User)</span></span> &#123;<br>u.name = <span class="hljs-string">&quot;name-defer&quot;</span><br>&#125;(user)<br><br>user.name = <span class="hljs-string">&quot;name-2&quot;</span><br><span class="hljs-keyword">return</span> user<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>user := testUser()<br>fmt.Println(user)<br>&#125;<br><span class="hljs-comment">// &amp;&#123;name-defer&#125;</span><br></code></pre></td></tr></table></figure><p>第二个例子中，我们传入的就是结构体示例本身了，因为值传递，即拷贝了一份新的<code>user</code>，所以闭包内的修改对外面是不产生影响的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testUser</span><span class="hljs-params">()</span></span> User &#123;<br>user := User&#123;&#125;<br>user.name = <span class="hljs-string">&quot;name-1&quot;</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u User)</span></span> &#123;<br>u.name = <span class="hljs-string">&quot;name-defer&quot;</span><br>&#125;(user)<br><br>user.name = <span class="hljs-string">&quot;name-2&quot;</span><br><span class="hljs-keyword">return</span> user<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>user := testUser()<br>fmt.Println(user)<br>&#125;<br><span class="hljs-comment">// &#123;name-2&#125;</span><br></code></pre></td></tr></table></figure><h1 id="环境变量捕获">环境变量捕获</h1><p>将上面的一个例子进行简单修改，会输出什么呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printI</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;printI i:&quot;</span>, i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">10</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>printI(i * <span class="hljs-number">10</span>)<br>&#125;()<br>i = i + <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;main i:&quot;</span>, i)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候其实没有参数，所以会直接将下面闭包压入延迟栈中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  printI(i * <span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>而闭包是可以捕获环境变量的，所以在 <code>main</code> return后，<code>defer</code> 可以捕获到 <code>i</code> 的值，为更新后的<code>i+1</code>，最后再进行 <code>printI(i * 10)</code>。</p><p>所以输出结果是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">main i: <span class="hljs-number">11</span><br>printI i: <span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>所以说，<code>defer</code>后面的闭包，是可以捕获环境变量的，如果这个变量是返回值的话，那么理所应当也是可以对其产生作用的，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getI</span><span class="hljs-params">()</span></span> (i <span class="hljs-type">int</span>) &#123;<br>i = <span class="hljs-number">1</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i *= <span class="hljs-number">10</span><br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(getI())<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，<code>getI</code> 的返回值是有名字的<code>i</code>，<code>getI</code> 执行了<code>return 20</code>，其实就是将 <code>i</code> 设置为<code>20</code>，所以在执行到 <code>defer</code> 闭包的时候，捕获到了<code>i=20</code>，并将其进行了修改。所以最终输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h1 id="错误处理与-defer">错误处理与 defer</h1><p>我们都知道 Go 程序中遇到 <code>panic</code>就会中断后面的执行流程直接返回，这个时候我们可以在 <code>defer</code>中结合 <code>recover</code> 来捕获这个<code>panic</code>，从而保护程序不崩溃。</p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panicAndRecover</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;函数中正常流程&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;出现异常&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;panic 后的语句永远执行不到&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>panicAndRecover()<br>fmt.Println(<span class="hljs-string">&quot;正常回到 main&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 函数中正常流程</span><br><span class="hljs-comment">// 出现异常</span><br><span class="hljs-comment">// 正常回到 main</span><br></code></pre></td></tr></table></figure><p>更进一步，如果我们在 <code>defer</code> 中也有 <code>panic</code>呢？请思考下列代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panicAndRecover</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;第 1 个入栈的 defer&quot;</span>)<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;最终捕获的 panic:&quot;</span>, err)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;第 2 个入栈的 defer&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;第 2 个入栈的 defer 发生 panic&quot;</span>)<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;panicAndRecover 函数中正常流程&quot;</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panicAndRecover 出现异常&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;panic 后的语句永远执行不到&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>panicAndRecover()<br>fmt.Println(<span class="hljs-string">&quot;正常回到 main&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们在 <code>panicAndRecover</code> 强行抛出<code>panic</code>，由于 <code>defer</code> 先进后出，所以我们会先执行第2 个 <code>defer</code>，其中也发生了 <code>panic</code>，我们在第 1 个<code>defer</code> 中对 <code>panic</code> 进行<code>recover</code>，最终的现象是只捕获到了后面抛出的<code>panic</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">panicAndRecover 函数中正常流程<br>第 <span class="hljs-number">2</span> 个入栈的 <span class="hljs-keyword">defer</span><br>第 <span class="hljs-number">1</span> 个入栈的 <span class="hljs-keyword">defer</span><br>最终捕获的 <span class="hljs-built_in">panic</span>: 第 <span class="hljs-number">2</span> 个入栈的 <span class="hljs-keyword">defer</span> 发生 <span class="hljs-built_in">panic</span><br>正常回到 main<br></code></pre></td></tr></table></figure><p>这是为什么呢？</p><p>在 Go 语言中，<code>panic</code> 函数实际上是创建了一个<code>panic</code> 对象，并抛出这个对象。</p><p>当一个 <code>panic</code> 发生并开始向上传播时，Go 运行时会检查每个<code>defer</code>。如果 <code>defer</code> 中包含 <code>recover</code>调用，并且它被执行，那么 <code>recover</code> 会捕获当前的<code>panic</code>，并且防止它继续向上传播。如果 <code>defer</code>中再次发生 <code>panic</code>，那么原来的 <code>panic</code> 就不会被<code>recover</code> 捕获，因为 <code>defer</code>函数已经退出了。在这种情况下，新的 <code>panic</code>会导致程序崩溃，因为没有更多的 <code>defer</code> 函数去<code>recover</code> 这个新的 <code>panic</code>。</p><p>这说明了 Go 程序中不允许同时有多个活跃的 <code>panic</code>存在，这个设计确保了在任何给定的时刻，只有一个 <code>panic</code>能够被处理。这样做有几个原因：</p><ol type="1"><li><strong>简化错误处理：</strong> 如果同时存在多个<code>panic</code>，就会变得非常复杂去确定如何处理它们，尤其是在它们之间存在依赖关系的时候。一个<code>panic</code>应该表示一个不可恢复的错误，如果有多个这样的错误同时存在，程序的状态可能会变得非常不确定。</li><li><strong>保持一致性：</strong> <code>panic</code>通常表示程序中出现了严重错误，可能会破坏程序的一致性或安全性。如果允许多个<code>panic</code> 同时存在，就很难保证程序状态的一致性，因为不同的<code>panic</code> 可能需要回退不同的操作。</li><li><strong>避免资源泄漏：</strong> <code>defer</code>语句用于确保资源被释放，例如文件和锁。如果在处理一个 <code>panic</code>的过程中，又发生了另一个 <code>panic</code>，可能会导致<code>defer</code> 语句中剩余的清理代码无法执行，从而引起资源泄漏。</li><li><strong>控制流程清晰：</strong> <code>panic</code> 和<code>recover</code> 的设计使得错误的控制流程清晰且可预测。一旦一个<code>panic</code> 被 <code>recover</code>捕获，程序可以选择是否继续执行，或者是通过重新 <code>panic</code>来终止程序。这种决策过程在多个 <code>panic</code>情况下会变得复杂且难以管理。</li></ol><p>因此，在 Go 的设计中，不允许同时存在多个活跃的<code>panic</code>。一旦发生 <code>panic</code>，它必须被<code>recover</code>处理，否则程序将会终止。这确保了错误处理的清晰性和程序的稳定性。</p><h1 id="defer-放在哪">defer 放在哪</h1><p><code>defer</code> 实际上不一定是放在栈上的，截止Go1.22，<code>defer</code> 其实用 3 种分配策略：</p><ul><li>堆上分配</li><li>栈上分配</li><li>开放编码</li></ul><h2 id="执行机制">执行机制</h2><p>在 <ahref="https://github.com/golang/go/blob/release-branch.go1.22/src/cmd/compile/internal/ssagen/ssa.go">ssa.go</a>文件中，我们可以找到 <code>state.stmt()</code>，这个函数是负责在 Go程序编译过程中中间代码生成阶段时对不同语句的处理过程，其中对于<code>ODEFER</code> 即 <code>defer</code> 语句的处理逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// stmt converts the statement n to SSA and adds it to s.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *state)</span></span> stmt(n ir.Node) &#123;<br>s.stmtList(n.Init())<br><span class="hljs-keyword">switch</span> n.Op() &#123;<br><span class="hljs-keyword">case</span> ir.ODEFER:<br>      n := n.(*ir.GoDeferStmt)<br>      <span class="hljs-keyword">if</span> base.Debug.Defer &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">var</span> defertype <span class="hljs-type">string</span><br>        <span class="hljs-keyword">if</span> s.hasOpenDefers &#123;<br>          defertype = <span class="hljs-string">&quot;open-coded&quot;</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n.Esc() == ir.EscNever &#123;<br>          defertype = <span class="hljs-string">&quot;stack-allocated&quot;</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          defertype = <span class="hljs-string">&quot;heap-allocated&quot;</span><br>        &#125;<br>        base.WarnfAt(n.Pos(), <span class="hljs-string">&quot;%s defer&quot;</span>, defertype)<br>      &#125;<br>...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，总共有 3 种分配策略：</p><ul><li><strong>open-coded</strong>: s.hasOpenDefers == true</li><li><strong>stack-allocated</strong>: n.Esc() == ir.EscNever</li><li><strong>heap-allocated</strong>: 默认</li></ul><p>默认是堆分配，在 Go1.13以前，也只有堆分配这一种策略，不过该实现的性能较差。Go 语言在 1.13中引入栈上分配的结构体，<ahref="https://go-review.googlesource.com/c/go/+/171758">减少了 30%的额外开销</a>，并在 1.14 中引入了基于开放编码的<code>defer</code>，使得该关键字的额外开销<ahref="https://go-review.googlesource.com/c/go/+/190098/6">几乎可以忽略不计</a>。</p><p>本文中不对具体的分配机制进行分析，这一块会比较复杂，笔者本身也不是很感兴趣，便决定对此不过分深究，感兴趣的读者推荐详细阅读《Go语言设计与实现》中关于 <code>defer</code>关键字的分析：https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/。</p><p>本文只讨论什么情况下会使用什么分配策略。由于堆分配是默认的，我们就不作分析了，具体来看看<code>s.hasOpenDefers == true</code> 和<code>n.Esc() == ir.EscNever</code> 什么时候会成立。</p><h2 id="栈上分配">栈上分配</h2><p>我们先来看栈上分配，要满足栈上分配，则需要满足<code>n.Esc() == ir.EscNever</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>EscUnknown = <span class="hljs-literal">iota</span><br>EscNone    <span class="hljs-comment">// Does not escape to heap, result, or parameters.</span><br>EscHeap    <span class="hljs-comment">// Reachable from the heap</span><br>EscNever   <span class="hljs-comment">// By construction will not escape.</span><br>)<br></code></pre></td></tr></table></figure><p>当 <code>n</code> 的逃逸分析结果是 <code>ir.EscNever</code>，则表明该<code>defer</code>语句从不逃逸（不会在函数调用结束后仍然被引用），这种情况下<code>defer</code> 将被分配到栈上（stack-allocated）。否则，如果<code>defer</code> 逃逸了，就会被分配到堆上（heap-allocated）。</p><p>那 <code>defer</code> 语句什么时候会逃逸呢？</p><blockquote><p>在 Go中，一个变量的逃逸意味着它的生命周期超出了当前函数的范围。在函数内定义的变量通常分配在栈上，而在堆上分配内存需要更复杂的管理。在一些情况下，编译器可能会选择将变量分配在堆上，这种情况下我们称之为逃逸。</p></blockquote><p>对于 <code>defer</code> 语句，如果它引用了函数外的变量，这个<code>defer</code> 就会逃逸。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(x) <span class="hljs-comment">// 这里引用了外部变量 x</span><br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>defer</code> 函数内部引用了 <code>x</code>这个外部变量，因此 <code>defer</code> 语句需要确保 <code>x</code> 在<code>defer</code> 函数执行时仍然有效。为了满足这个条件，编译器可能会将<code>x</code> 分配在堆上，而不是栈上。</p><h2 id="开放编码">开放编码</h2><p>先给结论，在开发过程中，要使用开放编码策略，你只需要关注以下 4点即可：</p><ol type="1"><li>函数的 <code>defer</code> 数量不能超过 8 个；</li><li>函数的 <code>defer</code> 关键字不能在循环中执行；</li><li>函数的 <code>defer</code> 中不能发生逃逸；</li><li>函数的 <code>return</code> 语句与 <code>defer</code>语句的乘积小于或者等于 15 个；</li></ol><hr /><p>Ok，下面是具体的分析过程。</p><p>借助 Goland 的能力，将鼠标光标放在 <code>s.hasOpenDefers</code>上，按住 <strong>Command</strong>加点击鼠标，可以看到该属性的使用情况：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328133312845-20240328202233278.png"alt="s.hasOpenDefers" /><figcaption aria-hidden="true">s.hasOpenDefers</figcaption></figure><p>可以看到该属性的判断逻辑都在 <ahref="https://github.com/golang/go/blob/release-branch.go1.22/src/cmd/compile/internal/ssagen/ssa.go">ssa.go</a>文件中的 <code>buildssa()</code>函数中。去掉一些无关的代码，核心逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// buildssa builds an SSA function for fn.</span><br><span class="hljs-comment">// worker indicates which of the backend workers is doing the processing.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildssa</span><span class="hljs-params">(fn *ir.Func, worker <span class="hljs-type">int</span>)</span></span> *ssa.Func &#123;<br>...<br>  <span class="hljs-comment">// ①</span><br>s.hasOpenDefers = base.Flag.N == <span class="hljs-number">0</span> &amp;&amp; s.hasdefer &amp;&amp; !s.curfn.OpenCodedDeferDisallowed()<br><span class="hljs-keyword">switch</span> &#123;<br>  <span class="hljs-comment">// ②</span><br><span class="hljs-keyword">case</span> base.Debug.NoOpenDefer != <span class="hljs-number">0</span>:<br>s.hasOpenDefers = <span class="hljs-literal">false</span><br><span class="hljs-keyword">case</span> s.hasOpenDefers &amp;&amp; (base.Ctxt.Flag_shared || base.Ctxt.Flag_dynlink) &amp;&amp; base.Ctxt.Arch.Name == <span class="hljs-string">&quot;386&quot;</span>:<br>    <span class="hljs-comment">// ③</span><br><span class="hljs-comment">// Don&#x27;t support open-coded defers for 386 ONLY when using shared</span><br><span class="hljs-comment">// libraries, because there is extra code (added by rewriteToUseGot())</span><br><span class="hljs-comment">// preceding the deferreturn/ret code that we don&#x27;t track correctly.</span><br>s.hasOpenDefers = <span class="hljs-literal">false</span><br>&#125;<br>  <span class="hljs-comment">// ④</span><br><span class="hljs-keyword">if</span> s.hasOpenDefers &amp;&amp; <span class="hljs-built_in">len</span>(s.curfn.Exit) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Skip doing open defers if there is any extra exit code (likely</span><br><span class="hljs-comment">// race detection), since we will not generate that code in the</span><br><span class="hljs-comment">// case of the extra deferreturn/ret segment.</span><br>s.hasOpenDefers = <span class="hljs-literal">false</span><br>&#125;<br>  <span class="hljs-comment">// ⑤</span><br><span class="hljs-keyword">if</span> s.hasOpenDefers &#123;<br><span class="hljs-comment">// Similarly, skip if there are any heap-allocated result</span><br><span class="hljs-comment">// parameters that need to be copied back to their stack slots.</span><br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> s.curfn.Type().Results().FieldSlice() &#123;<br><span class="hljs-keyword">if</span> !f.Nname.(*ir.Name).OnStack() &#123;<br>s.hasOpenDefers = <span class="hljs-literal">false</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br>  <span class="hljs-comment">// ⑥</span><br><span class="hljs-keyword">if</span> s.hasOpenDefers &amp;&amp;<br>s.curfn.NumReturns*s.curfn.NumDefers &gt; <span class="hljs-number">15</span> &#123;<br><span class="hljs-comment">// Since we are generating defer calls at every exit for</span><br><span class="hljs-comment">// open-coded defers, skip doing open-coded defers if there are</span><br><span class="hljs-comment">// too many returns (especially if there are multiple defers).</span><br><span class="hljs-comment">// Open-coded defers are most important for improving performance</span><br><span class="hljs-comment">// for smaller functions (which don&#x27;t have many returns).</span><br>s.hasOpenDefers = <span class="hljs-literal">false</span><br>&#125;<br>  ...<br><span class="hljs-keyword">return</span> s.f<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到总共有 6个条件，我已在注释中进行标注，我们来进行逐一分析：</p><h3 id="base.flag.n-0-s.hasdefer-s.curfn.opencodeddeferdisallowed">①base.Flag.N == 0 &amp;&amp; s.hasdefer &amp;&amp;!s.curfn.OpenCodedDeferDisallowed()</h3><blockquote><p>如果<code>base.Flag.N</code> 等于 0且当前函数有延迟调用且没有禁止开放式延迟，那么设置<code>s.hasOpenDefers</code>为<code>true</code>。</p></blockquote><p>在 Go编译器中，<code>-N</code>标志通常用于禁用优化。在这段代码中，如果<code>base.Flag.N</code>等于0，意味着没有禁用优化，因此编译器可能会尝试使用更高级的优化技术，比如开放式延迟（open-codeddefers）。</p><p><code>OpenCodedDeferDisallowed()</code>即禁用开放编码，它的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> funcOpenCodedDeferDisallowed <span class="hljs-comment">// can&#x27;t do open-coded defers</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Func)</span></span> OpenCodedDeferDisallowed() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> f.flags&amp;funcOpenCodedDeferDisallowed != <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p>按住 Command 后点击 <code>funcOpenCodedDeferDisallowed</code>可以看到只有 <code>funcOpenCodedDeferDisallowed(b)</code>可以修改它的值。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328140733594.png"alt="funcOpenCodedDeferDisallowed" /><figcaption aria-hidden="true">funcOpenCodedDeferDisallowed</figcaption></figure><p>我们来看看哪个地方会调用<code>funcOpenCodedDeferDisallowed()</code>，并将<code>funcOpenCodedDeferDisallowed</code> 设置为 <code>true</code>：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328140859879.png"alt="将 funcOpenCodedDeferDisallowed 设置为 true 的地方" /><figcaption aria-hidden="true">将 funcOpenCodedDeferDisallowed 设置为true 的地方</figcaption></figure><p>调用它的地方在 <ahref="https://github.com/golang/go/blob/release-branch.go1.22/src/cmd/compile/internal/walk/stmt.go">stmt.go</a>文件中的 <code>walkStmt()</code> 函数，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The max number of defers in a function using open-coded defers. We enforce this</span><br><span class="hljs-comment">// limit because the deferBits bitmask is currently a single byte (to minimize code size)</span><br><span class="hljs-keyword">const</span> maxOpenDefers = <span class="hljs-number">8</span><br><br><span class="hljs-comment">// The result of walkStmt MUST be assigned back to n, e.g.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//n.Left = walkStmt(n.Left)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkStmt</span><span class="hljs-params">(n ir.Node)</span></span> ir.Node &#123;<br>  ...<br><span class="hljs-keyword">switch</span> n.Op() &#123;<br>    ...<br>    <span class="hljs-keyword">case</span> ir.ODEFER:<br>      n := n.(*ir.GoDeferStmt)<br>      ir.CurFunc.SetHasDefer(<span class="hljs-literal">true</span>)<br>      ir.CurFunc.NumDefers++<br>      <span class="hljs-keyword">if</span> ir.CurFunc.NumDefers &gt; maxOpenDefers &#123;<br>        <span class="hljs-comment">// Don&#x27;t allow open-coded defers if there are more than</span><br>        <span class="hljs-comment">// 8 defers in the function, since we use a single</span><br>        <span class="hljs-comment">// byte to record active defers.</span><br>        ir.CurFunc.SetOpenCodedDeferDisallowed(<span class="hljs-literal">true</span>)<br>      &#125;<br>      <span class="hljs-keyword">if</span> n.Esc() != ir.EscNever &#123;<br>        <span class="hljs-comment">// If n.Esc is not EscNever, then this defer occurs in a loop,</span><br>        <span class="hljs-comment">// so open-coded defers cannot be used in this function.</span><br>        ir.CurFunc.SetOpenCodedDeferDisallowed(<span class="hljs-literal">true</span>)<br>      &#125;<br>      <span class="hljs-keyword">fallthrough</span><br>    ...<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>第一点是：当前函数中 <code>defer</code> 个数超过 8的话，则禁用开放编码。</p><p>第二点是当 <code>n.Esc() != ir.EscNever</code>使，就禁用开放编码。这个要求跟前面分析的“栈上分配”要求是一样的。</p><p>这里再补充一点：什么时候 <code>n.Esc()</code> 会被设置为<code>ir.EscNever</code> 呢？</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/imgimage-20240328192005520.png"alt="n.SetEsc(ir.EscNever)" /><figcaption aria-hidden="true">n.SetEsc(ir.EscNever)</figcaption></figure><p>这里面核心点是第一个，它对应的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *escape)</span></span> goDeferStmt(n *ir.GoDeferStmt) &#123;<br>k := e.heapHole()<br><span class="hljs-keyword">if</span> n.Op() == ir.ODEFER &amp;&amp; e.loopDepth == <span class="hljs-number">1</span> &#123;<br>...<br>n.SetEsc(ir.EscNever)<br>&#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>e.loopDepth == 1</code> 时就设置，换言之，<code>defer</code>不在循环中的时候，才允许开放编码。</p><p>总而言之，第 ① 个条件约束了要采用<code>open-coded 开放编码</code>策略的 3 个条件：</p><ol type="1"><li>函数中 <code>defer</code> 个数不能超过 <strong>8</strong>；</li><li><code>defer</code> 不能在循环中；</li><li><code>defer</code> 不能发生逃逸。</li></ol><h3 id="base.debug.noopendefer-0">② base.Debug.NoOpenDefer != 0</h3><blockquote><p>如果<code>base.Debug.NoOpenDefer</code>不为0，那么禁用开放式延迟。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">NoOpenDefer           <span class="hljs-type">int</span>    <span class="hljs-string">`help:&quot;disable open-coded defers&quot; concurrent:&quot;ok&quot;`</span><br></code></pre></td></tr></table></figure><h3id="base.ctxt.flag_shared-base.ctxt.flag_dynlink-base.ctxt.arch.name-386">③(base.Ctxt.Flag_shared || base.Ctxt.Flag_dynlink) &amp;&amp;base.Ctxt.Arch.Name == "386"</h3><blockquote><p>如果当前架构是<code>386</code>，并且使用共享库或动态链接，那么不支持开放式延迟，因为存在一些额外的代码（由<code>rewriteToUseGot()</code>添加）可能无法正确追踪。</p></blockquote><h3 id="lens.curfn.exit">④ len(s.curfn.Exit)</h3><blockquote><p>如果存在任何额外的退出代码（比如可能是竞态检测相关的代码），则跳过开放式延迟。</p></blockquote><h3 id="f.nname.ir.name.onstack">⑤ !f.Nname.(*ir.Name).OnStack()</h3><blockquote><p>如果有任何堆分配的结果参数需要复制回它们的栈槽，也跳过开放式延迟。</p></blockquote><h3 id="s.curfn.numreturnss.curfn.numdefers-15">⑥s.curfn.NumReturns*s.curfn.NumDefers &gt; 15</h3><blockquote><p>如果函数的返回数乘以延迟调用数大于<strong>15</strong>，考虑到每个退出点都要生成延迟调用，并且开放式延迟对于小函数（没有多个返回）的性能提升最为重要，所以在这种情况下也不使用开放式延迟。</p></blockquote><h2 id="堆上分配">堆上分配</h2><p>当不满足开放编码和栈上分配的时候，默认就是堆上分配（heap-allocated），性能最差，这里不做分析。</p><hr /><p>以上就是本文关于 Go 语言中 <code>defer</code> 关键字的具体分析，HappyCoding! Peace~</p><h1 id="参考">参考</h1><ul><li><a href="https://book.douban.com/subject/36403287/">深入理解 Go语言</a></li><li><a href="https://book.douban.com/subject/35556889/">Go语言底层原理剖析</a></li><li><ahref="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/">Go语言设计与实现</a></li><li>ChatGPT4</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入 Go 语言核心：结构体的全方位解析</title>
    <link href="/2024/03/09/go-struct/"/>
    <url>/2024/03/09/go-struct/</url>
    
    <content type="html"><![CDATA[<p>Go语言，作为一种高效、静态类型的编程语言，自其问世以来便以其并发处理能力和简洁的语法结构广受开发者欢迎。虽然Go不是传统意义上的面向对象语言，它却以独特的方式支持面向对象编程的核心概念，其中结构体扮演了非常关键的角色。</p><p>结构体在 Go语言中是一种复合数据类型，允许我们将不同类型的数据聚合到一起。它不仅提高了数据管理的效率和逻辑清晰度，还是Go语言中实现面向对象编程思想如封装、组合等概念的基石。了解和掌握结构体的使用，对于深入理解Go 语言的特性和编写高效、可维护的 Go 代码至关重要。</p><p>本文将带您全面深入地探索 Go语言中结构体的各个方面，从基本定义、初始化和使用，到高级特性如结构体的组合、方法定义、内存对齐等，每一个细节都将一一展开。无论您是Go语言的新手，还是有一定经验的开发者，相信本文都能为您提供有价值的见解和帮助。让我们一起探索Go结构体的奥秘，揭开其背后的原理，优化我们的代码结构，提升编程效率。</p><h1 id="版本声明">版本声明</h1><ul><li>Go 1.22.1</li><li>gopkg.in/yaml.v3 v3.0.1</li><li>os: m2max</li></ul><h1 id="全文概览">全文概览</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/go-struct.png"alt="Go 语言结构体" /><figcaption aria-hidden="true">Go 语言结构体</figcaption></figure><h1 id="结构体的基本使用">1. 结构体的基本使用</h1><h2 id="定义结构体">1.1 定义结构体</h2><p>结构体类型的定义形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>  Field T1,<br>  Field T2,<br>  ....<br>  FieldN Tn,<br>&#125;<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  Name <span class="hljs-type">string</span><br>  Age <span class="hljs-type">int</span><br>  ExtraInfo <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体内部，也可以内嵌<strong>匿名结构体</strong>，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>  Age <span class="hljs-type">int</span><br>  School <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Address <span class="hljs-type">string</span><br>    Phone <span class="hljs-type">string</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但是！注意，如果 Person 中包含了 Person 呢？</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>person  Person<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会报错：不允许引用自身。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./main.go:5:6: invalid recursive <span class="hljs-built_in">type</span>: Person refers to itself<br></code></pre></td></tr></table></figure><p>这是因为 Go语言在编译时需要知道每个类型的确切大小，以便正确地分配内存。但在这个定义中，因为<code>Person</code> 包含自身，编译器无法确定 <code>Person</code>的大小，因此会报错。</p><p>如果你需要在一个结构体中引用相同类型的数据，你应该使用指针。指针的大小是固定的，因此编译器可以确定结构体的大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  person *Person<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化结构体">1.2 初始化结构体</h2><p>假设我们有以下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name      <span class="hljs-type">string</span><br>Age       <span class="hljs-type">int</span><br>ExtraInfo <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以有以下几种初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 逐个字段赋值，顺序不重要，也可以只赋值部分字段</span><br>person1 := Person&#123;<br>  Age:       <span class="hljs-number">18</span>,<br>  Name:      <span class="hljs-string">&quot;hedon&quot;</span>,<br>  ExtraInfo: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;),<br>&#125;<br>fmt.Println(person1) <span class="hljs-comment">// &#123;hedon 18 map[]&#125;</span><br><br><span class="hljs-comment">// 可以不指定字段，严格按照顺序</span><br>person2 := Person&#123;<span class="hljs-string">&quot;hedon2&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)&#125;<br>fmt.Println(person2) <span class="hljs-comment">// &#123;hedon2 19 map[]&#125;</span><br><br><span class="hljs-comment">// 默认初始化，则结构体中的每个字段都会被默认赋予其对应类型的“零值”</span><br><span class="hljs-keyword">var</span> person3 Person<br>fmt.Println(person3)                  <span class="hljs-comment">// &#123; 0 map[]&#125;</span><br>fmt.Println(person3.ExtraInfo == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 也可以使用 new() 或 &amp; 来初始化并返回指针</span><br>person3 := <span class="hljs-built_in">new</span>(Person)<br>fmt.Println(person3)  <span class="hljs-comment">// &amp;&#123; 0 map[]&#125;</span><br></code></pre></td></tr></table></figure><h2 id="空结构体">1.3 空结构体</h2><p>有一种特殊的结构体，它一个字段都没有，我们称之为“空结构体”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>空结构体非常特殊，它不占据任何空间！你可以自己验证一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;the size of empty:&quot;</span>, unsafe.Sizeof(Empty&#123;&#125;)) <span class="hljs-comment">// the size of empty: 0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而且，所有空结构体的地址都一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">type</span> Empty1 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>e := Empty&#123;&#125;<br>e1 := Empty1&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;the address of empty: %p\n&quot;</span>, &amp;e) <span class="hljs-comment">// the address of empty: 0x10460f520</span><br>fmt.Printf(<span class="hljs-string">&quot;the address of empty1: %p\n&quot;</span>, &amp;e1)  <span class="hljs-comment">// the address of empty1: 0x10460f520</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为 Go 语言为所有大小为 0 的变量都指向了同一个值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// base address for all 0-byte allocations</span><br><span class="hljs-keyword">var</span> zerobase <span class="hljs-type">uintptr</span><br></code></pre></td></tr></table></figure><p>好处就是减少了内存的浪费。典型的用法就是我们可以使用 map 来实现Set，这样就只花费了存储键的空间，而值不占用任何空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="访问和修改结构体">1.4 访问和修改结构体</h2><ul><li>结构体属性的可见性跟 Go包的可见性规则一样：大写对包外可见，小写仅包内可见。</li><li>使用 <code>.</code> 访问和修改结构体中的属性。</li><li>Go语言中只有“<strong>值传递</strong>”，所以如果你要将结构体示例传入一个func 进行修改，则需要传入其引用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>UpdatePersonName(p)<br>fmt.Println(<span class="hljs-string">&quot;1:&quot;</span>, p)<br>UpdatePersonNameWithRef(&amp;p)<br>fmt.Println(<span class="hljs-string">&quot;2:&quot;</span>, p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdatePersonName</span><span class="hljs-params">(p Person)</span></span> &#123;<br>p.Name = <span class="hljs-string">&quot;hedon-1&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdatePersonNameWithRef</span><span class="hljs-params">(p *Person)</span></span> &#123;<br>p.Name = <span class="hljs-string">&quot;hedon-2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">1: &#123;hedon 18&#125;<br>2: &#123;hedon-2 18&#125;<br></code></pre></td></tr></table></figure><h1 id="结构体的高级特性">2. 结构体的高级特性</h1><h2 id="结构体组合">2.1 结构体组合</h2><p>在 Go语言中，倡导的是“组合优于继承”的哲学，即倡导使用组合而不是继承来实现代码的复用。该理念鼓励开发者通过组合和接口来构建灵活、可维护的代码，而不是依赖于更严格、更易出错的继承关系。这种方式促进了代码的解耦，增强了代码的灵活性和可重用性，同时也使得代码更加清晰和易于理解。</p><p>在 Go中，组合是通过将一个或多个类型（通常是结构体）嵌入到另一个结构体中来实现的。这使得嵌入的类型的方法被“提升”到包含它的结构体中，允许你调用这些方法就像它们是外部结构体的一部分一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>    Power <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Engine)</span></span> Start() &#123;<br>    <span class="hljs-comment">// 启动引擎的逻辑</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Car <span class="hljs-keyword">struct</span> &#123;<br>    Engine <span class="hljs-comment">// 通过组合的方式嵌入 Engine</span><br>&#125;<br><br><span class="hljs-comment">// 现在 Car 可以直接调用 Start 方法</span><br>car := Car&#123;Engine&#123;Power: <span class="hljs-number">100</span>&#125;&#125;<br>car.Start() <span class="hljs-comment">// 调用的是 Engine 的 Start 方法</span><br></code></pre></td></tr></table></figure><h2 id="结构体的方法">2.2 结构体的方法</h2><p>假设我们定义了一个结构体 Person：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Go 中，你可以为结构体的值或指针实现特定的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>  p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p *Person)</span></span> SetName(name <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br>  p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>这两者最核心的区别是：<strong>当你为结构体的指针类型定义方法时，该方法会在原始结构体实例上操作。这意味着方法内部对结构体的任何修改都会影响到原始结构体。</strong></p><p>所以这两段代码的输出是不一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(p.Name)   <span class="hljs-comment">// name_name</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(p.Name)  <span class="hljs-comment">// hedon</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这里我想再补充两个小点。请先思考一下下面这两段代码是否可以编译通过？如果可以输出是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;person name after set:&quot;</span>, p.Name)<br><br>pt := reflect.TypeOf(p)<br>fmt.Println(<span class="hljs-string">&quot;the number of person&#x27;s method: &quot;</span>, pt.NumMethod())<br><br>p2 := &amp;Person&#123;&#125;<br>pt = reflect.TypeOf(p2)<br>fmt.Println(<span class="hljs-string">&quot;the number of &amp;person&#x27;s method: &quot;</span>, pt.NumMethod())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;person name after set:&quot;</span>, p.Name)<br><br>pt := reflect.TypeOf(p)<br>fmt.Println(<span class="hljs-string">&quot;the number of person&#x27;s method: &quot;</span>, pt.NumMethod())<br><br>p2 := &amp;Person&#123;&#125;<br>pt = reflect.TypeOf(p2)<br>fmt.Println(<span class="hljs-string">&quot;the number of &amp;person&#x27;s method: &quot;</span>, pt.NumMethod())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显这两段代码的唯一区别就是，第一段代码我们是为<code>*Person</code> 实现了 <code>SetName</code>方法，而第二段代码我们是为 <code>Person</code> 实现了<code>SetName</code> 方法。两段代码我们都打印了调用 <code>SetName</code>后 <code>p.name</code> 的值，以及利用方式分别获取 <code>Person</code> 和<code>*Person</code> 实现的方法个数。</p><p>第一段代码的输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">person name after set: new<span class="hljs-built_in">_</span>name<br>the number of person&#x27;s method:  0<br>the number of <span class="hljs-built_in">&amp;</span>person&#x27;s method:  1<br></code></pre></td></tr></table></figure><p>第二段代码的输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">person name after set: hedon<br>the number of person&#x27;s method:  1<br>the number of <span class="hljs-built_in">&amp;</span>person&#x27;s method:  1<br></code></pre></td></tr></table></figure><p>这里我们可以得出 2 个结论：</p><p><strong>① 结构体的修改依赖于方法接收器的类型</strong>：</p><ul><li>当方法的接收器为值类型（<code>Person</code>）时，对结构体的修改不会影响原始结构体实例，因为方法作用于结构体的副本上。</li><li>当方法的接收器为指针类型（<code>*Person</code>）时，对结构体的修改会影响原始结构体实例，因为方法作用于结构体的引用上。</li></ul><p><strong>② 方法集依赖于接收器的类型</strong>：</p><ul><li>为值类型（<code>Person</code>）实现的方法，既属于值类型也属于指针类型（<code>*Person</code>）的方法集。</li><li>为指针类型（<code>*Person</code>）实现的方法，只属于指针类型的方法集。</li></ul><p>对于 ②，我们可以通过 Plan9 汇编代码一探究竟。</p><p>我们为第一段代码执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -gcflags -S main.go<br></code></pre></td></tr></table></figure><p>在输出的最上面，可以看到只有<code>main.(*Person).GetName</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"># command-line-arguments<br>main.main STEXT size=<span class="hljs-number">128</span> args=<span class="hljs-number">0x0</span> locals=<span class="hljs-number">0x48</span> funcid=<span class="hljs-number">0x0</span> align=<span class="hljs-number">0x0</span><br>        ...<br>main.(*Person).GetName STEXT size=<span class="hljs-number">16</span> args=<span class="hljs-number">0x8</span> locals=<span class="hljs-number">0x0</span> funcid=<span class="hljs-number">0x0</span> align=<span class="hljs-number">0x0</span> leaf<br>       ...<br></code></pre></td></tr></table></figure><p>我们再来为第二段代码执行相同的命令。可以在输出的最上面，看到不仅有<code>main.Person.GetName</code>，还可以发现编译器自动帮我们生成了<code>main.(*Person).GetName</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># command-line-arguments</span><br>main.main STEXT size=480 args=0x0 locals=0xe8 funcid=0x0 align=0x0<br>...<br>main.Person.SetName STEXT size=16 args=0x28 locals=0x0 funcid=0x0 align=0x0 leaf<br>   ...<br>main.(*Person).SetName STEXT dupok size=128 args=0x18 locals=0x8 funcid=0x16 align=0x0<br>...<br></code></pre></td></tr></table></figure><p>对于 ②，笔者其实有一个不太理解的地方，比如下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := &amp;Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>p.SetName(<span class="hljs-string">&quot;new_name&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;person name after set:&quot;</span>, p.Name) <span class="hljs-comment">// hedon</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.Name = name<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>p</code> 是引用类型，下面实现的是<code>Person.SetName</code>，按照我们上面的结论，编译器会自动帮我们实现<code>(*Person).SetName</code>。按照这种思路，输出 <code>new_name</code>也是解释得通的。因为既然我们声明的是一个引用类型，那么 <code>p</code>完全可以去调用自动生成的<code>(*Person).SetName</code>。但是最终的结果还是输出<code>hedon</code>，所以这里编译器自动帮我们将 <code>p</code>进行解引用，然后调用了 <code>Person.SetName</code>。</p><p>这是比较困扰笔者的一个地方，欢迎评论区讨论~</p><p>可能编译器还是更希望对于开发者来说“所见即所得”，既然开发者实现的是<code>Person.SetName</code>，那么对于开发者来说，应该就是希望不影响原始结构体的值，所以编译器还是选择遵循这种“意愿”，不乱操作。</p><h2 id="结构体比较">2.3 结构体比较</h2><p>Go 允许直接比较两个结构体实例，但有一定的限制：</p><ol type="1"><li><strong>可比较性</strong>：只有当结构体中的所有字段都是可比较的时，结构体才是可比较的。基本数据类型（如int、string 等）是可比较的，但切片、映射、函数等类型不可比较。</li><li><strong>相等性检测</strong>：当两个结构体的对应字段都相等时，这两个结构体被认为是相等的。可以使用<code>==</code> 和 <code>!=</code> 操作符来进行比较。</li></ol><p>下面这段示例，<code>p3==p4</code> 返回了<code>true</code>，这符合我们上面总结的结论。<code>p1==p2</code> 返回了<code>false</code>，因为这其实不是结构体之间的比较了，这是指针的比较了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">p1 := &amp;Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>p2 := &amp;Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>fmt.Println(p1 == p2) <span class="hljs-comment">// false</span><br>p3 := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>p4 := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>fmt.Println(p3 == p4) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>结构体的比较只支持 <code>==</code> 和 <code>!=</code>，不支持<code>&lt;</code> 和 <code>&gt;</code> 等其他运算符的比较。而 Go语言又不支持比较符重载。所以如果你要比较两个结构体的大小，那么只能自行封装类型<code>compare</code>的函数。在这我们排序结构体数组或切片的时候，经常使用到，比如我们希望按<code>Age</code> 字段从小到大排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Slice(persons, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">return</span> persons[i].Age &lt; persons[j].Age<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="结构体复制">2.4 结构体复制</h2><p>在 Go中，结构体也是值类型，这意味着当它们被赋值给新的变量或作为函数参数传递时，实际上是进行了一次深拷贝：</p><ol type="1"><li><strong>值复制</strong>：当将一个结构体赋值给一个新变量时，新变量会获得原始结构体的一个副本，它们在内存中占有不同的位置。</li><li><strong>独立性</strong>：因为是深拷贝，所以原始结构体和副本结构体是完全独立的；修改其中一个不会影响另一个。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">int</span><br>&#125;<br><br>original := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><span class="hljs-built_in">copy</span> := original<br><span class="hljs-built_in">copy</span>.X = <span class="hljs-number">3</span><br><br>fmt.Println(original) <span class="hljs-comment">// &#123;1, 2&#125;</span><br>fmt.Println(<span class="hljs-built_in">copy</span>)     <span class="hljs-comment">// &#123;3, 2&#125;</span><br></code></pre></td></tr></table></figure><h1 id="结构体与接口">3. 结构体与接口</h1><p>在 Go语言中，如果一个类型实现了接口中所有的方法，则这个类型就实现了该接口。关于接口部分的知识点，比如接口定义、多态和断言等，本文就不赘述了。</p><p>在这里我主要想从另外一个角度继续来验证前面我们总结的：<strong>为值类型（<code>Person</code>）实现的方法，既属于值类型也属于指针类型（<code>*Person</code>）的方法集</strong>。</p><p>请看这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">interface</span> &#123;<br>GetName() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Man <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m Man)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> m.Name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintPersonName</span><span class="hljs-params">(p Person)</span></span> &#123;<br>fmt.Println(p.GetName())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m1 := Man&#123;Name: <span class="hljs-string">&quot;hedon1&quot;</span>&#125;<br>PrintPersonName(m1)<br>m2 := &amp;Man&#123;Name: <span class="hljs-string">&quot;hedon2&quot;</span>&#125;<br>PrintPersonName(m2)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码我们定义了 <code>Person</code> 接口，它只有一个方法<code>GetName</code>。然后我们定义了一个结构体<code>Man</code>，并为它的值类型实现了 <code>Person</code>接口。通过我们上面的结论，这里 <code>Man</code> 和 <code>*Man</code>其实都实现了 <code>Person</code>接口，所以上面的代码是可以编译通过的。</p><p>如果改成为指针类型实现接口呢？你可以试一下~</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Man)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> m.Name<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="泛型结构体">4. 泛型结构体</h1><p>Go 语言在其 1.18版本中引入了泛型支持，这包括了对泛型结构体的支持。通过使用泛型，你可以创建更灵活和可重用的数据结构和函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Container[T any] <span class="hljs-keyword">struct</span> &#123;<br>items []T<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 Go 语言用 <code>[]</code> 来实现泛型，而不像其他语言一样用<code>&lt;&gt;</code>，真是喜欢搞特殊啊 🤡，又丑又容易跟 map 和 slice混淆。</p><h1 id="结构体的标签tag">5. 结构体的标签（Tag）</h1><p>在结构体字段后面，我们可以用 <strong>``</strong>来指定标签，这允许我们对结构体定制化一些常用操作，最经典的就是序列化与反序列化。</p><h2 id="序列化与反序列化">5.1 序列化与反序列化</h2><p>对于常见的数据结构，如<code>json</code>、<code>yaml</code>、<code>xml</code> 或<code>toml</code>，我们都可以通过在结构体中指定标签，然后使用对应解析库进行序列化和反序列化。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>&#125;<br>bs, _ := json.Marshal(p) <span class="hljs-comment">// 序列化</span><br>fmt.Println(<span class="hljs-type">string</span>(bs))  <span class="hljs-comment">// &#123;&quot;name&quot;:&quot;hedon&quot;,&quot;age&quot;:18&#125;</span><br>newP := Person&#123;&#125;<br>_ = json.Unmarshal(bs, &amp;newP) <span class="hljs-comment">// 反序列化</span><br>fmt.Println(newP)             <span class="hljs-comment">// &#123;hedon 18&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在笔者的实践过程中，在结构体组合的场景下，不同数据格式的解析会有一些小差别，这在实战过程中你需要重点关注和验证。比如<code>json</code> 和 <code>yaml</code> 就会有一些不同。</p><p>比如说我这里定义了下面 2 个结构体，其中 <code>Person</code> 组合了<code>School</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot; yaml:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot; yaml:&quot;age&quot;`</span><br>School<br>&#125;<br><br><span class="hljs-keyword">type</span> School <span class="hljs-keyword">struct</span> &#123;<br>SchoolName    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;school_name&quot; yaml:&quot;school_name&quot;`</span><br>SchoolAddress <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;school_address&quot; json:&quot;school_address&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它们都加上了 <code>json</code> 和 <code>yaml</code> 标签，对于<code>json</code> 类型，你可以用标准库的 <code>encoding/json</code>来进行序列化和反序列化，而 <code>yaml</code> 你可以使用第三方库：<ahref="https://github.com/go-yaml/yaml">go-yaml</a>。</p><p>先来看系列化结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>, Age: <span class="hljs-number">18</span>, School: School&#123;SchoolName: <span class="hljs-string">&quot;nb_school&quot;</span>, SchoolAddress: <span class="hljs-string">&quot;a_good_school_place&quot;</span>&#125;&#125;<br>bs, _ := json.Marshal(p)<br>fmt.Println(<span class="hljs-string">&quot;json:\n&quot;</span>, <span class="hljs-type">string</span>(bs))<br>bs, _ = yaml.Marshal(p)<br>fmt.Println(<span class="hljs-string">&quot;yaml:\n&quot;</span>, <span class="hljs-type">string</span>(bs))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">json:<br> &#123;&quot;name&quot;:&quot;hedon&quot;,&quot;age&quot;:18,&quot;school<span class="hljs-built_in">_</span>name&quot;:&quot;nb<span class="hljs-built_in">_</span>school&quot;,&quot;school<span class="hljs-built_in">_</span>address&quot;:&quot;a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>school<span class="hljs-built_in">_</span>place&quot;&#125;<br>yaml:<br> name: hedon<br> age: 18<br> school:<br>    school<span class="hljs-built_in">_</span>name: nb<span class="hljs-built_in">_</span>school<br>    school<span class="hljs-built_in">_</span>address: a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>school<span class="hljs-built_in">_</span>place<br></code></pre></td></tr></table></figure><p>通过观察你可以发现哈，在 <code>json</code> 中，组合的时候（没有给School 加标签）直接将 <code>School</code> 平铺在 <code>Person</code>中，所以在序列化的结果中，找不到 <code>"school": &#123;&#125;</code>。而在<code>yaml</code> 中，并不是直接平铺的。</p><p>这个区别在你解析配置文件的时候尤其重要，如果不注意，那么可能会导致配置解析失败。</p><p>我准备了 4 个配置文件，分别是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// person1.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon_json&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;school_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nb_json_school&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;school_address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_good_place_in_json&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># person1.yaml</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;hedon_yaml&quot;</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">school:</span><br>  <span class="hljs-attr">school_name:</span> <span class="hljs-string">&quot;nb_yaml_school&quot;</span><br>  <span class="hljs-attr">school_address:</span> <span class="hljs-string">&quot;a_good_price_in_yaml&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// person2.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hedon_json&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nb_json_school&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;school_address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a_good_place_in_json&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># person2.yaml</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;hedon_yaml&quot;</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br><span class="hljs-attr">school_name:</span> <span class="hljs-string">&quot;nb_yaml_school&quot;</span><br><span class="hljs-attr">school_address:</span> <span class="hljs-string">&quot;a_good_price_in_yaml&quot;</span><br></code></pre></td></tr></table></figure><p>解析代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filenames := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;person1.json&quot;</span>, <span class="hljs-string">&quot;person1.yaml&quot;</span>, <span class="hljs-string">&quot;person2.json&quot;</span>, <span class="hljs-string">&quot;person2.yaml&quot;</span>&#125;<br><span class="hljs-keyword">for</span> i, fn := <span class="hljs-keyword">range</span> filenames &#123;<br>bs := readFileIntoBytes(fn)<br>p := Person&#123;&#125;<br><span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>_ = json.Unmarshal(bs, &amp;p)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>_ = yaml.Unmarshal(bs, &amp;p)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s -&gt; %v\n&quot;</span>, fn, p)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFileIntoBytes</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">byte</span> &#123;<br>f, err := os.Open(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>bs, _ := io.ReadAll(f)<br><span class="hljs-keyword">return</span> bs<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">person1.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123; &#125;&#125;<br>person1.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123;nb<span class="hljs-built_in">_</span>yaml<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>price<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>yaml&#125;&#125;<br>person2.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123;nb<span class="hljs-built_in">_</span>json<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>place<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>json&#125;&#125;<br>person2.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123; &#125;&#125;<br></code></pre></td></tr></table></figure><p>如果给 <code>School</code> 字段加上 <code>json tag</code>的话，结果又是不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot; yaml:&quot;name&quot;`</span><br>Age    <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot; yaml:&quot;age&quot;`</span><br>School <span class="hljs-string">`json:&quot;school&quot; yaml:&quot;school&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">person1.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123;nb<span class="hljs-built_in">_</span>json<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>place<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>json&#125;&#125;<br>person1.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123;nb<span class="hljs-built_in">_</span>yaml<span class="hljs-built_in">_</span>school a<span class="hljs-built_in">_</span>good<span class="hljs-built_in">_</span>price<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>yaml&#125;&#125;<br>person2.json -&gt; &#123;hedon<span class="hljs-built_in">_</span>json 18 &#123; &#125;&#125;<br>person2.yaml -&gt; &#123;hedon<span class="hljs-built_in">_</span>yaml 18 &#123; &#125;&#125;<br></code></pre></td></tr></table></figure><p>可以看到受影响的只有 <code>json</code>。</p><p>到这里我们可以总结：<strong>在组合场景下，如果不明确指定<code>tag</code>，<code>yaml</code> 解析期望字段是嵌套的，而<code>json</code> 解析期望字段是平铺的</strong>。</p><h2 id="自定义-tag">5.2 自定义 Tag</h2><p>在 Go中，你可以为结构体字段定义任意的标签。这些标签在编译时会被存储，并且可以在运行时通过反射（reflection）来访问。</p><p>假设我们定义一个名为 <code>check</code>的标签，它用于我们对结构体字段的检查，假设我们这个标签支持以下功能：</p><ul><li><code>check:"strnoempty"</code>: 字符串不可以为空。</li></ul><p>假如加入 <code>check</code> 标签的 <code>Person</code>结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`check:&quot;strnoempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来为 <code>check</code> 实现解析函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckPerson</span><span class="hljs-params">(p Person)</span></span> <span class="hljs-type">error</span> &#123;<br>pt := reflect.TypeOf(p)<br>pv := reflect.ValueOf(p)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; pt.NumField(); i++ &#123;<br>field := pt.Field(i)<br>tagValue := field.Tag.Get(<span class="hljs-string">&quot;check&quot;</span>)<br><span class="hljs-keyword">if</span> tagValue == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> field.Type.Kind() == reflect.String &amp;&amp; tagValue == <span class="hljs-string">&quot;strnoempty&quot;</span> &#123;<br><span class="hljs-keyword">if</span> err := checkStrNoEmpty(field.Name, pv.Field(i).Interface()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkStrNoEmpty</span><span class="hljs-params">(fieldName <span class="hljs-type">string</span>, v any)</span></span> <span class="hljs-type">error</span> &#123;<br>s, ok := v.(<span class="hljs-type">string</span>)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%v is not string&quot;</span>, v)<br>&#125;<br><span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;[check] %s should not be empty&quot;</span>, fieldName)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p1 := Person&#123;&#125;<br>p2 := Person&#123;Name: <span class="hljs-string">&quot;hedon&quot;</span>&#125;<br>fmt.Println(CheckPerson(p1)) <span class="hljs-comment">// [check] Name should not be empty</span><br>fmt.Println(CheckPerson(p2)) <span class="hljs-comment">// &lt;nil&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结构体内存对齐">6. 结构体内存对齐</h1><p>在本小节中，我们将探讨 Go 语言结构体的内存结构和对齐策略。</p><h2 id="问题引出">6.1 问题引出</h2><p>思考下面这段代码的输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num2 <span class="hljs-type">int8</span><br>num1 <span class="hljs-type">int16</span><br>flag <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S2 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int8</span><br>flag <span class="hljs-type">bool</span><br>num2 <span class="hljs-type">int16</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(unsafe.Sizeof(S1&#123;&#125;))<br>fmt.Println(unsafe.Sizeof(S2&#123;&#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么仅是字段顺序不同，<code>S1&#123;&#125;</code> 和 <code>S2&#123;&#125;</code>的大小就不一样了？</p><p>我们可以写个简单的程序来输出 <code>S1</code> 和 <code>S2</code>的内存结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := S1&#123;&#125;<br>s2 := S2&#123;&#125;<br>fmt.Print(<span class="hljs-string">&quot;s1: &quot;</span>)<br>printMemory(s1)<br>fmt.Print(<span class="hljs-string">&quot;s2: &quot;</span>)<br>printMemory(s2)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMemory</span><span class="hljs-params">(a any)</span></span> &#123;<br>t := reflect.TypeOf(a)<br>mem := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>(t.Size()))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>field := t.Field(i)<br>offset := <span class="hljs-type">int</span>(field.Offset)<br>size := <span class="hljs-type">int</span>(field.Type.Size())<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; size; j++ &#123;<br>mem[j+offset] = i + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>fmt.Println(mem)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s1: [<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span>]<br>s2: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>其中 <code>1</code>、<code>2</code>、<code>3</code>分别替代结构体中的第 1/2/3 个字段所占用的内存。这里可以看到<code>s1</code> 的长度是 6 字节，而 <code>s2</code> 是 4 字节。这里<code>s1</code> 比 <code>s2</code> 多出的 2 个字节就是这两个填充的<code>0</code>。这而 2个字节的填充，就是为了<strong>内存对齐</strong>。</p><h2 id="内存对齐">6.2 内存对齐</h2><p>如上分析，<code>s1</code> 的内存结构如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310154903219.png"alt="s1 内存结构" /><figcaption aria-hidden="true">s1 内存结构</figcaption></figure><p>如果没有内存对齐呢？<code>s1</code> 的结构可能如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310155353882.png"alt="没有内存对齐的 s1 内存结构" /><figcaption aria-hidden="true">没有内存对齐的 s1 内存结构</figcaption></figure><p>如果是 16 位系统的话，那么没有内存对齐的情况下，要访问<code>s1.num2</code> 字段，就需要跨过 2个系统字长的内存，效率就低了。具体来说，内存对齐是计算机内存分配的一种优化方式，用于确保数据结构的存储按照特定的字节边界对齐。这种对齐是为了提高计算机处理数据的效率。</p><h2 id="对齐系数">6.3 对齐系数</h2><ul><li>对齐系数：变量的内存地址必须被对齐系数整除。</li><li><code>unsafe.Alignof()</code>: 可以查看值在内存中的对齐系数。</li></ul><h2 id="基本类型对齐">6.4 基本类型对齐</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;bool size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">bool</span>(<span class="hljs-literal">true</span>)), unsafe.Alignof(<span class="hljs-type">bool</span>(<span class="hljs-literal">true</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;byte size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">byte</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">byte</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int8 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int8</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int8</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int16 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int16</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int16</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int32 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int32</span>(<span class="hljs-number">0</span>)))<br>fmt.Printf(<span class="hljs-string">&quot;int64 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(<span class="hljs-type">int64</span>(<span class="hljs-number">0</span>)), unsafe.Alignof(<span class="hljs-type">int64</span>(<span class="hljs-number">0</span>)))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">bool</span> size: <span class="hljs-number">1</span>, align: <span class="hljs-number">1</span><br><span class="hljs-type">byte</span> size: <span class="hljs-number">1</span>, align: <span class="hljs-number">1</span><br><span class="hljs-type">int8</span> size: <span class="hljs-number">1</span>, align: <span class="hljs-number">1</span><br><span class="hljs-type">int16</span> size: <span class="hljs-number">2</span>, align: <span class="hljs-number">2</span><br><span class="hljs-type">int32</span> size: <span class="hljs-number">4</span>, align: <span class="hljs-number">4</span><br><span class="hljs-type">int64</span> size: <span class="hljs-number">8</span>, align: <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>结论：基本类型的对齐系数跟它的长度一致。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310160412598.png"alt="基本类型内存对齐" /><figcaption aria-hidden="true">基本类型内存对齐</figcaption></figure><h2 id="结构体内部对齐">6.5 结构体内部对齐</h2><p>结构体内存对齐分为内部对齐和结构体之间对齐。</p><p>我们先来看结构体内部对齐：</p><ul><li>指的是结构体内部成员的相对位置（偏移量）；</li><li>每个成员的偏移量是 <strong>自身大小</strong> 和<strong>对齐系数</strong> 的较小值的倍数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br>  a <span class="hljs-type">bool</span><br>  b <span class="hljs-type">string</span><br>  c <span class="hljs-type">int16</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假如我们定义了上面的结构体 <code>Demo</code>，如果在 64位系统上（字长为 8 字节）通过上面的规则，可以判断出：（单位为字节）</p><ul><li>a: size=1, align=1</li><li>b: size=16, align=8</li><li>c: size=2, align=2</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310163126556.png"alt="Demo 内存结构" /><figcaption aria-hidden="true">Demo 内存结构</figcaption></figure><p>当然我们也可以通过程序输出来验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Demo <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">bool</span>   <span class="hljs-comment">// size=1, align=1</span><br>b <span class="hljs-type">string</span> <span class="hljs-comment">// size=16, align=8</span><br>c <span class="hljs-type">int16</span>  <span class="hljs-comment">// size=2, align=2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>d := Demo&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(d.a), unsafe.Alignof(d.a))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(d.b), unsafe.Alignof(d.b))<br>fmt.Printf(<span class="hljs-string">&quot;c: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(d.c), unsafe.Alignof(d.c))<br>printMemory(d)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMemory</span><span class="hljs-params">(a any)</span></span> &#123;<br>t := reflect.TypeOf(a)<br>mem := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>(t.Size()))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>field := t.Field(i)<br>offset := <span class="hljs-type">int</span>(field.Offset)<br>size := <span class="hljs-type">int</span>(field.Type.Size())<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; size; j++ &#123;<br>mem[j+offset] = i + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>fmt.Println(mem)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>c: size=<span class="hljs-number">2</span>, align=<span class="hljs-number">2</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="结构体长度填充">6.6 结构体长度填充</h2><p>上面 Demo 结构体最后还填了 6 个字节的 0，这就是结构体长度填充：</p><ul><li>结构体通过填充长度，来对齐系统字长。</li><li>结构体长度是 <strong>最大成员长度</strong> 和<strong>系统字长</strong> 较小值的整数倍。</li></ul><p>我的系统环境是 m2max，系统字长是 8 字节，Demo 最大成员长度是<code>b string</code>，即 16 个字节，所以 <code>Demo</code> 的长度应该是<code>8</code> 的倍数，所以最后填充了 6 个字节的 0。</p><h2 id="结构体之间对齐">6.7 结构体之间对齐</h2><ul><li>结构体之间对齐，是为了确定结构体的第一个成员变量的内存地址，以让后面的成员地址都合法。</li><li>结构体的对齐系数是 <strong>其成员的最大对齐系数</strong>；</li></ul><h2 id="空结构体对齐">6.8 空结构体对齐</h2><p>前面我们专门讨论了空结构体<code>struct&#123;&#125;</code>，它们的内存地址统一指向<code>zerobase</code>，而且内存长度为0。这也导致了它的内存对齐规则，有一些不同。具体可以分为以下 4个情况。</p><h3 id="空结构体单独存在">6.8.1 空结构体单独存在</h3><p>空结构体单独存在时，其内存地址为<code>zerobase</code>，不额外分配内存。</p><h3 id="空结构体在结构体最前">6.8.2 空结构体在结构体最前</h3><p>空结构体是结构体第一个字段时，它的地址跟结构体本身及结构体第 2个字段一样，不占据内存空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestEmpty <span class="hljs-keyword">struct</span> &#123;<br>empty <span class="hljs-keyword">struct</span>&#123;&#125;<br>a     <span class="hljs-type">bool</span><br>b     <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>te := TestEmpty&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;address of te: %p\n&quot;</span>, &amp;te)<br>fmt.Printf(<span class="hljs-string">&quot;address of te.empty: %p\n&quot;</span>, &amp;(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;address of te.a: %p\n&quot;</span>, &amp;(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;empty: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.empty), unsafe.Alignof(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.a), unsafe.Alignof(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.b), unsafe.Alignof(te.b))<br>printMemory(te)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">address of te: <span class="hljs-number">0x140000ba000</span><br>address of te.empty: <span class="hljs-number">0x140000ba000</span><br>address of te.a: <span class="hljs-number">0x140000ba000</span><br>empty: size=<span class="hljs-number">0</span>, align=<span class="hljs-number">1</span><br>a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>[<span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="空结构体在结构体中间">6.8.3 空结构体在结构体中间</h3><p>空结构体出现在结构体中时，地址跟随前一个变量。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310165025700.png"alt="空结构体在结构体中间内存对齐" /><figcaption aria-hidden="true">空结构体在结构体中间内存对齐</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestEmpty <span class="hljs-keyword">struct</span> &#123;<br>a     <span class="hljs-type">bool</span><br>empty <span class="hljs-keyword">struct</span>&#123;&#125;<br>b     <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>te := TestEmpty&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;address of te: %p\n&quot;</span>, &amp;te)<br>fmt.Printf(<span class="hljs-string">&quot;address of te.a: %p\n&quot;</span>, &amp;(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;address of te.empty: %p\n&quot;</span>, &amp;(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.a), unsafe.Alignof(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;empty: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.empty), unsafe.Alignof(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.b), unsafe.Alignof(te.b))<br>printMemory(te)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">address of te: <span class="hljs-number">0x14000128000</span><br>address of te.a: <span class="hljs-number">0x14000128000</span><br>address of te.empty: <span class="hljs-number">0x14000128001</span><br>a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>empty: size=<span class="hljs-number">0</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="空结构体在结构体最后">6.8.4 空结构体在结构体最后</h3><p>空结构体出现在结构体最后，如果开启了一个新的系统字长，则需要补零，防止与其他结构体混用地址。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240310164933867.png"alt="空结构体在结构体最后内存对齐" /><figcaption aria-hidden="true">空结构体在结构体最后内存对齐</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TestEmpty <span class="hljs-keyword">struct</span> &#123;<br>a     <span class="hljs-type">bool</span><br>b     <span class="hljs-type">string</span><br>empty <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>te := TestEmpty&#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;address of te: %p\n&quot;</span>, &amp;te)<br>fmt.Printf(<span class="hljs-string">&quot;address of te.a: %p\n&quot;</span>, &amp;(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;address of te.empty: %p\n&quot;</span>, &amp;(te.empty))<br>fmt.Printf(<span class="hljs-string">&quot;a: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.a), unsafe.Alignof(te.a))<br>fmt.Printf(<span class="hljs-string">&quot;b: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.b), unsafe.Alignof(te.b))<br>fmt.Printf(<span class="hljs-string">&quot;empty: size=%d, align=%d\n&quot;</span>, unsafe.Sizeof(te.empty), unsafe.Alignof(te.empty))<br>printMemory(te)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">address of te: <span class="hljs-number">0x1400006a020</span><br>address of te.a: <span class="hljs-number">0x1400006a020</span><br>address of te.empty: <span class="hljs-number">0x1400006a038</span><br>a: size=<span class="hljs-number">1</span>, align=<span class="hljs-number">1</span><br>b: size=<span class="hljs-number">16</span>, align=<span class="hljs-number">8</span><br>empty: size=<span class="hljs-number">0</span>, align=<span class="hljs-number">1</span><br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="使用-fieldalignment--fix-工具优化结构体内存对齐">6.9 使用fieldalignment -fix 工具优化结构体内存对齐</h2><p>还记得我们最开始提出的问题吗？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num2 <span class="hljs-type">int8</span><br>num1 <span class="hljs-type">int16</span><br>flag <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S2 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int8</span><br>flag <span class="hljs-type">bool</span><br>num2 <span class="hljs-type">int16</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(unsafe.Sizeof(S1&#123;&#125;))<br>fmt.Println(unsafe.Sizeof(S2&#123;&#125;))<br>&#125;<br></code></pre></td></tr></table></figure><p><code>S1</code> 和 <code>S2</code> 提供的程序功能是一样的，但是<code>S1</code> 却比 <code>S2</code>花费了更多的内存空间。所以有时候我们可以通过仅仅调整结构体内部字段的顺序就减少不少的内存空间消耗。在这个时候<code>fieldalignment</code> 可以帮助我们自动检测并优化。</p><p>你可以运行下面命令安装 <code>fieldalignment</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest<br></code></pre></td></tr></table></figure><p>然后在项目根目录下运行下面命令，对我们的代码进行检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go vet -vettool=$(<span class="hljs-built_in">which</span> fieldalignment) ./...<br></code></pre></td></tr></table></figure><p>这里会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./main.go:9:9: struct of size 6 could be 4<br></code></pre></td></tr></table></figure><p>这个时候可以执行 <code>fieldalignment -fix 目录|文件</code>，它会自动帮我们的代码进行修复，但是<strong>强烈建议你在运行之前，备份你的代码，因为注释会被删除！</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fieldalignment -fix ./...<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">/Users/hedon/GolandProjects/learn-<span class="hljs-keyword">go</span>-<span class="hljs-keyword">struct</span>/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>:<span class="hljs-number">9</span>: <span class="hljs-keyword">struct</span> of size <span class="hljs-number">6</span> could be <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>这个时候 <code>S1</code> 已经被优化好了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>num1 <span class="hljs-type">int16</span><br>num2 <span class="hljs-type">int8</span><br>flag <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 实战丨HTTPie</title>
    <link href="/2024/03/06/rust-action-httpie/"/>
    <url>/2024/03/06/rust-action-httpie/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>之前学习过《陈天·Rust 编程第一课 - 04｜get hands dirty：来写个实用的CLI 小工具》，学的时候迷迷糊糊。后来在系统学习完 Rust后，重新回过头来看这个实战小案例，基本上都能掌握，并且有了一些新的理解。所以我决定以一个Rust 初学者的角度，并以最新版本的 Rust（1.7.6）和clap（4.5.1）来重新实现这个案例，期望能对 Rust感兴趣的初学者提供一些帮助。</p><p>本文将实现的应用叫 HTTPie，HTTPie 是一个用 Python 编写的命令行 HTTP客户端，其目标是使 CLI 与 web 服务的交互尽可能愉快。它被设计为一个<code>curl</code> 和 <code>wget</code>的替代品，提供易于使用的界面和一些用户友好的功能，如 JSON支持、语法高亮和插件。它对于测试、调试和通常与 HTTP 服务器或 RESTful API进行交云的开发人员来说非常有用。</p><p>HTTPie 的一些关键特性包括：</p><ol type="1"><li><strong>JSON 支持</strong>：默认情况下，HTTPie 会自动发送JSON，并且可以轻松地通过命令行发送 JSON 请求体。</li><li><strong>语法高亮</strong>：它会为 HTTP响应输出提供语法高亮显示，使得结果更加易于阅读。</li><li><strong>插件</strong>：HTTPie 支持插件，允许扩展其核心功能。</li><li><strong>表单和文件上传</strong>：可以很容易地通过表单上传文件。</li><li><strong>自定义 HTTP 方法和头部</strong>：可以发送任何 HTTP方法的请求，自定义请求头部。</li><li><strong>HTTPS、代理和身份验证支持</strong>：支持 HTTPS请求、使用代理以及多种 HTTP 身份验证机制。</li><li><strong>流式上传和下载</strong>：支持大文件的流式上传和下载。</li><li><strong>会话支持</strong>：可以保存和重用常用的请求和集合。</li></ol><p>本文我们将实现其中的 <code>1</code>、<code>2</code> 和<code>5</code>。我们会支持发送 GET 和 POST 请求，其中 POST支持设置请求头和 JSON 数据。</p><p>在本文中，你可以学习到：</p><ul><li>如何用 <code>clap</code> 解析命令行参数。</li><li>如何用 <code>tokio</code> 进行异步编程。</li><li>如何用 <code>reqwest</code> 发送 HTTP 请求。</li><li>如何用 <code>colored</code> 在终端输出带颜色的内容。</li><li>如何用 <code>jsonxf</code> 美化 json 字符串。</li><li>如何用 <code>anyhow</code> 配合 <code>?</code> 进行错误传播。</li><li>如何使用 <code>HTTPie</code> 来进行 HTTP 接口测试。</li></ul><p>在进行实际开发之前，推荐你先了解一下：</p><ul><li><a href="https://hedon.top/2024/03/02/rust-crate-reqwest/">Rustreqwest 简明教程</a></li><li><a href="https://hedon.top/2024/03/05/rust-crate-anyhow/">Rustanyhow 简明教程</a></li><li><a href="https://hedon.top/2024/03/02/rust-crate-clap/">深入探索Rust 的 clap 库：命令行解析的艺术</a></li></ul><p>本文完整代码：<ahref="https://github.com/hedon954/httpie">hedon954/httpie</a></p><h1 id="开发思路">开发思路</h1><h2 id="http-协议">HTTP 协议</h2><p>回顾一下 HTTP 协议的请求体和响应体结构。</p><p>请求结构：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240303131157545.png"alt="http request structure" /><figcaption aria-hidden="true">http request structure</figcaption></figure><p>响应结构：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240303131123618.png"alt="http response structure" /><figcaption aria-hidden="true">http response structure</figcaption></figure><h2 id="命令分析">命令分析</h2><p>在本文中，我们就实现 HTTPie cli 官方的这个<ahref="https://github.com/httpie/cli?tab=readme-ov-file#examples">示例</a>：即允许指定请求方法、携带headers 和 json 数据发送请求。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240303131445159.png"alt="HTTPie 官方示例" /><figcaption aria-hidden="true">HTTPie 官方示例</figcaption></figure><p>我们来拆解一下，这个命令可以分为以下几个部分：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">httpie &lt;METHOD&gt; &lt;URL&gt; [headers | params]...<br></code></pre></td></tr></table></figure><ul><li><code>&lt;METHOD&gt;</code>: 请求方法，本案例中，我们仅支持 GET 和POST。</li><li><code>&lt;URL&gt;</code>: 请求地址。</li><li><code>&lt;HEADERS&gt;</code>: 请求头，格式为<code>h1:v1</code>。</li><li><code>&lt;PARAMS&gt;</code>: 请求参数，格式为<code>k1=v1</code>，最终以 json 结构发送。</li></ul><h2 id="效果展示">效果展示</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  httpie git:(master) ✗ ./Httpie --<span class="hljs-built_in">help</span>                                              <br>Usage: Httpie &lt;COMMAND&gt;<br><br>Commands:<br>  get   <br>  post  <br>  <span class="hljs-built_in">help</span>  Print this message or the <span class="hljs-built_in">help</span> of the given subcommand(s)<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br></code></pre></td></tr></table></figure><p>其中 post 子命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: Httpie post &lt;URL&gt; &lt;BODY&gt;...<br><br>Arguments:<br>  &lt;URL&gt;      Specify the url you wanna request to<br>  &lt;BODY&gt;...  Set the request body. Examples: headers: header1:value1 params: key1=value1<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>  Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>请求示例：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240305225846224.png"alt="httpie response demo" /><figcaption aria-hidden="true">httpie response demo</figcaption></figure><h2 id="思路梳理">思路梳理</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240306223319742.png"alt="httpie 开发思路梳理" /><figcaption aria-hidden="true">httpie 开发思路梳理</figcaption></figure><p><strong>第 1 步：解析命令行参数</strong></p><p>本案例中 httpie 支持 2 个子命令：</p><ul><li>get 支持 url 参数</li><li>post 支持 url、body 参数，因为其中 headers 和 params是变长的，我们统一用 <code>Vec&lt;String&gt;</code> 类型的 body来接收，然后用 <code>:</code> 和 <code>=</code> 来区分它们。</li></ul><p><strong>第 2 步：发送请求</strong></p><ol type="1"><li>使用 reqwest 创建 http client；</li><li>设置 url；</li><li>设置 method；</li><li>设置 headers；</li><li>设置 params；</li><li>发送请求；</li><li>获取响应体。</li></ol><p><strong>第 3 步：打印响应</strong></p><ol type="1"><li>打印 http version 和 status，并使用 colored 赋予蓝色；</li><li>打印 response headers，并使用 colored 赋予绿色；</li><li>确定 content-type，如果是 json，我们就用 jsonxf 美化 json 串并使用colored 赋予蓝绿色输出，如果是其他类型，这里我们就输出原文即可。</li></ol><h1 id="实战过程">实战过程</h1><h2 id="创建项目">1. 创建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new httpie<br></code></pre></td></tr></table></figure><h2 id="添加依赖">2. 添加依赖</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;httpie&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">anyhow</span> = <span class="hljs-string">&quot;1.0.80&quot;</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.1&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;<br><span class="hljs-attr">colored</span> = <span class="hljs-string">&quot;2.1.0&quot;</span><br><span class="hljs-attr">jsonxf</span> = <span class="hljs-string">&quot;1.1.1&quot;</span><br><span class="hljs-attr">mime</span> = <span class="hljs-string">&quot;0.3.17&quot;</span><br><span class="hljs-attr">reqwest</span> = &#123; version = <span class="hljs-string">&quot;0.11.24&quot;</span>, features = [<span class="hljs-string">&quot;json&quot;</span>] &#125;<br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1.36.0&quot;</span>, features = [<span class="hljs-string">&quot;rt&quot;</span>, <span class="hljs-string">&quot;rt-multi-thread&quot;</span>, <span class="hljs-string">&quot;macros&quot;</span>] &#125;<br></code></pre></td></tr></table></figure><ul><li><code>anyhow</code>: 用于简化异常处理。</li><li><code>clap</code>: 解析命令行参数。</li><li><code>colored</code>: 为终端输出内容赋予颜色。</li><li><code>jsonxf</code>: 美化 json 串。</li><li><code>mime</code>: 提供了各种 Media Type 的类型封装。</li><li><code>reqwest</code>: http 客户端。</li><li><code>tokio</code>: 异步库，本案例种我们使用 reqwest的异步功能。</li></ul><h2 id="完整源码">3. 完整源码</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// src/main.rs  为减小篇幅，省略了单元测试，读者可自行补充。</span><br><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">use</span> reqwest::&#123;Client, header, Response&#125;;<br><span class="hljs-keyword">use</span> std::<span class="hljs-type">str</span>::FromStr;<br><span class="hljs-keyword">use</span> anyhow::anyhow;<br><span class="hljs-keyword">use</span> clap::&#123;Args, Parser, Subcommand&#125;;<br><span class="hljs-keyword">use</span> colored::Colorize;<br><span class="hljs-keyword">use</span> mime::Mime;<br><span class="hljs-keyword">use</span> reqwest::header::&#123;HeaderMap, HeaderName, HeaderValue&#125;;<br><span class="hljs-keyword">use</span> reqwest::Url;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Httpie</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    methods: Method,<br>&#125;<br><br><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-title function_ invoke__">Get</span>(Get),<br>    <span class="hljs-title function_ invoke__">Post</span>(Post)<br>&#125;<br><br><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Get</span> &#123;<br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-comment">/// Specify the url you wanna request to.</span><br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-comment">/// Set the request body.</span><br>    <span class="hljs-comment">/// Examples:</span><br>    <span class="hljs-comment">///     headers:</span><br>    <span class="hljs-comment">///         header1:value1</span><br>    <span class="hljs-comment">///     params:</span><br>    <span class="hljs-comment">///         key1=value1</span><br>    <span class="hljs-meta">#[arg(required = true, value_parser = parse_kv_pairs)]</span><br>    body: <span class="hljs-type">Vec</span>&lt;KvPair&gt;<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    k: <span class="hljs-type">String</span>,<br>    v: <span class="hljs-type">String</span>,<br>    t: KvPairType,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug,Clone)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">KvPairType</span> &#123;<br>    Header,<br>    Param,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">FromStr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Err</span> = anyhow::Error;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_str</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::<span class="hljs-literal">Err</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pair_type</span>: KvPairType;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">split_char</span> = <span class="hljs-keyword">if</span> s.<span class="hljs-title function_ invoke__">contains</span>(<span class="hljs-string">&#x27;:&#x27;</span>) &#123;<br>            pair_type = KvPairType::Header;<br>            <span class="hljs-string">&#x27;:&#x27;</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pair_type = KvPairType::Param;<br>            <span class="hljs-string">&#x27;=&#x27;</span><br>        &#125;;<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">split</span> = s.<span class="hljs-title function_ invoke__">split</span>(split_char);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">err</span> = || anyhow!(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;failed to parse pairs &#123;&#125;&quot;</span>,s));<br>        <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-keyword">Self</span> &#123;<br>            k: (split.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">ok_or_else</span>(err)?).<span class="hljs-title function_ invoke__">to_string</span>(),<br>            v: (split.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">ok_or_else</span>(err)?).<span class="hljs-title function_ invoke__">to_string</span>(),<br>            t: pair_type,<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_url</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_url</span>: Url = s.<span class="hljs-title function_ invoke__">parse</span>()?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">into</span>())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_kv_pairs</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;KvPair&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">parse</span>()?)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(client: Client, args: &amp;Get) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">resp</span> = client.<span class="hljs-title function_ invoke__">get</span>(&amp;args.url).<span class="hljs-title function_ invoke__">send</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">print_resp</span>(resp).<span class="hljs-keyword">await</span>?)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">post</span>(client: Client, args: &amp;Post) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">body</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">header_map</span> = HeaderMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">pair</span> <span class="hljs-keyword">in</span> args.body.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">match</span> pair.t &#123;<br>            KvPairType::Param =&gt;  &#123;body.<span class="hljs-title function_ invoke__">insert</span>(&amp;pair.k, &amp;pair.v);&#125;<br>            KvPairType::Header =&gt; &#123;<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(name) = HeaderName::<span class="hljs-title function_ invoke__">from_str</span>(pair.k.<span class="hljs-title function_ invoke__">as_str</span>()) &#123;<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(value) = HeaderValue::<span class="hljs-title function_ invoke__">from_str</span>(pair.v.<span class="hljs-title function_ invoke__">as_str</span>()) &#123;<br>                        header_map.<span class="hljs-title function_ invoke__">insert</span>(name,value);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Invalid header value for key: &#123;&#125;&quot;</span>, pair.v);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Invalid header key: &#123;&#125;&quot;</span>, pair.k);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">resp</span> = client.<span class="hljs-title function_ invoke__">post</span>(&amp;args.url)<br>        .<span class="hljs-title function_ invoke__">headers</span>(header_map)<br>        .<span class="hljs-title function_ invoke__">json</span>(&amp;body).<span class="hljs-title function_ invoke__">send</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-title function_ invoke__">print_resp</span>(resp).<span class="hljs-keyword">await</span>?)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_resp</span>(resp: Response) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-title function_ invoke__">print_status</span>(&amp;resp);<br>    <span class="hljs-title function_ invoke__">print_headers</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mime</span> = <span class="hljs-title function_ invoke__">get_content_type</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = resp.<span class="hljs-title function_ invoke__">text</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">print_body</span>(mime, &amp;body);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_status</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">status</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;:?&#125; &#123;&#125;&quot;</span>, resp.<span class="hljs-title function_ invoke__">version</span>(), resp.<span class="hljs-title function_ invoke__">status</span>()).<span class="hljs-title function_ invoke__">blue</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>, status);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_headers</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">for</span> (k,v) <span class="hljs-keyword">in</span> resp.<span class="hljs-title function_ invoke__">headers</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, k.<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">green</span>(), v);<br>    &#125;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_body</span>(mime: <span class="hljs-type">Option</span>&lt;Mime&gt;, resp: &amp;<span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-keyword">match</span> mime &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(v) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> v == mime::APPLICATION_JSON &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, jsonxf::<span class="hljs-title function_ invoke__">pretty_print</span>(resp).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">cyan</span>())<br>            &#125;<br>        &#125;<br>        _ =&gt; <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, resp),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_content_type</span>(resp: &amp;Response) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Mime&gt; &#123;<br>    resp.<span class="hljs-title function_ invoke__">headers</span>()<br>        .<span class="hljs-title function_ invoke__">get</span>(header::CONTENT_TYPE)<br>        .<span class="hljs-title function_ invoke__">map</span>(|v|v.<span class="hljs-title function_ invoke__">to_str</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>())<br>&#125;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt;&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">httpie</span> = Httpie::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">match</span> httpie.methods &#123;<br>        Method::<span class="hljs-title function_ invoke__">Get</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">get</span>(client, args).<span class="hljs-keyword">await</span>?,<br>        Method::<span class="hljs-title function_ invoke__">Post</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">post</span>(client, args).<span class="hljs-keyword">await</span>?,<br>    &#125;;<br>    <span class="hljs-title function_ invoke__">Ok</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，即使算上 <code>use</code> 部分，总代码也不过160行左右，Rust 的 <code>clap</code> 库在 CLI 开发上确实 yyds！</p><p>接下来我们来一一拆解这部分的代码，其中关于 <code>clap</code>的部分我不会过多展开，刚兴趣的读者可以参阅：<ahref="https://hedon.top/2024/03/02/rust-crate-clap/">深入探索 Rust 的clap 库：命令行解析的艺术</a>。</p><h3 id="命令行解析">3.1 命令行解析</h3><p>我们先从 <code>main()</code> 开始：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt;&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">httpie</span> = Httpie::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">match</span> httpie.methods &#123;<br>        Method::<span class="hljs-title function_ invoke__">Get</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">get</span>(client, args).<span class="hljs-keyword">await</span>?,<br>        Method::<span class="hljs-title function_ invoke__">Post</span>(<span class="hljs-keyword">ref</span> args) =&gt; <span class="hljs-title function_ invoke__">post</span>(client, args).<span class="hljs-keyword">await</span>?,<br>    &#125;;<br>    <span class="hljs-title function_ invoke__">Ok</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们希望使用 <code>clap</code> 的异步功能，所以使用了<code>async</code> 关键字，同时加上了 <code>tokio</code> 提供的属性宏<code>#[tokio::main]</code>，用于设置异步环境。为了能够使用<code>?</code> 快速传播错误，我们设置返回值为<code>anyhow::Result&lt;()&gt;</code>，本项目中我们不对错误进行过多处理，所以这种方式可以大大简化我们的错误处理过程。</p><p><code>main()</code> 中我们使用 <code>Httpie::parse()</code>解析命令行中的参数，使用 <code>Client::new()</code> 创建一个 httpclient，根据解析到的命令行参数，我们匹配子命令<code>methods</code>，分别调用 <code>get()</code> 和 <code>post()</code>来发送 GET 和 POST 请求。</p><p><code>Httpie</code> 的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Httpie</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    methods: Method,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Parser)]</code> 是一个过程宏（proceduralmacro），用于自动为结构体实现 <code>clap::Parser</code>trait。这使得该结构体可以用来解析命令行参数。</p><p>在 <code>Httpie</code> 中我们定义了子命令 <code>Method</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-title function_ invoke__">Get</span>(Get),<br>    <span class="hljs-title function_ invoke__">Post</span>(Post)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Subcommand)]</code>属性宏会自动为枚举派生一些代码，以便它可以作为子命令来解析命令行参数。目前支持<code>Get</code> 和 <code>Post</code> 两个子命令，它们分别接收<code>Get</code> 和 <code>Post</code> 参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Get</span> &#123;<br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-meta">#[derive(Args)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-meta">#[arg(value_parser = parse_url)]</span><br>    url: <span class="hljs-type">String</span>,<br>  <br>    <span class="hljs-meta">#[arg(value_parser = parse_kv_pairs)]</span><br>    body: <span class="hljs-type">Vec</span>&lt;KvPair&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Args)]</code> 属性宏表明当前 struct 是命令的参数，其中<code>Get</code> 仅支持 <code>url</code> 参数，<code>Post</code> 支持<code>url</code> 和 <code>body</code> 参数。</p><p><code>url</code> 参数我们使用 <code>parse_url</code>函数来进行解析：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest::Url;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_url</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_url</span>: Url = s.<span class="hljs-title function_ invoke__">parse</span>()?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">into</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>reqwest::Url</code> 已经实现了 <code>FromStr</code>trait，所以这里我们可以直接调用 <code>s.parse()</code> 来解析<code>url</code>。</p><p>而 <code>body</code>，因为我们期望 CLI 使用起来像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">httpie url header1:value1 param1=v1<br></code></pre></td></tr></table></figure><p><code>body</code> 就是 <code>header1:value1 param1=v1</code>，一对 kv就代表着一个 header 或者 param，用 <code>:</code> 和 <code>=</code>来区分。因为 kv 对的个数的变长的，所以我们使用<code>Vec&lt;KvPair&gt;</code> 来接收 <code>body</code> 这个参数，并使用<code>parse_kv_pairs</code> 来解析 kv 对。</p><p><code>KvPair</code> 是我们自定义的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    k: <span class="hljs-type">String</span>,<br>    v: <span class="hljs-type">String</span>,<br>    t: KvPairType,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug,Clone)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">KvPairType</span> &#123;<br>    Header,<br>    Param,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>parse_kv_pairs</code> 的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_kv_pairs</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;KvPair&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s.<span class="hljs-title function_ invoke__">parse</span>()?)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，你可以在 <code>parse_kv_pairs()</code> 函数中，对<code>s</code> 进行解析并返回<code>anyhow::Result&lt;KvPair&gt;</code>。不过，更优雅，更统一的方式是什么呢？就是像<code>reqwest::Url</code> 一样，为 <code>KvPair</code> 实现<code>FromStr</code> trait，这样就可以直接调用 <code>s.parse()</code>来进行解析了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">FromStr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">KvPair</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Err</span> = anyhow::Error;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_str</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::<span class="hljs-literal">Err</span>&gt; &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发送请求">3.2 发送请求</h3><p>参数解析完，就到了发送请求的地方了，这里使用 <code>reqwest</code>crate 就非常方便了，这里就不赘述了，具体可以参考：<ahref="https://hedon.top/2024/03/02/rust-crate-reqwest/">Rust reqwest简明教程</a>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(client: Client, args: &amp;Get) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123; ... &#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">post</span>(client: Client, args: &amp;Post) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="打印响应">3.3 打印响应</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240305225846224.png"alt="httpie response demo" /><figcaption aria-hidden="true">httpie response demo</figcaption></figure><p>响应分为 3 个部分：</p><ul><li>print_status()</li><li>print_headers()</li><li>print_body()</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_resp</span>(resp: Response) <span class="hljs-punctuation">-&gt;</span> anyhow::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-title function_ invoke__">print_status</span>(&amp;resp);<br>    <span class="hljs-title function_ invoke__">print_headers</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mime</span> = <span class="hljs-title function_ invoke__">get_content_type</span>(&amp;resp);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = resp.<span class="hljs-title function_ invoke__">text</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-title function_ invoke__">print_body</span>(mime, &amp;body);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p><code>print_status()</code> 比较简单，就是打印 HTTP版本和响应状态码，然后我们使用 <code>colored</code> crate 的<code>blue()</code> 使其在终端以<font color="blue">蓝色</font>输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_status</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">status</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;:?&#125; &#123;&#125;&quot;</span>, resp.<span class="hljs-title function_ invoke__">version</span>(), resp.<span class="hljs-title function_ invoke__">status</span>()).<span class="hljs-title function_ invoke__">blue</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>, status);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>print_headers()</code> 中，我们使用 <code>green()</code> 使header_name 在终端以<font color="green">绿色</font>输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_headers</span>(resp: &amp;Response) &#123;<br>    <span class="hljs-keyword">for</span> (k,v) <span class="hljs-keyword">in</span> resp.<span class="hljs-title function_ invoke__">headers</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, k.<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">green</span>(), v);<br>    &#125;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>响应体的格式（Media Type）有很多，本案例中我们仅支持<code>application/json</code>，所以在 <code>print_body()</code>之前，我们需要先读取 response header 中的 content-type：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_content_type</span>(resp: &amp;Response) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Mime&gt; &#123;<br>    resp.<span class="hljs-title function_ invoke__">headers</span>()<br>        .<span class="hljs-title function_ invoke__">get</span>(header::CONTENT_TYPE)<br>        .<span class="hljs-title function_ invoke__">map</span>(|v|v.<span class="hljs-title function_ invoke__">to_str</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>print_resp()</code> 中，对于<code>application/json</code>，我们使用 <code>jsonxf</code> crate对进行美化，并使用 <code>cyan()</code>使其在终端以<font color="cyan">蓝绿色</font>输出。对于其他类型，我们姑且照原文输出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_body</span>(mime: <span class="hljs-type">Option</span>&lt;Mime&gt;, resp: &amp;<span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-keyword">match</span> mime &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(v) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> v == mime::APPLICATION_JSON &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, jsonxf::<span class="hljs-title function_ invoke__">pretty_print</span>(resp).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">cyan</span>())<br>            &#125;<br>        &#125;<br>        _ =&gt; <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, resp),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>在本文中，我们深入探讨了如何使用 Rust 语言来实现一个类似于 HTTPie的命令行工具。这个过程包括了对 HTTP 协议的理解、命令行参数的解析、HTTP客户端的创建和请求发送，以及对响应的处理和展示。通过本文，读者不仅能够获得一个实用的命令行工具，还能够学习到如何使用Rust 的库来构建实际的应用程序，包括<code>clap</code>、<code>reqwest</code>、<code>tokio</code> 和<code>colored</code> 等。此外，文章也说明了在 Rust中进行异步编程和错误处理的一些常见模式。尽管示例代码的错误处理较为简单，但它提供了一个良好的起点，开发者可以在此基础上进行扩展和改进，以适应更复杂的应用场景。</p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust anyhow 简明教程</title>
    <link href="/2024/03/05/rust-crate-anyhow/"/>
    <url>/2024/03/05/rust-crate-anyhow/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.rs/anyhow/latest/anyhow/index.html">anyhow</a>是 Rust 中的一个库，旨在提供灵活的、具体的错误处理能力，建立在<code>std::error::Error</code>基础上。它主要用于那些需要简单错误处理的应用程序和原型开发中，尤其是在错误类型不需要被严格区分的场景下。</p><p>以下是 <code>anyhow</code> 的几个关键特性：</p><ul><li><strong>易用性</strong>: <code>anyhow</code> 提供了一个<code>Error</code> 类型，这个类型可以包含任何实现了<code>std::error::Error</code> 的错误。这意味着你可以使用<code>anyhow::Error</code>来包装几乎所有类型的错误，无需担心具体的错误类型。</li><li><strong>简洁的错误链</strong>: <code>anyhow</code> 支持通过<code>?</code>操作符来传播错误，同时保留错误发生的上下文。这让错误处理更加直观，同时还能保留错误链，便于调试。</li><li><strong>便于调试</strong>: <code>anyhow</code> 支持通过<code>&#123;:#&#125;</code>格式化指示符来打印错误及其所有相关的上下文和原因，这使得调试复杂的错误链变得更加简单。</li><li><strong>无需关心错误类型</strong>:在很多情况下，特别是在应用程序的顶层，你可能不需要关心错误的具体类型，只需要知道出错了并且能够将错误信息传递给用户或日志。<code>anyhow</code>让这一过程变得简单，因为它可以包装任何错误，而不需要显式地指定错误类型。</li></ul><p>使用 <code>anyhow</code>的典型场景包括快速原型开发、应用程序顶层的错误处理，或者在库中作为返回错误类型的一个简便选择，尤其是在库的使用者不需要关心具体错误类型的时候。</p><h2 id="anyhowerror">anyhow::Error</h2><p><code>anyhow::Error</code> 是 <code>anyhow</code>库定义的一个错误类型。它是一个包装器（wrapper）类型，可以包含任何实现了<code>std::error::Error</code> trait的错误类型。这意味着你可以将几乎所有的错误转换为<code>anyhow::Error</code>类型，从而在函数之间传递，而不需要在意具体的错误类型。这在快速原型开发或应用程序顶层错误处理中特别有用，因为它简化了错误处理的逻辑。</p><p>它的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg_attr(not(doc), repr(transparent))]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Error</span> &#123;<br>    inner: Own&lt;ErrorImpl&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p>其中核心是 <code>ErrorImpl</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[repr(C)]</span><br><span class="hljs-title function_ invoke__">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ErrorImpl</span>&lt;E = ()&gt; &#123;<br>    vtable: &amp;<span class="hljs-symbol">&#x27;static</span> ErrorVTable,<br>    backtrace: <span class="hljs-type">Option</span>&lt;Backtrace&gt;,<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Don&#x27;t use directly. Use only through vtable. Erased type may have</span><br>    <span class="hljs-comment">// different alignment.</span><br>    _object: E,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ErrorImpl</code> 是一个内部结构体，用于实现<code>anyhow::Error</code> 类型的具体功能。它包含了三个主要字段：</p><ul><li><code>vtable</code>是一个指向静态虚拟表的指针，用于动态派发错误相关的方法。</li><li><code>backtrace</code>是一个可选的回溯（Backtrace）类型，用于存储错误发生时的调用栈信息。</li><li><code>_object</code>字段用于存储具体的错误对象，其类型在编译时被擦除以提供类型安全的动态错误处理。</li></ul><p>这种设计允许 <code>anyhow</code>错误封装并表示各种不同的错误类型，同时提供了方法动态派发和回溯功能，以便于错误调试。</p><p><code>anyhow::Error</code> 可以包含任何实现了<code>std::error::Error</code> trait 的错误类型，这里因为下面的<code>impl</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">impl&lt;E&gt; StdError <span class="hljs-keyword">for</span> ErrorImpl&lt;E&gt;<br>where<br>    E: StdError,<br>&#123;<br>    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn StdError + <span class="hljs-string">&#x27;static)&gt; &#123;</span><br><span class="hljs-string">        unsafe &#123; ErrorImpl::error(self.erase()).source() &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    #[cfg(error_generic_member_access)]</span><br><span class="hljs-string">    fn provide&lt;&#x27;</span>a&gt;(&amp;<span class="hljs-string">&#x27;a self, request: &amp;mut Request&lt;&#x27;</span>a&gt;) &#123;<br>        unsafe &#123; ErrorImpl::provide(self.erase(), request) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="anyhowresult">anyhow::Result</h2><p><code>anyhow::Result</code> 是一个别名（type alias），它是<code>std::result::Result&lt;T, anyhow::Error&gt;</code> 的简写。在使用<code>anyhow</code>库进行错误处理时，你会频繁地看到这个类型。它基本上是标准的<code>Result</code> 类型，但错误类型被固定为<code>anyhow::Error</code>。这使得你可以很容易地在函数之间传递错误，而不需要声明具体的错误类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span>&lt;T, E = Error&gt; = core::result::<span class="hljs-type">Result</span>&lt;T, E&gt;;<br></code></pre></td></tr></table></figure><p>使用 <code>anyhow::Result</code>的好处在于它提供了一种统一的方式来处理错误。你可以使用 <code>?</code>操作符来传播错误，同时保留错误的上下文信息和回溯。这极大地简化了错误处理代码，尤其是在多个可能产生不同错误类型的操作链中。</p><h2 id="个核心使用技巧">3 个核心使用技巧</h2><ul><li>使用 <code>Result&lt;T, anyhow::Error&gt;</code> 或者<code>anyhow::Result&lt;T&gt;</code> 作为返回值，然后利用 <code>?</code>语法糖无脑传播报错。</li><li>使用 with_context(f) 来附加错误信息。</li><li>使用 downcast 反解具体的错误类型。</li></ul><h2 id="实战案例">实战案例</h2><p>下面我们用一个案例来体会 <code>anyhow</code> 的使用方式：</p><p>我们的需求是：打开一个文件，解析文件中的数据并进行大写化，然后输出处理后的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> anyhow::&#123;<span class="hljs-type">Result</span>, Context&#125;;<br><span class="hljs-keyword">use</span> std::&#123;fs, io&#125;;<br><br><span class="hljs-comment">// 1. 读取文件、解析数据和执行数据操作都可能出现错误，</span><br><span class="hljs-comment">// 所以我们需要返回 Result 来兼容异常情况。</span><br><span class="hljs-comment">// 这里我们使用 anyhow::Result 来简化和传播错误。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_and_process_file</span>(file_path: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// 尝试读取文件</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">data</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(file_path)<br>        <span class="hljs-comment">// 2. 使用 with_context 来附加错误信息，然后利用 ? 语法糖传播错误。</span><br>        .<span class="hljs-title function_ invoke__">with_context</span>(||<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;failed to read file `&#123;&#125;`&quot;</span>, file_path))?;<br><br>    <span class="hljs-comment">// 解析数据</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">processed_data</span> = <span class="hljs-title function_ invoke__">parse_data</span>(&amp;data)<br>        .<span class="hljs-title function_ invoke__">with_context</span>(||<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;failed to parse data from file `&#123;&#125;`&quot;</span>, file_path))?;<br><br>    <span class="hljs-comment">// 执行数据操作</span><br>    <span class="hljs-title function_ invoke__">perform_some_operation</span>(processed_data)<br>        .<span class="hljs-title function_ invoke__">with_context</span>(|| <span class="hljs-string">&quot;failed to perform operation based on file data&quot;</span>)?;<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_data</span>(data: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(data.<span class="hljs-title function_ invoke__">to_uppercase</span>())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">perform_some_operation</span>(data: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;processed data: &#123;&#125;&quot;</span>, data);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">file_path</span> = <span class="hljs-string">&quot;./anyhow.txt&quot;</span>;<br>  <span class="hljs-comment">// 执行处理逻辑</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> =  <span class="hljs-title function_ invoke__">read_and_process_file</span>(file_path);<br>  <span class="hljs-comment">// 处理结果</span><br>    <span class="hljs-keyword">match</span> res &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;successfully!&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; &#123;<br>            <span class="hljs-comment">// 3. 使用 downcast 来反解出实际的错误实例，本案例中可能出现的异常是 io::Error。</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(my_error) = e.downcast_ref::&lt;io::Error&gt;() &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;has io error: &#123;:#&#125;&quot;</span>, my_error);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;unknown error: &#123;:?&#125;&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 常用库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入探索 Rust 的 clap 库：命令行解析的艺术</title>
    <link href="/2024/03/02/rust-crate-clap/"/>
    <url>/2024/03/02/rust-crate-clap/</url>
    
    <content type="html"><![CDATA[<h1 id="版本声明">版本声明</h1><ul><li>Rust: 1.76</li><li><a href="https://docs.rs/clap/4.5.1/clap/index.html">clap:4.5.1</a></li><li><ahref="https://docs.rs/clap_complete/4.5.1/clap_complete/index.html">clap_complete4.5.1</a></li><li><ahref="https://docs.rs/rpassword/7.3.1/rpassword/index.html">rpassword:7.3.1</a></li></ul><h1 id="结论先行">结论先行</h1><p>本文将从 CLI（Command LineInterface）命令行工具的概述讲起，介绍一个优秀的命令行工具应该具备的功能和特性。然后介绍Rust 中一个非常优秀的命令行解析工具 <code>clap</code>经典使用方法，并利用 <code>clap</code> 实现一个类似于 <code>curl</code>的工具 <code>httpie</code>。文章最后还将 <code>clap</code> 于 Go语言中同样优秀的命令行解析工具 <code>cobra</code>进行一个简单对比，便于读者进一步体会 <code>clap</code>的简洁和优秀。</p><p>本文将包含以下几个部分：</p><ol type="1"><li><strong>CLI 概述</strong>：从 CLI的基本概念出发，介绍优秀命令行工具应该具备的功能特性，并以 curl作为经典范例进行说明。</li><li><strong>详细介绍 clap</strong>：基于 clap 官方文档，分别详细介绍clap 以 derive 和 builder 两个方式构建 cli 的常用方法。</li><li><strong>实战 httpie</strong>：参考陈天老师的《Rust编程第一课》，用最新的 clap 版本（1.7.6）实现 httpie 工具。</li><li><strong>对比cobra</strong>：从设计理念和目标、功能特点、使用场景等方面简要对比 clap和 Go 流行的命令行解析库 cobra。</li></ol><p>特此声明，本文包含 AI 辅助生成内容，如有错误遗漏之处，敬请指出。</p><h1 id="cli-概述">CLI 概述</h1><p>CLI（Command LineInterface，命令行界面）是一种允许用户通过文本命令与计算机程序或操作系统进行交互的接口。与图形用户界面（GUI，GraphicalUser Interface）相比，CLI不提供图形元素，如按钮或图标，而是依赖于文本输入。用户通过键盘输入特定的命令行指令，命令行界面解释这些指令并执行相应的操作。</p><p>一款优秀的 CLI工具应该具备以下的功能和特性，以提升用户体验和效率：</p><p>一个优秀的命令行工具（CLI, Command LineInterface）应该具备以下功能和特性，以提升用户体验和效率：</p><ol type="1"><li><strong>直观易用</strong>：<ul><li><strong>简洁的命令语法</strong>：命令和参数的设计应直观易懂，方便用户记忆和使用。</li><li><strong>自动补全</strong>：支持命令和参数的自动补全功能，提高用户输入效率。</li><li><strong>命令别名</strong>：提供常用命令的简短别名，减少输入的工作量。</li></ul></li><li><strong>强大的帮助系统</strong>：<ul><li><strong>详细的帮助文档</strong>：每个命令和参数都应有清晰的说明文档。</li><li><strong>示例使用方式</strong>：提供常见的使用示例，帮助用户快速理解和应用。</li><li><strong>内置帮助命令</strong>：通过如<code>--help</code>或<code>-h</code>参数轻松访问帮助信息。</li></ul></li><li><strong>错误处理与反馈</strong>：<ul><li><strong>清晰的错误信息</strong>：出现错误时，提供明确、具体的错误信息，帮助用户快速定位问题。</li><li><strong>建议和解决方案</strong>：在可能的情况下，给出错误解决的建议或自动修复选项。</li></ul></li><li><strong>高效的执行和输出</strong>：<ul><li><strong>快速响应</strong>：命令执行应迅速，减少用户等待时间。</li><li><strong>格式化的输出</strong>：提供易于阅读和解析的输出格式，如表格、JSON或 XML 等。</li><li><strong>输出过滤和排序</strong>：允许用户根据需要过滤和排序输出结果，提高信息的查找效率。</li></ul></li><li><strong>跨平台兼容</strong>：<ul><li><strong>多平台支持</strong>：能够在不同的操作系统上运行，如Windows、macOS、Linux 等。</li><li><strong>环境适应性</strong>：自动适应不同的终端环境和字符编码，确保输出显示正确。</li></ul></li><li><strong>安全性</strong>：<ul><li><strong>安全的默认设置</strong>：默认配置应强调安全，避免暴露敏感信息。</li><li><strong>数据加密</strong>：在处理敏感信息（如密码）时，应使用加密手段保护数据安全。</li></ul></li><li><strong>版本管理</strong>：<ul><li><strong>版本控制</strong>：提供命令查看工具版本，支持多版本共存或升级。</li><li><strong>向后兼容</strong>：新版本应尽量保持与旧版本的兼容性，避免破坏用户现有的工作流程。</li></ul></li></ol><p>这些特性不仅能够提高用户的工作效率，还能增强用户体验，使命令行工具更加强大和易用。</p><p>下面我们以 <code>curl</code> 为例，看看优秀的 CLI工具大概长什么样子。</p><p><code>curl</code>是一种命令行工具和库，用于传输数据。它支持多种协议，包括HTTP、HTTPS、FTP、FTPS、SCP、SFTP、TFTP、TELNET、DICT、LDAP、LDAPS、IMAP、POP3、SMTP和 RTSP 等。<code>curl</code>是一个非常强大和灵活的工具，广泛应用于自动化脚本、系统测试、数据收集和许多其他用途。</p><p>进入终端，我们可以用下面命令查看 <code>curl</code> 的说明文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ curl --<span class="hljs-built_in">help</span><br>Usage: curl [options...] &lt;url&gt;<br> -d, --data &lt;data&gt;          HTTP POST data<br> -f, --fail                 Fail fast with no output on HTTP errors<br> -h, --<span class="hljs-built_in">help</span> &lt;category&gt;      Get <span class="hljs-built_in">help</span> <span class="hljs-keyword">for</span> commands<br> -i, --include              Include protocol response headers <span class="hljs-keyword">in</span> the output<br> -o, --output &lt;file&gt;        Write to file instead of stdout<br> -O, --remote-name          Write output to a file named as the remote file<br> -s, --silent               Silent mode<br> -T, --upload-file &lt;file&gt;   Transfer <span class="hljs-built_in">local</span> FILE to destination<br> -u, --user &lt;user:password&gt; Server user and password<br> -A, --user-agent &lt;name&gt;    Send User-Agent &lt;name&gt; to server<br> -v, --verbose              Make the operation more talkative<br> -V, --version              Show version number and quit<br><br>This is not the full <span class="hljs-built_in">help</span>, this menu is stripped into categories.<br>Use <span class="hljs-string">&quot;--help category&quot;</span> to get an overview of all categories.<br>For all options use the manual or <span class="hljs-string">&quot;--help all&quot;</span>.<br></code></pre></td></tr></table></figure><p>使用示例：</p><ul><li>下载文件： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -O http://example.com/file.txt<br></code></pre></td></tr></table></figure></li><li>发送 POST 请求： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&quot;param1=value1&amp;param2=value2&quot;</span> http://example.com/resource<br></code></pre></td></tr></table></figure></li><li>使用 HTTPS 并忽略证书验证： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -k https://example.com<br></code></pre></td></tr></table></figure></li><li>使用基本认证： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -u username:password http://example.com<br></code></pre></td></tr></table></figure></li></ul><p><code>curl</code>的这些特性使其成为开发者、系统管理员和自动化脚本中广泛使用的工具之一。</p><h1 id="clap">clap</h1><h2 id="概述">概述</h2><p><code>clap</code>，代表 <em>Command Line ArgumentParser</em>，是一个旨在创建直观、易用且功能强大的命令行界面的 Rust库。截至目前（2024.2），<code>clap</code> 已经发展到了 4.5.1版本，它通过简化命令行参数的处理，让开发者能更专注于应用逻辑的构建。</p><p><code>clap</code> 之所以在 Rust社区如此流行，得益于以下几个优点：</p><p><strong>1. 易于使用</strong></p><p><code>clap</code>的设计理念是让命令行参数的解析变得简单而直观。即使是没有经验的开发者也能快速上手，通过几行代码就能实现复杂的命令行参数解析。</p><p><strong>2. 功能丰富</strong></p><p><code>clap</code>提供了广泛的功能来满足各种命令行解析需求，包括但不限于：</p><ul><li><strong>自动生成的帮助信息</strong>：<code>clap</code>能根据定义的参数自动生成帮助信息，包括参数的说明、类型、默认值等。</li><li><strong>强大的错误提示</strong>：当用户输入无效的命令行参数时，<code>clap</code>会提供清晰且有用的错误提示，帮助用户快速定位问题。</li><li><strong>参数验证</strong>：开发者可以为参数设定验证规则，确保输入的参数符合预期。</li><li><strong>复杂的命令结构</strong>：支持子命令的嵌套，允许构建复杂的命令行应用结构。</li><li><strong>自定义派生</strong>：通过 <code>clap</code>的派生宏，可以简化命令行解析器的定义，使代码更加清晰。</li></ul><p><strong>3. 高度可定制</strong></p><p><code>clap</code>允许开发者高度定制命令行解析的行为和外观，包括自定义帮助信息的格式、控制错误消息的显示方式等。这种灵活性意味着你可以根据应用程序的需求调整<code>clap</code> 的行为。</p><p><strong>4. 性能优异</strong></p><p>尽管 <code>clap</code>功能强大，但它仍然非常注重性能。<code>clap</code>经过优化，以尽可能少的性能开销处理命令行参数。</p><p><strong>5. 活跃的社区支持</strong></p><p><code>clap</code> 有一个非常活跃的社区，在 GitHub上不断有新的贡献者加入。这意味着 <code>clap</code>不断地得到改进和更新，同时也有大量的社区资源可供参考。</p><h2 id="derive-vs-builder-1-初探">Derive vs Builder (1) 初探</h2><p><code>clap</code> 提供了 2 种构建命令行的方式，分别为<code>Derive</code> 和<code>Builder</code>。顾名思义，<code>Derive</code>就是利用宏强大的功能来构建命令行，而 <code>Builder</code>则采用构建者模式链式构建命令行工具。</p><p>在这里我们先给出示例来直观感受这 2 种构建方式的不同：</p><p>Derive:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-comment">/// Specify your name</span><br>    name: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-comment">/// Specify your age optionally</span><br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    age: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i8</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name: &#123;&#125;&quot;</span>, cli.name);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;age: &#123;:?&#125;&quot;</span>, cli.age);<br>&#125;<br></code></pre></td></tr></table></figure><p>Builder:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;myapp&quot;</span>)<br>  .<span class="hljs-title function_ invoke__">version</span>(<span class="hljs-string">&quot;1.0.0&quot;</span>)<br>  .<span class="hljs-title function_ invoke__">author</span>(<span class="hljs-string">&quot;hedon&quot;</span>)<br>  .<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;this is the short about&quot;</span>)<br>  .<span class="hljs-title function_ invoke__">long_about</span>(<span class="hljs-string">&quot;this is the long about&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!([NAME]).<span class="hljs-title function_ invoke__">required</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your name&quot;</span>))<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(-a --age &lt;AGE&gt;)<br>            .<span class="hljs-title function_ invoke__">value_parser</span>(clap::value_parser!(<span class="hljs-type">u8</span>))<br>            .<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your age optionally&quot;</span>))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name: &#123;:?&#125;&quot;</span>, matches.get_one::&lt;<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;NAME&quot;</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;age: &#123;:?&#125;&quot;</span>, matches.get_one::&lt;<span class="hljs-type">u8</span>&gt;(<span class="hljs-string">&quot;age&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这 2 个程序都实现了相同的功能，使用 <code>--help</code>，输出的内容大致都如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: derive [OPTIONS] &lt;NAME&gt;<br><br>Arguments:<br>  &lt;NAME&gt;  Specify your name<br><br>Options:<br>  -a, --age &lt;AGE&gt;  Specify your age optionally<br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>通过观察，可以发现 Derive 模式下，宏中的每一个属性，如<code>version</code>、<code>author</code> 等，都对应到 Builder模式下一个同名的函数。</p><p>下面我们将从<strong>「应用配置」</strong>、<strong>「参数类型」</strong>和<strong>「参数校验」</strong>三个方面，分别介绍<code>clap</code> 中 Derive 和 Builder 两种模式构建 CLI 的常用方法。</p><p>特别说明：后续的例子均在 <code>examples</code>目录下实现，故编译和执行命令都包含 example。</p><p>目录结构大概如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ tree         <br>.<br>├── Cargo.lock<br>├── Cargo.toml<br>├── examples<br>│   ├── optional.rs<br>├── src<br>│   └── main.rs<br>└── target<br>    └── release<br>        └── examples<br>        └── optional<br></code></pre></td></tr></table></figure><h2 id="derive">Derive</h2><p>要使用 <code>clap</code> 的 Derive 模式，需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add clap --features derive<br></code></pre></td></tr></table></figure><h3 id="应用配置">1. 应用配置</h3><p>我们需要定义一个 <code>strut</code> 来表示我们的<code>application</code>，利用它来承载应用的参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// The example of clap derive</span><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-comment">/// Specify your name</span><br>    name: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-comment">/// Specify your age optionally</span><br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    age: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i8</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name: &#123;&#125;&quot;</span>, cli.name);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;age: &#123;:?&#125;&quot;</span>, cli.age);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[derive(Parser)]</code> 是一个过程宏（proceduralmacro），用于自动为结构体实现 <code>clap::Parser</code>trait。这使得该结构体可以用来解析命令行参数。</p><ul><li>使用<code>#[derive(Parser)]</code>，你可以简化命令行解析的代码，因为<code>clap</code> 会根据结构体的字段自动生成命令行解析的逻辑。</li><li>每个字段都对应一个命令行参数，字段的类型和属性用来决定参数的解析方式和验证规则。</li></ul><p><code>#[command(version, about, long_about = None)]</code>属性用于为整个命令行程序提供元信息，它支持以下几个元素：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240301202114143.png"alt="#[command] 支持的元素" /><figcaption aria-hidden="true">#[command] 支持的元素</figcaption></figure><p><code>#[arg(short, long)]</code>属性用于配置命令参数的元信息，它支持以下几个属性：</p><table><thead><tr class="header"><th>属性</th><th>方法</th><th>默认值/行为</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>id</td><td>Arg::id</td><td>field’s name</td><td>当属性不存在时，使用字段名</td></tr><tr class="even"><td>value_parser</td><td>Arg::value_parser</td><td>auto-select based on field type</td><td>当属性不存在时，会基于字段类型自动选择实现</td></tr><tr class="odd"><td>action</td><td>Arg::action</td><td>auto-select based on field type</td><td>当属性不存在时，会基于字段类型自动选择动作</td></tr><tr class="even"><td>help</td><td>Arg::help</td><td>Doc comment summary</td><td>当属性不存在时，使用文档注释摘要</td></tr><tr class="odd"><td>long_help</td><td>Arg::long_help</td><td>Doc comment with blank line, else nothing</td><td>当属性不存在时，使用文档注释，如果有空行</td></tr><tr class="even"><td>verbatim_doc_comment</td><td>Minimizes preprocessing</td><td>-</td><td>将文档注释转换为 help/long_help 时最小化预处理</td></tr><tr class="odd"><td>short</td><td>Arg::short</td><td>no short set</td><td>当属性不存在时，没有短名称设置</td></tr><tr class="even"><td>long</td><td>Arg::long</td><td>no long set</td><td>当属性不存在时，没有长名称设置</td></tr><tr class="odd"><td>env</td><td>Arg::env</td><td>no env set</td><td>当属性不存在时，没有环境变量设置</td></tr><tr class="even"><td>from_global</td><td>Read Arg::global</td><td>-</td><td>无论在哪个子命令中，都读取 Arg::global 参数</td></tr><tr class="odd"><td>value_enum</td><td>Parse with ValueEnum</td><td>-</td><td>使用 ValueEnum 解析值</td></tr><tr class="even"><td>skip</td><td>Ignore this field</td><td>fills the field with Default::default()</td><td>忽略此字段，用 &lt;expr&gt; 或 Default::default() 填充</td></tr><tr class="odd"><td>default_value</td><td>Arg::default_value</td><td>Arg::required(false)</td><td>设置默认值，并将 Arg 设置为非必须</td></tr><tr class="even"><td>default_value_t</td><td>Arg::default_value</td><td>Arg::required(false)</td><td>要求 std::fmt::Display 与 Arg::value_parser 相匹配</td></tr><tr class="odd"><td>default_values_t</td><td>Arg::default_values</td><td>Arg::required(false)</td><td>要求字段类型为 Vec&lt;T&gt;，T 实现 std::fmt::Display</td></tr><tr class="even"><td>default_value_os_t</td><td>Arg::default_value_os</td><td>Arg::required(false)</td><td>要求 std::convert::Into&lt;OsString&gt;</td></tr><tr class="odd"><td>default_values_os_t</td><td>Arg::default_values_os</td><td>Arg::required(false)</td><td>要求字段类型为 Vec&lt;T&gt;，T实现std::convert::Into&lt;OsString&gt;</td></tr></tbody></table><h3 id="参数类型">2. 参数类型</h3><h4 id="arguments-options">2.1 Arguments &amp; Options</h4><p>从上面这个输出样例中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">the example of clap derive<br><br>Usage: derive [OPTIONS] &lt;NAME&gt;<br><br>Arguments:<br>  &lt;NAME&gt;  Specify your name<br><br>Options:<br>  -a, --age &lt;AGE&gt;  Specify your age optionally<br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>可以看到跟在命令后面有 2 中参数类型：</p><ul><li><strong>Arguments</strong>: 直接在命令后面指定值，如<code>cmd hedon</code>，有严格的顺序要求。</li><li><strong>Options</strong>: 需要用 <code>-&#123;short&#125;</code> 或<code>--&#123;long&#125;</code> 来指定是哪个参数，无严格的顺序要求。</li></ul><p>它们的定义区别就是是否使用了 <code>#[arg]</code>：</p><ul><li><strong>Options</strong>: 指定了 short 或 long。</li><li><strong>Arguments</strong>: 没有 short 和 long。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>  <span class="hljs-comment">/// 会被解析成 [NAME]</span><br>  name: <span class="hljs-type">String</span>,<br>  <br>  <span class="hljs-comment">/// 会被解析成 -a &lt;AGE&gt;</span><br>  <span class="hljs-meta">#[arg(short, long)]</span><br>  age: <span class="hljs-type">u8</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可选参数">2.2 可选参数</h4><p>可以使用 <code>Option</code> 来实现可选参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    name: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br><br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    age: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u8</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;name: &#123;:?&#125;&quot;</span>, cli.name);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;age: &#123;:?&#125;&quot;</span>, cli.age);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build --example optional --release<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/target/release/examples/optional --<span class="hljs-built_in">help</span> <br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">this is the about from Cargo.toml<br><br>Usage: optional [OPTIONS] [NAME]<br><br>Arguments:<br>  [NAME]  <br><br>Options:<br>  -a, --age &lt;AGE&gt;  <br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br>  -V, --version    Print version<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/optional       <br>name: None<br>age: None<br>➜  learn-clap git:(master) ✗ ./target/release/examples/optional -a 1  <br>name: None<br>age: Some(1)<br>➜  learn-clap git:(master) ✗ ./target/release/examples/optional hedon  <br>name: Some(<span class="hljs-string">&quot;hedon&quot;</span>)<br>age: None<br>➜  learn-clap git:(master) ✗ ./target/release/examples/optional hedon -a 18<br>name: Some(<span class="hljs-string">&quot;hedon&quot;</span>)<br>age: Some(18)<br></code></pre></td></tr></table></figure><h4 id="枚举参数">2.3 枚举参数</h4><p>可以使用 <code>enum</code> 搭配 <code>value_enum</code>来实现多选一参数，并限制可选参数的取值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Parser, ValueEnum&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-comment">/// Choose the program mode run in</span><br>    <span class="hljs-meta">#[arg(value_enum)]</span><br>    mode: Mode,<br>&#125;<br><br><span class="hljs-meta">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Mode</span> &#123;<br>    <span class="hljs-comment">/// run in fast mode</span><br>    Fast,<br>    <span class="hljs-comment">/// run in slow mode</span><br>    Slow,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">match</span> cli.mode &#123;<br>        Mode::Fast =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;fast!!!!!&quot;</span>),<br>        Mode::Slow =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;slow......&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">Usage: enum &lt;MODE&gt;<br><br>Arguments:<br>  &lt;MODE&gt;<br>          Choose the program mode run <span class="hljs-keyword">in</span><br><br>          Possible values:<br>          - fast: run <span class="hljs-keyword">in</span> fast mode<br>          - slow: run <span class="hljs-keyword">in</span> slow mode<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span><br>          Print <span class="hljs-built_in">help</span> (see a summary with <span class="hljs-string">&#x27;-h&#x27;</span>)<br><br>  -V, --version<br>          Print version<br></code></pre></td></tr></table></figure><h4 id="累计参数">2.4 累计参数</h4><p>累积参数允许用户通过重复指定同一个标志（例如<code>-d</code>）来累加值或效果，通常用于控制命令行应用的详细级别（verbositylevel）或其他需要根据次数变化的行为。</p><p>在很多命令行工具中，累积参数常见于控制日志输出的详细程度。例如，一个<code>-v</code>（verbose）标志可能每被指定一次，就增加一层详细级别。所以，<code>-vvv</code>（等价于<code>-v -v -v</code>） 会比单个 <code>-v</code>提供更多的详细信息。</p><p>在 <code>clap</code> 中可以通过 <code>clap::ArgAction::Count</code>来实现这种累积参数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, action = clap::ArgAction::Count)]</span><br>    verbose: <span class="hljs-type">u8</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;verbose: &#123;&#125;&quot;</span>, cli.verbose);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/accurate --<span class="hljs-built_in">help</span><br>this is the about from Cargo.toml<br><br>Usage: accurate [OPTIONS]<br><br>Options:<br>  -v, --verbose...  <br>  -h, --<span class="hljs-built_in">help</span>        Print <span class="hljs-built_in">help</span><br>  -V, --version     Print version<br>➜  learn-clap git:(master) ✗ ./target/release/examples/accurate -v    <br>verbose: 1<br>➜  learn-clap git:(master) ✗ ./target/release/examples/accurate -vvvv<br>verbose: 4<br></code></pre></td></tr></table></figure><h4 id="变长参数">2.5 变长参数</h4><p>有时候我们希望接收变长参数，比如说：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">del file1 file2 file3<br></code></pre></td></tr></table></figure><p>这个时候可以使用 <code>Vec&lt;&gt;</code> 来实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    files: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;files: &#123;:?&#125;&quot;</span>, cli.files);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/var_length --<span class="hljs-built_in">help</span><br>this is the about from Cargo.toml<br><br>Usage: var_length [FILES]...<br><br>Arguments:<br>  [FILES]...  <br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br>➜  learn-clap git:(master) ✗ ./target/release/examples/var_length       <br>files: []<br>➜  learn-clap git:(master) ✗ ./target/release/examples/var_length file1 <br>files: [<span class="hljs-string">&quot;file1&quot;</span>]<br>➜  learn-clap git:(master) ✗ ./target/release/examples/var_length file1 file2<br>files: [<span class="hljs-string">&quot;file1&quot;</span>, <span class="hljs-string">&quot;file2&quot;</span>]<br>➜  learn-clap git:(master) ✗ ./target/release/examples/var_length file1 file2 file3<br>files: [<span class="hljs-string">&quot;file1&quot;</span>, <span class="hljs-string">&quot;file2&quot;</span>, <span class="hljs-string">&quot;file3&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="标志参数">2.6 标志参数</h4><p>对于标志参数，只要指定类型为<code>bool</code>，就可以自动实现了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    verbose: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;verbose: &#123;&#125;&quot;</span>, cli.verbose);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/flag --<span class="hljs-built_in">help</span><br>Usage: flag [OPTIONS]<br><br>Options:<br>  -v, --verbose  <br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br>➜  learn-clap git:(master) ✗ ./target/release/examples/flag       <br>verbose: <span class="hljs-literal">false</span><br>➜  learn-clap git:(master) ✗ ./target/release/examples/flag -v    <br>verbose: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="子命令">2.7 子命令</h4><p>在更复杂的命令行工具中，除了主命令，还有子命令，甚至子命令下面还有子命令，其实就是一颗命令树。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/hedon954/mapStorage/img/image-20240228183301763.png"alt="command tree" /><figcaption aria-hidden="true">command tree</figcaption></figure><p>在 <code>clap</code> 中可以使用 <code>#[command(subcommand)]</code>搭配 <code>#[derive(Subcommand)]</code> 实现子命令功能。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Parser, Subcommand&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    test: <span class="hljs-type">Option</span>&lt;Test&gt;,<br>&#125;<br><br><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-comment">/// Add a number</span><br>    Add &#123;<br>        <span class="hljs-meta">#[arg(short, long)]</span><br>        num: <span class="hljs-type">u16</span>,<br>    &#125;,<br>    <span class="hljs-comment">/// Sub a number</span><br>    Sub &#123;<br>        <span class="hljs-meta">#[arg(short, long)]</span><br>        num: <span class="hljs-type">u16</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(test) = cli.test &#123;<br>        <span class="hljs-keyword">match</span> test &#123;<br>            Test::Add &#123;num&#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;test add num: &#123;:?&#125;&quot;</span>, num),<br>            Test::Sub &#123;num&#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;test sub num: &#123;:?&#125;&quot;</span>, num),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/subcommand --<span class="hljs-built_in">help</span>      <br>this is the about from Cargo.toml<br><br>Usage: subcommand [COMMAND]<br><br>Commands:<br>  add   Add a number<br>  sub   Sub a number<br>  <span class="hljs-built_in">help</span>  Print this message or the <span class="hljs-built_in">help</span> of the given subcommand(s)<br><br>Options:<br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br>➜  learn-clap git:(master) ✗ ./target/release/examples/subcommand add --<span class="hljs-built_in">help</span><br>Add a number<br><br>Usage: subcommand add --num &lt;NUM&gt;<br><br>Options:<br>  -n, --num &lt;NUM&gt;  <br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br>➜  learn-clap git:(master) ✗ ./target/release/examples/subcommand add -n 1  <br><span class="hljs-built_in">test</span> add num: 1<br>➜  learn-clap git:(master) ✗ ./target/release/examples/subcommand sub -n 2<br><span class="hljs-built_in">test</span> sub num: 2<br></code></pre></td></tr></table></figure><h3 id="参数校验">3. 参数校验</h3><h4 id="类型校验">3.1 类型校验</h4><p>可以发现，使用 Derive模式的时候，我们在参数后面指定参数类型的时候，<code>clap</code>就会对我们输入参数进行类型检查，不匹配的时候会输出丰富的报错信息和指导建议。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">error: invalid value <span class="hljs-string">&#x27;xxxx&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;--num &lt;NUM&gt;&#x27;</span>: invalid digit found <span class="hljs-keyword">in</span> string<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br></code></pre></td></tr></table></figure><p>默认支持：</p><ul><li>原生类型：<code>bool</code>, <code>String</code>,<code>OsString</code>,<code>PathBuf</code>、<code>usize</code>、<code>isize</code></li><li>范围数据：<code>u8</code>, <code>i8</code>, <code>u16</code>,<code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>,<code>i64</code></li><li>实现了 <code>ValueEnum</code> 的 enum 类型</li><li>实现了<code>From&lt;OsString&gt;</code>、<code>From&lt;&amp;OsStr&gt;</code>、<code>FromStr</code> 的类型</li></ul><p>这是因为他们都实现了 <code>TypedValueParser</code>trait，你自定义的类型也可以实现这个triat，这样就可以自动进行类型校验了。</p><p><code>clap</code> 还提供了一些更加严格的参数校验功能。👇🏻</p><h4 id="枚举校验">3.2 枚举校验</h4><p>对于实现 <code>ValueEnum</code>的枚举类型，如果输入的值不是枚举中定义的，则 <code>clap</code>会报错并提示可选值。</p><p>我们复用上面介绍「多选一参数」的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Parser, ValueEnum&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-comment">/// Choose the program mode run in</span><br>    <span class="hljs-meta">#[arg(value_enum)]</span><br>    mode: Mode,<br>&#125;<br><br><span class="hljs-meta">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Mode</span> &#123;<br>    <span class="hljs-comment">/// run in fast mode</span><br>    Fast,<br>    <span class="hljs-comment">/// run in slow mode</span><br>    Slow,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">match</span> cli.mode &#123;<br>        Mode::Fast =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;fast!!!!!&quot;</span>),<br>        Mode::Slow =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;slow......&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用错误的值进行尝试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/enum xxxx               <br>error: invalid value <span class="hljs-string">&#x27;xxxx&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;&lt;MODE&gt;&#x27;</span><br>  [possible values: fast, slow]<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br></code></pre></td></tr></table></figure><h4 id="范围校验">3.3 范围校验</h4><p>如果你想要实现数字类型范围限制的话，比如端口号参数的范围应该是 [1,65535]，那可以使用<code>value_parser! = clap::value_parser!(u16).range(1..)</code>来实现这个功能：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, value_parser = clap::value_parser!(u16).range(1..))]</span><br>    port: <span class="hljs-type">u16</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;port: &#123;:?&#125;&quot;</span>, cli.port);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/range --<span class="hljs-built_in">help</span>             <br>this is the about from Cargo.toml<br><br>Usage: range --port &lt;PORT&gt;<br><br>Options:<br>  -p, --port &lt;PORT&gt;  <br>  -h, --<span class="hljs-built_in">help</span>         Print <span class="hljs-built_in">help</span><br>  -V, --version      Print version<br>  <br>➜  learn-clap git:(master) ✗ ./target/release/examples/range -p 0  <br>error: invalid value <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;--port &lt;PORT&gt;&#x27;</span>: 0 is not <span class="hljs-keyword">in</span> 1..=65535<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/range -p 11111111<br>error: invalid value <span class="hljs-string">&#x27;11111111&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;--port &lt;PORT&gt;&#x27;</span>: 11111111 is not <span class="hljs-keyword">in</span> 1..=65535<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/range -p 1111    <br>port: 1111<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>value_parser = clap::value_parser!(u16).range(1..)</code>的含义可以分为两部分解释：</p><p><strong>1. clap::value_parser!(u16)</strong></p><p>这部分使用 <code>value_parser!</code> 宏为命令行参数指定了<code>u16</code> 类型的解析器。这意味着输入的参数值会被尝试解析为无符号16 位整数（<code>u16</code>）。如果输入不能被成功解析为 <code>u16</code>类型（例如，输入是非数字字符串或者数字过大/过小而不符合 <code>u16</code>的范围），<code>clap</code> 会报错并提示用户输入有效的参数值。</p><p><strong>2. .range(1..)</strong></p><p>这部分进一步限制了参数值的有效范围。<code>.range(1..)</code>指定了参数值必须大于或等于 1（包含 1），但没有上限。换句话说，任何小于 1的值都将被认为是无效的，<code>clap</code>会因此报错并要求用户输入一个符合范围要求的值。这在需要限定参数值为正数时非常有用。</p><p>结合起来，<code>value_parser = clap::value_parser!(u16).range(1..)</code>创建了一个规则，要求命令行参数必须是一个大于或等于 1 的 <code>u16</code>类型的数值。这在很多场景下都非常有用，比如当你需要用户指定一个正数端口号时。</p><p>在 RustRover 中，你可以在 Builder 模式，通过在<code>clap::value_parser!()</code> 中指定其他的类型，然后输入<code>.</code> 获得其他类型的内置校验规则。</p><h4 id="自定义校验">3.4 自定义校验</h4><p>对于更复杂的规则，<code>clap</code> 还支持自定义校验规则。比如上面对port 的校验，也可以自己实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::RangeInclusive;<br><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long, value_parser = parse_port)]</span><br>    port: <span class="hljs-type">u16</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> PORT_RANGE: RangeInclusive&lt;<span class="hljs-type">usize</span>&gt; = <span class="hljs-number">1</span>..=<span class="hljs-number">65535</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_port</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u16</span>, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">port</span>: <span class="hljs-type">usize</span> = s<br>        .<span class="hljs-title function_ invoke__">parse</span>()<br>        .<span class="hljs-title function_ invoke__">map_err</span>(|_| <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;`&#123;s&#125;` isn&#x27;t a port number`&quot;</span>))?;<br><br>    <span class="hljs-keyword">if</span> PORT_RANGE.<span class="hljs-title function_ invoke__">contains</span>(&amp;port) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(port <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-built_in">format!</span>(<br>            <span class="hljs-string">&quot;port not in range &#123;&#125;-&#123;&#125;&quot;</span>,<br>            PORT_RANGE.<span class="hljs-title function_ invoke__">start</span>(),<br>            PORT_RANGE.<span class="hljs-title function_ invoke__">end</span>(),<br>        ))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;port: &#123;:?&#125;&quot;</span>, cli.port);<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码中，我们直接使用 <code>value_parser = parse_port</code>来指定自定义的校验规则。</p><p>我们自定义的校验规则为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_port</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u16</span>, <span class="hljs-type">String</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>它需要满足：</p><ul><li>入参是 &amp;str</li><li>出参是 Result&lt;参数类型, String&gt;</li></ul><p>可以测试输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/custom --<span class="hljs-built_in">help</span><br>this is the about from Cargo.toml<br><br>Usage: custom --port &lt;PORT&gt;<br><br>Options:<br>  -p, --port &lt;PORT&gt;  <br>  -h, --<span class="hljs-built_in">help</span>         Print <span class="hljs-built_in">help</span><br>  -V, --version      Print version<br>  <br>➜  learn-clap git:(master) ✗ ./target/release/examples/custom -p xxx<br>error: invalid value <span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;--port &lt;PORT&gt;&#x27;</span>: `xxx` isn<span class="hljs-string">&#x27;t a port number`</span><br><span class="hljs-string"></span><br><span class="hljs-string">For more information, try &#x27;</span>--<span class="hljs-built_in">help</span><span class="hljs-string">&#x27;.</span><br><span class="hljs-string"></span><br><span class="hljs-string">➜  learn-clap git:(master) ✗ ./target/release/examples/custom -p 0  </span><br><span class="hljs-string">error: invalid value &#x27;</span>0<span class="hljs-string">&#x27; for &#x27;</span>--port &lt;PORT&gt;<span class="hljs-string">&#x27;: port not in range 1-65535</span><br><span class="hljs-string"></span><br><span class="hljs-string">For more information, try &#x27;</span>--<span class="hljs-built_in">help</span><span class="hljs-string">&#x27;.</span><br><span class="hljs-string"></span><br><span class="hljs-string">➜  learn-clap git:(master) ✗ ./target/release/examples/custom -p 9527</span><br><span class="hljs-string">port: 9527</span><br></code></pre></td></tr></table></figure><h4 id="关联参数">3.5 关联参数</h4><p>有时候参数直接还有关联关系，比如说：</p><ul><li>依赖：必须存在 <code>-a</code> 参数，<code>-b</code>参数才有意义，即要使用 <code>-b</code> 参数时，必须指定 <code>-a</code>参数。</li><li>互斥：<code>-a</code> 和 <code>-b</code> 只能同时存在一个。</li></ul><p><strong>可以使用 requires 实现依赖关系：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    a: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br><br>    <span class="hljs-meta">#[arg(short, long,requires = <span class="hljs-string">&quot;a&quot;</span>)]</span><br>    b: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a: &#123;:?&#125;&quot;</span>, cli.a);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;b: &#123;:?&#125;&quot;</span>, cli.b);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们在参数 <code>b</code> 中加入了<code>requires = "a"</code>，表示要使用 <code>b</code> 参数必须要有<code>a</code> 参数。</p><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/relation      <br>a: None<br>b: None<br>➜  learn-clap git:(master) ✗ ./target/release/examples/relation -b 1 <br>error: the following required arguments were not provided:<br>  --a &lt;A&gt;<br><br>Usage: relation --a &lt;A&gt; --b &lt;B&gt;<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/relation -a 1<br>a: Some(<span class="hljs-string">&quot;1&quot;</span>)<br>b: None<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/relation -a 1 -b 2<br>a: Some(<span class="hljs-string">&quot;1&quot;</span>)<br>b: Some(<span class="hljs-string">&quot;2&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>可以使用 #[group(required = true, mutiple = false)]来实现互斥关系：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Args, Parser&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[command(flatten)]</span><br>    args: Only,<br>&#125;<br><br><span class="hljs-meta">#[derive(Args, Debug)]</span><br><span class="hljs-meta">#[group(required = true, multiple = false)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Only</span> &#123;<br>    <span class="hljs-meta">#[arg(long)]</span><br>    a: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>    <span class="hljs-meta">#[arg(long)]</span><br>    b: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>    <span class="hljs-meta">#[arg(long)]</span><br>    c: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>    <span class="hljs-meta">#[arg(long)]</span><br>    d: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;only: &#123;:?&#125;&quot;</span>, cli.args)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>#[command(flattern)]</code> 直接将结构体里面的参数平铺。</p><p><code>#[group]</code>用于将一组参数归为一个组，<code>required = true</code> 表示必须提供该group 中的参数，<code>multiple = false</code>表示只能有一个参数被提供。</p><p>测试输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap git:(master) ✗ ./target/release/examples/only_one --<span class="hljs-built_in">help</span><br>this is the about from Cargo.toml<br><br>Usage: only_one &lt;--a &lt;A&gt;|--b &lt;B&gt;|--c &lt;C&gt;|--d &lt;D&gt;&gt;<br><br>Options:<br>      --a &lt;A&gt;    <br>      --b &lt;B&gt;    <br>      --c &lt;C&gt;    <br>      --d &lt;D&gt;    <br>  -h, --<span class="hljs-built_in">help</span>     Print <span class="hljs-built_in">help</span><br>  -V, --version  Print version<br>  <br>➜  learn-clap git:(master) ✗ ./target/release/examples/only_one       <br>error: the following required arguments were not provided:<br>  &lt;--a &lt;A&gt;|--b &lt;B&gt;|--c &lt;C&gt;|--d &lt;D&gt;&gt;<br><br>Usage: only_one &lt;--a &lt;A&gt;|--b &lt;B&gt;|--c &lt;C&gt;|--d &lt;D&gt;&gt;<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/only_one --a 1      <br>only: Only &#123; a: Some(<span class="hljs-string">&quot;1&quot;</span>), b: None, c: None, d: None &#125;<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/only_one --a 1 --b 2<br>error: the argument <span class="hljs-string">&#x27;--a &lt;A&gt;&#x27;</span> cannot be used with <span class="hljs-string">&#x27;--b &lt;B&gt;&#x27;</span><br><br>Usage: only_one &lt;--a &lt;A&gt;|--b &lt;B&gt;|--c &lt;C&gt;|--d &lt;D&gt;&gt;<br><br>For more information, try <span class="hljs-string">&#x27;--help&#x27;</span>.<br><br>➜  learn-clap git:(master) ✗ ./target/release/examples/only_one --b 2      <br>only: Only &#123; a: None, b: Some(<span class="hljs-string">&quot;2&quot;</span>), c: None, d: None &#125;<br></code></pre></td></tr></table></figure><h2 id="builder">Builder</h2><p>使用 <code>clap</code> 的 Builder模式，一般情况下不需要额外引入其他的 features：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add clap<br></code></pre></td></tr></table></figure><p>但是如果要使用 <code>command!</code> 来构建应用的话，需要引入<code>cargo</code> 这个 features：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add clap --features cargo<br></code></pre></td></tr></table></figure><h3 id="应用配置-1">1. 应用配置</h3><p>在 Builder 模式下，你可以使用 <code>command!()</code> 或<code>Command::new("appname")</code> 来构建一个命令行应用，其中<code>command!()</code> 默认将 appname 设置应用名称，而<code>Command::new()</code> 必须显示指定 appname。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, Arg, Command, command, value_parser&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// let matches = command!()</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;MyApp&quot;</span>)<br>        <span class="hljs-comment">// Application configuration</span><br>        .<span class="hljs-title function_ invoke__">version</span>(<span class="hljs-string">&quot;1.0.0&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">author</span>(<span class="hljs-string">&quot;hedon&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;This the intro of the cli application&quot;</span>)<br>        <span class="hljs-comment">// Application args</span><br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!([NAME]).<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your name&quot;</span>))<br>        .<span class="hljs-title function_ invoke__">arg</span>(<br>            Arg::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-title function_ invoke__">short</span>(<span class="hljs-string">&#x27;a&#x27;</span>).<span class="hljs-title function_ invoke__">long</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">u8</span>))<br>        )<br>    .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-comment">// Read and parse command args</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(name) = matches.get_one::&lt;<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;NAME&quot;</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value for name: &#123;name&#125;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(age) = matches.get_one::&lt;<span class="hljs-type">u8</span>&gt;(<span class="hljs-string">&quot;age&quot;</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value for age: &#123;age&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码分为以下几个部分：</p><p><strong>1. 创建命令行应用实例</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;MyApp&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里使用 <code>Command::new</code>方法创建了一个新的命令行应用实例，命名为 <code>"MyApp"</code>。</p><p><strong>2. 配置应用</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">version</span>(<span class="hljs-string">&quot;1.0.0&quot;</span>)<br>.<span class="hljs-title function_ invoke__">author</span>(<span class="hljs-string">&quot;hedon&quot;</span>)<br>.<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;This the intro of the cli application&quot;</span>)<br></code></pre></td></tr></table></figure><p>接下来，使用链式调用方法配置应用的版本号为<code>"1.0.0"</code>，作者为<code>"hedon"</code>，并添加了一个简短的描述。</p><p>这里等价于 Builder 模式下的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[command(version, author, about)]</span><br></code></pre></td></tr></table></figure><p><strong>3. 添加命令行参数</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!([NAME]).<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your name&quot;</span>))<br>.<span class="hljs-title function_ invoke__">arg</span>(<br>    Arg::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-title function_ invoke__">short</span>(<span class="hljs-string">&#x27;a&#x27;</span>).<span class="hljs-title function_ invoke__">long</span>(<span class="hljs-string">&quot;age&quot;</span>).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">u8</span>))<br>)<br></code></pre></td></tr></table></figure><p>这部分代码添加了两个命令行参数： -<code>.arg(arg!([NAME]).required(true).help("Specify your name"))</code>使用 <code>arg!</code> 宏添加了一个名为 <code>NAME</code>的必需参数，并提供了一些帮助信息。 -<code>.arg(Arg::new("age").short('a').long("age").value_parser(value_parser!(u8)))</code>创建了另一个参数 <code>age</code>，可以通过 <code>-a</code> 或<code>--age</code> 来指定。这个参数使用了 <code>value_parser</code>宏来指明它的值应被解析为 <code>u8</code> 类型的数字。</p><p><strong>4. 解析命令行参数</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">get_matches</span>();<br></code></pre></td></tr></table></figure><p>使用 <code>.get_matches()</code> 方法来解析命令行参数并将结果存储在<code>matches</code> 变量中。</p><p><strong>5. 读取并打印参数值</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(name) = matches.get_one::&lt;<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;NAME&quot;</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value for name: &#123;name&#125;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(age) = matches.get_one::&lt;<span class="hljs-type">u8</span>&gt;(<span class="hljs-string">&quot;age&quot;</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value for age: &#123;age&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，使用 <code>matches.get_one::&lt;T&gt;("arg_name")</code>方法尝试获取指定名称的参数值。如果成功找到，则将其打印出来。这里分别尝试获取<code>"NAME"</code> 和 <code>"age"</code> 参数的值，并使用<code>println!</code> 宏将它们打印到控制台。</p><p>使用 <code>-- help</code> 测试输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">This the intro of the cli application<br><br>Usage: app2 [OPTIONS] [NAME]<br><br>Arguments:<br>  [NAME]  Specify your name<br><br>Options:<br>  -a, --age &lt;AGE&gt;  <br>  -h, --<span class="hljs-built_in">help</span>       Print <span class="hljs-built_in">help</span><br>  -V, --version    Print version<br></code></pre></td></tr></table></figure><p>你可以将其与「Derive -应用配置」进行比较，应该很容易找到它们之间的对应关系。</p><p>在 Derive 中 <code>#[command]</code> 和 <code>#[arg]</code>支持的属性，都可以在 Builder中找到对应的同名的函数，这里就不赘述了。</p><h3 id="参数类型-1">2. 参数类型</h3><p>在 Builder 模式中，配置参数有两种方式：</p><ul><li>arg!([-short] [--long] id)</li><li>Args::new("id").short('s').long("long")</li></ul><h4 id="arguments-options-1">2.1 Arguments &amp; Options</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Arguments:<br>  [NAME]  Specify your name<br><br>Options:<br>  -a, --age &lt;AGE&gt;  <br></code></pre></td></tr></table></figure><ul><li><strong>Argument:</strong> 不包含 <code>-&#123;short&#125;</code> 和<code>--&#123;long&#125;</code>。</li><li><strong>Options:</strong> 包含 <code>-&#123;short&#125;</code> 或<code>--&#123;long&#125;</code>。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!([NAME]).<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;Specify your name&quot;</span>))<br>.<span class="hljs-title function_ invoke__">arg</span>(arg!(-a --age &lt;AGE&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">u16</span>)))<br></code></pre></td></tr></table></figure><h4 id="可选参数-1">2.2 可选参数</h4><p>根据约定，<code>&lt;&gt;</code> 表示必须，而 <code>[]</code>表示可选：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;NAME&gt;)   <span class="hljs-comment">// 必须</span><br>.<span class="hljs-title function_ invoke__">arg</span>(arg!([ADDRESS]))  <span class="hljs-comment">// 可选</span><br></code></pre></td></tr></table></figure><p>你也可以使用 <code>.required(bool)</code> 函数明确指出是否必须：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;NAME&gt;).<span class="hljs-title function_ invoke__">required</span>(<span class="hljs-literal">true</span>))<br></code></pre></td></tr></table></figure><p><code>.required()</code> 的优先级高于 <code>&lt;&gt;</code> 和<code>[]</code>，但是建议你在构建的时候还是遵循约定。</p><h4 id="枚举参数-1">2.3 枚举参数</h4><p><strong>第 1 种：在 value_parser()中直接指定可选的枚举参数</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;MODE&gt;).<span class="hljs-title function_ invoke__">value_parser</span>([<span class="hljs-string">&quot;fast, slow&quot;</span>]))<br></code></pre></td></tr></table></figure><p><strong>第 2 种：使用枚举，但是枚举需要实现 ValueEnumtrait</strong></p><p>这里又有 2 种方式，你可以向 Derive 一样引入 <code>derive</code>features，然后直接 <code>#[derive(ValueElem)]</code>使用默认实现，也可以手动实现。我更倾向于前者。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, command, value_parser, ValueEnum&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = command!()<br>        <span class="hljs-comment">// .arg(arg!(&lt;MODE&gt;).value_parser([&quot;fast, slow&quot;]))</span><br>        .<span class="hljs-title function_ invoke__">arg</span>(<br>            arg!(&lt;MODE&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(Mode)).<span class="hljs-title function_ invoke__">required</span>(<span class="hljs-literal">true</span>)<br>        )<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-keyword">match</span> matches.get_one::&lt;Mode&gt;(<span class="hljs-string">&quot;MODE&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;&#x27;Mode&#x27; is required and parsing will fail if its missing&quot;</span>)&#123;<br>        Mode::Fast =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;fast&quot;</span>),<br>        Mode::Slow =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;slow&quot;</span>),<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, ValueEnum)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Mode</span> &#123;<br>    <span class="hljs-comment">/// Run in fast mode</span><br>    Fast,<br>    <span class="hljs-comment">/// Run in slow mode</span><br>    Slow,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="累计参数-1">2.4 累计参数</h4><p>使用 <code>clap::ArgAction::Count</code> 设置参数为累计参数，然后使用<code>get_count(id)</code> 获取参数的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, command&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = command!()<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(-v --verbose...).<span class="hljs-title function_ invoke__">action</span>(clap::ArgAction::Count))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;v count: &#123;:?&#125;&quot;</span>, matches.<span class="hljs-title function_ invoke__">get_count</span>(<span class="hljs-string">&quot;verbose&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，<code>arg!()</code> 中参数的定义，也要符合累计参数的格式<code>-&#123;short&#125; --&#123;long&#125;...</code>。</p><h4 id="变长参数-1">2.5 变长参数</h4><p>使用 <code>clap::ArgAction::Append</code>设置参数为变长参数，然后使用 <code>get_many::&lt;类型&gt;("id")</code>获取参数的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, Command&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;append-application&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!([FILES]...).<span class="hljs-title function_ invoke__">action</span>(clap::ArgAction::Append))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">files</span> = matches<br>        .get_many::&lt;<span class="hljs-type">String</span>&gt;(<span class="hljs-string">&quot;FILES&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">unwrap_or_default</span>()<br>        .<span class="hljs-title function_ invoke__">map</span>(|v|v.<span class="hljs-title function_ invoke__">as_str</span>())<br>        .collect::&lt;<span class="hljs-type">Vec</span>&lt;_&gt;&gt;();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;files: &#123;:?&#125;&quot;</span>, files);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，<code>arg!()</code> 中参数的定义，也要符合变长参数的格式<code>[arg]|&lt;arg&gt;...</code>。</p><h4 id="标志参数-1">2.6 标志参数</h4><p>使用 <code>clap::ArgAction::SetTrue</code> 或<code>clap::ArgAction::SetFalse</code> 设置参数为标志参数，然后使用<code>get_flag()</code> 获取参数的值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, command&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = command!()<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(-d --debug).<span class="hljs-title function_ invoke__">action</span>(clap::ArgAction::SetTrue))<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(-v --verbose).<span class="hljs-title function_ invoke__">action</span>(clap::ArgAction::SetFalse))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;debug: &#123;:?&#125;&quot;</span>, matches.<span class="hljs-title function_ invoke__">get_flag</span>(<span class="hljs-string">&quot;debug&quot;</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;verbose: &#123;:?&#125;&quot;</span>, matches.<span class="hljs-title function_ invoke__">get_flag</span>(<span class="hljs-string">&quot;verbose&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>clap::ArgAction::SetTrue</code> : 设置参数的话，则为true，否则 false（默认）。</li><li><code>clap::ArgAction::SetFalse</code> : 设置参数的话，则为false，否则 true（默认）。</li></ul><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  learn-clap-builder git:(master) ✗ ./target/release/examples/flag      <br>debug: <span class="hljs-literal">false</span><br>verbose: <span class="hljs-literal">true</span><br>➜  learn-clap-builder git:(master) ✗ ./target/release/examples/flag -d   <br>debug: <span class="hljs-literal">true</span><br>verbose: <span class="hljs-literal">true</span><br>➜  learn-clap-builder git:(master) ✗ ./target/release/examples/flag -v   <br>debug: <span class="hljs-literal">false</span><br>verbose: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h4 id="子命令-1">2.7 子命令</h4><p>可以使用 <code>subcommand(sub_cmd)</code> 和<code>subcommand([sub_cmd1, sub_cmd2])</code>来添加子命令，解析的时候使用 <code>matches.subcommand()</code>匹配子命令，再按照之前的规则解析子命令中对应的参数即可。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;arg, Command, value_parser&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;myapp&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">subcommands</span>([<br>            Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;add&quot;</span>)<br>                .<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;NUM&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">i16</span>))),<br>            Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;sub&quot;</span>)<br>                .<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;NUM&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">i16</span>))),<br>        ])<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-keyword">match</span> matches.<span class="hljs-title function_ invoke__">subcommand</span>() &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-string">&quot;add&quot;</span>, add_cmd)) =&gt; <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;&#x27;myapp add&#x27; was used, num is: &#123;:?&#125;&quot;</span>,<br>            add_cmd.get_one::&lt;<span class="hljs-type">i16</span>&gt;(<span class="hljs-string">&quot;NUM&quot;</span>),<br>        ),<br>        <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-string">&quot;sub&quot;</span>, sub_cmd)) =&gt; <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;&#x27;myapp sub&#x27; was used, num is: &#123;:?&#125;&quot;</span>,<br>            sub_cmd.get_one::&lt;<span class="hljs-type">i16</span>&gt;(<span class="hljs-string">&quot;NUM&quot;</span>),<br>        ),<br>        _ =&gt; <span class="hljs-built_in">unreachable!</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参数校验-1">3. 参数校验</h3><h4 id="类型校验-1">3.1 类型校验</h4><p>使用 <code>value_parser!()</code> 在括号中指定类型，<code>clap</code>就会自动帮我们对参数进行类型校验，当然你在获取参数值<code>get_one::&lt;类型&gt;()</code> 的时候，类型要对上，否则会panic。</p><p>默认支持：</p><ul><li>原生类型：<code>bool</code>, <code>String</code>,<code>OsString</code>,<code>PathBuf</code>、<code>usize</code>、<code>isize</code></li><li>范围数据：<code>u8</code>, <code>i8</code>, <code>u16</code>,<code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>,<code>i64</code></li><li>实现了 <code>ValueEnum</code> 的 enum 类型</li><li>实现了<code>From&lt;OsString&gt;</code>、<code>From&lt;&amp;OsStr&gt;</code>、<code>FromStr</code> 的类型</li></ul><h4 id="枚举校验-1">3.2 枚举校验</h4><p>2.3 中枚举参数的说明中，已经体现了枚举校验的功能了，这里不赘述。</p><h4 id="范围校验-1">3.3 范围校验</h4><p>对于上述提到的「范围数据」，可以使用<code>value_parser!(类型).range()</code> 进行范围校验。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">arg!(&lt;PORT&gt;)<br>  .<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(<span class="hljs-type">u16</span>).<span class="hljs-title function_ invoke__">range</span>(<span class="hljs-number">1</span>..))<br></code></pre></td></tr></table></figure><h4 id="自定义校验-1">3.4 自定义校验</h4><p><code>value_parser()</code>中也可以传自定义的校验函数，该函数的签名需要满足的条件跟我们在介绍Derive 时一样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::RangeInclusive;<br><span class="hljs-keyword">use</span> clap::&#123;arg, command&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">matches</span> = command!()<br>        .<span class="hljs-title function_ invoke__">arg</span>(arg!(&lt;PORT&gt;).<span class="hljs-title function_ invoke__">value_parser</span>(port_in_range))<br>        .<span class="hljs-title function_ invoke__">get_matches</span>();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;port: &#123;:?&#125;&quot;</span>, matches.get_one::&lt;<span class="hljs-type">u16</span>&gt;(<span class="hljs-string">&quot;PORT&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">const</span> PORT_RANGE: RangeInclusive&lt;<span class="hljs-type">usize</span>&gt; = RangeInclusive::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>, <span class="hljs-number">65535</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">port_in_range</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u16</span>, <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">port</span>: <span class="hljs-type">usize</span> = s<br>        .<span class="hljs-title function_ invoke__">parse</span>()<br>        .<span class="hljs-title function_ invoke__">map_err</span>(|_|<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;`&#123;s&#125;` is not a port number&quot;</span>))?;<br>    <span class="hljs-keyword">if</span> PORT_RANGE.<span class="hljs-title function_ invoke__">contains</span>(&amp;port) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(port <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-built_in">format!</span>(<br>            <span class="hljs-string">&quot;port not in range &#123;&#125;-&#123;&#125;&quot;</span>,<br>            PORT_RANGE.<span class="hljs-title function_ invoke__">start</span>(),<br>            PORT_RANGE.<span class="hljs-title function_ invoke__">end</span>(),<br>        ))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关联参数-1">3.5 关联参数</h4><ul><li><strong>依赖关系：</strong>使用<code>requires(id | group)</code></li><li><strong>排斥关系</strong>：使用<code>group().multiple(false).required(true)</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust">.<span class="hljs-title function_ invoke__">group</span>(<br>    ArgGroup::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;vers&quot;</span>)<br>  <span class="hljs-comment">// 表示 &quot;set-ver&quot;, &quot;major&quot;, &quot;minor&quot;, &quot;patch&quot; 必须有一个且只能有一个存在</span><br>        .<span class="hljs-title function_ invoke__">multiple</span>(<span class="hljs-literal">false</span>)<br>        .<span class="hljs-title function_ invoke__">required</span>(<span class="hljs-literal">true</span>)<br>        .<span class="hljs-title function_ invoke__">args</span>([<span class="hljs-string">&quot;set-ver&quot;</span>, <span class="hljs-string">&quot;major&quot;</span>, <span class="hljs-string">&quot;minor&quot;</span>, <span class="hljs-string">&quot;patch&quot;</span>]),<br>)<br>.<span class="hljs-title function_ invoke__">arg</span>(<br>    arg!([INPUT_FILE] <span class="hljs-string">&quot;some regular input&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(PathBuf))<br>        .<span class="hljs-title function_ invoke__">group</span>(<span class="hljs-string">&quot;input&quot;</span>),<br>)<br>.<span class="hljs-title function_ invoke__">arg</span>(<br>    arg!(config: -c &lt;CONFIG&gt;)<br>        .<span class="hljs-title function_ invoke__">value_parser</span>(value_parser!(PathBuf))<br>   <span class="hljs-comment">// 表示 -c 需要有 group 为 input 的命令存在才可以使用</span><br>        .<span class="hljs-title function_ invoke__">requires</span>(<span class="hljs-string">&quot;input&quot;</span>),<br>)<br></code></pre></td></tr></table></figure><h2 id="derive-vs-builder-2-对比">Derive vs Builder (2) 对比</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/screencapture-wepie-feishu-cn-wiki-Bdb3wl4cViE6hqkUuykctkrqn8i-2024-03-01-20_52_38.png"alt="Derive vs Builder" /><figcaption aria-hidden="true">Derive vs Builder</figcaption></figure><h2 id="clap-rpassword-实现加密输入">clap + rpassword 实现加密输入</h2><p>对于密码、密钥等关键信息的输入，为了信息安全，我们一般会使用加密输出，<code>clap</code>本身不支持加密输入功能。若你有这方面的需求，可以使用<code>rpassword</code> crate 辅助完成。</p><p>示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::Parser;<br><span class="hljs-keyword">use</span> rpassword::read_password;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(version, author, about, long_about = None)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[arg(short, long)]</span><br>    username: <span class="hljs-type">String</span>,<br><br>    <span class="hljs-meta">#[arg(short, long, required = true)]</span><br>    password: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">password</span> = <span class="hljs-keyword">if</span> cli.password &#123;<br>        <span class="hljs-comment">// Prompt user to enter password</span><br>        <span class="hljs-title function_ invoke__">read_password</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to read password&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-string">&quot;&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()<br>    &#125;;<br><br>    <span class="hljs-comment">// Use username and password to do something</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;username: &#123;&#125;, password: &#123;&#125;&quot;</span>, cli.username, password);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="clap_complete-实现自动补全">clap_complete 实现自动补全</h2><p>要实现自动补全，需要在 <code>.zshrc</code> 或 <code>.bashrc</code> 等<code>SHELL</code> 文件中加入命令自动补全脚本。这时候可以使用<code>clap_complete</code> 来实现这个功能。</p><p>下面的示例目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── Cargo.lock<br>├── Cargo.toml<br>├── build.rs<br>└── src<br>    ├── cli.rs<br>    └── main.rs<br></code></pre></td></tr></table></figure><p>首先我们需要引入 <code>clap</code> 和 <code>clap_complete</code>crate，其中 <code>clap_complete</code> 只需在 build环境下即可，所以我们的 <code>Cargo.tmol</code> 如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;myapp&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-attr">build</span> = <span class="hljs-string">&quot;build.rs&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.1&quot;</span> &#125;<br><span class="hljs-attr">dirs</span> = <span class="hljs-string">&quot;5.0.1&quot;</span><br><br><span class="hljs-section">[build-dependencies]</span><br><span class="hljs-attr">clap</span> = &#123; version = <span class="hljs-string">&quot;4.5.1&quot;</span>&#125;<br><span class="hljs-attr">clap_complete</span> = <span class="hljs-string">&quot;4.5.1&quot;</span><br></code></pre></td></tr></table></figure><p>我们先在 <code>src/cli.rs</code> 中实现一个简单的命令行程序<strong>myapp</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123;Arg, ArgAction, Command&#125;;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_cli</span>() <span class="hljs-punctuation">-&gt;</span> Command &#123;<br>    Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;myapp&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;Tests completions&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">arg</span>(Arg::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;file&quot;</span>)<br>            .<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;some input file&quot;</span>))<br>        .<span class="hljs-title function_ invoke__">subcommand</span>(Command::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;test&quot;</span>)<br>            .<span class="hljs-title function_ invoke__">about</span>(<span class="hljs-string">&quot;tests things&quot;</span>)<br>            .<span class="hljs-title function_ invoke__">arg</span>(Arg::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;case&quot;</span>)<br>                .<span class="hljs-title function_ invoke__">long</span>(<span class="hljs-string">&quot;case&quot;</span>)<br>                .<span class="hljs-title function_ invoke__">action</span>(ArgAction::Set)<br>                .<span class="hljs-title function_ invoke__">help</span>(<span class="hljs-string">&quot;the case to test&quot;</span>)))<br>&#125;<br></code></pre></td></tr></table></figure><p>我们主要是演示这个自动补全功能，为了省事，<code>src/main.rs</code>中就不实现具体逻辑了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> cli;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_m</span> = cli::<span class="hljs-title function_ invoke__">build_cli</span>().<span class="hljs-title function_ invoke__">get_matches</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们在项目根目录下实现<code>build.rs</code>，它将为我们指定的命令生成自动补全脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> build.rs<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap_complete::&#123;generate_to, shells::Bash&#125;;<br><span class="hljs-keyword">use</span> std::env;<br><span class="hljs-keyword">use</span> std::io::Error;<br><br>include!(<span class="hljs-string">&quot;src/cli.rs&quot;</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">outdir</span> = <span class="hljs-keyword">match</span> env::<span class="hljs-title function_ invoke__">var_os</span>(<span class="hljs-string">&quot;OUT_DIR&quot;</span>) &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Ok</span>(()),<br>        <span class="hljs-title function_ invoke__">Some</span>(outdir) =&gt; outdir,<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cmd</span> = <span class="hljs-title function_ invoke__">build_cli</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = <span class="hljs-title function_ invoke__">generate_to</span>(<br>        Bash,<br>        &amp;<span class="hljs-keyword">mut</span> cmd, <span class="hljs-comment">// We need to specify what generator to use</span><br>        <span class="hljs-string">&quot;myapp&quot;</span>,  <span class="hljs-comment">// We need to specify the bin name manually</span><br>        outdir,   <span class="hljs-comment">// We need to specify where to write to</span><br>    )?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;cargo:warning=completion file is generated: &#123;path:?&#125;&quot;</span>);<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>你需要把其中的 <strong>myapp</strong> 替换为你的命令。</p><p>执行构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build<br></code></pre></td></tr></table></figure><p>可以看到输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">warning: myapp@0.1.0: completion file is generated: <span class="hljs-string">&quot;/Users/hedon/RustroverProjects/learn-clap-complete/target/debug/build/myapp-42e401d08c044ca3/out/myapp.bash&quot;</span><br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 1.90s<br></code></pre></td></tr></table></figure><p>这里会输出生成脚本所在的位置，我这里是<code>/Users/hedon/RustroverProjects/learn-clap-complete/target/debug/build/myapp-42e401d08c044ca3/out/myapp.bash</code>。</p><p>我的终端使用的是 zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span>      <br>/bin/zsh<br></code></pre></td></tr></table></figure><p>所以我需要将这个文件的内容加到 <code>~/.zshrc</code> 文件的末尾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /Users/hedon/RustroverProjects/learn-clap-complete/target/debug/build/myapp-42e401d08c044ca3/out/myapp.bash &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure><p>重新加载配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><p>这个时候你使用 <strong>myapp</strong> 命令的时候，按 <code>tap</code>键，就有自动补全了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ./target/debug/myapp <br>--<span class="hljs-built_in">help</span>    -h        \[file\]  <span class="hljs-built_in">help</span>      <span class="hljs-built_in">test</span> <br></code></pre></td></tr></table></figure><h1 id="httpie">HTTPie</h1><p>由于篇幅原因，实战 HTTPie 部分请看：<ahref="https://hedon.top/2024/03/06/rust-action-httpie/">Rust实战丨HTTPie</a></p><h1 id="与-go-语言-cobra-比较">与 Go 语言 cobra 比较</h1><p>Go 的 <code>cobra</code> 也是用于构建命令行应用程序的库，它在 Go语言生态中非常受欢迎。</p><p>为了直观展示这 2个库构建命令行应用程序的区别，我们来设计一个简单的命令行程序，用<code>clap</code> 和 <code>cobra</code>分别实现，以展示如何用这两个库实现相同的功能。</p><p>让我们创建一个 CLI 程序，它有一个 <code>greet</code> 子命令，接受一个<code>-n</code> 或 <code>--name</code> 参数，并打印出一条欢迎信息。</p><h2 id="rust-clap-实现">Rust clap 实现</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> clap::&#123; Parser, Subcommand&#125;;<br><br><span class="hljs-meta">#[derive(Parser)]</span><br><span class="hljs-meta">#[command(bin_name = <span class="hljs-string">&quot;greet_app&quot;</span>)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cli</span> &#123;<br>    <span class="hljs-meta">#[command(subcommand)]</span><br>    sub: <span class="hljs-type">Option</span>&lt;Sub&gt;,<br>&#125;<br><br><span class="hljs-meta">#[derive(Subcommand)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Sub</span> &#123;<br>    Greet &#123;<br>        <span class="hljs-meta">#[arg(short, long)]</span><br>        name: <span class="hljs-type">String</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cli</span> = Cli::<span class="hljs-title function_ invoke__">parse</span>();<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(sub) = cli.sub &#123;<br>        <span class="hljs-keyword">match</span> sub &#123;<br>            Sub::Greet&#123;name&#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;greeting: &#123;:?&#125;&quot;</span>, name),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="go-cobra-实现">Go cobra 实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><br><span class="hljs-string">&quot;github.com/spf13/cobra&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> rootCmd = &amp;cobra.Command&#123;<br>Use:   <span class="hljs-string">&quot;greet_app&quot;</span>,<br>Short: <span class="hljs-string">&quot;A simple greeting application&quot;</span>,<br>Long:  <span class="hljs-string">`This is a simple greeting application with a greet command.`</span>,<br>&#125;<br><br><span class="hljs-keyword">var</span> greetCmd = &amp;cobra.Command&#123;<br>Use:   <span class="hljs-string">&quot;greet&quot;</span>,<br>Short: <span class="hljs-string">&quot;Greets a user&quot;</span>,<br>Long:  <span class="hljs-string">`Prints a greeting message for the specified user.`</span>,<br>Run: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cmd *cobra.Command, args []<span class="hljs-type">string</span>)</span></span> &#123;<br>name, _ := cmd.Flags().GetString(<span class="hljs-string">&quot;name&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;Hello, %s!\n&quot;</span>, name)<br>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>rootCmd.AddCommand(greetCmd)<br>greetCmd.Flags().StringP(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;Sets the name to greet&quot;</span>)<br>greetCmd.MarkFlagRequired(<span class="hljs-string">&quot;name&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := rootCmd.Execute(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">This is a simple greeting application with a greet <span class="hljs-built_in">command</span>.<br><br>Usage:<br>  greet_app [<span class="hljs-built_in">command</span>]<br><br>Available Commands:<br>  completion  Generate the autocompletion script <span class="hljs-keyword">for</span> the specified shell<br>  greet       Greets a user<br>  <span class="hljs-built_in">help</span>        Help about any <span class="hljs-built_in">command</span><br><br>Flags:<br>  -h, --<span class="hljs-built_in">help</span>   <span class="hljs-built_in">help</span> <span class="hljs-keyword">for</span> greet_app<br><br>Use <span class="hljs-string">&quot;greet_app [command] --help&quot;</span> <span class="hljs-keyword">for</span> more information about a <span class="hljs-built_in">command</span>.<br></code></pre></td></tr></table></figure><h2 id="对比">对比</h2><h3 id="设计哲学和易用性">设计哲学和易用性</h3><p><strong>clap</strong>:</p><ul><li>使用 Rust 的宏来提供强大的编译时功能，如参数解析、验证等。</li><li>利用 Rust 的类型安全特性，减少运行时错误。</li><li>支持通过派生宏自动从结构体生成命令行解析代码，简化开发流程。</li></ul><p><strong>cobra</strong>:</p><ul><li>采用更传统的命令式编程模型，直观且易于上手。</li><li>通过组合命令对象来构建复杂的命令行应用。</li><li>提供了一套完整的生成工具来创建命令和配置，促进了开发速度。</li></ul><h3 id="功能和特性">功能和特性</h3><p><strong>clap</strong>:</p><ul><li>自动生成帮助信息、版本信息等。</li><li>支持多级子命令。</li><li>支持自定义验证器和复杂的参数关系（如互斥、依赖等）。</li></ul><p><strong>cobra</strong>:</p><ul><li>支持自动生成帮助文档。</li><li><strong>内置命令自动补全脚本生成功能</strong>。</li><li><strong>支持持久化命令行标志到配置文件</strong>。</li><li>通过插件支持增加额外的子命令。</li><li>能够轻松地与其他 Go 库集成，如 Viper 用于配置管理。</li></ul><h3 id="性能">性能</h3><p><strong>clap</strong>:</p><ul><li>由于 Rust 的编译时优化，<code>clap</code>在解析命令行参数时通常会有更好的性能。</li><li>更少的运行时开销，尤其是在处理大量复杂命令行参数时。</li></ul><p><strong>cobra</strong>:</p><ul><li>性能对于大多数命令行应用来说已经足够，但可能不如 <code>clap</code>优化。</li><li>Go 的运行时可能会引入额外的开销，尤其是在并发处理时。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 常用库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>clap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust reqwest 简明教程</title>
    <link href="/2024/03/02/rust-crate-reqwest/"/>
    <url>/2024/03/02/rust-crate-reqwest/</url>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p><code>reqwest</code> 是 Rust 中一个非常流行和强大的 HTTP客户端库，它提供了一种简单的方式来发送 HTTP请求并处理响应。<code>reqwest</code>支持阻塞和非阻塞（异步）请求，使其适合于各种不同的应用场景。在这篇博文中，我们将详细介绍如何使用<code>reqwest</code> 发送各种 HTTP 请求，并处理返回的响应。</p><h2 id="开始之前">开始之前</h2><p>在开始编写代码之前，你需要在你的 Rust 项目中添加 <code>reqwest</code>依赖。打开你的 <code>Cargo.toml</code> 文件，并添加以下内容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">reqwest</span> = &#123; version = <span class="hljs-string">&quot;0.12.4&quot;</span>, features = [<span class="hljs-string">&quot;json&quot;</span>] &#125;<br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1&quot;</span>, features = [<span class="hljs-string">&quot;full&quot;</span>] &#125;<br><span class="hljs-attr">serde</span> = &#123; version = <span class="hljs-string">&quot;1.0.197&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>] &#125;<br><span class="hljs-attr">serde_json</span> = <span class="hljs-string">&quot;1.0.114&quot;</span><br></code></pre></td></tr></table></figure><p>这里我们还添加了其他几个依赖：</p><ul><li><code>tokio</code>: 在后面的示例中，我们将使用 <code>reqwest</code>的异步功能。</li><li><code>serde</code>: 用于数据解析，在示例中，我们会演示 json数据的解析。</li><li><code>serde_json</code>: 便于使用 <code>json!</code> 宏快速构建 json数据。</li></ul><h2 id="发送-get-请求">发送 GET 请求</h2><p>发送一个 GET 请求是最基本的 HTTP 操作。以下是如何使用<code>reqwest</code> 发送 GET 请求并设置请求头的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest::header;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">params</span> = [(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>), (<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;values&quot;</span>)];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = reqwest::Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = client<br>        .<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;http://httpbin.org/get&quot;</span>)<br>        <span class="hljs-comment">// set query params</span><br>        .form(&amp;params)<br>        <span class="hljs-comment">// set request headers</span><br>        .<span class="hljs-title function_ invoke__">header</span>(header::USER_AGENT, <span class="hljs-string">&quot;My Rust Program&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">header</span>(header::CONTENT_TYPE, <span class="hljs-string">&quot;application/json&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">send</span>()<br>        .<span class="hljs-keyword">await</span>?<br>        .<span class="hljs-title function_ invoke__">text</span>()<br>        .<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;body = &#123;:?&#125;&quot;</span>, body);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用 <code>reqwest::get</code> 函数发送一个 GET请求到 "https://httpbin.org/get"，并通过 <code>text</code>方法获取响应的文本内容。</p><h2 id="发送-post---text-请求">发送 POST - text 请求</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest::Client;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = client.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&quot;http://httpbin.org/post&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">body</span>(<span class="hljs-string">&quot;the exact body that is sent&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">send</span>()<br>        .<span class="hljs-keyword">await</span>?<br>        .<span class="hljs-title function_ invoke__">text</span>()<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;body: &#123;:?&#125;&quot;</span>, res);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="发送-post---form-请求">发送 POST - form 请求</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">params</span> = [(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>), (<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;values&quot;</span>)];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = reqwest::Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = client.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&quot;http://httpbin.org/post&quot;</span>)<br>        .form(&amp;params)<br>        .<span class="hljs-title function_ invoke__">send</span>()<br>        .<span class="hljs-keyword">await</span>?<br>        .<span class="hljs-title function_ invoke__">text</span>()<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;body: &#123;:?&#125;&quot;</span>, res);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="发送-post---json-请求">发送 POST - json 请求</h2><p>发送 POST 请求通常用于向服务器提交数据。以下是如何使用<code>reqwest</code> 发送包含 JSON 数据的 POST 请求的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest;<br><span class="hljs-keyword">use</span> serde_json::json;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">client</span> = reqwest::Client::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = client.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&quot;https://httpbin.org/post&quot;</span>)<br>        .<span class="hljs-title function_ invoke__">json</span>(&amp;json!(&#123;<span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;value&quot;</span>&#125;))<br>        .<span class="hljs-title function_ invoke__">send</span>()<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = res.<span class="hljs-title function_ invoke__">text</span>().<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Body:\n&#123;&#125;&quot;</span>, body);<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们使用 <code>Client::post</code> 方法创建一个 POST 请求，并通过<code>json</code> 方法设置 JSON 负载。然后，我们调用 <code>send</code>方法发送请求。</p><h2 id="处理-json-响应">处理 JSON 响应</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> reqwest;<br><span class="hljs-keyword">use</span> serde::Deserialize;<br><br><span class="hljs-meta">#[derive(Deserialize)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ip</span> &#123;<br>    origin: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), reqwest::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ip</span>: Ip = reqwest::<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;https://httpbin.org/ip&quot;</span>)<br>        .<span class="hljs-keyword">await</span>?<br>        .<span class="hljs-title function_ invoke__">json</span>()<br>        .<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;IP: &#123;&#125;&quot;</span>, ip.origin);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个 <code>Ip</code> 结构体来表示 JSON响应，然后使用 <code>json</code> 方法将响应反序列化为 <code>Ip</code>类型。</p><h2 id="总结">总结</h2><p><code>reqwest</code> 库为 Rust 提供了一个功能丰富而灵活的 HTTP客户端，适用于各种网络编程任务。无论是简单的数据获取还是复杂的 API交互，<code>reqwest</code> 都能帮助你以简洁的 Rust代码完成任务。希望这篇博文能帮助你开始使用 <code>reqwest</code>来开发网络相关的 Rust 应用！</p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 常用库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出 Go 语言的 GPM 模型（Go1.21）</title>
    <link href="/2024/01/20/go-gpm/"/>
    <url>/2024/01/20/go-gpm/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>在现代软件开发中，有效地利用并发是提高应用性能和响应速度的关键。随着多核处理器的普及，编程语言和框架如何高效、简便地支持并发编程，成为了软件工程师们评估和选择工具时的一个重要考量。在这方面，Go语言凭借其创新的并发模型—GPM（Goroutine, P,M）—在众多编程语言中脱颖而出，为开发者提供了强大的工具，以简单、高效的方式实现并发。</p><p>自从 2009 年首次发布以来，Go语言就以其出色的性能、简洁的语法和对并发的原生支持赢得了广泛的关注。尤其是其并发模型，被设计为能够充分利用现代多核处理器的能力，同时隐藏底层的线程管理和同步复杂性，让开发者能够以更直观、更高级的抽象来构建并发程序。GPM模型，作为 Go 语言并发编程的核心，通过Goroutine、P（processor）、M（machine）三者的协同工作，实现了一种高效且易于管理的并发机制。</p><p>本文将基于 <strong>Go1.21</strong> 深入浅出地探讨 Go 语言的 GPM模型，主要分为几个部分：</p><ul><li>首先从其设计理念出发，详细解析 Goroutine、P 和 M三者的角色、工作原理及其相互之间的交互方式。</li><li>然后引入几个关键问题，我们会从结论上先总结 GPM的核心要点，内容包括协程调度循环、调度策略和调度时机。</li><li>接着我们会深入源码，去一步步洞察 Go 语言设计者是如何实现 GPM模型中的各个要点的，这个过程会比较繁琐，但其实也比较有趣，感兴趣的读者可以阅读这一块，若只是想对GPM 模型有个大概了解，那么停留在上一步也足矣了。</li><li>最后我们基于前面的分析，总结 G、P、M 三大组件在 Go程序运行过程中的状态流转图。</li></ul><p>通过对 GPM 模型的探讨，我们不仅能够理解 Go语言如何在众多现代编程语言中以其并发编程能力脱颖而出，还能够洞察其设计背后的智慧，以及这一模型如何随着Go 语言版本的迭代而不断进化和优化。无论你是对 Go语言充满好奇的新手，还是希望深化理解其并发模型的经验开发者，本文都将为你提供宝贵的视角和深刻的洞见。</p><h1 id="结论先行">结论先行</h1><h2 id="gpm-调度原理图">GPM 调度原理图</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126214830929.png"alt="Goroutine 调度原理图" /><figcaption aria-hidden="true">Goroutine 调度原理图</figcaption></figure><h2 id="goroutine-底层结构">Goroutine 底层结构</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h569pjiiosj21cu0u040p.jpg"alt="Goroutine 底层结构示例" /><figcaption aria-hidden="true">Goroutine 底层结构示例</figcaption></figure><h2 id="调度器-p-底层结构">调度器 P 底层结构</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57sl36b40j20o40u8js7.jpg"alt="P 底层结构" /><figcaption aria-hidden="true">P 底层结构</figcaption></figure><h2 id="gpm-调度循环">GPM 调度循环</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57qxoptk4j21hm0simyy.jpg"alt="GPM 调度循环图" /><figcaption aria-hidden="true">GPM 调度循环图</figcaption></figure><h2 id="gpm-协程调度优先级与顺序">GPM 协程调度优先级与顺序</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240127161341751.png"alt="Go 协程调度优先级与顺序" /><figcaption aria-hidden="true">Go 协程调度优先级与顺序</figcaption></figure><h2 id="寻找可执行-g-过程">寻找可执行 G 过程</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240128212451142.png"alt="findRunnable()" /><figcaption aria-hidden="true">findRunnable()</figcaption></figure><h2 id="协程切换时机">协程切换时机</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240129000028727.png"alt="Go 协程切换时机" /><figcaption aria-hidden="true">Go 协程切换时机</figcaption></figure><h1 id="gpm-模型">GPM 模型</h1><h2 id="概览">1. 概览</h2><p>这里有一张很流行的 Goroutine 调度原理图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126214830929.png"alt="Goroutine 调度原理图" /><figcaption aria-hidden="true">Goroutine 调度原理图</figcaption></figure><table><thead><tr class="header"><th>代号</th><th>名称</th><th>定义位置</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>Sched</td><td>调度器</td><td>proc.c</td><td>维护有存储 M 和 G 的队列以及调度器的一些状态信息等。</td></tr><tr class="even"><td>M</td><td>Machine 系统线程</td><td>runtime.h</td><td>它由操作系统管理的，Goroutine 就是跑在 M 之上的；M是一个很大的结构，里面维护小对象内存 cache（mcache）、当前执行的Goroutine、随机数发生器等等非常多的信息。</td></tr><tr class="odd"><td>P</td><td>Processor 处理器</td><td>runtime.h</td><td>它的主要用途就是用来执行 Goroutine 的，它维护了一个 Goroutine队列，即 runqueue。Processor 是让我们从 N:1 调度到 M:N调度的重要部分。所有的 P 都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS（可配置）个。</td></tr><tr class="even"><td>G</td><td>Goroutine 实现的核心结构</td><td>runtime.h</td><td>它包含了栈，指令指针，以及其他对调度 Goroutine很重要的信息，例如其阻塞的 channel。</td></tr><tr class="odd"><td>Global Queue</td><td>全局队列</td><td>proc.h</td><td>存放等待运行的 G。全局队列可能被任意的 P 加锁去获取里面的 G。</td></tr><tr class="even"><td>P Local Queue</td><td>P 的本地队列</td><td>proc.h</td><td>同全局队列类似，存放的也是等待运行的 G，但存放的数据有限，不会超过256 个。新建 G 时，G会优先加入本地队列。如果队列满了，则会把本地队列中一半的 G 以及新 G一起移动到全局队列。</td></tr></tbody></table><p>通过这个原理图我们知道 Go 语言的 GPM模型的作用非常简单，它就是一个“精打细算”的工具。以前单进程无法充分利用CPU资源，所以引入了多进程。又因为进程拥有的资源太多，其创建、切换和销毁都会占用很长时间，所以引入了更小粒度的线程。随着计算机科学的进步，现在看来，线程拥有的资源也是“比较多”的，所以线程的创建、切换和销毁代价也是“相对大”的。所以很多编程语言就引入了协程这个概念，其核心目的就是应用层自己抽象一个比线程更小粒度的调度单元，应用层结合操作系统的多线程能力，自己来管理“调度单元”的创建、切换和销毁，从而尽可能减少由线程切换带来的开销，以做到更轻量级的并发。</p><p>不同的编程语言可能有不同的实现，而关键就在于如何让调度更快、开销更小。这便是我们本文要探讨的主要内容。</p><div class="note note-info">            <p><strong>Go 语言的实现：</strong></p><p>线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P的本地队列为空时，M 会尝试从全局队列获得一批 G 放到 P的本地队列，或者从其他 P 的本地队列中“偷”一半 G 放到自己的本地队列。然后M 运行 G，G 执行之后，再从 P 获取下一个 G，如此不断重复下去。</p>          </div><p>在进入更加具体深入的讨论之前，我们需要重点思考以下几个问题：</p><ol type="1"><li>G 我们可以随便创建，可能有成千上万个，那 P 和 M 有多少个呢？</li><li>P 和 M 什么时候被创建呢？</li><li>操作系统只知道线程，所以实际上还是线程在执行任务，那么 G是如何调度到线程上并执行的呢？</li><li>如何防止协程饥饿？</li><li>如何减少频繁地创建和销毁线程？</li><li>多个线程从全局队列拿 G如何解决并发问题？又如何减少这种数据竞争呢？</li><li>在整个 Go 调度协程的过程中，G、P、M有哪些状态？它们又是如何轮转的呢？</li></ol><p>如果你对这几个问题有兴趣，请继续阅读下文。</p><h2 id="p-和-m-的个数问题">2. P 和 M 的个数问题</h2><ol type="1"><li>P 的数量由启动时环境变量 <code>$GOMAXPROCS</code> 或者程序中<code>runtime.GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有 <code>GOMAXPROCS</code> 个Goroutine 在同时运行。</li><li>M 的数量由 Go 语言本身的限制决定，Go 程序启动时会设置 M 的最大数量为<strong>10000</strong>个，但是内核很难支持这么多的线程数，所以这个限制可以忽略。可以使用<code>runtime.SetMaxThreads()</code> 设置 M 的最大数量。</li></ol><h2 id="p-和-m-何时被创建">3. P 和 M 何时被创建</h2><ol type="1"><li>P 的创建时机在确定了 P 的最大数量 n 后，runtime 会根据这个数量创建 n个 P。</li><li>M 创建的时机是在当没有足够的 M 来关联 P 并运行其中可运行的 G的时候，如所有的 M 此时都阻塞住了，而 P中还有很多就绪任务，就会去寻找空闲的 M，如果没有空闲的 M，就会去创建新的M。</li></ol><h2 id="调度循环">4. 调度循环</h2><p>在讨论 G 是如何被调度到 M 去执行的时候，我们需要先介绍 GPM模型中两个比较特殊的角色：<code>m0</code> 和 <code>g0</code>。</p><h3 id="m0">4.1 m0</h3><ul><li><strong>定义</strong>：m0 是 Go 程序启动时创建的第一个 M。它是由 Go运行时系统直接从操作系统线程创建的，不是从线程池中获取的。</li><li><strong>作用</strong>：m0 负责初始化和启动 Go运行时环境，包括创建调度器、分配第一个P（p0），并创建其他系统级别的资源。在程序的整个生命周期中，m0会继续存在，即使它可能不执行任何 Go 代码。</li><li><strong>特点</strong>：m0 不同于其他M，因为它不是从线程池中获取的。它可能没有绑定任何 P，除非程序中只有一个P（即 GOMAXPROCS 设置为 1）。</li></ul><h3 id="g0">4.2 g0</h3><ul><li><strong>定义</strong>：g0 是每个 M 的特殊Goroutine，它不执行任何实际的 Go 代码。每个 M 在创建时都会分配一个g0。</li><li><strong>作用</strong>：g0 主要用于执行调度器代码和进行系统调用。当 M需要执行这些非用户代码时，会切换到 g0 的栈上运行。</li><li><strong>特点</strong>：g0拥有自己的栈，这个栈用于存放调度器函数和系统调用的数据。这意味着当执行这些操作时，不会影响当前运行的用户Goroutine 的栈。</li></ul><h3 id="协程栈切换">4.3 协程栈切换</h3><p>g0 是 M 中负责调度其他 g 的协程，所以一个 M 中的协程调度其实就是在 g和 g0 之间不断切换：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240127155030695.png"alt="协程 g 与 协程 g0 的对应关系" /><figcaption aria-hidden="true">协程 g 与 协程 g0 的对应关系</figcaption></figure><p>大致过程如下：</p><ol type="1"><li>当 M 执行一个 G（用户 Goroutine）时，它使用 G的栈来运行用户代码。</li><li>当需要执行系统调用或调度器相关的代码时，M 会切换到 g0。g0拥有自己的栈，专门用于执行系统调用和调度器代码，这样可以避免污染用户Goroutine 的栈空间。在 g0 上，M 可以执行如内存分配、调度决策、处理Goroutine 的创建和销毁等操作。</li><li>完成系统调用或调度器任务后，M 会切换回之前的G，继续执行用户代码。这个过程会从 g0 的栈切换回 G 的栈。</li></ol><p>详细细节我们留到后面的源码分析揭晓。</p><h2 id="调度策略">5. 调度策略</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240127161341751.png"alt="Go 协程调度优先级与顺序" /><figcaption aria-hidden="true">Go 协程调度优先级与顺序</figcaption></figure><h3 id="获取本地运行队列">5.1 获取本地运行队列</h3><p>P 会优先尝试从自己的本地队列中寻找就绪的G，它<strong>一般</strong>会优先调度最近加入的。</p><p>因为这个时候可能由其他 P 来窃取 G，所以这里是需要同步机制的，Go采用原子操作来降低同步开销。</p><p>本地队列 G 的个数不超过 <strong>256</strong> 个，<strong>如果在创建 G的时候本地队列满了，会将本地队列中 1/2 的 G 连同新创建的 G一起放入全局队列中。</strong></p><h3 id="获取全局运行队列">5.2 获取全局运行队列</h3><p>P 会优先本地队列，然后才全局队列，这有个好处：</p><ul><li>如果只有全局队列，那么所有的 P 都需要去竞争全局队列中的G，这个时候需要上锁，且数据竞争会比较激烈，性能较差。</li><li>通过每个 P维护一个自己的本地队列可以减少并发冲突，如果实在需要去全局队列拿G，也可以一次性拿多个，大大减少了并发冲突的情况发生。</li></ul><p>但这又带来了一个问题，全局队列中协程的饥饿问题，因为 P会优先调度最近加入到自己本地队列中的 G，那可能会一直有新的 G被创建，导致全局队列中的 G 没有机会被调度到。Go 的解决思路是：</p><ul><li>P 每调度 <strong>61</strong> 次后，就会从全局队列中获取一个 G来运行。</li></ul><h3 id="获取准备就绪的网络协程">5.3 获取准备就绪的网络协程</h3><p>如果本地队列和全局队列都找不到就绪的 G 可以执行的话。调度会通过<code>runtime.netpoll</code> 获取可以运行的网络协程。</p><p>Go 语言的网络模型是对不同操作系统平台上 I/O 多路复用技术的封装。</p><p>当 Goroutine 在进行网络 I/O 时，它会被挂起，线程会去执行其他Goroutine。一旦 I/O 操作完成，该 Goroutine会被唤醒并重新排队等待执行。</p><h3 id="系统调用">5.4 系统调用</h3><p>当一个 Goroutine执行系统调用时，它可能会被阻塞，这时它的执行线程（M）可能会释放当前绑定的处理器（P），以便其他Goroutine 可以在该 P 上运行。</p><h3 id="协程窃取">5.5 协程窃取</h3><p>空闲的 M 如果绑定了 P，那么它的 P 会一直尝试从其他 P 的队列中窃取Goroutine，以平衡负载和避免空闲。这个时候为了让每个 P 都有可能被窃取，Go没有直接顺序遍历 P 列表，而是采用了一种相对随机的方式去遍历 P列表，直到找到可以运行的协程就返回。M 不断寻找可执行 G的这段期间，它被称为<strong>自旋线程</strong>。</p><p>所以为减少创建、切换和销毁线程的开销，Go 做了至少两点努力：</p><ol type="1"><li><p>偷取（Work Stealing）机制</p><p>当本线程无可运行的 G 时，它所绑定的 P 会尝试从其他线程绑定的 P 窃取G，而不是销毁线程。</p></li><li><p>移交（Hand Off）机制</p><p>当本线程因为 G 进行系统调用而阻塞时，线程会释放绑定的 P，把 P移交给其他空闲的线程执行。</p></li></ol><h2 id="调度时机">6. 调度时机</h2><p>Go 语言的调度器结合了抢占式调度和协作式调度，以下是 Go中这两种调度方式的具体实现和特性：</p><h3 id="协作式调度cooperative-scheduling">6.1 协作式调度（CooperativeScheduling）</h3><p><strong>阻塞操作</strong>：</p><ul><li>当 Goroutine执行阻塞操作（如通道操作、等待锁、系统调用等）时，它会主动放弃 CPU控制权，允许调度器切换到其他 Goroutine。</li></ul><p><strong>显式调度</strong>：</p><ul><li>Goroutine 显式请求 <code>runtime.Gosched()</code>调用，调度器进行调度。</li><li>这个时候回从当前协程切换到 g0 协程，取消 G 与 M 之间的绑定关系，把 G放入全局队列中。</li></ul><h3 id="抢占式调度preemptive-scheduling">6.2 抢占式调度（PreemptiveScheduling）</h3><p><strong>基于时间的抢占</strong>：</p><ul><li>从 Go 1.14 开始，调度器引入了基于时间的抢占机制。如果一个 Goroutine运行时间超过 10 毫秒，或者在系统调用中超过了 20微妙，调度器会在安全点（如函数调用、循环迭代、阻塞操作等）尝试暂停该Goroutine。</li><li>这种抢占不依赖于 Goroutine的显式放弃控制，而是由调度器主动触发。</li><li>安全点的选择旨在减少对 Goroutine执行的干扰，同时确保调度的公平性和响应性。</li></ul><p><strong>基于信号的抢占：</strong></p><ul><li>当程序在执行过程中既无法主动挂起，也不能进行系统调用，且无法进行函数调用时，就可以使用信号来调度。</li><li>信号其实就是线程信号，在操作系统中有很多基于信号的底层通信方式（SIGPIPE/ SIGURG / SIGHUP），而我们的线程可以注册对应信号的处理函数。</li><li>当线程接收到抢占信号时，会进入一个专门的信号处理器。这个处理器会检查是否处于安全点，如果是，则暂停当前Goroutine 并进行上下文切换。</li></ul><h1 id="源码分析">源码分析</h1><p>前面我们对 Go 语言的 GPM模型在基本概念、调度循环、调度策略和调度时机各个方面都进行了详细的阐述。如果读者只是想简单了解一下GPM模型的一些概念和设计思想，那么阅读到这里就基本足够了。如果对其源码实现有兴趣的话，那么请继续往下阅读~</p><p>接下来我们会从以下几个方面来对 Go 语言的 GPM 模型进行源码分析：</p><ol type="1"><li>G、P、M 在 Go 语言中的表示。</li><li>G 的创建过程。</li><li>g 和 g0 的切换过程。</li><li>GPM 的调度机制。</li></ol><h2 id="g-的底层结构">1. G 的底层结构</h2><p>G 在 Go 里面就是 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime2.go">runtime2.go</a>里面定义的 <code>g</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 栈参数。</span><br><span class="hljs-comment">// stack 描述实际的栈内存：[stack.lo, stack.hi)。</span><br><span class="hljs-comment">// stackguard0 是在 Go 栈增长序言中比较的栈指针。</span><br><span class="hljs-comment">// 通常是 stack.lo+StackGuard，但可以是 StackPreempt 来触发抢占。</span><br><span class="hljs-comment">// stackguard1 是在 C 栈增长序言中比较的栈指针。</span><br><span class="hljs-comment">// 在 g0 和 gsignal 栈上是 stack.lo+StackGuard。</span><br><span class="hljs-comment">// 在其他 goroutine 栈上是 ~0，以触发对 morestackc 的调用（并崩溃）。</span><br>stack       stack   <span class="hljs-comment">// 运行时/CGO 已知的偏移</span><br>stackguard0 <span class="hljs-type">uintptr</span> <span class="hljs-comment">// liblink 已知的偏移</span><br>stackguard1 <span class="hljs-type">uintptr</span> <span class="hljs-comment">// liblink 已知的偏移</span><br><br>_panic    *_panic <span class="hljs-comment">// 最内层的 panic - liblink 已知的偏移</span><br>_defer    *_defer <span class="hljs-comment">// 最内层的 defer</span><br>m         *m      <span class="hljs-comment">// 当前 m；arm liblink 已知的偏移</span><br>sched     gobuf   <span class="hljs-comment">// 当前协程的运行现场</span><br>syscallsp <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 如果 status==Gsyscall, syscallsp = sched.sp 在 gc 期间使用</span><br>syscallpc <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 如果 status==Gsyscall, syscallpc = sched.pc 在 gc 期间使用</span><br>stktopsp  <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 栈顶的预期 sp，用于回溯检查</span><br><span class="hljs-comment">// param 是一个通用的指针参数字段，用于在特定上下文中传递值，</span><br><span class="hljs-comment">// 其他存储参数的方式难以找到。目前有三种用途：</span><br><span class="hljs-comment">// 1. 当通道操作唤醒一个阻塞的 goroutine 时，它将 param 设置为</span><br><span class="hljs-comment">//    指向已完成阻塞操作的 sudog。</span><br><span class="hljs-comment">// 2. 由 gcAssistAlloc1 使用，以向其调用者信号，表明 goroutine 完成了 GC 周期。</span><br><span class="hljs-comment">//    以任何其他方式这样做是不安全的，因为此时 goroutine 的栈可能已经移动。</span><br><span class="hljs-comment">// 3. 由 debugCallWrap 使用，以将参数传递给新的 goroutine，因为在运行时分配闭包是被禁止的。</span><br>param        unsafe.Pointer<br>atomicstatus atomic.Uint32<br>stackLock    <span class="hljs-type">uint32</span> <span class="hljs-comment">// sigprof/scang 锁；<span class="hljs-doctag">TODO:</span> 合并到 atomicstatus</span><br>goid         <span class="hljs-type">uint64</span><br>schedlink    guintptr<br>waitsince    <span class="hljs-type">int64</span>      <span class="hljs-comment">// g 变为阻塞的大致时间</span><br>waitreason   waitReason <span class="hljs-comment">// 如果 status==Gwaiting</span><br><br>preempt       <span class="hljs-type">bool</span> <span class="hljs-comment">// 抢占信号，复制 stackguard0 = stackpreempt</span><br>preemptStop   <span class="hljs-type">bool</span> <span class="hljs-comment">// 在抢占时转换为 _Gpreempted；否则，只是取消调度</span><br>preemptShrink <span class="hljs-type">bool</span> <span class="hljs-comment">// 在同步安全点缩小栈</span><br><br><span class="hljs-comment">// asyncSafePoint 设置为 true 表示 g 在异步安全点停止。</span><br><span class="hljs-comment">// 这意味着栈上有没有精确指针信息的帧。</span><br>asyncSafePoint <span class="hljs-type">bool</span><br><br>paniconfault <span class="hljs-type">bool</span> <span class="hljs-comment">// 在意外的故障地址上触发 panic（而不是崩溃）</span><br>gcscandone   <span class="hljs-type">bool</span> <span class="hljs-comment">// g 已扫描栈；由 _Gscan 位在状态中保护</span><br>throwsplit   <span class="hljs-type">bool</span> <span class="hljs-comment">// 必须不分割栈</span><br><span class="hljs-comment">// activeStackChans 表示有未锁定的通道指向这个 goroutine 的栈。</span><br><span class="hljs-comment">// 如果为 true，栈复制需要获取通道锁来保护这些栈区域。</span><br>activeStackChans <span class="hljs-type">bool</span><br><span class="hljs-comment">// parkingOnChan 表示 goroutine 即将在 chansend 或 chanrecv 上停车。</span><br><span class="hljs-comment">// 用于标记栈缩小的不安全点。</span><br>parkingOnChan atomic.Bool<br><br>raceignore    <span class="hljs-type">int8</span>  <span class="hljs-comment">// 忽略竞态检测事件</span><br>tracking      <span class="hljs-type">bool</span>  <span class="hljs-comment">// 是否跟踪此 G 以获取调度延迟统计</span><br>trackingSeq   <span class="hljs-type">uint8</span> <span class="hljs-comment">// 用于决定是否跟踪此 G</span><br>trackingStamp <span class="hljs-type">int64</span> <span class="hljs-comment">// G 最后开始被跟踪的时间戳</span><br>runnableTime  <span class="hljs-type">int64</span> <span class="hljs-comment">// 可运行时间，运行时清除，仅在跟踪时使用</span><br>lockedm       muintptr<br>sig           <span class="hljs-type">uint32</span><br>writebuf      []<span class="hljs-type">byte</span><br>sigcode0      <span class="hljs-type">uintptr</span><br>sigcode1      <span class="hljs-type">uintptr</span><br>sigpc         <span class="hljs-type">uintptr</span><br>parentGoid    <span class="hljs-type">uint64</span>          <span class="hljs-comment">// 创建此 goroutine 的 goroutine 的 goid</span><br>gopc          <span class="hljs-type">uintptr</span>         <span class="hljs-comment">// 创建此 goroutine 的 go 语句的 pc</span><br>ancestors     *[]ancestorInfo <span class="hljs-comment">// 创建此 goroutine 的祖先 goroutine 的信息（仅在 debug.tracebackancestors 使用）</span><br>startpc       <span class="hljs-type">uintptr</span>         <span class="hljs-comment">// goroutine 函数的 pc</span><br>racectx       <span class="hljs-type">uintptr</span><br>waiting       *sudog         <span class="hljs-comment">// 此 g 正在等待的 sudog 结构（具有有效的 elem 指针）；按锁顺序</span><br>cgoCtxt       []<span class="hljs-type">uintptr</span>      <span class="hljs-comment">// cgo 回溯上下文</span><br>labels        unsafe.Pointer <span class="hljs-comment">// 分析器标签</span><br>timer         *timer         <span class="hljs-comment">// 缓存的计时器，用于 time.Sleep</span><br>selectDone    atomic.Uint32  <span class="hljs-comment">// 我们是否参与 select 并且有人赢得了竞赛？</span><br><br><span class="hljs-comment">// goroutineProfiled 指示当前 goroutine 的栈状态</span><br>  <span class="hljs-comment">// 是否已经被记录在进行中的 goroutine 性能分析中。</span><br>goroutineProfiled goroutineProfileStateHolder<br><br><span class="hljs-comment">// 每个 G 的追踪状态。</span><br>trace gTraceState<br><br><span class="hljs-comment">// 每个 G 的 GC 状态</span><br><br><span class="hljs-comment">// gcAssistBytes 是此 G 的 GC 协助信用，以分配的字节为单位。</span><br><span class="hljs-comment">// 如果为正，则 G 有信用分配 gcAssistBytes 字节而不协助。</span><br><span class="hljs-comment">// 如果为负，则 G 必须通过执行扫描工作来纠正这一点。</span><br><span class="hljs-comment">// 我们以字节为单位跟踪这一点，以便在 malloc 热路径中快速更新和检查债务。</span><br><span class="hljs-comment">// 协助比率决定了这如何对应于扫描工作债务。</span><br>gcAssistBytes <span class="hljs-type">int64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 <code>g</code> 结构字段非常多，这个结构体的设计反映了 Go语言对并发和协程管理的底层机制，包括栈管理、调度、垃圾回收、异常处理等多个方面。通过这种抽象，Go语言能够有效地管理成千上万的<code>goroutine</code>，使得并发编程变得更加简单和高效。</p><p>这里我们只关注 GPM 模型相关的内容，需要重点关心以下几个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br>stack     stack   <span class="hljs-comment">// 当前协程的协程栈</span><br>m         *m      <span class="hljs-comment">// 当前线程</span><br>sched     gobuf  <span class="hljs-comment">// 保存协程的运行现场</span><br>atomicstatus atomic.Uint32<span class="hljs-comment">// 协程状态</span><br>goid         <span class="hljs-type">uint64</span><span class="hljs-comment">// 协程ID</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="协程栈-stack">1.1 协程栈 stack</h3><p>其中 <code>stack</code>结构如下，它存储了协程栈的低地址和高地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> stack <span class="hljs-keyword">struct</span> &#123;<br>lo <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 栈的低地址</span><br>hi <span class="hljs-type">uintptr</span> <span class="hljs-comment">// 栈的高地址</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程抽象-m">1.2 线程抽象 m</h3><p>而 <code>m</code> 就是 Go语言对操作系统线程的抽象，这不是实际的线程，这只是 Go语言对线程相关信息的抽象，以方便更好地调度协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> m <span class="hljs-keyword">struct</span> &#123;<br>g0      *g     <span class="hljs-comment">// g0 协程，Go 中的主协程</span><br>curg    *g       <span class="hljs-comment">// 现在正在运行的协程</span><br>id      <span class="hljs-type">int64</span> <span class="hljs-comment">// 线程ID</span><br>mOS<span class="hljs-comment">// 当前操作系统对线程的额外描述信息</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>m</code>结构体包含了许多字段，这些字段涉及到线程管理、调度、信号处理、系统调用、锁管理等多个方面。这个结构体是Go 并发模型的核心部分之一，它与 <code>g</code>（goroutine）和<code>p</code>（processor）结构体一起，构成了 Go的调度系统的基础。通过这种设计，Go能够有效地在多个操作系统线程之间调度成千上万的goroutine，实现高效的并发执行。</p><h3 id="协程上下文-gobuf">1.3 协程上下文 gobuf</h3><p><code>gobuf</code> 结构体在 Go 语言的运行时系统中用于保存<code>Goroutine</code>的执行上下文，特别是在调度和系统调用中。这个结构体保存了足够的信息以便在<code>Goroutine</code> 被暂停后能够恢复执行。</p><p>下面是对 <code>gobuf</code> 结构体中各个字段的解释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// sp, pc 和 g 的偏移量是已知的（在 libmach 中硬编码）。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// ctxt 在 GC 方面比较特殊：它可能是一个堆分配的 funcval，</span><br><span class="hljs-comment">// 因此 GC 需要跟踪它，但它需要在汇编中设置和清除，</span><br><span class="hljs-comment">// 在那里实现写屏障比较困难。然而，ctxt 实际上是一个保存的、活跃的寄存器，</span><br><span class="hljs-comment">// 我们只在真实寄存器和 gobuf 之间交换它。因此，我们在栈扫描期间将其视为根，</span><br><span class="hljs-comment">// 这意味着保存和恢复它的汇编不需要写屏障。它仍然被类型化为指针，</span><br><span class="hljs-comment">// 以便任何其他从 Go 进行的写操作都会获得写屏障。</span><br>sp   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 栈指针</span><br>pc   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 程序计数器</span><br>g    guintptr       <span class="hljs-comment">// 指向当前 goroutine 的指针</span><br>ctxt unsafe.Pointer <span class="hljs-comment">// 上下文，用于保存额外的状态或信息</span><br>ret  <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 用于保存函数返回值</span><br>lr   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 链接寄存器（在某些架构中用于函数调用）</span><br>bp   <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 基指针（在启用帧指针的架构中使用）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们重点需要关注 2 个字段：</p><ul><li><code>sp</code>：栈指针，表示当前协程运行到栈中的哪个位置了。</li><li><code>pc</code>：程序计数器，表示当前协程运行到哪一行代码了。</li></ul><h3 id="协程状态-atomicstatus">1.4 协程状态 atomicstatus</h3><p>我记得在 Go1.16 版本中，这个字段的类型还是 <code>uint32</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">atomicstatus <span class="hljs-type">uint32</span><br></code></pre></td></tr></table></figure><p>现在 Go1.21 版本中，已经用了原子操作来减少并发冲突了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">atomicstatus atomic.Uint32<br></code></pre></td></tr></table></figure><p>可以看到 Go 的底层也是随着版本更新不断优化中的。</p><p><ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime2.go">runtime2.go</a>定义了 G 的各种状态，如：</p><ul><li><code>_Gidle (0)</code>: 表示 G 刚刚被分配，尚未初始化。</li><li><code>_Grunnable (1)</code>: 表示 G在运行队列上。它当前没有执行用户代码。栈不被该 <code>goroutine</code>拥有。</li><li>...</li></ul><p>后面我们会给出 G 状态的流转图。</p><h3 id="举个例子">1.5 举个例子</h3><p>假设我们现在有以下 Go 代码：main() 调用 do1()，do1() 调用do2()，do2() 调用 do3()。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do3</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;here is do3&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do2</span><span class="hljs-params">()</span></span> &#123;<br>do3()<span class="hljs-comment">//&lt;---------------</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do1</span><span class="hljs-params">()</span></span> &#123;<br>do2()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>do1()<br>&#125;<br></code></pre></td></tr></table></figure><p>那么当这段程序运行到第 6 行的时候，它的底层结构大概如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h569pjiiosj21cu0u040p.jpg"alt="Goroutine 底层结构示例" /><figcaption aria-hidden="true">Goroutine 底层结构示例</figcaption></figure><p>至于为什么这里有个 <code>goexit()</code>，其实就是为了可以跳回到<code>g0</code> 协程，后面我们会具体分析到。</p><h2 id="p-的底层结构">2. P 的底层结构</h2><p>P 的本质是 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime2.go">runtime2.go</a>里面定义的 <code>p</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;<br>    id          <span class="hljs-type">int32</span>          <span class="hljs-comment">// P 的唯一标识符</span><br>    status      <span class="hljs-type">uint32</span>         <span class="hljs-comment">// P 的状态，如 pidle/prunning/...</span><br>    link        puintptr       <span class="hljs-comment">// P 链接</span><br>    schedtick   <span class="hljs-type">uint32</span>         <span class="hljs-comment">// 每次调度器调用时递增</span><br>    syscalltick <span class="hljs-type">uint32</span>         <span class="hljs-comment">// 每次系统调用时递增</span><br>    sysmontick  sysmontick     <span class="hljs-comment">// sysmon 观察到的最后一个 tick</span><br>    m           muintptr       <span class="hljs-comment">// 关联的 M 的反向链接（如果空闲则为 nil）</span><br>    mcache      *mcache        <span class="hljs-comment">// M 缓存</span><br>    pcache      pageCache      <span class="hljs-comment">// 页面缓存</span><br>    raceprocctx <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 用于竞态检测的上下文</span><br><br>    <span class="hljs-comment">// 延迟结构体池</span><br>    deferpool    []*_defer<br>    deferpoolbuf [<span class="hljs-number">32</span>]*_defer<br><br>    <span class="hljs-comment">// Goroutine ID 缓存，减少对 runtime·sched.goidgen 的访问</span><br>    goidcache    <span class="hljs-type">uint64</span><br>    goidcacheend <span class="hljs-type">uint64</span><br><br>    <span class="hljs-comment">// 可运行 goroutine 队列，无锁访问</span><br>    runqhead <span class="hljs-type">uint32</span><br>    runqtail <span class="hljs-type">uint32</span><br>    runq     [<span class="hljs-number">256</span>]guintptr<br>    runnext  guintptr <span class="hljs-comment">// 下一个要运行的 G</span><br><br>    <span class="hljs-comment">// 空闲 G 的列表（状态 == Gdead）</span><br>    gFree <span class="hljs-keyword">struct</span> &#123;<br>        gList<br>        n <span class="hljs-type">int32</span><br>    &#125;<br><br>    <span class="hljs-comment">// sudog 缓存</span><br>    sudogcache []*sudog<br>    sudogbuf   [<span class="hljs-number">128</span>]*sudog<br><br>    <span class="hljs-comment">// 堆上 mspan 对象的缓存</span><br>    mspancache <span class="hljs-keyword">struct</span> &#123;<br>        <span class="hljs-built_in">len</span> <span class="hljs-type">int</span><br>        buf [<span class="hljs-number">128</span>]*mspan<br>    &#125;<br><br>    <span class="hljs-comment">// pinner 对象的缓存</span><br>    pinnerCache *pinner<br><br>  <span class="hljs-comment">// P 状态跟踪</span><br>    trace pTraceState<br><br>    <span class="hljs-comment">// 每个 P 的持久分配，避免互斥</span><br>    palloc persistentAlloc <br><br>    <span class="hljs-comment">// 定时器相关字段</span><br>    timer0When             atomic.Int64<br>    timerModifiedEarliest  atomic.Int64<br>    timersLock             mutex<br>    timers                 []*timer<br>    numTimers              atomic.Uint32<br>    deletedTimers          atomic.Uint32<br>    timerRaceCtx           <span class="hljs-type">uintptr</span><br><br>    <span class="hljs-comment">// GC 相关字段</span><br>    gcAssistTime         <span class="hljs-type">int64</span><br>    gcFractionalMarkTime <span class="hljs-type">int64</span><br>    gcw                  gcWork<br>    wbBuf                wbBuf<br><br>    <span class="hljs-comment">// 指示是否在下一个安全点运行特定的函数</span><br>    runSafePointFn <span class="hljs-type">uint32</span><br>  <br>    <span class="hljs-comment">// 指示当前 P 是否正在写入任何统计数据。</span><br>  <span class="hljs-comment">// 偶数时表示没有写入，奇数时表示正在写入。</span><br>    statsSeq       atomic.Uint32<br>  <br>    <span class="hljs-comment">// 指示当前的 P 应该尽快进入调度器，无论其上运行的是哪个 G。</span><br><span class="hljs-comment">// 这是实现抢占式调度的一部分，允许调度器在必要时中断长时间运行的 goroutine，</span><br>    <span class="hljs-comment">// 以便其他 goroutine 有机会运行。</span><br>    preempt        <span class="hljs-type">bool</span><br>  <br>    <span class="hljs-comment">// 记录页面分配、释放和清理跟踪信息的缓冲区。</span><br>    pageTraceBuf   pageTraceBuf<br>&#125;<br></code></pre></td></tr></table></figure><p><code>p</code> 结构体在 Go语言的运行时系统中代表了一个处理器（processor），它是调度器的核心组成部分。每个<code>p</code> 负责管理一组 <code>goroutine</code>的运行。这个结构体包含了许多字段，涉及到 <code>goroutine</code>的调度、内存分配、垃圾回收和其他系统级别的操作。</p><p>我们重点关注以下几个字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;<br>m           muintptr   <span class="hljs-comment">// 当前负责的线程</span><br>  <br><span class="hljs-comment">// 本地可运行的协程的队列，可无锁访问</span><br>runqhead <span class="hljs-type">uint32</span> <span class="hljs-comment">// 队头</span><br>runqtail <span class="hljs-type">uint32</span> <span class="hljs-comment">// 队尾</span><br>runq     [<span class="hljs-number">256</span>]guintptr   <span class="hljs-comment">// 长度为 256</span><br>runnext guintptr <span class="hljs-comment">// 下一个可用的协程的指针</span><br>  <br>  <span class="hljs-comment">// 抢占标识，指示当前的 P 应该尽快进入调度器，无论其上运行的是哪个 G。</span><br>  preempt <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57sl36b40j20o40u8js7.jpg"alt="P 底层结构" /><figcaption aria-hidden="true">P 底层结构</figcaption></figure><h2 id="goroutine-的创建">3. Goroutine 的创建</h2><p>Go 并发能力的优秀之处，就在于它启动一个新的协程实在是太方便了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; ... &#125;()<br></code></pre></td></tr></table></figure><p>那么底层究竟做了什么呢？</p><h3 id="newproc">3.1 newproc()</h3><p>Goroutine 通过 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a>中的 <code>newproc()</code> 创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc</span><span class="hljs-params">(fn *funcval)</span></span> &#123;<br>    gp := getg()<br>    pc := getcallerpc()<br>    systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        newg := newproc1(fn, gp, pc)<br><br>        pp := getg().m.p.ptr()<br>        runqput(pp, newg, <span class="hljs-literal">true</span>)<br><br>        <span class="hljs-keyword">if</span> mainStarted &#123;<br>            wakep()<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>获取当前 goroutine 和调用者 PC</strong>: <code>getg()</code>获取当前正在执行的 <code>goroutine</code>，<code>getcallerpc()</code>获取调用者的程序计数器地址。</li><li><strong>在系统栈上执行 <code>newproc1</code></strong>:<code>systemstack</code> 确保 <code>newproc1</code>在系统栈上执行，而不是当前 <code>goroutine</code> 的栈。这是因为新的<code>goroutine</code> 可能需要更多的栈空间。</li><li><strong>创建新的 goroutine</strong>: <code>newproc1</code>被调用来实际创建新的 <code>goroutine</code>。</li><li><strong>将新的 goroutine 放入运行队列</strong>: <code>runqput</code>将新创建的 <code>goroutine</code> 放入运行队列。</li><li><strong>唤醒处理器</strong>:如果主函数已经开始执行，<code>wakep</code> 用于唤醒一个空闲的 P来运行新的 <code>goroutine</code>。</li></ol><h3 id="newproc1">3.2 newproc1()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">(fn *funcval, callergp *g, callerpc <span class="hljs-type">uintptr</span>)</span></span> *g &#123;<br>    <span class="hljs-comment">// ... (省略了错误检查和获取 M 的代码)</span><br><br>  <span class="hljs-comment">// 尝试从 P 的空闲列表获取一个 G，如果没有则创建一个新的</span><br>    newg := gfget(pp)<br>    <span class="hljs-keyword">if</span> newg == <span class="hljs-literal">nil</span> &#123;<br>        newg = malg(stackMin)<br>        casgstatus(newg, _Gidle, _Gdead)<br>        allgadd(newg)<br>    &#125;<br><br>    <span class="hljs-comment">// 设置新 G 的栈</span><br>    totalSize := <span class="hljs-type">uintptr</span>(<span class="hljs-number">4</span>*goarch.PtrSize + sys.MinFrameSize)<br>    totalSize = alignUp(totalSize, sys.StackAlign)<br>    sp := newg.stack.hi - totalSize<br>  spArg := sp<br>  <br>    <span class="hljs-comment">// 清空并设置新 G 的调度器相关字段</span><br>    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))<br>    newg.sched.sp = sp<br>    newg.stktopsp = sp<br>    newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum<br>    newg.sched.g = guintptr(unsafe.Pointer(newg))<br>  <br>    <span class="hljs-comment">// 设置新 G 的其他字段</span><br>    gostartcallfn(&amp;newg.sched, fn)<br>    newg.parentGoid = callergp.goid<br>    newg.gopc = callerpc<br>    newg.startpc = fn.fn<br>    <br>  <span class="hljs-comment">// ... (省略了跟踪和调试相关的代码)</span><br><br>    casgstatus(newg, _Gdead, _Grunnable)<br><br>    <span class="hljs-keyword">return</span> newg<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>创建或获取一个新的 goroutine</strong>: <code>gfget</code>尝试从 P 的空闲列表中获取一个<code>goroutine</code>，如果没有可用的，则通过 <code>malg</code>分配一个新的。</li><li><strong>初始化 goroutine 的栈和调度器</strong>: 设置新<code>goroutine</code>的栈、程序计数器、调用函数等。这里有个非常核心的点<code>newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum</code>，我们前面留了个疑问，协程栈顶的<code>goexit</code> 是哪里来的，就是这里来的。这里设置新<code>goroutine</code> 的程序计数器（<code>pc</code>）指向<code>goexit</code> 函数。<code>goexit</code> 是每个<code>goroutine</code> 在退出时必须调用的函数，用于执行清理工作并切换到g0 栈。</li><li><strong>设置父 goroutine ID 和创建点</strong>: 记录创建这个新<code>goroutine</code> 的父 <code>goroutine</code> 的 ID 和<code>go</code> 语句的位置。</li><li><strong>更改 goroutine 状态</strong>: 将新 <code>goroutine</code>的状态从 <code>_Gdead</code> 改为<code>_Grunnable</code>，使其准备好被调度。</li><li><strong>返回新的 goroutine</strong>: 函数返回新创建的<code>goroutine</code>。</li></ol><h3 id="runqput">3.3 runqput()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runqput tries to put g on the local runnable queue.</span><br><span class="hljs-comment">// If next is false, runqput adds g to the tail of the runnable queue.</span><br><span class="hljs-comment">// If next is true, runqput puts g in the pp.runnext slot.</span><br><span class="hljs-comment">// If the run queue is full, runnext puts g on the global queue.</span><br><span class="hljs-comment">// Executed only by the owner P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqput</span><span class="hljs-params">(pp *p, gp *g, next <span class="hljs-type">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrandn(<span class="hljs-number">2</span>) == <span class="hljs-number">0</span> &#123;<br>next = <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">if</span> next &#123;<br>retryNext:<br>oldnext := pp.runnext<br><span class="hljs-keyword">if</span> !pp.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;<br><span class="hljs-keyword">goto</span> retryNext<br>&#125;<br><span class="hljs-keyword">if</span> oldnext == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>gp = oldnext.ptr()<br>&#125;<br><br>retry:<br>h := atomic.LoadAcq(&amp;pp.runqhead) <br>t := pp.runqtail<br><span class="hljs-keyword">if</span> t-h &lt; <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)) &#123;<br>pp.runq[t%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].set(gp)<br>atomic.StoreRel(&amp;pp.runqtail, t+<span class="hljs-number">1</span>) <br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> runqputslow(pp, gp, h, t) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">goto</span> retry<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>随机调度器</strong>：如果启用了调度器的随机化（<code>randomizeScheduler</code>），并且<code>next</code> 为 <code>true</code>（newproc 调用的时候永远都是传的true），则有一半的概率将 <code>next</code> 设置为<code>false</code>。这有助于防止调度器的行为过于可预测。</li><li><strong>处理 <code>runnext</code> 槽</strong>：如果<code>next</code> 为 <code>true</code>，函数尝试将 <code>gp</code> 放入<code>pp.runnext</code> 槽。如果该槽已被占用，则将原有的<code>goroutine</code> 移动到常规运行队列，并重试将新的 <code>gp</code>放入 <code>runnext</code>。</li><li><strong>放入本地运行队列</strong>：如果 <code>next</code> 为<code>false</code> 或 <code>runnext</code> 槽已满，函数尝试将<code>gp</code> 放入本地运行队列的尾部。如果队列未满，<code>gp</code>将被成功添加。</li><li><strong>处理队列满的情况</strong>：如果本地运行队列已满，<code>runqputslow</code>被调用，尝试将 <code>gp</code> 连同自己队列中一半的 g放入全局运行队列。如果这也失败了，函数会重试将 <code>gp</code>放入本地队列。</li><li><strong>原子操作</strong>：函数使用原子操作来加载和存储队列头（<code>runqhead</code>）和尾（<code>runqtail</code>）指针，以确保多线程环境下的数据一致性和线程安全。</li></ol><h3 id="runqputslow">3.4 runqputslow()</h3><p><code>runqputslow</code> 函数处理本地运行队列满的情况，将<code>goroutine</code>批量转移到全局队列。这个函数通过原子操作和锁来确保操作的原子性和线程安全。随机化调度器的使用增加了调度的随机性和公平性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Put g and a batch of work from local runnable queue on global queue.</span><br><span class="hljs-comment">// Executed only by the owner P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqputslow</span><span class="hljs-params">(pp *p, gp *g, h, t <span class="hljs-type">uint32</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><br>  <span class="hljs-comment">// 从 pp 的本地队列中获取一半的 goroutine</span><br>  <span class="hljs-keyword">var</span> batch [<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]*g<br>n := t - h<br>n = n / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> n != <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span>) &#123;<br>throw(<span class="hljs-string">&quot;runqputslow: queue is not full&quot;</span>)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i] = pp.runq[(h+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br>&#125;<br><span class="hljs-keyword">if</span> !atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>batch[n] = gp<br><br>  <span class="hljs-comment">// 随机打乱 goroutine 的顺序，以增加调度的随机性</span><br><span class="hljs-keyword">if</span> randomizeScheduler &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">1</span>); i &lt;= n; i++ &#123;<br>j := fastrandn(i + <span class="hljs-number">1</span>)<br>batch[i], batch[j] = batch[j], batch[i]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 串成队列</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i].schedlink.set(batch[i+<span class="hljs-number">1</span>])<br>&#125;<br><span class="hljs-keyword">var</span> q gQueue<br>q.head.set(batch[<span class="hljs-number">0</span>])<br>q.tail.set(batch[n])<br><br><span class="hljs-comment">// 放入全局队列中</span><br>lock(&amp;sched.lock)<br>globrunqputbatch(&amp;q, <span class="hljs-type">int32</span>(n+<span class="hljs-number">1</span>))<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>创建批处理数组</strong>：函数首先创建一个 <code>batch</code>数组，用于存储从本地队列中取出的 <code>goroutine</code>。</li><li><strong>从本地队列中获取一批<code>goroutine</code></strong>：函数计算出要从本地队列中取出多少个<code>goroutine</code>（通常是队列长度的一半），并将它们添加到<code>batch</code> 数组中。</li><li><strong>原子操作更新队列头部</strong>：使用原子操作<code>atomic.CasRel</code>更新本地运行队列的头部索引，这是一个释放（release）操作，确保之前的读取操作完成。</li><li><strong>将当前 <code>goroutine</code>添加到批处理中</strong>：将传入的 <code>gp</code> 添加到<code>batch</code> 数组的末尾。</li><li><strong>随机化调度器</strong>：如果启用了随机调度器，函数会随机打乱<code>batch</code> 数组中的 <code>goroutine</code>顺序，以增加调度的随机性。</li><li><strong>链接 <code>goroutine</code></strong>：将 <code>batch</code>数组中的 <code>goroutine</code> 链接起来，形成一个队列。</li><li><strong>准备全局队列</strong>：创建一个 <code>gQueue</code>结构，并设置其头部和尾部指向 <code>batch</code> 数组中的第一个和最后一个<code>goroutine</code>。</li><li><strong>将批处理放入全局队列</strong>：加锁访问全局调度器的锁，然后将整个<code>batch</code> 队列放入全局运行队列。</li></ol><h2 id="调度过程-schedule">4. 调度过程 schedule()</h2><p>Go 的调度器核心执行逻辑都在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a>的 <code>schedule()</code>函数中。我们先不探讨过多的细节，我们先把整个大体脉络理清楚再说。</p><p>简化后的 <code>schedule()</code> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 获取当前正在执行的 M</span><br>mp := getg().m<br>  ...<br>  <span class="hljs-comment">// 查找一个可运行的 G，会阻塞住直到返回。</span><br>gp, inheritTime, tryWakeP := findRunnable() <br>  ...<br><span class="hljs-comment">// 执行 g</span><br>execute(gp, inheritTime)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>execute()</code> 执行 g，它简化后如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">execute</span><span class="hljs-params">(gp *g, inheritTime <span class="hljs-type">bool</span>)</span></span> &#123;<br>mp := getg().m<br>..<br>gogo(&amp;gp.sched)<br>&#125;<br></code></pre></td></tr></table></figure><p>它调用了 <code>gogo()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gogo</span><span class="hljs-params">(buf *gobuf)</span></span><br></code></pre></td></tr></table></figure><p>一般这种格式说明函数是用汇编实现的，我们在 Goland 上可以双击 shift然后搜索 <code>runtime·gogo</code>：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240128130637007.png"alt="runtime·gogo" /><figcaption aria-hidden="true">runtime·gogo</figcaption></figure><p>不同的平台有不同的实现，但是核心逻辑都是一样的，它直接操作处理器的寄存器和栈，以实现从一个 <code>goroutine</code>切换到另一个 <code>goroutine</code> 的功能。</p><p>我们后面的发内心会发现 <code>goexit()</code> 最终会调用<code>schedule()</code>。</p><p>这就串起来了，Go 程序启动后会创建 m0 和g0，所以第一个<code>schedule()</code> 是 g0 调用的，最后通过<code>gogo</code> 切换到用户协程 g 上面执行业务方法，完事后 g 通过<code>goexit</code> 回到 <code>schedule()</code>，以此循环反复下去。</p><p>现在我们可以来总结一下 GPM 调度循环的过程，大概如下图表示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57qxoptk4j21hm0simyy.jpg"alt="GPM 调度循环图" /><figcaption aria-hidden="true">GPM 调度循环图</figcaption></figure><p>下面我们再对这个过程中的关键函数进行细致分析：</p><ul><li><code>schedule()</code>：调度入口。</li><li><code>findRunnable()</code>：寻找可执行的 G。</li><li><code>execute()</code>：执行 G。</li><li><code>gogo()</code>：切换协程栈 g0 到 g。</li><li><code>goexit()</code>：退出 g 协程，切换回 g0 栈。</li></ul><h3 id="schedule">4.1 schedule()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 获取当前正在执行的 M</span><br>mp := getg().m<br><br>  <span class="hljs-comment">// 有锁的话抛出异常，避免该情况下调度出现死锁或其他问题</span><br><span class="hljs-keyword">if</span> mp.locks != <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;schedule: holding locks&quot;</span>)<br>&#125;<br><br>  <span class="hljs-comment">// M 被锁定了特定的 G，这个时候直接执行这个锁定的 G。</span><br><span class="hljs-keyword">if</span> mp.lockedg != <span class="hljs-number">0</span> &#123;<br>stoplockedm()<br>execute(mp.lockedg.ptr(), <span class="hljs-literal">false</span>) <span class="hljs-comment">// Never returns.</span><br>&#125;<br><br><span class="hljs-comment">// CGO 调用需要 g0 栈，所以这个时候不继续调度了，抛出异常。</span><br><span class="hljs-keyword">if</span> mp.incgo &#123;<br>throw(<span class="hljs-string">&quot;schedule: in cgo&quot;</span>)<br>&#125;<br><br>top:<br>pp := mp.p.ptr()<br>pp.preempt = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// 安全点检查：如果当前 M 在自旋的话，应该是没有可执行 G 的。</span><br><span class="hljs-keyword">if</span> mp.spinning &amp;&amp; (pp.runnext != <span class="hljs-number">0</span> || pp.runqhead != pp.runqtail) &#123;<br>throw(<span class="hljs-string">&quot;schedule: spinning with local work&quot;</span>)<br>&#125;<br><br>  <span class="hljs-comment">// 查找一个可运行的 G，会阻塞住直到返回。</span><br>gp, inheritTime, tryWakeP := findRunnable() <br><br>  <span class="hljs-comment">// 调试的时候系统会处于“冻结”状态，</span><br>  <span class="hljs-comment">// 这里故意通过两次 lock 引入死锁使当前 M 陷入无限等待，</span><br>  <span class="hljs-comment">// 以在调试时保持当前的调度器和运行时状态不变。</span><br><span class="hljs-keyword">if</span> debug.dontfreezetheworld &gt; <span class="hljs-number">0</span> &amp;&amp; freezing.Load() &#123;<br>lock(&amp;deadlock)<br>lock(&amp;deadlock)<br>&#125;<br><br>  <span class="hljs-comment">// 如果当前 M 之前是自旋的，但是现在要准备执行 G 了，那就不是自旋了。</span><br><span class="hljs-keyword">if</span> mp.spinning &#123;<br>resetspinning()<br>&#125;<br><br>  <span class="hljs-comment">// 当用户级调度被禁用时，采用双重检查后如果确实被禁用了，</span><br>  <span class="hljs-comment">// 那么就把当前 g 放在 sched.disable.runnable 列表中，</span><br>  <span class="hljs-comment">// 等待调度重启启用时再处理。</span><br>  <span class="hljs-comment">// 在 gc 的时候会出现这种情况：</span><br>  <span class="hljs-comment">// gcStart()    -&gt;  schedEnableUser(false)</span><br>  <span class="hljs-comment">// gcMarkDone() -&gt;  schedEnableUser(true)</span><br><span class="hljs-keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;<br>lock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> schedEnabled(gp) &#123;<br>unlock(&amp;sched.lock)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>sched.disable.runnable.pushBack(gp)<br>sched.disable.n++<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">goto</span> top<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 检查是否需要唤醒一个 P。</span><br>  <span class="hljs-comment">// 如果返回的 g 比较特殊，比如要负责 gc，那么这个值会是 true。</span><br><span class="hljs-keyword">if</span> tryWakeP &#123;<br>wakep()<br>&#125;<br>  <br>  <span class="hljs-comment">// 如果 g 已经绑定了 M，则直接启动该 M 去执行 g。</span><br><span class="hljs-keyword">if</span> gp.lockedm != <span class="hljs-number">0</span> &#123;<br>startlockedm(gp)<br><span class="hljs-keyword">goto</span> top<br>&#125;<br><br>  <span class="hljs-comment">// 执行 g</span><br>execute(gp, inheritTime)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>schedule()</code> 函数是 Go 调度器的核心，负责管理<code>goroutine</code> 的执行。它包括多个步骤，如检查当前 M的状态，处理特殊情况（如 <code>goroutine</code> 被锁定到特定的 M，或者 M正在执行 CGO 调用），以及选择和执行可运行的 <code>goroutine</code>。</p><h3 id="findrunnable">4.2 findRunnable()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Finds a runnable goroutine to execute.</span><br><span class="hljs-comment">// Tries to steal from other P&#x27;s, get g from local or global queue, poll network.</span><br><span class="hljs-comment">// tryWakeP indicates that the returned goroutine is not normal (GC worker, trace reader) so the caller should try to wake a P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRunnable</span><span class="hljs-params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="hljs-type">bool</span>) &#123;<br></code></pre></td></tr></table></figure><p>通过注释就可以知道这个函数的作用：寻找一个可执行的 goroutine：</p><ol type="1"><li>尝试从其他 P 窃取 g、从本地获取 g、从全局队列获取g、从网络轮询器获取 g；</li><li>如果是一个特殊的 g，如要负责 gc 或 trace，那么会将<code>tryWakeP</code> 置为<code>true</code>，表示调度器需要尝试唤醒或启动一个新的 P 来运行这个g，以确保了即使在系统负载较低时，这些特殊的g 也能得到及时处理。</li></ol><p>我们只关心它的核心部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRunnable</span><span class="hljs-params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="hljs-type">bool</span>) &#123;<br>  <span class="hljs-comment">// 获取当前 M</span><br>mp := getg().m<br>top:<br>  <br>  <span class="hljs-comment">// 获取 M 绑定的 P</span><br>pp := mp.p.ptr()<br><br><span class="hljs-comment">// 1. 每 61 次循环调度，就会去全局队列中获取一个 g 来执行</span><br><span class="hljs-keyword">if</span> pp.schedtick%<span class="hljs-number">61</span> == <span class="hljs-number">0</span> &amp;&amp; sched.runqsize &gt; <span class="hljs-number">0</span> &#123;<br>lock(&amp;sched.lock)<br>gp := globrunqget(pp, <span class="hljs-number">1</span>)<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">// 2. 从本地队列中获取 g</span><br><span class="hljs-keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, inheritTime, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 3. 从全局队列中获取 g</span><br><span class="hljs-keyword">if</span> sched.runqsize != <span class="hljs-number">0</span> &#123;<br>lock(&amp;sched.lock)<br>gp := globrunqget(pp, <span class="hljs-number">0</span>)<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 4. 从网络轮询器中获取 g</span><br><span class="hljs-keyword">if</span> netpollinited() &amp;&amp; netpollWaiters.Load() &gt; <span class="hljs-number">0</span> &amp;&amp; sched.lastpoll.Load() != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> list := netpoll(<span class="hljs-number">0</span>); !list.empty() &#123; <span class="hljs-comment">// non-blocking</span><br>gp := list.pop()<br>injectglist(&amp;list)<br>casgstatus(gp, _Gwaiting, _Grunnable)<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoUnpark(gp, <span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 5. 自旋，从其他 P 窃取 g</span><br>  <span class="hljs-comment">// mp.spinning 这个条件检查当前 M（操作系统线程）是否应该进入自旋状态。</span><br>  <span class="hljs-comment">// 自旋状态意味着 M 会积极地寻找工作，而不是休眠。</span><br>  <span class="hljs-comment">// 2*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load()</span><br>  <span class="hljs-comment">// 这个条件确保系统中自旋的 M 的数量不会超过一定比例。</span><br>  <span class="hljs-comment">// 这是为了防止在低并发情况下过多的 CPU 使用。</span><br><span class="hljs-keyword">if</span> mp.spinning || <span class="hljs-number">2</span>*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load() &#123;<br><span class="hljs-keyword">if</span> !mp.spinning &#123;<br>mp.becomeSpinning()<br>&#125;<br> <br>gp, inheritTime, tnow, w, newWork := stealWork(now)<br><span class="hljs-keyword">if</span> gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, inheritTime, <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> newWork &#123;<br><span class="hljs-keyword">goto</span> top<br>&#125;<br><br>now = tnow<br><span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; (pollUntil == <span class="hljs-number">0</span> || w &lt; pollUntil) &#123;<br>pollUntil = w<br>&#125;<br>&#125;<br>  ...<br><span class="hljs-keyword">goto</span> top<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个过程涉及到几个重要的函数：</p><ul><li><code>globrunqget()</code>：从全局队列中寻找可运行的 G。</li><li><code>runqget()</code>：从本地队列中寻找可运行的 G。</li><li><code>netpoll()</code>：寻找可以运行的网络协程。</li><li><code>stealWork()</code>：从其他 P 窃取可运行的 G。</li></ul><h3 id="globrunqget">4.3 globrunqget()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">globrunqget</span><span class="hljs-params">(pp *p, max <span class="hljs-type">int32</span>)</span></span> *g &#123;<br>  <span class="hljs-comment">// 抢全局列表的锁</span><br>    assertLockHeld(&amp;sched.lock)<br><br>  <span class="hljs-comment">// 如果为空则直接返回</span><br>    <span class="hljs-keyword">if</span> sched.runqsize == <span class="hljs-number">0</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>  <span class="hljs-comment">// 确定 n 的大小，即要从全局队列中获取的 g 的个数。</span><br>  <span class="hljs-comment">// 这里会结合入参 max 对边界值进行判断，以获得一个合理的 n。</span><br>  <span class="hljs-comment">// 一次性最多拿 len(pp.runq)/2 个 g。</span><br>    n := sched.runqsize/gomaxprocs + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> n &gt; sched.runqsize &#123;<br>       n = sched.runqsize<br>    &#125;<br>    <span class="hljs-keyword">if</span> max &gt; <span class="hljs-number">0</span> &amp;&amp; n &gt; max &#123;<br>       n = max<br>    &#125;<br>    <span class="hljs-keyword">if</span> n &gt; <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(pp.runq))/<span class="hljs-number">2</span> &#123;<br>       n = <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(pp.runq)) / <span class="hljs-number">2</span><br>    &#125;<br><br>    sched.runqsize -= n<br><br>  <span class="hljs-comment">// 通过 pop() 从全局队列中弹出 g</span><br>    gp := sched.runq.pop()<br>    n--<br>    <span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- &#123;<br>       gp1 := sched.runq.pop()<br>       <span class="hljs-comment">// 将 g 放入 pp 的本地队列中</span><br>       <span class="hljs-comment">// runqput 在前面创建协程的地方已经介绍过了，这里不赘述。</span><br>       runqput(pp, gp1, <span class="hljs-literal">false</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> gp<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runqget">4.4 runqget()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqget</span><span class="hljs-params">(pp *p)</span></span> (gp *g, inheritTime <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-comment">// runnext 的 g 会优先执行</span><br>next := pp.runnext<br><span class="hljs-keyword">if</span> next != <span class="hljs-number">0</span> &amp;&amp; pp.runnext.cas(next, <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> next.ptr(), <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 原子操作获取队头指针</span><br>h := atomic.LoadAcq(&amp;pp.runqhead) <br>t := pp.runqtail<br><span class="hljs-keyword">if</span> t == h &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125;<br>    <span class="hljs-comment">// 从队头获取 g，并通过原子操作更新队头（即抢这个 g）</span><br>gp := pp.runq[h%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br><span class="hljs-keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+<span class="hljs-number">1</span>) &#123; <br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runqget()</code> 函数用于从本地运行队列中获取一个可运行的<code>goroutine</code>。这个函数只能由拥有该队列的处理器（P）执行。下面是对这个函数的详细解释：</p><p><strong>1. 检查 <code>runnext</code></strong>：</p><ul><li><code>runnext</code> 是一个特殊的字段，用于存储下一个要运行的<code>goroutine</code>。如果 <code>runnext</code>非零，并且能成功通过原子操作（CAS）将其设置为零，则直接返回这个<code>goroutine</code>。</li><li>如果成功获取 <code>runnext</code> 指向的<code>goroutine</code>，<code>inheritTime</code> 被设置为<code>true</code>，表示这个 <code>goroutine</code>应该继承当前时间片的剩余时间。</li><li>如果没成功，意味着 runnext 的这个 g 已经被其他 P给抢了，因为我们可以发现本 P 只可能将其设置为 0，只有其他 P才会将其设置以为非 0。</li></ul><p><strong>2. 从本地队列中获取 <code>goroutine</code></strong>：</p><ul><li>使用原子操作加载<code>runqhead</code>（队列头指针），<code>runqtail</code>（队列尾指针）。</li><li>如果 <code>runqhead</code> 等于<code>runqtail</code>，表示队列为空，返回 <code>nil</code>。</li><li>否则，从队列中获取 <code>runqhead</code> 指向的<code>goroutine</code>，并尝试通过原子操作（CAS）更新<code>runqhead</code>。</li><li>如果更新成功，返回获取到的<code>goroutine</code>，<code>inheritTime</code> 被设置为<code>false</code>，表示这个 <code>goroutine</code>应该开始一个新的时间片。</li></ul><p>两个问题：</p><p><strong>1. 为什么获取 runqhead 需要上锁，获取 runqtail就不需要？</strong></p><p><strong>单一生产者</strong>：每个本地运行队列只有一个生产者，即与之关联的当前P。只有这个 P 可以向队列尾部添加新的<code>goroutine</code>。由于不存在多个生产者的并发写入问题，因此不需要锁来保护队尾。</p><p><strong>2. inheritTime 有什么用？</strong></p><p><code>inheritTime</code> 的主要作用是决定新调度的<code>goroutine</code>是否应该立即开始一个新的时间片，或者继续使用当前时间片的剩余部分。这在以下两种情况下尤为重要：</p><ul><li><strong>继承时间片</strong> (<code>inheritTime == true</code>)：当<code>runqget</code> 从 <code>runnext</code> 字段获取<code>goroutine</code> 时，这个 <code>goroutine</code>被认为是特别优先的，因此它继承了当前时间片的剩余时间。这通常发生在<code>goroutine</code>通过特定的同步机制（如通道操作）被明确唤醒时。</li><li><strong>开始新的时间片</strong>(<code>inheritTime == false</code>)：当 <code>runqget</code>从本地运行队列中正常获取 <code>goroutine</code> 时，这个<code>goroutine</code>将开始一个全新的时间片。这确保了调度的公平性，使得每个<code>goroutine</code> 都有机会在给定的时间片内运行。</li></ul><h3 id="netpoll">4.5 netpoll()</h3><p><code>netpoll()</code> 函数是 Go语言运行时网络轮询机制的一部分，用于检查网络连接是否准备好进行非阻塞 I/O操作。这个函数返回一组已经变为可运行状态的 <code>goroutine</code>，这些<code>goroutine</code> 之前可能因等待网络 I/O 而被挂起。</p><p>这里涉及到 Go 语言网络编程原理，在本文中不细究，就简单带过了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">netpoll</span><span class="hljs-params">(delay <span class="hljs-type">int64</span>)</span></span> gList &#123;<br>  <span class="hljs-comment">// 检查轮询器是否初始化。</span><br><span class="hljs-keyword">if</span> kq == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> gList&#123;&#125;<br>&#125;<br>  <span class="hljs-comment">// 设置轮询超时。</span><br><span class="hljs-keyword">var</span> tp *timespec<br><span class="hljs-keyword">var</span> ts timespec<br><span class="hljs-keyword">if</span> delay &lt; <span class="hljs-number">0</span> &#123;<br>tp = <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> delay == <span class="hljs-number">0</span> &#123;<br>tp = &amp;ts<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ts.setNsec(delay)<br><span class="hljs-keyword">if</span> ts.tv_sec &gt; <span class="hljs-number">1e6</span> &#123;<br>ts.tv_sec = <span class="hljs-number">1e6</span><br>&#125;<br>tp = &amp;ts<br>&#125;<br>  <span class="hljs-comment">// 使用 kevent 进行轮询操作，结果放在 events 中。</span><br><span class="hljs-keyword">var</span> events [<span class="hljs-number">64</span>]keventt<br>retry:<br>n := kevent(kq, <span class="hljs-literal">nil</span>, <span class="hljs-number">0</span>, &amp;events[<span class="hljs-number">0</span>], <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(events)), tp)<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> n != -_EINTR &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;runtime: kevent on fd&quot;</span>, kq, <span class="hljs-string">&quot;failed with&quot;</span>, -n)<br>throw(<span class="hljs-string">&quot;runtime: netpoll failed&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> delay &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> gList&#123;&#125;<br>&#125;<br><span class="hljs-keyword">goto</span> retry<br>&#125;<br>  <span class="hljs-comment">// 遍历 events 处理轮询事件。</span><br><span class="hljs-keyword">var</span> toRun gList<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">int</span>(n); i++ &#123;<br>ev := &amp;events[i]<br><br>    <span class="hljs-comment">// netpollBreakRd 用于唤醒轮询，即唤醒等待中的 goroutine。</span><br><span class="hljs-keyword">if</span> <span class="hljs-type">uintptr</span>(ev.ident) == netpollBreakRd &#123;<br><span class="hljs-keyword">if</span> ev.filter != _EVFILT_READ &#123;<br><span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;runtime: netpoll: break fd ready for&quot;</span>, ev.filter)<br>throw(<span class="hljs-string">&quot;runtime: netpoll: break fd ready for something unexpected&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> delay != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> tmp [<span class="hljs-number">16</span>]<span class="hljs-type">byte</span><br>read(<span class="hljs-type">int32</span>(netpollBreakRd), noescape(unsafe.Pointer(&amp;tmp[<span class="hljs-number">0</span>])), <span class="hljs-type">int32</span>(<span class="hljs-built_in">len</span>(tmp)))<br>netpollWakeSig.Store(<span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>    <span class="hljs-comment">// 根据轮询事件的类型（读或写），唤醒相应等待网络 I/O 的 groutine。</span><br><span class="hljs-keyword">var</span> mode <span class="hljs-type">int32</span><br><span class="hljs-keyword">switch</span> ev.filter &#123;<br><span class="hljs-keyword">case</span> _EVFILT_READ:<br>mode += <span class="hljs-string">&#x27;r&#x27;</span><br><span class="hljs-keyword">if</span> ev.flags&amp;_EV_EOF != <span class="hljs-number">0</span> &#123;<br>mode += <span class="hljs-string">&#x27;w&#x27;</span><br>&#125;<br><span class="hljs-keyword">case</span> _EVFILT_WRITE:<br>mode += <span class="hljs-string">&#x27;w&#x27;</span><br>&#125;<br><span class="hljs-keyword">if</span> mode != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> pd *pollDesc<br><span class="hljs-keyword">var</span> tag <span class="hljs-type">uintptr</span><br><span class="hljs-keyword">if</span> goarch.PtrSize == <span class="hljs-number">4</span> &#123;<br>pd = (*pollDesc)(unsafe.Pointer(ev.udata))<br>tag = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tp := taggedPointer(<span class="hljs-type">uintptr</span>(unsafe.Pointer(ev.udata)))<br>pd = (*pollDesc)(tp.pointer())<br>tag = tp.tag()<br><span class="hljs-keyword">if</span> pd.fdseq.Load() != tag &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>pd.setEventErr(ev.flags == _EV_ERROR, tag)<br>      <span class="hljs-comment">// 标记 goroutine 可执行。</span><br>netpollready(&amp;toRun, pd, mode)<br>&#125;<br>&#125;<br>  <br>  <span class="hljs-comment">// 返回可运行的 goroutine 列表。</span><br><span class="hljs-keyword">return</span> toRun<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stealwork">4.6 stealWork()</h3><p><code>stealWork()</code> 函数用于尝试从其他处理器（P）窃取可运行的<code>goroutine</code> 或定时器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stealWork</span><span class="hljs-params">(now <span class="hljs-type">int64</span>)</span></span> (gp *g, inheritTime <span class="hljs-type">bool</span>, rnow, pollUntil <span class="hljs-type">int64</span>, newWork <span class="hljs-type">bool</span>) &#123;<br>  <br>  <span class="hljs-comment">// 获取当前 M 绑定的 P。</span><br>pp := getg().m.p.ptr()<br><br>ranTimer := <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment">// 尝试 4 次。</span><br><span class="hljs-keyword">const</span> stealTries = <span class="hljs-number">4</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; stealTries; i++ &#123;<br>    <span class="hljs-comment">// 前 3 次尝试窃取 g。</span><br>    <span class="hljs-comment">// 第 4 次尝试窃取 timer，并且尝试获取其他 P 的 runnext 中的 g。</span><br>stealTimersOrRunNextG := i == stealTries<span class="hljs-number">-1</span><br><br>    <span class="hljs-comment">// 随机选一个 P。</span><br><span class="hljs-keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;<br><span class="hljs-comment">// 如果系统正在 GC，则可以直接返回 true，因为可能要负责 gc 了，有事干了。</span><br>      <span class="hljs-keyword">if</span> sched.gcwaiting.Load() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>, now, pollUntil, <span class="hljs-literal">true</span><br>&#125;<br>      <br>      <span class="hljs-comment">// 获取选中的 P，如果是当前 P 则直接 continue，重试。</span><br>p2 := allp[enum.position()]<br><span class="hljs-keyword">if</span> pp == p2 &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>      <span class="hljs-comment">// 第 4 次尝试去窃取 p2 的 timer。</span><br><span class="hljs-keyword">if</span> stealTimersOrRunNextG &amp;&amp; timerpMask.read(enum.position()) &#123;<br>        <span class="hljs-comment">// 检查并可能执行 timer。</span><br>tnow, w, ran := checkTimers(p2, now)<br>now = tnow<br><span class="hljs-keyword">if</span> w != <span class="hljs-number">0</span> &amp;&amp; (pollUntil == <span class="hljs-number">0</span> || w &lt; pollUntil) &#123;<br>pollUntil = w<br>&#125;<br>        <span class="hljs-comment">// 如果执行了 timer，则检查本地队列是否有 g 可以运行，</span><br>        <span class="hljs-comment">// 因为 timer 会唤醒被挂起的 g。</span><br><span class="hljs-keyword">if</span> ran &#123;<br><span class="hljs-keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, inheritTime, now, pollUntil, ranTimer<br>&#125;<br>ranTimer = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br>      <span class="hljs-comment">// 前 3 次尝试或者第 4 次尝试没有窃取到 timer 的时候，</span><br>      <span class="hljs-comment">// 就从其他非空闲 P 的本地队列中尝试窃取 g。</span><br><span class="hljs-keyword">if</span> !idlepMask.read(enum.position()) &#123;<br>        <span class="hljs-comment">// 如果 stealTimersOrRunNextG 为 true，</span><br>        <span class="hljs-comment">// 那么会在窃取的时候，尝试窃取 p2 的 runnext。</span><br><span class="hljs-keyword">if</span> gp := runqsteal(pp, p2, stealTimersOrRunNextG); gp != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> gp, <span class="hljs-literal">false</span>, now, pollUntil, ranTimer<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>, now, pollUntil, ranTimer<br>&#125;<br></code></pre></td></tr></table></figure><p>阅读源码的好处这就体现了，所有人都告诉我们 P 找不到可运行 G的时候就会去窃取其他 P 的G，但没人告诉我们，在这个过程<strong>还可能会去窃取其他 P 的 timer 和runnext</strong>。</p><p>所谓<code>timer</code>，即定时器，用于在指定的时间后执行某些操作。这些操作通常包括唤醒等待特定时间的<code>goroutine</code>，或执行与时间相关的任务。定时器在 Go的并发模型中扮演着重要的角色，特别是在涉及到时间延迟或周期性任务的场景中。在调度器层面，定时器的管理对于确保及时响应时间相关的事件和维持高效的调度至关重要。通过合理地处理定时器事件，Go能够在保持高并发性的同时，有效地管理时间延迟和周期性任务。</p><p>在 Go 语言的调度器中，跨 P 的定时器窃取是一种优化机制，它有 2个好处：</p><ul><li><strong>保持处理器活跃</strong>：当一个 P没有足够的本地工作时，它可以尝试从其他 P窃取定时器任务。这样做可以保持该 P活跃，避免它进入休眠状态，从而提高整体系统的效率。</li><li><strong>平衡系统负载</strong>：在多核系统中，不同的 P可能会有不同的负载。跨 P 的定时器窃取有助于在 P之间平衡负载，特别是在一些 P 非常忙碌而其他 P 相对空闲的情况下。</li></ul><p>好的，回过头来，为什么我们会说窃取的时候会从队头窃取呢？为什么是窃取p2 一半的 g 呢？这个过程就在 <code>runqsteal()</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqsteal</span><span class="hljs-params">(pp, p2 *p, stealRunNextG <span class="hljs-type">bool</span>)</span></span> *g &#123;<br>t := pp.runqtail<br>  <br>  <span class="hljs-comment">// 从 p2 中获取 n 个 g。</span><br>n := runqgrab(p2, &amp;pp.runq, t, stealRunNextG)<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>  <br>  <span class="hljs-comment">// 返回第 1 个 g，因为它可以直接执行了。</span><br>n--<br>gp := pp.runq[(t+n)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> gp<br>&#125;<br>  <span class="hljs-comment">// 如果还有剩下的 g，那么就加入到本地队列中。</span><br>  <span class="hljs-comment">// 这里可以看到是从队头加入的，所以需要使用原子操作获取队头。</span><br>h := atomic.LoadAcq(&amp;pp.runqhead)<br><span class="hljs-keyword">if</span> t-h+n &gt;= <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)) &#123;<br>throw(<span class="hljs-string">&quot;runqsteal: runq overflow&quot;</span>)<br>&#125;<br>atomic.StoreRel(&amp;pp.runqtail, t+n)<br><span class="hljs-keyword">return</span> gp<br>&#125;<br></code></pre></td></tr></table></figure><p><code>runqgrab()</code> 是窃取 n 个 g 的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqgrab</span><span class="hljs-params">(pp *p, batch *[256]guintptr, batchHead <span class="hljs-type">uint32</span>, stealRunNextG <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">uint32</span> &#123;<br>  <span class="hljs-comment">// 使用无限循环来尝试窃取工作，直到成功或确定没有可窃取的工作。</span><br><span class="hljs-keyword">for</span> &#123;<br>h := atomic.LoadAcq(&amp;pp.runqhead) <br>t := atomic.LoadAcq(&amp;pp.runqtail) <br>n := t - h<br>    <br>    <span class="hljs-comment">// 这里可以看到，要窃取的个数，就是 pp 本地队列中 g 个数的一半</span><br>n = n - n/<span class="hljs-number">2</span><br>    <br>    <span class="hljs-comment">// 如果 n 为 0，且 stealRunNextG == true，</span><br>    <span class="hljs-comment">// 那么就尝试窃取 pp 的 runnext 中的 g。</span><br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> stealRunNextG &#123;<br><span class="hljs-keyword">if</span> next := pp.runnext; next != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> !pp.runnext.cas(next, <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>batch[batchHead%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(batch))] = next<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br>    <br>    <span class="hljs-comment">// 如果 n 不为队列长度的一半，则说明队列发生了变化，</span><br>    <span class="hljs-comment">// 这个时候重新尝试窃取。</span><br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span>) &#123; <br><span class="hljs-keyword">continue</span><br>&#125;<br>    <span class="hljs-comment">// 将要窃取的 g 从 pp.runq 中转移到 batch 中。</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>g := pp.runq[(h+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))]<br>batch[(batchHead+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(batch))] = g<br>&#125;<br>    <span class="hljs-comment">// 使用原子操作尝试更新 pp 的队列头部，即将 g 从 pp.runq 中移除。</span><br><span class="hljs-keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123; <br><span class="hljs-keyword">return</span> n<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>findRunnable()</code>的全部过程我们总算是梳理完了，这个过程确实非常精彩，Go调度器在提高调度性能、确保调度的公平性、平衡系统负载、降低同步开销、减少资源再分配等方面都做了很多的努力，这才让Go 语言的并发又强大又易用。</p><p>下面是对 <code>findRunnable()</code> 一个简单的总结：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240128212451142.png"alt="findRunnable()" /><figcaption aria-hidden="true">findRunnable()</figcaption></figure><h3 id="execute">4.7 execute()</h3><p><code>findRunnable()</code> 之后就是<code>execute()</code>，它的核心过程如下（有删减）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">execute</span><span class="hljs-params">(gp *g, inheritTime <span class="hljs-type">bool</span>)</span></span> &#123;<br>mp := getg().m<br><span class="hljs-comment">// 将 g0 d 线程信息复制到即将要调用的协程 gp 中。</span><br>mp.curg = gp<br>gp.m = mp<br>  <span class="hljs-comment">// 修改 gp 的状态为 _Grunning，即运行中。</span><br>casgstatus(gp, _Grunnable, _Grunning)<br>gp.waitsince = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 标记为非抢占</span><br>gp.preempt = <span class="hljs-literal">false</span><br>  <span class="hljs-comment">// 用于栈保护，检测栈溢出</span><br>gp.stackguard0 = gp.stack.lo + stackGuard<br>  <span class="hljs-comment">// gogo 会完成 g0 到 g 的协程栈的切换，并从 gp.sched 开始执行。</span><br>  <span class="hljs-comment">// sched 字段我们前面介绍过，它是 gobuf 结构体，存储了 sp 和 pc。</span><br>gogo(&amp;gp.sched)<br>&#125;<br></code></pre></td></tr></table></figure><p>所以 <code>execute()</code> 的工作非常简单，其实就是将 g0的线程信息复制到 gp 上，并修改状态和一些元数据，核心部分其实在<code>gogo()</code> 中。</p><h3 id="gogo">4.8 gogo()</h3><p>前面我们说过，<code>gogo()</code> 会完成 g0 栈到 g栈的切换，且在不同平台下有不同的视线，这里我们以 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/asm_arm64.s">asm_arm64.s</a>为代表来看一下 <code>gogo()</code> 的汇编实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly">TEXT runtime·gogo(SB), NOSPLIT|NOFRAME, $0-8<br>MOVDbuf+0(FP), R5<br>MOVDgobuf_g(R5), R6<br>MOVD0(R6), R4// make sure g != nil<br>Bgogo&lt;&gt;(SB)<br><br>TEXT gogo&lt;&gt;(SB), NOSPLIT|NOFRAME, $0<br>MOVDR6, g<br>BLruntime·save_g(SB)<br><br>MOVDgobuf_sp(R5), R0<br>MOVDR0, RSP<br>MOVDgobuf_bp(R5), R29<br>MOVDgobuf_lr(R5), LR<br>MOVDgobuf_ret(R5), R0<br>MOVDgobuf_ctxt(R5), R26<br>MOVD$0, gobuf_sp(R5)<br>MOVD$0, gobuf_bp(R5)<br>MOVD$0, gobuf_ret(R5)<br>MOVD$0, gobuf_lr(R5)<br>MOVD$0, gobuf_ctxt(R5)<br>CMPZR, ZR // set condition codes for == test, needed by stack split<br>MOVDgobuf_pc(R5), R6<br>B(R6)<br></code></pre></td></tr></table></figure><p>具体过程如下：</p><ol type="1"><li><strong><code>runtime·gogo</code>函数</strong>：这个函数用于设置新的 <code>goroutine</code>上下文。它接收一个指向 <code>gobuf</code>结构的指针（<code>buf+0(FP)</code>），该结构包含了<code>goroutine</code> 的上下文信息。</li><li><strong>加载 <code>gobuf</code> 并检查 <code>g</code></strong>：加载<code>gobuf</code> 结构，并检查 <code>g</code> 是否为<code>nil</code>。</li><li><strong>跳转到 <code>gogo&lt;&gt;</code></strong>：执行无条件跳转到<code>gogo&lt;&gt;</code> 函数。</li><li><strong><code>gogo&lt;&gt;</code>函数</strong>：这个函数实际上完成了上下文切换。<ul><li>设置当前 <code>goroutine</code>：将 <code>R6</code>寄存器中的值（新的 <code>goroutine</code>）设置为当前<code>goroutine</code>。</li><li>保存当前 <code>goroutine</code>：调用 <code>runtime·save_g</code>保存当前 <code>goroutine</code> 的状态。</li><li>恢复栈指针和其他寄存器：从 <code>gobuf</code>结构中恢复栈指针（<code>RSP</code>）、基指针（<code>R29</code>）、链接寄存器（<code>LR</code>）、返回值（<code>R0</code>）和上下文（<code>R26</code>）。</li><li>清空 <code>gobuf</code> 结构：将 <code>gobuf</code>结构中的字段清零。</li><li>准备跳转到新的程序计数器位置：从 <code>gobuf</code>中加载新的程序计数器地址（<code>gobuf_pc(R5)</code>）到<code>R6</code>。</li><li>跳转执行：通过 <code>B (R6)</code>跳转到新的程序计数器地址，继续执行新 <code>goroutine</code>的代码。</li></ul></li></ol><p>这段汇编代码是 Go 运行时中处理 <code>goroutine</code>上下文切换的关键部分。它直接操作处理器的寄存器和栈，以实现从一个<code>goroutine</code> 切换到另一个 <code>goroutine</code> 的功能。</p><p>在 <code>execute()</code> 中是这么调用 <code>gogo()</code> 的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">gogo(&amp;gp.sched)<br></code></pre></td></tr></table></figure><p>所以完成栈的切换后会从 <code>gp.sched</code>开始，执行代码，前面我们介绍过 <code>sched</code> 是一个<code>gobuf</code> 结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;<br>sp   <span class="hljs-type">uintptr</span><br>pc   <span class="hljs-type">uintptr</span><br>g    guintptr<br>ctxt unsafe.Pointer<br>ret  <span class="hljs-type">uintptr</span><br>lr   <span class="hljs-type">uintptr</span><br>bp   <span class="hljs-type">uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以会从 pc 处开始执行业务代码，前面在 <code>newproc()</code>的时候，我们提过一行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum<br></code></pre></td></tr></table></figure><p>这行代码的作用，是在协程创建的时候插入一个 <code>goexit</code>函数的地址，因为这个时候 <code>g</code>刚创建，所以其实就是往协程栈顶插入了 <code>goexit</code> 的地址。所以当<code>g</code> 执行完业务代码后，当栈中元素不断弹出后，最终就会弹出<code>goexit</code> 的地址，然后执行 <code>goexit()</code>函数，退出当前 <code>g</code>，切换回 <code>g0</code>。</p><h3 id="goexit">4.9 goexit()</h3><p><code>goexit</code> 定义在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/stubs.go">runtime/stubs.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// goexit is the return stub at the top of every goroutine call stack.</span><br><span class="hljs-comment">// Each goroutine stack is constructed as if goexit called the</span><br><span class="hljs-comment">// goroutine&#x27;s entry point function, so that when the entry point</span><br><span class="hljs-comment">// function returns, it will return to goexit, which will call goexit1</span><br><span class="hljs-comment">// to perform the actual exit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function must never be called directly. Call goexit1 instead.</span><br><span class="hljs-comment">// gentraceback assumes that goexit terminates the stack. A direct</span><br><span class="hljs-comment">// call on the stack will cause gentraceback to stop walking the stack</span><br><span class="hljs-comment">// prematurely and if there is leftover state it may panic.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit</span><span class="hljs-params">(neverCallThisFunction)</span></span><br></code></pre></td></tr></table></figure><p>通过注释我们可以得到 2 个信息：</p><ul><li><code>goexit</code> 的位于每个 goroutine 调用栈的顶部。每个goroutine 的栈被构造得好像 <code>goexit</code> 调用了 goroutine的入口函数。这意味着当入口函数返回时，它实际上返回到<code>goexit</code>。</li><li>不要直接调用 <code>goexit</code>，应该调用<code>goexit1</code>。</li></ul><p><code>goexit1</code> 位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Finishes execution of the current goroutine.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit1</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racegoend()<br>&#125;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoEnd()<br>&#125;<br>mcall(goexit0)<br>&#125;<br></code></pre></td></tr></table></figure><p>好吧，它调用了<code>goexit0</code>，原来这才是真正的退出入口，它也位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goexit0</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>  <span class="hljs-comment">// 获取当前的 M 和 P</span><br>mp := getg().m<br>pp := mp.p.ptr()<br><br>  <span class="hljs-comment">// 修改 gp 的状态为 _Gdead，标志它的终止</span><br>casgstatus(gp, _Grunning, _Gdead)<br>  <span class="hljs-comment">// 标记 gc 的栈内存是可以进行 gc 扫描的</span><br>gcController.addScannableStack(pp, -<span class="hljs-type">int64</span>(gp.stack.hi-gp.stack.lo))<br><span class="hljs-comment">// 如果 gp 是系统 goroutine，则将系统 goroutine 的计数减少</span><br>  <span class="hljs-keyword">if</span> isSystemGoroutine(gp, <span class="hljs-literal">false</span>) &#123;<br>sched.ngsys.Add(<span class="hljs-number">-1</span>)<br>&#125;<br>  <span class="hljs-comment">// 清理 gp 的状态</span><br>gp.m = <span class="hljs-literal">nil</span><br>locked := gp.lockedm != <span class="hljs-number">0</span><br>gp.lockedm = <span class="hljs-number">0</span><br>mp.lockedg = <span class="hljs-number">0</span><br>gp.preemptStop = <span class="hljs-literal">false</span><br>gp.paniconfault = <span class="hljs-literal">false</span><br>gp._defer = <span class="hljs-literal">nil</span> <br>gp._panic = <span class="hljs-literal">nil</span><br>gp.writebuf = <span class="hljs-literal">nil</span><br>gp.waitreason = waitReasonZero<br>gp.param = <span class="hljs-literal">nil</span><br>gp.labels = <span class="hljs-literal">nil</span><br>gp.timer = <span class="hljs-literal">nil</span><br><br>  <span class="hljs-comment">// 如果启用了垃圾回收（GC）并且 gp.gcAssistBytes 大于 0，</span><br>  <span class="hljs-comment">// 则将辅助信用归还给全局池。这有助于更好地控制垃圾回收进程。</span><br><span class="hljs-keyword">if</span> gcBlackenEnabled != <span class="hljs-number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="hljs-number">0</span> &#123;<br>assistWorkPerByte := gcController.assistWorkPerByte.Load()<br>scanCredit := <span class="hljs-type">int64</span>(assistWorkPerByte * <span class="hljs-type">float64</span>(gp.gcAssistBytes))<br>gcController.bgScanCredit.Add(scanCredit)<br>gp.gcAssistBytes = <span class="hljs-number">0</span><br>&#125;<br><br>  <span class="hljs-comment">// 将当前 g 从 P 的运行队列中移除</span><br>dropg()<br><br>  <span class="hljs-comment">// WebAssembly 平台特殊处理</span><br><span class="hljs-keyword">if</span> GOARCH == <span class="hljs-string">&quot;wasm&quot;</span> &#123; <br>gfput(pp, gp)<br>schedule() <br>&#125;<br><br>  <span class="hljs-comment">// 将 gp 放回处理器的可用队列中，这样可以复用 g</span><br>gfput(pp, gp)<br><br>  <span class="hljs-comment">// 如果 goroutine 被绑定到当前线程上，</span><br>  <span class="hljs-comment">// 那可能是在做系统调用，cgo 调用或其他特殊任务，</span><br>  <span class="hljs-comment">// 那么就需要切到 g0，让 g0 来完成后面的调度。</span><br>  <span class="hljs-keyword">if</span> locked &#123;<br><span class="hljs-comment">// 如果 goroutine 在终止前曾锁定当前线程，</span><br>    <span class="hljs-comment">// 则根据不同的操作系统执行不同的处理。</span><br>    <span class="hljs-comment">// 在大多数操作系统上，会跳转到 mstart 函数，释放 P 并退出线程。</span><br>    <span class="hljs-comment">// 但在 Plan 9 操作系统上，会清除 lockedExt。</span><br><span class="hljs-keyword">if</span> GOOS != <span class="hljs-string">&quot;plan9&quot;</span> &#123; <span class="hljs-comment">// See golang.org/issue/22227.</span><br>gogo(&amp;mp.g0.sched)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mp.lockedExt = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>  <br>  <span class="hljs-comment">// 继续调度</span><br>  <span class="hljs-comment">// 如果执行了 gogo，那就是 g0 在调度。</span><br>  <span class="hljs-comment">// 如果没有执行 gogo，那就是 gp 在调度。</span><br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里我们就完成了对 GPM 调度循环的全过程源码分析了，你可以回到 <ahref="##4.%20调度过程%20schedule()">4. 调度过程 schedule()</a>看一下我总结的那张图，这回你应该会有更加深入的理解了。</p><h2 id="协程切换">5. 协程切换</h2><p>如果要一个协程要一直到执行完毕才退出的话，那很可能会造成其他协程饥饿的问题。所以Go其实会在一些特殊的时机对协程进行切换，这个过程有抢占式调度，也有协作式的调度。</p><p>协程切换的时候，最核心的就是要保存当前协程的现场，以方便回到该协程的时候继续执行剩下的内容。大致过程如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57vi6wrdqj21ho0sqjtn.jpg"alt="Go 协程切换" /><figcaption aria-hidden="true">Go 协程切换</figcaption></figure><p>有哪些时机会触发切换呢，这里我直接给出结论：</p><p>基于协作的抢占式调度</p><ul><li>主动挂起：<code>runtime.gopark()</code></li><li>系统调用结束时：<code>exitsyscall()</code></li><li>函数跳转时：<code>morestack()</code></li></ul><p>基于信号的抢占式调度</p><ul><li>信号调度：<code>doSigPreempt()</code></li></ul><h3 id="主动挂起-runtime.gopack">5.1 主动挂起 runtime.gopack()</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57vq4flf5j21j20s4jto.jpg"alt="gopack 协程切换" /><figcaption aria-hidden="true">gopack 协程切换</figcaption></figure><p>这个函数位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gopark</span><span class="hljs-params">(unlockf <span class="hljs-keyword">func</span>(*g, unsafe.Pointer)</span></span> <span class="hljs-type">bool</span>, lock unsafe.Pointer, reason waitReason, traceReason traceBlockReason, traceskip <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> reason != waitReasonSleep &#123;<br>checkTimeouts() <br>&#125;<br>mp := acquirem()<br>gp := mp.curg<br>status := readgstatus(gp)<br><span class="hljs-keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;<br>throw(<span class="hljs-string">&quot;gopark: bad g status&quot;</span>)<br>&#125;<br>mp.waitlock = lock<br>mp.waitunlockf = unlockf<br>gp.waitreason = reason<br>mp.waitTraceBlockReason = traceReason<br>mp.waitTraceSkip = traceskip<br>releasem(mp)<br>mcall(park_m)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>gopark</code> 函数的主要目的是使 G进入休眠状态，等待被唤醒。</p><p>最后它调用了 <code>mcall()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// mcall switches from the g to the g0 stack and invokes fn(g)</span><br><span class="hljs-comment">// mcall 切换到 g0，并执行 fn。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mcall</span><span class="hljs-params">(fn <span class="hljs-keyword">func</span>(*g)</span></span>)<br></code></pre></td></tr></table></figure><p>所以这里切换回 <code>g0</code>，并执行了 <code>pack_m</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">park_m</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pack_m()</code> 其实就是调用了 <code>schedule()</code>去进行下一轮调度，这就完成了协程的切换。</p><p>当协程被阻塞的时候，就会去调用 <code>runtime.gopark()</code> 主动让出CPU，切回 <code>g0</code>，等待被唤醒，以此保证最大化利用 CPU资源。比如以下几种情况：</p><ul><li>休眠</li><li>channel 通道阻塞</li><li>网络 I/O 阻塞</li><li>因为执行垃圾回收而暂停</li></ul><h3 id="系统调用结束时-exitsyscall">5.2 系统调用结束时exitsyscall()</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/e6c9d24egy1h57vx0tfayj21g60r4tb4.jpg"alt="exitsyscall 协程切换" /><figcaption aria-hidden="true">exitsyscall 协程切换</figcaption></figure><p>Go 通过 <code>entersyscall()</code> 进行系统调用，完事后会执行<code>exitsyscall()</code>，它也位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exitsyscall</span><span class="hljs-params">()</span></span> &#123;<br>...<br>mcall(exitsyscall0)<br>&#125;<br></code></pre></td></tr></table></figure><p>其实它最终也是调用 <code>mcall()</code> 切换到 <code>g0</code>，我们不难猜出，它这里让 <code>g0</code> 去执行 <code>exitsyscall0</code>函数，做完系统调用的善后后，肯定还是会执行 <code>schedule()</code>函数进行协程调度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exitsyscall0</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数跳转时-morestack">5.3 函数跳转时 morestack()</h3><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57w74gg19j21iq0smwgs.jpg"alt="morestack 协程切换" /><figcaption aria-hidden="true">morestack 协程切换</figcaption></figure><p>因为函数跳转意味着“压栈”，函数跳转时都会调用这个方法，它的本意在于检查当前协程栈空间是否有足够内存，如果不够就要扩大该栈空间。</p><p>为了让每个协程都有执行的机会，并且最大化利用 CPU 资源，Go语言在初始化时会启动一个特殊的线程来执行系统监控任务，系统监控在一个独立的M 上运行，不用绑定逻辑处理器 P。当系统监控到协程运行超过<code>10ms</code>，就将 <code>g.stackguard0</code> 置为<code>stackPreempt</code>（该值是一个抢占标志）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> forcePreemptNS = <span class="hljs-number">10</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> <span class="hljs-comment">// 10ms</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">retake</span><span class="hljs-params">(now <span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">uint32</span> &#123;<br><span class="hljs-comment">// 遍历所有的 P</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(allp); i++ &#123;<br>pp := allp[i]<br>pd := &amp;pp.sysmontick<br>s := pp.status<br>sysretake := <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> s == _Prunning || s == _Psyscall &#123;<br>t := <span class="hljs-type">int64</span>(pp.schedtick)<br><span class="hljs-keyword">if</span> <span class="hljs-type">int64</span>(pd.schedtick) != t &#123;<br>pd.schedtick = <span class="hljs-type">uint32</span>(t)<br>pd.schedwhen = now<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now &#123;<br>        <span class="hljs-comment">// 如果 G 运行时间过长，超过了 forcePreemptNS(10ms)，</span><br>        <span class="hljs-comment">// 则标记抢占</span><br>preemptone(pp)<br>sysretake = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> s == _Psyscall &#123;<br>      <span class="hljs-comment">// 如果是系统调用，且已经超过了一个系统监控的 tick(20us)，</span><br>      <span class="hljs-comment">// 则从系统调用中抢占 p。</span><br>      t := <span class="hljs-type">int64</span>(pp.syscalltick)<br><span class="hljs-keyword">if</span> !sysretake &amp;&amp; <span class="hljs-type">int64</span>(pd.syscalltick) != t &#123;<br>pd.syscalltick = <span class="hljs-type">uint32</span>(t)<br>pd.syscallwhen = now<br><span class="hljs-keyword">continue</span><br>&#125;<br>...<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 标记抢占</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preemptone</span><span class="hljs-params">(pp *p)</span></span> <span class="hljs-type">bool</span> &#123;<br>mp := pp.m.ptr()<br>gp := mp.curg<br>gp.preempt = <span class="hljs-literal">true</span><br>gp.stackguard0 = stackPreempt<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>巧的就是，Go 设计者，让程序在执行 <code>morestack()</code>函数时顺便判断一下 <code>g</code> 中的 <code>stackguard</code>是否已经被置为抢占 <code>stackPreempt</code>，如果的确被标记抢占，就回到<code>schedule()</code> 方法，并将当前协程放回队列中。</p><p><code>morestack</code> 是汇编实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">TEXT runtime·morestack(SB),NOSPLIT|NOFRAME,$0-0<br>...<br>BLruntime·newstack(SB)<br></code></pre></td></tr></table></figure><p>它最终会调用 <code>newstack()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newstack</span><span class="hljs-params">()</span></span> &#123;<br>  thisg := getg()<br>  gp := thisg.m.curg<br>  <span class="hljs-comment">// 1. 判断 gp.stackguard0 是否被标记为抢占</span><br>  stackguard0 := atomic.Loaduintptr(&amp;gp.stackguard0)<br>preempt := stackguard0 == stackPreempt<br>  <span class="hljs-comment">// 2. 如果被标记位抢占，调用 gopreempt_m()</span><br>  <span class="hljs-keyword">if</span> preempt &#123;<br><span class="hljs-comment">// 3. 最终会去调用  schedule() 去调新的协程执行</span><br>gopreempt_m(gp) <span class="hljs-comment">// never return</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gopreempt_m</span><span class="hljs-params">(gp *g)</span></span> &#123;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoPreempt()<br>&#125;<br>goschedImpl(gp)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goschedImpl</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号调度-dosigpreempt">5.4 信号调度 doSigPreempt()</h3><p>当程序在执行过程中既无法主动挂起，也不能进行系统调用，且无法进行函数调用时，就可以使用信号来调度。</p><p>信号其实就是线程信号，在操作系统中有很多基于信号的底层通信方式（SIGPIPE/ SIGURG / SIGHUP），而我们的线程可以注册对应信号的处理函数。</p><p>Go 中是注册了 <code>SIGURG</code> 信号的处理函数<code>doSigPreempt()</code>，在 GC工作时，向目标线程发送信号。线程收到信号后，会触发调度。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57wecvgwdj21hk0ssgny.jpg"alt="doSigPreempt 协程切换" /><figcaption aria-hidden="true">doSigPreempt 协程切换</figcaption></figure><p><code>doSigPreempt</code> 位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/signal_unix.go">runtime.signal_unix.go</a>中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSigPreempt</span><span class="hljs-params">(gp *g, ctxt *sigctxt)</span></span> &#123;<br><span class="hljs-comment">// 检查此 g 是否要被抢占并且安全抢占</span><br><span class="hljs-keyword">if</span> wantAsyncPreempt(gp) &#123;<br><span class="hljs-keyword">if</span> ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok &#123;<br><span class="hljs-comment">// 2. 调整程序计数器 PC 并异步调用 asyncPreempt</span><br>ctxt.pushCall(abi.FuncPCABI0(asyncPreempt), newpc)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>asyncPreempt</code> 的实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncPreempt</span><span class="hljs-params">()</span></span><br><br><span class="hljs-comment">// </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncPreempt2</span><span class="hljs-params">()</span></span> &#123;<br>gp := getg()<br>gp.asyncSafePoint = <span class="hljs-literal">true</span><br>  <span class="hljs-comment">// </span><br><span class="hljs-keyword">if</span> gp.preemptStop &#123;<br>mcall(preemptPark)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mcall(gopreempt_m)<br>&#125;<br>gp.asyncSafePoint = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>asyncPreempt</code> 是汇编实现，最终是调的<code>asyncPreempt2</code>，它会调用 <code>mcall</code> 切回<code>g0</code>，并执行 <code>preemptPark</code> 或<code>gopreempt_m</code>， <code>gopreempt_m</code> 就是前面<code>morestack</code> 最后调的！不出意外，<code>preemptPack</code>最后肯定还是调的 <code>schedule()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preemptPark</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>...<br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="runtime.gosched">5.5 runtime.Gosched()</h3><p>在我们实际编程中，你可以通过显式调用 <code>runtime.Gosched()</code>来主动让出 CPU，促进 Go 的下一轮调度，我们来看它的具体实现，肯定还是调的<code>schedule()</code>，没有意外！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Gosched</span><span class="hljs-params">()</span></span> &#123;<br>checkTimeouts()<br>mcall(gosched_m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gosched_m</span><span class="hljs-params">(gp *g)</span></span> &#123;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoSched()<br>&#125;<br>goschedImpl(gp)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goschedImpl</span><span class="hljs-params">(gp *g)</span></span> &#123;<br>status := readgstatus(gp)<br><span class="hljs-keyword">if</span> status&amp;^_Gscan != _Grunning &#123;<br>dumpgstatus(gp)<br>throw(<span class="hljs-string">&quot;bad g status&quot;</span>)<br>&#125;<br>casgstatus(gp, _Grunning, _Grunnable)<br>dropg()<br>lock(&amp;sched.lock)<br>globrunqput(gp)<br>unlock(&amp;sched.lock)<br><br>schedule()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结">5.6 总结</h3><p>Go 语言为了确保 P 不会因为 G运行时间过长或系统调用阻塞时间过长而导致性能下降。它会尝试进行协程切换，以确保任务可以适时地被分配和执行。这有助于保持Go程序的并发性能和响应性。而协程切换的方式有基于协作的抢占式调度（主动挂起<code>runtime.gopark()</code>，系统调用结束时<code>exitsyscall()</code>，函数跳转时<code>morestack()</code>），也有基于信号的抢占式调度<code>doSigPreempt()</code>，他们都无一例外的最终调用了<code>schedule()</code>。</p><p>所以总结下来其实还是这张图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/e6c9d24egy1h57vi6wrdqj21ho0sqjtn.jpg"alt="Go 协程切换" /><figcaption aria-hidden="true">Go 协程切换</figcaption></figure><h1 id="gpm-状态流转">G、P、M 状态流转</h1><p>经过我们前面的分析，你可以自行整理 G、P、M状态的流转，这里我给出几张图供你参考：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126224853429.png"alt="Go 协程（G）状态转换图" /><figcaption aria-hidden="true">Go 协程（G）状态转换图</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126225021035.png"alt="Go 处理器（P）状态转换图" /><figcaption aria-hidden="true">Go 处理器（P）状态转换图</figcaption></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240126225849169.png"alt="Go M（操作系统线程）状态转换" /><figcaption aria-hidden="true">Go M（操作系统线程）状态转换</figcaption></figure><h1 id="总结-1">总结</h1><p>以上便是对 Go 语言 GPM 模型的全部分享啦！GPM 模型使得 Go语言能够并发执行成千上万个协程。</p><p>为了减少线程“相对昂贵”的切换代价，Go 引入了 GPM，将大量的 Goroutine分配到少量的系统线程上去执行，并利用多核并行，实现更强大的并发。</p><p>为了减小并发冲突，Go 在全局队列的基础上引入了本地队列。</p><p>为了避免协程饥饿，Go 又引入了多种协程调度的策略。</p><p>为了避免协程阻塞浪费 CPU，Go 引入了多种协程切换的方式。</p><p>Go 语言设计者进行了如此复杂的调度器实现，最终交付给 Gopher的，仅仅是一个 <code>go</code>关键字这么简单，真的是大道至简，这也是充分印证了那句话：“Go为并发而生”。</p><p>希望本文能对你有所帮助，enjoy~ happy coding~</p><h1 id="参考">参考</h1><ul><li><a href="https://book.douban.com/subject/36403287/">深入理解 Go语言</a></li><li><a href="https://book.douban.com/subject/35556889/">Go语言底层原理剖析</a></li><li><a href="https://coding.imooc.com/class/576.html">深入 Go底层原理</a></li><li>ChatGPT4</li></ul><h1 id="作图工具">作图工具</h1><ul><li><a href="https://excalidraw.com/">excalidraw</a></li><li><a href="https://whimsical.com/">whimsical</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 实战丨绘制曼德博集</title>
    <link href="/2024/01/17/rust-action-mandelbrot/"/>
    <url>/2024/01/17/rust-action-mandelbrot/</url>
    
    <content type="html"><![CDATA[<h1 id="曼德博集">曼德博集</h1><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/2560px-Mandelset_hires-20240118170914026.png"alt="曼德博集" /><figcaption aria-hidden="true">曼德博集</figcaption></figure><p>曼德博集其实是一个“没什么用”的发现。</p><p>曼德博集（MandelbrotSet）是一种在复平面上形成独特且复杂图案的点的集合。这个集合是以数学家本华·曼德博（BenoitMandelbrot）的名字命名的，他在研究复杂结构和混沌理论时发现了这个集合。曼德博集是分形几何的一个经典例子，显示了一个简单的数学公式如何能产生无限复杂和美丽的图案。</p><p>曼德博集的定义相对简单。对于每一个复数 <spanclass="math inline">\(c\)</span>，我们考虑以下迭代序列： <spanclass="math display">\[Z_{n+1} = z_n^2 + c \;\;\\ 其中 \;\; (z_0 = 0)\]</span> <strong>曼德博集合由那些使得上述序列不趋于无限大的复数 <spanclass="math inline">\(c\)</span>组成</strong>。在复平面上，这些点形成了一种独特的图案，通常以一种美丽且艺术的方式呈现。这个图案的边界非常复杂，包含了无限的细节和自相似的结构。这意味着无论你放大图案的哪一部分，你都会发现越来越精细的结构，这些结构在形式上与整体图案相似。</p><p>曼德博集合不仅在数学上有意义，也在艺术和科学中有广泛的应用，尤其是在研究混沌理论和复杂系统时。</p><p>具体可以看</p><ul><li><ahref="https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%BE%B7%E5%8D%9A%E9%9B%86%E5%90%88">维基百科-曼德博集</a></li><li><a href="https://www.bilibili.com/video/BV1kA411T7at">bilibili -2000亿倍放大曼德博集</a></li></ul><h1 id="目标功能">目标功能</h1><p>最终我们将实现一个命令行工具，它会根据我们输入的参数生成曼德博集图，使用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./mandelbrot &lt;FILE&gt; &lt;PIXELS&gt; &lt;UPPERLEFT&gt; &lt;LOWERRIGHT&gt;<br></code></pre></td></tr></table></figure><ul><li><code>FILE</code>: 曼德博集图生成的图片路经。</li><li><code>PIXELS</code>: 图片分辨率，如 <code>4x3</code>。</li><li><code>UPPERLEFT</code>: 指定在复平面中图片覆盖的左上角，如<code>4.0,3.0</code>。</li><li><code>LOWERRIGHT</code>: 制定在复平面中图片覆盖的右下角。</li></ul><p>所以我们最终会根据指定的图片范围，截取 <code>PIXELS</code>分辨率大小的曼德博集图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240118171322832.png"alt="截取曼德博集示意图" /><figcaption aria-hidden="true">截取曼德博集示意图</figcaption></figure><p>基于以上目标，我们拆分成几个问题：</p><ol type="1"><li>如何表示复数？</li><li>如何解析分辨率和坐标？</li><li>如何将图上像素映射到复数？</li><li>如何生成曼德博集图？即如何找到那些符合曼德博集的点，并将其进行着色标注？</li><li>如何写入图片文件？</li><li>如何渲染曼德博集？</li><li>如何解析命令行参数？</li><li>如何并发写入图片文件？</li></ol><h1 id="能学到什么">能学到什么</h1><ol type="1"><li>曼德博集是什么？</li><li>Rust 中的复数的原理与应用。</li><li>Rust 泛型初探。</li><li>Rust 中的 Option 和 Result 初探。</li><li>Rust 并发初探。</li><li>Rust 中如何解析命令行参数？</li><li>Rust 如何写入图像文件？</li><li>Rust 如何写测试用例？</li><li>Rust 实用 crate<code>num</code>、<code>image</code>、<code>crossbeam</code>。</li></ol><h1 id="版本">版本</h1><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;mandelbrot&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">image</span> = &#123;version = <span class="hljs-string">&quot;0.13.0&quot;</span>, features = [<span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;png&quot;</span>]&#125;<br><span class="hljs-attr">num</span> = <span class="hljs-string">&quot;0.4.1&quot;</span><br><span class="hljs-attr">crossbeam</span> = <span class="hljs-string">&quot;0.8&quot;</span><br><span class="hljs-attr">rayon</span> = <span class="hljs-string">&quot;1.10.0&quot;</span><br></code></pre></td></tr></table></figure><p>完整代码：https://github.com/hedon954/mandelbrot/blob/master/src/main.rs</p><h1 id="编码实现">编码实现</h1><h2 id="创建项目">0. 创建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new mandelbrot<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> mandelbrot<br></code></pre></td></tr></table></figure><h2 id="复数表示">1. 复数表示</h2><p>使用复数，我们需要引入一个 crete：<code>num</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add num<br></code></pre></td></tr></table></figure><p>其中定义了一个复数类型 <code>Complex</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/// 复数的实部</span><br>    <span class="hljs-keyword">pub</span> re: T,<br>    <span class="hljs-comment">/// 复数的虚部</span><br>    <span class="hljs-keyword">pub</span> im: T,<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>T</code> 是 Rust 中的泛型功能，表示任意类型<code>T</code>，确定好这个结构体的 <code>T</code> 的类型后，其中的属性<code>re</code> 和 <code>im</code> 的类型也就随之确定了。</p><h2 id="解析分辨率和坐标">2. 解析分辨率和坐标</h2><ul><li>分辨率格式为：4000x3000</li><li>坐标格式为：-1.0,2.0</li></ul><h3 id="解析数对">2.1 解析数对</h3><p>我们要做的就是，将分辨率拆成 (4000,3000)，将坐标拆为 (-1.0,2.0)。这里：</p><ul><li>带解析的元素 <code>s</code> 是一个字符串<code>&amp;str</code>。</li><li>分隔符 <code>separator</code> 是一个字符 <code>char</code>。</li><li>返回值是一个元组 <code>(T, T)</code>，其中 <code>T</code> 这里可以是u64/f32 等数字，它们都需要能从字符串转化而来，即<code>&lt;T:FromStr&gt;</code>。</li><li>因为解析可能出错，所以我们使用 <code>Option</code> 来承载。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 把字符串 `s`（形如 `&quot;400×600&quot;` 或 ``&quot;1.0,0.5&quot;）解析成一个坐标对</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// 具体来说，`s` 应该具有&lt;left&gt;&lt;sep&gt;&lt;right&gt;的格式，其中&lt;sep&gt;是由`separator`</span><br><span class="hljs-comment">/// 参数给出的字符，而&lt;left&gt;和&lt;right&gt;是可以被 `T:from_str` 解析的字符串。</span><br><span class="hljs-comment">/// `separator` 必须是 ASCII 字符</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// 如果 `s` 具有正确的格式，就返回 `Some(x,y)`，否则返回 `None`</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pair</span>&lt;T: FromStr&gt;(s: &amp;<span class="hljs-type">str</span>, separator: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;(T, T)&gt; &#123;<br>    <span class="hljs-keyword">match</span> s.<span class="hljs-title function_ invoke__">find</span>(separator) &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>        <span class="hljs-title function_ invoke__">Some</span>(index) =&gt; <span class="hljs-keyword">match</span> (T::<span class="hljs-title function_ invoke__">from_str</span>(&amp;s[..index]), T::<span class="hljs-title function_ invoke__">from_str</span>(&amp;s[index + <span class="hljs-number">1</span>..])) &#123;<br>            (<span class="hljs-title function_ invoke__">Ok</span>(l), <span class="hljs-title function_ invoke__">Ok</span>(r)) =&gt; <span class="hljs-title function_ invoke__">Some</span>((l, r)),<br>            _ =&gt; <span class="hljs-literal">None</span>,<br>        &#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以写几个测试用例来验证一下这个函数的正确性，这里我们用到<code>#[test]</code> 和 <code>assert_eq!</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_parse_pair</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;10,&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;,10&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;10,20&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)));<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">i32</span>&gt;(<span class="hljs-string">&quot;10,20xy&quot;</span>, <span class="hljs-string">&#x27;,&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">f64</span>&gt;(<span class="hljs-string">&quot;0.5x&quot;</span>, <span class="hljs-string">&#x27;x&#x27;</span>), <span class="hljs-literal">None</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(parse_pair::&lt;<span class="hljs-type">f64</span>&gt;(<span class="hljs-string">&quot;0.5x1.5&quot;</span>, <span class="hljs-string">&#x27;x&#x27;</span>), <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-number">0.5</span>, <span class="hljs-number">1.5</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="转为复数">2.2 转为复数</h3><p>我们需要的参数 <code>upper_left</code> 和 <code>lower_right</code>都是复平面中的一个点，所以从字符串中将数对解析完毕后，我们将其赋值到复数的实部和虚部，转为复数实例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 把一对用逗号隔开的浮点数解析为复数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_complex</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Complex&lt;<span class="hljs-type">f64</span>&gt;&gt; &#123;<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">parse_pair</span>(s, <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>((re, im)) =&gt; <span class="hljs-title function_ invoke__">Some</span>(Complex &#123; re, im &#125;),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="将像素点映射成复数">3. 将像素点映射成复数</h2><p>第 2 步我们其实确定了两件事：</p><ol type="1"><li>确定截取曼德博集的哪一部分。</li><li>要在这个部分中画多少个点。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240118174407537.png"alt="目标区域中的像素点" /><figcaption aria-hidden="true">目标区域中的像素点</figcaption></figure><p>这一步我们需要把 <code>x</code>点转为复数，即确定它的横坐标和纵坐标。这部分可能需要发挥一下你的几何数学能力了（🤡🤡🤡）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 给定输出图像重像素的行和列，返回复平面中对应的坐标</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// `pixed` 是表示给图片中特定像素的 (column, row) 二元组。</span><br><span class="hljs-comment">/// `upper_left` 参数和 `lower_right` 参数是在复平面中表示指定图像覆盖范围的点。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">pixed_to_point</span>(<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    ·--------------------&gt; bounds.0  re</span><br><span class="hljs-comment">    丨</span><br><span class="hljs-comment">    丨</span><br><span class="hljs-comment">    丨</span><br><span class="hljs-comment">    bounds.1  im</span><br><span class="hljs-comment">     */</span><br>    bounds: (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>),<br>    pixed: (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>),<br>    upper_left: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>    lower_right: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>) <span class="hljs-punctuation">-&gt;</span> Complex&lt;<span class="hljs-type">f64</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> (width, height) = (<br>        lower_right.re - upper_left.re, <span class="hljs-comment">// 右-左</span><br>        upper_left.im - lower_right.im, <span class="hljs-comment">// 上-下</span><br>    );<br><br>    Complex &#123;<br>        re: upper_left.re + pixed.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> * width / bounds.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>,<br>        im: upper_left.im - pixed.<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> * height / bounds.<span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_pixed_to_point</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<br>        <span class="hljs-title function_ invoke__">pixed_to_point</span>(<br>            (<span class="hljs-number">100</span>, <span class="hljs-number">200</span>),<br>            (<span class="hljs-number">25</span>, <span class="hljs-number">175</span>),<br>            Complex &#123; re: -<span class="hljs-number">1.0</span>, im: <span class="hljs-number">1.0</span> &#125;,<br>            Complex &#123; re: <span class="hljs-number">1.0</span>, im: -<span class="hljs-number">1.0</span> &#125;<br>        ),<br>        Complex &#123;<br>            re: -<span class="hljs-number">0.5</span>,<br>            im: -<span class="hljs-number">0.75</span>,<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="寻找曼德博集点">4. 寻找曼德博集点</h2><p>什么是曼德博集点？看看上面的定义：<strong>曼德博集合由那些使得上述序列不趋于无限大的复数<span class="math inline">\(c\)</span> 组成</strong>。</p><p>现在我们可以来表示上述的公式 <span class="math inline">\(Z_{n+1} =z_n^2 + c\)</span> 了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">complex_square_add_loop</span>(c: Complex&lt;<span class="hljs-type">f64</span>&gt;) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> = Complex &#123; re: <span class="hljs-number">0.0</span>, im: <span class="hljs-number">0.0</span> &#125;;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        z = z * z + c<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中我们将泛型结构体 <code>Complex</code> 的 <code>T</code> 确定为<code>f64</code>，并使用 <code>loop</code> 关键字进行无限循环。</p><p>所以我们的目标是什么？<strong>找到令 <code>z</code>不会“飞到”无穷远的 <code>c</code></strong>。</p><p>由于复数 <span class="math inline">\(c\)</span> 具有实部 re 和虚部im，因此可以把它们视为笛卡尔平面上某个点的 x 坐标和 y 坐标，如果 <spanclass="math inline">\(c\)</span>在曼德博集中，就在其中用黑色着色，否则就用浅色。因此，对于图像中的每个像素，必须在复平面上相应点位运行前面的循环，看看它是否逃逸到无穷远还是永远绕着原点运行，并相应将其着色。</p><p>无限循环肯定是不现实的，我们总要找到退出循环的机会，有 2 个思路：</p><ol type="1"><li>进行有限次数的迭代，这样可以获得该集合的一个不错的近似值，迭代的次数取决了精度的需要；</li><li>业界已证明，<strong>一旦 <code>z</code> 离开了以原点为中心的半径 2的圆，它最终一定会“飞到”无穷远</strong>。</li></ol><p>所以我们最终确定的函数如下，其中 <code>norm_sqr()</code> 会返回<code>z</code> 跟复平面原点的距离的平方：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 尝试测试 `c` 是否位于曼德博集中，使用最多 `limit` 次迭代来判定</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// 如果 `c` 不是集合成员之一，则返回 `Some(i)`，其中 `i` 是 `c` 离开以原点</span><br><span class="hljs-comment">/// 为中心的半径为 2 的圆时所需的迭代次数。如果 `c` 似乎是集群成员之一（确</span><br><span class="hljs-comment">/// 切而言是达到了迭代次数限制但仍然无法证明 `c` 不是成员），则返回 `None`</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">escape_time</span>(c: Complex&lt;<span class="hljs-type">f64</span>&gt;, limit: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">usize</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> = Complex &#123; re: <span class="hljs-number">0.0</span>, im: <span class="hljs-number">0.0</span> &#125;;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..limit &#123;<br>        <span class="hljs-keyword">if</span> z.<span class="hljs-title function_ invoke__">norm_sqr</span>() &gt; <span class="hljs-number">4.0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Some</span>(i);<br>        &#125;<br>        z = z * z + c<br>    &#125;<br>    <span class="hljs-literal">None</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写入图片文件">5. 写入图片文件</h2><p>我们可以使用 <code>image</code> 这个 crate来写入图片文件，它支持多种格式图片的读写，并内置了多种颜色色值。</p><p>这里我们准备生成 png图片，且需要对图片进行不同颜色的着色，所以我们引入 <code>default</code>和 <code>png</code> 这两个 feature。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add image --features default,png<br></code></pre></td></tr></table></figure><h3 id="创建文件-filecreate">5.1 创建文件 File::create()</h3><p>我们可以用标准库中的 <code>File::create(filename)</code>来创建一个文件，成功的话会返回一个文件句柄：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">output</span> = File::<span class="hljs-title function_ invoke__">create</span>(filename)?;<br></code></pre></td></tr></table></figure><h3 id="写入图片-pngencoder">5.2 写入图片 PNGEncoder</h3><p><code>image</code> 中提供了 <code>PNGEncoder</code> 用于写入 png图片，它有两个核心方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;W: Write&gt; PNGEncoder&lt;W&gt; &#123;<br>    <span class="hljs-comment">/// Create a new encoder that writes its output to ```w```</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(w: W) <span class="hljs-punctuation">-&gt;</span> PNGEncoder&lt;W&gt; &#123;<br>        PNGEncoder &#123;<br>            w: w<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/// Encodes the image ```image```</span><br>    <span class="hljs-comment">/// that has dimensions ```width``` and ```height```</span><br>    <span class="hljs-comment">/// and ```ColorType``` ```c```</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">encode</span>(<span class="hljs-keyword">self</span>, data: &amp;[<span class="hljs-type">u8</span>], width: <span class="hljs-type">u32</span>, height: <span class="hljs-type">u32</span>, color: ColorType) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>        <span class="hljs-keyword">let</span> (ct, bits) = color.<span class="hljs-title function_ invoke__">into</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">encoder</span> = png::Encoder::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">self</span>.w, width, height);<br>        encoder.<span class="hljs-title function_ invoke__">set</span>(ct).<span class="hljs-title function_ invoke__">set</span>(bits);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">writer</span> = <span class="hljs-built_in">try!</span>(encoder.<span class="hljs-title function_ invoke__">write_header</span>());<br>        writer.<span class="hljs-title function_ invoke__">write_image_data</span>(data).<span class="hljs-title function_ invoke__">map_err</span>(|e| e.<span class="hljs-title function_ invoke__">into</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>new(w)</code>: 传进目标 writer，即我们上面创建的<code>output</code>。</li><li><code>encode()</code>: 写入图片信息，这里有几个参数：<ul><li><code>width: u32</code>: 图片宽度。</li><li><code>height: u32</code>: 图片高度。</li><li><code>color: ColorType</code>: 颜色类型，可以是 RGB, Gray(8)等。</li><li><code>data: &amp;[u8]</code>: 像素色值列表，它的长度应该由上面 3个字段共同决定，如果选取的颜色是 RGB，意味着需要 3 个 u8才能表示一个像素点的颜色，所以长度为 width * height *3，如果选取的颜色是 Gray(8)，那么我们用 1 个 u8就可以表示一个像素点的灰度值，所以长度为 width * height *1。本文中我们会采用 Gray(8) 来汇总曼德博集的黑白图。</li></ul></li></ul><h2 id="渲染曼德博集">6. 渲染曼德博集</h2><p>这一步我们需要来确定上述 <code>PNGEncoder::encode()</code> 的 4个参数：</p><ul><li><p><code>width: u32</code>:图片宽度由命令行参数中指定即可。</p></li><li><p><code>height: u32</code>:图片高度由命令行参数中指定即可。</p></li><li><p><code>color: ColorType</code>: 本文我们只绘制黑白图，这里使用<code>ColorType::Gray(8)</code>，它表示图像是一个灰度（单色）图像，每个像素用8位（即1个字节）来表示。在这种格式中，每个像素的灰度值范围是0 到 255，其中 0 通常表示黑色，255表示白色，中间值表示不同的灰度。</p></li><li><p><code>data: &amp;[u8]</code>: 像素色值列表，我们需要确定 width *height 个像素的灰度值。</p><p>首先我们根据第 3 步将像素点映射成复数 <spanclass="math inline">\(c\)</span>，然后使用第 4 步中的<code>escape_time()</code> 函数来判断复数 <spanclass="math inline">\(c\)</span>是否位于曼德博集中，如果是，则着黑色，即赋值<code>0</code>，如果不是，则看它迭代了多少次才失败，次数越多，则越接近曼德博集，颜色越深，即越靠近0，所以赋值 <code>255-time</code>。</p></li></ul><p>最终我们实现的函数如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 将曼德博集对应的矩形渲染到像素缓冲区中</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// `bounds` 参数会给缓冲区 `pixels` 的宽度和高度，此缓冲区的每个字节都</span><br><span class="hljs-comment">/// 包含一个灰度像素。`upper_left` 和 `lower_right` 参数分别指定了</span><br><span class="hljs-comment">/// 复平面中对应于像素缓冲区左上角和右上角的点。</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">render</span>(<br>    pixels: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>],<br>    bounds: (<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>),<br>    upper_left: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>    lower_right: Complex&lt;<span class="hljs-type">f64</span>&gt;,<br>) &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(pixels.<span class="hljs-title function_ invoke__">len</span>(), bounds.<span class="hljs-number">0</span> * bounds.<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">raw</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..bounds.<span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">column</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..bounds.<span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">point</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (column, raw), upper_left, lower_right);<br>            pixels[raw * bounds.<span class="hljs-number">0</span> + column] = <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">escape_time</span>(point, <span class="hljs-number">255</span>) &#123;<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-number">0</span>,<br>                <span class="hljs-title function_ invoke__">Some</span>(count) =&gt; <span class="hljs-number">255</span> - count <span class="hljs-keyword">as</span> <span class="hljs-type">u8</span>,<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解析命令行参数">7. 解析命令行参数</h2><p>核心逻辑部分到这里其实就完成了，现在我们要做最后一步，就是解析命令行参数，让程序可以根据我们的要求绘制曼德博集图。</p><h3 id="解析-stdenvargs">7.1 解析 std::env::args()</h3><p>在 Rust中解析命令行参数的一个常用方法是使用<code>std::env::args</code>函数，这个函数返回一个迭代器，它包含了命令行上传递给程序的所有参数。对于更复杂的命令行参数解析，可以使用像<code>clap</code>或<code>structopt</code>这样的第三方库，这些库提供了更高级的功能和更好的错误处理。</p><p>下面是一个使用<code>std::env::args</code>的基本例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::env;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">args</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">arg</span> <span class="hljs-keyword">in</span> args.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基础版程序">7.2 基础版程序</h3><p>到这里，我们就可以实现完整的基础版程序了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 读取参数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">args</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>  <span class="hljs-comment">// 参数个数 = 1 + 4，其中第 1 个是应用程序名</span><br>    <span class="hljs-keyword">if</span> args.<span class="hljs-title function_ invoke__">len</span>() != <span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">eprintln!</span>(<span class="hljs-string">&quot;Usage: &#123;&#125; FILE PIXELS UPPERLEFT LOWERRIGHT&quot;</span>, args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">eprintln!</span>(<br>            <span class="hljs-string">&quot;Example: &#123;&#125; mandel.png 1000x700 -1.20,0.35 -1,0.20&quot;</span>,<br>            args[<span class="hljs-number">0</span>]<br>        );<br>        std::process::<span class="hljs-title function_ invoke__">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">// 解析参数</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bounds</span> = <span class="hljs-title function_ invoke__">parse_pair</span>(&amp;args[<span class="hljs-number">2</span>], <span class="hljs-string">&#x27;x&#x27;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error parsing image dimensions&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">upper_left</span> = <span class="hljs-title function_ invoke__">parse_complex</span>(&amp;args[<span class="hljs-number">3</span>]).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error parsing upper left corner point&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lower_right</span> = <span class="hljs-title function_ invoke__">parse_complex</span>(&amp;args[<span class="hljs-number">4</span>]).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error parsing lower right corner point&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">pixels</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; bounds.<span class="hljs-number">0</span> * bounds.<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 渲染曼德博集</span><br>    <span class="hljs-title function_ invoke__">render</span>(&amp;<span class="hljs-keyword">mut</span> pixels, bounds, upper_left, lower_right);<br>  <span class="hljs-comment">// 输出图片</span><br>    <span class="hljs-title function_ invoke__">write_image</span>(&amp;args[<span class="hljs-number">1</span>], &amp;pixels, bounds).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;error writing PNG file&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在项目根目录下编译一下程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build --release<br></code></pre></td></tr></table></figure><p>会在 target/release 下生成可执行文件，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20<br></code></pre></td></tr></table></figure><p>执行后你应该可以看到我们生成的曼德博集图如下：</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/mandel.png"alt="程序生成的曼德博集" /><figcaption aria-hidden="true">程序生成的曼德博集</figcaption></figure><p>大概是处于这个位置：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240118191624303.png"alt="程序截取的局部曼德博集处于整个曼德博集中的位置" /><figcaptionaria-hidden="true">程序截取的局部曼德博集处于整个曼德博集中的位置</figcaption></figure><h2 id="并发渲染">8. 并发渲染</h2><p>在 macOS 或 linux 系统下，我们可以使用 <code>time</code>来输出程序的执行时间：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">time ./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20<br>./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20  3.30s user 0.01s system 98% cpu 3.341 total<br></code></pre></td></tr></table></figure><p>笔者使用的电脑为 macbook Pro m2 max 芯片 32 G 内存 12核，可以看到在单核模式下，差不多需要 3~4s 的时间。</p><p>几乎所有的现代机器都有多个处理器核心，而当前这个程序只使用了一个。如果可以把此工作分派个机器提供的多个处理器核心，则应该可以更快地画完图像。</p><p>为此，我们可以将图像划分成多个部分，每个处理器负责其中的一个部分，并让每个处理器为分派给它的像素着色。为简单起见，可以将其分成一些水平条带，如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/CleanShot%202024-01-18%20at%2021.28.20.jpg"alt="将像素缓冲区划分为一些条带以进行并发渲染" /><figcaptionaria-hidden="true">将像素缓冲区划分为一些条带以进行并发渲染</figcaption></figure><p>crossbeam 是 Rust中的一个并发编程工具箱，它广泛用于提供各种并发和多线程编程的组件。</p><p><code>crossbeam::scope</code> 是 crossbeam提供的一个非常有用的功能，它允许你安全地创建临时的线程，并确保这些线程在离开作用域之前结束。</p><p>这里我们引入 crossbeam：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add crossbeam<br></code></pre></td></tr></table></figure><p>我们将 <code>fn main()</code> 中的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-title function_ invoke__">render</span>(&amp;<span class="hljs-keyword">mut</span> pixels, bounds, upper_left, lower_right);<br></code></pre></td></tr></table></figure><p>替换成：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 8 个线程来并发执行</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">threads</span> = <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 计算每个线程负责渲染的高度，向上取整</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">rows_per_band</span> = bounds.<span class="hljs-number">1</span> / threads + <span class="hljs-number">1</span>;<br>&#123;<br>  <span class="hljs-comment">// chunks_mut() 会返回一个迭代器，该迭代器会生成此缓冲区的可变且不可迭代的切片</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bands</span>: <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>]&gt; = pixels.<span class="hljs-title function_ invoke__">chunks_mut</span>(rows_per_band * bounds.<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">collect</span>();<br>  <span class="hljs-comment">// crossbeam::scope 确保所有子线程在作用域结束之前完成，</span><br>  <span class="hljs-comment">// 这防止了悬垂指针和其他数据竞争问题。</span><br>    crossbeam::<span class="hljs-title function_ invoke__">scope</span>(|spawner| &#123;<br>      <span class="hljs-comment">// 遍历像素缓冲区的各个条带，</span><br>      <span class="hljs-comment">// 这里 into_iter() 迭代器会为循环体的每次迭代赋予独占一个条带的所有权，</span><br>      <span class="hljs-comment">// 确保一次只有一个线程可以写入它。</span><br>        <span class="hljs-keyword">for</span> (i, band) <span class="hljs-keyword">in</span> bands.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>          <span class="hljs-comment">// 确定每个条带的参数</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">top</span> = rows_per_band * i;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">height</span> = band.<span class="hljs-title function_ invoke__">len</span>() / bounds.<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">band_bounds</span> = (bounds.<span class="hljs-number">0</span>, height);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">band_upper_left</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (<span class="hljs-number">0</span>, top), upper_left, lower_right);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">band_lower_right</span> =<br>                <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (bounds.<span class="hljs-number">0</span>, top + height), upper_left, lower_right);<br>          <span class="hljs-comment">// 创建一个线程，渲染图像</span><br>          <span class="hljs-comment">// move 表示这个闭包会接手它所用遍历的所有权，</span><br>          <span class="hljs-comment">// 所以只有此闭关，即只有此线程可以使用可变切片 band。</span><br>            spawner.<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> |_| &#123;<br>                <span class="hljs-title function_ invoke__">render</span>(band, band_bounds, band_upper_left, band_lower_right);<br>            &#125;);<br>        &#125;<br>    &#125;)<br>    .<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>再次执行：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">time ./<span class="hljs-keyword">target</span>/<span class="hljs-keyword">release</span>/mandelbrot mandel.png <span class="hljs-number">4000</span><span class="hljs-keyword">x</span><span class="hljs-number">3000</span> <span class="hljs-number">-1.20</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.35</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.20</span><br>./<span class="hljs-keyword">target</span>/<span class="hljs-keyword">release</span>/mandelbrot mandel.png <span class="hljs-number">4000</span><span class="hljs-keyword">x</span><span class="hljs-number">3000</span> <span class="hljs-number">-1.20</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.35</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0.20</span>  <span class="hljs-number">3.57</span>s user <span class="hljs-number">0.01</span>s system <span class="hljs-number">335</span>% cpu <span class="hljs-number">1.067</span> total<br></code></pre></td></tr></table></figure><p>可以看到虽然总共使用的 CPU 时间还是3~4s，但是整个程序的执行时间只缩短到 1s 左右了。</p><h2 id="rayon-工作窃取">9. rayon 工作窃取</h2><p>前面我们使用 8 个工作线程优化了曼德博集的绘制速度，大概是 4倍的速度提升。其实这还不够快。</p><p>问题的根源在于我们没有平均分配工作量。计算图像的一个像素相当于运行一个循环。事实上，图像的浅灰色部分（循环会快速退出的地方）比黑色部分（循环会运行整整255次迭代的地方）渲染速度要快得多。因此，虽然我们将整个区域划分成了大小相等的水平条带，但创建了不均等的工作负载，</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image00879.jpeg"alt="曼德博集程序中的工作分配不均等" /><figcaptionaria-hidden="true">曼德博集程序中的工作分配不均等</figcaption></figure><p>使用 rayon很容易解决这个问题。我们可以为输出中的每一行像素启动一个并行任务。这会创建数百个任务，而rayon可以在其线程中分配这些任务。有了工作窃取机制，任务的规模是无关紧要的。rayon会对这些工作进行平衡。</p><p>我们先引入 <code>rayon</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add rayon<br></code></pre></td></tr></table></figure><p>在 <code>main.rs</code> 中引入 <code>rayon</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rayon::prelude::*;<br></code></pre></td></tr></table></figure><p>然后 <code>main</code> 中并发绘制的部分替换为下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">bands</span>: <span class="hljs-type">Vec</span>&lt;(<span class="hljs-type">usize</span>, &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>])&gt; = pixels.<span class="hljs-title function_ invoke__">chunks_mut</span>(bounds.<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">enumerate</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><br>bands.<span class="hljs-title function_ invoke__">into_par_iter</span>().for_each(|(i, band)| &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">top</span> = i;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">band_bounds</span> = (bounds.<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">band_upper_left</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (<span class="hljs-number">0</span>, top), upper_left, lower_right);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">band_lower_right</span> = <span class="hljs-title function_ invoke__">pixed_to_point</span>(bounds, (bounds.<span class="hljs-number">0</span>, top + <span class="hljs-number">1</span>), upper_left, lower_right);<br>    <span class="hljs-title function_ invoke__">render</span>(band, band_bounds, band_upper_left, band_lower_right);<br>&#125;);<br></code></pre></td></tr></table></figure><p>首先，创建 bands，也就是要传给 rayon的任务集合。每个任务只是一个元组类型 (usize, &amp;mut[u8])：第一个是计算所需的行号，第二个是要填充的 pixels 切片。我们使用chunks_mut 方法将图像缓冲区分成一些行，enumerate则会给每一行添加行号，然后 collect会将所有数值切片对放入一个向量中。（这里需要一个向量，因为 rayon只能从数组和向量中创建并行迭代器。）</p><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build --release<br></code></pre></td></tr></table></figure><p>再次执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">time ./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20<br>./target/release/mandelbrot mandel.png 4000x3000 -1.20,0.35 -1,0.20  3.96s user 0.01s system 973% cpu 0.408 total<br></code></pre></td></tr></table></figure><p>可以看到，这次速度提升更加明显，总共只用了 0.4s 左右的时间。</p><p>以上就是实用 Rust 绘制曼德博集实战的全部内容，enjoy，happycoding~</p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>Rust 实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust Web 框架 Axum 指南</title>
    <link href="/2024/01/14/rust-axum/"/>
    <url>/2024/01/14/rust-axum/</url>
    
    <content type="html"><![CDATA[<h1 id="结论先行">结论先行</h1><h1 id="hello-world">Hello World</h1><p>先来看看 Axum 的 Hello World：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> axum::Router;<br><span class="hljs-keyword">use</span> axum::routing::get;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 创建一个应用，带一个 / 路由，输出 Hello World</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(|| <span class="hljs-keyword">async</span> &#123; <span class="hljs-string">&quot;Hello World!&quot;</span> &#125;));<br><br>    <span class="hljs-comment">// 监听 3000 端口</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = tokio::net::TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;0.0.0.0:3000&quot;</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// 启动服务</span><br>    axum::<span class="hljs-title function_ invoke__">serve</span>(listener, app).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面这个例子，可以得到的第一个信息就是：<code>Axum</code> 是<code>tokic</code> 生态下的一员。</p><blockquote><p>本文默认读者对 <code>tokio</code> 具有基本的了解。</p></blockquote><p>所以这里我们需要引入两个组件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add tokio --features macros,rt-multi-thread<br>cargo add axum<br></code></pre></td></tr></table></figure><p>这个例子我们定义了一个路由，下面我们就先从 Axum 的路由开始介绍。</p><h1 id="routing-路由">Routing 路由</h1><h2 id="单个路由">单个路由</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">Router::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(|| <span class="hljs-keyword">async</span> &#123; <span class="hljs-string">&quot;Hello World!&quot;</span> &#125;));<br></code></pre></td></tr></table></figure><p>实际上它等价于：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(handler_hello_world));<br> ...<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handler_hello_world</span> () <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">IntoResponse</span> &#123;<br>    <span class="hljs-string">&quot;Hello World&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>路由注册部分为为 <code>path</code>、<code>method</code> 和<code>handler</code> 三个部分。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20240114141604009.png"alt="路由注册部分" /><figcaption aria-hidden="true">路由注册部分</figcaption></figure><p>其中 <code>get</code> 可以替换为<code>post</code>、<code>patch</code>、<code>delete</code>、<code>head</code>和 <code>options</code> 等 http method。</p><p>其中 <code>handler</code>的返回值需要满足：<code>impl IntoResponse</code>，常用的<code>字符串</code>、<code>json</code> 和 <code>html</code> 都已经实现了<code>IntoResponse</code>，所以都是可以直接返回的。</p><h2 id="路由分组">路由分组</h2><p>你可以使用 <code>merge()</code> 和 <code>nest()</code>来进行路由分组，其中 <code>nest()</code> 可以指定统一路由前缀：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">merge</span>(<span class="hljs-title function_ invoke__">todo_routers</span>())<br>        .<span class="hljs-title function_ invoke__">nest</span>(<span class="hljs-string">&quot;/v2/todo&quot;</span>, <span class="hljs-title function_ invoke__">todo_routers_v2</span>());<br>...<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">todo_routers</span>() <span class="hljs-punctuation">-&gt;</span> Router &#123;<br>    Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/todo/delete/:id&quot;</span>, <span class="hljs-title function_ invoke__">delete</span>(handler_todo_delete))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/todo/list&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(handler_todo_list))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/todo/create&quot;</span>, <span class="hljs-title function_ invoke__">post</span>(handler_todo_create))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/todo/update&quot;</span>, <span class="hljs-title function_ invoke__">put</span>(handler_todo_update))<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">todo_routers_v2</span>() <span class="hljs-punctuation">-&gt;</span> Router &#123;<br>    Router::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/delete/:id&quot;</span>, <span class="hljs-title function_ invoke__">delete</span>(handler_todo_delete))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/list&quot;</span>, <span class="hljs-title function_ invoke__">get</span>(handler_todo_list))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/create&quot;</span>, <span class="hljs-title function_ invoke__">post</span>(handler_todo_create))<br>        .<span class="hljs-title function_ invoke__">route</span>(<span class="hljs-string">&quot;/update&quot;</span>, <span class="hljs-title function_ invoke__">put</span>(handler_todo_update))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态路由">静态路由</h2><p>可以使用同 <code>tokio</code> 生态下的 <code>tower-http</code>来实现静态路由：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_routers</span>() <span class="hljs-punctuation">-&gt;</span> Router &#123;<br>    Router::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">nest_service</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-title function_ invoke__">get_service</span>(ServeDir::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;./&quot;</span>)))<br>&#125;<br></code></pre></td></tr></table></figure><p>这里你需要添加 <code>tower-http</code> 组件，至少需要载入<code>fs</code> 特性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo add tower-http --features fs<br></code></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://docs.rs/axum/latest/axum/">Rust-Axum</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
      <category>web 框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Axum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文彻底掌握浮点数</title>
    <link href="/2023/12/23/floating-point-number/"/>
    <url>/2023/12/23/floating-point-number/</url>
    
    <content type="html"><![CDATA[<h2 id="经典问题">经典问题</h2><p>0.1 + 0.2 = ？</p><p>我们写个 Go 程序来测试一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f1 <span class="hljs-type">float64</span> = <span class="hljs-number">0.1</span><br><span class="hljs-keyword">var</span> f2 <span class="hljs-type">float64</span> = <span class="hljs-number">0.2</span><br>fmt.Println(f1+f2 == <span class="hljs-number">0.3</span>)<br>fmt.Println(f1 + f2)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-literal">false</span><br>0.30000000000000004<br></code></pre></td></tr></table></figure><p>如此违背 “常识”的结果，其实是因为当下计算机体系中小数的表示方式是浮点数，而计算机中对浮点数的表示并非百分百精确的，在表示和计算过程中都有可能会丢失精度。</p><p>这迫使必须深入理解浮点数在计算机中的存储方式及性质，才能正确处理关于数字的计算问题。</p><h2 id="结论先行">结论先行</h2><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/IEEE-754%20%E6%B5%AE%E7%82%B9%E6%95%B0.jpg"alt="IEEE-754 浮点数" /><figcaption aria-hidden="true">IEEE-754 浮点数</figcaption></figure><h2 id="定点数">定点数</h2><p>要理解浮点数的第一步是考虑含有小数值的二进制数字。在这之前，我们来看看更加熟悉的十进制表示法：</p><p><span class="math display">\[d_md_{m-1} ··· d_1d_0 . d_{-1}d_{-2}··· d_{-n}\]</span></p><p>小数点 <code>.</code>左边是整数部分，右边是小数部分。其中每个十进制数 <code>di</code>的取值范围是 0~9。</p><p>如十进制的 <code>12.34</code> 即可以表示为：</p><p><span class="math display">\[1×10^1+2×10^0+3×10^{-1}+4×10^{-2}\]</span></p><p>那其实二进制也是一样的道理，只不过把其中的 <code>10</code> 换成<code>2</code>，而 <code>di</code> 的取值范围为 0~1。</p><p>如二进制的 <code>101.11</code> 可以表示为：</p><p><span class="math display">\[1×2^2+0×2^1+1×2^0+1×2^{-1}+1×2^{-2}\]</span></p><p>如果我们仅考虑有限长度的编码，那么十进制表示法不能准确表达像 1/3 和5/7这样的数。类似的，小数的二进制表示法只能表示那些能够被写成以下形式的数：</p><p><span class="math display">\[x × 2^y\]</span></p><p>其他的值就只能近似地表示。</p><p>定点数的整数部分是小数部分的位数是固定不变的，在位数有限的情况下，定点数的取值范围和精度都比较差。于是就有了IEEE-754 提出的浮点数表示法。</p><h2 id="浮点数">浮点数</h2><p>所谓“浮点数”（Floating-pointnumbers），即小数点可以“<strong>浮动</strong>”，即小数点的位置不是固定的，而是可以根据数值的大小和精度需求移动的。这种表示法允许在广泛的范围内表示数值，同时保持相对恒定的精度。</p><p>在计算机中，浮点数通常遵循 IEEE-754标准。这个标准定义了浮点数的存储和运算方式，确保了不同计算机系统之间的一致性。IEEE-754用以下形式来表示一个数：</p><p><span class="math display">\[V = (-1)^s×M×2^E\]</span></p><p>其中：</p><ul><li><strong>s 符号位（Sign bit）</strong>：表示数值的正负。</li><li><strong>M 尾数（Mantissa）</strong>：表示数值的有效数字。</li><li><strong>E 指数（Exponent）</strong>：决定小数点的位置。</li></ul><p>IEEE-754将浮点数的位表示划分成三个部分，分别对各个部分进行编码，对应上面公式右边的3 个字母：</p><ul><li>一个单独的符号位 <code>s</code> 直接编码符号 <code>s</code>。</li><li><span class="math inline">\(k\)</span> 位的阶码字段 <spanclass="math inline">\(exp=e_{k-1}\cdots e_1e_0\)</span> 编码阶码<code>E</code>。</li><li><span class="math inline">\(n\)</span> 位小数字段 <spanclass="math inline">\(frac=f_{n-1}\cdots f_1f_0\)</span> 编码尾数<code>M</code>，但是编码出来的值也依赖于阶码字段的值是否等于 0。</li></ul><p>在 IEEE-754 标准中，定义了两种精度的浮点数，分别是单精度浮点数（32位）和双精度浮点数（64 位）。</p><p>单精度：</p><ul><li>1 位符号位 s</li><li>8 位指数 exp</li><li>23 位尾数 frac</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224102703581.png"alt="单精度浮点数" /><figcaption aria-hidden="true">单精度浮点数</figcaption></figure><p>双精度：</p><ul><li>1 位符号位 s</li><li>11 位指数 exp</li><li>52 位尾数 frac</li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224102756244.png"alt="双精度浮点数" /><figcaption aria-hidden="true">双精度浮点数</figcaption></figure><p>根据 <code>exp</code> 的值，浮点数又可以分成三类：</p><ol type="1"><li>规格化的</li><li>非规格化的</li><li>特殊的</li></ol><p>其中第三类“特殊的”又可以根据 <code>frac</code> 分成两类：</p><ol type="1"><li>无穷大</li><li>不是一个数 NaN（Not a Number）</li></ol><p>具体如下表所示：</p><table><thead><tr class="header"><th></th><th style="text-align: center;">exp</th><th style="text-align: center;">frac</th></tr></thead><tbody><tr class="odd"><td>规格化的</td><td style="text-align: center;">≠0 &amp; ≠ 255</td><td style="text-align: center;">f</td></tr><tr class="even"><td>非规格化的</td><td style="text-align: center;">0</td><td style="text-align: center;">f</td></tr><tr class="odd"><td>特殊的</td><td style="text-align: center;">1</td><td style="text-align: center;">f</td></tr><tr class="even"><td>- 无穷大</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr class="odd"><td>- NaN</td><td style="text-align: center;">1</td><td style="text-align: center;">≠0</td></tr></tbody></table><p>对于不同类型的浮点数，在计算公式 <spanclass="math inline">\(V=(-1)^s×M×2^E\)</span>中，<code>exp -&gt; E</code> 和 <code>frac -&gt; M</code>的方式有所不同。</p><p>下面我们来对这几种不同类型进行详细讨论，其中不乏有一些很有趣且充满智慧的设计理念。</p><h3 id="特殊值-special-values">特殊值 Special Values</h3><ul><li><strong>指数部分</strong>：全为 0。</li><li><strong>尾数部分</strong>：全为 0 则表示无穷大，不全为 0 则表示NaN。</li><li><strong>作用</strong>：特殊值用于表示那些无法用常规数值表示的情况，如无穷大、非数（NaN）等。这些值通常用于操作的错误或特殊情况的结果，如除以0、无效操作等。</li></ul><h3 id="规格化的值-normalize-values">规格化的值 Normalize Values</h3><ul><li><strong>指数部分</strong>：不全为 0 且不全为 1。</li><li><strong>尾数部分</strong>：可以是任意值。</li><li><strong>作用</strong>：用于表示大多数非零数值</li></ul><p>在规格化值中：</p><ul><li><span class="math inline">\(E=e-bias\)</span></li><li><span class="math inline">\(M=1+f\)</span></li></ul><p>其中 <code>e</code> 即为 <code>exp</code>，，<code>bias</code>是偏置量，它的值为 <span class="math inline">\(2^{k-1} -1\)</span>，其中<code>k</code> 为 <code>exp</code> 的位数，故：</p><ul><li>在单精度中，<spanclass="math inline">\(bias=2^{8-1}-1=2^7-1=128-1=127\)</span></li><li>在双精度中，<spanclass="math inline">\(bias=2^{11-1}-1=2^{10}-1=1024-1=1023\)</span></li></ul><p>其中 <code>f</code> 为 <code>frac</code> 表示的数，范围 <spanclass="math inline">\(0≤f&lt;1\)</span>。</p><p>所以一个规格化数，具体可以表示为：</p><p><span class="math display">\[V=(-1)^{sign}×1.frac×2^{(exp-bias)}\]</span></p><p>这里有 4 个问题：</p><ol type="1"><li>这个 <code>bias</code> 是什么？</li><li>为什么 <code>E</code> 要 <code>e</code> 去减掉一个<code>bias</code>？</li><li><code>bias</code> 的值是怎么定下的，如单精度为什么是 127，不是 126或 128？</li><li><code>M</code> 为什么需要 <code>f</code> 去加上一个<code>1</code>？</li></ol><p>下面我们来对这 4 个问题进行一一解答。</p><p><strong>第 1 个问题，这个 bias 是什么？</strong></p><blockquote><p><code>bias</code>是一个预设的偏移量，用于将指数部分的值偏移到全正数，从而简化处理。</p></blockquote><p><strong>第 2 个问题：为什么 E 要 e 去减去一个 bias？</strong></p><blockquote><p>先说结论：使用 bias（偏置指数，biasedexponent）可以允许浮点数以统一的方式表示，同时也使得浮点数的排序和比较变得简单。</p></blockquote><p>首先指数肯定得支持正负形式的出现，那么直接使用无符号整型来表示指数肯定是不行的，因为它无法表示负指数。暂时先抛开IEEE-754 定下的标准，我们可以尝试用补码来表示指数。</p><p>假设我们有两个 32 位的浮点数 <code>A</code> 和<code>B</code>，并且我们假设它们的指数部分使用 8 位二进制补码表示（这与IEEE-754 标准不同）。</p><ul><li><code>A</code>的二进制表示：<code>0 0000010 00000000000000000000000</code></li><li><code>B</code>的二进制表示：<code>0 1111110 00000000000000000000000</code></li></ul><p>在这里，第一位是符号位（0 表示正数），接下来的 8位是以补码形式表示的指数，剩下的 23 位是尾数。</p><p>我们想要比较这两个数的大小，需要怎么做呢？</p><p>我们先解析这 2 个数：</p><ul><li>符号位：对于 <code>A</code> 和 <code>B</code>，符号位都是0，表示这是两个正数。</li><li>指数部分（使用补码表示）<ul><li><code>A</code> 的指数为 <code>0000010</code>，解读为正数 +2。</li><li><code>B</code> 的指数为<code>1111110</code>，在补码表示中，这是一个负数。先加取反后加 1转换为正数 <code>00000010</code>，它表示 -2。</li></ul></li></ul><p>要比较这 2 个数：</p><ul><li>当我们比较 <code>A</code> 和 <code>B</code>时，首先需要考虑它们的指数。</li><li>指数 <code>A</code> 为 +2，而 <code>B</code> 为-2。即使它们的尾数部分相同（在这个例子中都是 0），<code>A</code>的实际值要大于<code>B</code>，因为正指数表示的数值范围远大于负指数。</li></ul><p>可以看出：使用补码表示指数增加了比较过程的复杂性，因为我们需要解读补码并考虑其正负。特别是在涉及到负指数的情况下，我们不能仅仅比较二进制表示的大小，而必须将补码转换为实际的数值，然后再进行比较。</p><p>现在回过头来看看 IEEE-754 的设计，假设我们有两个单精度（32 位）浮点数<code>A</code> 和 <code>B</code>：</p><ul><li><code>A</code>的二进制表示为：<code>0 10000010 00000000000000000000000</code></li><li><code>B</code>的二进制表示为：<code>0 01111110 00000000000000000000000</code></li></ul><p>解析这两个数：</p><ul><li><code>A</code>：符号位为 0（正数），指数部分为<code>10000010</code>（二进制，对应十进制的 130），尾数部分为全 0。</li><li><code>B</code>：符号位为 0（正数），指数部分为<code>01111110</code>（二进制，对应十进制的 126），尾数部分为全 0。</li></ul><p>计算实际指数值：单精度浮点数的偏置值 <code>bias</code> 为127，故：</p><ul><li><code>A</code> 的实际指数 <code>E = 130 - 127 = 3</code>。</li><li><code>B</code> 的实际指数 <code>E = 126 - 127 = -1</code>。</li></ul><p>比较这两个数：</p><ul><li>在减去 <code>bias</code>后，我们可以直接比较指数部分的二进制表示来确定数值的大小。</li><li>由于 <code>10000010</code>（130）大于<code>01111110</code>（126），因此我们可以直接得出 <code>A</code> 大于<code>B</code>，而无需考虑负指数的复杂表示问题。</li></ul><p>这个例子说明了通过减去偏置值，IEEE-754标准能够简化浮点数的比较和排序操作。偏置后的指数表示方法允许计算机以统一和高效的方式处理浮点数，无论它们的实际数值大小如何。</p><p><strong>第 3 个问题：bias 的值是怎么定下的，如单精度为什么是127，而不是 126 或 128？</strong></p><blockquote><p><code>bias</code>值的选择，是为了平衡正负指数的表示范围，并且充分利用指数部分的存储空间。</p></blockquote><p>以单精度为例，<code>exp</code> 占了 8 位，8位二进制可以表示的值的范围是 <spanclass="math inline">\([0,255]\)</span>。如果我们选择 127 作为<code>bias</code>，则存储的指数范围就是 <spanclass="math inline">\([-127,128]\)</span>。这样可以使得指数部分可以均匀地表示从负大数到正大数的范围（对称）。</p><p>在 IEEE-754 标准中，全 0 的指数表示为非规格化数或 0，而全 1的指数用于表示无穷大或 NaN）。选择 127 作为 <code>bias</code>可以在保留这些特殊值的同时，提供最大的有效指数范围。</p><p><strong>第 4 个问题：M 为什么需要 f 去加上一个 1？</strong></p><blockquote><p>在规格化数中隐含最高位 1是为了提高尾数部分的表示效率，从而增加精度。</p></blockquote><p>其实这跟科学计数法的很像的，为了确保浮点数表示的<strong>唯一性</strong>，IEEE-754规定规格化浮点数最高位一定是非零的。如果不规定最高位非零，同一个数可以有多种不同的浮点表示，例如，在二进制中<code>0.5</code> 可以表示为 <spanclass="math inline">\(1.0×2^{-1}\)</span>，也可以表示位 <spanclass="math inline">\(0.1×2^0\)</span> 或 <spanclass="math inline">\(0.01×2^1\)</span>等等。这种多重表示会使浮点运算变得复杂且低效。</p><p>那既然最高位总是 1，那就没必要显示存储了，还可以使尾数部分中多 1位的存储空间，从而允许存储更多的有效数字，以<strong>提高精度</strong>。</p><h3 id="非规格化的值-denormalized-values">非规格化的值 DenormalizedValues</h3><ul><li><strong>指数部分</strong>：全为 0。</li><li><strong>尾数部分</strong>：可以是任意值。</li><li><strong>作用</strong>：<ul><li>提供表示数值 0 的方法。因为规格化中 <spanclass="math inline">\(M≥1\)</span>，所以无法表示 0。</li><li>用于表示非常接近于 0的数值，这些数值太小，无法用规格化格式表示。它们填补了 0和最小规格化正数之间的间隙，提供了渐近于 0的连续表示，防止了所谓的“下溢”。</li></ul></li></ul><p>在非规格化值中：</p><ul><li><span class="math inline">\(E=1-bias\)</span></li><li><span class="math inline">\(M=f\)</span></li></ul><p>所以一个规格化数，具体可以表示为：</p><p><span class="math display">\[V=(-1)^{sign}×0.frac×2^{(1-bias)}\]</span></p><p>那这里又有 2 个问题了：</p><ol type="1"><li>为什么指数部分不是 <span class="math inline">\(0-bias\)</span> 而是<span class="math inline">\(1-bias\)</span>？</li><li>为什么 M 不需要隐含的 1 了？</li></ol><p><strong>第 1 个问题：为什么指数部分不是 0-bias 而是1-bias？</strong></p><blockquote><p>这是一个特殊的设计，旨在使非规格化数能够平滑地连接到规格化数的最小正值。</p></blockquote><p>最小的规格化数的指数为<code>1 - bias</code>。为了在数值上平滑地过渡到非规格化数，非规格化数的实际指数也被设定为<code>1 - bias</code>。这样，非规格化数就可以代表那些小于最小规格化正数的数值，而不会出现一个数值的“间隙”。</p><p><strong>第 2 个问题：为什么 M 不需要隐含的 1 了？</strong></p><blockquote><p>不包含隐含的 1 使得非规格化数能够在浮点数表示中填补 0和最小规格化数之间的空隙，提供对极小数值的连续表示。</p></blockquote><ul><li><strong>避免下溢</strong>：非规格化数通过允许尾数部分不以隐含的 1开始（而是以显式的 0开始），使得它们可以表示比最小规格化数还要小的数值。这对于避免数值下溢至0 非常重要，尤其是在累积了多次运算后的场合。</li><li><strong>精度牺牲</strong>：使用非规格化数的代价是牺牲了一些精度。由于没有隐含的最高位1，非规格化数的精度较低。但这是为了在非常小的数值范围内提供数值的连续性所做的必要妥协。</li></ul><h3 id="总结">总结</h3><p>规格化值、非规格化值和特殊值三种类型共同构成了 IEEE-754浮点数标准的完整表示体系，使得浮点数能够在计算机中有效低处理从非常小到非常大的数值范围，同时还能应对特殊的计算情况。</p><h3 id="举例">举例</h3><p>参考《深入理解计算机系统》，我们以 8 位浮点数为例，其中：</p><ul><li>1 位符号 s</li><li>4 位指数 exp</li><li>3 位尾数 frac</li></ul><p>可以算出 <spanclass="math inline">\(bias=2^{4-1}-1=2^3-1=8-1=7\)</span>。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/544558-20211104211145834-189368139.png"alt="8 位浮点数（≥0部分）" /><figcaption aria-hidden="true">8 位浮点数（≥0部分）</figcaption></figure><p>其中靠近 0 的是非规格化值：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224130157112.png"alt="8 位浮点数 - 非规格化值" /><figcaption aria-hidden="true">8 位浮点数 - 非规格化值</figcaption></figure><p>以 <code>0 0000 001</code> 为例：</p><p><span class="math display">\[V = (-1)^s×M×2^E \\= (-1)^s×0.frac×2^{1-bias} \\= (-1)^0×(0+(1/8))×2^{1-7} \\= 1×1/8×2^{-6} \\=2^{(-9)} \\= 1/512\]</span></p><p>再往下，就是规格化值：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224130849986.png"alt="8 位浮点数 - 规格化值" /><figcaption aria-hidden="true">8 位浮点数 - 规格化值</figcaption></figure><p>以 <code>0 0110 110</code> 为例：</p><p><span class="math display">\[V = (-1)^s×M×2^E \\= (-1)^s×1.frac×2^{e-bias} \\= (-1)^0×(1+6/8)×2^{6-7} \\=1×14/8×2^{-1} \\= 14/16 \\=7/8\]</span></p><h2 id="整型转为浮点型">整型转为浮点型</h2><p>下面以一个例子来直观感受一下一个整型是如何转为浮点型的。</p><p>现在我们有一个 int32 的整型<code>123</code>，我们希望将其转为单精度浮点型 <code>123.0</code>。</p><p><strong>1. 将整型用二进制表示出来</strong></p><p><span class="math display">\[12345_{(10)} = 1111011_{(2)}\]</span></p><p><strong>2. 规范化表示</strong></p><p><span class="math display">\[1111011= 1.111011×2^6\]</span></p><p><strong>3. 计算指数</strong></p><p><span class="math display">\[exp = 6 + 127 = 133_{(10)} = 10000101_{(2)}\]</span></p><p><strong>4. 确定尾数**</strong></p><p>这是个规范化值，所以 <code>1.frac</code> 的 <code>1</code>省略，又因为单精度浮点数 <code>frac</code> 占 23 位，所以我们需要在<code>111011</code> 后面再填 17 个 0，即：</p><p><span class="math display">\[frac = 111011 0000 0000 0000 0000 0\]</span></p><p><strong>5. 确定符号位</strong></p><p><span class="math display">\[s = 0_{(2)}\]</span></p><p><strong>6. 组合起来</strong></p><p><code>12345.0</code> =<code>0  10000101 11101100000000000000000</code></p><h2 id="浮点数舍入">浮点数舍入</h2><p>由于浮点数的表示具有固定的精度，在进行运算或表示时，经常会遇到无法精确表示的数值，这就需要采用舍入方法来近似表示这些数值。IEEE-754标准定义了几种不同的舍入模式，以适应不同的计算需求。</p><h3 id="舍入模式">舍入模式</h3><p><strong>最近舍入（Round to Nearest）</strong>:</p><ul><li>这是最常用的舍入模式，也是默认的模式。</li><li>规则是向最接近的可表示值舍入。如果精确结果位于两个可表示值的中点，通常舍入到最近的偶数（即尾数的最后一位为0）。</li><li>这种方法减少了累积误差，确保了在多次运算后的总体精度。</li></ul><p><strong>向零舍入（Round Toward Zero）</strong>:</p><ul><li>这种模式总是舍入到零的方向，即舍去小数部分。</li><li>对于正数，这相当于取下限，对于负数，相当于取上限。</li></ul><p><strong>向上舍入（Round Up）</strong>:</p><ul><li>无论正负，都向远离零的方向舍入。</li><li>对于正数，舍入后的值不小于原值；对于负数，舍入后的值不大于原值。</li></ul><p><strong>向下舍入（Round Down）</strong>:</p><ul><li>无论正负，都向接近零的方向舍入。</li><li>对于正数，舍入后的值不大于原值；对于负数，舍入后的值不小于原值。</li></ul><h3 id="舍入的影响">舍入的影响</h3><ul><li><strong>精度损失</strong>：由于固定的尾数位数，舍入可能导致精度的损失。</li><li><strong>舍入误差</strong>：舍入操作本身可能引入误差，这些误差在连续运算中可能会累积。</li><li><strong>选择合适的舍入模式</strong>：不同的舍入模式适合不同的应用场景。例如，金融计算可能更倾向于使用向零舍入，而科学计算通常使用最近舍入以减少累积误差。</li></ul><h3 id="实例">实例</h3><table><thead><tr class="header"><th>Mode</th><th style="text-align: center;">1.40</th><th style="text-align: center;">1.60</th><th style="text-align: center;">1.50</th><th style="text-align: center;">2.50</th><th style="text-align: center;">-1.50</th></tr></thead><tbody><tr class="odd"><td>最近舍入</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">-2</td></tr><tr class="even"><td>向零舍入</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">-1</td></tr><tr class="odd"><td>向上舍入</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">-1</td></tr><tr class="even"><td>向下舍入</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">-2</td></tr></tbody></table><h2 id="浮点数运算">浮点数运算</h2><p>因为浮点数本身就存在精度问题，所以浮点数运算在计算机中是一个近似过程，涉及到精确度的权衡、特殊值的处理、错误的传播，以及舍入规则的应用。</p><h3 id="浮点数加减">浮点数加减</h3><ol type="1"><li>浮点数加法和减法首先需要对操作数进行对齐，使得它们的指数相同。这可能涉及将尾数的二进制表示向右移位，可能导致精度损失。</li><li>然后执行加法或减法操作。</li><li>对结果进行规范化和舍入。</li></ol><p>注意，浮点数的加减法<strong>不满足</strong>结合律、交换律和分配律，这你简单分析下应该就可以理解了，这里不赘述了。</p><p>假设我们要在单精度浮点数格式下计算：</p><p><span class="math display">\[12.375 + 0.1 = ?\]</span></p><p><strong>第 1 步：转为二进制表示</strong></p><p>其中 12.375 我们可以用二进制精确表示：</p><p><span class="math display">\[12.375_{(10)} = 1100.011_{(2)}\]</span></p><p>而 0.1 就比较特殊了，用二进制表示的话它会无限循环。</p><blockquote><p>将十进制小数转换为二进制表示涉及到重复乘以 2的过程，并提取每次乘法后整数部分作为二进制位。这个过程是一个不断重复的过程，直到小数部分变为0 或开始循环。</p></blockquote><ol type="1"><li><p>取 <code>0.1</code> 的小数部分乘以 2（即<code>0.1 × 2 = 0.2</code>），整数部分是 <code>0</code>，小数部分是<code>0.2</code>。</p></li><li><p>再次取小数部分乘以 2（即 <code>0.2 × 2 = 0.4</code>），整数部分是<code>0</code>，小数部分是 <code>0.4</code>。</p></li><li><p>继续这个过程，我们得到以下序列：</p><p><code>0.4 × 2 = 0.8</code> → 整数部分 <code>0</code></p><p><code>0.8 × 2 = 1.6</code> → 整数部分 <code>1</code></p><p><code>0.6 × 2 = 1.2</code> → 整数部分 <code>1</code></p><p><code>0.2 × 2 = 0.4</code> → 整数部分 <code>0</code></p><p>…（循环开始）</p></li></ol><p>所以，<code>0.1</code> 的二进制表示开始为<code>0.0001100110011…</code>，并且这个模式会无限循环下去。</p><p><strong>第 2 步：规格化</strong></p><p>回顾一下这张图：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231224102703581.png"alt="单精度浮点数" /><figcaption aria-hidden="true">单精度浮点数</figcaption></figure><p>所以 12.375 规格化表示为：</p><ul><li>先规范化为 1.xxxx 形式： <span class="math inline">\(1100.011_{(2)}= 1.100011 × 2^3\)</span></li><li>指数为：<span class="math inline">\(3 + 127 = 130 =10000010_{(2)}\)</span></li><li>尾数为：<spanclass="math inline">\(10001100000000000000000（23\;位，右边补\;0）\)</span></li><li>汇总：<spanclass="math inline">\(0\;10000010\;10001100000000000000000\)</span></li></ul><p>而 0.1 由于无限循环，我们在单精度下只能保留 23位，并采用<strong>最近舍入</strong>，所以 0.1 规格化表示为：</p><ul><li>先规范为 1.xxxx 形式：<spanclass="math inline">\(0.00011001100110011001100(循环) =1.10011001100110011001100 × 2^-4\)</span></li><li>指数为：<span class="math inline">\(-4 + 127 = 123 =01111011_{(2)}\)</span></li><li>尾数为：<spanclass="math inline">\(10011001100110011001100\)</span></li><li>汇总：<spanclass="math inline">\(0\;01111011\;10011001100110011001100\)</span></li></ul><p><strong>第 3 步：对齐指数</strong></p><p>先把 2 个浮点表示放在一起，好对比：</p><ul><li><spanclass="math inline">\(0\;10000010\;10001100000000000000000\)</span></li><li><spanclass="math inline">\(0\;01111011\;10011001100110011001100\)</span></li></ul><p>将两个数的指数对齐，较小的指数增加，同时相应地调整尾数。</p><p>这里需要调整将 <code>0.1</code> 的指数从 <code>01111011</code> 调整到<code>10000010</code>，这里加了 <code>7</code>，所以 <code>0.1</code>的尾数 <code>1.10011001100110011001100</code>需要右移 <code>7</code>位，即：<code>0.00000011001100110011001</code>。</p><p><strong>第 4 步：相加</strong></p><p>现在两个数的指数相同了，我们可以直接把它们的尾数相加：</p><p><span class="math display">\[\;\;\;1.10001100000000000000000 \\+\;0.00000011001100110011001 \\=\;1.10001111001100110011001\]</span></p><p><strong>第 5 步：规范化结果</strong></p><p>这里无需规范化。</p><p><strong>第 6 步：舍入</strong></p><p>这里没有进位，不需要舍入。</p><p><strong>第 7 步：浮点化表示</strong></p><p><span class="math display">\[0\;10000010\;10001111001100110011001\]</span></p><p><strong>第 8 步：转为十进制</strong></p><p><span class="math display">\[V =(-1)^s×M×2^E \\= (-1)^s×1.frac×2^{e-bias} \\= 1.10001111001100110011001 × 2^3 \\= 1100.01111001100110011001_{(2)} \\= 12.47499942779541015625_{(10)} \\≈ 12.475_{(10)}\]</span></p><h3 id="浮点数乘法">浮点数乘法</h3><ol type="1"><li><strong>符号位计算</strong>：结果的符号由两个操作数的符号位决定。如果符号位相同（都是正数或都是负数），结果为正；如果符号位不同，结果为负。</li><li><strong>指数相加</strong>：两个数的指数相加，并减去偏置值（单精度浮点数中为127，双精度为 1023）。</li><li><strong>尾数相乘</strong>：两个数的尾数相乘。这里的尾数包括隐含的最高位1。</li><li><strong>结果规范化</strong>：如果乘法的结果需要规范化（即调整为<code>1.xxxx</code> 的形式），则相应调整指数。</li><li><strong>舍入处理</strong>：如果需要，对结果进行舍入以适应目标格式。</li><li><strong>检查溢出或下溢</strong>：如果指数超出了表示范围，则发生溢出（结果可能为无穷大或特殊值）；如果指数太小，发生下溢（结果可能为0 或非规格化数）。</li></ol><p>假设我们要在单精度浮点数格式下计算：</p><p><span class="math display">\[2.0 × 3.0 = ?\]</span></p><p><strong>第 1 步：转为二进制表示</strong></p><p><span class="math display">\[2.0_{(10)} = 1_{(2)} \\3.0_{(10)} = 11_{(2)}\]</span></p><p><strong>第 2 步：规范化</strong></p><p><span class="math display">\[1 = 1.0 × 2^0 \\11 = 1.1 × 2^1\]</span></p><p><strong>第 3 步：浮点化</strong></p><p><span class="math display">\[2.0 = 0\;00000001\;00000000000000000000000 \\3.0 = 0\;00000001\;10000000000000000000000\]</span></p><p><strong>第 4 步：乘法操作</strong></p><ul><li>符号位：正正得正：<span class="math inline">\(0_{(2)} × 0_{(2)} =0_{(2)}\)</span></li><li>指数相加并减去偏置值：<spanclass="math inline">\((127+1)+(127+1)-127=129\)</span></li><li>尾数相乘：<span class="math inline">\(1.0_{(2)}×1.1_{(2)} =1.1_{(2)}\)</span></li></ul><p><strong>第 5 步：规范化</strong></p><p>这里无需规范化。</p><p><strong>第 6 步：舍入</strong></p><p>这里无需舍入。</p><p><strong>第 7 步：浮点化结果</strong></p><p><span class="math display">\[0\;00000010\;10000000000000000000000\]</span></p><p><strong>第 8 步：转为十进制</strong></p><p><span class="math display">\[V = (-1)^s×1.frac×2^{(e-127)} \\= 0 × 1.1 × 2^2 \\= 110_{(2)} \\= 6.0_{(10)}\]</span></p><h3 id="浮点数除法">浮点数除法</h3><p>浮点数除法类似于乘法，但有一些不同：</p><ol type="1"><li><strong>符号位计算</strong>：与乘法类似，结果的符号由两个操作数的符号位决定。</li><li><strong>指数相减</strong>：被除数的指数减去除数的指数，再加上偏置值。</li><li><strong>尾数相除</strong>：被除数的尾数除以除数的尾数。</li><li><strong>结果规范化</strong>：如果必要，调整结果使其规范化。</li><li><strong>舍入处理</strong>：如果需要，对结果进行舍入。</li><li><strong>检查溢出或下溢</strong>：与乘法类似的检查。</li></ol><p>假设我们要在单精度浮点数格式下计算：</p><p><span class="math display">\[6.0 ÷ 3.0 =?\]</span></p><p><strong>第 1 步：转为二进制表示</strong></p><p><span class="math display">\[6.0_{(10)} = 110_{(2)} \\3.0_{(10)} = 11_{(2)}\]</span></p><p><strong>第 2 步：规范化</strong></p><p><span class="math display">\[6.0 = 110 = 1.10 × 2^2 \\3.0 = 11 = 1.1 × 2^1\]</span></p><p><strong>第 3 步：浮点化</strong></p><p><span class="math display">\[6.0 = 0\;00000020\;10000000000000000000000 \\3.0 = 0\;00000001\;10000000000000000000000\]</span></p><p><strong>第 4 步：除法操作</strong></p><ul><li>符号位：正正得正：<span class="math inline">\(0_{(2)} × 0_{(2)} =0_{(2)}\)</span></li><li>指数减并加上偏置值：<spanclass="math inline">\((127+2)-(127+1)+127=128\)</span></li><li>尾数相除：<span class="math inline">\(1.1_{(2)}×1.1_{(2)} =1.0_{(2)}\)</span></li></ul><p><strong>第 5 步：规范化</strong></p><p>这里无需规范化。</p><p><strong>第 6 步：舍入</strong></p><p>这里无需舍入。</p><p><strong>第 7 步：浮点化结果</strong></p><p><span class="math display">\[0\;00000001\;00000000000000000000000\]</span></p><p><strong>第 8 步：转为十进制</strong></p><p><span class="math display">\[V = (-1)^s×1.frac×2^{(e-127)} \\= 0 × 1.0 × 2^1 \\= 10_{(2)} \\= 2.0_{(10)}\]</span></p><h2 id="go-语言输出浮点数">Go 语言输出浮点数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> number <span class="hljs-type">float32</span> = <span class="hljs-number">12.375</span><br>fmt.Printf(<span class="hljs-string">&quot;浮点数：%f\n&quot;</span>, number)<br>fmt.Printf(<span class="hljs-string">&quot;科学计数法：%e\n&quot;</span>, number)<br>fmt.Printf(<span class="hljs-string">&quot;保留 2 位小数：%.2f\n&quot;</span>, number)<br><br>bits := math.Float32bits(number)<br>bitsStr := fmt.Sprintf(<span class="hljs-string">&quot;%.32b&quot;</span>, bits)<br>fmt.Printf(<span class="hljs-string">&quot;输出32位浮点表示：%s %s %s\n&quot;</span>, bitsStr[:<span class="hljs-number">1</span>], bitsStr[<span class="hljs-number">1</span>:<span class="hljs-number">9</span>], bitsStr[<span class="hljs-number">9</span>:])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mathbig">math/big</h2><p>Go 语言的 <code>math/big</code>包提供了对大数的精确计算支持，这些大数的大小超出了标准整数类型（如<code>int64</code>）或浮点类型（如<code>float64</code>）的范围。这个包主要用于需要高精度计算的领域，如加密、科学计算等。</p><p>主要功能：</p><ul><li><strong>算术运算</strong>：支持基本的加、减、乘、除等算术运算。</li><li><strong>比较操作</strong>：可以比较两个大数的大小。</li><li><strong>位操作</strong>：对大整数进行位操作，如位移、与、或、异或等。</li><li><strong>解析和格式化</strong>：可以从字符串解析大数，也可以将大数格式化为字符串。</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := big.NewFloat(math.MaxFloat64)<br>b := big.NewFloat(math.MaxFloat64)<br>sum := big.NewFloat(<span class="hljs-number">0</span>)<br>sum.Add(a, b)<br>fmt.Println(<span class="hljs-string">&quot;a:&quot;</span>, a)<br>fmt.Println(<span class="hljs-string">&quot;sum:&quot;</span>, sum)<br>sum2 := big.NewFloat(<span class="hljs-number">0</span>).<br>SetPrec(<span class="hljs-number">15</span>).        <span class="hljs-comment">// 设置精度，prec 越大，精度越高，计算越复杂</span><br>SetMode(big.ToZero) <span class="hljs-comment">// 设置舍入策略</span><br>sum2.Add(a, b)<br>fmt.Println(<span class="hljs-string">&quot;sum2:&quot;</span>, sum2)<br>&#125;<br><br><span class="hljs-comment">// a: 1.7976931348623157e+308</span><br><span class="hljs-comment">// sum: 3.5953862697246314e+308</span><br><span class="hljs-comment">// sum2: 3.5953e+308</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li><strong>性能考虑</strong>：由于 <code>math/big</code>提供的是任意精度计算，其性能通常低于原生的固定大小数值类型。</li><li><strong>内存使用</strong>：大数运算可能会消耗更多的内存。</li><li><strong>方法链式调用</strong>：<code>math/big</code>的许多方法返回接收者本身，支持链式调用。</li></ul><h2 id="参考资料">参考资料</h2><ul><li><ahref="https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">IEEE-754</a></li><li>深入理解计算机系统</li><li>Go 语言底层原理剖析</li><li>https://www.bilibili.com/video/BV1zK4y1j7Cn</li><li>ChatGPT-4</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机原理</tag>
      
      <tag>浮点数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go1.21.0 程序启动过程</title>
    <link href="/2023/12/07/go-start/"/>
    <url>/2023/12/07/go-start/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><ul><li>Go 1.21.0</li><li>操作系统：Windows11 Intel64</li></ul><h2 id="结论先行">结论先行</h2><h3 id="开发关注版">开发关注版</h3><p>在 Go 语言中，启动顺序通常如下：</p><ol type="1"><li><strong>导入包</strong>：首先，Go 编译器按照源文件中的<code>import</code> 语句导入所有需要的包。</li><li><strong>初始化常量和变量</strong>：接着，编译器会初始化包级别（全局）的常量和变量。它们的初始化顺序按照它们在源文件中出现的顺序进行。</li><li><strong>执行 init 函数</strong>：然后，编译器会执行包级别的<code>init</code> 函数。如果一个包有多个 <code>init</code>函数，它们的执行顺序和它们在源文件中出现的顺序一致。</li><li><strong>执行 main.main 函数</strong>：最后，编译器会执行<code>main</code> 函数。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/710735-20211213134644475-1604352048.png"alt="Go 程序启动流程 - 开发关注版" /><figcaption aria-hidden="true">Go 程序启动流程 - 开发关注版</figcaption></figure><h3 id="深入原理版">深入原理版</h3><ol type="1"><li><strong>命令行参数复制</strong>：读取命令行参数，复制到 argc 和argv。</li><li><strong>初始化 g0 栈</strong>：g0 是运行时系统的一个特殊的goroutine，它在程序启动时被创建，用于执行系统调用和协程调度。</li><li><strong>runtime.check 运行时检查</strong>：<ol type="1"><li>类型长度</li><li>指针操作</li><li>结构体字段偏移量</li><li>CAS</li><li>atomic 操作</li><li>栈大小是否为 2 的幂次。</li></ol></li><li><strong>runtime.args 参数初始化</strong>：将 argc 和 argv的参数赋值到 Go 的变量中。</li><li><strong>runtime.osinit初始化操作系统特点的设置</strong>：主要是判断系统字长和 CPU 核数。</li><li><strong>runtime.schedinit 初始化调度器</strong>：<ol type="1"><li>锁初始化</li><li>竞态检测器初始化</li><li>调度器设置，设置调度器可以管理的最大线程（M）数目</li><li>系统初始化，初始化内存管理、CPU设置、算法等，这些都是调度器正常工作的基础</li><li>设置当前 M 的信号掩码</li><li>解析程序参数和环境变量</li><li>垃圾收集器初始化</li><li>设置 process 的数量</li></ol></li><li><strong>runtime.newproc 创建主协程 g0并将其放入队列中等待执行</strong>。</li><li><strong>runtime. mstart 启动调度器</strong>：初始化 m0，并调度 g0去执行 <code>runtime.main</code>。</li><li><strong>runtime.main 程序真正入口</strong>：<ol type="1"><li>runtime.init</li><li>启动 gc</li><li>执行用户包 init</li><li>执行用户函数 main.main</li></ol></li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231210224929126.png"alt="Go 程序启动流程 - 深入原理版" /><figcaption aria-hidden="true">Go 程序启动流程 - 深入原理版</figcaption></figure><blockquote><p>如果只是想对 Go语言程序的启动过程有一个简单的了解，那么阅读到这里就可以结束了。</p></blockquote><h2 id="runtime">Runtime</h2><p>在分析 Go 程序的启动过程之前，我们需要先了解一下 Go 中的Runtime。所谓 Runtime，即 Go 的运行时环境，可以理解为 Java 的JVM、JavaScript 依赖的浏览器内核。</p><p>Go 的 Runtime是一份代码，它会随着用户程序一起打包成二进制文件，随着程序一起运行。</p><p>Runtime 具有内存管理、GC、协程、屏蔽不同操作系统调用等能力。</p><p>综上，Go 程序的运行都依赖于 Runtime 运行，所以我们在分析 Go语言程序的启动过程的时候，首先要确定程序的入口，即 Runtime。</p><p>这部分代码位于 go 源码中 <ahref="https://github.com/golang/go/tree/go1.21.0/src/runtime">src/runtime</a>目录下，当你在本机安装 go 后，你可以进入相应的代码目录下，在 Windows上，你可以在该目录下运行下面命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">dir</span> | findstr <span class="hljs-string">&quot;rt0&quot;</span> |  findstr <span class="hljs-string">&quot;amd&quot;</span><br></code></pre></td></tr></table></figure><p>这里我们输出 go 官方为多种 <code>amd</code>处理器架构的操作系统所实现的 runtime，如：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">754</span> rt0_android_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">399</span> rt0_darwin_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">448</span> rt0_dragonfly_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">442</span> rt0_freebsd_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">311</span> rt0_illumos_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">425</span> rt0_ios_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">307</span> rt0_linux_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">309</span> rt0_netbsd_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">311</span> rt0_openbsd_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">481</span> rt0_plan9_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>            <span class="hljs-number">311</span> rt0_solaris_amd64.s<br><span class="hljs-literal">-a----</span>         <span class="hljs-number">2023</span>/<span class="hljs-number">8</span>/<span class="hljs-number">25</span>     <span class="hljs-number">23</span>:<span class="hljs-number">44</span>           <span class="hljs-number">1166</span> rt0_windows_amd64.s<br></code></pre></td></tr></table></figure><p>到这里也就明白了，前面所说的 Go Runtime 能力之“屏蔽不同操作系统调用能力”的方式便是针对每一种操作系统单独做实现，最后在编译的时候根据操作系统选择对应的实现即可。</p><p>这里我们以 <ahref="https://github.com/golang/go/blob/go1.21.0/src/runtime/rt0_windows_amd64.s">rt0_windows_amd64.s</a>为例，看看这个文件写了些什么：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">TEXT</span> _rt0_amd64_windows(<span class="hljs-built_in">SB</span>),NOSPLIT<span class="hljs-title">|NOFRAME,$-8</span><br><span class="hljs-title">JMP_rt0_amd64(SB)</span><br></code></pre></td></tr></table></figure><p>这里我们可以看到它会直接跳到 <code>_rt0_amd64(SB)</code> 这里，在Goland IDE 中，你可以双击 Shift 键打开搜索，搜索<code>TEXT _rt0_amd64</code>，就可以发现这个函数位于 <ahref="https://github.com/golang/go/blob/go1.21.0/src/runtime/asm_amd64.s">asm_amd64.s</a>文件中，查看该文件：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// _rt0_amd64 is common startup code for most amd64 systems when using</span><br><span class="hljs-comment">// internal linking. This is the entry point for the program from the</span><br><span class="hljs-comment">// kernel for an ordinary -buildmode=exe program. The stack holds the</span><br><span class="hljs-comment">// number of arguments and the C-style argv.</span><br><span class="hljs-symbol">TEXT</span> _rt0_amd64(<span class="hljs-built_in">SB</span>),NOSPLIT,$-<span class="hljs-number">8</span><br>MOVQ<span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>), DI<span class="hljs-comment">// argc</span><br>LEAQ<span class="hljs-number">8</span>(<span class="hljs-built_in">SP</span>), SI<span class="hljs-comment">// argv</span><br>JMPruntime·rt0_go(<span class="hljs-built_in">SB</span>)<br></code></pre></td></tr></table></figure><p>翻译一下上面的注释：<code>_rt0_amd64</code> 是大多数<code>amd64</code> 系统在使用内部链接时的通用启动代码。这是<code>exe</code> 程序从内核进入程序的入口点。堆栈保存了参数的数量和 C语言风格的 argv。</p><p>到这里我们就可以非常确定地找到了对应操作系统的 Go语言程序启动入口了，接下来只需要沿着该入口继续分析即可。</p><h2 id="runtimert0_go">runtime·rt0_go</h2><p>上面我们分析到 <code>_rt0_adm64</code> 会 JMP 到<code>runtime·rt0_go</code> 执行，这个函数也位于 <ahref="https://github.com/golang/go/blob/go1.21.0/src/runtime/asm_amd64.s">asm_amd64.s</a>文件中，通过分析这个函数，我们可以了解到 Go 语言程序的整个启动过程。</p><p>下面将对这整个函数进行一个概览，后面会对重点过程逐个详述。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">TEXT</span> runtime·rt0_go(<span class="hljs-built_in">SB</span>),NOSPLIT<span class="hljs-title">|NOFRAME|</span>TOPFRAME,<span class="hljs-number">$0</span><br><span class="hljs-comment">// 读取命令行参数，复制参数变量 argc 和 argv 到栈上</span><br>MOVQDI, AX<span class="hljs-comment">// argc</span><br>MOVQSI, <span class="hljs-keyword">BX</span><span class="hljs-comment">// argv</span><br>SUBQ$(<span class="hljs-number">5</span>*<span class="hljs-number">8</span>), <span class="hljs-built_in">SP</span><br>ANDQ$~<span class="hljs-number">15</span>, <span class="hljs-built_in">SP</span><br>MOVQAX, <span class="hljs-number">24</span>(<span class="hljs-built_in">SP</span>)<br>MOVQBX, <span class="hljs-number">32</span>(<span class="hljs-built_in">SP</span>)<br><br><span class="hljs-comment">// 从给定的（操作系统）堆栈创建istack。</span><br><span class="hljs-comment">// 这是在设置 g0 的堆栈，g0 是运行时系统的一个特殊的 goroutine。</span><br><span class="hljs-comment">// 它在程序启动时被创建，用于执行系统调用和协程调度。</span><br><span class="hljs-comment">// 这里只是初始化 g0 的堆栈，还没有启动 g0。</span><br>MOVQ$runtime·g0(<span class="hljs-built_in">SB</span>), DI<br>LEAQ(-<span class="hljs-number">64</span>*<span class="hljs-number">1024</span>)(<span class="hljs-built_in">SP</span>), <span class="hljs-keyword">BX</span><br>MOVQBX, g_stackguard0(DI)<br>MOVQBX, g_stackguard1(DI)<br>MOVQBX, (g_stack+stack_lo)(DI)<br>MOVQ<span class="hljs-built_in">SP</span>, (g_stack+stack_hi)(DI)<br><br><span class="hljs-comment">// 检查 CPU 的厂商 ID：</span><br><span class="hljs-comment">//如果没有 CPU 信息，则跳转到 nocpuinfo；</span><br><span class="hljs-comment">//如果是 Intel 的 CPU，就设置 runtime·isIntel=1，否则跳到 notintel。</span><br>MOVL<span class="hljs-number">$0</span>, AX<br>CPUID<br>CMPLAX, <span class="hljs-number">$0</span><br>JEnocpuinfo<br>CMPLBX, <span class="hljs-number">$0x756E6547</span>  <span class="hljs-comment">// &quot;Genu&quot;</span><br>JNEnotintel<br>CMPLDX, <span class="hljs-number">$0x49656E69</span>  <span class="hljs-comment">// &quot;ineI&quot;</span><br>JNEnotintel<br>CMPLCX, <span class="hljs-number">$0x6C65746E</span>  <span class="hljs-comment">// &quot;ntel&quot;</span><br>JNEnotintel<br>MOVB<span class="hljs-number">$1</span>, runtime·isIntel(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-symbol">notintel:</span>  <span class="hljs-comment">// 加载 EXA=1 的 cpuid 标志和版本信息</span><br>MOVL<span class="hljs-number">$1</span>, AX<br>CPUID<br>MOVLAX, runtime·processorVersionInfo(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-symbol">nocpuinfo:</span>  <br><span class="hljs-comment">// 如果有 _cgo_init 就调用它</span><br>MOVQ_cgo_init(<span class="hljs-built_in">SB</span>), AX<br>TESTQAX, AX<br><span class="hljs-comment">// 如果 _cgo_init 不存在，那么跳过后面的代码，</span><br><span class="hljs-comment">// 直接进入到 needtls 进行 TLS 的初始化。</span><br><span class="hljs-comment">// TLS，全称为Thread-Local Storage（线程局部存储），</span><br><span class="hljs-comment">// 是操作系统提供的一种机制，允许每个线程拥有一份自己的数据副本。</span><br><span class="hljs-comment">// 这些数据在同一线程的所有函数中都是可见的，但对其他线程是不可见的。</span><br><span class="hljs-comment">// 这样，每个线程可以访问和修改自己的数据，而不会影响其他线程。</span><br>JZneedtls<br><span class="hljs-comment">// 将 setg_gcc 函数的地址加载到 SI 寄存器中。</span><br><span class="hljs-comment">// 这是 _cgo_init 函数的第二个参数。</span><br>MOVQ$setg_gcc&lt;&gt;(<span class="hljs-built_in">SB</span>), SI <span class="hljs-comment">// arg 2: setg_gcc</span><br><span class="hljs-comment">// 在使用平台的TLS时不使用这第3和第4个参数。</span><br>MOVQ<span class="hljs-number">$0</span>, DX<br>MOVQ<span class="hljs-number">$0</span>, CX<br><span class="hljs-comment">#ifdef GOOS_android</span><br>MOVQ$runtime·tls_g(<span class="hljs-built_in">SB</span>), DX <span class="hljs-comment">// arg 3: &amp;tls_g</span><br><span class="hljs-comment">// arg 4: TLS base, stored in slot 0 (Android&#x27;s TLS_SLOT_SELF).</span><br><span class="hljs-comment">// Compensate for tls_g (+16).</span><br>MOVQ-<span class="hljs-number">16</span>(TLS), CX<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_windows</span><br>MOVQ$runtime·tls_g(<span class="hljs-built_in">SB</span>), DX <span class="hljs-comment">// arg 3: &amp;tls_g</span><br><span class="hljs-comment">// 调整 Win64 的调用约定。</span><br>MOVQCX, <span class="hljs-built_in">R9</span> <span class="hljs-comment">// arg 4</span><br>MOVQDX, <span class="hljs-built_in">R8</span> <span class="hljs-comment">// arg 3</span><br>MOVQSI, DX <span class="hljs-comment">// arg 2</span><br>MOVQDI, CX <span class="hljs-comment">// arg 1</span><br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">// 前面 MOVQ_cgo_init(SB), AX，这里就是调用 _cgo_init</span><br>CALLAX<br><span class="hljs-comment">// 在 _cgo_init 之后更新 stackguard</span><br>MOVQ$runtime·g0(<span class="hljs-built_in">SB</span>), CX<br>MOVQ(g_stack+stack_lo)(CX), AX<br>ADDQ$const_stackGuard, AX<br>MOVQAX, g_stackguard0(CX)<br>MOVQAX, g_stackguard1(CX)<br><br><span class="hljs-comment">#ifndef GOOS_windows</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">// 针对不同操作系统对 TLS 进行设置</span><br><span class="hljs-symbol">needtls:</span>  <br><span class="hljs-comment">#ifdef GOOS_plan9</span><br><span class="hljs-comment">// skip TLS setup on Plan 9</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_solaris</span><br><span class="hljs-comment">// skip TLS setup on Solaris</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_illumos</span><br><span class="hljs-comment">// skip TLS setup on illumos</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_darwin</span><br><span class="hljs-comment">// skip TLS setup on Darwin</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#ifdef GOOS_openbsd</span><br><span class="hljs-comment">// skip TLS setup on OpenBSD</span><br>JMP ok<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef GOOS_windows</span><br>CALLruntime·wintls(<span class="hljs-built_in">SB</span>)<br><span class="hljs-comment">#endif</span><br><br>LEAQruntime·m0+m_tls(<span class="hljs-built_in">SB</span>), DI<br>CALLruntime·settls(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-comment">// 检查 TLS 是否正常工作</span><br>get_tls(BX)<br>MOVQ<span class="hljs-number">$0x123</span>, g(BX)<br>MOVQruntime·m0+m_tls(<span class="hljs-built_in">SB</span>), AX<br>CMPQAX, <span class="hljs-number">$0x123</span><br>JEQ <span class="hljs-number">2</span>(<span class="hljs-built_in">PC</span>)<br>CALLruntime·abort(<span class="hljs-built_in">SB</span>)<br><span class="hljs-symbol">ok:</span><br><span class="hljs-comment">//设置 g0 和 m0 和 TLS</span><br>get_tls(BX)<br>LEAQruntime·g0(<span class="hljs-built_in">SB</span>), CX<br>MOVQCX, g(BX)<br>LEAQruntime·m0(<span class="hljs-built_in">SB</span>), AX<br>MOVQCX, m_g0(AX)<br>MOVQAX, g_m(CX)<br>CLD<br><br><span class="hljs-comment">// 下面的 ifdef NEED_xxx 主要是在检查 CPU 是否支持 Go 运行时系统需要的特性。</span><br><span class="hljs-comment">// 我们需要在设置了 TLS 之后做这个，</span><br><span class="hljs-comment">// 如果失败就跳转到 bad_cpu 报告错误。</span><br><span class="hljs-comment">#ifdef NEED_FEATURES_CX</span><br>MOVL<span class="hljs-number">$0</span>, AX<br>CPUID<br>CMPLAX, <span class="hljs-number">$0</span><br>JEbad_cpu<br>MOVL<span class="hljs-number">$1</span>, AX<br>CPUID<br>ANDL$NEED_FEATURES_CX, CX<br>CMPLCX, $NEED_FEATURES_CX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_MAX_CPUID</span><br>MOVL<span class="hljs-number">$0x80000000</span>, AX<br>CPUID<br>CMPLAX, $NEED_MAX_CPUID<br>JLbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_EXT_FEATURES_BX</span><br>MOVL<span class="hljs-number">$7</span>, AX<br>MOVL<span class="hljs-number">$0</span>, CX<br>CPUID<br>ANDL$NEED_EXT_FEATURES_BX, <span class="hljs-keyword">BX</span><br>CMPLBX, $NEED_EXT_FEATURES_BX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_EXT_FEATURES_CX</span><br>MOVL<span class="hljs-number">$0x80000001</span>, AX<br>CPUID<br>ANDL$NEED_EXT_FEATURES_CX, CX<br>CMPLCX, $NEED_EXT_FEATURES_CX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_OS_SUPPORT_AX</span><br>XORL    CX, CX<br>XGETBV<br>ANDL$NEED_OS_SUPPORT_AX, AX<br>CMPLAX, $NEED_OS_SUPPORT_AX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifdef NEED_DARWIN_SUPPORT</span><br>MOVQ$commpage64_version, <span class="hljs-keyword">BX</span><br>CMPW(BX), <span class="hljs-number">$13</span>  <span class="hljs-comment">// cpu_capabilities64 undefined in versions &lt; 13</span><br>JLbad_cpu<br>MOVQ$commpage64_cpu_capabilities64, <span class="hljs-keyword">BX</span><br>MOVQ(BX), <span class="hljs-keyword">BX</span><br>MOVQ$NEED_DARWIN_SUPPORT, CX<br>ANDQCX, <span class="hljs-keyword">BX</span><br>CMPQBX, CX<br>JNEbad_cpu<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">// 检查完 AMD64 不同操作系统是否支持 Go 运行时系统需要的特性后，</span><br><span class="hljs-comment">// 这里执行 runtime·check 对代码做一下运行时检查。</span><br>CALLruntime·check(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-comment">// 复制 argc（命令行参数的数量）到 AX 寄存器，</span><br><span class="hljs-comment">// 然后把 AX 寄存器的值存到栈上。</span><br>MOVL<span class="hljs-number">24</span>(<span class="hljs-built_in">SP</span>), AX<br>MOVLAX, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)<br><span class="hljs-comment">// 复制 argv（命令行参数的数组）到 AX 寄存器，</span><br><span class="hljs-comment">// 然后把 AX 寄存器的值存到栈上。</span><br>MOVQ<span class="hljs-number">32</span>(<span class="hljs-built_in">SP</span>), AX<br>MOVQAX, <span class="hljs-number">8</span>(<span class="hljs-built_in">SP</span>)<br><span class="hljs-comment">// 调用 runtime·args 函数处理命令行参数。</span><br>CALLruntime·args(<span class="hljs-built_in">SB</span>)<br><span class="hljs-comment">// 调用 runtime·osinit 函数初始化操作系统特定的设置。</span><br>CALLruntime·osinit(<span class="hljs-built_in">SB</span>)<br><span class="hljs-comment">// 调用 runtime·schedinit 函数初始化调度器。</span><br>CALLruntime·schedinit(<span class="hljs-built_in">SB</span>)<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">   补充：这是该文件下面对 runtime·mainPC 的声明</span><br><span class="hljs-comment">    // mainPC is a function value for runtime.main, to be passed to newproc.</span><br><span class="hljs-comment">    // The reference to runtime.main is made via ABIInternal, since the</span><br><span class="hljs-comment">    // actual function (not the ABI0 wrapper) is needed by newproc.</span><br><span class="hljs-comment">    DATAruntime·mainPC+0(SB)/8,$runtime·main&lt;ABIInternal&gt;(SB)</span><br><span class="hljs-comment">    */</span><br>        <br>    <span class="hljs-comment">// 取 runtime·mainPC 的地址，这其实就是 runtime 包下的 main() 方法。</span><br>    <span class="hljs-comment">// 它是 Go 语言程序的真正入口，而不是 main.main()。</span><br>MOVQ$runtime·mainPC(<span class="hljs-built_in">SB</span>), AX<br>PUSHQAX<br>    <span class="hljs-comment">// 创建一个新的 goroutine 来运行程序的主函数。</span><br>    <span class="hljs-comment">// 这里还没有正在的运行，因为调度器还没有启动，</span><br>    <span class="hljs-comment">// 只是将 runtime.main 放进 goroutine 的 queue 中等待执行。</span><br>CALLruntime·newproc(<span class="hljs-built_in">SB</span>)<br>POPQAX<br><br><span class="hljs-comment">// 调用 runtime·mstart 函数启动 M（machine，代表一个操作系统线程），</span><br><span class="hljs-comment">// 开始执行 goroutines。</span><br>CALLruntime·mstart(<span class="hljs-built_in">SB</span>)<br><br><span class="hljs-comment">//  如果 runtime·mstart 函数返回，那么就调用 runtime·abort 函数终止程序。</span><br><span class="hljs-comment">// 因为 runtime·mstart 函数在正常情况下是不应该返回的，如果返回了，说明有错误发生。</span><br>CALLruntime·abort(<span class="hljs-built_in">SB</span>)<span class="hljs-comment">// mstart should never return</span><br>RET<br><br><span class="hljs-symbol">bad_cpu:</span> <span class="hljs-comment">// 当前 CPU 不支持 Go 运行时系统需要的时候的错误报告。</span><br>MOVQ<span class="hljs-number">$2</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)<br>MOVQ$bad_cpu_msg&lt;&gt;(<span class="hljs-built_in">SB</span>), AX<br>MOVQAX, <span class="hljs-number">8</span>(<span class="hljs-built_in">SP</span>)<br>MOVQ<span class="hljs-number">$84</span>, <span class="hljs-number">16</span>(<span class="hljs-built_in">SP</span>)<br>CALLruntime·write(<span class="hljs-built_in">SB</span>)<br>MOVQ<span class="hljs-number">$1</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)<br>CALLruntime·exit(<span class="hljs-built_in">SB</span>)<br>CALLruntime·abort(<span class="hljs-built_in">SB</span>)<br>RET<br><br><span class="hljs-comment">// Prevent dead-code elimination of debugCallV2, which is</span><br><span class="hljs-comment">// intended to be called by debuggers.</span><br>MOVQ$runtime·debugCallV2&lt;ABIInternal&gt;(<span class="hljs-built_in">SB</span>), AX<br>RET<br></code></pre></td></tr></table></figure><p>整理一下，<code>runtime·rt0_go</code> 的大体过程如下：</p><ol type="1"><li>读取命令行参数，复制参数变量 argc 和 argv 到栈上。</li><li>初始化 g0 栈，g0 是为了调度协程而产生的协程，是 g0是运行时系统的一个特殊的goroutine，它在程序启动时被创建，用于执行系统调用和协程调度。</li><li>获取 CPU 信息。</li><li>如果存在 <code>_cgo_init</code>，这调用它。</li><li>检查并设置线性局部存储（TLS）。</li><li>检查 CPU 是否支持 Go 运行时系统需要的特性。</li><li>完成运行时系统检查和初始化：<ul><li>调用 <code>runtime·check</code> 对代码进行运行时检查。</li><li>调用 <code>runtime·args</code> 函数处理命令行参数。</li><li>调用 <code>runtime·osinit</code> 函数初始化操作系统特定的设置。</li><li>调用 <code>runtime·schedinit</code> 函数初始化调度器。</li></ul></li><li>调用 <code>runtime·newproc</code> 创建一个新的 goroutine来运行程序的主函数。</li><li>调用 <code>runtime·mstart</code> 启动当前的 machine，执行goroutines，执行程序。</li></ol><p>一句话：<code>runtime·rt0_go</code> 是 Go语言运行时的入口点，它负责设置和初始化运行时环境，然后创建 g0 和 m0来运行程序的主函数。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/3EGyo5Q3LRKr4XdNg1dHFr.png"alt="Go 运行时系统初始化流程" /><figcaption aria-hidden="true">Go 运行时系统初始化流程</figcaption></figure><p>了解完 Go 程序的整体启动流程后，我们重点来分析一下其中的<code>runtime·check</code>、<code>runtime·args</code>、<code>runtime·osinit</code>、<code>runtime·schedinit</code>、<code>runtime·newproc</code>和 <code>runtime·mstart</code>。</p><blockquote><p>对了，充分理解 Go 启动流程，可能需要你对 Go 的 GMP 模型有一定的了解。// TODO</p></blockquote><h2 id="runtimecheck">runtime·check</h2><p>在 Goland IDE 上，我们双击 Shift，全局搜索 <code>runtime·check</code>会发现找不到函数的实现。</p><p>Go 语言的运行时系统大部分是用 Go自己编写的，但是有一部分，特别是与平台相关的部分，是用汇编语言编写的。在汇编语言中，调用Go 函数的一种方式是使用 <code>CALL</code>指令和函数的全名，包括包名和函数名。在这种情况下，<code>runtime·check</code>就是调用 <code>runtime</code> 包下的 <code>check()</code> 函数。</p><p>所以我们需要双击 Shift，搜索 <code>runtine.check</code>，即将<code>·</code> 换成<code>.</code>（后面所有函数均是这个道理）。我们会发现<code>check()</code> 位于 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/runtime1.go">runtime/runtime1.go</a>中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>a     <span class="hljs-type">int8</span><br>b     <span class="hljs-type">uint8</span><br>c     <span class="hljs-type">int16</span><br>d     <span class="hljs-type">uint16</span><br>e     <span class="hljs-type">int32</span><br>f     <span class="hljs-type">uint32</span><br>g     <span class="hljs-type">int64</span><br>h     <span class="hljs-type">uint64</span><br>i, i1 <span class="hljs-type">float32</span><br>j, j1 <span class="hljs-type">float64</span><br>k     unsafe.Pointer<br>l     *<span class="hljs-type">uint16</span><br>m     [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span><br>)<br><span class="hljs-keyword">type</span> x1t <span class="hljs-keyword">struct</span> &#123;<br>x <span class="hljs-type">uint8</span><br>&#125;<br><span class="hljs-keyword">type</span> y1t <span class="hljs-keyword">struct</span> &#123;<br>x1 x1t<br>y  <span class="hljs-type">uint8</span><br>&#125;<br><span class="hljs-keyword">var</span> x1 x1t<br><span class="hljs-keyword">var</span> y1 y1t<br>    <span class="hljs-comment">// 检查各种类型的变量的大小是否符合预期</span><br><span class="hljs-keyword">if</span> unsafe.Sizeof(a) != <span class="hljs-number">1</span> &#123;<br>throw(<span class="hljs-string">&quot;bad a&quot;</span>)<br>&#125;<br>    ...<br>    <span class="hljs-comment">// 检查指针操作</span><br><span class="hljs-keyword">if</span> unsafe.Sizeof(k) != goarch.PtrSize &#123;<br>throw(<span class="hljs-string">&quot;bad k&quot;</span>)<br>&#125;<br>    ...<br><span class="hljs-comment">// 检查结构体中字段的偏移量是否符合预期 </span><br><span class="hljs-keyword">if</span> unsafe.Offsetof(y1.y) != <span class="hljs-number">1</span> &#123;<br>throw(<span class="hljs-string">&quot;bad offsetof y1.y&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// timediv 函数的目的是在 32 位处理器上实现 64 位的除法运算。</span><br>    <span class="hljs-comment">// 由于在 32 位处理器上，64 位的除法运算会被转换为 _divv() 函数调用，</span><br>    <span class="hljs-comment">// 这可能会超出 nosplit 函数的栈限制，所以需要这个特殊的函数来进行处理。</span><br>    <span class="hljs-comment">// //go:nosplit 是一个编译器指令，它告诉编译器不要在这个函数中插入栈分割检查。</span><br>    <span class="hljs-comment">// 这意味着这个函数必须在当前的栈帧中运行，不能增加栈的大小。</span><br>    <span class="hljs-comment">// 如果这个函数需要更多的栈空间，那么它将会导致栈溢出。</span><br><span class="hljs-keyword">if</span> timediv(<span class="hljs-number">12345</span>*<span class="hljs-number">1000000000</span>+<span class="hljs-number">54321</span>, <span class="hljs-number">1000000000</span>, &amp;e) != <span class="hljs-number">12345</span> || e != <span class="hljs-number">54321</span> &#123;<br>throw(<span class="hljs-string">&quot;bad timediv&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// CAS 操作检查</span><br><span class="hljs-keyword">var</span> z <span class="hljs-type">uint32</span><br>z = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> !atomic.Cas(&amp;z, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &#123;<br>throw(<span class="hljs-string">&quot;cas1&quot;</span>)<br>&#125;<br>...<br>    <span class="hljs-comment">// 检查 atomic 原子操作</span><br>m = [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br>atomic.Or8(&amp;m[<span class="hljs-number">1</span>], <span class="hljs-number">0xf0</span>)<br><span class="hljs-keyword">if</span> m[<span class="hljs-number">0</span>] != <span class="hljs-number">1</span> || m[<span class="hljs-number">1</span>] != <span class="hljs-number">0xf1</span> || m[<span class="hljs-number">2</span>] != <span class="hljs-number">1</span> || m[<span class="hljs-number">3</span>] != <span class="hljs-number">1</span> &#123;<br>throw(<span class="hljs-string">&quot;atomicor8&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 测试浮点数 NaN（Not a Number）的行为</span><br>*(*<span class="hljs-type">uint64</span>)(unsafe.Pointer(&amp;j)) = ^<span class="hljs-type">uint64</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> j == j &#123;<br>throw(<span class="hljs-string">&quot;float64nan&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> !(j != j) &#123;<br>throw(<span class="hljs-string">&quot;float64nan1&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 测试 64 位原子操作</span><br>testAtomic64()<br>    <span class="hljs-comment">// 检查栈大小是否是 2 的 n 次幂</span><br><span class="hljs-keyword">if</span> fixedStack != round2(fixedStack) &#123;<br>throw(<span class="hljs-string">&quot;FixedStack is not power-of-2&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 上报编代码的运行时检查中是否有异常</span><br><span class="hljs-keyword">if</span> !checkASM() &#123;<br>throw(<span class="hljs-string">&quot;assembly checks failed&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上：<code>runtime·check</code> 主要是做一些运行时的检查。</p><ol type="1"><li>使用 <code>unsafe.Sizeof</code>函数检查各种类型的变量的大小是否符合预期。</li><li>使用 <code>unsafe.Offsetof</code>函数检查结构体中字段的偏移量是否符合预期。</li><li>测试 <code>timediv</code> 函数检查在 32 位机器上进行 64位除法运算的结果是否符合预期。</li><li>使用 <code>atomic.Cas</code> 函数（Compare andSwap）进行原子比较和交换测试。</li><li>使用 <code>atomic.Or8</code> 和 <code>atomic.And8</code>函数进行原子位操作测试。</li><li>测试浮点数 NaN（Not a Number）的行为。</li><li>调用 <code>testAtomic64</code> 函数测试 64 位的原子操作。</li><li>检查 <code>fixedStack</code> 栈大小是否是 2 的幂。</li><li>调用 <code>checkASM</code>函数检查汇编代码检查运行时中是否有异常。</li></ol><h2 id="runtimeargs">runtime·args</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> runtime<br><br><span class="hljs-keyword">var</span> (<br>argc <span class="hljs-type">int32</span><br>argv **<span class="hljs-type">byte</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">args</span><span class="hljs-params">(c <span class="hljs-type">int32</span>, v **<span class="hljs-type">byte</span>)</span></span> &#123;<br>argc = c<br>argv = v<br>sysargs(c, v)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数比较简单，就是将命令行参数拷贝到 <code>runtime</code>包下的全局变量 <code>argc</code> 和 <code>argv</code> 上。后面在<code>shcedinit()</code> 函数中会调用 <code>goargs()</code> 来遍历 argv将参数复制到 slice 上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goargs</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> GOOS == <span class="hljs-string">&quot;windows&quot;</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>argslice = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, argc)<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">int32</span>(<span class="hljs-number">0</span>); i &lt; argc; i++ &#123;<br>argslice[i] = gostringnocopy(argv_index(argv, i))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runtimeosinit">runtime·osinit</h2><p>这里函数主要是初始化操作系统特点的设置，可以看到这里针对不同操作系统都做了实现：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231209131939116.png"alt="osinit" /><figcaption aria-hidden="true">osinit</figcaption></figure><p>这里我们以 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/os_windows.go">os_windows.go</a>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">osinit</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 获取 asmstdcall 函数的地址，并将其转换为一个不安全的指针。</span><br>    <span class="hljs-comment">// 这通常在需要直接操作内存或进行系统调用的时候使用。</span><br>asmstdcallAddr = unsafe.Pointer(abi.FuncPCABI0(asmstdcall))<br><br>    <span class="hljs-comment">// 加载一些可选的系统调用。</span><br>loadOptionalSyscalls()<br><br>    <span class="hljs-comment">// 阻止显示错误对话框。这可能是为了防止在出现错误时打断用户。</span><br>preventErrorDialogs()<br><br>    <span class="hljs-comment">// 初始化异常处理器，用于处理运行时发生的异常。</span><br>initExceptionHandler()<br><br>    <span class="hljs-comment">// 初始化高分辨率计时器，用于精确的时间测量。</span><br>initHighResTimer()<br>timeBeginPeriodRetValue = osRelax(<span class="hljs-literal">false</span>)<br><br>    <span class="hljs-comment">// 初始化系统目录</span><br>initSysDirectory()<br>    <br>    <span class="hljs-comment">// 启用长路径支持。</span><br>    <span class="hljs-comment">// 在 Windows 中，路径的长度通常限制为 260 个字符。启用长路径支持可以突破这个限制。</span><br>initLongPathSupport()<br><br>    <span class="hljs-comment">// 码获取处理器的数量并将其赋给 ncpu。</span><br>    ncpu = getproccount()<br><br>    <span class="hljs-comment">// 获取内存页的大小并将其赋给 physPageSize，为了后面进行内存管理。</span><br>physPageSize = getPageSize()<br><br>    <span class="hljs-comment">// 调用 SetProcessPriorityBoost 函数，禁用动态优先级提升。</span><br>    <span class="hljs-comment">// 在 Windows 中，动态优先级提升是一种机制，可以根据线程的类型和行为自动调整其优先级。</span><br>    <span class="hljs-comment">// 但在 Go 的环境中，所有的线程都是等价的，都可能进行 GUI、IO、计算等各种操作，</span><br>    <span class="hljs-comment">// 所以动态优先级提升可能会带来问题，因此这里选择禁用它。</span><br>stdcall2(_SetProcessPriorityBoost, currentProcess, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runtimeschedinit">runtime·schedinit ★</h2><p>这个函数就非常重要了，从名字就可以看出来，这是 Go语言调度器的初始化过程。这个函数位于：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">runtime/proc.go</a>。</p><p>我们可以先来看看 <code>schedinit()</code> 的函数注释，这里也透露了 Go语言程序的启动流程的核心顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The bootstrap sequence is:启动流程顺序：</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//call osinit  1. 调用 osinit</span><br><span class="hljs-comment">//call schedinit2. 调用 schedinit</span><br><span class="hljs-comment">//make &amp; queue new G3. 创建一个协程 G</span><br><span class="hljs-comment">//call runtime·mstart4. 调用 mstart</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The new G calls runtime·main. 5. G 执行 runtime.main</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedinit</span><span class="hljs-params">()</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>接下来我们详细来看看 <code>schedinit()</code> 都做了些什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">schedinit</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 初始化各种锁，其中 lockRankXXX 指定锁的级别。</span><br>lockInit(&amp;sched.lock, lockRankSched)<br>lockInit(&amp;sched.sysmonlock, lockRankSysmon)<br>lockInit(&amp;sched.deferlock, lockRankDefer)<br>lockInit(&amp;sched.sudoglock, lockRankSudog)<br>lockInit(&amp;deadlock, lockRankDeadlock)<br>lockInit(&amp;paniclk, lockRankPanic)<br>lockInit(&amp;allglock, lockRankAllg)<br>lockInit(&amp;allpLock, lockRankAllp)<br>lockInit(&amp;reflectOffs.lock, lockRankReflectOffs)<br>lockInit(&amp;finlock, lockRankFin)<br>lockInit(&amp;cpuprof.lock, lockRankCpuprof)<br>traceLockInit()<br>lockInit(&amp;memstats.heapStats.noPLock, lockRankLeafRank)<br><br><span class="hljs-comment">// 如果启用了竞态检测，则初始化竞态检测器，</span><br>    <span class="hljs-comment">// 即我们使用 -race 的时候会执行这里。</span><br>gp := getg()<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>gp.racectx, raceprocctx0 = raceinit()<br>&#125;<br><br>    <span class="hljs-comment">// 限制 M 的数量，即线程的数量。</span><br>    <span class="hljs-comment">// maxmcount    int32    // maximum number of m&#x27;s allowed (or die)</span><br>sched.maxmcount = <span class="hljs-number">10000</span><br><br><span class="hljs-comment">// 将调度器设置为初始暂停状态，在必要的初始化完成之前不调度任何协程。</span><br>worldStopped()<br><br>    <span class="hljs-comment">// 进行一系列的系统初始化（内存管理、CPU 设置、栈、算法等）</span><br>moduledataverify()<br>stackinit()<br>mallocinit()<br>godebug := getGodebugEarly()<br>initPageTrace(godebug) <span class="hljs-comment">// must run after mallocinit but before anything allocates</span><br>cpuinit(godebug)       <span class="hljs-comment">// must run before alginit</span><br>alginit()              <span class="hljs-comment">// maps, hash, fastrand must not be used before this call</span><br>fastrandinit()         <span class="hljs-comment">// must run before mcommoninit</span><br>mcommoninit(gp.m, <span class="hljs-number">-1</span>)<br>modulesinit()   <span class="hljs-comment">// provides activeModules</span><br>typelinksinit() <span class="hljs-comment">// uses maps, activeModules</span><br>itabsinit()     <span class="hljs-comment">// uses activeModules</span><br>stkobjinit()    <span class="hljs-comment">// must run before GC starts</span><br><br>    <span class="hljs-comment">// 设置和保存当前 M 的信号掩码</span><br>sigsave(&amp;gp.m.sigmask)<br>initSigmask = gp.m.sigmask<br><br>    <span class="hljs-comment">// 解析程序参数和环境变量</span><br>goargs()<br>goenvs()<br>secure()<br>parsedebugvars()<br>    <br>    <span class="hljs-comment">// 初始化垃圾回收器</span><br>gcinit()<br><br><span class="hljs-comment">// 如果设置了 disableMemoryProfiling，即禁用内存分析，</span><br>    <span class="hljs-comment">// 则将 MemProfileRate 置为 0，关闭内存分析。</span><br><span class="hljs-keyword">if</span> disableMemoryProfiling &#123;<br>MemProfileRate = <span class="hljs-number">0</span><br>&#125;<br><br>    <span class="hljs-comment">// 锁定调度器，处理环境变量 GOMAXPROCS，这是开发者可以设置的允许的最多的 P 的数量。</span><br>lock(&amp;sched.lock)<br>sched.lastpoll.Store(nanotime())<br>procs := ncpu<br><span class="hljs-keyword">if</span> n, ok := atoi32(gogetenv(<span class="hljs-string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="hljs-number">0</span> &#123;<br>procs = n<br>&#125;<br><span class="hljs-keyword">if</span> procresize(procs) != <span class="hljs-literal">nil</span> &#123;<br>throw(<span class="hljs-string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)<br>&#125;<br>unlock(&amp;sched.lock)<br><br><span class="hljs-comment">// 将调度器设置为开始状态。</span><br>worldStarted()<br><br>    <span class="hljs-comment">// 确保构建版本和模块信息被保留在最终的二进制文件中。</span><br><span class="hljs-keyword">if</span> buildVersion == <span class="hljs-string">&quot;&quot;</span> &#123;<br>buildVersion = <span class="hljs-string">&quot;unknown&quot;</span><br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(modinfo) == <span class="hljs-number">1</span> &#123;<br>modinfo = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：<code>schedinit</code> 是 Go语言运行时中的一个函数，负责初始化调度器及其相关组件，如锁、信号掩码、内存分配、以及其他系统级别的设置，确保并发执行环境的正确配置和高效运作。</p><p>具体过程如下：</p><ol type="1"><li><strong>锁初始化</strong>:<ul><li>函数开始时，通过 <code>lockInit</code> 调用初始化了多个锁。在 Go的调度器中，锁用于保护共享资源和调度数据结构，确保在多个线程或协程中的安全访问。每个锁都有一个特定的级别，这有助于防止死锁。</li></ul></li><li><strong>竞态检测器初始化</strong>:<ul><li>如果启用了竞态检测(<code>raceenabled</code>)，则初始化竞态上下文。这对于在开发阶段检测和避免竞态条件非常重要。</li></ul></li><li><strong>调度器设置</strong>:<ul><li><code>sched.maxmcount = 10000</code>设置调度器可以管理的最大线程（M）数目，这对于控制资源使用和性能调优很重要。</li><li><code>worldStopped()</code>将调度器设置为初始暂停状态，在必要的初始化完成之前不调度任何协程。</li></ul></li><li><strong>系统初始化</strong>:<ul><li>接下来调用一系列函数（如 <code>moduledataverify</code>,<code>mallocinit</code>, <code>cpuinit</code>, <code>alginit</code>等）来初始化内存管理、CPU设置、算法等，这些都是调度器正常工作的基础。</li></ul></li><li><strong>环境和调试变量设置</strong>:<ul><li>解析程序参数、环境变量、安全设置和调试变量。</li></ul></li><li><strong>垃圾收集器初始化</strong>:<ul><li><code>gcinit()</code> 初始化垃圾收集器，这是 Go运行时的关键组成部分，负责自动内存管理。</li></ul></li><li><strong>内存分析设置</strong>:<ul><li>根据 <code>disableMemoryProfiling</code>标志决定是否关闭内存分析功能。</li></ul></li><li><strong>处理器数量设置和调度器锁</strong>:<ul><li>锁定调度器来安全地基于环境变量 <code>GOMAXPROCS</code>设置处理器（<code>procs</code>）数量。</li><li>使用 <code>procresize</code>函数根据处理器数量调整调度器的内部结构。</li></ul></li><li><strong>最终步骤和错误检查</strong>:<ul><li>调用 <code>worldStarted()</code>表示调度器已准备好开始调度协程。</li><li>检查和设置构建版本和模块信息，保证这些信息在最终的二进制文件中。</li></ul></li></ol><p>这里有几个地方比较有趣，我们来做一下简单的了解。（可跳过）</p><h3 id="初始化锁-lockinitmutex-rank">初始化锁 lockInit(mutex, rank)</h3><p>我们知道 <code>lockInit(mutex,rank)</code> 是用来初始化锁的，第 2个参数 <code>rank</code> 便是锁的等级。如果这个时候你链接到<code>lcokInit</code> 实现的地方，你会发现默认会跳到 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/lockrank_off.go">lockrank_off.go</a>，而且你会发现，它的实现是空的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:build !goexperiment.staticlockranking</span><br><br><span class="hljs-keyword">package</span> runtime<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lockInit</span><span class="hljs-params">(l *mutex, rank lockRank)</span></span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实 <code>lockInit</code> 还有另外一个实现，在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/lockrank_on.go">lockrank_on.go</a>文件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:build goexperiment.staticlockranking</span><br><br><span class="hljs-keyword">package</span> runtime<br><br><span class="hljs-keyword">const</span> staticLockRanking = <span class="hljs-literal">true</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLockRank</span><span class="hljs-params">(l *mutex)</span></span> lockRank &#123;<br><span class="hljs-keyword">return</span> l.rank<br>&#125;<br></code></pre></td></tr></table></figure><p>这什么意思呢？通过文件名称我们其实就可以猜到了，<code>lockrank_off.go</code>是提供了无锁级别的锁，而 <code>lockrank_on.go</code>是提供了有锁级别的锁。至于应该采用哪一个，是通过 go build 中的<code>goexperiment.staticlockranking</code> 参数来控制的。</p><p>这里涉及一个概念，叫做锁排序（Lock Ranking）：</p><ul><li>锁排序是一种用于避免死锁的技术。在这种机制中，每个锁都被赋予一个等级（或称为“rank”），并且有规则确保锁的获取遵循这些等级的顺序。</li><li>通常，这意味着一个线程在获取等级较低的锁之前，必须先释放所有等级较高的锁。这样可以防止死锁，因为它避免了循环等待条件的发生。</li><li>Go 语言中锁的等级和顺序定义在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/lockrank.go">lockrank.go</a>文件中。</li></ul><p>锁排序的作用：</p><ul><li>在 Go的并发模型中，锁是同步共享资源访问的重要机制。<code>lockInit</code>函数在运行时初始化锁，为其分配等级，有助于维护程序的稳定性和性能。</li><li>锁排序功能的开启或关闭取决于是否需要额外的死锁检测。在开发和调试阶段，开启锁排序可以帮助发现死锁问题。然而，它可能引入额外的性能开销，因此在生产环境中可能会被关闭。</li></ul><p>最后我们来看一下 <code>schedinit()</code> 都初始化了哪些锁：</p><table><thead><tr class="header"><th>Lock</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>sched.lock</td><td>初始化调度器的主锁。这个锁用于控制对调度器的访问，保证调度过程的正确性。</td></tr><tr class="even"><td>sched.sysmonlock</td><td>系统监控锁，用于保护系统监控相关的数据结构。</td></tr><tr class="odd"><td>sched.deferlock</td><td>用于控制延迟执行函数列表的锁。</td></tr><tr class="even"><td>sched.sudoglock</td><td>sudog 是 Go 中表示等待通信的 goroutine 的结构。这个锁保护与 sudog相关的操作。</td></tr><tr class="odd"><td>deadlock</td><td>可能用于检测或防止死锁的锁。</td></tr><tr class="even"><td>paniclk</td><td>在处理 panic 时使用的锁。</td></tr><tr class="odd"><td>allglock</td><td>用于控制对所有 goroutine 列表的访问。</td></tr><tr class="even"><td>allpLock</td><td>控制对所有处理器（P）的访问。</td></tr><tr class="odd"><td>reflectOffs.lock</td><td>用于反射操作的锁。</td></tr><tr class="even"><td>finlock</td><td>管理终结器列表的锁。</td></tr><tr class="odd"><td>cpuprof.lock</td><td>用于 CPU 分析数据的锁。</td></tr><tr class="even"><td>traceLockInit()</td><td>专门用于追踪系统的锁初始化函数。</td></tr><tr class="odd"><td>memstats.heapStats.noPLock</td><td>这是一个特殊的锁，被标记为<code>lockRankLeafRank</code>，意味着它应该是锁层级中的最末端（leaf）。这样的锁应该只在非常短的关键部分中使用，以避免成为死锁的源头。</td></tr></tbody></table><h3 id="信号掩码-initsigmask">信号掩码 initSigmask</h3><p>这两行代码是在搞啥呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">sigsave(&amp;gp.m.sigmask)<br>initSigmask = gp.m.sigmask<br></code></pre></td></tr></table></figure><ul><li><code>sigmask</code> 的中文意思是 <code>信号掩码</code>。</li></ul><p>先看一下源码中 <code>initSigmast</code> 的注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Value to use for signal mask for newly created M&#x27;s.</span><br><span class="hljs-keyword">var</span> initSigmask sigset<br></code></pre></td></tr></table></figure><ul><li><code>initSigmask</code> 是一个变量，存储着用于新创建的M（Machine，即操作系统线程）的初始信号掩码。</li></ul><p>什么是信号掩码：</p><ul><li>信号掩码是操作系统中用于控制信号传递给进程或线程的一种机制。它允许进程或线程指定哪些信号可以被阻塞（暂时忽略）或允许。在多线程环境中，这个机制尤其重要，因为它帮助确保线程安全地处理信号。</li></ul><p>信号掩码的作用：</p><ul><li>信号掩码定义了一组信号，这些信号在特定时间内不会传递给进程或线程，即使这些信号发生了也会被系统挂起。这允许进程或线程在一个稳定的状态下运行，不被特定信号中断。</li><li>这种机制对于处理那些可能在关键操作期间导致不稳定状态的信号特别重要。</li></ul><p>信号掩码的重要性：</p><ul><li>在多线程程序中，不同的线程可能需要响应不同的信号或以不同方式处理相同的信号。通过为每个线程设置适当的信号掩码，可以确保线程只处理对它们来说重要的信号。</li><li>这有助于防止线程在执行关键代码时被不相关的信号打断。</li></ul><p><strong>sigsave(&amp;gp.m.sigmask)</strong>：</p><ul><li><code>sigsave(&amp;gp.m.sigmask)</code> 这个调用是在保存当前 M的信号掩码。<code>gp</code> 指的是当前的 goroutine，<code>gp.m</code>是该 goroutine 正在运行的 M（操作系统线程）。</li><li><code>sigsave</code> 函数的作用是将 <code>gp.m</code>的当前信号掩码保存到提供的地址（在这里是<code>&amp;gp.m.sigmask</code>）。这对于恢复线程的信号掩码到一个已知状态是非常有用的。</li></ul><p><strong>initSigmask = gp.m.sigmask</strong>：</p><ul><li>这一行将 <code>gp.m</code> 的信号掩码赋值给<code>initSigmask</code>。这意味着 <code>initSigmask</code>现在保存了当前 M 的信号掩码，这个掩码将被用作新创建的 M的初始信号掩码。</li><li>这是一个重要的步骤，因为它确保了所有新创建的 M 都将具有与当前 M相同的信号处理行为。</li><li>这意味着所有新线程都会以一致的信号掩码启动，这有助于避免由于不同线程处理信号的不一致性导致的问题。</li></ul><p>总体来说，Go语言在其运行时中这样处理信号掩码，是为了确保在并发执行和线程调度中能够安全、一致地处理信号，这对于维护高效和稳定的运行时环境至关重要。</p><h3 id="初始化垃圾回收器-gcinit">初始化垃圾回收器 gcinit()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcinit</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 检查 workbuf 结构体的大小是否等于预期的 _WorkbufSize。</span><br>    <span class="hljs-comment">// 如果不是，抛出异常。这是为了确保 workbuf 的大小是最优的，</span><br>    <span class="hljs-comment">// workbuf 用于垃圾回收过程中的内部工作。</span><br>    <span class="hljs-keyword">if</span> unsafe.Sizeof(workbuf&#123;&#125;) != _WorkbufSize &#123;<br>       throw(<span class="hljs-string">&quot;size of Workbuf is suboptimal&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 第一个垃圾回收周期不进行扫描操作。</span><br>    <span class="hljs-comment">// 在 Go 的垃圾回收过程中，扫描是回收前清理内存的重要步骤。</span><br>    sweep.active.state.Store(sweepDrainedMask)<br><br>    <span class="hljs-comment">// 使用环境变量 GOGC 和 GOMEMLIMIT 来设置初始的垃圾回收百分比和内存限制。</span><br>    gcController.init(readGOGC(), readGOMEMLIMIT())<br><br>    <span class="hljs-comment">// 初始化用于控制垃圾回收工作流程的信号量。</span><br>    <span class="hljs-comment">// 这些信号量用于同步垃圾回收过程中的不同阶段。</span><br>    work.startSema = <span class="hljs-number">1</span><br>    work.markDoneSema = <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment">// 初始化了用于垃圾回收过程中的各种锁。</span><br>    <span class="hljs-comment">// 这些锁用于保护垃圾回收相关数据结构的并发访问，确保垃圾回收过程的线程安全。</span><br>    lockInit(&amp;work.sweepWaiters.lock, lockRankSweepWaiters)<br>    lockInit(&amp;work.assistQueue.lock, lockRankAssistQueue)<br>    lockInit(&amp;work.wbufSpans.lock, lockRankWbufSpans)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *gcControllerState)</span></span> init(gcPercent <span class="hljs-type">int32</span>, memoryLimit <span class="hljs-type">int64</span>) &#123;<br>    <span class="hljs-comment">// 设置 heapMinimum 为默认的最小堆大小。</span><br>    <span class="hljs-comment">// 这是垃圾回收器考虑启动新回收周期前的最小堆内存大小。</span><br>c.heapMinimum = defaultHeapMinimum<br>    <br>    <span class="hljs-comment">// 将 triggered 设置为 uint64 的最大值。</span><br>    <span class="hljs-comment">// 这个字段用于表示触发垃圾回收的内存阈值，</span><br>    <span class="hljs-comment">// 这里的设置意味着在初始状态下不会自动触发垃圾回收</span><br>c.triggered = ^<span class="hljs-type">uint64</span>(<span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-comment">// 设置垃圾回收的百分比阈值。</span><br>    <span class="hljs-comment">// gcPercent 参数表示触发垃圾回收的内存增长百分比。</span><br>    <span class="hljs-comment">// 这个设置控制了堆内存增长到多少百分比时会触发垃圾回收。</span><br>c.setGCPercent(gcPercent)<br>    <br>    <span class="hljs-comment">// 设置内存限制。</span><br>    <span class="hljs-comment">// memoryLimit 参数可能表示堆内存的最大限制，</span><br>    <span class="hljs-comment">// 用于控制垃圾回收器在内存使用方面的行为。</span><br>c.setMemoryLimit(memoryLimit)<br>    <br>    <span class="hljs-comment">// 提交垃圾回收控制器的当前设置，并指示第一次垃圾回收周期没有扫描（sweep）阶段。</span><br>    <span class="hljs-comment">// 在 Go 的垃圾回收中，扫描是回收周期的一部分，这里指明在第一次垃圾回收时跳过扫描阶段。</span><br>c.commit(<span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runtimenewproc">runtime·newproc ★</h2><p>初始化完调度器后，就进入到创建 g0的阶段了，我们需要一个协程来运行程序的入口：<code>runtime.main</code>。</p><p><code>newproc()</code> 的作用如注释所说：<strong>创建一个新的goroutine 来执行 <code>fn</code>，并将它放入等待运行的 g队列中。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create a new g running fn.</span><br><span class="hljs-comment">// Put it on the queue of g&#x27;s waiting to run.</span><br><span class="hljs-comment">// The compiler turns a go statement into a call to this.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc</span><span class="hljs-params">(fn *funcval)</span></span> &#123;<br>gp := getg()<span class="hljs-comment">// 获取当前协程</span><br>pc := getcallerpc()<span class="hljs-comment">// 获取当前程序计数器</span><br>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 在系统栈上执行新 goroutine 的创建</span><br>newg := newproc1(fn, gp, pc)<span class="hljs-comment">// 创建新 goroutine</span><br><br>pp := getg().m.p.ptr()<span class="hljs-comment">// 获取当前 M 绑定的 P</span><br>runqput(pp, newg, <span class="hljs-literal">true</span>)<span class="hljs-comment">// 将新创建的 goroutine 放入 P 的本地队列中</span><br><br><span class="hljs-keyword">if</span> mainStarted &#123;<br>wakep()<span class="hljs-comment">// 如果主程序已经启动，则唤醒或启动一个 M，以确保新的 goroutine 有机会被执行</span><br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>重点来看一下 <code>newproc1()</code> 和 <code>runqput()</code>。</p><h3 id="创建协程-newproc1">创建协程 newproc1()</h3><p>这段代码的主要作用是创建一个新的 goroutine并设置其初始状态，以便它可以被调度器安排运行。它处理了从分配 goroutine的内存到设置其栈空间和调度信息等一系列步骤。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个新的 goroutine，状态为 _Grunnable，从函数 fn 开始执行。</span><br><span class="hljs-comment">// callerpc 是创建此 goroutine 的 go 语句的地址。</span><br><span class="hljs-comment">// 调用者负责将新的 g 添加到调度器中。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">(fn *funcval, callergp *g, callerpc <span class="hljs-type">uintptr</span>)</span></span> *g &#123;<br><span class="hljs-keyword">if</span> fn == <span class="hljs-literal">nil</span> &#123;<br>fatal(<span class="hljs-string">&quot;go of nil func value&quot;</span>) <span class="hljs-comment">// 如果 fn 是 nil，抛出致命错误</span><br>&#125;<br><br>mp := acquirem() <span class="hljs-comment">// 禁用抢占，因为我们在局部变量中持有 M 和 P</span><br>pp := mp.p.ptr()<br>newg := gfget(pp) <span class="hljs-comment">// 尝试从 P 的空闲列表中获取一个 g</span><br><span class="hljs-keyword">if</span> newg == <span class="hljs-literal">nil</span> &#123;<br>newg = malg(stackMin) <span class="hljs-comment">// 如果没有空闲的 g，创建一个新的</span><br>casgstatus(newg, _Gidle, _Gdead) <span class="hljs-comment">// 将 g 的状态从 _Gidle 改为 _Gdead</span><br>allgadd(newg) <span class="hljs-comment">// 将新的 g 添加到所有 goroutine 的列表中</span><br>&#125;<br><span class="hljs-keyword">if</span> newg.stack.hi == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;newproc1: newg missing stack&quot;</span>) <span class="hljs-comment">// 如果新的 g 没有栈，抛出异常</span><br>&#125;<br><br><span class="hljs-keyword">if</span> readgstatus(newg) != _Gdead &#123;<br>throw(<span class="hljs-string">&quot;newproc1: new g is not Gdead&quot;</span>) <span class="hljs-comment">// 确保新的 g 的状态为 _Gdead</span><br>&#125;<br><br>totalSize := <span class="hljs-type">uintptr</span>(<span class="hljs-number">4</span>*goarch.PtrSize + sys.MinFrameSize) <span class="hljs-comment">// 计算额外的栈空间大小</span><br>totalSize = alignUp(totalSize, sys.StackAlign) <span class="hljs-comment">// 栈空间对齐</span><br>sp := newg.stack.hi - totalSize <span class="hljs-comment">// 设置栈指针</span><br>spArg := sp<br><span class="hljs-keyword">if</span> usesLR &#123;<br>*(*<span class="hljs-type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="hljs-number">0</span> <span class="hljs-comment">// 针对 LR 架构，设置调用者的 LR</span><br>prepGoExitFrame(sp)<br>spArg += sys.MinFrameSize<br>&#125;<br><br>memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched)) <span class="hljs-comment">// 清除调度器的内存</span><br>newg.sched.sp = sp <span class="hljs-comment">// 设置调度器的栈指针</span><br>newg.stktopsp = sp <span class="hljs-comment">// 设置栈顶指针</span><br><span class="hljs-comment">// 设置调度器的程序计数器，+PCQuantum 使得前一个指令在同一函数中</span><br>newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum <br>newg.sched.g = guintptr(unsafe.Pointer(newg)) <span class="hljs-comment">// 设置调度器的 g 指针</span><br>gostartcallfn(&amp;newg.sched, fn) <span class="hljs-comment">// 启动新的 g 执行函数 fn</span><br>newg.parentGoid = callergp.goid <span class="hljs-comment">// 设置新 g 的父 goroutine ID</span><br>newg.gopc = callerpc <span class="hljs-comment">// 设置新 g 的创建位置</span><br>newg.ancestors = saveAncestors(callergp) <span class="hljs-comment">// 保存祖先信息</span><br>newg.startpc = fn.fn <span class="hljs-comment">// 设置新 g 的起始函数地址</span><br><span class="hljs-keyword">if</span> isSystemGoroutine(newg, <span class="hljs-literal">false</span>) &#123;<br>sched.ngsys.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 如果是系统 goroutine，增加计数</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> mp.curg != <span class="hljs-literal">nil</span> &#123;<br>newg.labels = mp.curg.labels <span class="hljs-comment">// 只有用户 goroutines 继承 pprof 标签</span><br>&#125;<br><span class="hljs-keyword">if</span> goroutineProfile.active &#123;<br>newg.goroutineProfiled.Store(goroutineProfileSatisfied) <span class="hljs-comment">// 标记不需要纳入 goroutine 分析</span><br>&#125;<br>&#125;<br>newg.trackingSeq = <span class="hljs-type">uint8</span>(fastrand()) <span class="hljs-comment">// 设置追踪序列号</span><br><span class="hljs-keyword">if</span> newg.trackingSeq%gTrackingPeriod == <span class="hljs-number">0</span> &#123;<br>newg.tracking = <span class="hljs-literal">true</span> <span class="hljs-comment">// 是否启用追踪</span><br>&#125;<br>casgstatus(newg, _Gdead, _Grunnable) <span class="hljs-comment">// 将新 g 的状态从 _Gdead 改为 _Grunnable</span><br>gcController.addScannableStack(pp, <span class="hljs-type">int64</span>(newg.stack.hi-newg.stack.lo)) <span class="hljs-comment">// 将新 g 的栈添加到可扫描栈列表</span><br><br><span class="hljs-keyword">if</span> pp.goidcache == pp.goidcacheend &#123;<br>pp.goidcache = sched.goidgen.Add(_GoidCacheBatch) <span class="hljs-comment">// 分配新的 goroutine ID</span><br>pp.goidcache -= _GoidCacheBatch - <span class="hljs-number">1</span><br>pp.goidcacheend = pp.goidcache + _GoidCacheBatch<br>&#125;<br>newg.goid = pp.goidcache <span class="hljs-comment">// 设置新 g 的 ID</span><br>pp.goidcache++<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>newg.racectx = racegostart(callerpc) <span class="hljs-comment">// 设置竞态检测上下文</span><br>newg.raceignore = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> newg.labels != <span class="hljs-literal">nil</span> &#123;<br>racereleasemergeg(newg, unsafe.Pointer(&amp;labelSync)) <span class="hljs-comment">// 同步竞态检测和信号处理</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> traceEnabled() &#123;<br>traceGoCreate(newg, newg.startpc) <span class="hljs-comment">// 记录追踪信息</span><br>&#125;<br>releasem(mp) <span class="hljs-comment">// 释放当前 M</span><br><br><span class="hljs-keyword">return</span> newg <span class="hljs-comment">// 返回新创建的 goroutine</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231210231623561.png"alt="newproc1() 函数概述" /><figcaption aria-hidden="true">newproc1() 函数概述</figcaption></figure><p>有几个地方比较有趣，我们可以来研究一下。</p><h4 id="获取-g">获取 g</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The minimum size of stack used by Go code</span><br>stackMin = <span class="hljs-number">2048</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newproc1</span><span class="hljs-params">()</span></span> &#123;<br>    ...<br>    newg := gfget(pp) <span class="hljs-comment">// 尝试从 P 的空闲列表中获取一个 g</span><br>    <span class="hljs-keyword">if</span> newg == <span class="hljs-literal">nil</span> &#123;<br>        newg = malg(stackMin) <span class="hljs-comment">// 如果没有空闲的 g，创建一个新的</span><br>        casgstatus(newg, _Gidle, _Gdead) <span class="hljs-comment">// 将 g 的状态从 _Gidle 改为 _Gdead</span><br>        allgadd(newg) <span class="hljs-comment">// 将新的 g 添加到所有 goroutine 的列表中</span><br>    &#125;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里可以看出，Go 语言每个新创建的协程分配的默认大小就是<code>stackMin</code>，即 <code>2KB</code>。</p><p>其实 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/stack.go">statck.go</a>还定义了另外一个字段，即栈最大为 <code>2GB</code>，所以我们可以知道，Go协程栈大小 <code>[2KB, 2GB]</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> maxstacksize <span class="hljs-type">uintptr</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span> <span class="hljs-comment">// enough until runtime.main sets it for real</span><br></code></pre></td></tr></table></figure><p>另外我们可以看出来，Go 语言会尽可能重用现有的空闲goroutine，以减少内存分配的开销，提供创建新 goroutine 的效率。</p><p>重用的具体逻辑在 <code>gfget(pp)</code> 中，这个函数的作用是从与当前M 绑定的 P 的空闲列表中获取一个空闲的g，如果没有，则尝试从全局空闲列表中获取 g。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get from gfree list.</span><br><span class="hljs-comment">// If local list is empty, grab a batch from global list.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gfget</span><span class="hljs-params">(pp *p)</span></span> *g &#123;<br>retry:<br>    <span class="hljs-comment">// 如果当前 P 的空闲队列为空，并且全局空闲队列中有可用的 goroutine，则进行下列操作。</span><br><span class="hljs-keyword">if</span> pp.gFree.empty() &amp;&amp; (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) &#123;<br>        <span class="hljs-comment">// 枷锁全局空闲列表</span><br>lock(&amp;sched.gFree.lock)<br><span class="hljs-comment">// 将最多 32 个空闲的 g 从全局列表中移动到当前 P 的空闲列表</span><br><span class="hljs-keyword">for</span> pp.gFree.n &lt; <span class="hljs-number">32</span> &#123;<br><span class="hljs-comment">// 优先选择有栈的 g</span><br>gp := sched.gFree.stack.pop()<br><span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-comment">// 实在没有栈，也可以接受</span><br>gp = sched.gFree.noStack.pop()<br><span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>sched.gFree.n--<br>pp.gFree.push(gp)<br>pp.gFree.n++<br>&#125;<br>unlock(&amp;sched.gFree.lock)<br>        <span class="hljs-comment">// 一直尝试，知道 P 有空闲 g，或者全局列表也没有空闲 g 了，就退出 for 循环，进行下面的操作。</span><br><span class="hljs-keyword">goto</span> retry<br>&#125;<br>    <br>    <span class="hljs-comment">// 从 P 的空闲列表中取出一个 g</span><br>gp := pp.gFree.pop()<br><span class="hljs-keyword">if</span> gp == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>pp.gFree.n--<br>    <br>    <span class="hljs-comment">// 检查获取到的 g 是否有一个有效的栈，如果栈不符合预期的大小，则释放旧栈</span><br><span class="hljs-keyword">if</span> gp.stack.lo != <span class="hljs-number">0</span> &amp;&amp; gp.stack.hi-gp.stack.lo != <span class="hljs-type">uintptr</span>(startingStackSize) &#123;<br>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>stackfree(gp.stack)<br>gp.stack.lo = <span class="hljs-number">0</span><br>gp.stack.hi = <span class="hljs-number">0</span><br>gp.stackguard0 = <span class="hljs-number">0</span><br>&#125;)<br>&#125;<br>    <span class="hljs-comment">// 如果 g 没有有效的栈，或者刚刚被释放了，则分配新栈给 g</span><br><span class="hljs-keyword">if</span> gp.stack.lo == <span class="hljs-number">0</span> &#123;<br>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>gp.stack = stackalloc(startingStackSize)<br>&#125;)<br>gp.stackguard0 = gp.stack.lo + stackGuard<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racemalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &#123;<br>msanmalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)<br>&#125;<br><span class="hljs-keyword">if</span> asanenabled &#123;<br>asanunpoison(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> gp<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>startingStackSize</code> 表示新创建的 goroutine开始时的栈大小。它被初始化为 <code>fixedStack</code>的值。<code>startingStackSize</code>在每次垃圾回收（GC）后可能会更新，以反映在 GC过程中扫描的栈的平均大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> startingStackSize <span class="hljs-type">uint32</span> = fixedStack<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcComputeStartingStackSize</span><span class="hljs-params">()</span></span> &#123;<br>...<br>    <span class="hljs-comment">// 求出栈平均大小</span><br>avg := scannedStackSize/scannedStacks + stackGuard<br><br><span class="hljs-keyword">if</span> avg &gt; <span class="hljs-type">uint64</span>(maxstacksize) &#123;<br>avg = <span class="hljs-type">uint64</span>(maxstacksize)<br>&#125;<br><span class="hljs-keyword">if</span> avg &lt; fixedStack &#123;<br>avg = fixedStack<br>&#125;<br>    <span class="hljs-comment">// 更新 startingStackSize</span><br>startingStackSize = <span class="hljs-type">uint32</span>(round2(<span class="hljs-type">int32</span>(avg)))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="初始化协程栈">初始化协程栈</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">totalSize := <span class="hljs-type">uintptr</span>(<span class="hljs-number">4</span>*goarch.PtrSize + sys.MinFrameSize) <span class="hljs-comment">// 计算额外的栈空间大小</span><br>totalSize = alignUp(totalSize, sys.StackAlign) <span class="hljs-comment">// 栈空间对齐</span><br>sp := newg.stack.hi - totalSize <span class="hljs-comment">// 设置栈指针</span><br>spArg := sp<br><span class="hljs-keyword">if</span> usesLR &#123;<br>    *(*<span class="hljs-type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="hljs-number">0</span> <span class="hljs-comment">// 针对 LR 架构，设置调用者的 LR</span><br>    prepGoExitFrame(sp)<br>    spArg += sys.MinFrameSize<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1. 计算额外的栈空间大小</strong>:</p><p><code>totalSize := uintptr(4*goarch.PtrSize + sys.MinFrameSize)</code>这行代码计算新 goroutine 需要的额外栈空间大小。</p><p><code>4*goarch.PtrSize</code>是为了留出足够的空间来存储函数调用过程中的一些额外信息（例如返回地址、寄存器保存等）。</p><p><code>sys.MinFrameSize</code>：是系统为每个栈帧保留的最小空间，用于存储一些特定于架构的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MinFrameSize is the size of the system-reserved words at the bottom</span><br><span class="hljs-comment">// of a frame (just above the architectural stack pointer).</span><br><span class="hljs-comment">// It is zero on x86 and PtrSize on most non-x86 (LR-based) systems.</span><br><span class="hljs-comment">// On PowerPC it is larger, to cover three more reserved words:</span><br><span class="hljs-comment">// the compiler word, the link editor word, and the TOC save word.</span><br><span class="hljs-keyword">const</span> MinFrameSize = goarch.MinFrameSize<br></code></pre></td></tr></table></figure><p><code>goarch.PtrSize</code>：指针大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PtrSize is the size of a pointer in bytes - unsafe.Sizeof(uintptr(0)) but as an ideal constant.</span><br><span class="hljs-comment">// It is also the size of the machine&#x27;s native word size (that is, 4 on 32-bit systems, 8 on 64-bit).</span><br><span class="hljs-keyword">const</span> PtrSize = <span class="hljs-number">4</span> &lt;&lt; (^<span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">63</span>)<br></code></pre></td></tr></table></figure><p><strong>2. 栈空间对齐</strong>:</p><p><code>totalSize = alignUp(totalSize, sys.StackAlign)</code>:根据系统的栈对齐要求调整 <code>totalSize</code>的大小。栈对齐是为了确保栈上的数据按照硬件要求的边界对齐，这通常是为了提高访问效率或满足特定的硬件要求。</p><p><strong>3. 设置栈指针 (<code>sp</code>)</strong>:</p><p><code>sp := newg.stack.hi - totalSize</code>: 计算新 goroutine的栈顶指针。<code>newg.stack.hi</code> 是分配给这个 goroutine的栈的高地址（栈顶），从这里向下分配空间。通过从栈顶地址减去计算出的<code>totalSize</code>，设置新的栈顶位置。</p><p><strong>4. 处理链接寄存器（LR）架构</strong>:</p><p>在某些架构上（如ARM、PowerPC），函数调用的返回地址不是存储在栈上，而是存储在一个名为链接寄存器（LR）的特殊寄存器中。这几行代码检查是否在这种架构上运行(<code>usesLR</code>)。</p><ul><li>如果是，则在栈上的适当位置存储一个 0 值作为返回地址，并调用<code>prepGoExitFrame</code> 来准备 goroutine退出时的栈帧。这是为了模拟在非 LR 架构上的栈帧结构。</li><li><code>spArg</code>是一个辅助变量，用于记录参数传递时应该使用的栈地址。在 LR架构上，它需要根据 <code>sys.MinFrameSize</code>进行调整，以保证函数参数的正确位置。</li></ul><h3 id="放入队列-runqput">放入队列 runqput()</h3><p><code>runqput()</code> 负责将 goroutine (<code>gp</code>)放入到本地可运行队列或全局队列中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runqput 尝试将 g 放入当前的执行队列中</span><br><span class="hljs-comment">// 如果 next=false，则将 g 放在队列末尾，</span><br><span class="hljs-comment">// 如果 next=true，则将 g 放在 pp.runnext，即下一个要执行的 goroutine。</span><br><span class="hljs-comment">// 如果本地队列满了，则加入到全局队列。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqput</span><span class="hljs-params">(pp *p, gp *g, next <span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 如果启用了随机调度器 (randomizeScheduler)，</span><br>    <span class="hljs-comment">// 并且调用者指示将 goroutine 放入 runnext 位置 (next 为 true)，</span><br>    <span class="hljs-comment">// 则有 50% 的概率将 next 设置为 false，以随机地将 goroutine 放入队列尾部。</span><br><span class="hljs-keyword">if</span> randomizeScheduler &amp;&amp; next &amp;&amp; fastrandn(<span class="hljs-number">2</span>) == <span class="hljs-number">0</span> &#123;<br>next = <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">if</span> next &#123;<br>retryNext:<br>        <span class="hljs-comment">// 如果为 next，则尝试将 p 放入 pp.runnext 插槽</span><br>oldnext := pp.runnext<br><span class="hljs-keyword">if</span> !pp.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) &#123;<br><span class="hljs-keyword">goto</span> retryNext<br>&#125;<br>        <span class="hljs-comment">// 如果这个槽之前没有被占用，则直接返回</span><br><span class="hljs-keyword">if</span> oldnext == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>        <span class="hljs-comment">// 如果这个槽之前已经被占用了，则剔除旧 goroutine，</span><br>        <span class="hljs-comment">// 然后进行下面的逻辑，即将其放入常规的运行队列中</span><br>gp = oldnext.ptr()<br>&#125;<br><br>retry:<br>h := atomic.LoadAcq(&amp;pp.runqhead) <span class="hljs-comment">// 取出队列头部</span><br>t := pp.runqtail<span class="hljs-comment">// 取出队列尾部</span><br>    <span class="hljs-comment">// 如果还没满，则将 gp 放入本地队列中（可能是新 g，也可能是之前在 runnext 的 g</span><br><span class="hljs-keyword">if</span> t-h &lt; <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)) &#123;<br>pp.runq[t%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].set(gp)<br>atomic.StoreRel(&amp;pp.runqtail, t+<span class="hljs-number">1</span>) <span class="hljs-comment">// store-release, makes the item available for consumption</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">// 如果本地队列满了，则尝试将其放入全局队列中</span><br><span class="hljs-keyword">if</span> runqputslow(pp, gp, h, t) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">goto</span> retry<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>runqputslow()</code> 不仅会尝试将 <code>gp</code>放入全局队列中，还会尝试将本地队列的部分 g放入全局队列中，因为这个时候本地队列已经满了，放入全局队列中就有机会被其他P 所调度，减少饥饿。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Put g and a batch of work from local runnable queue on global queue.</span><br><span class="hljs-comment">// Executed only by the owner P.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runqputslow</span><span class="hljs-params">(pp *p, gp *g, h, t <span class="hljs-type">uint32</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <br>    <span class="hljs-comment">// 初始化一个数组 batch，大小为本地队列的一半，</span><br>    <span class="hljs-comment">// 它用来存储将要移动到全局队列的 goroutine。</span><br><span class="hljs-keyword">var</span> batch [<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]*g<br><br>n := t - h<br>n = n / <span class="hljs-number">2</span><br>    <span class="hljs-comment">// 只有本地队列满才这么操作</span><br><span class="hljs-keyword">if</span> n != <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq)/<span class="hljs-number">2</span>) &#123;<br>throw(<span class="hljs-string">&quot;runqputslow: queue is not full&quot;</span>)<br>&#125;<br>    <span class="hljs-comment">// 将本地队列一半的 g 复制到 batch 中</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i] = pp.runq[(h+i)%<span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(pp.runq))].ptr()<br>&#125;<br>    <span class="hljs-comment">// CAS 更新本地队列头指针，如果失败，则返回</span><br><span class="hljs-keyword">if</span> !atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123; <span class="hljs-comment">// cas-release, commits consume</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>    <span class="hljs-comment">// 将当前要调度的 gp 放入 batch 的末尾</span><br>batch[n] = gp<br><br>    <span class="hljs-comment">// 如果启动了随机调度器，则随机化 batch 数组</span><br><span class="hljs-keyword">if</span> randomizeScheduler &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">1</span>); i &lt;= n; i++ &#123;<br>j := fastrandn(i + <span class="hljs-number">1</span>)<br>batch[i], batch[j] = batch[j], batch[i]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 链接 goroutine，以便它们可以作为一个连续的队列被处理</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>); i &lt; n; i++ &#123;<br>batch[i].schedlink.set(batch[i+<span class="hljs-number">1</span>])<br>&#125;<br><span class="hljs-keyword">var</span> q gQueue<br>q.head.set(batch[<span class="hljs-number">0</span>])<br>q.tail.set(batch[n])<br><br><span class="hljs-comment">// 将 batch 放入全局队列中</span><br>lock(&amp;sched.lock)<br>globrunqputbatch(&amp;q, <span class="hljs-type">int32</span>(n+<span class="hljs-number">1</span>))<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231210231353833.png"alt="runqput() 函数概述" /><figcaption aria-hidden="true">runqput() 函数概述</figcaption></figure><h3 id="总结">总结</h3><p>到这里我们可以总结，<code>runtime·newproc</code>的核心功能就是初始化一个新的goroutine，并将其放入队列中进行调度。其中</p><ul><li><code>newproc1()</code> 会新建或复用空闲的goroutine，然后初始化其栈空间和调度信息；</li><li><code>runqput()</code> 会优先将 g放入本地队列中调度，如果本地队列满了，会连带本地队列中一半的 goroutine一起转移到全局队列中调度。</li></ul><h2 id="runtimemstart">runtime·mstart</h2><p>调度器 m0 和主协程 g0都初始化完毕了，这个时候就可以启动调度器来调度协程工作了。</p><p>我们找到 <code>mstart()</code> 函数的声明，位于：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// mstart is the entry-point for new Ms.</span><br><span class="hljs-comment">// It is written in assembly, uses ABI0, is marked TOPFRAME, and calls mstart0.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstart</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>可以看到，这里 <code>mstart()</code>是没用函数体的，通过注释我们可以知道这个函数的实现部分是用汇编实现的，Go编译器会在编译的时候往这个函数里面插入相关指令。另外注释也告诉我们，这里最终其实就是调用<code>mstart0()</code> 函数。我们找到相关的汇编代码，果然是如此：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">TEXT</span> runtime·mstart(<span class="hljs-built_in">SB</span>),NOSPLIT<span class="hljs-title">|TOPFRAME,$0</span><br><span class="hljs-title">CALLruntime·mstart0(SB)</span><br><span class="hljs-title">RET // not reached</span><br></code></pre></td></tr></table></figure><p><code>mstart0()</code> 就在 <code>mstart()</code> 的下面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstart0</span><span class="hljs-params">()</span></span> &#123;<br>gp := getg()<br>osStack := gp.stack.lo == <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> osStack &#123;<br><span class="hljs-comment">// Initialize stack bounds from system stack.</span><br><span class="hljs-comment">// Cgo may have left stack size in stack.hi.</span><br><span class="hljs-comment">// minit may update the stack bounds.</span><br>size := gp.stack.hi<br><span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> &#123;<br>size = <span class="hljs-number">8192</span> * sys.StackGuardMultiplier<br>&#125;<br>gp.stack.hi = <span class="hljs-type">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))<br>gp.stack.lo = gp.stack.hi - size + <span class="hljs-number">1024</span><br>&#125;<br><span class="hljs-comment">// Initialize stack guard so that we can start calling regular</span><br><span class="hljs-comment">// Go code.</span><br>gp.stackguard0 = gp.stack.lo + stackGuard<br><span class="hljs-comment">// This is the g0, so we can also call go:systemstack</span><br><span class="hljs-comment">// functions, which check stackguard1.</span><br>gp.stackguard1 = gp.stackguard0<br>mstart1()<br><span class="hljs-comment">// Exit this thread.</span><br><span class="hljs-keyword">if</span> mStackIsSystemAllocated() &#123;<br><span class="hljs-comment">// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate</span><br><span class="hljs-comment">// the stack, but put it in gp.stack before mstart,</span><br><span class="hljs-comment">// so the logic above hasn&#x27;t set osStack yet.</span><br>osStack = <span class="hljs-literal">true</span><br>&#125;<br>mexit(osStack)<br>&#125;<br></code></pre></td></tr></table></figure><p>简单过一下 <code>mstart0()</code> 后，我们会发现其实<code>mstart0()</code> 也不是关键，关键是 <code>mstart1()</code>。</p><p>我们先对 <code>mstart0()</code> 做一个简单的总结：它是 Go语言运行时中新M（操作系统线程）的入口点。这个函数负责初始化新线程的栈和一些其他设置，然后调用<code>mstart1</code> 来继续线程的初始化过程。</p><p>我们继续来看<code>mstart1()</code>，它用于进一步设置新线程并最终将控制权交给调度器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstart1</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 获取当前协程</span><br>gp := getg()<br>    <span class="hljs-comment">// 只有 g0 协程可以执行 mstart1()，即启动 m0。</span><br>    <span class="hljs-comment">// 每一个 M 都有一个特殊的 goroutine，其被称为 g0，它用于执行系统级任务。</span><br><span class="hljs-keyword">if</span> gp != gp.m.g0 &#123;<br>throw(<span class="hljs-string">&quot;bad runtime·mstart&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 设置 gp.sched 调度信息，以便 goroutine 能够在未来被正确调度。</span><br>gp.sched.g = guintptr(unsafe.Pointer(gp))<span class="hljs-comment">// goroutine 指针</span><br>gp.sched.pc = getcallerpc()<span class="hljs-comment">// 程序计数器</span><br>gp.sched.sp = getcallersp()<span class="hljs-comment">// 栈指针</span><br><br>    <span class="hljs-comment">// 初始化于汇编相关的设置。</span><br>asminit()<br>    <span class="hljs-comment">// 初始化当前 M 的线程局部存储和其他线程相关的数据。</span><br>minit()<br><br><span class="hljs-comment">// 如果是 m0，则安装信号处理器</span><br><span class="hljs-keyword">if</span> gp.m == &amp;m0 &#123;<br>mstartm0()<br>&#125;<br><br>    <span class="hljs-comment">// 如果 M 启动时配置了函数，则调用它</span><br><span class="hljs-keyword">if</span> fn := gp.m.mstartfn; fn != <span class="hljs-literal">nil</span> &#123;<br>fn()<br>&#125;<br><br>    <span class="hljs-comment">// 如果当前现场不是 m0（主线程），则获取一个 P，准备开始执行 goroutine</span><br><span class="hljs-keyword">if</span> gp.m != &amp;m0 &#123;<br>acquirep(gp.m.nextp.ptr())<br>gp.m.nextp = <span class="hljs-number">0</span><br>&#125;<br>    <span class="hljs-comment">// 调用 schedule() 将控制权交给调度器，开始执行 goroutine</span><br>schedule()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mstartm0</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> (iscgo || GOOS == <span class="hljs-string">&quot;windows&quot;</span>) &amp;&amp; !cgoHasExtraM &#123;<br>cgoHasExtraM = <span class="hljs-literal">true</span><br>newextram()<br>&#125;<br>    <span class="hljs-comment">// 安装信号处理器</span><br>initsig(<span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>schedule()</code> 是调度器的具体调度过程，这部分会在 GMP篇章进行展开（TODO 😁）。</p><p>注意这里：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如果 M 启动时配置了函数，则调用它</span><br><span class="hljs-keyword">if</span> fn := gp.m.mstartfn; fn != <span class="hljs-literal">nil</span> &#123;<br>    fn()<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们提到 <code>runtime·newproc</code> 的时候，获取并设置了<code>runtime.main</code> 的函数地址：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 取 runtime·mainPC 的地址，这其实就是 runtime 包下的 main() 方法。</span><br><span class="hljs-comment">// 它是 Go 语言程序的真正入口，而不是 main.main()。</span><br><span class="hljs-symbol">MOVQ</span>$runtime·mainPC(<span class="hljs-built_in">SB</span>), AX<br><span class="hljs-symbol">PUSHQ</span>AX<br><span class="hljs-comment">// 创建一个新的 goroutine 来运行程序的主函数。</span><br><span class="hljs-comment">// 这里还没有正在的运行，因为调度器还没有启动，</span><br><span class="hljs-comment">// 只是将 runtime.main 放进 goroutine 的 queue 中等待执行。</span><br><span class="hljs-symbol">CALL</span>runtime·newproc(<span class="hljs-built_in">SB</span>)<br><span class="hljs-symbol">POPQ</span>AX<br></code></pre></td></tr></table></figure><p>所以这里其实就是调用<code>runtime.main()</code>，到这里，我们终于开始执行程序的主函数了。</p><h2 id="runtime.main">runtime.main ★</h2><p>终于我们到了 <code>runtime.main</code> 这个 Go 语言世界中 “真正”的主函数了，它位于：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go">proc.go</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The main goroutine.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 获取当前的 M</span><br>mp := getg().m<br><br>mp.g0.racectx = <span class="hljs-number">0</span><br><br><span class="hljs-comment">// 限制栈大小的上限，64 位系统为 1G，32 位系统为 250M</span><br><span class="hljs-keyword">if</span> goarch.PtrSize == <span class="hljs-number">8</span> &#123;<br>maxstacksize = <span class="hljs-number">1000000000</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>maxstacksize = <span class="hljs-number">250000000</span><br>&#125;<br><br><span class="hljs-comment">// 这里就将栈的上限提升 2 倍，用于避免在分配过大的栈时崩溃。</span><br>    <span class="hljs-comment">// 所以其实 64 位系统最大栈 2G，32 位系统最大栈 500M。</span><br>maxstackceiling = <span class="hljs-number">2</span> * maxstacksize<br><br><span class="hljs-comment">// 将 mainStarted 置为 true，允许 newproc 启动新的 M。</span><br>mainStarted = <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// WebAssemby 上暂时没有线程和系统监视器，所以这里过滤掉。</span><br><span class="hljs-keyword">if</span> GOARCH != <span class="hljs-string">&quot;wasm&quot;</span> &#123; <br>        <span class="hljs-comment">// 其他架构就启动系统监视器。</span><br>systemstack(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>newm(sysmon, <span class="hljs-literal">nil</span>, <span class="hljs-number">-1</span>)<br>&#125;)<br>&#125;<br><br><span class="hljs-comment">// 在初始化期间将 g0 锁定在 m0 上。</span><br>lockOSThread()<br><br>    <span class="hljs-comment">// 只有 m0 可以运行 runtime.main</span><br><span class="hljs-keyword">if</span> mp != &amp;m0 &#123;<br>throw(<span class="hljs-string">&quot;runtime.main not on m0&quot;</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 记录 runtime 的开始时间，需要在 doInit() 之前，因为这样才把 init 也追踪上。</span><br>runtimeInitTime = nanotime()<br><span class="hljs-keyword">if</span> runtimeInitTime == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;nanotime returning zero&quot;</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 初始化 trace</span><br><span class="hljs-keyword">if</span> debug.inittrace != <span class="hljs-number">0</span> &#123;<br>inittrace.id = getg().goid<br>inittrace.active = <span class="hljs-literal">true</span><br>&#125;<br><br>    <span class="hljs-comment">// 执行 runtime 的 init() 方法</span><br>doInit(runtime_inittasks) <span class="hljs-comment">// Must be before defer.</span><br>    <br><span class="hljs-comment">// defer 解锁，以便在初始化期间调用 runtime.Goexit 时也能解锁。</span><br>needUnlock := <span class="hljs-literal">true</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> needUnlock &#123;<br>unlockOSThread()<br>&#125;<br>&#125;()<br><br>    <span class="hljs-comment">// 启动垃圾回收期</span><br>gcenable()<br><br>    <span class="hljs-comment">// 监听初始化完成的信号</span><br>main_init_done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br>    <br>    <span class="hljs-comment">// 如果使用 cgo，则进行相关的初始化</span><br><span class="hljs-keyword">if</span> iscgo &#123;<br>...<br>cgocall(_cgo_notify_runtime_init_done, <span class="hljs-literal">nil</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 执行所有模块的 init()</span><br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> activeModules() &#123;<br>doInit(m.inittasks)<br>&#125;<br><br><span class="hljs-comment">// 初始化任务都完成后，则禁用初始化 trace。</span><br>inittrace.active = <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">// 关闭初始化完成的信号通道</span><br><span class="hljs-built_in">close</span>(main_init_done)<br><br>    <span class="hljs-comment">// 解锁 m0 线程</span><br>needUnlock = <span class="hljs-literal">false</span><br>unlockOSThread()<br><br>    <span class="hljs-comment">// 以 -buildmode=(c-archive|c-shared) 方式进行构建程序的话，则不执行 main.main</span><br><span class="hljs-keyword">if</span> isarchive || islibrary &#123;<br><span class="hljs-comment">// A program compiled with -buildmode=c-archive or c-shared</span><br><span class="hljs-comment">// has a main, but it is not executed.</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <br>    <span class="hljs-comment">// 执行 main.main() 函数，也就是我们自己写的 main()</span><br>fn := main_main <br>fn()  <span class="hljs-comment">// 如果我们启动了一个 server 服务，这里就会被阻塞住，直到我们的 main 返回。</span><br>    <br>    <span class="hljs-comment">// 静态检测输出</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>runExitHooks(<span class="hljs-number">0</span>) <span class="hljs-comment">// run hooks now, since racefini does not return</span><br>racefini()<br>&#125;<br><br><span class="hljs-comment">// 处理在 main 返回时同时存在的其他 goroutine 的 panic</span><br><span class="hljs-keyword">if</span> runningPanicDefers.Load() != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">1000</span>; c++ &#123;<br>            <span class="hljs-comment">// 执行 defer</span><br><span class="hljs-keyword">if</span> runningPanicDefers.Load() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>Gosched()<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// 阻塞 g0 的执行，直到所有的 panic 都处理完毕</span><br><span class="hljs-keyword">if</span> panicking.Load() != <span class="hljs-number">0</span> &#123;<br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonPanicWait, traceBlockForever, <span class="hljs-number">1</span>)<br>&#125;<br>    <br>    <span class="hljs-comment">// 执行 hook 退出函数</span><br>runExitHooks(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 退出程序，0 表示正常退出</span><br>exit(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 理论上 exit(0) 应该退出程序的，</span><br>    <span class="hljs-comment">// 如果还没退出，使用 nil 指针强行赋值，引发崩溃，强行退出程序。</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">var</span> x *<span class="hljs-type">int32</span><br>*x = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，<code>runtime.main()</code> 干这么几件事：</p><ol type="1"><li>首先进行一些基本的设置和检查，包括设置栈大小限制和锁定主 goroutine到主 OS 线程。</li><li>然后，函数执行一系列初始化操作，包括启动垃圾回收器、处理 CGo交互、执行包的 init()。</li><li>在完成所有 init() 后，函数调用用户定义的 <code>main.main</code>函数。</li><li>最后，函数处理程序退出，包括执行 defer、等待 panic处理完成，并正式退出程序。</li></ol><p>所以这里我们就知道了为什么 <code>init()</code> 会在<code>main.main()</code> 之前被执行，而且如果一个 package在整个程序路径都没有被 import 的时候，<code>init()</code>是不会被执行的，就是因为 <code>runtime.main()</code> 只处理了<code>activeModules()</code> 的 <code>initTasks()</code>。</p><div class="note note-info">            <p>到这里，还有个遗留问题，开发时我们需要关注的 <code>init()</code> 和<code>main.main()</code>可以讨论过了，那全局变量的初始化是在哪里做的呢？</p><p>在 Go语言的编译过程中，全局变量的初始化主要发生在链接阶段。编译器首先编译每个包，生成对象文件。然后在链接阶段，编译器或链接器将这些对象文件合并成一个可执行文件。在这个过程中，编译器或链接器负责生成初始化全局变量的代码，并安排这些代码在程序启动时执行。</p><p>这些初始化代码通常嵌入在程序的启动序列中，确保在执行任何包级<code>init</code> 函数或用户定义的 <code>main</code>函数之前，所有全局变量已经被初始化。由于这些操作是编译器在内部执行的，它们不会直接显示在源代码或运行时代码中。</p>          </div><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231210232155964.png"alt="runtime.main 函数概述" /><figcaption aria-hidden="true">runtime.main 函数概述</figcaption></figure><hr /><p>至此，我们就分析完 Go语言程序的整个启动过程了。具体的启动流程总结，可以回到开头的 “结论先行”查看。</p><h2 id="参考">参考</h2><ul><li><ahref="https://coding.imooc.com/class/576.html">慕课网-深入Go底层原理</a></li><li>Go1.21.0 官方源码</li><li>ChatGPT-4</li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go1.21.0 程序编译过程</title>
    <link href="/2023/11/29/go-compilation/"/>
    <url>/2023/11/29/go-compilation/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><ul><li>Go 1.21</li></ul><h2 id="官方文档">官方文档</h2><p>Go 语言官方文档详细阐述了 Go 语言编译器的具体执行过程，Go1.21版本可以看这个：https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile</p><p>大致过程如下：</p><ol type="1"><li><strong>解析</strong> (<code>cmd/compile/internal/syntax</code>):<ul><li><strong>词法分析器和语法分析器</strong>：源代码被分词（词法分析）并解析（语法分析）。</li><li><strong>语法树构建</strong>：为每个源文件构建一个语法树。</li></ul></li><li><strong>类型检查</strong>(<code>cmd/compile/internal/types2</code>):<ul><li><strong>类型检查</strong>：<code>types2</code> 包是<code>go/types</code> 的一个移植版本，它使用 <code>syntax</code> 包的AST（抽象语法树）而不是 <code>go/ast</code>。</li></ul></li><li><strong>IR 构建（"noding"）</strong>:<ul><li><strong>编译器类型</strong>(<code>cmd/compile/internal/types</code>)</li><li><strong>编译器 AST</strong>(<code>cmd/compile/internal/ir</code>)</li><li><strong>AST 转换</strong>(<code>cmd/compile/internal/typecheck</code>)</li><li><strong>创建编译器 AST</strong>(<code>cmd/compile/internal/noder</code>)</li><li>这个阶段使用自己的 AST 定义和 Go 类型的表示，这些定义和表示形式是用C编写时遗留下来的。它的所有代码都是根据这些编写的，因此类型检查后的下一步是转换语法和<code>types2</code> 表示形式到 <code>ir</code> 和<code>types</code>。这个过程被称为“noding”。</li></ul></li><li><strong>中间阶段</strong>:<ul><li><strong>死代码消除</strong>(<code>cmd/compile/internal/deadcode</code>)</li><li><strong>函数调用内联</strong>(<code>cmd/compile/internal/inline</code>)</li><li><strong>已知接口方法调用的去虚拟化</strong>(<code>cmd/compile/internal/devirtualize</code>)</li><li><strong>逃逸分析</strong>(<code>cmd/compile/internal/escape</code>)</li><li>在 IR表示上执行几个优化过程：死代码消除、（早期的）去虚拟化、函数调用内联和逃逸分析。</li></ul></li><li><strong>Walk</strong> (<code>cmd/compile/internal/walk</code>):<ul><li><strong>求值顺序和语法糖</strong>：这是对 IR表示的最后一次遍历，它有两个目的：将复杂的语句分解为简单的单个语句，引入临时变量并遵守求值顺序；将高级Go 构造转换为更原始的构造。</li></ul></li><li><strong>通用 SSA</strong> (<code>cmd/compile/internal/ssa</code> 和<code>cmd/compile/internal/ssagen</code>):<ul><li>在这个阶段，IR被转换为静态单赋值（SSA）形式，这是一种具有特定属性的低级中间表示，使得从中实现优化并最终生成机器代码变得更容易。</li></ul></li><li><strong>生成机器代码</strong> (<code>cmd/compile/internal/ssa</code>和 <code>cmd/internal/obj</code>):<ul><li>这是编译器的机器依赖阶段，以“lower”过程开始，将通用值重写为它们的机器特定变体。然后进行最终的代码优化过程。最后，Go函数被转换为一系列 <code>obj.Prog</code>指令，这些指令被汇编器（<code>cmd/internal/obj</code>）转换为机器代码，并写出最终的目标文件。</li></ul></li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img5eRkfKJ8cMojTjPoZzjr1i-20231129143006857.png"alt="Go编译器概览" /><figcaption aria-hidden="true">Go编译器概览</figcaption></figure><h2 id="编译过程">编译过程</h2><p>Go程序的编译过程符合经典编译原理的过程拆解，即三阶段编译器，分别为编译器前端、中端和后端：</p><ul><li><strong>前端（Front End）：</strong>前端的任务是进行语法分析和语义分析。这一阶段会将源代码转换为一个中间表示。在这个过程中，编译器会检查代码的语法和语义，比如语法错误、类型错误等。前端通常是依赖于具体语言的，比如Go 的前端和 C++ 的前端就会有很大的不同。</li><li><strong>中间端（Middle End）：</strong>中间端的任务是对中间表示进行优化。这一阶段的优化是语言无关的，比如常量折叠、死代码消除、循环优化等。这些优化可以提高生成的代码的性能，但是不会改变程序的语义。</li><li><strong>后端（Back End）：</strong>后端的任务是将优化后的中间表示转换为目标机器代码。这一阶段会进行更多的优化，比如寄存器分配、指令选择、指令调度等。后端通常是依赖于具体机器的，比如x86 的后端和 ARM 的后端就会有很大的不同。</li></ul><p>参考《Go 语言底层原理剖析（郑建勋）》一书，本文将 Go语言编译器执行流程拆分为以下几个阶段：</p><ul><li>词法解析</li><li>语法解析</li><li>抽象语法树构建</li><li>类型检查</li><li>死代码消除</li><li>去虚拟化</li><li>函数内联</li><li>逃逸分析</li><li>变量捕获</li><li>闭包重写</li><li>遍历函数</li><li>SSA 生成</li><li>机器码生成</li></ul><p>下面本文将以此书为参考并结合 Go1.21.0 版本，对每个过程进行阐述。</p><blockquote><p>如果只想对 Go程序的编译过程做一个简单的了解，那阅读到这里就已经足够了。</p></blockquote><h2 id="词法解析">词法解析</h2><p>词法解析过程主要负责将源代码中的字符序列转换成一系列的标记（tokens），这些标记是编译器更进一步处理的基本单位。在Go 语言的编译器中，<code>tokens.go</code>文件包含了与词法分析有关的标记定义。</p><p>词法解析的过程可以分为几个关键步骤：</p><ol type="1"><li><strong>扫描（Scanning）</strong>：编译器的扫描器会逐字符读取源代码，识别出基本的语法单位，如标识符、关键字、字面量、运算符等。</li><li><strong>标记生成（TokenGeneration）</strong>：每当扫描器识别出一个有效的语法单位时，它会生成一个相应的标记。例如，对于一个变量名，扫描器会生成一个标识符标记。</li><li><strong>去除空白字符和注释</strong>：在生成标记的过程中，扫描器还会忽略空白字符（如空格、换行符）和注释，因为它们对程序的逻辑没有影响。</li><li><strong>错误处理</strong>：如果扫描器在源代码中遇到无法识别的字符或序列，它会生成一个错误消息。</li></ol><p>我们来看以下 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/tokens.go">tokens.go</a>文件中的 <code>token</code> 定义，它们实质上是用 <code>iota</code>声明的一系列整数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>_    token = <span class="hljs-literal">iota</span><br>_EOF       <span class="hljs-comment">// EOF</span><br><br><span class="hljs-comment">// names and literals</span><br>_Name    <span class="hljs-comment">// name</span><br>_Literal <span class="hljs-comment">// literal</span><br><br><span class="hljs-comment">// operators and operations</span><br><span class="hljs-comment">// _Operator is excluding &#x27;*&#x27; (_Star)</span><br>_IncOp    <span class="hljs-comment">// opop</span><br>    _Define   <span class="hljs-comment">// :=</span><br>    ...<br><br><span class="hljs-comment">// delimiters</span><br>_Lparen    <span class="hljs-comment">// (</span><br>_Rparen    <span class="hljs-comment">// )</span><br>...<br><br><span class="hljs-comment">// keywords</span><br>_Break       <span class="hljs-comment">// break</span><br>...<br><br><span class="hljs-comment">// empty line comment to exclude it from .String</span><br>tokenCount <span class="hljs-comment">//</span><br>)<br></code></pre></td></tr></table></figure><p>举个例子，<code>a := b + c(12)</code>这个表达式，被解析后，如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231202200135678.png"alt="Go 语言编译器词法解析示例图" /><figcaption aria-hidden="true">Go 语言编译器词法解析示例图</figcaption></figure><h2 id="语法解析">语法解析</h2><p>语法解析发生在词法解析之后，其主要目的是分析源代码中标记（tokens）的排列和结构，以确定它们是否形成了有效的语句。核心算法位于两个文件中：</p><ul><li><ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/nodes.go">syntax/nodes.go</a>：定义了语法节点（SyntaxNodes），这些节点是构成抽象语法树（AST）的基本元素。每个节点代表了 Go语法中的一个构造，比如变量声明、函数调用、表达式等。通过这些节点，编译器能够理解和表示程序代码的结构。</li><li><ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/parser.go">syntax/parser.go</a>：包含了解析器的实现。解析器负责读取词法分析阶段生成的标记流，并根据这些标记构建AST。它遵循 Go语言的语法规则，确保代码符合语法结构，并在遇到语法错误时提供相应的反馈。</li></ul><p>Go 语言采用了标准的自上而下的递归下降（Top-DownRecursive-Descent）算法，以简单高效的方式完成无须回溯的语法扫描。</p><p>下面我们来看下 <code>nodes.go</code>文件中对各个节点的声明（以下都省略了 struct 中的具体属性）：</p><h3 id="声明-declarations">声明 Declarations</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>Decl <span class="hljs-keyword">interface</span> &#123;<br>Node<br>aDecl()<br>&#125;<br>ImportDecl <span class="hljs-keyword">struct</span> &#123;&#125;   <span class="hljs-comment">// 导入声明</span><br>ConstDecl <span class="hljs-keyword">struct</span> &#123;&#125;   <span class="hljs-comment">// 常量声明</span><br>TypeDecl <span class="hljs-keyword">struct</span> &#123;&#125;   <span class="hljs-comment">// 类型声明</span><br>VarDecl <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 变量声明</span><br>FuncDecl <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 函数声明</span><br>)<br></code></pre></td></tr></table></figure><h3 id="表达式-expressions">表达式 Expressions</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>Expr <span class="hljs-keyword">interface</span> &#123;<br>Node<br>typeInfo<br>aExpr()<br>&#125;<br><span class="hljs-comment">// 省略了结构体属性</span><br>BadExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 无效表达式</span><br>Name <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Value</span><br>BasicLit <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Value</span><br>CompositeLit <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Type &#123; ElemList[0], ElemList[1], ... &#125;</span><br>    KeyValueExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Key: Value</span><br>FuncLit <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// func Type &#123; Body &#125;</span><br>ParenExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// (X)</span><br>SelectorExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// X.Sel</span><br>IndexExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// X[Index]</span><br>SliceExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// X[Index[0] : Index[1] : Index[2]]</span><br>AssertExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// X.(Type)</span><br>TypeSwitchGuard <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Lhs := X.(type)</span><br>Operation <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 操作 +-*\</span><br>CallExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Fun(ArgList[0], ArgList[1], ...)</span><br>ListExpr <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// ElemList[0], ElemList[1], ...</span><br>ArrayType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// [Len]Elem</span><br>SliceType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// []Elem</span><br>DotsType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// ...Elem</span><br>StructType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// struct &#123; FieldList[0] TagList[0]; FieldList[1] TagList[1]; ... &#125;</span><br>Field <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// Name Type</span><br>InterfaceType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// interface &#123; MethodList[0]; MethodList[1]; ... &#125;</span><br>    FuncType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// type FuncName func (param1, param2) return1, return2</span><br>MapType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// map[Key]Value</span><br>ChanType <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// chan Elem, &lt;-chan Elem, chan&lt;- Elem</span><br>)<br></code></pre></td></tr></table></figure><h3 id="语句-statements">语句 Statements</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>    <span class="hljs-comment">// 所有语句的通用接口</span><br>    Stmt <span class="hljs-keyword">interface</span> &#123;<br>       Node<br>       aStmt()<br>    &#125;<br><span class="hljs-comment">// 更加简单语句的通用接口</span><br>    SimpleStmt <span class="hljs-keyword">interface</span> &#123;&#125;<br><br>    EmptyStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 空语句</span><br>    LabeledStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 标签语句</span><br>    BlockStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 代码块语句</span><br>    ExprStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 表达式语句</span><br>    SendStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 发送语句，用于 channel</span><br>    DeclStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 声明语句</span><br>    AssignStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 赋值语句</span><br>    BranchStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 分支语句，break, continue</span><br>    CallStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 调用语句</span><br>    ReturnStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// 返回语句</span><br>    IfStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// if 条件语句</span><br>    ForStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// for 循环语句</span><br>    SwitchStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// switch 语句</span><br>    SelectStmt <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-comment">// select 语句</span><br>)<br></code></pre></td></tr></table></figure><p>我们可以重点来看一下最常用的赋值语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AssignStmt <span class="hljs-keyword">struct</span> &#123;<br>    Op       Operator <span class="hljs-comment">// 操作符 0 means no operation</span><br>    Lhs, Rhs Expr     <span class="hljs-comment">// 左右两个表达式 Rhs == nil means Lhs++ (Op == Add) or Lhs-- (Op == Sub)</span><br>    simpleStmt<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="举例">举例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;hedon&quot;</span><br><span class="hljs-keyword">type</span> String <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> s String = <span class="hljs-string">&quot;hello &quot;</span> + word<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的源代码会被解析成如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231202195439495.png"alt="Go 编译器语法解析示例图" /><figcaption aria-hidden="true">Go 编译器语法解析示例图</figcaption></figure><p>再来看一个赋值语句是如何解析的，就以之前的<code>a := b + c(12)</code> 为例：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203003155036.png"alt="特定赋值语句的语法解析示例" /><figcaption aria-hidden="true">特定赋值语句的语法解析示例</figcaption></figure><h2 id="抽象语法树构建">抽象语法树构建</h2><p>编译器前端必须构建程序的中间表示形式，以便在编译器中端及后端使用，抽象语法树（AbstractSyntax Tree，AST）是一种常见的树状结构的中间态。</p><h3 id="抽象语法树">抽象语法树</h3><p>抽象语法树（AST，Abstract SyntaxTree）是源代码的树状结构表示，它用于表示编程语言的语法结构，但不包括所有语法细节。AST是编译器设计中的关键概念，广泛应用于编译器的各个阶段。</p><p>基本概念：</p><ul><li>结构：AST是一种树形结构，其中每个节点代表程序中的一种构造（如表达式、语句等）。</li><li>抽象性：它抽象出了代码的语法结构，省略了某些语法细节（如括号、特定的语法格式等）。</li></ul><p>节点类型：</p><ul><li>根节点：代表整个程序或一段完整代码。</li><li>内部节点：通常代表控制结构（如循环、条件语句）和操作符（如加、减、乘、除）。</li><li>叶节点：代表程序中的基本元素，如常量、变量和标识符。</li></ul><p>构建过程：</p><ul><li>词法分析：源代码首先经过词法分析，分解为一系列标记（tokens）。</li><li>语法分析：然后，基于这些标记，语法分析器根据编程语言的语法规则构建AST。</li><li>树的构建：在这个过程中，分析器会根据语言的语法创建不同类型的节点，并按照程序的结构将它们组织成树。</li></ul><p>使用场景：</p><ul><li>语义分析：编译器使用 AST 来进行类型检查和其他语义分析。</li><li>代码优化：在优化阶段，编译器会对 AST进行变换，以提高代码的执行效率。</li><li>代码生成：编译器根据 AST 生成中间代码或目标代码。</li></ul><p>优点：</p><ul><li>简化处理：由于省略了不必要的语法细节，AST使得编译器的设计更为简洁和高效。</li><li>灵活性：AST 可以轻松地进行修改和扩展，便于实现各种编译器功能。</li><li>可视化：AST的树形结构使得代码的逻辑结构一目了然，有助于理解和调试。</li></ul><h3 id="go-构建抽象语法树">Go 构建抽象语法树</h3><p>在 Go 语言源文件中的任何一种 Declarations 都是一个根节点，如下<code>pkgInit(decls)</code>函数将源文件中的所有声明语句都转换为节点（Node），代码位于：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/syntax.go">syntax/syntax.go</a>和 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/syntax/parser.go">syntax/parser.go</a>中。</p><h4 id="parse">Parse()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(base *PosBase, src io.Reader, errh ErrorHandler, pragh PragmaHandler, mode Mode)</span></span> (_ *File, first <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> p := <span class="hljs-built_in">recover</span>(); p != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err, ok := p.(Error); ok &#123;<br>first = err<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-built_in">panic</span>(p)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">var</span> p parser<br>p.init(base, src, errh, pragh, mode)<br>p.next()<br><span class="hljs-keyword">return</span> p.fileOrNil(), p.first<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是对 <code>Parse()</code> 函数的一个简单解释：</p><ul><li>作用：解析单个 Go 源文件并返回相应的语法树。</li><li>参数<ul><li><code>base</code>: 位置基础信息。</li><li><code>src</code>: 要解析的源文件。</li><li><code>errh</code>: 错误处理函数。</li><li><code>pragh</code>: 用于处理每个遇到的编译指令（pragma）。</li><li><code>mode</code>: 解析模式。</li></ul></li><li>返回值：返回一个 <code>File</code> 类型的指针，表示解析后的AST，以及可能的错误。</li><li>错误处理<ul><li>如果 <code>errh</code>不为空：将会调用它处理每个遇到的错误，解析器尽可能多地处理源文件。此时，只有在没有找到正确的包声明时，返回的语法树才为<code>nil</code>。</li><li>如果 <code>errh</code>为空：解析器在遇到第一个错误时立即终止，返回的语法树为<code>nil</code>。</li></ul></li></ul><p>其中 <code>File</code> 类型结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> File <span class="hljs-keyword">struct</span> &#123;<br>Pragma    Pragma <span class="hljs-comment">// 编译指令</span><br>PkgName   *Name  <span class="hljs-comment">// 包名</span><br>DeclList  []Decl <span class="hljs-comment">// 源文件中的各种声明</span><br>EOF       Pos <span class="hljs-comment">// 解析位置</span><br>GoVersion <span class="hljs-type">string</span> <span class="hljs-comment">// go 版本</span><br>node<span class="hljs-comment">// 该源文件的 AST 根节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="parser.fileornil">parser.fileOrNil()</h4><p>具体的解析过程在 <code>parser.fileOrNil()</code> 方法中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *parser)</span></span> fileOrNil() *File &#123;<br><span class="hljs-keyword">if</span> trace &#123;<br><span class="hljs-keyword">defer</span> p.trace(<span class="hljs-string">&quot;file&quot;</span>)()<br>&#125;<br><br>    <span class="hljs-comment">// 1. 初始化文件节点</span><br>f := <span class="hljs-built_in">new</span>(File)<br>f.pos = p.pos()<br><br><span class="hljs-comment">// 2. 解析包声明</span><br>f.GoVersion = p.goVersion<br>p.top = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> !p.got(_Package) &#123;<span class="hljs-comment">// 包声明必须放在第一位，这跟我们学 Go 语法对应上了</span><br>p.syntaxError(<span class="hljs-string">&quot;package statement must be first&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>f.Pragma = p.takePragma() <span class="hljs-comment">// 获取编译指令</span><br>f.PkgName = p.name()<span class="hljs-comment">// 获取包名</span><br>    p.want(_Semi) <span class="hljs-comment">// _Semi 在之前的 tokens.go 中可以发现是分号（;)，是的，包声明后面就是得带分号</span><br><br><span class="hljs-comment">// 3. 处理包声明错误</span><br><span class="hljs-keyword">if</span> p.first != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 4. 循环解析顶层声明</span><br>    <span class="hljs-comment">// 循环处理文件中的所有声明，包括 import、const、type、var 和 func</span><br>    <span class="hljs-comment">// 对每种类型的声明，调用其解析函数，如 importDecl、constDecl 进行解析</span><br>prev := _Import<br><span class="hljs-keyword">for</span> p.tok != _EOF &#123;<br><span class="hljs-keyword">if</span> p.tok == _Import &amp;&amp; prev != _Import &#123;<br>p.syntaxError(<span class="hljs-string">&quot;imports must appear before other declarations&quot;</span>)<br>&#125;<br>prev = p.tok<br><br><span class="hljs-keyword">switch</span> p.tok &#123;<br><span class="hljs-keyword">case</span> _Import:<br>p.next()<br>f.DeclList = p.appendGroup(f.DeclList, p.importDecl)<br><br><span class="hljs-keyword">case</span> _Const:<br>p.next()<br>f.DeclList = p.appendGroup(f.DeclList, p.constDecl)<br><br><span class="hljs-keyword">case</span> _Type:<br>p.next()<br>f.DeclList = p.appendGroup(f.DeclList, p.typeDecl)<br><br><span class="hljs-keyword">case</span> _Var:<br>p.next()<br>f.DeclList = p.appendGroup(f.DeclList, p.varDecl)<br><br><span class="hljs-keyword">case</span> _Func:<br>p.next()<br><span class="hljs-keyword">if</span> d := p.funcDeclOrNil(); d != <span class="hljs-literal">nil</span> &#123;<br>f.DeclList = <span class="hljs-built_in">append</span>(f.DeclList, d)<br>&#125;<br><br><span class="hljs-keyword">default</span>:<br>             <span class="hljs-comment">// 5. 处理异常和错误</span><br><span class="hljs-keyword">if</span> p.tok == _Lbrace &amp;&amp; <span class="hljs-built_in">len</span>(f.DeclList) &gt; <span class="hljs-number">0</span> &amp;&amp; isEmptyFuncDecl(f.DeclList[<span class="hljs-built_in">len</span>(f.DeclList)<span class="hljs-number">-1</span>]) &#123;<br>p.syntaxError(<span class="hljs-string">&quot;unexpected semicolon or newline before &#123;&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p.syntaxError(<span class="hljs-string">&quot;non-declaration statement outside function body&quot;</span>)<br>&#125;<br>p.advance(_Import, _Const, _Type, _Var, _Func)<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// Reset p.pragma BEFORE advancing to the next token (consuming &#x27;;&#x27;)</span><br><span class="hljs-comment">// since comments before may set pragmas for the next function decl.</span><br>p.clearPragma()<br><br><span class="hljs-keyword">if</span> p.tok != _EOF &amp;&amp; !p.got(_Semi) &#123;<br>p.syntaxError(<span class="hljs-string">&quot;after top level declaration&quot;</span>)<br>p.advance(_Import, _Const, _Type, _Var, _Func)<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 6. 完成解析，记录文件结束的位置</span><br>p.clearPragma()<br>f.EOF = p.pos()<br><br><span class="hljs-keyword">return</span> f<br>&#125;<br></code></pre></td></tr></table></figure><p>总结 <code>parser.fileOrNil()</code> 方法的处理过程大致如下：</p><ol type="1"><li><strong>初始化文件节点</strong>：<ul><li><code>f := new(File)</code>: 创建一个新的 <code>File</code>节点。</li><li><code>f.pos = p.pos()</code>: 设置节点的位置信息。</li></ul></li><li><strong>解析包声明（Package Clause）</strong>：<ul><li><code>f.GoVersion = p.goVersion</code>: 记录 Go 版本。</li><li><code>p.top = false</code>: 设置状态，表示不再处于文件顶层。</li><li><code>if !p.got(_Package) &#123;...&#125;</code>:检查是否存在包声明，如果没有，则报错并返回 <code>nil</code>。</li><li><code>f.Pragma = p.takePragma()</code>:获取与包声明相关的编译指令。</li><li><code>f.PkgName = p.name()</code>: 获取包名。</li><li><code>p.want(_Semi)</code>: 确认包声明后有分号。</li></ul></li><li><strong>处理包声明错误</strong>：<ul><li><code>if p.first != nil &#123;...&#125;</code>: 如果已有错误，停止解析并返回<code>nil</code>。</li></ul></li><li><strong>解析顶层声明</strong>：<ul><li>通过一个循环处理文件中的所有声明，包括导入（import）、常量（const）、类型（type）、变量（var）和函数（func）。</li><li>对每种类型的声明，调用相应的解析函数（如<code>p.importDecl</code>、<code>p.constDecl</code> 等）。</li><li>将解析得到的声明添加到 <code>f.DeclList</code> 中。</li></ul></li><li><strong>处理异常和错误</strong>：<ul><li>在解析过程中遇到的任何不符合语法的情况都会触发错误处理。</li><li>使用 <code>p.syntaxError</code> 报告语法错误。</li><li>使用 <code>p.advance</code>在遇到错误时跳过一些标记，以尝试恢复到一个已知的稳定状态。</li></ul></li><li><strong>完成解析</strong>：<ul><li>当遇到文件结束标记（EOF）时，完成解析。</li><li><code>f.EOF = p.pos()</code>: 记录文件结束的位置。</li><li>返回构建的 <code>File</code> 节点。</li></ul></li></ol><h3 id="op-字段">Op 字段</h3><p>AST 每个节点都包含了当前节点属性的 Op 字段，定义在<code>ir/node.go</code> 中，以 O 开头。与词法解析阶段中的 token相同的是，Op 字段也是一个整数。不同的是，每个 Op字段都包含了语义信息。例如，当一个节点的 Op 操作为 OAS时，该节点代表的语义为 Left := Right，而当节点的操作为 OAS2时，代码的语义为 x,y,z = a,b,c。</p><p>这里仅展示部分 Op 字段的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Op <span class="hljs-type">uint8</span><br><br><span class="hljs-comment">// Node ops.</span><br><span class="hljs-keyword">const</span> (<br>OXXX Op = <span class="hljs-literal">iota</span><br><br><span class="hljs-comment">// names</span><br>ONAME <span class="hljs-comment">// var or func name</span><br><span class="hljs-comment">// Unnamed arg or return value: f(int, string) (int, error) &#123; etc &#125;</span><br><span class="hljs-comment">// Also used for a qualified package identifier that hasn&#x27;t been resolved yet.</span><br>ONONAME<br>OTYPE    <span class="hljs-comment">// type name</span><br>OLITERAL <span class="hljs-comment">// literal</span><br>ONIL     <span class="hljs-comment">// nil</span><br><br><span class="hljs-comment">// expressions</span><br>OADD          <span class="hljs-comment">// X + Y</span><br>...<br><span class="hljs-comment">// X = Y or (if Def=true) X := Y</span><br><span class="hljs-comment">// If Def, then Init includes a DCL node for X.</span><br>OAS<br><span class="hljs-comment">// Lhs = Rhs (x, y, z = a, b, c) or (if Def=true) Lhs := Rhs</span><br><span class="hljs-comment">// If Def, then Init includes DCL nodes for Lhs</span><br>OAS2<br>...<br>    <br>    <span class="hljs-comment">// statements</span><br>    OLABEL    <span class="hljs-comment">// Label:</span><br>    ...<br>OEND<br>)<br></code></pre></td></tr></table></figure><p>以前面举例的赋值语句 <code>a := b + c(12)</code>为例，该赋值语句最终会编程如下图所示的抽象语法树，节点之间具有从上到下的层次结构和依赖关系。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203003058976.png"alt="抽象语法树示例图" /><figcaption aria-hidden="true">抽象语法树示例图</figcaption></figure><h2 id="类型检查">类型检查</h2><p>完成 AST的初步构建后，就进入类型检查阶段遍历节点树并决定节点的类型。具体的代码在<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/types2/check.go">types2/check,go</a>。</p><h3 id="checker.checkfiles">checker.CheckFiles()</h3><p>其中最核心的方法就是 <code>checker.CheckFiles()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(check *Checker)</span></span> checkFiles(files []*syntax.File) (err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 1. 不检查 unsafe 包</span><br><span class="hljs-keyword">if</span> check.pkg == Unsafe &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>    <span class="hljs-comment">// 2. 检查 go 版本</span><br>check.version, err = parseGoVersion(check.conf.GoVersion)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> check.version.after(version&#123;<span class="hljs-number">1</span>, goversion.Version&#125;) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;package requires newer Go version %v&quot;</span>, check.version)<br>&#125;<br><span class="hljs-keyword">if</span> check.conf.FakeImportC &amp;&amp; check.conf.go115UsesCgo &#123;<br><span class="hljs-keyword">return</span> errBadCgo<br>&#125;<br><br>    <span class="hljs-comment">// 3. 错误处理</span><br><span class="hljs-keyword">defer</span> check.handleBailout(&amp;err)<br><br>    <span class="hljs-comment">// 4. 详细检查每个地方</span><br><span class="hljs-built_in">print</span> := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> check.conf.Trace &#123;<br>fmt.Println()<br>fmt.Println(msg)<br>&#125;<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== initFiles ==&quot;</span>)<br>check.initFiles(files)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== collectObjects ==&quot;</span>)<br>check.collectObjects()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== packageObjects ==&quot;</span>)<br>check.packageObjects()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== processDelayed ==&quot;</span>)<br>check.processDelayed(<span class="hljs-number">0</span>) <span class="hljs-comment">// incl. all functions</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== cleanup ==&quot;</span>)<br>check.cleanup()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== initOrder ==&quot;</span>)<br>check.initOrder()<br><span class="hljs-keyword">if</span> !check.conf.DisableUnusedImportCheck &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== unusedImports ==&quot;</span>)<br>check.unusedImports()<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;== recordUntyped ==&quot;</span>)<br>check.recordUntyped()<br><span class="hljs-keyword">if</span> check.firstErr == <span class="hljs-literal">nil</span> &#123;<br>check.monomorph()<br>&#125;<br>check.pkg.goVersion = check.conf.GoVersion<br>check.pkg.complete = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 5. 更新和清理</span><br>check.imports = <span class="hljs-literal">nil</span><br>check.dotImportMap = <span class="hljs-literal">nil</span><br>check.pkgPathMap = <span class="hljs-literal">nil</span><br>check.seenPkgMap = <span class="hljs-literal">nil</span><br>check.recvTParamMap = <span class="hljs-literal">nil</span><br>check.brokenAliases = <span class="hljs-literal">nil</span><br>check.unionTypeSets = <span class="hljs-literal">nil</span><br>check.ctxt = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结 <code>checker.checkFiles()</code> 的过程大致如下：</p><ol type="1"><li><strong>检查特殊包</strong>：如果是 <code>Unsafe</code>包，则直接返回，因为它不能进行类型检查且不应被修改。</li><li><strong>解析Go版本</strong>：根据配置解析 Go版本，并进行兼容性检查。</li><li><strong>错误处理</strong>：设置一个延迟函数来处理任何可能出现的错误。</li><li><strong>类型检查的步骤</strong>：<ul><li><code>initFiles</code>: 初始化文件。</li><li><code>collectObjects</code>: 收集对象。</li><li><code>packageObjects</code>: 打包对象。</li><li><code>processDelayed</code>: 处理延迟的任务（包括所有函数）。</li><li><code>cleanup</code>: 清理。</li><li><code>initOrder</code>: 初始化顺序。</li><li><code>unusedImports</code>: 检查未使用的导入。</li><li><code>recordUntyped</code>: 记录未定类型。</li><li><code>monomorph</code>: 如果没有错误，进行单态化处理。</li></ul></li><li><strong>更新和清理</strong>：<ul><li>更新包的 Go 版本和完成状态。</li><li>清理不再需要的内部数据结构，释放内存。</li></ul></li><li><strong>返回</strong>：函数完成类型检查并返回。</li></ol><p>可以看出具体的检查步骤都封装在第 4点的各个函数中，其实检查的东西我们学习 Go语言时所需要掌握的那些语法，我们以 <code>initFiles</code>为例子来分析一下，对于其他检查函数，你有兴趣的话也可以了解一下，这里推荐将函数源代码拷贝发给<strong>ChatGPT-4</strong>，相信对你会有很大的帮助。</p><h3 id="checker.initfiles">checker.initFiles()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// initFiles 初始化与文件相关的类型检查器</span><br><span class="hljs-comment">// 参数中的 files 必须都属于同一个 package</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(check *Checker)</span></span> initFiles(files []*syntax.File) &#123;<br><span class="hljs-comment">// 1. 初始化</span><br>check.files = <span class="hljs-literal">nil</span><br>check.imports = <span class="hljs-literal">nil</span><br>check.dotImportMap = <span class="hljs-literal">nil</span><br>check.firstErr = <span class="hljs-literal">nil</span><br>check.methods = <span class="hljs-literal">nil</span><br>check.untyped = <span class="hljs-literal">nil</span><br>check.delayed = <span class="hljs-literal">nil</span><br>check.objPath = <span class="hljs-literal">nil</span><br>check.cleaners = <span class="hljs-literal">nil</span><br><br><span class="hljs-comment">// 2. 确定包名和有效文件</span><br>pkg := check.pkg<br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br><span class="hljs-keyword">switch</span> name := file.PkgName.Value; pkg.name &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&quot;</span>:<br><span class="hljs-keyword">if</span> name != <span class="hljs-string">&quot;_&quot;</span> &#123;<br>pkg.name = name<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>check.<span class="hljs-type">error</span>(file.PkgName, BlankPkgName, <span class="hljs-string">&quot;invalid package name _&quot;</span>)<br>&#125;<br><span class="hljs-keyword">fallthrough</span><br><br><span class="hljs-keyword">case</span> name:<br>check.files = <span class="hljs-built_in">append</span>(check.files, file)<br><br><span class="hljs-keyword">default</span>:<br>check.errorf(file, MismatchedPkgName, <span class="hljs-string">&quot;package %s; expected %s&quot;</span>, name, pkg.name)<br><span class="hljs-comment">// ignore this file</span><br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 3. 对每个文件，解析其中指定的 Go 版本</span><br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> check.files &#123;<br>v, _ := parseGoVersion(file.GoVersion)<br><span class="hljs-keyword">if</span> v.major &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> v.equal(check.version) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// Go 1.21 introduced the feature of setting the go.mod</span><br><span class="hljs-comment">// go line to an early version of Go and allowing //go:build lines</span><br><span class="hljs-comment">// to “upgrade” the Go version in a given file.</span><br><span class="hljs-comment">// We can do that backwards compatibly.</span><br><span class="hljs-comment">// Go 1.21 also introduced the feature of allowing //go:build lines</span><br><span class="hljs-comment">// to “downgrade” the Go version in a given file.</span><br><span class="hljs-comment">// That can&#x27;t be done compatibly in general, since before the</span><br><span class="hljs-comment">// build lines were ignored and code got the module&#x27;s Go version.</span><br><span class="hljs-comment">// To work around this, downgrades are only allowed when the</span><br><span class="hljs-comment">// module&#x27;s Go version is Go 1.21 or later.</span><br><span class="hljs-comment">// If there is no check.version, then we don&#x27;t really know what Go version to apply.</span><br><span class="hljs-comment">// Legacy tools may do this, and they historically have accepted everything.</span><br><span class="hljs-comment">// Preserve that behavior by ignoring //go:build constraints entirely in that case.</span><br><span class="hljs-keyword">if</span> (v.before(check.version) &amp;&amp; check.version.before(version&#123;<span class="hljs-number">1</span>, <span class="hljs-number">21</span>&#125;)) || check.version.equal(version&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> check.posVers == <span class="hljs-literal">nil</span> &#123;<br>check.posVers = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*syntax.PosBase]version)<br>&#125;<br>check.posVers[base(file.Pos())] = v<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结 <code>checker.initFiles()</code> 方法的大致流程如下：</p><ol type="1"><li><strong>初始化状态</strong>：清空 <code>Checker</code>结构体中与文件相关的多个字段，如 <code>files</code>,<code>imports</code>, <code>dotImportMap</code>等，为新的检查过程做准备。</li><li><strong>确定包名和有效文件</strong>：<ul><li>遍历提供的文件，确定包名，并收集有效的文件。</li><li>如果文件的包名与 <code>Checker</code>中的包名不匹配，则报错并忽略该文件。</li></ul></li><li><strong>处理Go版本</strong>：<ul><li>对每个文件，解析其中指定的 Go 版本。</li><li>处理 Go 版本的兼容性和升级逻辑，尤其是在 Go 1.21 引入的一些特性，如<code>//go:build</code> 行的处理。</li></ul></li></ol><p>可以看到 Go 语言开发团队在这里写了一大段关于 Go1.21的注释，这段注释描述了 Go 1.21 版本引入的关于 Go版本设置的两个新特性,这里简单解释一下：</p><ol type="1"><li><strong>升级 Go 版本的特性</strong>：在 Go 1.21 版本中，可以在<code>go.mod</code> 文件里设置一个较旧的Go版本，同时允许在源文件中通过<code>//go:build</code> 行来指定一个更高的 Go版本。这样做可以向后兼容，即允许旧版本代码在新版本的 Go环境中运行。</li><li><strong>降级 Go 版本的限制</strong>：Go 1.21 也允许通过<code>//go:build</code> 行来降低源文件中的 Go版本。但这通常不是向后兼容的，因为在以前，<code>//go:build</code>行被忽略，代码总是使用模块定义的 Go 版本。为了避免兼容性问题，仅当模块的Go 版本为 1.21 或更高时，才允许这种降级。</li></ol><p><strong>未指定版本的情况</strong>：如果没有明确指定<code>check.version</code>，编译器就不确定应该使用哪个 Go版本。为了保持与旧工具的兼容，如果没有明确的版本约束，编译器将忽略<code>//go:build</code> 行的限制。</p><h2 id="死代码消除">死代码消除</h2><p>类型检查阶段完成后，编译器前端工作基本完成，后面就进入中端了。这个阶段Go 语言编译器将对 AST 进行分析和重构，从而完成一系列优化。</p><p>第一部分是死代码消除（dead codeelimination），过程识别并移除不会在运行时执行的代码。这包括未使用的变量、函数、常量等。通过删除这些无用代码片段，可以减小最终程序的大小并提高运行效率。</p><p>这部分的代码在：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/deadcode/deadcode.go">deadcode/deadcode.go</a>。打开代码文件，可以看到核心就是<code>Func()</code> 和 <code>stmt()</code> 这 2 个函数。</p><h3 id="func">Func()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Func</span><span class="hljs-params">(fn *ir.Func)</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 1. 对函数体进行预处理</span><br>stmts(&amp;fn.Body)<br><br>    <span class="hljs-comment">// 2. 空函数体直接返回</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fn.Body) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>    <span class="hljs-comment">// 3. 遍历函数体，对其中每个节点进行处理</span><br><span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> fn.Body &#123;<br>        <span class="hljs-comment">// 节点有任何初始化操作，则不可消除，提前返回。</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.Init()) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">switch</span> n.Op() &#123;<br><span class="hljs-keyword">case</span> ir.OIF:<br>n := n.(*ir.IfStmt)<br>            <span class="hljs-comment">// 如果 if 语句判断条件不是常量，或者 if else 中的 body 不为空，则不可消除，提前返回</span><br><span class="hljs-keyword">if</span> !ir.IsConst(n.Cond, constant.Bool) || <span class="hljs-built_in">len</span>(n.Body) &gt; <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(n.Else) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">case</span> ir.OFOR:<br>n := n.(*ir.ForStmt)<br>            <span class="hljs-comment">// 如果 for 循环条件不是常量或一直为真，则不可消除，提前返回</span><br><span class="hljs-keyword">if</span> !ir.IsConst(n.Cond, constant.Bool) || ir.BoolVal(n.Cond) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 4. 标记隐藏闭包为死代码</span><br>ir.VisitList(fn.Body, markHiddenClosureDead)<br>    <span class="hljs-comment">// 5. 重置函数体，替换为一个空语句，进行清理和优化</span><br>fn.Body = []ir.Node&#123;ir.NewBlockStmt(base.Pos, <span class="hljs-literal">nil</span>)&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol type="1"><li><strong>语句处理（<code>stmts(&amp;fn.Body)</code>）</strong>：对函数体中的语句进行预处理或转换，以便于后续的分析和优化。</li><li><strong>空函数体直接返回</strong>：如果函数体为空，没有任何代码需要执行，因此函数直接返回。这是一种优化，避免对空函数体进行不必要的分析。</li><li><strong>遍历函数体</strong>:<ul><li><strong>节点初始化检查</strong>：如果任何节点有初始化操作，意味着可能存在副作用或必要的代码执行，因此函数提前返回。</li><li><code>If</code> 和 <code>For</code> 语句特殊处理<ul><li><code>ir.OIF</code>：如果 <code>If</code>语句的条件不是常量布尔值，或者 <code>If</code> 语句有非空的 body 或 else分支，则提前返回，因为这些分支可能包含重要的代码。</li><li><code>ir.OFOR</code>：对于 <code>For</code>循环，如果条件不是常量布尔值或者布尔值为真，意味着循环可能执行，因此提前返回。</li></ul></li></ul></li><li><strong>标记隐藏闭包为死代码（<code>markHiddenClosureDead</code>）</strong>：如果所有节点都不触发提前返回，意味着整个函数体可能没有有效的代码执行。此时，将隐藏的闭包标记为死代码，可能是为了进一步的优化处理，如移除这些代码。</li><li><strong>重置函数体</strong>：最后，将函数体替换为一个空的新块语句，这表明原始的函数体被认为是无效的或不会被执行，从而进行了代码的清理和优化。</li></ol><h3 id="stmt">stmt()</h3><p>这个函数的目的是通过分析和简化控制流结构，来识别和移除那些在程序执行中永远不会到达的代码部分。这样的优化可以减少编译后的代码量，并提高程序运行时的效率。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stmts</span><span class="hljs-params">(nn *ir.Nodes)</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 1. 标记最后一个标签，其对应的 Op 字段就是 OLABEL</span><br><span class="hljs-keyword">var</span> lastLabel = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> i, n := <span class="hljs-keyword">range</span> *nn &#123;<br><span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &amp;&amp; n.Op() == ir.OLABEL &#123;<br>lastLabel = i<br>&#125;<br>&#125;<br>    <br>    <span class="hljs-comment">// 2. 处理 if 和 switch 语句</span><br><span class="hljs-keyword">for</span> i, n := <span class="hljs-keyword">range</span> *nn &#123;<br>cut := <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> n.Op() == ir.OIF &#123;<br>n := n.(*ir.IfStmt)<br>n.Cond = expr(n.Cond)<br>             <span class="hljs-comment">// if 语句根据条件是否为常量来保留和移除分支</span><br><span class="hljs-keyword">if</span> ir.IsConst(n.Cond, constant.Bool) &#123;<br><span class="hljs-keyword">var</span> body ir.Nodes<br><span class="hljs-keyword">if</span> ir.BoolVal(n.Cond) &#123;<br>ir.VisitList(n.Else, markHiddenClosureDead)<br>n.Else = ir.Nodes&#123;&#125;<br>body = n.Body<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ir.VisitList(n.Body, markHiddenClosureDead)<br>n.Body = ir.Nodes&#123;&#125;<br>body = n.Else<br>&#125;<br>                 <span class="hljs-comment">// 如果 then 或 else 分支以 panic 或 return 语句结束，那么可以安全地移除该节点之后的所有语句。</span><br>                 <span class="hljs-comment">// 这是因为 panic 或 return 会导致函数终止，后续的代码永远不会被执行。</span><br>                 <span class="hljs-comment">// 同时，注释提到要避免移除标签（labels），因为它们可能是 goto 语句的目标，</span><br>                 <span class="hljs-comment">// 而且为了避免 goto 相关的复杂性，没有使用 isterminating 标记。</span><br>                 <span class="hljs-comment">// might be the target of a goto. See issue 28616.</span><br><span class="hljs-keyword">if</span> body := body; <span class="hljs-built_in">len</span>(body) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">switch</span> body[(<span class="hljs-built_in">len</span>(body) - <span class="hljs-number">1</span>)].Op() &#123;<br><span class="hljs-keyword">case</span> ir.ORETURN, ir.OTAILCALL, ir.OPANIC:<br><span class="hljs-keyword">if</span> i &gt; lastLabel &#123;<br>cut = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>        <span class="hljs-comment">// 尝试简化 switch 语句，根据条件值决定哪个分支始终被执行</span><br><span class="hljs-keyword">if</span> n.Op() == ir.OSWITCH &#123;<br>n := n.(*ir.SwitchStmt)<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Tag != <span class="hljs-literal">nil</span> &amp;&amp; n.Tag.Op() == ir.OTYPESW &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// no special type-switch case yet.</span><br>&#125;<br><span class="hljs-keyword">var</span> x constant.Value <span class="hljs-comment">// value we&#x27;re switching on</span><br><span class="hljs-keyword">if</span> n.Tag != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> ir.ConstType(n.Tag) == constant.Unknown &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>x = n.Tag.Val()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>x = constant.MakeBool(<span class="hljs-literal">true</span>) <span class="hljs-comment">// switch &#123; ... &#125;  =&gt;  switch true &#123; ... &#125;</span><br>&#125;<br><span class="hljs-keyword">var</span> def *ir.CaseClause<br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cas.List) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// default case</span><br>def = cas<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> cas.List &#123;<br><span class="hljs-keyword">if</span> ir.ConstType(c) == constant.Unknown &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// can&#x27;t statically tell if it matches or not - give up.</span><br>&#125;<br><span class="hljs-keyword">if</span> constant.Compare(x, token.EQL, c.Val()) &#123;<br><span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> cas.Body &#123;<br><span class="hljs-keyword">if</span> n.Op() == ir.OFALL &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// fallthrough makes it complicated - abort.</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// This switch entry is the one that always triggers.</span><br><span class="hljs-keyword">for</span> _, cas2 := <span class="hljs-keyword">range</span> n.Cases &#123;<br><span class="hljs-keyword">for</span> _, c2 := <span class="hljs-keyword">range</span> cas2.List &#123;<br>ir.Visit(c2, markHiddenClosureDead)<br>&#125;<br><span class="hljs-keyword">if</span> cas2 != cas &#123;<br>ir.VisitList(cas2.Body, markHiddenClosureDead)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Rewrite to switch &#123; case true: ... &#125;</span><br>n.Tag = <span class="hljs-literal">nil</span><br>cas.List[<span class="hljs-number">0</span>] = ir.NewBool(c.Pos(), <span class="hljs-literal">true</span>)<br>cas.List = cas.List[:<span class="hljs-number">1</span>]<br>n.Cases[<span class="hljs-number">0</span>] = cas<br>n.Cases = n.Cases[:<span class="hljs-number">1</span>]<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> def != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> def.Body &#123;<br><span class="hljs-keyword">if</span> n.Op() == ir.OFALL &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// fallthrough makes it complicated - abort.</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br><span class="hljs-keyword">if</span> cas != def &#123;<br>ir.VisitList(cas.List, markHiddenClosureDead)<br>ir.VisitList(cas.Body, markHiddenClosureDead)<br>&#125;<br>&#125;<br>n.Cases[<span class="hljs-number">0</span>] = def<br>n.Cases = n.Cases[:<span class="hljs-number">1</span>]<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle case bodies ending with panic/return as we do in the IF case above.</span><br><br><span class="hljs-comment">// entire switch is a nop - no case ever triggers</span><br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br>ir.VisitList(cas.List, markHiddenClosureDead)<br>ir.VisitList(cas.Body, markHiddenClosureDead)<br>&#125;<br>n.Cases = n.Cases[:<span class="hljs-number">0</span>]<br>&#125;()<br>&#125;<br><br>        <span class="hljs-comment">// 3. 对节点的初始化语句递归调用 stmt 函数进行处理</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.Init()) != <span class="hljs-number">0</span> &#123;<br>stmts(n.(ir.InitNode).PtrInit())<br>&#125;<br>        <span class="hljs-comment">// 4. 遍历其他控制结构，递归处理它们的内部语句</span><br><span class="hljs-keyword">switch</span> n.Op() &#123;<br><span class="hljs-keyword">case</span> ir.OBLOCK:<br>n := n.(*ir.BlockStmt)<br>stmts(&amp;n.List)<br><span class="hljs-keyword">case</span> ir.OFOR:<br>n := n.(*ir.ForStmt)<br>stmts(&amp;n.Body)<br><span class="hljs-keyword">case</span> ir.OIF:<br>n := n.(*ir.IfStmt)<br>stmts(&amp;n.Body)<br>stmts(&amp;n.Else)<br><span class="hljs-keyword">case</span> ir.ORANGE:<br>n := n.(*ir.RangeStmt)<br>stmts(&amp;n.Body)<br><span class="hljs-keyword">case</span> ir.OSELECT:<br>n := n.(*ir.SelectStmt)<br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br>stmts(&amp;cas.Body)<br>&#125;<br><span class="hljs-keyword">case</span> ir.OSWITCH:<br>n := n.(*ir.SwitchStmt)<br><span class="hljs-keyword">for</span> _, cas := <span class="hljs-keyword">range</span> n.Cases &#123;<br>stmts(&amp;cas.Body)<br>&#125;<br>&#125;<br><br>        <span class="hljs-comment">// 5. 如果确定了是可以消除的代码，则对函数体进行阶段，且标记其中的闭包为死代码</span><br><span class="hljs-keyword">if</span> cut &#123;<br>ir.VisitList((*nn)[i+<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(*nn)], markHiddenClosureDead)<br>*nn = (*nn)[:i+<span class="hljs-number">1</span>]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>标记最后一个标签</strong>：遍历所有节点，记录最后一个标签（<code>OLABEL</code>）的位置。这对于后面判断是否可以安全地移除代码非常重要。</li><li><strong>处理 <code>if</code> 和 <code>switch</code> 语句</strong>：<ul><li>对于 <code>if</code>语句，它根据条件是否为常量来决定保留哪个分支，移除另一个分支。</li><li>对于 <code>switch</code> 语句，它尝试简化<code>switch</code>，根据条件值决定哪个分支将始终被执行。</li></ul></li><li><strong>节点初始化</strong>：如果节点有初始化语句，对这些初始化语句递归调用<code>stmts</code> 函数。</li><li><strong>遍历其他控制结构</strong>：对于<code>for</code>、<code>if</code>、<code>range</code>、<code>select</code>和 <code>switch</code> 等控制结构，递归地处理它们的内部语句。</li><li><strong>消除死代码</strong>：如果判断一个节点之后的所有代码都是无效的，它会标记这些代码为死代码并截断函数体。</li></ol><h2 id="去虚拟化">去虚拟化</h2><p>去虚拟化（Devirtualization）是编译器优化的一种技术，用于提高面向对象程序的性能。在面向对象编程中，方法调用通常是通过虚拟函数表（vtable）动态解析的，这被称为虚拟调用。虚拟调用允许对象在运行时表现出多态行为，但这也带来了一定的性能开销。</p><p>去虚拟化的目的是在编译时静态确定方法调用的目标，从而避免运行时的动态查找。如果编译器能够确定一个特定的接口调用总是调用同一个方法，它可以将这个虚拟调用替换为直接调用，减少运行时开销。这种优化特别适用于那些调用目标不会因为程序执行的不同路径而改变的情况。</p><p>这部分的代码在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/devirtualize/devirtualize.go">devirtuailze/devirtualize.go</a>。</p><p>核心就 2 个函数：</p><ul><li><code>Static()</code> ：遍历函数中的所有节点，尤其注意跳过在<code>go</code> 或 <code>defer</code>语句中的调用，并对其他接口方法调用尝试进行静态去虚拟化优化。</li><li><code>staticCall()</code>：针对一个具体的接口方法调用，如果可能，将其替换为直接的具体类型方法调用，以优化性能。</li></ul><h3 id="static">Static()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Static</span><span class="hljs-params">(fn *ir.Func)</span></span> &#123;<br>ir.CurFunc = fn<br>goDeferCall := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ir.CallExpr]<span class="hljs-type">bool</span>)<br>    <span class="hljs-comment">// 1. VisitList 对 fn.Body 中所有节点调用后面的 func</span><br>ir.VisitList(fn.Body, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n ir.Node)</span></span> &#123;<br><span class="hljs-keyword">switch</span> n := n.(<span class="hljs-keyword">type</span>) &#123;<br>        <span class="hljs-comment">// 2. 跳过 go 和 defer 语句</span><br><span class="hljs-keyword">case</span> *ir.GoDeferStmt:<br><span class="hljs-keyword">if</span> call, ok := n.Call.(*ir.CallExpr); ok &#123;<br>goDeferCall[call] = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span><br>        <span class="hljs-comment">// 3. 调用 staticCall 尝试进行去虚拟化</span><br><span class="hljs-keyword">case</span> *ir.CallExpr:<br><span class="hljs-keyword">if</span> !goDeferCall[n] &#123;<br>staticCall(n)<br>&#125;<br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>设定当前函数为 <code>fn</code>。</li><li>遍历函数体内的节点，特别注意 <code>go</code> 和 <code>defer</code>语句。如果调用发生在这些语句中，它会被跳过，因为去虚拟化可能改变程序的语义。</li><li>对于不在 <code>go</code> 或 <code>defer</code>语句中的接口方法调用，调用 <code>staticCall</code>函数尝试进行去虚拟化。</li></ol><h3 id="staticcall">staticCall()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">staticCall</span><span class="hljs-params">(call *ir.CallExpr)</span></span> &#123;<br>    <span class="hljs-comment">// 1. 检查调用是否为接口方法调用，如果不是，直接返回</span><br><span class="hljs-keyword">if</span> call.Op() != ir.OCALLINTER &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>    <br>    <span class="hljs-comment">// 2. 获取接收器和相关类型</span><br>sel := call.X.(*ir.SelectorExpr)<br>r := ir.StaticValue(sel.X)<br>    <br>     <span class="hljs-comment">// 3. 检查接收器是否是接口转换，如果不是，直接返回</span><br><span class="hljs-keyword">if</span> r.Op() != ir.OCONVIFACE &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>recv := r.(*ir.ConvExpr)<br><br>   <span class="hljs-comment">// 4. 提取接收器类型</span><br>typ := recv.X.Type()<br><span class="hljs-keyword">if</span> typ.IsInterface() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 5. shape 类型直接返回，因为这一般涉及到泛型，需要通过字典进行间接调用</span><br><span class="hljs-keyword">if</span> typ.IsShape() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> typ.HasShape() &#123;<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;cannot devirtualize %v: shaped receiver %v&quot;</span>, call, typ)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> sel.X.Type().HasShape() &#123;<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;cannot devirtualize %v: shaped interface %v&quot;</span>, call, sel.X.Type())<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>    <span class="hljs-comment">// 6. 类型断言和方法选择，尝试确定调用的具体方法</span><br>dt := ir.NewTypeAssertExpr(sel.Pos(), sel.X, <span class="hljs-literal">nil</span>)<br>dt.SetType(typ)<br>x := typecheck.Callee(ir.NewSelectorExpr(sel.Pos(), ir.OXDOT, dt, sel.Sel))<br><span class="hljs-keyword">switch</span> x.Op() &#123;<br><span class="hljs-keyword">case</span> ir.ODOTMETH:<br>x := x.(*ir.SelectorExpr)<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;devirtualizing %v to %v&quot;</span>, sel, typ)<br>&#125;<br>call.SetOp(ir.OCALLMETH)<br>call.X = x<br><span class="hljs-keyword">case</span> ir.ODOTINTER:<br>x := x.(*ir.SelectorExpr)<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;partially devirtualizing %v to %v&quot;</span>, sel, typ)<br>&#125;<br>call.SetOp(ir.OCALLINTER)<br>call.X = x<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(call.Pos(), <span class="hljs-string">&quot;failed to devirtualize %v (%v)&quot;</span>, x, x.Op())<br>&#125;<br><span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-comment">// 7. 根据类型断言的结果，尝试将接口方法调用转换为直接方法调用或保留为接口方法调用。</span><br>types.CheckSize(x.Type())<br><span class="hljs-keyword">switch</span> ft := x.Type(); ft.NumResults() &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>call.SetType(ft.Results().Field(<span class="hljs-number">0</span>).Type)<br><span class="hljs-keyword">default</span>:<br>call.SetType(ft.Results())<br>&#125;<br><br><span class="hljs-comment">// 8. 对可能修改后的方法调用进行进一步的类型检查和调整。</span><br>typecheck.FixMethodCall(call)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>检查是否为接口方法调用</strong>：函数首先判断传入的调用是否是接口方法调用（<code>ir.OCALLINTER</code>），这是去虚拟化的前提条件。</li><li><strong>处理形状类型</strong>：代码中提到，如果接收器的类型是形状类型（用于泛型），则无法去虚拟化，因为这需要通过字典进行间接调用。</li><li><strong>处理形状类型的接收器</strong>：如果接收器的类型具有形状类型，则当前无法进行去虚拟化。注释中还提到了一些待实现（TODO）的优化点，例如处理非泛型的提升方法。</li><li><strong>处理形状类型的接口</strong>：如果调用的接口本身是一个形状类型，由于指针身份的不同，类型断言可能会失败，因此在这种情况下也无法去虚拟化。</li><li><strong>转换方法调用</strong>：根据调用的具体情况，将接口方法调用转换为直接的方法调用（<code>OCALLMETH</code>）或保留为接口方法调用（<code>OCALLINTER</code>）。</li><li><strong>更新调用类型</strong>：为了正确处理函数返回值，需要更新调用的类型，确保参数大小和栈偏移量正确。</li><li><strong>反糖化方法调用</strong>：如果创建了直接方法调用，需要对其进行后续的类型检查和调整。</li></ol><h2 id="函数内联">函数内联</h2><p>函数内联是将一个函数的代码直接插入到每个调用点，而不是进行常规的函数调用。这意味着函数的整个体被复制到每个调用该函数的地方。</p><p>优点：</p><ul><li><strong>减少开销</strong>：内联消除了函数调用的开销，如参数传递、栈操作等。</li><li><strong>提升性能</strong>：有助于其他优化，比如循环展开、常量传播，因为编译器可以看到函数体内的代码。</li></ul><p>选择哪些函数内联：</p><ul><li><strong>小函数</strong>：通常是小函数，因为它们的内联带来的性能提升相对于代码膨胀的代价来说是值得的。</li><li><strong>调用频率高的函数</strong>：这些函数如果内联，可以显著减少运行时的调用开销。</li></ul><p>在 Go 语言中，可以通过 <code>//go:noinline</code>来禁止函数内联。</p><p>这部分的主要实现在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal~/inl.go">inline.inl.go</a>，核心函数是：<code>CanInline()</code>和 <code>InlineImpossible()</code>。</p><h3 id="caninline">CanInline()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Inlining budget parameters, gathered in one place</span><br><span class="hljs-keyword">const</span> (<br>    <span class="hljs-comment">// budget 是内联复杂度的衡量，</span><br>    <span class="hljs-comment">// 超过 80 表示编译器认为这个函数太复杂了，就不进行函数内联了</span><br>inlineMaxBudget       = <span class="hljs-number">80</span><br>)<br><br><span class="hljs-comment">// CanInline 用于判断 fn 是否可内联。</span><br><span class="hljs-comment">// 如果可以，会将 fn.Body 和 fn.Dcl 拷贝一份放到 fn.Inl，</span><br><span class="hljs-comment">// 其中 fn 和 fn.Body 需要确保已经经过类型检查了。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CanInline</span><span class="hljs-params">(fn *ir.Func, profile *pgo.Profile)</span></span> &#123;<br>    <br>    <span class="hljs-comment">// 函数名必须有效</span><br><span class="hljs-keyword">if</span> fn.Nname == <span class="hljs-literal">nil</span> &#123;<br>base.Fatalf(<span class="hljs-string">&quot;CanInline no nname %+v&quot;</span>, fn)<br>&#125;<br><br>    <span class="hljs-comment">// 如果不能内联，输出原因</span><br><span class="hljs-keyword">var</span> reason <span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> base.Flag.LowerM &gt; <span class="hljs-number">1</span> || logopt.Enabled() &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> reason != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">if</span> base.Flag.LowerM &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v: cannot inline %v: %s\n&quot;</span>, ir.Line(fn), fn.Nname, reason)<br>&#125;<br><span class="hljs-keyword">if</span> logopt.Enabled() &#123;<br>logopt.LogOpt(fn.Pos(), <span class="hljs-string">&quot;cannotInlineFunction&quot;</span>, <span class="hljs-string">&quot;inline&quot;</span>, ir.FuncName(fn), reason)<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br><br>    <span class="hljs-comment">// 检查是否符合不可能内联的情况，如果返回的 reason 不为空，则表示有不可以内联的原因</span><br>reason = InlineImpossible(fn)<br><span class="hljs-keyword">if</span> reason != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> fn.Typecheck() == <span class="hljs-number">0</span> &#123;<br>base.Fatalf(<span class="hljs-string">&quot;CanInline on non-typechecked function %v&quot;</span>, fn)<br>&#125;<br><br>n := fn.Nname<br><span class="hljs-keyword">if</span> n.Func.InlinabilityChecked() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> n.Func.SetInlinabilityChecked(<span class="hljs-literal">true</span>)<br><br>cc := <span class="hljs-type">int32</span>(inlineExtraCallCost)<br><span class="hljs-keyword">if</span> base.Flag.LowerL == <span class="hljs-number">4</span> &#123;<br>cc = <span class="hljs-number">1</span> <span class="hljs-comment">// this appears to yield better performance than 0.</span><br>&#125;<br><br><span class="hljs-comment">// 设置内联预算，后面如果检查函数的复杂度超过预算了，就不内联了</span><br>budget := <span class="hljs-type">int32</span>(inlineMaxBudget)<br><span class="hljs-keyword">if</span> profile != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> n, ok := profile.WeightedCG.IRNodes[ir.LinkFuncName(fn)]; ok &#123;<br><span class="hljs-keyword">if</span> _, ok := candHotCalleeMap[n]; ok &#123;<br>budget = <span class="hljs-type">int32</span>(inlineHotMaxBudget)<br><span class="hljs-keyword">if</span> base.Debug.PGODebug &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;hot-node enabled increased budget=%v for func=%v\n&quot;</span>, budget, ir.PkgFuncName(fn))<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 遍历函数体，计算复杂度，判断是否超过内联预算</span><br>visitor := hairyVisitor&#123;<br>curFunc:       fn,<br>budget:        budget,<br>maxBudget:     budget,<br>extraCallCost: cc,<br>profile:       profile,<br>&#125;<br><span class="hljs-keyword">if</span> visitor.tooHairy(fn) &#123;<br>reason = visitor.reason<br><span class="hljs-keyword">return</span><br>&#125;<br><br>    <span class="hljs-comment">// 前面检查都没问题，则标记为可以内联，并复制其函数体和声明到内联结构体中</span><br>n.Func.Inl = &amp;ir.Inline&#123;<br>Cost: budget - visitor.budget,<br>Dcl:  pruneUnusedAutos(n.Defn.(*ir.Func).Dcl, &amp;visitor),<br>Body: inlcopylist(fn.Body),<br><br>CanDelayResults: canDelayResults(fn),<br>&#125;<br><br>    <span class="hljs-comment">// 日志和调试</span><br><span class="hljs-keyword">if</span> base.Flag.LowerM &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v: can inline %v with cost %d as: %v &#123; %v &#125;\n&quot;</span>, ir.Line(fn), n, budget-visitor.budget, fn.Type(), ir.Nodes(n.Func.Inl.Body))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> base.Flag.LowerM != <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v: can inline %v\n&quot;</span>, ir.Line(fn), n)<br>&#125;<br><span class="hljs-keyword">if</span> logopt.Enabled() &#123;<br>logopt.LogOpt(fn.Pos(), <span class="hljs-string">&quot;canInlineFunction&quot;</span>, <span class="hljs-string">&quot;inline&quot;</span>, ir.FuncName(fn), fmt.Sprintf(<span class="hljs-string">&quot;cost: %d&quot;</span>, budget-visitor.budget))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>基本检查</strong>：验证函数是否已经进行了类型检查，以及函数名是否有效。</li><li><strong>判断是否可以内联</strong>：调用<code>InlineImpossible</code>函数来检查是否有任何基本的限制条件阻止内联（例如函数太大、递归等）。</li><li><strong>内联预算设置</strong>：根据函数的特征和可能的性能剖析信息来设定内联预算。这个预算是内联决策的关键参数之一。</li><li><strong>详细分析</strong>：<code>hairyVisitor</code>结构用于遍历函数体，判断是否超出了内联预算。这涉及对函数体的复杂度和大小的评估。</li><li><strong>内联决策</strong>：如果函数通过了所有检查并且未超出预算，则标记为可以内联，并复制其函数体和声明（Dcl）到内联结构体中。</li><li><strong>日志和调试</strong>：根据编译器的日志级别，输出关于内联决策的详细信息，例如为什么一个函数不能被内联或者它的内联成本是多少。</li></ol><h3 id="inlineimpossible">InlineImpossible()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InlineImpossible</span><span class="hljs-params">(fn *ir.Func)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> reason <span class="hljs-type">string</span> <span class="hljs-comment">// reason, if any, that the function can not be inlined.</span><br><span class="hljs-keyword">if</span> fn.Nname == <span class="hljs-literal">nil</span> &#123;<br>reason = <span class="hljs-string">&quot;no name&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked &quot;go:noinline&quot;, don&#x27;t inline.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.Noinline != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:noinline&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked &quot;go:norace&quot; and -race compilation, don&#x27;t inline.</span><br><span class="hljs-keyword">if</span> base.Flag.Race &amp;&amp; fn.Pragma&amp;ir.Norace != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:norace with -race compilation&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked &quot;go:nocheckptr&quot; and -d checkptr compilation, don&#x27;t inline.</span><br><span class="hljs-keyword">if</span> base.Debug.Checkptr != <span class="hljs-number">0</span> &amp;&amp; fn.Pragma&amp;ir.NoCheckPtr != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:nocheckptr&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked &quot;go:cgo_unsafe_args&quot;, don&#x27;t inline, since the function</span><br><span class="hljs-comment">// makes assumptions about its argument frame layout.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.CgoUnsafeArgs != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:cgo_unsafe_args&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked as &quot;go:uintptrkeepalive&quot;, don&#x27;t inline, since the keep</span><br><span class="hljs-comment">// alive information is lost during inlining.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// TODO(prattmic): This is handled on calls during escape analysis,</span><br><span class="hljs-comment">// which is after inlining. Move prior to inlining so the keep-alive is</span><br><span class="hljs-comment">// maintained after inlining.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.UintptrKeepAlive != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked as having a keep-alive uintptr argument&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If marked as &quot;go:uintptrescapes&quot;, don&#x27;t inline, since the escape</span><br><span class="hljs-comment">// information is lost during inlining.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.UintptrEscapes != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked as having an escaping uintptr argument&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// The nowritebarrierrec checker currently works at function</span><br><span class="hljs-comment">// granularity, so inlining yeswritebarrierrec functions can confuse it</span><br><span class="hljs-comment">// (#22342). As a workaround, disallow inlining them for now.</span><br><span class="hljs-keyword">if</span> fn.Pragma&amp;ir.Yeswritebarrierrec != <span class="hljs-number">0</span> &#123;<br>reason = <span class="hljs-string">&quot;marked go:yeswritebarrierrec&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If a local function has no fn.Body (is defined outside of Go), cannot inline it.</span><br><span class="hljs-comment">// Imported functions don&#x27;t have fn.Body but might have inline body in fn.Inl.</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fn.Body) == <span class="hljs-number">0</span> &amp;&amp; !typecheck.HaveInlineBody(fn) &#123;<br>reason = <span class="hljs-string">&quot;no function body&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-comment">// If fn is synthetic hash or eq function, cannot inline it.</span><br><span class="hljs-comment">// The function is not generated in Unified IR frontend at this moment.</span><br><span class="hljs-keyword">if</span> ir.IsEqOrHashFunc(fn) &#123;<br>reason = <span class="hljs-string">&quot;type eq/hash function&quot;</span><br><span class="hljs-keyword">return</span> reason<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>无函数名</strong>：如果函数没有名字，不能内联。</li><li><strong>有 <code>go:noinline</code>指令</strong>：显式标记为不内联。</li><li><strong>有 <code>go:norace</code> 指令并在 <code>-race</code>编译模式下</strong>：在竞态检测编译模式下不内联标记为<code>norace</code> 的函数。</li><li><strong>有 <code>go:nocheckptr</code> 指令并在<code>-d checkptr</code>编译模式下</strong>：在指针检查编译模式下不内联标记为<code>nocheckptr</code> 的函数。</li><li><strong>有 <code>go:cgo_unsafe_args</code> 指令</strong>：对于标记为<code>cgo_unsafe_args</code> 的函数，由于参数布局的假设，不内联。</li><li><strong>有 <code>go:uintptrkeepalive</code>指令</strong>：不内联标记为 <code>uintptrkeepalive</code> 的函数。</li><li><strong>有 <code>go:uintptrescapes</code>指令</strong>：不内联标记为 <code>uintptrescapes</code> 的函数。</li><li><strong>有 <code>go:yeswritebarrierrec</code>指令</strong>：为了防止写屏障记录检查器的混淆，不内联标记为<code>yeswritebarrierrec</code> 的函数。</li><li><strong>无函数体</strong>：本地定义但没有函数体的函数（外部定义的 Go函数）不可内联。</li><li><strong>是合成的 hash 或 eq函数</strong>：不能内联这些类型的函数。</li></ol><h3 id="举例-1">举例</h3><p>我们通过一段代码来看看编译器的函数内联情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SayHello</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>s := <span class="hljs-string">&quot;hello, &quot;</span> + <span class="hljs-string">&quot;world&quot;</span><br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fib</span><span class="hljs-params">(index <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> index<br>&#125;<br><span class="hljs-keyword">return</span> Fib(index<span class="hljs-number">-1</span>) + Fib(index<span class="hljs-number">-2</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ForSearch</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> s = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;<br>res := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br><span class="hljs-keyword">if</span> s[i] == i &#123;<br>res = i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>SayHello()<br>Fib(<span class="hljs-number">65</span>)<br>ForSearch()<br>&#125;<br></code></pre></td></tr></table></figure><p>在编译时我们可以加入 <code>-m=2</code>标签，来打印函数的内联调试信息。在 <code>main.go</code> 目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -m=2 main.go<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">main.go:3:6: can inline SayHello with cost 7 as: func() string &#123; s := <span class="hljs-string">&quot;hello, &quot;</span> + <span class="hljs-string">&quot;world&quot;</span>; <span class="hljs-built_in">return</span> s &#125;<br>main.go:8:6: cannot inline Fib: recursive<br>main.go:15:6: can inline ForSearch with cost 45 as: func() int &#123; s := []int&#123;...&#125;; res := 0; <span class="hljs-keyword">for</span> loop; <span class="hljs-built_in">return</span> res &#125;<br>main.go:26:6: cannot inline main: <span class="hljs-keyword">function</span> too complex: cost 116 exceeds budget 80<br>main.go:27:10: inlining call to SayHello<br>main.go:29:11: inlining call to ForSearch<br>main.go:16:15: []int&#123;...&#125; does not escape<br>main.go:29:11: []int&#123;...&#125; does not escape<br></code></pre></td></tr></table></figure><p>可以看到 <code>SayHello()</code> 和 <code>ForSearch</code>都被内联了，而 <code>Fib()</code> 因为有递归，所以不会被内联。</p><h2 id="逃逸分析">逃逸分析</h2><p>逃逸分析是 Go语言中非常重要的优化阶段，<strong>用于标识变量内存应该被分配在栈上还是堆上</strong>。</p><p>在传统的 C 或 C++开发中，开发者经常会犯的错误就是函数返回了一个栈上的对象指针，在函数执行完毕后，函数栈会被销毁，如果继续访问被销毁栈上的对象指针，那么就会出现问题。</p><p>Go语言能够通过编译时的逃逸分析识别这种问题，自动将这类变量放置到堆区，并借助Go运行时的垃圾回收机制自动释放内存。编译器会尽可能地将变量放置在栈上，因为栈中的对象会随着函数调用结束被自动销毁，这可以减轻运行时分配和垃圾回收的负担。</p><p>在 Go语言中，开发者模糊了栈区和堆区的区别，不管是字符串、数组字面量，还是通过new、make标识符创建的对象，都既可能被分配到栈上，也可能被分配到堆上。但是，整体上会遵循2 个原则：</p><ol type="1"><li>指向栈上对象的指针不能被存储到堆上；</li><li>指向栈上对象的指针不能超过该栈对象的生命周期。</li></ol><p>这部分的代码主要在 <ahref="https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile/internal/escape">escape</a>。</p><h3 id="分析过程">分析过程</h3><p>Go 语言通过对 AST 的静态数据流分析来实现逃逸分析（<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/escape/graph.go">escape/graph.go</a>），在这个过程，它会构建带权重的有向图，其中权重可以表面当前变量引用和解引用的数量。</p><ul><li>引用（&amp;a） 减 1</li><li>解引用（*a）加 1</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k hole)</span></span> deref(where ir.Node, why <span class="hljs-type">string</span>) hole &#123; <span class="hljs-keyword">return</span> k.shift(<span class="hljs-number">1</span>).note(where, why) &#125; <span class="hljs-comment">// 解引用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k hole)</span></span> addr(where ir.Node, why <span class="hljs-type">string</span>) hole  &#123; <span class="hljs-keyword">return</span> k.shift(<span class="hljs-number">-1</span>).note(where, why) &#125; <span class="hljs-comment">// 引用</span><br></code></pre></td></tr></table></figure><p>具体来说，Go逃逸分析会按照如下规则生成数据流图（带权重的有向图）：</p><ol type="1"><li>每个变量作为一个节点（location）；</li><li>每个赋值动作是一个有向边（edge），赋值给谁则指向谁；</li><li>解引用（deref），即 <code>*</code>操作会给边的权重 +1；</li><li>引用（addr），即 <code>&amp;</code> 操作会给边权重 -1。</li></ol><p>其中：<strong>节点权重 = 指向的节点权重 + 边权重</strong></p><p>逃逸分析的目标就是<strong>找到其中节点权重为 -1的变量</strong>，并结合上述提到的 2个原则，来判断要不要将变量分配到堆上。</p><h3 id="分析实例">分析实例</h3><p>我们举一个例子来进行分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">var</span> o *<span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>l := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>) <br>*l = <span class="hljs-number">42</span><br>m := &amp;l<br>n := &amp;m<br>o = **n<br>&#125;<br></code></pre></td></tr></table></figure><p>再次回顾一下，<code>*</code> 是加 1，<code>&amp;</code>是减一。按照常规思路，我们从上往下分析：</p><p>先画出节点的赋值顺序，赋值给谁，边就指向谁：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203193913047.png"alt="第1步：梳理节点顺序" /><figcaption aria-hidden="true">第1步：梳理节点顺序</figcaption></figure><p>然后根据引用和解引用给边赋权重，因为 <code>new(int)</code>其实就是分配一个 <code>int(0)</code> 并取地址，相当于<code>&amp;</code>，所以指向 <code>l</code> 的边权重是<code>-1</code>：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203194101882.png"alt="第2步：给边赋值" /><figcaption aria-hidden="true">第2步：给边赋值</figcaption></figure><p>节点权重 = 边权重 + 指向节点权重，因为没有对 <code>o</code>变量进行任何的操作，所以 <code>o</code> 权重为0，从右往左推可以得到：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203194432349.png"alt="第3步：计算节点权重" /><figcaption aria-hidden="true">第3步：计算节点权重</figcaption></figure><p>经过分析，我们就找到了节点权重为 <code>-1</code> 的节点<code>new(int)</code>，又由于它的节点变量地址最终会被传递到变量<code>o</code> 上，结合之前的 2 个原则，<code>o</code>是一个全局变量，声明周期是超过函数栈的，所以 <code>new(int)</code>会被分配到堆上。</p><p>可以执行下面语句输出逃逸结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -m main.go<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/escape/main.go:5:6: can inline main<br>/escape/main.go:6:10: new(int) escapes to hea<br></code></pre></td></tr></table></figure><p>也可以执行下面语句输出数据流图构建过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -gcflags=<span class="hljs-string">&quot;-m -m -l&quot;</span> main.go<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># command-line-arguments</span><br>./main.go:6:10: new(int) escapes to heap:<br>./main.go:6:10:   flow: l = &amp;&#123;storage <span class="hljs-keyword">for</span> new(int)&#125;:<br>./main.go:6:10:     from new(int) (spill) at ./main.go:6:10<br>./main.go:6:10:     from l := new(int) (assign) at ./main.go:6:4<br>./main.go:6:10:   flow: m = &amp;l:<br>./main.go:6:10:     from &amp;l (address-of) at ./main.go:8:7<br>./main.go:6:10:     from m := &amp;l (assign) at ./main.go:8:4<br>./main.go:6:10:   flow: n = &amp;m:<br>./main.go:6:10:     from &amp;m (address-of) at ./main.go:9:7<br>./main.go:6:10:     from n := &amp;m (assign) at ./main.go:9:4<br>./main.go:6:10:   flow: &#123;heap&#125; = **n:<br>./main.go:6:10:     from *n (indirection) at ./main.go:10:7<br>./main.go:6:10:     from *(*n) (indirection) at ./main.go:10:6<br>./main.go:6:10:     from o = *(*n) (assign) at ./main.go:10:4<br>./main.go:6:10: new(int) escapes to heap<br></code></pre></td></tr></table></figure><p>如果我们试一下，把 <code>o</code> 放在 <code>main()</code>里面呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> o *<span class="hljs-type">int</span><br>l := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>*l = <span class="hljs-number">42</span><br>m := &amp;l <br>n := &amp;m <br>o = **n <br>o = o   <span class="hljs-comment">// 让编译通过</span><br>&#125;<br></code></pre></td></tr></table></figure><p>执行下面语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -m main.go<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/escape/main.go:3:6: can inline main<br>/escape/main.go:5:10: new(int) does not escape<br></code></pre></td></tr></table></figure><p>如我们所想，虽然 <code>new(int)</code> 的权重为<code>-1</code>，但是它的声明周期始终没有超过<code>main()</code>，所以没必要逃逸到堆上。</p><h2 id="变量捕获">变量捕获</h2><p>变量捕获主要是针对闭包（closure）场景而言的，由于闭包函数中可能引用闭包外的变量，因此变量捕获需要明确在闭包中通过值引用或者地址引用的方式来捕获变量。</p><p>这一过程在前面提到的逃逸分析过程中进行，具体实现在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/escape/escape.go">escape/escape.go</a>的 <code>flowClosure()</code> 函数中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *batch)</span></span> flowClosure(k hole, clo *ir.ClosureExpr) &#123;<br>    <span class="hljs-comment">// 遍历闭包中的所有变量</span><br>    <span class="hljs-keyword">for</span> _, cv := <span class="hljs-keyword">range</span> clo.Func.ClosureVars &#123;<br>        n := cv.Canonical()<br>        loc := b.oldLoc(cv)<br>        <span class="hljs-comment">// 如果变量未被捕获，则触发错误</span><br>        <span class="hljs-keyword">if</span> !loc.captured &#123;<br>            base.FatalfAt(cv.Pos(), <span class="hljs-string">&quot;closure variable never captured: %v&quot;</span>, cv)<br>        &#125;<br><br>        <span class="hljs-comment">// 根据变量的特性决定是通过值还是引用捕获</span><br>        <span class="hljs-comment">// 如果变量未被重新赋值或取址，并且小于等于 128 字节，则通过值捕获</span><br>        n.SetByval(!loc.addrtaken &amp;&amp; !loc.reassigned &amp;&amp; n.Type().Size() &lt;= <span class="hljs-number">128</span>)<br>        <span class="hljs-keyword">if</span> !n.Byval() &#123;<br>            n.SetAddrtaken(<span class="hljs-literal">true</span>)<br>            <span class="hljs-comment">// 特殊情况处理：字典变量不通过值捕获</span><br>            <span class="hljs-keyword">if</span> n.Sym().Name == typecheck.LocalDictName &#123;<br>                base.FatalfAt(n.Pos(), <span class="hljs-string">&quot;dictionary variable not captured by value&quot;</span>)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 记录闭包捕获变量的方式（值或引用）</span><br>        <span class="hljs-keyword">if</span> base.Flag.LowerM &gt; <span class="hljs-number">1</span> &#123;<br>            how := <span class="hljs-string">&quot;ref&quot;</span><br>            <span class="hljs-keyword">if</span> n.Byval() &#123;<br>                how = <span class="hljs-string">&quot;value&quot;</span><br>            &#125;<br>            base.WarnfAt(n.Pos(), <span class="hljs-string">&quot;%v capturing by %s: %v (addr=%v assign=%v width=%d)&quot;</span>, n.Curfn, how, n, loc.addrtaken, loc.reassigned, n.Type().Size())<br>        &#125;<br><br>        <span class="hljs-comment">// 建立闭包变量的数据流</span><br>        k := k<br>        <span class="hljs-keyword">if</span> !cv.Byval() &#123;<br>            k = k.addr(cv, <span class="hljs-string">&quot;reference&quot;</span>)<br>        &#125;<br>        b.flow(k.note(cv, <span class="hljs-string">&quot;captured by a closure&quot;</span>), loc)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">1</span><br>b := <span class="hljs-number">2</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>add(a, b)<br>&#125;()<br>a = <span class="hljs-number">99</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>a = a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>执行下面语句看看变量的捕获方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go tool compile -m=2 main.go  | grep <span class="hljs-string">&quot;capturing&quot;</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">main.go:4:2: main capturing by ref: a (addr=<span class="hljs-literal">false</span> assign=<span class="hljs-literal">true</span> width=8)<br>main.go:5:2: main capturing by value: b (addr=<span class="hljs-literal">false</span> assign=<span class="hljs-literal">false</span> width=8)<br></code></pre></td></tr></table></figure><p>可以看到 <code>a</code> 是通过 <code>ref 地址引用</code>的方式进行引用的，而 <code>b</code> 是通过 <code>value 值传递</code>的方式进行引用的。</p><p>简单分析一下：上述例子中，闭包引用了 <code>a</code> 和 <code>b</code>这 2 个闭包外声明的变量，而变量 <code>a</code>在闭包之前又做了一些其他的操作，而 b 没有，所以对于<code>a</code>，因为闭包外有操作，所以闭包内的操作可能是有特殊意义的，需要反馈到闭包外，就需要用<code>ref 地址引用</code>了，而 <code>b</code>在闭包外并不关心，所以闭包内的操作不会影响到闭包外，故直接使用<code>value 值传递</code> 即可。</p><h2 id="闭包重写">闭包重写</h2><p>逃逸分析后，现在我们进入 <code>walk</code>阶段了。这里首先会进行闭包重写。其核心逻辑在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/walk/closure.go">walk/closure.go</a>中。</p><p>闭包重写分为 2 种情况：</p><ul><li>闭包定义后被立即调用</li><li>闭包定义后不立即调用</li></ul><h3 id="闭包定义后被立即调用">闭包定义后被立即调用</h3><p>在闭包定义后被立即调用的情况下，闭包只会被调用一次，这时可以将闭包转换为普通函数的调用形式。</p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">1</span><br>b := <span class="hljs-number">2</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>add(a, b)<br>&#125;()<br>a = <span class="hljs-number">99</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>a = a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>会被转换为普通函数的调用形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">1</span><br>b := <span class="hljs-number">2</span><br><span class="hljs-keyword">go</span> func1(&amp;a, b)<br>a = <span class="hljs-number">99</span><br>&#125;<br><br><span class="hljs-comment">// 注意这里 a 的类型的 *int，因为在变量捕获阶段，判断了 a 应该用地址引用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">(a *<span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> &#123;<br>add(*a, b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>a = a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器具体的处理逻辑在 <code>directClosureCall()</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// directClosureCall rewrites a direct call of a function literal into</span><br><span class="hljs-comment">// a normal function call with closure variables passed as arguments.</span><br><span class="hljs-comment">// This avoids allocation of a closure object.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For illustration, the following call:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//func(a int) &#123;</span><br><span class="hljs-comment">//println(byval)</span><br><span class="hljs-comment">//byref++</span><br><span class="hljs-comment">//&#125;(42)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// becomes:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//func(byval int, &amp;byref *int, a int) &#123;</span><br><span class="hljs-comment">//println(byval)</span><br><span class="hljs-comment">//(*&amp;byref)++</span><br><span class="hljs-comment">//&#125;(byval, &amp;byref, 42)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directClosureCall</span><span class="hljs-params">(n *ir.CallExpr)</span></span> &#123;<br>clo := n.X.(*ir.ClosureExpr)<br>clofn := clo.Func<br><br>    <span class="hljs-comment">// 如果闭包足够简单，不进行处理，留给 walkClosure 处理。</span><br><span class="hljs-keyword">if</span> ir.IsTrivialClosure(clo) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-comment">// leave for walkClosure to handle</span><br>&#125;<br><br><span class="hljs-comment">// 将闭包中的每个变量转换为函数的参数。对于引用捕获的变量，创建相应的指针参数。</span><br><span class="hljs-keyword">var</span> params []*types.Field<br><span class="hljs-keyword">var</span> decls []*ir.Name<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> clofn.ClosureVars &#123;<br><span class="hljs-keyword">if</span> !v.Byval() &#123;<br><span class="hljs-comment">// 对于引用捕获的变量，创建相应的指针参数。</span><br>addr := ir.NewNameAt(clofn.Pos(), typecheck.Lookup(<span class="hljs-string">&quot;&amp;&quot;</span>+v.Sym().Name))<br>addr.Curfn = clofn<br>addr.SetType(types.NewPtr(v.Type()))<br>v.Heapaddr = addr<br>v = addr<br>&#125;<br><br>v.Class = ir.PPARAM<br>decls = <span class="hljs-built_in">append</span>(decls, v)<br><br>fld := types.NewField(src.NoXPos, v.Sym(), v.Type())<br>fld.Nname = v<br>params = <span class="hljs-built_in">append</span>(params, fld)<br>&#125;<br><br><span class="hljs-comment">// 创建一个新的函数类型，将捕获的变量作为前置参数，并更新函数的声明。</span><br>f := clofn.Nname<br>typ := f.Type()<br>typ = types.NewSignature(<span class="hljs-literal">nil</span>, <span class="hljs-built_in">append</span>(params, typ.Params().FieldSlice()...), typ.Results().FieldSlice())<br>f.SetType(typ)<br>clofn.Dcl = <span class="hljs-built_in">append</span>(decls, clofn.Dcl...)<br><br><span class="hljs-comment">// 将原始的闭包调用重写为对新函数的调用，并将捕获的变量作为实际参数传递。</span><br>n.X = f<br>n.Args.Prepend(closureArgs(clo)...)<br><br><span class="hljs-comment">// 调整调用表达式的类型，以反映参数和返回值类型的变化。</span><br><span class="hljs-keyword">if</span> typ.NumResults() == <span class="hljs-number">1</span> &#123;<br>n.SetType(typ.Results().Field(<span class="hljs-number">0</span>).Type)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>n.SetType(typ.Results())<br>&#125;<br><br><span class="hljs-comment">// 虽然不再是传统意义上的闭包，但为了确保函数被编译，将其添加到待编译列表中。</span><br>ir.CurFunc.Closures = <span class="hljs-built_in">append</span>(ir.CurFunc.Closures, clofn)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是 Go 编译器中的 <code>directClosureCall</code>函数，用于将直接调用的函数字面量重写为正常的函数调用，同时将闭包变量作为参数传递。这避免了闭包对象的分配。</p><p>主要步骤如下：</p><ol type="1"><li><strong>检查闭包是否简单</strong>：如果闭包足够简单，不进行处理，留给<code>walkClosure</code> 处理。</li><li><strong>处理闭包变量</strong>：将闭包中的每个变量转换为函数的参数。对于引用捕获的变量，创建相应的指针参数。</li><li><strong>更新函数类型和声明</strong>：创建一个新的函数类型，将捕获的变量作为前置参数，并更新函数的声明。</li><li><strong>重写调用</strong>：将原始的闭包调用重写为对新函数的调用，并将捕获的变量作为实际参数传递。</li><li><strong>更新调用表达式类型</strong>：调整调用表达式的类型，以反映参数和返回值类型的变化。</li><li><strong>添加到待编译列表</strong>：虽然不再是传统意义上的闭包，但为了确保函数被编译，将其添加到待编译列表中。</li></ol><p>这个函数的目的是优化闭包的调用，通过避免闭包对象的分配来提高性能。</p><h3 id="闭包定义后不立即调用">闭包定义后不立即调用</h3><p>如果闭包定义后不被立即调用，而是后续调用，那么同一个闭包可能会被调用多次，这个时候就必须创建闭包对象了。</p><p>编译器具体的处理逻辑在 <code>walkClosure()</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkClosure</span><span class="hljs-params">(clo *ir.ClosureExpr, init *ir.Nodes)</span></span> ir.Node &#123;<br>clofn := clo.Func<br><br><span class="hljs-comment">// 如果没有闭包变量，闭包被视为全局函数，直接返回函数名。</span><br><span class="hljs-keyword">if</span> ir.IsTrivialClosure(clo) &#123;<br><span class="hljs-keyword">if</span> base.Debug.Closure &gt; <span class="hljs-number">0</span> &#123;<br>base.WarnfAt(clo.Pos(), <span class="hljs-string">&quot;closure converted to global&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> clofn.Nname<br>&#125;<br><br><span class="hljs-comment">// 对于复杂闭包，设置需要上下文标记，并进行运行时检查。</span><br>ir.ClosureDebugRuntimeCheck(clo)<br>clofn.SetNeedctxt(<span class="hljs-literal">true</span>)<br><br><span class="hljs-comment">// 确保闭包函数不会被重复添加到编译队列。</span><br><span class="hljs-keyword">if</span> !clofn.Walked() &#123;<br>clofn.SetWalked(<span class="hljs-literal">true</span>)<br>ir.CurFunc.Closures = <span class="hljs-built_in">append</span>(ir.CurFunc.Closures, clofn)<br>&#125;<br><br><span class="hljs-comment">// 构造一个复合字面量表达式来表示闭包实例。</span><br>typ := typecheck.ClosureType(clo)<br><br>    <span class="hljs-comment">// 将闭包函数和捕获的变量作为字段添加到闭包结构中。</span><br>clos := ir.NewCompLitExpr(base.Pos, ir.OCOMPLIT, typ, <span class="hljs-literal">nil</span>)<br>clos.SetEsc(clo.Esc())<br>clos.List = <span class="hljs-built_in">append</span>([]ir.Node&#123;ir.NewUnaryExpr(base.Pos, ir.OCFUNC, clofn.Nname)&#125;, closureArgs(clo)...)<br><span class="hljs-keyword">for</span> i, value := <span class="hljs-keyword">range</span> clos.List &#123;<br>clos.List[i] = ir.NewStructKeyExpr(base.Pos, typ.Field(i), value)<br>&#125;<br><br>    <span class="hljs-comment">// 创建闭包结构的地址，并进行类型转换以符合闭包类型。</span><br>addr := typecheck.NodAddr(clos)<br>addr.SetEsc(clo.Esc())<br>cfn := typecheck.ConvNop(addr, clo.Type())<br><br><span class="hljs-comment">// 如果存在预分配的闭包对象，进行相关处理。</span><br><span class="hljs-keyword">if</span> x := clo.Prealloc; x != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !types.Identical(typ, x.Type()) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;closure type does not match order&#x27;s assigned type&quot;</span>)<br>&#125;<br>addr.Prealloc = x<br>clo.Prealloc = <span class="hljs-literal">nil</span><br>&#125;<br><br>    <span class="hljs-comment">// 对最终构建的闭包表达式进行进一步处理。</span><br><span class="hljs-keyword">return</span> walkExpr(cfn, init)<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><strong>检查是否为简单闭包</strong>：如果没有闭包变量，闭包被视为全局函数，直接返回函数名。</li><li><strong>处理非简单闭包</strong>：对于复杂闭包，设置需要上下文标记，并进行运行时检查。</li><li><strong>防止重复处理</strong>：确保闭包函数不会被重复添加到编译队列。</li><li><strong>创建闭包结构</strong>：构造一个复合字面量表达式来表示闭包实例。</li><li><strong>填充闭包参数</strong>：将闭包函数和捕获的变量作为字段添加到闭包结构中。</li><li><strong>地址和类型转换</strong>：创建闭包结构的地址，并进行类型转换以符合闭包类型。</li><li><strong>处理预分配的闭包</strong>：如果存在预分配的闭包对象，进行相关处理。</li><li><strong>表达式处理</strong>：对最终构建的闭包表达式进行进一步处理。</li></ol><h2 id="遍历函数">遍历函数</h2><p>闭包重写后，会进入 walk 阶段，如官方 文档所说：这是对 IR表示的最后一次遍历，它有两个目的：</p><ol type="1"><li>将复杂的语句分解为简单的单个语句，引入临时变量并遵守求值顺序；</li><li>将高级 Go 构造转换为更原始的构造。</li></ol><p>举个例子，<code>walkRange()</code> 函数针对不同类型的<code>range</code>语句（数组、切片、映射、通道和字符串）进行处理，将其转换为更基本的循环结构，并应用必要的变换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkRange</span><span class="hljs-params">(nrange *ir.RangeStmt)</span></span> ir.Node &#123;<br>    <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 遍历 range 语句的不同情况</span><br>    <span class="hljs-keyword">switch</span> t.Kind() &#123;<br>    <span class="hljs-keyword">default</span>:<br>        base.Fatalf(<span class="hljs-string">&quot;walkRange&quot;</span>)<br><br>    <span class="hljs-comment">// 处理数组、切片、指针（指向数组）的情况</span><br>    <span class="hljs-keyword">case</span> types.TARRAY, types.TSLICE, types.TPTR:<br>        <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 处理映射的情况</span><br>    <span class="hljs-keyword">case</span> types.TMAP:<br>        <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 处理通道的情况</span><br>    <span class="hljs-keyword">case</span> types.TCHAN:<br>        <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 处理字符串的情况</span><br>    <span class="hljs-keyword">case</span> types.TSTRING:<br>        <span class="hljs-comment">// ... 省略代码 ...</span><br>    &#125;<br><br>    <span class="hljs-comment">// ... 省略代码 ...</span><br><br>    <span class="hljs-comment">// 构建并返回新的 for 语句</span><br>    nfor.PtrInit().Append(init...)<br>    typecheck.Stmts(nfor.Cond.Init())<br>    nfor.Cond = typecheck.Expr(nfor.Cond)<br>    nfor.Cond = typecheck.DefaultLit(nfor.Cond, <span class="hljs-literal">nil</span>)<br>    nfor.Post = typecheck.Stmt(nfor.Post)<br>    typecheck.Stmts(body)<br>    nfor.Body.Append(body...)<br>    nfor.Body.Append(nrange.Body...)<br><br>    <span class="hljs-keyword">var</span> n ir.Node = nfor<br>    n = walkStmt(n)<br><br>    base.Pos = lno<br>    <span class="hljs-keyword">return</span> n<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分代码在 <ahref="https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile/internal/walk">walk</a>，对其他优化感兴趣的读者可以阅读这部分的代码。</p><h2 id="ssa-生成">SSA 生成</h2><p>遍历函数（Walk）阶段后，编译器会将 AST转换为下一个重要的中间表示形态，称为 SSA，其全称为 Static SingleAssignment，静态单赋值。SSA 被大多数现代的编译器（包括 GCC 和LLVM）使用，用于编译过程中的优化和代码生成。其核心特点和用途如下：</p><ol type="1"><li><strong>变量唯一赋值</strong>：在 SSA形式中，每个变量只被赋值一次，使得变量的使用和修改更加清晰。</li><li><strong>方便的数据流分析</strong>：SSA使得数据流分析更加直接和高效，因为每个变量的赋值点只有一个。</li><li><strong>优化算法的基础</strong>：许多编译器优化技术，如死代码消除、常量传播、强度削减等，在SSA 形式下更易实现。</li><li><strong>Phi 函数</strong>：SSA 引入了 Phi函数来处理变量在不同控制流路径上的不同赋值。</li><li><strong>代码生成</strong>：SSA形式简化了目标代码生成的过程，因为它提供了更清晰的操作和变量使用视图。</li></ol><p>官方对 SSA 生成阶段进行了详细的描述：<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/ssa/README.md">Introductionto the Go compiler's SSA backend</a></p><p>Go 提供了强有力的工具查看 SSA初始及其后续优化阶段生成的代码片段，可以通过编译时指定<code>GOSSAFUNC=&#123;pkg.func&#125;</code> 实现。</p><p>以下面代码为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">var</span> d <span class="hljs-type">uint8</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">uint8</span> = <span class="hljs-number">1</span><br>a = <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>a = <span class="hljs-number">3</span><br>&#125;<br>d = a<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以自行简单分析一下，这段代码前面 <code>a</code>的所有操作其实都是无意义的，整段代码其实就在说 <code>d = 3</code>这件事。</p><p>在 linux 或者 mac 上执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">GOSSAFUNC=main.main <span class="hljs-keyword">go</span> build main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>在 Windows 上执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$env:GOSSAFUNC</span>=<span class="hljs-string">&quot;main&quot;</span><br>go build .\main.go<br></code></pre></td></tr></table></figure><p>可以看到输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">dumped SSA to .\ssa.html<br></code></pre></td></tr></table></figure><p>通过浏览器打开生成的 <code>ssa.html</code> 文件，我们可以看到 SSA的初始阶段、优化阶段和最终阶段的代码片段。</p><figure><img src="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/ssa.png"alt="ssa.html 文件示例" /><figcaption aria-hidden="true">ssa.html 文件示例</figcaption></figure><p>我们直接看最终的结果，来看看我们前面的分析正确与否：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231203211001137.png"alt="ssa 最终结果" /><figcaption aria-hidden="true">ssa 最终结果</figcaption></figure><p>可以看到这一行：<code>00003 (**+11**) MOVB $3, main.d(SB)</code>，那其实就是直接<code>d = 3</code>。</p><h2 id="机器码生成">机器码生成</h2><p>在 SSA阶段，编译器先执行与特定指令集无关的优化，再执行与特定指令集有关的优化，并最终生成与特定指令集有关的指令和寄存器分配方式。如<ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/ssa/_gen/genericOps.go">ssa/_gen/genericOps.go</a>中包含了与特定指令集无关的 Op 操作，在 <ahref="https://github.com/golang/go/blob/release-branch.go1.21/src/cmd/compile/internal/ssa/_gen/S390XOps.go">ssa/_gen/AMD64Ops.go</a>中包含了和 AMD64 指令集相关的 Op 操作。</p><p>机器码生成阶段是编译器的机器依赖阶段，主要过程如下：</p><ol type="1"><li><strong>Lowering 过程</strong>：这个过程将通用的 SSA形式转换为特定于目标机器的变体。这包括将通用操作符替换为针对特定硬件优化的操作。</li><li><strong>代码优化</strong>：在机器特定的形式上执行最终优化，进一步提高代码效率。</li><li><strong>生成机器指令</strong>：将 Go 函数转换为<code>obj.Prog</code> 指令序列。</li><li><strong>汇编和输出</strong>：这些指令由<code>cmd/internal/obj</code>模块的汇编器处理，转换为机器代码，并输出最终的目标文件。</li></ol><p>Go 为我们了解 Go语言程序的编译和链接过程提供了一个非常好用的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -n<br></code></pre></td></tr></table></figure><p>其中 <code>-n</code> 表示<strong>只输出编译过程中将要执行的 shell命令，但不执行</strong>。</p><p>以下面程序为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/spf13/cast&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := cast.ToInt(<span class="hljs-string">&quot;1&quot;</span>)<br>fmt.Println(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序引入了标准库 <code>fmt</code> 以及第三方库<code>github.com/spf13/cast</code>。</p><p>在工程目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build -n -o main<br></code></pre></td></tr></table></figure><p>可以看到输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$WORK</span>/b001/<br><span class="hljs-built_in">cat</span> &gt;<span class="hljs-variable">$WORK</span>/b001/importcfg.link &lt;&lt; <span class="hljs-string">&#x27;EOF&#x27;</span> <span class="hljs-comment"># internal</span><br>packagefile go-compilation=/Users/wangjiahan/Library/Caches/go-build/48/48745ff5ef7f8945297b5894ec377f47e246d94739e0b8f00e86b6d58879e71d-d<br>packagefile <span class="hljs-built_in">fmt</span>=/Users/wangjiahan/Library/Caches/go-build/10/10ab74ff0df27a2f4bdbe7651290f13ad466f3df63e11241e07ccd21c169b206-d<br>packagefile github.com/spf13/cast=/Users/wangjiahan/Library/Caches/go-build/77/77eed0b7028cfc4c90d78d6670325d982325399573dff9d7f82ffbf76e4559e8-d<br>...<br>packagefile net/url=/Users/wangjiahan/Library/Caches/go-build/72/72d0ef9b8f99a52bf1de760bb2f630998d6bb66a3d2a3fa66bd66f4efddfbc71-d<br>modinfo <span class="hljs-string">&quot;0w\xaf\f\x92t\b\x02A\xe1\xc1\a\xe6\xd6\x18\xe6path\tgo-compilation\nmod\tgo-compilation\t(devel)\t\ndep\tgithub.com/spf13/cast\tv1.6.0\th1:GEiTHELF+vaR5dhz3VqZfFSzZjYbgeKDpBxQVS4GYJ0=\nbuild\t-buildmode=exe\nbuild\t-compiler=gc\nbuild\tCGO_ENABLED=1\nbuild\tCGO_CFLAGS=\nbuild\tCGO_CPPFLAGS=\nbuild\tCGO_CXXFLAGS=\nbuild\tCGO_LDFLAGS=\nbuild\tGOARCH=arm64\nbuild\tGOOS=darwin\n\xf92C1\x86\x18 r\x00\x82B\x10A\x16\xd8\xf2&quot;</span><br>EOF<br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$WORK</span>/b001/exe/<br><span class="hljs-built_in">cd</span> .<br>/opt/homebrew/opt/go/libexec/pkg/tool/darwin_arm64/link -o <span class="hljs-variable">$WORK</span>/b001/exe/a.out -importcfg <span class="hljs-variable">$WORK</span>/b001/importcfg.link -buildmode=pie -buildid=FDJiS-4glijTlqBbjVbe/UWsngURatTblImv3DE6-/OjO-hZGekrr-XpHFs_zA/FDJiS-4glijTlqBbjVbe -extld=cc /Users/wangjiahan/Library/Caches/go-build/48/48745ff5ef7f8945297b5894ec377f47e246d94739e0b8f00e86b6d58879e71d-d<br>/opt/homebrew/opt/go/libexec/pkg/tool/darwin_arm64/buildid -w <span class="hljs-variable">$WORK</span>/b001/exe/a.out <span class="hljs-comment"># internal</span><br><span class="hljs-built_in">mv</span> <span class="hljs-variable">$WORK</span>/b001/exe/a.out main<br></code></pre></td></tr></table></figure><p>这里建议你先尝试自行分析一下这个编译过程，再继续往下阅读。</p><p>经过分析，上述过程可以分为以下 8 个步骤：</p><ol type="1"><li><strong>创建工作目录</strong>：<code>mkdir -p $WORK/b001/</code>创建一个临时工作目录，用于存放编译过程中的临时文件。</li><li><strong>生成导入配置文件</strong>：<code>cat &gt;$WORK/b001/importcfg.link &lt;&lt; 'EOF'</code>命令开始创建一个名为 <code>importcfg.link</code>的文件，这个文件包含了编译过程中需要的包文件路径。</li><li><strong>写入包文件路径</strong>：接下来的多行内容是对<code>importcfg.link</code>文件的填充，指定了各个依赖包的存储位置。</li><li><strong>结束文件写入</strong>：<code>EOF</code> 标志着<code>importcfg.link</code> 文件内容的结束。</li><li><strong>创建可执行文件目录</strong>：<code>mkdir -p $WORK/b001/exe/</code>创建一个目录，用于存放最终的可执行文件。</li><li><strong>编译链接</strong>：<code>/opt/homebrew/opt/go/libexec/pkg/tool/darwin_arm64/link -o $WORK/b001/exe/a.out ...</code>这一步是编译链接的核心，它使用Go的链接工具，根据之前生成的<code>importcfg.link</code> 文件，将代码编译成可执行文件。</li><li><strong>更新构建ID</strong>：<code>/opt/homebrew/opt/go/libexec/pkg/tool/darwin_arm64/buildid -w $WORK/b001/exe/a.out</code>这一步更新了可执行文件的构建ID。</li><li><strong>移动可执行文件</strong>：<code>mv $WORK/b001/exe/a.out main</code>将编译好的可执行文件移动到当前目录，并重命名为 <code>main</code>。</li></ol><p>如下图所示：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img6sR2uDuHwbkSNk3FuUxHmY-20231129143014805.png"alt="Go语言编译和链接过程" /><figcaption aria-hidden="true">Go语言编译和链接过程</figcaption></figure><h2 id="参考资料">参考资料</h2><ul><li><ahref="https://github.com/golang/go/tree/release-branch.go1.21/src/cmd/compile">Go1.21官方文档</a></li><li><a href="https://book.douban.com/subject/35556889/">《Go语言底层原理剖析》</a></li><li><ahref="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/">《Go语言设计与实现》</a></li><li><ahref="https://medium.com/a-journey-with-go/go-overview-of-the-compiler-4e5a153ca889">Go:Overview of the Compiler</a></li><li><ahref="https://en.wikipedia.org/wiki/Abstract_syntax_tree">维基百科 -AST</a></li><li><ahref="https://en.wikipedia.org/wiki/Static_single-assignment_form">维基百科- SSA</a></li><li><a href="https://zhuanlan.zhihu.com/p/592602585">Go机制：逃逸分析学习笔记</a></li><li>ChatGPT-4</li></ul><hr /><p>以上便是 Go 语言在 1.21.0这个版本下编译过程的整个过程，笔者会在阅读完《用 Go语言自制解释器》和《用 Go语言自制编译器》这两本书后，若有对编译原理有更深入的体会和感悟，再回过来对本文的内容进行勘误和进一步提炼。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 顺序消息实现</title>
    <link href="/2023/11/23/kafka-ordered-msg/"/>
    <url>/2023/11/23/kafka-ordered-msg/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><p>本文所有的讨论均在如下版本进行，其他版本可能会有所不同。</p><ul><li>Kafka: 3.6.0</li><li>Pulsar: 2.9.0</li><li>RabbitMQ 3.7.8</li><li>RocketMQ 5.0</li><li>Go1.21</li><li>github.com/segmentio/kafka-go v0.4.45</li></ul><h2 id="结论先行">结论先行</h2><p>Kafka只能保证单一分区内的顺序消息，无法保证多分区间的顺序消息。具体来说，要在Kafka 完全实现顺序消息，至少需要保证以下几个条件：</p><ol type="1"><li>同一生产者生产消息；</li><li>同步发送消息到 Kafka broker；</li><li>所有消息发布到同一个分区；</li><li>同一消费者同步按照顺序消费消息。</li></ol><p>而要满足第 3 点，常用的有 2 种思路：</p><ol type="1"><li>固定消息的 key，生产端采用 <code>key hash</code> 的方式写入broker；</li><li>自定义分区策略，要保证顺序的消息都写入到指定的分区。</li></ol><h2 id="消息队列中的顺序消息如何实现">消息队列中的顺序消息如何实现</h2><h3 id="顺序消息定义">顺序消息定义</h3><p>生产端发送出来的消息的顺序和消费端接收到消息的顺序是一样的。</p><h3 id="消息存储结构">消息存储结构</h3><p>一般来说，消息队列都是基于<strong>顺序存储结构</strong>来存储数据的，不需要B 树、B+树等复杂数据结构，利用文件的顺序读写，性能也很高。所以理想情况下，生产者按顺序发送消息，broker会按顺序存储消息，消费者再按顺序消费消息，那么天然就实现了我们要的<strong>顺序消息</strong>了，如下：</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231124235214392.png"alt="消息队列顺序存储结构" /><figcaption aria-hidden="true">消息队列顺序存储结构</figcaption></figure><h3 id="基本条件">基本条件</h3><p>但是一般情况下，消息队列为了支持更高的并发和吞吐，大多数都有分区（partition）和消费者组（consumergroup）机制，而为了高可用，一般也会有副本（replica）机制，所以情况就复杂得多了，如下面几个例子，就会导致消息失序：</p><ol type="1"><li>多个生产者同时发送消息，那么到达 broker 的时间也是不确定的，所以broker 就无法保证落盘的顺序性了；</li><li>单个生产者，但是采用异步发送，因为异步线程是并发执行的，由 CPU进行调度，且有可能会因为发送失败而重试，所以也无法保证消息可以按照顺序到达broker，同理，消费者异步处理消息，也无法保证顺序性；</li><li>一个 topic有多个分区，那么即使是同一个生产者，由于分区策略，消息可能会被分发到多个分区中，消费者也就无法保证顺序性了。</li></ol><p>所以到这里，我们可以总结出实现顺序消息，至少需要满足以下 3 点：</p><ol type="1"><li>单一生产者同步发送；</li><li>单一分区；</li><li>单一消费者同步消费；</li></ol><p>第 1、3 点比较简单，Kafka 通过分区和 offset的方式保证了消息的顺序。每个分区都是一个有序的、不可变的消息序列，每个消息在分区中都有一个唯一的序数标识，称为<code>offset</code>。生产者在发送消息到分区时，Kafka会自动为消息分配一个 offset。消费者在读取消息时，会按照 offset的顺序来读取，从而保证了消息的顺序。</p><p>下面我们主要来谈一谈第 2 点。</p><h2 id="kafka-顺序消息的实现">Kafka 顺序消息的实现</h2><h3 id="写入消息的过程">写入消息的过程</h3><ol type="1"><li><strong>配置生产者</strong>：首先，你需要配置 Kafka生产者。这包括指定 Kafka集群的地址和端口，以及其他相关配置项，如消息序列化器、分区策略等。</li><li><strong>创建生产者实例</strong>：在应用程序中，你需要创建一个 Kafka生产者的实例。这个实例将用于与 Kafka 集群进行通信。</li><li><strong>序列化消息</strong>：在将消息发送到 Kafka集群之前，你需要将消息进行序列化。Kafka使用字节数组来表示消息的内容，因此你需要将消息对象序列化为字节数组。这通常涉及将消息对象转换为JSON、Avro、Protobuf 等格式。</li><li><strong>选择分区</strong>：Kafka的主题（topic）被分为多个分区（partition），每个分区都是有序且持久化的消息日志。当你发送消息时，你可以选择将消息发送到特定的分区，或者让Kafka 根据分区策略自动选择分区。</li><li><strong>发送消息</strong>：一旦消息被序列化并选择了目标分区，你可以使用Kafka 生产者的 <code>send()</code> 方法将消息发送到 Kafka集群。发送消息时，生产者会将消息发送到对应分区的 leader 副本。</li><li><strong>异步发送</strong>：Kafka生产者通常使用异步方式发送消息，这样可以提高吞吐量。生产者将消息添加到一个发送缓冲区（sendbuffer）中，并在后台线程中批量发送消息到 Kafka 集群。</li><li><strong>消息持久化</strong>：一旦消息被发送到 Kafka 集群的 leader副本，它将被持久化并复制到其他副本，以确保数据的高可靠性和冗余性。只有当消息被成功写入到指定数量的副本后，生产者才会收到确认（acknowledgement）。</li><li><strong>错误处理和重试</strong>：如果发送消息时发生错误，生产者可以根据配置进行错误处理和重试。你可以设置重试次数、重试间隔等参数来控制重试行为。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231125013322459.png"alt="Kafka 生产者组件 -《Kafka权威指南第2版》" /><figcaption aria-hidden="true">Kafka 生产者组件-《Kafka权威指南第2版》</figcaption></figure><h3 id="实现单一分区">实现单一分区</h3><p>再 Kafka 中，我们要实现将消息写入到同一个分区，有 3 种思路：</p><ul><li>配置 <code>num.partitions=1</code> 或者创建 topic 的时候指定只有 1个分区，但这会显著降低 Kafka 的吞吐量。</li><li><strong>固定消息的 key</strong>，然后采用 <strong>key hash</strong>的分区策略，这样就可以让所有消息都被分到同一个分区中。</li><li>实现并指定<strong>自定义分区策略</strong>，可以根据业务需求，将需要顺序消费的消息都分到固定一个分区中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如下例子，所有使用&quot;same-key&quot;作为key的消息都会被发送到同一个Partition</span><br>ProducerRecord&lt;String, String&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="hljs-string">&quot;topic&quot;</span>, <span class="hljs-string">&quot;same-key&quot;</span>, <span class="hljs-string">&quot;message&quot;</span>);<br>producer.send(record);<br></code></pre></td></tr></table></figure><h3 id="重平衡带来的问题">重平衡带来的问题</h3><p>如果采用上述的第 2 种思路：<strong>固定消息 key，依靠 key hash分区策略，实现单一分区</strong>。在我们只有 1个消费者的情况下是没有问题的，但是如果我们使用的是消费者组，那么，在发生<strong>重平衡</strong>操作的时候，就可能会有问题了。</p><p>Kafka 的重平衡（Rebalance）是指 Kafka 消费者组（ConsumerGroup）中的消费者实例对分区的重新分配。这个过程主要发生在以下几种情况：</p><ol type="1"><li>消费者组中新的消费者加入。</li><li>消费者组中的消费者离开或者挂掉。</li><li>订阅的 Topic 的分区数发生变化。</li><li>消费者调用了 <code>#unsubscribe()</code> 或者<code>#subscribe()</code> 方法。</li></ol><p>重平衡的过程主要包括以下几个步骤：</p><ol type="1"><li><strong>Revoke</strong>：首先，Kafka会撤销消费者组中所有消费者当前持有的分区。</li><li><strong>Assignment</strong>：然后，Kafka会重新计算分区的分配情况，然后将分区分配给消费者。</li><li><strong>Resume</strong>：最后，消费者会开始消费新分配到的分区。</li></ol><p>重平衡的目的是为了保证消费者组中的消费者能够公平地消费 Topic的分区。通过重平衡，Kafka可以在消费者的数量发生变化时，动态地调整消费者对分区的分配，从而实现负载均衡。</p><p>然而，当发生重平衡时，分区可能会被重新分配给不同的消费者，这可能会影响消息的消费顺序。</p><p>举个例子：</p><ol type="1"><li>假设消费者 A 正在消费分区 P 的消息，它已经消费了消息 1，消息2，正在处理消息 3。</li><li>此时，发生了重平衡，分区 P 被重新分配给了消费者 B。</li><li>消费者 B 开始消费分区P，它会从上一次提交的偏移量（offset）开始消费。假设消费者 A 在处理消息 3时发生了故障，没有提交偏移量，那么消费者 B 会从消息 3 开始消费。</li><li>这样，消息 3 可能会被消费两次，而且如果消费者 B 处理消息 3的速度快于消费者A，那么消息 3 可能会在消息 2之后被处理，这就打破了消息的顺序性。</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img/image-20231125003222491.png"alt="重平衡导致消息失序" /><figcaption aria-hidden="true">重平衡导致消息失序</figcaption></figure><p>再举个例子：</p><ol type="1"><li>topic-A 本来只有 3 个分区，按照 key hash，key 为<code>same-key</code> 的消息应该都发到 第 2 个分区；</li><li>但是后来 topic-A 变成了 4 个分区，按照 key hash，key 为<code>same-key</code> 的消息可能就被发到第 3 个分区了；</li><li>这就无法做到单一分区，可能会导致消息失序。</li></ol><p>当然这个例子不是由重平衡直接引起的，但是这种情况也是有可能导致消息失序的。</p><h3 id="缓解重平衡的问题">缓解重平衡的问题</h3><ul><li><strong>避免动态改变分区数</strong>：在需要严格保持消息顺序的场景下，应避免动态地改变分区数。这意味着在设计Kafka 主题时，应提前规划好所需的分区数，以避免日后需要进行更改。</li><li><strong>使用单个分区</strong>：对于严格顺序要求的场景，可以考虑使用单分区主题。虽然这会限制吞吐量和并发性，但可以保证消息的全局顺序。</li><li><strong>使用其他策略保持顺序</strong>：在某些情况下，可以通过在应用层实现逻辑来保持顺序，比如在消息中包含顺序号或时间戳，并在消费时根据这些信息重建正确的顺序。</li><li><strong>使用静态成员功能</strong>：它允许消费者在断开和重新连接时保持其消费者组内的身份，这可以减少因短暂的网络问题或消费者重启导致的不必要的重平衡。</li></ul><p>上面这些措施，只能减少重平衡带来的问题，并无法根除，如果非要实现严格意义上的顺序消息，要么在消息中加入时间戳等标记，在业务层保证顺序消费，要么就只能采用<code>单一生产者同步发送 + 单一分区 +单一消费者同步消费</code>这种模式了。</p><h3 id="静态成员功能">静态成员功能</h3><p>Kafka 2.3.0 版本引入了一项新功能：静态成员（StaticMembership）。这个功能主要是为了减少由于消费者重平衡（rebalance）引起的开销和延迟。在传统的Kafka消费者组中，当新的消费者加入或离开消费者组时，会触发重平衡。这个过程可能会导致消息的处理延迟，并且在高吞吐量的场景下可能会对性能造成影响。静态成员功能旨在缓解这些问题。以下是它的一些关键点：</p><p>静态成员的工作原理：</p><ol type="1"><li><p><strong>静态成员标识</strong>：消费者在加入消费者组时可以提供一个静态成员标识（StaticMember ID）。这允许 Kafka Broker识别特定的消费者实例，而不是仅仅依赖于消费者组内的动态分配。</p></li><li><p><strong>重平衡优化</strong>：当使用静态成员功能时，如果一个已知的消费者由于某种原因（如网络问题）短暂断开后重新连接，Kafka不会立即触发重平衡。相反，Kafka会等待一个预设的超时期限（session.timeout.ms），在此期间如果消费者重新连接，它将保留原来的分区分配。</p></li><li><p><strong>减少重平衡次数</strong>：这大大减少了由于消费者崩溃和恢复、网络问题或维护操作引起的不必要的重平衡次数。</p></li></ol><p>使用静态成员的优点：</p><ol type="1"><li><p><strong>提高稳定性</strong>：减少重平衡可以提高消费者组的整体稳定性，尤其是在大型消费者组和高吞吐量的情况下。</p></li><li><p><strong>减少延迟</strong>：由于减少了重平衡的次数，可以减少因重平衡导致的消息处理延迟。</p></li><li><p><strong>持久的消费者分区分配</strong>：这使得消费者在分区分配上更加持久，有助于更好地管理和优化消息的消费。</p></li></ol><p>如何使用：</p><ul><li>要使用静态成员功能，需要在 Kafka 消费者的配置中设置<code>group.instance.id</code>。这个 ID应该是唯一的，并且在消费者重启或重新连接时保持不变。同时，还需要配置<code>session.timeout.ms</code>，以决定在触发重平衡之前消费者可以离线多长时间。</li></ul><p>注意事项：</p><ul><li>虽然静态成员功能可以减少重平衡的发生，但它不会完全消除重平衡。在消费者组成员的长期变化（如新消费者的加入或永久离开）时，仍然会发生重平衡。</li><li>需要合理设置<code>session.timeout.ms</code>，以避免消费者由于短暂的网络问题或其他原因的断开而过早触发重平衡。</li></ul><p>静态成员功能在处理大规模 Kafka应用时尤其有用，它提供了一种机制来优化消费者组的性能和稳定性。</p><h3 id="幂等性">幂等性</h3><p>Kafka 0.11版本后提供了幂等性生产者，这意味着即使生产者因为某些错误重试发送相同的消息，这些消息也只会被记录一次。这是通过给每一批发送到Kafka 的消息分配一个序列号实现的，broker使用这个序列号来删除重复发送的消息。使用幂等性生产者，可以减少重复消息的风险，这意味着即使在网络重试等情况下，消息的顺序也能得到更好的保证。因为重复消息不会被多次记录，所以不会破坏已有消息的顺序。</p><h2id="其他常见消息队列顺序消息的实现">其他常见消息队列顺序消息的实现</h2><h3 id="pulsar">Pulsar</h3><p>Pulsar 和 Kafka 一样，都是通过生产端按 Key Hash的方案将数据写入到同一个分区。</p><h3 id="rabbitmq">RabbitMQ</h3><p>RabbitMQ 在生产时没有生产分区分配的过程。它是通过<code>Exchange</code> 和 <code>Route Key</code>机制来实现顺序消息的。<code>Exchange</code> 会根据设置好的<code>Route Key</code> 将数据路由到不同的 <code>Queue</code>中存储。此时 <code>Route Key</code> 的作用和 Kafka 的消息的<code>Key</code> 是一样的。</p><h3 id="rocketmq">RocketMQ</h3><p>RocektMQ支持<code>消息组（MessageGroup）</code>的概念。在生产端指定消息组，则同一个消息组的消息就会被发送到同一个分区中。此时这个消息组起到的作用和Kakfa 的消息的 Key 是一样的。</p><h2 id="实战-kafka-实现顺序消息">实战 Kafka 实现顺序消息</h2><blockquote><p>代码仓库：https://github.com/hedon954/kafka-go-examples/tree/master/orderedmsg</p></blockquote><p>下面我们来写一写实战用例，更加直观地感受一下 Kafka顺序消息的实现细节。</p><p>首先我们在集群上创建一个 topic <code>ordered-msg-topic</code>，分区为<code>3</code> 个，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic ordered-msg-topic --partitions 3 --replication-factor 1<br></code></pre></td></tr></table></figure><p>搭建 Kafka 集群可以看这两篇：<ahref="https://hedon.top/2023/11/22/kakfa-cluster-deploy/">Kafka集群搭建(Zookeeper)</a>、<ahref="https://hedon.top/2023/11/22/kafka-kraft-deploy/">Kafka集群搭建(KRaft)</a>。</p><h3 id="单生产者单消费者">单生产者单消费者</h3><p>正常情况下，使用单一生产者同步发送和单一消费者同步发送，只要我们保证key 是固定的，则所有消息都会写到同一个分区，是可以实现顺序消息的。</p><p>代码目录如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">├─config<br>│      config.go<span class="hljs-comment"># 常量定义</span><br>├─consumer<br>│      consumer.go<span class="hljs-comment"># 消费者</span><br>└─producer<br>        producer.go<span class="hljs-comment"># 生产者</span><br></code></pre></td></tr></table></figure><p>首先我们先定义一些常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/segmentio/kafka-go&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>Topic      = <span class="hljs-string">&quot;ordered-msg-topic&quot;</span><br>Brokers    = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;kafka1.com:9092&quot;</span>, <span class="hljs-string">&quot;kafka2.com:9092&quot;</span>, <span class="hljs-string">&quot;kafka3.com:9092&quot;</span>&#125;<br>Addr       = kafka.TCP(Brokers...)<br>GroupId    = <span class="hljs-string">&quot;ordered-msg-group&quot;</span><br>MessageKey = []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;message-key&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p>我们先实现生产者端，主要是不断往 <code>ordered-msg-topic</code>中写入数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;kafka-go-examples/orderedmsg/config&quot;</span><br><br><span class="hljs-string">&quot;github.com/segmentio/kafka-go&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewProducer</span><span class="hljs-params">()</span></span> *kafka.Writer &#123;<br><span class="hljs-keyword">return</span> &amp;kafka.Writer&#123;<br>Addr:     config.Addr,<br>Topic:    config.Topic,<br>Balancer: &amp;kafka.Hash&#123;&#125;, <span class="hljs-comment">// 哈希分区</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMessages</span><span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span> []kafka.Message &#123;<br>res := <span class="hljs-built_in">make</span>([]kafka.Message, count)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>res[i] = kafka.Message&#123;<br>Key:   config.MessageKey,<br>Value: []<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;msg-%d&quot;</span>, i+<span class="hljs-number">1</span>)),<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>producer := NewProducer()<br>messages := NewMessages(<span class="hljs-number">100</span>)<br><span class="hljs-keyword">if</span> err := producer.WriteMessages(context.Background(), messages...); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>_ = producer.Close()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来实现消费者，目前我们就启动 1 个消费者：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;kafka-go-examples/orderedmsg/config&quot;</span><br><br><span class="hljs-string">&quot;github.com/segmentio/kafka-go&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Consumer <span class="hljs-keyword">struct</span> &#123;<br>Id <span class="hljs-type">string</span><br>*kafka.Reader<br>&#125;<br><br><span class="hljs-comment">// NewConsumer 创建一个消费者，它属于 config.GroupId 这个消费者组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewConsumer</span><span class="hljs-params">(id <span class="hljs-type">string</span>)</span></span> *Consumer &#123;<br>c := &amp;Consumer&#123;<br>Id: id,<br>Reader: kafka.NewReader(kafka.ReaderConfig&#123;<br>Brokers: config.Brokers,<br>GroupID: config.GroupId,<br>Topic:   config.Topic,<br>Dialer: &amp;kafka.Dialer&#123;<br>ClientID: id,<br>&#125;,<br>&#125;),<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// Read 读取消息，intervalMs 用来控制消费者的消费速度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Consumer)</span></span> Read(intervalMs <span class="hljs-type">int</span>) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s start read\n&quot;</span>, c.Id)<br><span class="hljs-keyword">for</span> &#123;<br>msg, err := c.ReadMessage(context.Background())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s read msg err: %v\n&quot;</span>, c.Id, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 模拟消费速度</span><br>time.Sleep(time.Millisecond * time.Duration(intervalMs))<br>fmt.Printf(<span class="hljs-string">&quot;%s read msg: %s, time: %s\n&quot;</span>, c.Id, <span class="hljs-type">string</span>(msg.Value), time.Now().Format(<span class="hljs-string">&quot;03-04-05&quot;</span>))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c1 := NewConsumer(<span class="hljs-string">&quot;consumer-1&quot;</span>)<br>c1.Read(<span class="hljs-number">500</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>启动生产者生产消息，然后启动消费者，观察控制台，不难看出这种情况下就是顺序消费：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">consumer-1 read msg: msg-10, time: 04:29:10<br>consumer-1 read msg: msg-11, time: 04:29:11<br>consumer-1 read msg: msg-12, time: 04:29:12<br>consumer-1 read msg: msg-13, time: 04:29:13<br>consumer-1 read msg: msg-14, time: 04:29:14<br>consumer-1 read msg: msg-15, time: 04:29:15<br>consumer-1 read msg: msg-16, time: 04:29:16<br></code></pre></td></tr></table></figure><h3 id="重平衡带来的问题-1">重平衡带来的问题</h3><p>我们先重建 topic，清楚掉之前的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --delete --topic ordered-msg-topic<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic ordered-msg-topic --partitions 3 --replication-factor 1<br></code></pre></td></tr></table></figure><p>下面我们来采用消费者组的形式消费消息，在这期间，我们不断往消费者组中新增消费者，使其发生重平衡，我们来观察下消息的消费情况。</p><p>修改消费者端的 main()：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 先启动 c1</span><br>c1 := NewConsumer(<span class="hljs-string">&quot;consumer-1&quot;</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c1.Read(<span class="hljs-number">500</span>)<br>&#125;()<br><br><span class="hljs-comment">// 5 秒后启动 c2</span><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c2 := NewConsumer(<span class="hljs-string">&quot;consumer-2&quot;</span>)<br>c2.Read(<span class="hljs-number">300</span>)<br>&#125;()<br><br><span class="hljs-comment">// 再 10 秒后启动 c3 和 c4</span><br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c3 := NewConsumer(<span class="hljs-string">&quot;consumer-3&quot;</span>)<br>c3.Read(<span class="hljs-number">100</span>)<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c4 := NewConsumer(<span class="hljs-string">&quot;consumer-4&quot;</span>)<br>c4.Read(<span class="hljs-number">100</span>)<br>&#125;()<br><br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先启动生产者重新生产数据，然后再启动消费者消费数据，观察控制台：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">consumer-1 start <span class="hljs-built_in">read</span><br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-1, time: 04:44:28<br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-2, time: 04:44:28<br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-3, time: 04:44:29<span class="hljs-comment"># consumer-1 按顺序消费</span><br>consumer-2 start <span class="hljs-built_in">read</span>  <span class="hljs-comment"># consumer-2 进来</span><br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-4, time: 04:44:30<br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-5, time: 04:44:30<br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-6, time: 04:44:31      <span class="hljs-comment"># 这里相差了 6s，就是在进行重平衡</span><br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-7, time: 04:44:37      <span class="hljs-comment"># 重平衡后发现原来的分区给 consumer-2 消费了</span><br>consumer-1 <span class="hljs-built_in">read</span> msg: msg-7, time: 04:44:37    <span class="hljs-comment"># 这里发生了重复消费</span><br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-8, time: 04:44:37<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-9, time: 04:44:37<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-10, time: 04:44:38<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-11, time: 04:44:38<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-12, time: 04:44:38<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-13, time: 04:44:39<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-14, time: 04:44:39<br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-15, time: 04:44:39      <span class="hljs-comment"># consumer-2 按顺序消息</span><br>consumer-4 start <span class="hljs-built_in">read</span>   <span class="hljs-comment"># consumer-3 和 consumer-4 进来</span><br>consumer-3 start <span class="hljs-built_in">read</span><br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-16, time: 04:44:40   <br>consumer-4 <span class="hljs-built_in">read</span> msg: msg-17, time: 04:44:46      <span class="hljs-comment"># 这里发生重平衡</span><br>consumer-4 <span class="hljs-built_in">read</span> msg: msg-18, time: 04:44:46      <span class="hljs-comment"># 重平衡后由 consumer-4 负责该分区</span><br>consumer-2 <span class="hljs-built_in">read</span> msg: msg-17, time: 04:44:46      <span class="hljs-comment"># 这里由于 2 的速度比 4 慢很多，所以就乱序了，还重复消费</span><br>consumer-4 <span class="hljs-built_in">read</span> msg: msg-19, time: 04:44:46<br>consumer-4 <span class="hljs-built_in">read</span> msg: msg-20, time: 04:44:46<br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>当我们采用消费者组的时候，由于重平衡机制的存在，单纯从 Kafka的角度来说是无法完全实现顺序消息的，只能通过静态成员功能、避免分区数量变化和减少消费者组成员数量变化等方式来尽可能减少重平衡的发生，进而尽可能维持消息的顺序性。</p><h2 id="参考">参考</h2><ul><li><a href="https://time.geekbang.com/column/intro/100552001">极客时间- 深入拆解消息队列 47 讲（许文强）</a></li><li><a href="https://www.qidian.com/book/1035938080/">《Kafka权威指南（第 2 版）》</a></li><li><ahref="https://pulsar.staged.apache.org/docs/zh-CN/next/concepts-messaging/#%E9%A1%BA%E5%BA%8F%E4%BF%9D%E8%AF%81">Pulsar官方文档-分区topic-顺序保证</a></li><li><ahref="https://rocketmq.apache.org/zh/docs/featureBehavior/03fifomessage">RocketMQ官方文档-功能特性-顺序消息</a></li><li><ahref="https://www.rabbitmq.com/tutorials/tutorial-two-go.html">RabbitMQ官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 集群部署（KRaft）</title>
    <link href="/2023/11/22/kafka-kraft-deploy/"/>
    <url>/2023/11/22/kafka-kraft-deploy/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><ul><li>Ubuntu 18.04.6</li><li>Kafka 3.6.0</li><li>JDK8</li></ul><h2 id="集群配置">集群配置</h2><table><thead><tr class="header"><th style="text-align: center;">操作系统</th><th style="text-align: center;">ip</th><th style="text-align: center;">域名</th><th style="text-align: center;">Kafka Broker 端口</th><th style="text-align: center;">Kafka Controller 端口</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.131</td><td style="text-align: center;">kafka1.com</td><td style="text-align: center;">9092</td><td style="text-align: center;">9093</td></tr><tr class="even"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.132</td><td style="text-align: center;">kafka2.com</td><td style="text-align: center;">9092</td><td style="text-align: center;">9093</td></tr><tr class="odd"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.133</td><td style="text-align: center;">kafka3.com</td><td style="text-align: center;">9092</td><td style="text-align: center;">9093</td></tr></tbody></table><h2 id="安装-vim-curl">安装 vim, curl</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install vim<br>sudo apt install curl<br></code></pre></td></tr></table></figure><h2 id="配置静态-ip-和-hosts">配置静态 ip 和 hosts</h2><p>为了使用域名，更加方便的进行配置，这里将虚拟机的 DHCP 改成了静态分配IP，所以需要手动设置一下每台机器 IP 地址，这里以<code>192.168.50.131</code> 为例。</p><ol type="1"><li><p>找到网络接口名称，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p>查找以 <code>ens</code> 或 <code>eth</code>开头的接口名称。例如，<code>ens33</code> 或 <code>eth0</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host <br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.50.133/24 brd 192.168.50.255 scope global dynamic noprefixroute ens33<br>       valid_lft 1644sec preferred_lft 1644sec<br>    inet6 fe80::c367:c7cc:3ad4:23b3/64 scope <span class="hljs-built_in">link</span> <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>可以找到 <code>ens33</code>，其中 <code>inet 192.168.50.133/24</code>表示 IP 地址为 <code>192.168.50.133</code>，子网掩码为<code>/24</code>（等于 <code>255.255.255.0</code>）。</p><p>这个 IP 地址是 DHCP 动态分配的，说明宿主机分配给虚拟机的 IP 范围就在<code>192.168.50.xxx</code>，所以我们会将静态 IP配置在这个范围内。</p></li><li><p>获取网关地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip route | grep default<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ip route | grep default<br>default via 192.168.50.2 dev ens33 proto dhcp metric 100<br></code></pre></td></tr></table></figure><p>说明默认网关是 <code>192.168.50.2</code>，</p></li><li><p>编辑 <code>/etc/network/interfaces</code> 文件，配置静态 IP地址，内容如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">auto ens33<br>iface ens33 inet static<br>   address 192.168.50.131<br>   netmask 255.255.255.0<br>   gateway 192.168.50.2<br>   dns-nameservers 8.8.8.8 8.8.4.4<br></code></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">su reboot<br></code></pre></td></tr></table></figure></li><li><p>再次查看 ip 地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p>有以下输出便说明静态 IP 配置成功了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host <br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.50.131/24 brd 192.168.50.255 scope global ens33<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::20c:29ff:fe82:9e69/64 scope <span class="hljs-built_in">link</span> <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure></li><li><p>配置域名</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/hosts<br></code></pre></td></tr></table></figure><p>追加内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">192.168.50.131 kafka1.com<br>192.168.50.132 kafka2.com<br>192.168.50.133 kafka3.com<br></code></pre></td></tr></table></figure></li><li><p>ping 一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping kafka1.com<br>PING kafka1.com (192.168.50.131) 56(84) bytes of data.<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=1 ttl=64 time=0.024 ms<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=2 ttl=64 time=0.021 ms<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=3 ttl=64 time=0.029 ms<br>^C<br>--- kafka1.com ping statistics ---<br>3 packets transmitted, 3 received, 0% packet loss, time 2029ms<br>rtt min/avg/max/mdev = 0.021/0.024/0.029/0.006 ms<br></code></pre></td></tr></table></figure></li><li><p>ping 一下百度，看看能不能访问外网</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping baidu.com<br>ping: baidu.com: Name or service not known<br></code></pre></td></tr></table></figure><p>如果这里可以访问，则直接跳过进入下一步，不可以的话，需要配置一下域名解析系统。</p></li><li><p>配置域名解析系统</p><p>Ubuntu 系统使用 <code>systemd-resolved</code> 服务来管理DNS，你可以在 <code>/etc/systemd/resolved.conf</code> 文件中进行 DNS配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/systemd/resolved.conf<br></code></pre></td></tr></table></figure><p>取消或添加 <code>DNS</code> 的注释，并修改为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">[Resolve]<br>DNS=8.8.8.8 8.8.4.4<br></code></pre></td></tr></table></figure><p>重启启动 <code>systemd-resolved</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl restart systemd-resolved<br></code></pre></td></tr></table></figure><p>再尝试 ping 一下百度：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping www.baidu.com<br>PING www.a.shifen.com (153.3.238.110) 56(84) bytes of data.<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=1 ttl=128 time=15.9 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=2 ttl=128 time=15.9 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=3 ttl=128 time=16.1 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=4 ttl=128 time=15.3 ms<br>^C<br>--- www.a.shifen.com ping statistics ---<br>4 packets transmitted, 4 received, 0% packet loss, time 14104ms<br>rtt min/avg/max/mdev = 15.368/15.850/16.145/0.291 ms<br></code></pre></td></tr></table></figure></li></ol><div class="note note-info">            <p>补充说明：<code>/etc/network/interfaces</code> 文件的配置</p><p>这是一个用于配置 Linux 系统上网络接口的文件。在这个示例中，我们为名为<code>ens33</code> 的网络接口配置了静态 IP地址和相关的网络设置。下面是各行的解释：</p><ol type="1"><li><p><code>auto ens33</code>: 这一行表示在系统启动时自动激活<code>ens33</code> 网络接口。<code>auto</code>关键字后面跟着接口名称。</p></li><li><p><code>iface ens33 inet static</code>: 这一行定义了<code>ens33</code> 网络接口的配置。<code>iface</code>关键字后面跟着接口名称，<code>inet</code> 表示我们正在配置 IPv4地址，<code>static</code> 表示我们要为接口分配一个静态 IP地址（而不是通过 DHCP 获得）。</p></li><li><p><code>address 192.168.50.131</code>: 这一行设置了网络接口的静态IP 地址。在这个例子中，我们为 <code>ens33</code> 接口分配了<code>192.168.50.131</code> IP 地址。</p><blockquote><p>IP 地址是 Internet协议（IP）用于在网络中唯一标识设备的数字标签。每个连接到网络的设备都需要一个唯一的IP 地址，以便其他设备可以找到并与之通信。IP 地址通常分为两种版本：IPv4和 IPv6。在此示例中，我们使用了一个 IPv4 地址。</p></blockquote></li><li><p><code>netmask 255.255.255.0</code>:这一行定义了子网掩码。在这个例子中，子网掩码是<code>255.255.255.0</code>，表示前三个字节（24位）是网络地址，最后一个字节（8 位）是主机地址。</p><blockquote><p>子网掩码用于划分 IP 地址的网络部分和主机部分。子网掩码与 IP地址进行按位与操作，从而得到网络地址。这有助于确定哪些 IP地址属于同一子网，以便正确地将数据包路由到目的地。子网划分有助于组织网络、提高安全性和管理性。</p></blockquote></li><li><p><code>gateway 192.168.50.2</code>:这一行设置了默认网关。在这个例子中，我们将默认网关设置为<code>192.168.50.2</code>。默认网关是用于将数据包发送到其他网络的路由器或设备的IP 地址。</p><blockquote><p>网关是一个充当网络中数据包传输的中继点的设备，通常是一个路由器。当一个设备需要将数据包发送到不同子网的另一个设备时，它会将数据包发送到网关。网关负责将数据包路由到正确的目的地。默认网关是设备用于将数据包发送到其他网络的首选网关。</p></blockquote></li><li><p><code>dns-nameservers 8.8.8.8 8.8.4.4</code>: 这一行指定了 DNS服务器的 IP 地址。在这个例子中，我们使用了谷歌的公共 DNS 服务器<code>8.8.8.8</code> 和 <code>8.8.4.4</code>。DNS服务器用于将主机名解析为 IP 地址。</p><blockquote><p>域名系统（DNS）是将人类可读的域名（例如 www.baidu.com）IP地址的系统。DNS服务器是负责执行此解析过程的服务器。当您在浏览器中输入一个网址时，计算机会向DNS 服务器查询该域名对应的 IP 地址，然后将请求发送到该 IP地址以获取网页内容。</p></blockquote></li></ol><p>配置文件中的这些设置将在系统启动时生效。要立即应用更改，您可以使用以下命令重启网络服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart networking<br></code></pre></td></tr></table></figure>          </div><h2 id="安装-jdk">安装 jdk</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install openjdk-8-jdk<br></code></pre></td></tr></table></figure><p>验证 java8 是否已经安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -version<br></code></pre></td></tr></table></figure><p>有以下类似输出的话则表明安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">openjdk version <span class="hljs-string">&quot;1.8.0_362&quot;</span><br>OpenJDK Runtime Environment (build 1.8.0_362-8u372-ga~us1-0ubuntu1~18.04-b09)<br>OpenJDK 64-Bit Server VM (build 25.362-b09, mixed mode)<br></code></pre></td></tr></table></figure><h2 id="安装-kafka">安装 Kafka</h2><ol type="1"><li><p>下载并解压 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://archive.apache.org/dist/kafka/3.6.0/kafka_2.13-3.6.0.tgz<br>tar -zxvf kafka_2.13-3.6.0.tgz<br></code></pre></td></tr></table></figure></li><li><p>将解压缩后的文件夹移动到 <code>/opt</code> 目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mv</span> kafka_2.13-3.6.0 /opt/kafka-3.6.0<br></code></pre></td></tr></table></figure></li><li><p>使用 Kafka 提供的脚本生成一个 ClusterID</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> KAFKA_CLUSTER_ID=<span class="hljs-string">&quot;<span class="hljs-subst">$(/opt/kafka-3.6.0/bin/kafka-storage.sh random-uuid)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>输出 ClusterID</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:/opt/kafka-3.6.0$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$KAFKA_CLUSTER_ID</span><br>XiMRcbJ-QEO694L7sfDdBQ<br></code></pre></td></tr></table></figure><p>在其他节点上将 <code>KAFKA_CLUSTER_ID</code> 设置为上面的值：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> KAFKA_CLUSTER_ID=XiMRcbJ-QEO694L7sfDdBQ<br></code></pre></td></tr></table></figure></li><li><p>备份配置文件，注意这里的配置文件是<code>config/kraft/server.properties</code>，在 <code>config</code>目录下的 <code>kraft</code> 目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> /opt/kafka-3.6.0/config/kraft/server.properties /opt/kafka-3.6.0/config/kraft/server.properties.bak<br></code></pre></td></tr></table></figure></li><li><p>修改配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /opt/kafka-3.6.0/config/kraft/server.properties<br></code></pre></td></tr></table></figure><p>主要修改内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 节点 ID，分别为 1，2，3</span><br><span class="hljs-attr">node.id</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"># 日志目录</span><br><span class="hljs-attr">log.dirs</span>=<span class="hljs-string">/opt/kafka-3.6.0/kafka-combined-logs</span><br><span class="hljs-comment"># 可以成为控制器的节点和它们的端口</span><br><span class="hljs-attr">controller.quorum.voters</span>=<span class="hljs-string">1@kafka1.com:9093,2@kafka2.com:9093,3@kafka3.com:9093</span><br><span class="hljs-comment"># 定义 Kafka Broker 如何向外部公布它的地址。</span><br><span class="hljs-comment"># 这是 Kafka Broker 通知 Producer 和 Consumer 如何连接到自己的方式。</span><br><span class="hljs-comment"># 例如，如果你设置 advertised.listeners=PLAINTEXT://my.public.ip:9092，</span><br><span class="hljs-comment"># 那么 Kafka Broker 将告诉 Producer 和 Consumer 它的公共 IP 地址是 my.public.ip，并且它在 9092 端口上监听连接。</span><br><span class="hljs-comment"># 这里我们需要在 3 个节点分别设置对应的地址</span><br><span class="hljs-attr">advertised.listeners</span>=<span class="hljs-string">PLAINTEXT://kafka1.com:9092</span><br></code></pre></td></tr></table></figure></li><li><p>格式化日志目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-storage.sh format -t <span class="hljs-variable">$KAFKA_CLUSTER_ID</span> -c /opt/kafka-3.6.0/config/kraft/server.properties<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Formatting /opt/kafka-3.6.0/kraft-combined-logs with metadata.version 3.6-IV2.<br></code></pre></td></tr></table></figure></li><li><p>三个节点都启动 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-server-start.sh -daemon /opt/kafka-3.6.0/config/kraft/server.properties<br></code></pre></td></tr></table></figure></li><li><p>选择任意一个节点创建一个新 topic</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic <span class="hljs-built_in">test</span> --replication-factor 1 --partitions=2<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Created topic <span class="hljs-built_in">test</span>.<br></code></pre></td></tr></table></figure></li><li><p>在其他节点获取 <code>test</code> 这个 <code>topic</code>的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>可以看到关于 <code>test</code> 这个 <code>topic</code>的信息是可以获取到的，说明集群之前信息是互通的，集群搭建完毕。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">Topic: <span class="hljs-built_in">test</span>TopicId: svJClTUpSFa9Z6FWDvkARgPartitionCount: 2ReplicationFactor: 1Configs: segment.bytes=1073741824<br>Topic: <span class="hljs-built_in">test</span>Partition: 0Leader: 2Replicas: 2Isr: 2<br>Topic: <span class="hljs-built_in">test</span>Partition: 1Leader: 3Replicas: 3Isr: 3<br></code></pre></td></tr></table></figure></li><li><p>随便选择一个节点，往 <code>test</code> 里面写入数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>输入数据后按回车即发送一条数据，可以随时按 <code>Ctrl + C</code>退出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~/Downloads$ /opt/kafka-3.6.0/bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span><br>&gt;msg1<br>&gt;msg2<br>&gt;msg 3<br>&gt;^<br></code></pre></td></tr></table></figure></li><li><p>随便选择一个节点，启动消费者消费 <code>topic</code>中的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-3.6.0/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span> --from-beginning<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:/opt/kafka-3.6.0$ /opt/kafka-3.6.0/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span> --from-beginning<br>msg1<br>msg2<br>msg 3<br>^CProcessed a total of 3 messages<br></code></pre></td></tr></table></figure></li></ol><p>至此，Kafka 的 KRaft 版本集群就部署完毕了！</p><div class="note note-info">            <h2 id="补充说明---kraft-配置文件">补充说明 - KRaft 配置文件</h2><p>下面是 Kafka KRaft 版本配置文件每个配置项的解释：</p><table><thead><tr class="header"><th>配置项</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>process.roles</td><td>Kafka 服务器的角色，设置此项将 Kafka 置于 KRaft 模式。可能的值包括"broker" 和 "controller"。</td></tr><tr class="even"><td>node.id</td><td>与此实例关联的节点 ID。</td></tr><tr class="odd"><td>controller.quorum.voters</td><td>控制器选举的投票节点，格式为 <code>node-id@host:port</code>。</td></tr><tr class="even"><td>listeners</td><td>服务器监听的地址，格式为<code>listener_name://host_name:port</code>。</td></tr><tr class="odd"><td>inter.broker.listener.name</td><td>用于 broker 之间通信的监听器名称。</td></tr><tr class="even"><td>advertised.listeners</td><td>服务器向客户端宣告的监听器名称、主机名和端口。</td></tr><tr class="odd"><td>controller.listener.names</td><td>控制器使用的监听器名称列表。</td></tr><tr class="even"><td>listener.security.protocol.map</td><td>监听器名称到安全协议的映射。默认情况下，它们是相同的。</td></tr><tr class="odd"><td>num.network.threads</td><td>服务器用于从网络接收请求和向网络发送响应的线程数。</td></tr><tr class="even"><td>num.io.threads</td><td>服务器用于处理请求（可能包括磁盘 I/O）的线程数。</td></tr><tr class="odd"><td>socket.send.buffer.bytes</td><td>服务器用于发送数据的缓冲区大小。</td></tr><tr class="even"><td>socket.receive.buffer.bytes</td><td>服务器用于接收数据的缓冲区大小。</td></tr><tr class="odd"><td>socket.request.max.bytes</td><td>服务器接受的请求的最大大小（用于防止内存溢出）。</td></tr><tr class="even"><td>log.dirs</td><td>用于存储日志文件的目录列表。</td></tr><tr class="odd"><td>num.partitions</td><td>每个主题的默认日志分区数。</td></tr><tr class="even"><td>num.recovery.threads.per.data.dir</td><td>每个数据目录在启动时用于日志恢复和关闭时用于刷新的线程数。</td></tr><tr class="odd"><td>offsets.topic.replication.factor</td><td>内部主题 "__consumer_offsets" 和 "__transaction_state"的复制因子。</td></tr><tr class="even"><td>transaction.state.log.replication.factor</td><td>事务状态日志的复制因子。</td></tr><tr class="odd"><td>transaction.state.log.min.isr</td><td>事务状态日志的最小同步副本数。</td></tr><tr class="even"><td>log.flush.interval.messages</td><td>强制将数据刷新到磁盘之前接受的消息数。</td></tr><tr class="odd"><td>log.flush.interval.ms</td><td>消息在日志中停留的最大时间，超过这个时间就会强制刷新到磁盘。</td></tr><tr class="even"><td>log.retention.hours</td><td>由于年龄而使日志文件有资格被删除的最小年龄。</td></tr><tr class="odd"><td>log.retention.bytes</td><td>基于大小的日志保留策略。</td></tr><tr class="even"><td>log.segment.bytes</td><td>日志段文件的最大大小。</td></tr><tr class="odd"><td>log.retention.check.interval.ms</td><td>检查日志段是否可以根据保留策略被删除的间隔。</td></tr></tbody></table><p>请注意，这只是 Kafka 配置的一部分，Kafka 配置的完整列表可以在 <ahref="https://kafka.apache.org/36/documentation.html#configuration">Kafka的官方文档</a>中找到。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>部署</tag>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka 集群部署</title>
    <link href="/2023/11/22/kakfa-cluster-deploy/"/>
    <url>/2023/11/22/kakfa-cluster-deploy/</url>
    
    <content type="html"><![CDATA[<h2 id="版本说明">版本说明</h2><ul><li>Ubuntu 18.04.6</li><li>Zookeeper 3.5.9</li><li>Kafka 2.7.0</li><li>JDK8</li></ul><h2 id="集群配置">集群配置</h2><table><thead><tr class="header"><th style="text-align: center;">操作系统</th><th style="text-align: center;">ip</th><th style="text-align: center;">域名</th><th style="text-align: center;">Zookeeper 端口</th><th style="text-align: center;">Kafka 端口</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.131</td><td style="text-align: center;">kafka1.com</td><td style="text-align: center;">2181</td><td style="text-align: center;">9092</td></tr><tr class="even"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.132</td><td style="text-align: center;">kafka2.com</td><td style="text-align: center;">2181</td><td style="text-align: center;">9092</td></tr><tr class="odd"><td style="text-align: center;">Ubuntu 18.04.6</td><td style="text-align: center;">192.168.50.133</td><td style="text-align: center;">kafka3.com</td><td style="text-align: center;">2181</td><td style="text-align: center;">9092</td></tr></tbody></table><h2 id="安装-vim-curl">安装 vim, curl</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install vim<br>sudo apt install curl<br></code></pre></td></tr></table></figure><h2 id="配置静态-ip-和-hosts">配置静态 ip 和 hosts</h2><p>为了使用域名，更加方便的进行配置，这里将虚拟机的 DHCP 改成了静态分配IP，所以需要手动设置一下每台机器 IP 地址，这里以<code>192.168.50.131</code> 为例。</p><ol type="1"><li><p>找到网络接口名称，运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p>查找以 <code>ens</code> 或 <code>eth</code>开头的接口名称。例如，<code>ens33</code> 或 <code>eth0</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host <br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.50.133/24 brd 192.168.50.255 scope global dynamic noprefixroute ens33<br>       valid_lft 1644sec preferred_lft 1644sec<br>    inet6 fe80::c367:c7cc:3ad4:23b3/64 scope <span class="hljs-built_in">link</span> <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>可以找到 <code>ens33</code>，其中 <code>inet 192.168.50.133/24</code>表示 IP 地址为 <code>192.168.50.133</code>，子网掩码为<code>/24</code>（等于 <code>255.255.255.0</code>）。</p><p>这个 IP 地址是 DHCP 动态分配的，说明宿主机分配给虚拟机的 IP 范围就在<code>192.168.50.xxx</code>，所以我们会将静态 IP配置在这个范围内。</p></li><li><p>获取网关地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip route | grep default<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ip route | grep default<br>default via 192.168.50.2 dev ens33 proto dhcp metric 100<br></code></pre></td></tr></table></figure><p>说明默认网关是 <code>192.168.50.2</code>，</p></li><li><p>编辑 <code>/etc/network/interfaces</code> 文件，配置静态 IP地址，内容如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">auto ens33<br>iface ens33 inet static<br>address 192.168.50.131<br>netmask 255.255.255.0<br>gateway 192.168.50.2<br>dns-nameservers 8.8.8.8 8.8.4.4<br></code></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">su reboot<br></code></pre></td></tr></table></figure></li><li><p>再次查看 ip 地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p>有以下输出便说明静态 IP 配置成功了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host <br>       valid_lft forever preferred_lft forever<br>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 00:0c:29:82:9e:69 brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.50.131/24 brd 192.168.50.255 scope global ens33<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::20c:29ff:fe82:9e69/64 scope <span class="hljs-built_in">link</span> <br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure></li><li><p>配置域名</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/hosts<br></code></pre></td></tr></table></figure><p>追加内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">192.168.50.131 kafka1.com<br>192.168.50.132 kafka2.com<br>192.168.50.133 kafka3.com<br></code></pre></td></tr></table></figure></li><li><p>ping 一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping kafka1.com<br>PING kafka1.com (192.168.50.131) 56(84) bytes of data.<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=1 ttl=64 time=0.024 ms<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=2 ttl=64 time=0.021 ms<br>64 bytes from kafka1.com (192.168.50.131): icmp_seq=3 ttl=64 time=0.029 ms<br>^C<br>--- kafka1.com ping statistics ---<br>3 packets transmitted, 3 received, 0% packet loss, time 2029ms<br>rtt min/avg/max/mdev = 0.021/0.024/0.029/0.006 ms<br></code></pre></td></tr></table></figure></li><li><p>ping 一下百度，看看能不能访问外网</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping baidu.com<br>ping: baidu.com: Name or service not known<br></code></pre></td></tr></table></figure><p>如果这里可以访问，则直接跳过进入下一步，不可以的话，需要配置一下域名解析系统。</p></li><li><p>配置域名解析系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/resolv.conf<br></code></pre></td></tr></table></figure><p>追加下面内容：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">nameserver 8.8.8.8<br>nameserver 8.8.4.4<br></code></pre></td></tr></table></figure><p>再尝试 ping 一下百度：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:~$ ping www.baidu.com<br>PING www.a.shifen.com (153.3.238.110) 56(84) bytes of data.<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=1 ttl=128 time=15.9 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=2 ttl=128 time=15.9 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=3 ttl=128 time=16.1 ms<br>64 bytes from 153.3.238.110 (153.3.238.110): icmp_seq=4 ttl=128 time=15.3 ms<br>^C<br>--- www.a.shifen.com ping statistics ---<br>4 packets transmitted, 4 received, 0% packet loss, time 14104ms<br>rtt min/avg/max/mdev = 15.368/15.850/16.145/0.291 ms<br></code></pre></td></tr></table></figure></li></ol><div class="note note-info">            <p>补充说明：<code>/etc/network/interfaces</code> 文件的配置</p><p>这是一个用于配置 Linux 系统上网络接口的文件。在这个示例中，我们为名为<code>ens33</code> 的网络接口配置了静态 IP地址和相关的网络设置。下面是各行的解释：</p><ol type="1"><li><p><code>auto ens33</code>: 这一行表示在系统启动时自动激活<code>ens33</code> 网络接口。<code>auto</code>关键字后面跟着接口名称。</p></li><li><p><code>iface ens33 inet static</code>: 这一行定义了<code>ens33</code> 网络接口的配置。<code>iface</code>关键字后面跟着接口名称，<code>inet</code> 表示我们正在配置 IPv4地址，<code>static</code> 表示我们要为接口分配一个静态 IP地址（而不是通过 DHCP 获得）。</p></li><li><p><code>address 192.168.50.131</code>: 这一行设置了网络接口的静态IP 地址。在这个例子中，我们为 <code>ens33</code> 接口分配了<code>192.168.50.131</code> IP 地址。</p><blockquote><p>IP 地址是 Internet协议（IP）用于在网络中唯一标识设备的数字标签。每个连接到网络的设备都需要一个唯一的IP 地址，以便其他设备可以找到并与之通信。IP 地址通常分为两种版本：IPv4和 IPv6。在此示例中，我们使用了一个 IPv4 地址。</p></blockquote></li><li><p><code>netmask 255.255.255.0</code>:这一行定义了子网掩码。在这个例子中，子网掩码是<code>255.255.255.0</code>，表示前三个字节（24位）是网络地址，最后一个字节（8 位）是主机地址。</p><blockquote><p>子网掩码用于划分 IP 地址的网络部分和主机部分。子网掩码与 IP地址进行按位与操作，从而得到网络地址。这有助于确定哪些 IP地址属于同一子网，以便正确地将数据包路由到目的地。子网划分有助于组织网络、提高安全性和管理性。</p></blockquote></li><li><p><code>gateway 192.168.50.2</code>:这一行设置了默认网关。在这个例子中，我们将默认网关设置为<code>192.168.50.2</code>。默认网关是用于将数据包发送到其他网络的路由器或设备的IP 地址。</p><blockquote><p>网关是一个充当网络中数据包传输的中继点的设备，通常是一个路由器。当一个设备需要将数据包发送到不同子网的另一个设备时，它会将数据包发送到网关。网关负责将数据包路由到正确的目的地。默认网关是设备用于将数据包发送到其他网络的首选网关。</p></blockquote></li><li><p><code>dns-nameservers 8.8.8.8 8.8.4.4</code>: 这一行指定了 DNS服务器的 IP 地址。在这个例子中，我们使用了谷歌的公共 DNS 服务器<code>8.8.8.8</code> 和 <code>8.8.4.4</code>。DNS服务器用于将主机名解析为 IP 地址。</p><blockquote><p>域名系统（DNS）是将人类可读的域名（例如 www.baidu.com）IP地址的系统。DNS服务器是负责执行此解析过程的服务器。当您在浏览器中输入一个网址时，计算机会向DNS 服务器查询该域名对应的 IP 地址，然后将请求发送到该 IP地址以获取网页内容。</p></blockquote></li></ol><p>配置文件中的这些设置将在系统启动时生效。要立即应用更改，您可以使用以下命令重启网络服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart networking<br></code></pre></td></tr></table></figure>          </div><h2 id="安装-jdk">安装 jdk</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install openjdk-8-jdk<br></code></pre></td></tr></table></figure><p>验证 java8 是否已经安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -version<br></code></pre></td></tr></table></figure><p>有以下类似输出的话则表明安装成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">openjdk version <span class="hljs-string">&quot;1.8.0_362&quot;</span><br>OpenJDK Runtime Environment (build 1.8.0_362-8u372-ga~us1-0ubuntu1~18.04-b09)<br>OpenJDK 64-Bit Server VM (build 25.362-b09, mixed mode)<br></code></pre></td></tr></table></figure><h2 id="安装-zookeeper">安装 zookeeper</h2><p>在 Ubuntu 上，您可以通过以下步骤安装 Apache Zookeeper 3.5.9：</p><ol type="1"><li>下载 Apache Zookeeper 3.5.9 的二进制文件。使用以下命令下载并解压缩Zookeeper：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://archive.apache.org/dist/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz<br>tar -xzf apache-zookeeper-3.5.9-bin.tar.gz<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>将解压缩后的文件夹移动到 <code>/opt</code> 目录中：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mv</span> apache-zookeeper-3.5.9-bin /opt/zookeeper-3.5.9<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>在 <code>/opt/zookeeper-3.5.9</code> 目录中创建一个名为<code>data</code> 的文件夹，用于存储 Zookeeper 的数据：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mkdir</span> /opt/zookeeper-3.5.9/data<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>在 <code>/opt/zookeeper-3.5.9/data</code> 下创建 myid文件并设置内容为 <code>1</code>，其他两台机器则为 <code>2</code> 和<code>3</code>：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> 1 | sudo <span class="hljs-built_in">tee</span> /opt/zookeeper-3.5.9/data/myid<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>复制 Zookeeper 配置文件样本，并将其命名为<code>zoo.cfg</code>：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">cp</span> /opt/zookeeper-3.5.9/conf/zoo_sample.cfg /opt/zookeeper-3.5.9/conf/zoo.cfg<br></code></pre></td></tr></table></figure><ol start="8" type="1"><li>使用文本编辑器（例如 vim）编辑 <code>zoo.cfg</code> 文件：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /opt/zookeeper-3.5.9/conf/zoo.cfg<br></code></pre></td></tr></table></figure><ol start="9" type="1"><li>修改 <code>zoo.cfg</code> 文件：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># The number of milliseconds of each tick</span><br>tickTime=2000<br><span class="hljs-comment"># The number of ticks that the initial </span><br><span class="hljs-comment"># synchronization phase can take</span><br>initLimit=10<br><span class="hljs-comment"># The number of ticks that can pass between </span><br><span class="hljs-comment"># sending a request and getting an acknowledgement</span><br>syncLimit=5<br><span class="hljs-comment"># the directory where the snapshot is stored.</span><br><span class="hljs-comment"># 设置数据存储目录</span><br>dataDir=/opt/zookeeper-3.5.9/data<br><span class="hljs-comment"># the port at which the clients will connect</span><br>clientPort=2181<br><span class="hljs-comment"># 设置集群信息</span><br>server.1=kafka1.com:2888:3888<br>server.2=kafka2.com:2888:3888<br>server.3=kafka3.com:2888:3888<br></code></pre></td></tr></table></figure><blockquote><p>在 Zookeeper 的配置文件中，<code>server.x=hostname:port1:port2</code>这种格式的配置项是用来设置 Zookeeper集群（集群模式下）的。其中，<code>x</code> 是服务器的ID，<code>hostname</code> 是服务器的主机名或 IP 地址，<code>port1</code>和 <code>port2</code> 是用于集群间通信的端口。</p><p>具体来说：</p><ul><li><p><code>port1（2888）</code>：这是服务器之间用于相互通信的端口。Zookeeper服务器使用这个端口进行 leader 选举以及同步 follower 和 leader之间的状态。</p></li><li><p><code>port2（3888）</code>：这个端口用于服务器之间的 leader选举。在 Zookeeper 集群启动或者在 leader 服务器崩溃后，follower服务器会通过这个端口进行新一轮的 leader 选举。</p></li></ul><p>这两个端口可以根据你的网络配置进行修改，但必须在所有的 Zookeeper服务器上保持一致。</p></blockquote><ol start="10" type="1"><li>三个节点都启动 Zookeeper 服务器：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/zookeeper/bin/zkServer.sh start<br></code></pre></td></tr></table></figure><p>可以连接到 Zookeeper 的端口上（默认是<code>2181</code>），通过发送四字命令 <code>srvr</code> 来验证 Zookeeper是否安装正确（部署集群的话需要把所有 Zookeeper 启动）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">hedon@ubuntu:/opt/zookeeper-3.5.9$ telnet localhost 2181<br>Trying 127.0.0.1...<br>Connected to localhost.<br>Escape character is <span class="hljs-string">&#x27;^]&#x27;</span>.<br>srvr<br>Zookeeper version: 3.5.9-83df9301aa5c2a5d284a9940177808c01bc35cef, built on 01/06/2021 19:49 GMT<br>Latency min/avg/max: 0/0/0<br>Received: 1<br>Sent: 0<br>Connections: 1<br>Outstanding: 0<br>Zxid: 0x0<br>Mode: standalone<br>Node count: 5<br>Connection closed by foreign host.<br></code></pre></td></tr></table></figure><ol start="11" type="1"><li>要停止 Zookeeper 服务器，可以使用以下命令：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/zookeeper/bin/zkServer.sh stop<br></code></pre></td></tr></table></figure><h2 id="安装-kafka">安装 Kafka</h2><ol type="1"><li><p>下载并解压 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://archive.apache.org/dist/kafka/2.7.0/kafka_2.13-2.7.0.tgz<br>tar -zxvf kafka_2.13-2.7.0.tgz<br></code></pre></td></tr></table></figure></li><li><p>将解压缩后的文件夹移动到 <code>/opt</code> 目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mv</span> kafka_2.13-2.7.0 /opt/kafka-2.7.0<br></code></pre></td></tr></table></figure></li><li><p>创建日志目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mkdir</span> /opt/kafka-2.7.0/kafka-logs<br></code></pre></td></tr></table></figure></li><li><p>备份 Kafka 默认配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">cp</span> /opt/kafka-2.7.0/config/server.properties /opt/kafka-2.7.0/config/server.properties.bak<br></code></pre></td></tr></table></figure></li><li><p>修改 Kafka 配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /opt/kafka-2.7.0/config/server.properties<br></code></pre></td></tr></table></figure><p>主要是修改下面几个配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 集群中每个 broker 的 id 必须唯一，这里分别为 1，2，3</span><br><span class="hljs-attr">broker.id</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"># 日志目录</span><br><span class="hljs-attr">log.dirs</span>=<span class="hljs-string">/opt/kafka-2.7.0/kafka-logs</span><br><span class="hljs-comment"># 配置 Zookeeper</span><br><span class="hljs-attr">zookeeper.connect</span>=<span class="hljs-string">kafka1.com:2181,kafka2.com:2181,kafka3.com:2181</span><br><span class="hljs-comment"># 定义 Kafka Broker 在哪些网络地址上监听连接，下面配置表示在所有的 IP 地址上监听 9092 端口</span><br><span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://:9092</span><br><span class="hljs-comment"># 定义 Kafka Broker 如何向外部公布它的地址。这是 Kafka Broker 通知 Producer 和 Consumer 如何连接到自己的方式。例如，如果你设置 advertised.listeners=PLAINTEXT://my.public.ip:9092，那么 Kafka Broker 将告诉 Producer 和 Consumer 它的公共 IP 地址是 my.public.ip，并且它在 9092 端口上监听连接。</span><br><span class="hljs-attr">advertised.listeners</span>=<span class="hljs-string">PLAINTEXT://kafka1.com:9092</span><br></code></pre></td></tr></table></figure></li><li><p>三个节点都启动 Kafka</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-2.7.0/bin/kafka-server-start.sh -daemon /opt/kafka-2.7.0/config/server.properties<br></code></pre></td></tr></table></figure></li><li><p>选择任意一个节点创建一个新 topic</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-2.7.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic <span class="hljs-built_in">test</span> --replication-factor 1 --partitions=2<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Created topic <span class="hljs-built_in">test</span>.<br></code></pre></td></tr></table></figure></li><li><p>在其他节点获取 <code>test</code> 这个 <code>topic</code>的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/opt/kafka-2.7.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --describe --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>可以看到关于 <code>test</code> 这个 <code>topic</code>的信息是可以获取到的，说明集群之前信息是互通的，集群搭建完毕。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">Topic: <span class="hljs-built_in">test</span>PartitionCount: 2ReplicationFactor: 1Configs: segment.bytes=1073741824<br>Topic: <span class="hljs-built_in">test</span>Partition: 0Leader: 1Replicas: 1Isr: 1<br>Topic: <span class="hljs-built_in">test</span>Partition: 1Leader: 2Replicas: 2Isr: 2<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
      <tag>部署</tag>
      
      <tag>中间件</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft-Extended 论文翻译</title>
    <link href="/2023/11/18/raft/"/>
    <url>/2023/11/18/raft/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文：https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf</p></blockquote><h2 id="辨析">辨析</h2><p><strong>consensus</strong> vs <strong>consistency</strong></p><p>一致性（consistency）往往指分布式系统中多个副本对外呈现的数据的状态。如顺序一致性、线性一致性，描述了多个节点对数据状态的维护能力。</p><p>共识（consensus）则描述了分布式系统中多个节点之间，彼此对某个提案达成一致结果的过程。</p><p>因此，一致性描述的是<strong>结果</strong>，共识则是一种<strong>手段</strong>。</p><p>有的人会说一致性和共识实际上是一个问题的一体两面，某种程度上来说，共识方法确实可以看作是实现强一致性的一种方法。事实上在工业界有许多以共识算法作为核心组件的多副本状态机（ReplicatedStateMachine）实现，本质上利用了共识算法保证了所有副本的操作日志具有完全相同的顺序，从而实现了副本的一致性。但是，即使是在这样的场景下，讨论一个共识算法的一致性也是不合适的，因<strong>为整个分布式系统最终的一致性并不单单取决于共识算法，共识算法只是解决了其中一个问题。</strong></p><blockquote><p>参考：https://zhuanlan.zhihu.com/p/68743917</p></blockquote><h2 id="摘要">0. 摘要</h2><p>Raft 是用来管理复制日志（replicated log）的一致性协议。它跟multi-Paxos 作用相同，效率也相当。但是它的组织结构跟 Paxos不同，也是因为 Raft更简单的架构使得它更容易被理解，并且更容易在实际工程中得以实现。</p><p>为了让 Raft 更容易被理解，Raft将共识算法的关键性因素切分成几个部分，比如：</p><ul><li>leader election（领导者选举）</li><li>log replication（日志复制）</li><li>safety（安全性）</li></ul><p>并且 Raft实施了一种更强的共识性以便减少必须要考虑的状态（states）的数量。</p><p>用户研究表明，对于学生来说，Raft 相比于 Paxos 是更容易学习的。</p><p>Raft还包括一个用于解决<strong>变更集群成员问题</strong>的新机制，它使用重写多数来保证安全性。</p><h2 id="介绍">1. 介绍</h2><p>共识算法允许多台机器作为一个集群协同工作，并且在其中的某几台机器出故障时集群仍然能正常工作。正因为如此，共识算法在建立可靠的大规模软件系统方面发挥了重要作用。在过去十年中，Paxos[15,16] 主导了关于共识算法的讨论：大多数共识性的实现都是基于 Paxos或受其影响，Paxos 已经成为教授学生关于共识知识的主要工具。</p><p>比较遗憾的是，尽管很多人一直在努力尝试使 Paxos 更易懂，Paxos还是太难理解了。此外，Paxos的架构需要复杂的改变来支持实际系统。这导致的结果就是系统开发者和学生在学生和使用Paxos 过程中都很挣扎。</p><p>在我们自己与 Paxos斗争之后，我们开始着手寻找一个新的共识算法，希望可以为系统开发和教学提供更好的基础。我们的方法是不寻常的，因为我们的主要目标是可理解性：我们可以设计一个比Paxos 更适合用于实际工程实现并且更易懂的共识算法吗？</p><p>在该算法的设计中，重要的不仅是如何让算法起作用，还要清晰地知道该算法为什么会起作用。</p><p>这项工作的结果是一个称为 Raft 的共识性算法。在设计 Raft时，我们使用了特定的技术来提高它的可理解性，包括：</p><ul><li>分解（Raft 分离出三个关键点：leader election、logreplication、safety）</li><li>减少状态空间（相比于 Paxos，Raft降低了不确定性的程度和服务器之间的不一致）</li></ul><p>一项针对 2 所大学共 43 名学生的用户研究表明，Raft 比 Paxos更容易理解：在学习两种算法后，其中 33 名学生能够更好地回答 Raft的相关问题。</p><p>Raft 在许多方面类似于现有的公式算法（尤其是 Oki、Liskov 的Viewstamped Replication [29,22]），但它有几个新特性：</p><ul><li><strong>Strong leader（强领导性）</strong>：相比于其他算法，Raft使用了更强的领导形式。比如，日志条目只能从 leader 流向follower（集群中除 leader 外其他的服务器）。这在使 Raft更易懂的同时简化了日志复制的管理流程。</li><li><strong>Leader election（领导选举）</strong>：Raft使用随机计时器来进行领导选举。任何共识算法都需要心跳机制（heartbeats），Raft只需要在这个基础上，添加少量机制，就可以简单快速地解决冲突。</li><li><strong>Membership changes（成员变更）</strong>：Raft在更改集群中服务器集的机制中使用了一个 <strong>联合共识（jointconsensus）</strong> 的方法。在联合共识（jointconsensus）下，在集群配置的转换过程中，新旧两种配置大多数是重叠的，这使得集群在配置更改期间可以继续正常运行。</li></ul><p>我们认为 Raft 跟 Paxos以及其他共识算法相比是更优的，这不仅体现在教学方面，还体现在工程实现方面。</p><ul><li>它比其他算法更简单且更易于理解</li><li>它被描述得十分详细足以满足实际系统的需要</li><li>它有多个开源实现，并被多家公司使用</li><li>它的安全性已被正式规定和验证</li><li>它的效率与其他算法相当</li></ul><p>本文剩余部分：</p><table><thead><tr class="header"><th>所在节</th><th>内容</th></tr></thead><tbody><tr class="odd"><td>第 2 节</td><td>复制状态机问题（replicated state machine problem）</td></tr><tr class="even"><td>第 3 节</td><td>Paxos 的优缺点</td></tr><tr class="odd"><td>第 4 节</td><td>实现 Raft 易理解性的措施</td></tr><tr class="even"><td>第 5-8 节</td><td>Raft 共识性算法详细阐述</td></tr><tr class="odd"><td>第 9 节</td><td>评估 Raft</td></tr><tr class="even"><td>第 10 节</td><td>其他相关工作</td></tr></tbody></table><h2 id="复制状态机">2. 复制状态机</h2><p>共识算法一般都是在复制状态机 [37]的背景下实现的。在这种方法下，一组服务器在的状态机计算相同状态的相同副本，即使某些服务器崩溃，它们也可以继续运行。</p><p>复制状态机是用来解决分布式系统中的各种容错问题。比如说，具有单个leader 的大规模的系统，如 GFS [8]，HDFS [38] 和 RAMCloud [33]，他们通常都使用单独的复制状态机来管理 leader election 和保存 leader崩溃后重新选举所需的配置信息。像 Chubby [2] 和 ZooKeeper [11]都是复制状态机。</p><p>复制状态机通常都是使用日志复制（logreplication）来实现。如图1：每个服务器都保存着一份拥有一系列命令的日志，然后服务器上的状态机会按顺序执行日志中的命令。每一份日志中命令相同并且顺序也相同，因此每个状态机可以处理相同的命令序列。所以状态机是可确定的，每个状态机都执行相同的状态和相同的输出序列。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsmihlh9ptj322u0nsgpj.jpg"alt="image-20210719200404010" /><figcaption aria-hidden="true">image-20210719200404010</figcaption></figure><p>共识算法的主要工作就是保证复制日志（replicatedlog）的一致性。每台服务器上的共识模块接收来自客户端的命令，并将这些命令添加到其日志当中。它（指共识模块）与其他服务器上的共识模块进行通信，以确保每台服务器上最终以相同的顺序包含相同的命令，即使部分服务器崩溃了，这个条件也可以满足。一旦命令被正确复制，每台服务器上的状态机就会按日志顺序处理它们，并将输出返回给客户端。这样就形成了高可用的复制状态机。</p><p>适用于实际系统的共识算法通常都包含以下几点特征：</p><ul><li><p>它们确保在所有非拜占庭错误下的安全性，也就是从不返回一个错误的结果。（即使是网络延迟、分区、数据包丢失、数据包重复和数据包乱序）</p><blockquote><p><strong><ahref="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">拜占庭错误</a>：</strong></p><p>出现故障（crash 或fail-stop，即不响应）但不会伪造信息的情况称为“非拜占庭错误”。</p><p>伪造信息恶意响应的情况称为“拜占庭错误”，对应节点称为拜占庭节点。</p></blockquote></li><li><p>只要任何大多数（过半）服务器是可运行的，并且可以互相通信和与客户端通信，那么共识算法就可用。假设服务器崩溃了，一小段时间后，它们很可能会根据已经稳定存储的状态来进行恢复，并重新加入集群。</p></li><li><p>它们在保证日志一致性上不依赖于时序：错误的时钟和极端消息延迟在最坏的情况下会产生影响可用性的一系列问题。</p></li><li><p>在通常情况下，只要集群中大部分（过半）服务器已经响应了单轮远程过程调用（RPC），命令就可以被视为完成。少数（一半以下）慢服务器不会影响整个系统的性能。</p></li></ul><h2 id="paxos-存在的问题">3. Paxos 存在的问题</h2><p>在过去的十年间，Leslie Lamport 的 Paxos 协议 [15]几乎成为共识性（consensus）的同义词。它是课堂上被教授最多的共识协议，大多数共识性的实现也是以它为起点。Paxos首先定义了能在单个决策问题（例如单个复制日志条目）上达成共识的协议。我们将这个子集称为<em>signle-degree Paxos</em>。然后 Paxos组合该协议的多个实例去实现一系列决策，比如日志（<em>mutil-Paxos</em>）。Paxos保证了安全性和活性，它也支持改变集群中的成员，它的安全性也已经被论证了，并且大多数情况下都是高效的。</p><p>美中不足的是，Paxos 有两个严重的缺点：</p><ol type="1"><li><p><strong>Paxos 非常难理解</strong></p><p>众所周知，Paxos非常晦涩难懂，除非下了很大的功夫，很少有人能够成功理解它。因此，尽管目前已经有几个尝试希望将Paxos [16,20,21] 解释得通俗易懂一些，而且这些解释都集中在<code>single-decree Paxos</code>，但是它们还是很难懂。</p><p>在对 NSDI 2012 参会者的非正式调查中，我们发现很少人会喜欢Paxos，即使是经验丰富的研究人员。我们自己也一直在跟 Paxos作斗争，我们也无法完全理解整个 Paxos协议，直到阅读了几个更简单的描述和自己设计了替代 Paxos 的协议，我们才对Paxos 有了比较深刻的理解。但这个过程，花了将近一年。</p><p>我们推测 Paxos 这么晦涩难懂，主要是因为作者选择了<code>Single-decree Paxos</code>来作为基础。<code>Single-decree Paxso</code>非常搞人：它分为两个阶段，但是并没有对这两个阶段进行简单直观的说明，而且这两个阶段也不能分开了单独理解，所以使用者将就很难理解为什么该算法能起作用。<code>Multi-Paxos</code>的合成规则又增加了许多复杂性。我们相信，对多个决定（日志，并非单个日志条目）达成共识的总体问题可以用其他更直接和更明显的方式进行分解。</p></li><li><p><strong>Paxos 没有为实际实现提供一个良好的基础</strong></p><p>其中一个原因是没有广泛认同的针对 <code>Multi-Paxos</code>的算法。Lamport 的描述主要是针对 <code>signle-decree Paxos</code>的，他描述了针对 <code>multi-Paxos</code>的可能方法，但缺少了很多细节。</p><p>目前已经有人在尝试具体化和优化 Paxos，比如 [26]，[39] 和[13]，但是这些尝试都互不相同并且它们跟 Lamport 描述的也不尽相同。虽然像Chubby [4] 这样的系统已经实现了类Paxos（Paxos-like）算法，但是他们并没有透露出很多的实现细节。</p></li></ol><p>此外，Paxos 的架构对于构建实际系统来说其实是一个糟糕的设计，这是<code>single-decree Paxos</code>分解的另一个结果。举个例子，这对于独立选择地日志条目的集合，然后再将它们合并到顺序日志当中没有任何好处，这只会增加复杂性。围绕日志来设计系统是更加简单和高效的方法，其中新条目按受约束的顺序依次附加。另外一个问题是Paxos在其核心使用了<strong>对称对等方法</strong>（尽管它最终表明了这会被用作一种性能优化的弱领导模式）。这在只有一个决策的情况下是有意义的，但是尽管如此，还是很少有实际系统采用了这种方法。如果有一系列的决策需要制定，更简单和更快速的方法应该是首先选择一个leader，然后由 leader 去协调这些决策。</p><p>因此，按照 Paxos 来实现的实际系统往往跟 Paxos相差很大。几乎所有的实现都是从 Paxos开始，然后在实现的过程中发现了一系列的难题，在解决难题的过程中，开发出了跟Paxos 完全不一样的架构。这样既费时又容易出错，而且 Paxos本身的晦涩难懂又使得问题变得更加严重。Paxos公式可能是证明其正确性的一个很好的公式，但真正的实现与 Paxos又相差很大，这证明了它其实没有什么价值。下面来自 Chubby作者的评论非常典型：</p><blockquote><p>在 Paxos 算法描述和现实实现系统之间有着巨大的鸿沟... （如果一直按照Paxos 算法走下去），最终的系统往往会建立在一个还未被证明的协议之上。</p></blockquote><p>综合上述问题，我们觉得 Paxos在教学端和系统构建端都没有提供一个良好的基础。考虑到共识性在大规模软件系统中的重要性，我们决定去尝试一下看看能不能设计一个替代Paxos 并且具有更好特性的共识算法。Raft 就是这次实验的结果。</p><h2 id="为可理解性而设计">4. 为可理解性而设计</h2><p>在设计 Raft 算法过程中我们有几个目标：</p><ul><li>它必须为系统构建提供一个完整且实际的基础，这样才能大大减少开发者的工作</li><li>它必须在任何情况下都是安全的并且在典型的应用条件下是可用的，并且在正常情况下是高效的</li></ul><p>但是我们最重要的目标，也是我们遇到的最大的挑战：</p><ul><li>它必须具有易理解性，它必须保证能够被大多数人轻松地理解。而且它必须能够让人形成直观的认识，这样系统构建者才能在实现过程中对它进行不可避免的拓展。</li></ul><p>在设计 Raft算法的过程中，很多情况下我们需要在多个备选方案下做出抉择。在这种情况下，我们往往会基于可理解性来进行抉择：</p><ul><li>解释各个备选方案的难度有多大？例如，它的状态空间有多复杂？它是否具有难以理解的含义？</li><li>对于一个读者来说，完成理解这个方案和方案中的各种含义是否简单？</li></ul><p>我们意识到这一的分析具有高度的主观性。所以我们采取了两种通用的措施来解决这个问题。</p><ol type="1"><li>第一个措施就是众所周知的问题分解：只要有可能，我们就将问题划分成几个相对独立地解决、解释和理解的子问题。例如，Raft算法被我们划分成 leader 选举、日志复制、安全性和成员变更几个部分。</li><li>第二个措施是通过减少状态的数量来简化状态空间，尽可能地使系统变得更加连贯和尽可能地消除不确定性。很明显的一个例子就是，所有的日志都是不允许有空挡的，并且Raft限制了日志之间可能不一样的方式。尽管在大多数情况下我们都极力去消除不确定性，但是在某些情况下不确定性却可以提高可理解性。一个重要的例子就是随机化方法，它们虽然引入了不确定性，但是它们往往能够通过以类似的方式处理所有可能的选择来减少状态空间（随便选，没关系）。所有我们使用了随机化来简化Raft 中的 leader election 算法。</li></ol><h2 id="raft-共识算法">5. Raft 共识算法</h2><p>Raft 是一种用来管理第 2 节中提到的复制日志（replicatedlog）的算法。图 2 是该算法的浓缩，可以作为参考。图 3列举了该算法的一些关键特性。这两张图中的内容将会在后面的各个章节中逐一介绍。</p><p>Raft 在实现共识算法的过程中，首先选举一个 distinguishedleader，然后由该 leader 全权负责复制日志的一致性。Leader从客户端接收日志条目，然后将这些日志条目复制给其他服务器，并且在保证安全性的情况下通知其他服务器将日志条目应用到他们的状态机中。拥有一个leader 大大简化了对复制日志的管理流程。例如，leader可以在不跟其他服务器商议的情况下决定新的日志条目应该存放在日志的什么位置，并且数据都是从leader 流向其他服务器。当然了，一个 leader可能会崩溃，也可能与其他服务器断开连接，那么这个时候，Raft就会选举出一个新的 leader 出来。</p><p>通过选举一个 leader 的方式，Raft将共识问题分解成三个独立的子问题，这些问题将会在接下来的子章节中进行讨论：</p><ul><li><p><strong>Leader election（领导选举）</strong></p><p>一个 leader 倒下之后，一定会有一个新的 leader 站起来。</p></li><li><p><strong>Log replication（日志复制）</strong></p><p>leader必须接收来自客户端的日志条目然后复制到集群中的其他节点，并且强制其他节点的日志和自己的保持一致。</p></li><li><p><strong>Safety（安全性）</strong></p><p>Raft 中安全性的关键是图 3中状态机的安全性：只要有任何服务器节点将一个特定的日志条目应用到它的状态机中，那么其他服务器节点就不能在同一个日志索引位置上存储另外一条不同的指令。第5.4 节将会描述 Raft 如何保证这种特性，而且该解决方案在 5.2节描述的选举机制上还增加了额外的限制。</p></li></ul><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsar1v5rklj32300pc4bj.jpg"alt="image-20210709155333989" /><figcaption aria-hidden="true">image-20210709155333989</figcaption></figure><p>在展示了 Raft共识算法后，本章节将讨论可用性的一些问题以及时序在系统中的所用。</p><h3 id="raft-基础">5.1 Raft 基础</h3><p>一个 Raft 集群中包含若干个服务器节点，<font color="green"><strong>5个一个比较典型的数字，5 个服务器的集群可以容忍 2个节点的失效</strong></font>。在任何一个时刻，集群中的每一个节点都只可能是以下是三种身份之一：</p><ul><li>leader：它会处理所有来自客户端的请求（如果一个客户端和 follower通信，follower 会将请求重定向到 leader 上）</li><li>follower：它们被动的：它们不会发送任何请求，只是简单的响应来自leader 和 candidate 的请求</li><li>candidate：这是用来选举一个新的 leader的时候出现的一种临时状态，这将在第 5.2 节中详细描述</li></ul><p>在正常情况下，集群中只有一个 leader，然后剩下的节点都是 follower。图4展示了这些状态和它们之间的转换关系，这些转换关系将会在接下来进行讨论。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsap8d6ijjj322s0l47g5.jpg"alt="image-20210709145034498" /><figcaption aria-hidden="true">image-20210709145034498</figcaption></figure><p>如图 5 所示，Raft将时间划分成任意长度的任期（term）。每一段任期从一次选举开始，在这个时候会有一个或者多个candidate 尝试去成为 leader。如果某一个 candidate赢得了选举，那么它就会在任期剩下的时间里承担一个 leader的角色。在某些情况下，一次选举无法选出 leader，这个时候这个任期会以没有leader而结束。同时一个新的任期（包含一次新的选举）会很快重新开始。这是因为Raft 会保证在任意一个任期内，至多有一个 leader。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsapcmhhi4j31ym0ig78s.jpg"alt="image-20210709145441879" /><figcaption aria-hidden="true">image-20210709145441879</figcaption></figure><p>集群中不同的服务器观察到的任期转换的次数也许是不同的，在某些情况下，一个节点可能没有观察到leader 选举过程甚至是整个任期过程。</p><p>任期在 Raft 中还扮演着一个逻辑时钟（logicalclock）的角色，这使得服务器可以发现一些过期的信息，比如过时的leader。</p><p>每一个节点都存储着一个当前任期号（current termnumber），该任期号会随着时间<strong>单调递增</strong>。节点之间通信的时候会交换当前任期号，如果一个节点的当前任期号比其他节点小，那么它就将自己的任期号更新为较大的那个值。如果一个candidate 或者 leader 发现自己的任期号过期了，它就会立刻回到 follower状态。如果一个节点接收了一个带着过期的任期号的请求，那么它会拒绝这次请求。</p><p>Raft 算法中服务器节点之间采用 RPC进行通信，一般的共识算法都只需要两种类型的 RPC。</p><ul><li><strong>RequestVote RPCs（请求投票）</strong>：由 candidate在选举过程中发出（5.2 节中描述）</li><li><strong>AppendEntries RPCs（追加条目）</strong>：由 leader发出，用来做日志复制和提供心跳机制（5.3 节中描述）。</li></ul><p>在第 7 节中为了在节点之间传输快照（snapshot）增加了第三种RPC。当节点没有及时的收到 RPC的响应时，会进行重试，而且节点之间都是以并行（parallel）的方式发送 RPC请求，以此来获得最佳的性能。</p><h3 id="leader-election">5.2 Leader election</h3><p>Raft 采用一种心跳机制来触发 leader选举。当服务器启动的时候，他们都会称为 follower。一个服务器节点只要从candidate 或者 leader 那接收到有效的 RPC 就一直保持 follower的状态。Leader 会周期性地向所有的 follower 发起心跳来维持自己的 leader地位，所谓心跳，就是不包含日志条目的 AppendEntries RPC。如果一个follower 在一段时间内没有收到任何信息（这段时间我们称为<strong>选举超时election timeout</strong>），那么它就会假定目前集群中没有一个可用的leader，然后开启一次选举来选择一个新的 leader。</p><p>开始进行选举的时候，一个 follower 会自增当前任期号然后切换为candidate 状态。然后它会给自己投票，同时以并行的方式发送一个 RequestVoteRPCs 给集群中的其他服务器节点（企图得到它们的投票）。一个 candidate会一直保持当前状态直到以下的三件事之一发生（这些情况都会在下面的章节里分别讨论）：</p><ul><li>它赢得选举，成为了 leader</li><li>其他节点赢得了选择，那么它会变成 follower</li><li>一段时间之后没有任何节点在选举中胜出</li></ul><p>当一个 candidate获取集群中过半服务器节点针对同一任期的投票时，它就赢得了这次选举并成为新的leader。对于同一个任期，每一个服务器节点会按照<strong>先来先服务原则（first-come-first-served）</strong> 只投给一个candidate（在5.4节会在投票上增加额外的限制）。这种要求获得过半投票才能成为 leader的规则确保了最多只有一个 candidate 赢得此次选举（图 3中的选举安全性）。只要有一个 candidate 赢得选举，它就会成为leader。然后它就会向集群中其他节点发送心跳消息来确定自己的地位并阻止新的选举。</p><p>一个 candidate在等待其他节点给它投票的时候，它也有可能接收到另外一个自称为 leader的节点给它发过来的 AppendEntries RPC。</p><ul><li>如果这个 leader 的任期号（这个任期号会在这次 RPC中携带着）不小于这个 candidate 的当前任期号，那么这个 candidate就会觉得这个 leader 是合法的，然后将自己转变为 follower 状态。</li><li>如果这个 leader 的任期号小于这个 candidate 的当前任期号，那么这个candidate 就会拒绝这次 RPC，然后继续保持 candidate 状态。</li></ul><p>第三种可能的结果是 candidate既没有赢得选举也没有输。可以设想一下这么一个情况。所有的 follower同时变成 candidate，然后它们都将票投给自己，那这样就没有 candidate能得到超过半数的投票了，投票无果。当这种情况发生的时候，每个 candidate都会进行一次超时响应（timeout），然后通过自增任期号来开启一轮新的选举，并启动另一轮的 RequestVoteRPCs。然而，如果没有额外的措施，这种无结果的投票可能会无限重复下去。</p><p>为了解决上述问题，Raft 采用 <strong>随机选举超时时间（randomizedelection timeouts）</strong>来确保很少发生无果的投票，并且就算发生了也能很快地解决。<strong>为了防止选票一开始就被瓜分，选举超时时间是从一个固定的区间（比如，150-300ms）中随机选择。这样可以把服务器分散开来以确保在大多数情况下会只有一个服务器率先结束超时，那么这个时候，它就可以赢得选举并在其他服务器结束超时之前发送心跳</strong>（译者注：乘虚而入，不讲武德）。</p><p>同样的机制也可以被用来解决选票被瓜分（split votes）的情况。每个candidate在开始一轮选举之前会重置一个随机选举超时时间，然后一直等待直到结束超时状态。这样减少了在一次投票无果后再一次投票无果的可能性。9.3节展示了该方案能够快速地选出一个 leader。</p><p>选举的例子可以很好地展现可理解性是如何指导我们在多种备选设计方案中做出抉择的。在一开始，我们本打算使用一种等级系统（ranksystem）：每一个 candidate 被赋予一个一次的等级（rank），如果一个candidate 发现另外一个 candidate 有着更高的登记，那么它就会返回 follower状态，这样可以使高等级的 candidate更加容易地赢得下一轮选举。但是我们发现这种方法在可用性方面会有一些小问题：<strong>如果等级较高的服务器崩溃了，那么等级较低的服务器可能需要进入超时状态，然后重新成为一个candidate。如果这种操作出现得太快，那么它可能会重启进程去开启一轮新的选举。</strong>经过我们对该算法做出了多次的调整，我们最终还是认为随机重试的方法更加通俗易懂。</p><h3 id="log-replication">5.3 Log replication</h3><p>Leader一旦被选举出来，它就要开始为客户端的请求提供服务了。每一个客户端请求都包含一条将被复制状态机执行的命令。leader会以一个新条目的方式将该命令追加到自己的日志中，并且以同步的方式向集群中的其他节点发起AppendEntiresRPCs，让它们复制该条目。当条目被安全地复制（何为安全复制，后面会介绍）之后，leader会将该条目应用到自己的状态机中，状态机执行该指令，然后把执行的结果返回给客户端。如果follower 崩溃了或者运行缓慢，或者网络丢包，leader 会不断地重试AppendEntiries RPCs（即使已经对客户端作出了响应）直到所有的 follower都成功存储了所有的日志条目。</p><p>日志以图 6 展示的方式组织着。每条日志条目都存储着一条状态机指令和leader收到该指定时的任期号。日志条目中的任期号可以用来检测多个日志副本之间是否不一致，以此来保证图3中的某些性质。每个日志条目还有一个整数索引值来表明它在日志中的位置。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsasp7ss8gj32220ssjy9.jpg"alt="image-20210709165036190" /><figcaption aria-hidden="true">image-20210709165036190</figcaption></figure><p>那么问题就来了，<strong>leader什么时候会觉得把日志条目应用到状态机是安全的呢？</strong>这种日志条目被称为已提交的日志条目。Raft保证这种已提交的日志条目都是持久化的并且最终都会被所有可用的状态机执行。<strong>一旦创建该日志条目的 leader 将它复制到过半的节点上时（比如图 6中的条目 7），该日志条目就会被提交。</strong> 同时，leader日志中该日志条目之前的所有日志条目也都会被提交，包括由之前的其他 leader创建的日志条目。5.4 节会讨论在 leader变更之后应用该规则的一些细节，并证明这种提交的规则是安全的。leader会追踪它所知道的要提交的最高索引，并将该索引包含在未来的 AppendEntriesRPC 中（包括心跳），以便其他的节点可以发现这个索引。一旦一个 follower知道了一个日志条目被提交了。它就会将该日志条目按日志顺序应用到自己的状态机中。</p><p>我们设计 Raft日志机制来使得不同节点上的日志之间可以保持高水平的一致性。这么做不仅简化了系统的行为也使得系统更加可预测，同时该机制也是保证安全性的重要组成部分。Raft会一直维护着以下的特性，这些特性也同时构成了图 3 中的日志匹配特性（LogMatching Property）：</p><ul><li>如果不同日志中的两个条目有着相同的索引和任期值，那么它们就存储着相同的命令</li><li>如果不同日志中的两个条目有着相同的索引和任期值，那么他们之前的所有日志条目也都相同</li></ul><p>第一条特性源于这样一个事实，在给定的一个任期值和给定的一个日志索引中，一个leader最多创建一个日志条目，而且日志条目永远不会改变它们在日志中的位置。</p><p>第二条特性是由 AppendEntries RPC执行的一个简单的一致性检查所保证的。当 leader 发送一个 AppendEntries RPC的时候，leader会将前一个日志条目的索引位置和任期号包含在里面（紧邻最新的日志条目）。如果一个follower在它的日志中找不到包含相同索引位置和任期号的条目，那么它就会拒绝该新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性（LogMatchingProperty）的，然后一致性检查保证了日志扩展时的日志匹配特性。因此，当AppendEntries RPC 返回成功时，leader 就知道 follower的日志一定和自己相同（从第一个日志条目到最新条目）。</p><p>正常操作期间，leader 和 follower 的日志都是保持一致的，所以AppendEntries 的一致性检查从来不会失败。但是，如果 leader崩溃了，那么就有可能会造成日志处于不一致的状态，比如说老的 leader可能还没有完全复制它日志中的所有条目它就崩溃了。这些不一致的情况会在一系列的leader 和 follower 崩溃的情况下加剧。图 7 解释了什么情况下 follower的日志可能和新的 leader 的日志不同。follower 可能会确实一些在新 leader中有的日志条目，也有可能拥有一些新的 leader没有的日志条目，或者同时存在。缺失或多出日志条目的情况有可能会涉及到多个任期。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gse5vxj5sfj31se0u017c.jpg"alt="image-20210712144330139" /><figcaption aria-hidden="true">image-20210712144330139</figcaption></figure><p>在 Raft 算法中，leader 通过强制 follower 复制 leader日志来解决日志不一致的问题。也就是说，follower 中跟 leader冲突的日志条目会被 leader 的日志条目所覆盖。5.4节会证明通过增加一个限制，这种方式就可以保证安全性。</p><p>为了使 follower 的日志跟自己（leader）一致，leader必须找到两者达成一致的最大的日志条目索引，删除 follower日志中从那个索引之后的所有日志条目，并且将自己那个索引之后的所有日志条目发送给follower。所有的这些操作都发生在 AppendEntries RPCs的一致性检查的回复中。leader 维护着一个针对每一个 follower 的<strong>nextIndex</strong>，这个 nextIndex 代表的就是 leader 要发送给follower 的下一个日志条目的索引。<strong>当选出一个新的 leader 时，该leader 将所有的 nextIndex 的值都初始化为自己最后一个日志条目的 index 加1（图7 中的 11）</strong>。如果一个 follower 的日志跟 leader的是不一致的，那么下一次的 AppendEntries RPC的一致性检查就会失败。<strong>AppendEntries RPC 在被 follower拒绝之后，leader 对 nextIndex 进行减 1，然后重试 AppendEntries RPC。最终nextIndex 会在某个位置满足 leader 和 follower在该位置及之前的日志是一致的，此时，AppendEntries RPC 就会成功，将follower 跟 leader 冲突的日志条目全部删除然后追加 leader中的日志条目（需要的话）</strong>。一旦 AppendEntries RPC 成功，follower的日志就和 leader 的一致了，并且在该任期接下来的时间里都保持一致。</p><blockquote><p>如果需要的话，下面的协议可以用来优化被拒绝的 AppendEntries RPCs的个数。</p><p>比如说，当拒绝一个 AppendEntries RPC 的时候，follower可以包含冲突条目的任期号和自己存储的那个任期的第一个index。借助这些信息，leader 可以跳过那个任期内所有的日志条目来减少indexIndex。这样就变成了每个有冲突日志条目的任期只需要一个 AppendEntriesRPC，而不是每一个日志条目都需要一次 AppendEntires RPC。</p><p>在实践中，我们认为这种优化是没有必要的，因为失败不经常发生并且也不可能有很多不一致的日志条目。</p></blockquote><p>通过上述机制，leader在当权之后就不需要任何特殊的操作来使日志恢复到一致状态。leader只需进行正常的操作，然后日志就能在回复 AppendEntries RPC一致性检查的时候自动趋于一致。leader从来不会重写或者删除自己的日志条目（图3 中的 Leader Append-Only属性）。</p><p>上述这种日志复制机制展现了第 2 节中描述的 Raft算法的共识特性：只要过半的节点能正常运行，Raft就能接受、复制并处理新的日志条目。在通常情况下，一个新的条目可以在一轮RPC 中被复制给集群中过半的节点，并且单个运行缓慢的 follower并不会影响整个集群的性能。</p><blockquote><p>译者注：<strong>总结</strong></p><p>Leader 收到 Client 的写请求，向所有 Follower发起一个日志同步请求，得到集群内过半节点（包括 Leader自己）的响应，就推进 commitIndex，然后 apply 日志到状态机，再推进applyIndex，返回 Client 成功。</p><p>状态机同步分为两轮 RPC 广播：</p><ul><li>第一轮：同步日志 AppendEntries，得到过半节点回复，Leader状态机推进，返回 Client 成功。</li><li>第二轮：在下一次的 AppendEntries 中附带上一次的commitIndex，Follower 收到后，apply 日志条目到各自的状态机。</li></ul></blockquote><h3 id="safety">5.4 Safety</h3><p>前面的章节描述了 Raft 如何做 Leader Election 和 LogReplication。然而，到目前为止所讨论的机制并不能充分地保证每一个状态机会按相同的顺序执行相同的指令。比如说，一个follower 可能会进入不可用状态，在此期间，leader可能提交了若干的日志条目，然后这个 follower 可能被选举为新的 leader并且用新的日志条目去覆盖这些日志条目。这样就会造成不同的状态机执行不同的指令的情况。</p><p>本节通过对 Leader Election 增加一个限制来完善 Raft算法。这个限制保证了对于给定的任意任期号，该任期号对应的 leader都包含了之前各个任期所有被提交的日志条目（图3 中的 Leader Completeness性质）。有了这个限制，我们也可以使日志提交规则更加清晰。最后，我们会展示对于Leader Completeness性质的简要证明并且说该性质是如何保证状态机执行正确的行为的。</p><h4 id="选举限制">5.4.1 选举限制</h4><p>在任何基于 leader 的共识算法中，leader最终都必须存储所有已经提交的日志条目。在某些共识算法中，例如 ViewstampedReplication[22]，即使一个节点它一开始并没有包含所有已经提交的日志条目，它也有可能被选举为leader。这些算法包含一些额外的机制来识别丢失的日志条目并将它们传送给新的leader，这个机制要么发生在选举阶段，要么在选举完成之后很快进行。比较遗憾的是，这种方法会增加许多额外的机制，使得算法复杂性大大增加。Raft使用了一种更加简单的方法，它可以保证新 leader在当选时就包含了之前所有任期中已经提交的日志条目，根本就不需要再传送这些日志条目给新的leader。这就意味着<strong>日志条目的传送只有一个方向，那就是从 leader 到follower，leader 从来不会覆盖本地日志中已有的日志。</strong></p><p>Raft 采用投票的方式来保证一个 candidate只有拥有之前所有任期中已经提交的日志条目之后，才有可能赢得选举。一个candidate 如果想要被选为leader，那它就必须跟集群中超过半数的节点进行通信，这就意味这些节点中至少一个包含了所有已经提交的日志条目。如果candidate的日志至少跟过半的服务器节点一样新，那么它就一定包含了所有以及提交的日志条目，一旦有投票者自己的日志比candidate 的还新，那么这个投票者就会拒绝该投票，该 candidate也就不会赢得选举。</p><blockquote><p>所谓 “<strong>新</strong>” ：</p><p>Raft通过比较两份日志中的最后一条日志条目的索引和任期号来定义谁的日志更新。</p><ul><li>如果两份日志最后条目的任期号不同，那么任期号大的日志更新</li><li>如果两份日志最后条目的任期号相同，那么谁的日志更长，谁就更新</li></ul></blockquote><h4 id="提交之前任期内的日志条目">5.4.2 提交之前任期内的日志条目</h4><blockquote><p>译者注：注意！这一节「提交之前任期内的日志条目」这种操作 Raft的不允许的！本小节只是用来举一种错误情况！</p></blockquote><p>如 5.3节中提到的那样，一旦当前任期内的某个日志条目以及存储到过半的服务器节点上，leader就知道该日志可以被提交了。如果这个 leader在提交某个日志条目之前崩溃了，以后的 leader会尝试完成该日志条目的复制。然而，如果是之前任期内的某个日志条目已经存储到了过半的服务器节点上了，新任期内的leader 也无法立即断定该日志条目已经被提交了。图 8展示了一种情况：一个已经被存储到过半节点的老日志条目，仍然有可能会被未来的leader 覆盖掉。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gse88t4iicj31wc0u0ts1.jpg"alt="image-20210712160506841" /><figcaption aria-hidden="true">image-20210712160506841</figcaption></figure><blockquote><p>译者注：<strong>对图 8 的理解的补充</strong>。</p><p><font color="orange">参考：</font></p><ul><li><a href="https://zhuanlan.zhihu.com/p/369989974">知乎</a></li></ul><p><font color="orange">核心：</font></p><ul><li><strong>图 8 用来说明为什么 leader不能提交之前任期的日志，只能通过提交自己任期的日志，从而间接提交之前任期的日志。</strong></li></ul><p><font color="orange">分析：</font></p><ol type="1"><li>先按错误的情况，也就是 leader 提交之前任期的日志，那么上述的流程：<ol type="1"><li><ol type="a"><li>S1 是任期 2 的 leader，日志已经复制给了 S2，此时还没过半；</li></ol></li><li><ol start="2" type="a"><li>S1 崩溃，S5 获得了 S3、S4、S5 的投票成为leader，然后写了一个日志条目（index=2，term=3）；</li></ol></li><li><ol start="3" type="a"><li>S5 刚写完日志，还没来得及复制，就崩溃了，此时 S1 和 S2都可能当选，加入 S1 当选（currentTerm=4），此刻还没有新的请求进来，S1将日志条目（index=2，term=2）复制给了 S3，多数派达成，S1提交了这个日志条目（index=2，term=2），<strong>注意，该日志不是当前任期内的日志，我们在讨论错误的情况！</strong>然后请求进来，S1 写日志条目（index=3，term=4），然后 S1 崩溃。</li></ol></li><li>情况一：(d) S5 重启，因为 S5 最后的日志条目的任期号比 S2、S3大，所以 S5 可以赢得选举（currentTerm=5），S5将日志条目（index=2，item=3）复制给其他所有节点并提交， <strong>此时index=2 的日志条目被提交了两次！一次term=2，一次term=3，这是不被允许的，因为已经提交的日志条目是不能被覆盖的！</strong>✖️</li><li>情况二：(e) S1在崩溃之前将自己的日志条目（index=3，term=4）复制到了过半节点上，这种情况下，S5不可能选举成功。这是 S1 不发生故障，这是正确复制的情况。✔️</li></ol></li></ol><p>所以 <strong>「leader 可以提交之前任期的日志」</strong>这种操作是不允许的，我们需要加上约束： <strong>「leader只能提交自己任期的日志」</strong> 。</p><ol start="2" type="1"><li><p>加了约束之后，前面的 (a) 和 (b) 没有改变，从 (c) 开始：</p><ol type="1"><li><ol start="3" type="a"><li>S1 还是将日志条目（index=2，term=2）复制给其他节点，它复制给了S3，此时已经复制给了过半的节点了，但是<strong>由于 currentTerm=4，所以S1 还是不能提交该日志条目</strong>。如果 S1将日志条目（index=3，term=4）也复制给了过半的节点，S1是可以提交该日志条目的，那么这个时候，前面的日志条目（index=2，term=2）也会被间接提交，这就是(e) 所展示的情况。</li></ol></li><li><ol start="4" type="a"><li>S1 还是将日志条目（index=2，term=2）复制给其他节点，它复制给了S3，此时已经复制给了过半的节点了，但是<strong>由于 currentTerm=4，所以S1 还是不能提交该日志条目</strong>。但是这个时候，S1只是日志条目（index=3，term=4）写入自己的日志，还没来得及复制就崩溃了。然后S5重启并赢得了选举（currentTerm=5），然后将日志条目（index=2，term=3）复制给其他所有节点，现在index=2 的日志条目是没有提交过的，S5 能提交该日志吗？</li></ol><strong>不能！因为 leader不能提交之前任期的日志！只有等新的请求进来，超过半数节点复制了 1-3-5之后，term=3 的日志才能跟着 term=5 的日志一起被提交。</strong></li></ol></li></ol><p><font color="orange">延伸：</font></p><p>加了上述约束后，就不会出现同一个 index上的日志条目被重复提交的情况了，但是这又多出了另外一个问题了：<strong>如果一直没有新的请求进来，那么日志条目（index=2，term=3）岂不是就一直不能提交？那不就阻塞了吗？</strong></p><p>这里如果是 kv 数据库，问题就很明显了。假设 (c) 或 (d)中的日志条目（index=2）里的 Command 是 <code>Set("k", "1")</code>，S5当选 leader 后，客户端来查询 <code>Get("k")</code>，leader查到日志有记录但又不能回复 1给客户端（因为按照约束这条日志未提交），线性一致性要求不能返回陈旧的数据，leader迫切地需要知道这条日志到底能不能提交。</p><p>所以 Raft 论文提高了引入 <strong>no-op日志</strong>来解决这个问题，这个在 etcd 中有实现。</p><p><font color="orange">no-op 日志：</font></p><p>no-op 日志即只有 index 和 term 信息，command信息为空。也是要写到磁盘存储的。</p><p>具体流程是<strong>在 leader 刚选举成功的时候，立即追加一条 no-op日志，并立即复制到其它节点，no-op 日志一经提交，leader前面那些未提交的日志全部间接提交，问题就解决了。像上面的 kv 数据库，有了no-op 日志之后，Leader 就能快速响应客户端查询了。</strong></p><p>本质上，no-op 日志使 leader隐式地快速提交之前任期未提交的日志，确认当前<code>commitIndex</code>，这样系统才会快速对外正常工作。</p></blockquote><p>为了解决图 8 中描述的问题，Raft永远不会通过计算副本数目的方式来提交之前任期内的日志条目。只有 leader当期内的日志条目才通过计算副本数目的方式来提交。一旦当前任期内的某个日志条目以这种方式被提交（如图8 中的 e），那么由于日志匹配特性（LogMatching），之前的所有日志条目也会被间接地提交。在某些情况下，leader可以安全地断定一个老的日志条目已经被提交（例如，如果该条目已经被存储到每一个节点上了）。但是Raft 为了简化问题，采取了上述描述的更加保守的方法。</p><p>Raft 会在提交规则上增加额外的复杂性是因为当 leader复制之前任期内的日志条目时，这些日志条目都保留原来的任期号。在其他的共识算法中，如果一个新的leader 要重新复制之前任期里的日志时，它必须使用当前新的任期号。Raft的做法使得更加容易推导出日志条目，因为它们自始至终都使用同一个任期号。另外，和其他的算法相比，Raft中的新 leader只需要发送更少的日志条目（其他算法中必须在它们被提交之前发送更多的冗余日志条目来给它们重新编号）。</p><h4 id="安全性论证">5.4.3 安全性论证</h4><p>给出了完整的 Raft 算法后，我们现在可以更严格地来论证 leader完整性特性（Leader Completeness Property）（这一讨论基于 9.2节的安全性证明）。我们先假设 Leader Completeness Property是不满足的，然后再推出矛盾来。</p><p><strong>假设：</strong></p><p>假设任期 T 的 leader<sub>T</sub>在任期内提交了一个日志条目，但是该日志条目没有存在未来某些任期的 leader中，假设 U 是大于 T 的没有存储该日志条目的最小任期号，处在任期 U 的leader 称为 leader<sub>U</sub>。</p><p><strong>论证：</strong></p><ol type="1"><li><p>因为 leader从来不删除或重写自己的日志条目，所以如果一个已提交的日志要做到不存在未来的leader<sub>U</sub> 中的话，那么它只可能在 leader<sub>U</sub>选举的过程中被丢失。</p></li><li><p>leader<sub>T</sub>将该日志复制给了集群中过半的节点，leader<sub>U</sub>从集群中过半的节点得到了投票。因此，至少有一个节点（这里称它为voter）同时接收了来自 leader<sub>T</sub> 的日志条目并且给leader<sub>U</sub> 投票了。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsfipd3u1tj322c0j2wju.jpg"alt="image-20210713185232381" /><figcaption aria-hidden="true">image-20210713185232381</figcaption></figure></li><li><p>voter 必然在给 leader<sub>U</sub>投票之前就已经接收了这个已经提交的日志条目了。否则，它就会拒绝来自leader<sub>T</sub> 的 AppendEntries RPC 请求，因为如果它在给leader<sub>U</sub> 投票之后再接收条目的话，那么它的当前任期号会比 T大。</p><blockquote><p>译者注：因为要举行 Leader election的话需要开一轮新的任期，这个时候前一轮任期已经结束了。我们这里假设了 T&lt; U，上述所说的已提交日志条目是在任期 T 中的，如果 voter先投票的话，那么就说明它已经进入了任期 U 了，而 U &gt; T，voter是不可能接受 leader<sub>T</sub> 的 AppendEntries 请求的。</p></blockquote></li><li><p>而且，voter 在给 leader<sub>U</sub>投票的时候，它依旧保有该日志条目，因为任何 U、T 之间的 leader都包含该日志条目（因为我们前面假设了 U 是大于 T的没有存储该日志条目的最小任期号），而且 leader 从来不会删除条目，并且follower 只有再跟 leader 冲突的时候才会删除条目。</p></li><li><p>该投票者把自己的选票投给 leader<sub>U</sub>的时候，leader<sub>U</sub> 的日志至少跟 voter一样新（可以更新），这就导致了以下的两个矛盾之一了。</p></li><li><p><strong>第一个矛盾：</strong></p><p><strong>如果 voter 和 leader<sub>U</sub>最后一个日志条目的任期号相同的话，那么 leader<sub>U</sub> 的日志至少和voter 的一样长，所以 leader<sub>U</sub> 的日志一定包含 voter日志中的所有日志条目。 这是一个矛盾，因为 voter包含了该已提交的日志条目，所以 leader<sub>U</sub>必定也包含该日志条目，而前面我们假设了 leader<sub>U</sub>是不包含的，这就产生了矛盾。</strong></p></li><li><p><strong>第二个矛盾：</strong></p><p><strong>如果不是上面描述的情况的话，那么 leader<sub>U</sub>最后一个日志条目的任期号必然需要比 voter 的更大。此外，它还比 T要大，因为 voter 拥有在任期号为 T 提交的日志条目，所以 voter最后一个日志条目的任期号至少为 T。创建了 leader<sub>U</sub>的最后一个日志条目的之前的 leader一定已经包含了该已被提交的日志条目（因为我们上面假设了leader<sub>U</sub> 是第一个没有该日志条目的leader）。所以，根据日志匹配特性，leader<sub>U</sub>一定也包含了该已被提交的日志条目，这样也产生了矛盾</strong>。</p></li><li><p>上述讨论就证明了假设是不成立的。因此，所有比 T 大的任期的 leader一定包含了任期 T 中提交的所有日志条目。</p></li><li><p>日志匹配特性保证了未来的 leader也会包含被间接提交的日志条目，如图 8 (d) 中的索引 2。</p></li></ol><p>通过 leader 的完整性特性，我们就可以证明图 3中的状态机安全特性了，即如果某个节点已经将某个给定的索引处的日志条目应用到自己的状态机里了，那么其他的节点就不会在相同的索引处应用一个不同的日志条目。在一个节点应用一个日志条目到自己的状态机中时，它的日志和leader的日志从开始到该日志条目都是相同的，并且该日志条目必须被提交。现在考虑一个最小的任期号，在该任期中任意节点应用了一个给定的最小索引上面的日志条目，那么Log 的完整性特性就会保证该任期之后的所有 leader将存储相同的日志条目，因此在后面的任期中应用该索引上的日志条目的节点会应用相同的值。所以，状态机安全特性是可以得到保证的。</p><p>最后，因为 Raft要求服务器节点按照日志索引顺序应用日志条目，再加上状态机安全特性，这样就意味着我们可以保证所有的服务器都会按照相同的顺序应用相同的日志条目到自己的状态机中了。</p><h3 id="follower-和-candidate-崩溃">5.5 follower 和 candidate 崩溃</h3><p>到目前为止，我们只关注了 leader 崩溃的情况。follower 和 candidate崩溃后的处理方式要比 leader崩溃简单得多，而且它们的处理方式是相同的。如果一个 follower 或者candidate 崩溃的话，后面发送给它们的 RequestVote 和 AppendEntries RPCs都会失败。Raft通过无限重试来处理这种失败。如果崩溃的节点重启了，那么这些 RPC就会被成功地完成。如果一个节点在完成了一个RPC，但是还没来得及响应就崩溃了的话，那么在它重启之后它会再次收到同样的请求。Raft的 RPCs 都是幂等的，所以重复发送相同的 RPCs不会对系统造成危害。实际情况下，一个 follower 如果接收了一个AppendEntries请求，但是这个请求里面的这些日志条目在它日志中已经有了，它就会直接忽略这个新的请求中的这些日志条目。</p><blockquote><p>译者注：<strong>幂等</strong></p><p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现。</p></blockquote><h3 id="时序和可用性">5.6 时序和可用性</h3><p>Raft 中有一个要求就是 Raft的安全性不能依赖于时序（timing）：整个系统不能因为某些事件运行得比预期快一点或者慢一点就产生错误的结果。然而，可用性（即系统能够及时响应客户端的请求）不可避免的要依赖于时序。比如说，如果信息交换的时间比一般服务器崩溃所持续的时间还要长的话，那么candidate 可能等不到赢得选举了，而缺少了一个稳定的 leader，Raft将无法工作。</p><p>Raft 中时序最关键的地方就是 Leaderelection。只要整个系统满足下面的时间要求，Raft就可以选举并维持一个稳定的 leader：</p><blockquote><p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout）&lt;&lt; 平均故障间隔时间（MTBF）</p></blockquote><p>在这个不等式中，广播时间指的是一个节点并行地发送 RPCs给集群中其他所有的节点并得到响应的平均时间。选举超时时间就是在 5.2节中介绍的选举超时时间。平均故障间隔时间就是对于一台服务器而言，两次故障间隔时间的平均值。广播时间必须选举超时时间小一个量级，这样leader 才能够有效发送心跳信息来组织 follower进入选举状态。再加上随机化选举超时时间的方法，这个不等式也使得无果选票（splitvote）变得几乎不可能。而选举超时时间需要比平均故障间隔时间小上几个数量级，这样整个系统才可以稳定地运行。有了这个限制后，当leader崩溃后，整个系统会有一段大约选举超时时间的时长不可用，我们希望该情况在整个系统运行时间里只占一小部分。</p><p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们可以自定义的。Raft的 RPCs 需要接收方将信息持久化地保存到稳定存储中，所以广播时间大约是0.5ms ~ 20ms 之间，取决于存储的技术。因此，选举超时时间可能需要在 10ms ~500ms之间。而大多数的服务器的平均故障间隔时间都在几个月甚至更长，所以很容易满足时间的要求。</p><h2 id="集群成员变更">6. 集群成员变更</h2><p>到目前为止，我们都假设集群的配置（参与共识算法的服务器节点集合）是固定不变的。但是在实际情况中，我们有时候是需要去改变集群配置的，比如说在服务器崩溃的时候去更换服务器或者是更改副本的数量。尽管可以通过下线整个集群，更新所有配置，然后重启整个集群的方式来实现这个需求，但是这会导致集群在更改过程中是不可用的。另外，如果这个过程中存在一些操作需要人工干预，那么就会有操作失误的风险。为了避免这些问题，我们决定将配置变更自动化并将其纳入到Raft 的共识算法中来。</p><p>为了使配置变更机制足够安全，在配置变更过程中不能存在任何一个时刻使得同一任期中选出两个leader。遗憾的是，任何服务器直接从旧的配置转换为新的配置的方案都是不安全的。一次性自动地转换所有服务器的配置的不可能的，所以在转换期间整个集群可能划分为两个独立的大多数（如图10 所示）。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsgq3skl4gj322c0nwaes.jpg"alt="image-20210714195412552" /><figcaption aria-hidden="true">image-20210714195412552</figcaption></figure><blockquote><p>译者注：图 10 补充</p><p>上图中，在中间位置 Server1 可以通过自身和 Server2 的选票成为leader（满足旧配置下收到大多数选票的原则）；Server3 可以通过自身和Server4、Server5 的选票成为 leader（满足新配置线，即集群有 5个节点的情况下的收到大多数选票的原则）；此时整个集群可能在同一任期中出现了两个leader，这和 Raft 协议是违背的。</p></blockquote><p>为了保证安全性，配置变更必须采取一种两段式方法。目前有很多种两段式的实现。例如，有些系统（如[22]）在第一阶段停掉旧的配置，所以在这个阶段不能处理用户的请求，然后在第二阶段启用新的配置。在Raft 中，集群先切换到一个过渡的配置，我们称之为 <strong>联合共识（jointconsensus）</strong>。一旦联合共识配置已经被提交了，系统就可以切换到新的配置上了。<strong>联合共识配置是新旧配置的并集</strong>：</p><ul><li>日志条目被复制给集群中处于新、老配置的所有节点</li><li>新、旧配置的节点都可能成为 leader</li><li>达成一致（针对选举和提交）需要分别得到在两种配置上过半的支持</li></ul><p>联合共识允许每一个节点在不妥协安全性的前提下，在不同的时刻进行配置转换过程。此外，联合共识还允许在集群配置变更期间响应客户端的请求。</p><p>集群配置在复制日志中以特殊的日志条目来存储和通信。图 11展示了配置变更的过程。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsgpnv9f98j32060p6agz.jpg"alt="image-20210714193852320" /><figcaption aria-hidden="true">image-20210714193852320</figcaption></figure><p>当 leader接收到一个更新配置的请求的时候，它就创建一个联合共识日志条目C<sub>old,new</sub>，并以前面描述的方式复制该条目。<strong>一旦某个节点将该配置日志条目增加到自己的日志中。那么这个节点就会用该配置来做出未来的所有决策（一个节点总是使用日志中最新的配置，无论该日志是否已经被提交）。</strong>这就意味着 leader 会使用 C<sub>old,new</sub> 的规则来判断C<sub>old,new</sub> 日志条目是什么时候被提交的。如果 leader 崩溃了，新的leader 有可能处于 C<sub>old</sub> 配置，也可能处于 C<sub>old,new</sub>配置，这取决于赢得选举的 candidate 是否已经接收到了 C<sub>old,new</sub>配置。在任何情况下，处于 C<sub>new</sub>状态的节点在此期间都是不能单独做出决定的。</p><p>当 C<sub>old,new</sub> 被提交了，那么 C<sub>old</sub> 和C<sub>new</sub> 都不能在没有得到对方认可的情况下做出决定，并且 Leade完整特性（Leader Completeness Property）保证了只有拥有C<sub>old,new</sub> 日志的 candidate 有可能被选为 leader。所以现在leader 就可以安全地创建一个描述 C<sub>new</sub>的日志条目并将其复制给集群中的其他节点了。一样的，新的配置被节点收到后就会立刻生效。当新的配置在C<sub>new</sub>的规则下被提交了之后，旧配置就变得无关紧要了，处于旧配置的节点也可以关闭了。如图11 所示，没有任何一个时刻 C<sub>old</sub> 和 C<sub>new</sub>是可以单独做决定的，这保证了安全性。</p><p>关于配置变更有三个问题需要解决：</p><ul><li><p>第一个问题：新的节点可能在一开始并没有存储任何的日志条目。当这些节点以这种状态加入到集群中的时候，它们需要一段时间来更新自己的日志，以便赶上其他节点，在这个时间段里面它们是不可能提交一个新的日志条目的。<strong>为了避免因此造成的系统短时间的不可用，Raft在配置变更前引入了一个额外的阶段。在该阶段中，新的节点以没有投票权身份加入到集群中来（leader会把日志复制给它们，但是考虑过半的时候不需要考虑它们）。</strong>一旦新节点的日志已经赶上了集群中的其他节点，那么配置变更就可以按照之前描述的方式进行了。</p></li><li><p>第二个问题：leader 有可能不是新配置中的一员（译者注：也就是说这个leader 后面是需要被下线的）。在这种情况下，leader 一旦提交了C<sub>new</sub> 日志条目，它就会退位为follower（译者注：C<sub>old,new</sub>状态下依旧可用）。这就意味着有这样一段时间（leader 提交 C<sub>new</sub>期间）：leader管理着一个不包括自己的集群，它会复制日志给其他节点，但是算副本数量的时候不会算上自己。leader转换发生在 C<sub>new</sub>被提交的时候，因为这是新配置可以独立运行的最早时刻（在这个时刻之后，一定是从C<sub>new</sub> 中选出新的 leader）。在这个时间点之前，有可能只能从C<sub>old</sub> 中选出 leader。</p></li><li><p>第三个问题：那么被移除的节点（不处于 C<sub>new</sub>状态的节点）有可能会扰乱集群。这些节点将不会收到心跳信息，所以当选举超时时，它们就会进行新的选举过程。它们会发送带有新任期号的RequestVote RPCs，这样会导致当前的 leader 回到 follower状态，然后选出一个新的leader。但是这些被移除的节点还是会收不到心跳，然后再次超时，再次循环这个过程，导致系统的可用性很差。</p><p>为了避免这个问题，当节点认为当前有 leader 存在时，节点会忽略RequestVote RPCs。具体来说，当一个节点在最小选举超时时间内收到一个RequestVoteRPC，它不会更新它的任期或授予它的投票。这不会影响正常的选举，每个节点在开启一轮选举之前，它会至少等待一次最小选举超时时间。相反，这有利于避免被移除的节点的扰乱：如果一个leader 能够发送心跳给集群，那它就不会被更大的任期号废黜。</p></li></ul><blockquote><p>译者注：<strong>对配置变更的归纳</strong></p><ol type="1"><li><p>配置变更过程</p><ol type="1"><li><p>leader 在本地生成一个新的日志条目，其内容是 C<sub>old</sub> ∪C<sub>new</sub>，代表当前时刻新旧成员配置共存，写入本地日志，称为C<sub>old,new</sub>。后面 leader就以该日志作为自己的配置了。同时将该日志条目复制集群中是所有节点中。在此之后新的日志同步需要保证得到C<sub>old</sub> 和 C<sub>new</sub> 两个多数派的确认。</p><p>follower 收到 C<sub>old.new</sub>的日志后更新本地日志，并且此时就以该配置作为自己的成员配置。</p><p>如果 C<sub>old</sub> 和 C<sub>new</sub> 中的两个多数派确认了C<sub>old.new</sub> 这个日志条目，leader 就提交它。</p></li><li><p>接下来 leader 生成一条新的日志条目，其内容是新成员配置C<sub>new</sub>，同样将该日志条目写入本地日志，同时复制给集群中其他节点。</p><p>follower 收到新成员配置 C<sub>new</sub>后，将其写入日志，并且从此刻起，就以该配置作为自己的成员配置，并且如果发现自己不在C<sub>new</sub> 这个成员配置中会自动退出。</p><p>leader 收到 C<sub>new</sub>的多数派确认后，表示成员变更成功，后续的日志只要得到 C<sub>new</sub>多数派确认即可。</p></li></ol><p>完成上述两阶段后，leader就可以给客户端回复配置变更执行成功。</p></li><li><p>如果当前的 leader 不在 C<sub>new</sub> 的配置中会怎么样？</p><p>因为当前 leader 不在 C<sub>new</sub> 配置中，所以当 C<sub>new</sub>日志条目被提交的时候，leader 其实是要被下线的（比如说集群节点数从 5缩容为 3，且刚好下线的节点中包含当前 leader）。那这样的话，在C<sub>old,new</sub> 状态下，leader 还是可用的，但是一旦 C<sub>new</sub>日志条目被提交了，leader 就需要下线了，这个时候不用当心，因为C<sub>new</sub> 已经被复制过半了，重新选 leader 也一定是选有C<sub>new</sub> 的。</p></li><li><p>如果在配置分发过程中 leader 崩溃了怎么办？</p><p>分两种情况：</p><ol type="1"><li><p>C<sub>new</sub> 已经分发过半</p><p>集群开始重新选举，此时在 C<sub>new</sub>的规则下，不存在新配置中的节点不会赢得选举（因为他们要在C<sub>old,new</sub>的情况下决定，但是拿不到 C<sub>new</sub> 的选票），只有拿到C<sub>new</sub> 的节点可能成为 leader 并继续下发 C<sub>new</sub>配置，流程恢复。</p></li><li><p>C<sub>new</sub> 没有分发过半</p><p>这种情况下，C<sub>old,new</sub> 和 C<sub>new</sub> 的节点都可以成为leader，但是无所谓，因为无论谁成为leader，都能根据当前的配置继续完成后续流程（如果是 C<sub>new</sub>那么相当与完成了最终的配置，不在 C<sub>new</sub>的节点会因为没有心跳数据而失效）。</p></li></ol></li><li><p>旧配置节点下线造成的问题</p><p>Raft 的处理方式：当节点确信有 leader 存在时，不会进行投票（在 leader超时之前收到新的投票请求时不会提升任期号和做出投票）。且开始选举之前等待一个选举超时时间，这样在新leader 正常工作的情况下，不会受到旧节点的影响。</p><p>旧配置节点在发起选举前需要等待一段时间，那么这段时间新 leader可以发送心跳，这样就减少了影响。 对正常流程的影响不大。（leader失效后要等一段时间，没有及时触发，然而本身这里就有一个判断失效的时间，好像影响不大；比如原先超时时间是10s，那么如果设置成 5s，原策略下 10s 超时就是 10s 后开始选举，新策略下5s 超时就是超时后再等 5s 再开始选举，影响就是超时时间变短）</p></li><li><p>无数据的新节点加入集群中的问题</p><p>新加入的节点需要时间复制数据，在这个过程完成之前，Raft采用以下机制来保证可用性： 新加入节点没有投票权（ leader复制日志给他们，但计算已复制日志条目的副本数的时候不考虑它们），直到这些节点的日志追上其他节点。</p></li><li><p>如果在配置变更过程中接收到用户请求的话，是用旧配置响应还是用新配置响应？</p><p><strong>按照笔者的理解，这个方面，对 Raft协议的具体实现可以根据自身需求来自定义实现，Raft的联合共识是为了避免同一时刻出现了 2 个leader，避免了对客户端的一个请求同时有两个不同的响应出现。而在具体实现中，在某个阶段，究竟是采取新配置响应还是旧配置响应，可以再斟酌。</strong></p><p>比如说可以这样：</p><ol type="1"><li>C<sub>old</sub> 阶段：使用旧配置，需要过半旧配置节点确认</li><li>C<sub>new</sub> 已提交阶段：使用新配置，需要过半新配置节点确认</li><li>C<sub>old,new</sub>阶段：配置信息中有节点数量（这样才可能判断是否过半），这个时候新旧配置都需要过半节点确认，而响应新配置执行的结果还是响应旧配置执行的结果，就看old 多还是 new 多，谁多用谁。</li></ol></li><li><p>如果 leader 要下线，客户端发来的新的请求如何处理？</p><ol type="1"><li>如果是在 leader 复制 C<sub>new</sub> 之后，提交 C<sub>new</sub>之前的话，leader工作在新的集群配置下，所以会将日志复制到新集群的节点下，当收到新集群（不包含leader 本身）超过半数节点确认后，就可以提交日志。</li><li>在其他阶段，leader 就是正常可用的。</li></ol></li><li><p>所谓 C<sub>new</sub> 和 C<sub>old,new</sub>日志条目，里面没有数据，只有指令，里面的指令就是让节点执行对应的配置项。</p></li></ol></blockquote><h2 id="日志压缩">7. 日志压缩</h2><p>在正常情况下，Raft的日志会随着客户端请求的增加而不断增长。但在实际系统中，日志不可能无限制地增长。随着日志越来越长，它会占用越来越多的空间，并且需要花更多的时间来重新执行日志中的日志条目。如果没有一定的机制来清除日志中积累的过期的信息，那么最终一定会影响系统的可用性。</p><p><strong>快照技术（snapshotting）</strong>是日志压缩最简单的方法。在快照技术中，某个时间点下的前整个系统的状态都会以快照的形式持久化起来，然后该时间点之前的日志会被全部丢弃。快照技术呗使用在Chubby 和 ZooKeeper 当中，接下来的章节会介绍 Raft 中的快照技术。</p><p><strong>增量压缩方法（Incremental approach tocompaction）</strong>，例如<strong>日志清洗（log cleaning）</strong>[36]和<strong>日志结构合并树（log-structured merge trees）</strong>[30,5]，都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，选择一个积累了大量被删除或被覆盖的对象的数据区域，然后重写该区域内还活着的对象，之后释放该区域。和快照技术相比，这需要大量额外的机制，并且增加了更多的复杂性，快照技术通过操作整个数据集来简化问题。虽然日志清理需要对Raft 进行修改，但是状态机可以使用与快照技术相同的接口来实现LSM（日志结构合并） 树。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gshvublij8j321s0lsadj.jpg"alt="image-20210715195808192" /><figcaption aria-hidden="true">image-20210715195808192</figcaption></figure><p>图 12 展示了 Raft快照技术的基本思想。每一个节点独立地生成快照，快照中只包含自己日志中已经被提交的条目，这个过程主要的工作是状态机将自己的状态写入快照中。Raft在快照中还保留了少量的元数据：</p><ul><li>last includedindex：指的是最后一个被快照取代的日志条目的索引值（状态机最后应用的日志条目）</li><li>last included term：指的是该条目所处的任期号</li></ul><p>保留这些元数据是为了支持快照后第一个条目的 AppendEntries一致性检查，因为该条目需要一个之前的日志索引和任期号。为了支持集群成员变更（第6 节中讨论的），快照中还包含日志中到 last included index为止的最新的配置。一旦节点完成了快照的写入，它可能就会删除 last includedindex 及之前的所有日志条目，以及之前的快照。</p><p>尽管通常情况下，节点都是独立生成快照的，但是 leader不可避免偶尔需要发送快照给一些落后的 follower。这通常发生在 leader已经丢弃了需要发给 follower的下一条日志条目的时候。幸运的是，这种情况在正常操作中是不会出现的：一个与leader 保持同步的 follower 通常都会拥有该日志条目。不过如果一个 follower运行比较缓慢，或者是它刚加入集群，那么它就可能会没有该日志条目。这个时候leader 会通过网络将该快照发送给该 follower，以使得该 follower可以更新到最新的状态。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gshxf2bjwej31gg0u0k01.jpg"alt="image-20210715205247442" /><figcaption aria-hidden="true">image-20210715205247442</figcaption></figure><p>这个时候 leader 使用了一种新的 RPC 来发送快照给那些太落后的followers，如图 13 所示，这种 RPC 叫做<strong>InstallSnapshot</strong>。当一个 follower 通过这种 RPC收到快照的时候，它必须决定如何处理当前已经存在的日志条目。通常情况下，这份快照会包含接受者日志者没有的信息。所以这种情况下follower会丢弃它的整个日志，它的日志会全部被快照取代，并且可能有与快照冲突的未提交的条目。相反，如果一个follower收到一个描述其日志前缀的快照（可能是由于重传或错误），则被快照覆盖的日志条目将被删除，但是快照之后的条目仍然有效，且必须要保留。</p><p>这种快照的方式违反了 Raft 的 strong leader 原则，因为 follower可能在不知道 leader的情况下创建快照。但是我们认为这种违背是合乎情理的。leader的存在，是为了防止在达成共识的时候产生冲突，但是在创建快照的时候，共识已经达成了，因此没有决策会出现冲突。这种情况下，数据还是跟之前一样，只能从leader 流向 follower，只不过现在允许 follower可以重新组织它们的数组而已。</p><p>我们曾经考虑过一种可替代的方案，那就是只有 leader可以创建快照，然后由 leader 将这份快照发送给其他所有的follower。但是，这种方案有两个缺点：</p><ol type="1"><li>发送快照给每个 follower会浪费网络带宽和延缓了快照处理过程。实际上每一个 follower已经拥有了创建自己快照所需要的全部信息了，所以很显然，follower根据本地的状态创建快照要比通过网络来接收别人发过来的要更加实惠。</li><li>这会造成 leader 的实现更加复杂。比如说，leader 发送快照给 follower的同时要能够做到并行地将新的日志条目发送给它们，这样才不会阻塞新的客户端请求，这就复杂得多了。</li></ol><p>还有两个问题会影响快照的性能：</p><ol type="1"><li><p>每一个节点必须判断何时去生成快照。如果一个节点生成快照的频率太高，那么就会浪费大量的磁盘带宽和其他资源；如果一个节点生成快照的频率太低，那么就要承担耗尽存储容量的风险，同时也增加了重启时重新执行日志的时间。</p><p>一个简单的策略就是当日志大小达到一个固定的阈值的时候就生成一份快照。如果这个阈值设置得显著大于期望的快照的大小，那么快照的磁盘带宽开销将较小。</p></li><li><p>第二个影响性能的就是写快照需要花费一定的时间，而我们又不希望它会影响到正常的操作。</p><p>解决方案就是使用 <strong>写时复制的技术（copy-on-write）</strong>，这样新的更新就可以在不影响正在写的快照的情况下被接收。例如，具有泛型函数结构的状态机天然支持这样的功能。另外，操作系统对写时复制技术的支持（如Linux 上的fork）可以被用来创建整个状态机的内存快照（我们的实现用的就是这种方法）。</p></li></ol><h2 id="客户端交互">8. 客户端交互</h2><p>本节介绍客户端如何和 Raft 进行交互，包括客户端如何找到 leader 和 Raft是如何支持线性化语义的[10]。这些问题对于所有的基于共识算法的系统都是存在的，Raft的解决方案也跟其他的系统差不多。</p><p>Raft 的客户端们将所有的请求发送给leader。当客户端第一次启动的时候，它会随机挑选一个节点来进行通信。如果客户端首选的不是leader，那么被客户端选中的节点就会拒绝客户端的请求并且提供关于它最近收到的leader 的信息（AppendEntries RPC 包含了 leader 的网络地址）。如果 leader崩溃了，客户端请求就会超时，这个时候客户端需要随机选择一个节点来重试发送请求。</p><p>我们对 Raft的期许是希望它可以实现线性化语义（即每次操作看起来似乎都是在调用和响应之间的某个点上即时执行一次）。但是，按照上面描述的，Raft可能会对同一条指令执行多次。例如，如果 leader在提交了某个日志条目后，在还没来得及响应客户端的时候就崩溃了，那么客户端会和新的leader重试该指令，这就造成了同一指令被执行了两次。解决方案是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每个客户端已经处理的最新的序列号以及相关联的响应。如果状态机接收到了一条已经执行过的指令了，就立即作出响应，并且不会重复执行该指令。</p><p>只读操作（Read-Only）可以直接处理而不记录日志。但是，如果不采取任何措施的话，这可能会有返回过期数据（staledata）的风险。<strong>因为 leader 响应客户端请求的时候它可能已经被新的leader 代替了，但是它还不知道自己已经不是最新的 leader 了。</strong></p><blockquote><p>译者补充：<strong>为什么一个 leader 好好的会有另外一个 leader出现？</strong></p><p>参考：https://segmentfault.com/a/1190000039264427</p><p>实际上，老的 leader 可能不会马上消失，例如：网络分区将 leader与集群的其余部分分隔，其余部分选举出了一个新的 leader。然后老的 leader崩溃后重新连接，可能会不知道新的 leader 已经被选出来了。</p></blockquote><p>线性化的操作肯定不会返回过期的数据。Raft需要使用两个额外的预防措施来在不适用日志的时候保证这一点。</p><ol type="1"><li><p>leader 必须拥有那些已提交的日志条目的最新信息。Leader完整性特性（Leader Completeness Property）保证了 leader一定拥有所有已被提交的日志条目，但是在它任期刚开始的时候，它可能还不知道哪些是已经被提交的。为了知道这些信息，它需要在它的任期里提交一个日志条目。</p><p><strong>Raft 通过让 leader在任期开始的时候提交一个空的日志条目到日志中来解决该问题</strong>。（译者注：这就是前面5.4.2 节提到的 no-op 日志）</p></li><li><p>leader在处理只读请求的时候必须检查自己是否已经被替代了（因为如果一个新 leader被选出来了，那么这个旧 leader 的数据可能就过时了）。</p><p>Raft 通过让 leader在响应只读请求之前，先和集群中过半的节点交换一次心跳信息来解决该问题。</p><p>另一种可选的方案，leader 可以依赖心跳机制来实现一种租约的形式[9]，但是这种方式的安全性需要依赖于时序（假设时间误差是有界的）。</p></li></ol><h2 id="算法实现与评估">9. 算法实现与评估</h2><p>我们已经实现了 Raft 作为复制状态机的一部分，该状态机存储了 RAMCloud[33] 的配置信息，并帮助 RAMCloud 协调器进行故障转移。这个 Raft实现大概包含了 2000+ 行 C++代码，但是这里面没有包含测试、注释和空行。这些代码是开源的[23]。同时也有大约 25个其他独立的第三方、针对不同的开发场景、基于这篇论文草稿的开源实现。同时，很多公司已经部署了基于Raft 算法的系统了。</p><p>本节剩下的篇幅将从三个方面来评估 Raft 算法：</p><ul><li>可理解性</li><li>正确性</li><li>性能</li></ul><h3 id="可理解性">9.1 可理解性</h3><p>为了衡量 Raft 相对于 Paxos的可理解性，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一项实验研究。我们为Raft 和 Paxos 分别录制了一个视频教程，并且准备了相应的小测验。其中 Raft课程覆盖了本篇论文除了日志压缩之外的全部内容，而 Paxos课程涵盖了创建一个与 Raft 等价的复制状态机的全部资料，包括 signle-decreePaxos、multi-decree Paxos、重新配置和一切实际系统需要的性能优化（比如leader选举）。这个小测验主要是测试一些对算法的理解和解释一些边缘情况。每个学生都是看完第一个视频，然后做对应的测验，然后再看第二个视频，再做第二份测验。为了解释个人表现与从第一部分研究中获得的经验差异的原因，大约有一半的学生先进行Paxos 的部分，然后另一半学生先进行 Raft的部分。我们通过计算参与人员的每一份测验的得分来看参与者是否更加容易理解Raft 算法。</p><p>我们尽可能的使得在比较 Raft 和 Paxos过程中是公平的。这个实验从两个方面偏向了 Paxos：</p><ol type="1"><li>43 个参与者中有 15 个人在之前有一些 Paxos 的经验</li><li>Paxos 视频教程的时长要长 14%</li></ol><p>如表格 1总结的那样，我们采取了一些措施来减轻这种潜在的偏向。我们所有的材料都可供审查[28, 31]。</p><table style="width:100%;"><thead><tr class="header"><th>关注点</th><th>缓和偏向采取的手段</th><th>可供查看的材料</th></tr></thead><tbody><tr class="odd"><td>相同的讲课质量</td><td>两份教程采用同一个讲师。Paxos的教程是在现有的一些大学使用的材料基础上改进的。Paxos 的教程要长14%。</td><td>视频</td></tr><tr class="even"><td>相同的测验难度</td><td>问题以难度分组，在两个测验里成对出现。</td><td>小测验</td></tr><tr class="odd"><td>公平评分</td><td>使用评价量规。随机顺序打分，两个测验交替进行。</td><td>评分细则</td></tr></tbody></table><center>表格1：考虑到潜在的实验偏向，我们对于每种情况的解决方法，以及相应的材料。</center><p>平均上看，参与者在 Raft 测验上的得分要比在 Paxos 测验上的得分高处 4.9分（在 60 分中，Raft 的平均得分是 25.7 分，Paxos 的平均得分是 20.8分）。图 14 展示了每个参与者的得分。配对 t 检验（paired t-test）表明，在95% 的置信度下，Raft 分数的真实分布的平均值至少要比 Paxos 的大 2.5分。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsixtffkroj32220my76y.jpg"alt="image-20210716175208106" /><figcaption aria-hidden="true">image-20210716175208106</figcaption></figure><p>我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，这个模型基于以下三点：</p><ol type="1"><li>他们使用的是哪个测验</li><li>之前对于 Paxos 的经验</li><li>学习算法的顺序</li></ol><p>该模型预测，对小测验的选择会产生 12.5 分的有利于 Raft的差别，这很明显高于观察到的 4.9分的分差。这是因为实际上许多的学生之前有学习过 Paxos，这对 Paxos的有很大帮助的，但是对 Raft的帮助就较小了。但是奇怪的是，模型预测对于先进行 Paxos小测验的人而言，Raft 的得分低了 6.3分。虽然我们不知道这是为什么，但是这似乎在统计上是有意义的。</p><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsiz66oe4yj323m0jgdj0.jpg"alt="image-20210716183850084" /><figcaption aria-hidden="true">image-20210716183850084</figcaption></figure><p>我们同时也在测验之后对参与者进行了调查，调查的内容是他们认为哪个算法更容易去实现或解释。这些调查结果展示在图15。调查结果是碾压性的，结果表明 Raft 算法更加容易实现和解释（41 人中的33个）。然而，这种自我报告的感觉可能没有参与者的测试分数来得可靠，而且参与者可能由于我们假设Raft 更容易理解而存在偏向。</p><p>在参考文献 [33] 中有一个关于 Raft 用户学习的更加详细的讨论。</p><h3 id="正确性">9.2 正确性</h3><p>在第 5节中，我们已经对共识机制制定了正式的规范并且对其安全性做了证明。这份正式的规范使用TLA+ 规范语言 [17] 使图 2 中对算法的总结的信息非常清晰。它差不多有 400行并且作为了我们要证明的核心。同时这份规范对于任何想实现 Raft的人都是十分有用的。我们用 TLA 证明系统 [7] 机械地证明了日志完整性（LogCompletenessProperty）。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明规范中的类型安全）。而且，我们已经编写了状态机安全特性的非正式证明[31]，它是完整的（它仅依赖于规范）和相对精确的（大约 3500 字长）。</p><h3 id="性能">9.3 性能</h3><p>Raft 的性能跟其他像 Paxos的共识算法很接近。在性能方面，最重要的关注点就是，当一个 leader被选举出来后，它要在什么时候复制新的日志条目。Raft通过很少量的消息包（一轮从 leader到集群中过半节点的的消息传递）就解决了这个问题。同时，进一步提升 Raft的性能也是有可能的。比如说，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他共识算法已经提出过很多性能优化方案，其中很多都可以应用到Raft 上，但是我们暂时把这些工作放到未来的工作中。</p><p>我们使用我们自己的 Raft 实现来衡量 Raft 的 leader election算法的性能并且回答两个问题：</p><ol type="1"><li>leader 选举过程收敛是否足够快？</li><li>在 leader 崩溃之后，最小的系统崩溃时间是多久？</li></ol><figure><imgsrc="https://hedonspace.oss-cn-beijing.aliyuncs.com/img2/008i3skNly1gsj0yuh34ej61km0u043r02.jpg"alt="image-20210716194110554" /><figcaption aria-hidden="true">image-20210716194110554</figcaption></figure><p>为了衡量 leader election 的性能，我们反复使一个拥有 5 个节点的集群的leader 宕机，并计算它检测崩溃和重新选一个新的 leader 所需的时间（见图16）。为了构建一个最坏的情景，我们使各个节点中的日志长度都是不同的，这样某些candidate 是无法成为 leader 的。而已，为了尽可能出现无结果的投票（splitvote）情况，我们的测试脚本在终止 leader 的进程之前从 leader那触发了一个同步的发送了一次心跳广播（类似于 leader在崩溃前复制一个日志条目给其他节点）。leader在其心跳间隔内均匀随机地崩溃，这个心跳间隔也是所有测试中最小选举超时时长的一半。因此，<strong>最小宕机时间大约就是最小选举超时时间的一半</strong>。</p><p>图 16中上面的图表明，只需要在选举超时时间上使用很小的随机化就可以大大避免出现没有结果的投票的情况。在没有随机化的情况下（译者注：见图16中上面的图右边的橙色虚线），由于出现了很多没有结果的投票的情况，leaderelection 往往都需要花费超过 10s 的时间。仅仅加入 5ms的随机化时间，就大大改善了选举过程，现在平均的宕机时间只有287ms。继续增大随机性可以大大改善最坏的情况：通过增加 50ms的随机化时间，最坏的完成情况（即完成 1000 次实验）只需要 513 ms。</p><p>图 16中下面的图表明，通过减少选举超时时间可以禁烧系统的宕机时间。在选举超时时间为12~24ms 的情况下，只需要平均 35ms 就可以选举出新的leader（最长的一次花费了152ms）。然而，进一步降低选举超时时间可能就会违反 Raft不等式的要求。</p><blockquote><p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout）&lt;&lt; 平均故障间隔时间（MTBF）</p></blockquote><p>因为这会使得在其他节点开启一轮新的选举之前，当前的 leader要完成发送一次心跳广播变得很难。这会造成不必要的 leader更换，从而降低了系统的可用性。我们推荐使用一个更为保守的选举超时时间，比如150~300ms。这样的时间不大可能导致不必要的 leader更换，同时还能提供不错的可用性。</p><h2 id="相关工作">10. 相关工作</h2><p>现在已经有很多关于共识算法相关的产物了，其中很多都属于以下类别之一：</p><ul><li>Lamport 对于 Paxos 的最初的描述 [15]，以及尝试将 Paxos解释地更清晰的描述 [16, 20, 21 ]。</li><li>关于 Paxos的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础[26, 39, 13]。</li><li>实现共识算法的系统，例如 Chubby [2, 4]，ZooKeeper [11, 12] 和Spanner [6]。对于 Chubby 和 Spanner的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper的算法细节已经发表，但是和 Paxos 着实有着很大的差别。</li><li>对于 Paxos 的性能优化 [18, 19, 3, 25, 1, 27]。</li><li>Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos差不多的替代算法。原始的算法描述 [29]和分布式传输协议耦合在了一起，但是核心的共识算法在最近更新的版本 [22]里被分离了出来。VR 使用了一种基于 leader 的方法，和 Raft有很多相似之处。</li></ul><p>Raft 和 Paxos 最大的不同就在于 Raft 的<strong>强领导性（strongleadership）</strong>。Raft 将 leader election作为共识协议中非常重要的一环，并且将尽可能多的功能集中到了 leader身上。这种方法使得算法更加简单和更容易理解。比如说，在 Paxos 中，leaderelection和基本的共识协议是正交的：它只是作为一种性能优化，而不是实现共识所必需的。然而，这带来了很多额外的机制：</p><ul><li>Paxos 中包含了一个两段式的基本共识协议</li><li>Paxos 中还包含了一个单独的 leader election 机制</li></ul><p>相比之下，Raft 将 leader election直接纳入了共识算法并且将其作为共识两阶段中的第一个阶段，这使得 Raft使用的机制要比 Paxos 少得多。</p><p>像 Raft 一样，VR 和 ZooKeeper 也是基于 leader 的，因此他们也拥有一些Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制。因为 Raft尽可能的减少了非 leader 者的功能。例如，Raft 中日志条目都遵循着从 leader发送给 follower 这一个方向：AppendEntries RPCs 是向外发送的。在 VR中，日志条目的流动是双向的（leader人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像Raft。</p><p>跟我们上述提到的其他基于共识性的日志复制算法相比，Raft的消息类型更少。例如，我们计算了一下 VR 和 ZooKeeper用来实现基本功能和集群成员变更（不包括日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）所需要的消息类型。VR和 ZooKeeper 都分别定义了 10 种不同的消息类型。相比之下，Raft 只有 4种消息类型（两种 RPC Request 及其对应的两种 RPC Response）。Raft的消息的消息量比其他算法的要大一点，但总的来说，它们更加简单。另外，VR和 ZooKeeper 都在 leader改变的时候传输了整个日志，所以这些算法为了能在实践中使用，就不得不增加额外的消息类型了。</p><p>Raft 的强 leader模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义Paxos （EPaxos）在某些没有 leader 的情况下可以达到很高的性能[27]。平等主义 Paxos充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos在服务器之间的负载均衡做的很好，并且很容易在 WAN网络环境下获得很低的延迟。但是，他在 Paxos上增加了非常明显的复杂性。</p><p>一些集群成员变更的方法已经被提出或者在其他的工作中被实现，包括Lamport 的原始的讨论 [15]，VR [22] 和 SMART[24]。我们选择使用联合共识的方法是因为它利用了共识协议的其余部分，这样我们只需要很少的一些机制就可以实现成员变更。Lamport的基于 α 的方法之所以没有被 Raft 选择是因为它假设在没有 leader的情况下也可以达到共识性。和 VR 和 SMART 相比较，Raft的重新配置算法可以在不限制正常请求处理的情况下进行。相比之下，VR在配置变更期间需要停止所有正常的处理过程，而 SMART对未完成请求的数量实施了类似 α 方法的限制。另外，和 VR、SMART 相比，Raft的方法也只需要增加更少的额外机制来实现。</p><h2 id="结论">11. 结论</h2><p>算法的设计通常以正确性、效率和简洁性为主要目标。虽然这些都是有价值的目标，但我们相信可理解性同样重要。在开发人员将算法转化为实际实现之前，其他任何目标都不能实现，而实际实现将不可避免地偏离和扩展发布的形式。除非开发人员对算法有深刻的理解，并能对算法有直观的认识，否则他们很难在实现中保留算法理想的特性。</p><p>在本文中，我们讨论了分布式共识的问题，在这个问题上，一个被广泛接受但难以理解的算法：Paxos，多年来一直让学生和开发人员非常挣扎。我们开发了一种新的算法：Raft，我们已经证明它比Paxos 更容易理解。我们也相信 Raft会为系统建设提供更好的基础。将可理解性作为主要设计目标改变了我们处理Raft设计的方式。随着设计的进展，我们发现自己反复使用了一些技术，比如分解问题和简化状态空间。这些技术不仅提高了Raft 的可理解性，而且使我们更容易证实它的正确性。</p><h2 id="致谢">12. 致谢</h2><p>这项研究必须感谢以下人员的支持：Ali Ghodsi，David Mazie`res，和伯克利CS 294-91 课程、斯坦福 CS 240课程的学生，没有他们的大力支持，这项研究是不可能完成的。Scott Klemmer帮我们设计了用户调查，Nelson Ray建议我们进行统计学的分析。在用户调查时使用的关于 Paxos的幻灯片很大一部分是从 Lorenzo Alvisi的幻灯片上借鉴过来的。特别的，非常感谢 DavidMazieres 和 EzraHoch，他们找到了 Raft中一些难以发现的漏洞。许多人提供了关于这篇论文十分有用的反馈和用户调查材料，包括Ed Bugnion，Michael Chan，Hugues Evrard，Daniel Giffin，ArjunGopalan，Jon Howell，Vimalkumar Jeyakumar，Ankita Kejriwal，AleksandarKracun，Amit Levy，Joel Martin，Satoshi Matsushita，Oleg Pesok，DavidRamos，Robbert van Renesse，Mendel Rosenblum，Nicolas Schiper，DeianStefan，Andrew Stone，Ryan Stutsman，David Terei，Stephen Yang，MateiZaharia 以及 24位匿名的会议审查人员（可能有重复），并且特别感谢我们的领导人 EddieKohler。Werner Vogels 发了一条早期草稿链接的推特，给 Raft带来了极大的关注。我们的工作由 Gigascale 系统研究中心和 Multiscale系统研究中心给予支持，这两个研究中心由关注中心研究程序资金支持，一个是半导体研究公司的程序，由STARnet 支持，一个半导体研究公司的程序由 MARCO 和 DARPA支持，在国家科学基金会的 0963859 号批准，并且获得了来自Facebook，Google，Mellanox，NEC，NetApp，SAP 和 Samsung 的支持。DiegoOngaro 由 Junglee 公司，斯坦福的毕业团体支持。</p><h2 id="参考文献">参考文献</h2><p>[1] BOLOSKY, W. J., BRADSHAW, D., HAAGENS, R. B., KUSTERS, N. P., ANDLI, P. Paxos replicated state machines as the basis of ahigh-performance data store. In <em>Proc. NSDI’11, USENIX Conference onNetworked Systems Design and Implementation</em> (2011), USENIX, pp.141–154.</p><p>[2] BURROWS, M. The Chubby lock service for loosely- coupleddistributed systems. In <em>Proc. OSDI’06, Sympo- sium on OperatingSystems Design and Implementation</em> (2006), USENIX, pp. 335–350.</p><p>[3] CAMARGOS, L. J., SCHMIDT, R. M., AND PEDONE, F. MulticoordinatedPaxos. In <em>Proc. PODC’07, ACM Sym- posium on Principles ofDistributed Computing</em> (2007), ACM, pp. 316–317.</p><p>[4] CHANDRA, T. D., GRIESEMER, R., AND REDSTONE, J. Paxos made live:an engineering perspective. In <em>Proc. PODC’07, ACM Symposium onPrinciples of Distributed Computing</em> (2007), ACM, pp. 398–407.</p><p>[5] CHANG, F., DEAN, J., GHEMAWAT, S., HSIEH, W. C., WALLACH, D. A.,BURROWS, M., CHANDRA, T., FIKES, A., AND GRUBER, R. E. Bigtable: adistributed storage system for structured data. In <em>Proc. OSDI’06,USENIX Symposium on Operating Systems Design and Implementation</em>(2006), USENIX, pp. 205–218.</p><p>[6] CORBETT, J. C., DEAN, J., EPSTEIN, M., FIKES, A., FROST, C.,FURMAN, J. J., GHEMAWAT, S., GUBAREV, A., HEISER, C., HOCHSCHILD, P.,HSIEH, W., KAN- THAK, S., KOGAN, E., LI, H., LLOYD, A., MELNIK, S.,MWAURA, D., NAGLE, D., QUINLAN, S., RAO, R., ROLIG, L., SAITO, Y.,SZYMANIAK, M., TAYLOR, C., WANG, R., AND WOODFORD, D. Spanner: Google’sglobally-distributed database. In <em>Proc. OSDI’12, USENIX Conferenceon Operating Systems Design and Implemen- tation</em> (2012), USENIX,pp. 251–264.</p><p>[7] COUSINEAU, D., DOLIGEZ, D., LAMPORT, L., MERZ, S., RICKETTS, D.,AND VANZETTO, H. TLA+ proofs. In <em>Proc. FM’12, Symposium on FormalMethods</em> (2012), D. Giannakopoulou and D. Me ́ry, Eds., vol. 7436 of<em>Lec- ture Notes in Computer Science</em>, Springer, pp. 147–154.</p><p>[8] GHEMAWAT, S., GOBIOFF, H., AND LEUNG, S.-T. The Google filesystem. In <em>Proc. SOSP’03, ACM Symposium on Operating SystemsPrinciples</em> (2003), ACM, pp. 29–43.</p><p>[9] GRAY,C.,ANDCHERITON,D.Leases:Anefficientfault- tolerant mechanismfor distributed file cache consistency. In <em>Proceedings of the 12thACM Ssymposium on Operating Systems Principles</em> (1989), pp.202–210.</p><p>[10] HERLIHY, M. P., AND WING, J. M. Linearizability: a correctnesscondition for concurrent objects. <em>ACM Trans- actions on ProgrammingLanguages and Systems 12</em> (July 1990), 463–492.</p><p>[11] HUNT, P., KONAR, M., JUNQUEIRA, F. P., AND REED, B . ZooKeeper:wait-free coordination for internet-scale systems. In <em>Proc ATC’10,USENIX Annual Technical Con- ference</em> (2010), USENIX, pp.145–158.</p><p>[12] JUNQUEIRA, F. P., REED, B. C., AND SERAFINI, M. Zab:High-performance broadcast for primary-backup sys- tems. In <em>Proc.DSN’11, IEEE/IFIP Int’l Conf. on Depend- able Systems &amp;Networks</em> (2011), IEEE Computer Society, pp. 245–256.</p><p>[13] KIRSCH, J., AND AMIR, Y. Paxos for system builders. Tech. Rep.CNDS-2008-2, Johns Hopkins University, 2008.</p><p>[14] L A M P O RT, L . Time, clocks, and the ordering of events in adistributed system. <em>Commununications of the ACM 21</em>, 7 (July1978), 558–565.</p><p>[15] L A M P O RT, L . The part-time parliament. <em>ACM Transac-tions on Computer Systems 16</em>, 2 (May 1998), 133–169.</p><p>[16] LAMPORT, L. Paxos made simple. <em>ACM SIGACT News 32</em>, 4(Dec. 2001), 18–25.</p><p>[17] L A M P O RT, L . <em>Specifying Systems, The TLA+ Language andTools for Hardware and Software Engineers</em>. Addison- Wesley,2002.</p><p>[18] LAMPORT, L. Generalized consensus and Paxos. Tech. Rep.MSR-TR-2005-33, Microsoft Research, 2005.</p><p>[19] L A M P O RT, L . Fast paxos. (2006), 79–103.</p><p>[20] LAMPSON, B. W. How to build a highly available system usingconsensus. In <em>Distributed Algorithms</em>, O. Baboaglu and K.Marzullo, Eds. Springer-Verlag, 1996, pp. 1–17.</p><p>[21] LAMPSON, B. W. The ABCD’s of Paxos. In <em>Proc. PODC’01, ACMSymposium on Principles of Distributed Computing</em> (2001), ACM, pp.13–13.</p><p>[22] LISKOV, B., AND COWLING, J. Viewstamped replica- tion revisited.Tech. Rep. MIT-CSAIL-TR-2012-021, MIT, July 2012.</p><p>[23] LogCabin source code. http://github.com/ logcabin/logcabin.</p><p>[24] LORCH, J. R., ADYA, A., BOLOSKY, W. J., CHAIKEN, R., DOUCEUR, J.R., AND HOWELL, J. The SMART way to migrate replicated statefulservices. In <em>Proc. Eu- roSys’06, ACM SIGOPS/EuroSys EuropeanConference on Computer Systems</em> (2006), ACM, pp. 103–115.</p><p>[25] MAO, Y., JUNQUEIRA, F. P., AND MARZULLO, K. Mencius: buildingefficient replicated state machines for WANs. In <em>Proc. OSDI’08,USENIX Conference on Operating Systems Design and Implementation</em>(2008), USENIX, pp. 369–384.</p><p>[26] MAZIE` RES, D. Paxos made practical.http://www.scs.stanford.edu/ ̃dm/home/ papers/paxos.pdf, Jan. 2007.</p><p>[27] MORARU, I., ANDERSEN, D. G., AND KAMINSKY, M. There is moreconsensus in egalitarian parliaments. In <em>Proc. SOSP’13, ACMSymposium on Operating System Principles</em> (2013), ACM.</p><p>[28] Raft user study. http://ramcloud.stanford. edu/̃ongaro/userstudy/.</p><p>[29] OKI, B. M., AND LISKOV, B. H. Viewstamped replication: A newprimary copy method to support highly-available distributed systems. In<em>Proc. PODC’88, ACM Symposium on Principles of DistributedComputing</em> (1988), ACM, pp. 8–17.</p><p>[30] O’NEIL, P., CHENG, E., GAWLICK, D., AND ONEIL, E. Thelog-structured merge-tree (LSM-tree). <em>Acta Informat- ica 33</em>, 4(1996), 351–385.</p><p>[31] ONGARO, D. <em>Consensus: Bridging Theory and Practice</em>. PhDthesis, Stanford University, 2014 (work in progress).</p><p>[32] ONGARO, D., AND OUSTERHOUT, J. In search of an understandableconsensus algorithm. In <em>Proc ATC’14, USENIX Annual TechnicalConference</em> (2014), USENIX.</p><p>[33] OUSTERHOUT, J., AGRAWAL, P., ERICKSON, D., KOZYRAKIS, C.,LEVERICH, J., MAZIE`RES, D., MI- TRA, S., NARAYANAN, A., ONGARO, D.,PARULKAR, G., ROSENBLUM, M., RUMBLE, S. M., STRATMANN, E., AND STUTSMAN,R. The case for RAMCloud. <em>Com- munications of the ACM 54</em> (July2011), 121–130.</p><p>[34] Raft consensus algorithm website.http://raftconsensus.github.io.</p><p>[35] REED, B. Personal communications, May 17, 2013.</p><p>[36] ROSENBLUM, M., AND OUSTERHOUT, J. K. The design andimplementation of a log-structured file system. <em>ACM Trans. Comput.Syst. 10</em> (February 1992), 26–52.</p><p>[37] S C H N E I D E R , F. B . Implementing fault-tolerant servicesusing the state machine approach: a tutorial. <em>ACM Com- putingSurveys 22</em>, 4 (Dec. 1990), 299–319.</p><p>[38] SHVACHKO, K., KUANG, H., RADIA, S., AND CHANSLER, R. The Hadoopdistributed file system. In <em>Proc. MSST’10, Symposium on Mass StorageSys- tems and Technologies</em> (2010), IEEE Computer Society, pp.1–10.</p><p>[39] VAN RENESSE, R. Paxos made moderately complex. Tech. rep.,Cornell University, 2012.</p>]]></content>
    
    
    <categories>
      
      <category>论文翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>Raft</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
